
C3_Simple_socket_server.elf:     file format elf32-littlenios2
C3_Simple_socket_server.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x0d0002bc

Program Header:
    LOAD off    0x00001000 vaddr 0x09500000 paddr 0x09500000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001120 vaddr 0x0d000120 paddr 0x0d000120 align 2**12
         filesz 0x000528bc memsz 0x0005d4fc flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  09500000  09500000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000019c  0d000120  0d000120  00001120  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004a598  0d0002bc  0d0002bc  000012bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00006054  0d04a854  0d04a854  0004b854  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00002134  0d0508a8  0d0508a8  000518a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          0000ac40  0d0529dc  0d0529dc  000539dc  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  000539dc  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00001a70  00000000  00000000  00053a00  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_pubnames 00005a08  00000000  00000000  00055470  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   0008174c  00000000  00000000  0005ae78  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00011d90  00000000  00000000  000dc5c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00041d6f  00000000  00000000  000ee354  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00006840  00000000  00000000  001300c4  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00003926  00000000  00000000  00136904  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00014036  00000000  00000000  0013a22a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000050  00000000  00000000  0014e260  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000988  00000000  00000000  0014e2b0  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000006  00000000  00000000  00159765  2**0
                  CONTENTS, READONLY
 18 .cpu          00000003  00000000  00000000  0015976b  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  0015976e  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  0015976f  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  00159773  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  00159777  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  0015977b  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  00159784  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  0015978d  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000010  00000000  00000000  00159796  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 0000004f  00000000  00000000  001597a6  2**0
                  CONTENTS, READONLY
 28 .jdi          0000866e  00000000  00000000  001597f5  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
09500000 l    d  .entry	00000000 .entry
0d000120 l    d  .exceptions	00000000 .exceptions
0d0002bc l    d  .text	00000000 .text
0d04a854 l    d  .rodata	00000000 .rodata
0d0508a8 l    d  .rwdata	00000000 .rwdata
0d0529dc l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_pubnames	00000000 .debug_pubnames
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
0d000300 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 iniche_init.c
00000000 l    df *ABS*	00000000 led.c
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 simple_socket_server.c
0d0529e8 l     O .bss	00000004 SSSCommand.4583
0d052bf8 l     O .bss	000005f0 conn.4710
00000000 l    df *ABS*	00000000 tse_my_system.c
00000000 l    df *ABS*	00000000 ctype_.c
0d04ba7d l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
0d0509e0 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
0d0035d8 l     F .text	00000058 __sprint_r
0d04c41e l     O .rodata	00000010 blanks.3452
0d04c40e l     O .rodata	00000010 zeroes.3453
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 dtoa.c
0d005788 l     F .text	00000218 quorem
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 findfp.c
0d007184 l     F .text	00000058 std
0d007290 l     F .text	00000008 __fp_lock
0d007298 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 locale.c
0d052894 l     O .rwdata	00000004 charset
0d04c450 l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 mprec.c
0d04c598 l     O .rodata	0000000c p05.2458
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 refill.c
0d00a214 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
0d00b538 l     F .text	00000410 _fpadd_parts
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0d00c664 l     F .text	0000007c udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 dp-bit.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
0d00cf80 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
0d00d0a0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
0d00d1f0 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
0d0528a8 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_env_lock.c
0d0528ac l     O .rwdata	00000004 lockid
0d052a20 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
0d0528b0 l     O .rwdata	00000004 lockid
0d052a28 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
0d00edac l     F .text	00000044 OS_InitMisc
0d00edf0 l     F .text	0000006c OS_InitRdyList
0d00ef54 l     F .text	000000e0 OS_InitTCBList
0d00ecd0 l     F .text	000000dc OS_InitEventList
0d00ee5c l     F .text	0000007c OS_InitTaskIdle
0d00eed8 l     F .text	0000007c OS_InitTaskStat
0d00f1c8 l     F .text	00000070 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
0d0110e8 l     F .text	00000110 OS_FlagTaskRdy
0d010e40 l     F .text	000001c4 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0d0511f4 l     O .rwdata	000000d8 ext_flash
0d0512cc l     O .rwdata	0000106c jtag_uart
0d052338 l     O .rwdata	00000124 tristate_lcd
0d05245c l     O .rwdata	00000030 sgdma_rx
0d05248c l     O .rwdata	00000030 sgdma_tx
0d015c24 l     F .text	00000038 alt_dev_reg
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash.c
0d015cf8 l     F .text	00000038 alt_flash_device_register
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_table.c
0d016af8 l     F .text	0000007c alt_read_16bit_query_entry
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0d017bfc l     F .text	000002c4 altera_avalon_jtag_uart_irq
0d017ec0 l     F .text	00000114 altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207.c
0d05292c l     O .rwdata	00000004 colstart
0d0186d8 l     F .text	000000b8 lcd_write_command
0d018790 l     F .text	000000d4 lcd_write_data
0d018864 l     F .text	000000c4 lcd_clear_screen
0d018928 l     F .text	000001ec lcd_repaint_screen
0d018b14 l     F .text	000000c8 lcd_scroll_up
0d018bdc l     F .text	000002d0 lcd_handle_escape
0d0193dc l     F .text	000000cc alt_lcd_16207_timeout
00000000 l    df *ABS*	00000000 altera_avalon_lcd_16207_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0d019d34 l     F .text	00000060 alt_get_errno
0d01a2dc l     F .text	000000c0 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
0d01a448 l     F .text	00000070 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
0d052a82 l     O .bss	00000001 tse_system_count.4487
0d052a83 l     O .bss	00000001 is_init.4851
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
0d052a98 l     O .bss	00000004 nclosers
0d053210 l     O .bss	0000003c closers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
0d052948 l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
0d05324c l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 dhcpclnt.c
0d0276b8 l     F .text	000000cc dh_getlong
00000000 l    df *ABS*	00000000 dhcputil.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 udp_open.c
0d0293e4 l       .text	00000000 done
0d029274 l       .text	00000000 asm1
0d0293a0 l       .text	00000000 loop0
0d02929c l       .text	00000000 loop
0d0293bc l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
0d052af8 l     O .bss	00000004 kbd_init.3746
0d052b04 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
0d052b38 l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
0d02dae8 l     F .text	00000098 sockargs
0d02cd24 l     F .text	000001fc t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
0d035e1c l     F .text	000000e8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
0d038a2c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_dev.c
0d038b04 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
0d038be4 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
0d03906c l     F .text	000000c4 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_open.c
0d0391a8 l     F .text	000000dc alt_file_locked
0d03940c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_read.c
0d03958c l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
0d039b08 l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_irq.c
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_amd.c
0d03a420 l     F .text	000000bc alt_write_word_amd
0d03a2fc l     F .text	00000124 alt_wait_for_command_to_complete_amd
00000000 l    df *ABS*	00000000 altera_avalon_cfi_flash_intel.c
0d03a6d4 l     F .text	0000018c alt_unlock_block_intel
0d03a860 l     F .text	000000dc alt_write_word_intel
00000000 l    df *ABS*	00000000 allports.c
0d052b70 l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0d03add0 l     F .text	00000198 check_interval_timers
0d052b7c l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
0d052b80 l     O .bss	00000004 arp_timer
0d052b98 l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
0d0529c4 l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
0d052bc8 l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
0d0529cc l     O .rwdata	00000004 iCounter.4504
00000000 l    df *ABS*	00000000 dhcsetup.c
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
0d053264 l     O .bss	0000001e nearBuf.4182
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
0d0488ac l     F .text	00000060 alt_get_errno
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 icmp.c
0d05286c l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 calloc.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
0d04a5c4 l     F .text	00000004 register_fini
00000000 l    df *ABS*	00000000 alt_exit.c
0d04a778 l     F .text	00000040 alt_sim_halt
0d002bfc g     F .text	0000001c putchar
0d05cf88 g     O .bss	00000014 soq
0d008e74 g     F .text	00000094 _mprec_log10
0d01b81c g     F .text	000000e0 alt_tse_get_mac_info
0d0528fe g     O .rwdata	00000002 OSTaskNameSize
0d008f60 g     F .text	00000088 __any_on
0d00a84c g     F .text	00000070 _isatty_r
0d04c570 g     O .rodata	00000028 __mprec_tinytens
0d03cca4 g     F .text	00000780 ip_write_internal
0d00d250 g     F .text	000000c8 alt_main
0d049f48 g     F .text	0000008c strcpy
0d028b38 g     F .text	000000ac pk_free
0d002c20 g     F .text	000000a0 _puts_r
0d0165b8 g     F .text	00000048 alt_read_query_entry_32bit
0d05d134 g     O .bss	00000100 alt_irq
0d05270c g     O .rwdata	00000009 rtp_priority
0d00a8bc g     F .text	00000078 _lseek_r
0d049aa4 g     F .text	00000334 icmp_timex
0d02a4c4 g     F .text	00000044 m_freem
0d0480e4 g     F .text	00000048 vgetc
0d029560 g     F .text	0000001c clock_c
0d052b50 g     O .bss	00000004 tcp_optionbuf
0d03c76c g     F .text	00000084 if_getbynum
0d0119dc g     F .text	000000d0 OS_MemInit
0d052af0 g     O .bss	00000004 dsc_rlyerrs
0d052ae0 g     O .bss	00000004 dsc_releases
0d015d30 g     F .text	000002c0 alt_flash_cfi_write
0d025260 g     F .text	00000074 TK_OSTaskQuery
0d029254 g       .text	00000000 asm_cksum
0d01f718 g     F .text	00000100 marvell_cfg_rgmii
0d015918 g     F .text	00000064 OSTimeSet
0d047fc4 g     F .text	00000120 vgetc_locked
0d029da0 g     F .text	00000020 post_task_setup
0d0406a4 g     F .text	00000348 ipr_stats
0d037788 g     F .text	00000134 tcp_attach
0d052958 g     O .rwdata	00000004 reqlist_len
0d02b970 g     F .text	00000084 tcp_tick
0d02448c g     F .text	00000074 print_ipad
0d02515c g     F .text	00000104 tcp_wakeup
0d00c058 g     F .text	00000088 __eqdf2
0d0529e0 g     O .bss	00000004 last_flash_sector_offset
0d052a9c g     O .bss	00000004 igmp_timers_are_running
0d000fa0 g     F .text	000000ec led_bit_toggle
0d0346a8 g     F .text	0000012c tcp_pulloutofband
0d01cd98 g     F .text	000001f0 alt_tse_phy_print_profile
0d00d928 g     F .text	000006b4 OSEventPendMulti
0d05d61c g       *ABS*	00000000 __alt_heap_start
0d039f68 g     F .text	00000020 OSTaskCreateHook
0d028324 g     F .text	00000074 dhc_ifacedone
0d01f488 g     F .text	000000a8 marvell_phy_cfg
0d040a40 g     F .text	00000400 ip_rcv
0d047d14 g     F .text	0000017c vfseek
0d030508 g     F .text	00000120 soqremque
0d042890 g     F .text	00000858 udpdemux
0d020f18 g     F .text	00000104 tse_mac_close
0d002998 g     F .text	00000044 printf
0d052b9c g     O .bss	00000004 rt_mib
0d0528d6 g     O .rwdata	00000002 OSMboxEn
0d028234 g     F .text	00000060 dhc_state_init
0d04a46c g     F .text	00000024 vsprintf
0d0197a0 g     F .text	00000124 alt_avalon_sgdma_do_sync_transfer
0d00e030 g     F .text	0000007c OSIntEnter
0d00a318 g     F .text	00000068 __sseek
0d0071ec g     F .text	000000a4 __sinit
0d0419e4 g     F .text	00000118 in_delmulti
0d005500 g     F .text	00000130 __swbuf_r
0d052bb4 g     O .bss	00000004 so_evtmap_create
0d0528e6 g     O .rwdata	00000002 OSQEn
0d046294 g     F .text	00000094 in_pcballoc
0d052974 g     O .rwdata	00000002 socket_defaults
0d008010 g     F .text	00000084 _setlocale_r
0d03b598 g     F .text	00000498 send_arp
0d0072ec g     F .text	00000068 __sfmoreglue
0d046d80 g     F .text	00000368 vfopen_locked
0d0529ec g     O .bss	00000004 SSSLEDCommandQ
0d00d5e4 g     F .text	000000d0 __malloc_unlock
0d039fc4 g     F .text	0000001c OSTaskStatHook
0d03acb4 g     F .text	00000058 prep_modules
0d0239d4 g     F .text	000001b8 bsd_i_sockoptlen
0d052a30 g     O .bss	00000001 OSLockNesting
0d052950 g     O .rwdata	00000004 xids
0d002ee8 g     F .text	00000674 strerror
0d01ba80 g     F .text	00000e18 getPHYSpeed
0d0472e0 g     F .text	00000040 vfclose
0d05d028 g     O .bss	0000002c tcb
0d052924 g     O .rwdata	00000002 OSDataSize
0d03964c g     F .text	00000038 alt_remap_cached
0d052a31 g     O .bss	00000001 OSRunning
0d03c4a0 g     F .text	000002cc grat_arp
0d00133c g     F .text	0000005c get_ip_addr
0d045cac g     F .text	000000ac inet_pton
0d03c8d0 g     F .text	0000009c reg_type
0d05cb2c g     O .bss	000000f0 dhc_states
0d0227d0 g     F .text	00000198 igmp_fasttimo
0d0474a4 g     F .text	0000005c vunlink_flag_open_files
0d027fdc g     F .text	00000088 dhc_halt
0d019ef4 g     F .text	000003e8 alt_avalon_sgdma_construct_descriptor_burst
0d052ad4 g     O .bss	00000004 dsc_acks
0d05d054 g     O .bss	000000e0 tcpstat
0d03ff54 g     F .text	0000035c ip_reasm_copy_queued_fragments_into_reassy_buffer
0d02aa54 g     F .text	000000a8 dtom
0d035d20 g     F .text	000000fc tcp_setpersist
0d02d0fc g     F .text	000001a4 t_getsockopt
0d0027a0 g     F .text	000000e0 memmove
0d052ae4 g     O .bss	00000004 dsc_naks
0d02aef8 g     F .text	000005f8 ip_output
0d03a008 g     F .text	0000001c OSInitHookBegin
0d049dd8 g     F .text	00000054 icmp_du
0d05294c g     O .rwdata	00000004 num_net_tasks
0d052bd8 g     O .bss	00000004 vfiles
0d05291c g     O .rwdata	00000002 OSTmrSize
0d0453a8 g     F .text	00000104 dhc_main_ipset
0d0072dc g     F .text	00000010 _cleanup
0d03f04c g     F .text	000002e0 ip_reasm_process_first_fragment
0d008fe8 g     F .text	000000bc _Balloc
0d00185c g     F .text	00000194 get_board_mac_addr
0d052a34 g     O .bss	00000004 OSIdleCtr
0d0529f0 g     O .bss	00000004 SSSLEDLightshowSem
0d01e74c g     F .text	00000194 alt_tse_phy_set_adv_1000
0d052938 g     O .rwdata	00000001 max_mac_system
0d0442c4 g     F .text	000005f0 ip_setmoptions
0d01aa80 g     F .text	00000a14 alt_tse_system_add_sys
0d00c168 g     F .text	00000088 __gtdf2
0d04576c g     F .text	0000002c md_fseek
0d039c34 g       .text	00000000 OSStartTsk
00000000  w      *UND*	00000000 __errno
0d00f4fc g     F .text	000002e0 OS_TCBInit
0d03f32c g     F .text	000000a0 ip_reassm
0d028064 g     F .text	000001d0 dhc_reclaim
0d016744 g     F .text	00000048 alt_write_flash_command_32bit_device_16bit_mode
0d05d414 g     O .bss	00000010 udp_mib
09500000 g     F .entry	00000000 __reset
0d02d934 g     F .text	000000e4 t_shutdown
0d002104 g     F .text	000001ec sss_handle_receive
0d02d390 g     F .text	00000150 t_recvfrom
0d052922 g     O .rwdata	00000002 OSTmrWheelTblSize
0d044aa8 g     F .text	0000067c u_mctest_run
0d019a08 g     F .text	00000070 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
0d041b6c g     F .text	00000094 prep_ifaces
0d052ab8 g     O .bss	00000001 to_netmain
0d0287a4 g     F .text	000000dc pk_alloc
0d0528c2 g     O .rwdata	00000002 OSEventSize
0d000bc0 g     F .text	000002ec alt_SSSErrorHandler
0d052a38 g     O .bss	00000001 OSPrioHighRdy
0d00a7d8 g     F .text	00000074 _fstat_r
0d0508c0 g     O .rwdata	00000120 tse_mac_device
0d024ed4 g     F .text	0000004c tk_nettick
0d039f88 g     F .text	00000020 OSTaskDelHook
0d01624c g     F .text	000002e8 alt_flash_program_block
0d052a10 g     O .bss	00000004 errno
0d002d20 g     F .text	00000014 __srget
0d031834 g     F .text	000000cc in_pcbnotify
0d039c14 g       .text	00000000 OSStartHighRdy
0d05cc1c g     O .bss	00000014 lilfreeq
0d000304 g     F .text	00000624 alt_uCOSIIErrorHandler
0d041c28 g     F .text	00000028 evtmap_setup
0d0140f0 g     F .text	00000200 OSTaskCreateExt
0d052abc g     O .bss	00000004 tcp_sleep_timeout
0d030f34 g     F .text	000001d0 sbdrop
0d052bb0 g     O .bss	00000004 net_system_exit
0d05d424 g     O .bss	00000068 icmp_mib
0d036874 g     F .text	00000078 tcp_getseq
0d042038 g     F .text	000000cc ip_raw_alloc
0d01efa4 g     F .text	000004e4 alt_tse_phy_set_common_speed
0d01095c g     F .text	00000068 OSFlagPendGetFlagsRdy
0d052902 g     O .rwdata	00000002 OSTaskStatStkSize
0d05c600 g     O .bss	00000010 pmac_groups
0d026700 g     F .text	00000b3c dhc_request
0d02ebc0 g     F .text	000007e4 soreceive
0d00f968 g     F .text	00000334 OSFlagAccept
0d012114 g     F .text	000000c8 OSQFlush
0d011aac g     F .text	00000154 OSQAccept
0d052a18 g     O .bss	00000004 alt_argv
0d05a884 g       *ABS*	00000000 _gp
0d0409ec g     F .text	00000054 ip_reasm_send_icmp_timex
0d0398d0 g     F .text	00000118 usleep
0d047320 g     F .text	00000048 vfflush
0d05cf30 g     O .bss	00000040 resid_semaphore
0d024344 g     F .text	00000148 hexdump
0d03ef04 g     F .text	000000a8 ip_reasm_incr_mem_useage
0d029df8 g     F .text	00000034 calloc2
0d022e8c g     F .text	0000007c igmp_leavegroup
0d013f1c g     F .text	000001d4 OSTaskCreate
0d0139a8 g     F .text	00000574 OSTaskChangePrio
0d052a2c g     O .bss	00000004 alt_heapsem
0d0366c0 g     F .text	000000e8 tcp_close
0d00f7dc g     F .text	0000018c OSDebugInit
0d0142f0 g     F .text	0000040c OSTaskDel
0d048540 g     F .text	0000006c vferror
0d03986c g     F .text	00000064 alt_uncached_malloc
0d01a574 g     F .text	00000060 tse_mac_initTransInfo2
0d0435a0 g     F .text	000000c0 udp_alloc
0d052574 g     O .rwdata	00000180 alt_fd_list
0d0592fc g     O .bss	00000370 OSFlagTbl
0d052b3c g     O .bss	00000008 mbstat
0d002670 g     F .text	00000090 _getc_r
0d0025d8 g     F .text	00000098 getc
0d002c18 g     F .text	00000008 _putchar_r
0d00eaac g     F .text	000000b8 OS_EventTaskRemove
0d043eb4 g     F .text	00000158 igmpv2_chk_set_timer
0d024f20 g     F .text	0000002c TK_OSTimeDly
0d038d0c g     F .text	00000094 alt_find_dev
0d002700 g     F .text	000000a0 memcpy
0d01a7fc g     F .text	00000058 tse_mac_setMIImode
0d052aec g     O .bss	00000004 dsc_rebind
0d03b19c g     F .text	00000080 task_stats
0d02c420 g     F .text	0000004c DOMAIN_CHECK
0d02b4f0 g     F .text	00000040 in_broadcast
0d0528ec g     O .rwdata	00000002 OSRdyTblSize
0d01c898 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
0d052bd4 g     O .bss	00000004 vfsystems
0d0434d0 g     F .text	000000d0 udp_socket
0d052a8c g     O .bss	00000004 MaxMtu
0d0314c8 g     F .text	00000158 sock_selscan
0d01f898 g     F .text	0000015c triple_speed_ethernet_init
0d0072d0 g     F .text	0000000c _cleanup_r
0d00c300 g     F .text	000000f8 __floatsidf
0d03ecb0 g     F .text	000000d0 ip_reasm_match_frag_with_ire
0d030678 g     F .text	00000050 socantrcvmore
0d01a5d4 g     F .text	000000f0 tse_mac_sTxWrite
0d001f60 g     F .text	000001a4 sss_exec_command
0d002984 g     F .text	00000014 perror
0d039130 g     F .text	00000078 alt_io_redirect
0d00c278 g     F .text	00000088 __ltdf2
0d052b18 g     O .bss	00000004 netq_intmask
0d045c3c g     F .text	00000070 hextoa
0d04a854 g       *ABS*	00000000 __DTOR_END__
0d02d70c g     F .text	00000228 t_send
0d038930 g     F .text	000000fc alt_close
0d052b44 g     O .bss	00000002 select_wait
0d002cc0 g     F .text	00000014 puts
0d0249f0 g     F .text	00000044 std_out
0d05c620 g     O .bss	00000030 tse_iniche_dev_driver_data
0d04812c g     F .text	00000138 vfslookup_locked
0d02e3a8 g     F .text	0000009c soaccept
0d00d6b4 g     F .text	00000130 OSEventNameGet
0d0528d0 g     O .rwdata	00000002 OSFlagMax
0d039b68 g     F .text	00000020 altera_nios2_irq_init
0d05cf9c g     O .bss	0000003c tcpmib
0d02db80 g     F .text	0000009c t_errno
0d041c50 g     F .text	000000f0 ip_raw_open
0d0275a0 g     F .text	00000118 dhc_decline
0d008dc4 g     F .text	000000b0 __ratio
0d00e0ac g     F .text	00000100 OSIntExit
0d0529c8 g     O .rwdata	00000004 ipRoutes
0d04744c g     F .text	00000058 vfeof
0d036b8c g     F .text	0000005c tcp_canceltimers
0d025ec8 g     F .text	0000021c dhc_buildheader
0d05290a g     O .rwdata	00000002 OSTCBSize
0d019aec g     F .text	00000084 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
0d052a39 g     O .bss	00000001 OSPrioCur
0d01813c g     F .text	000002c0 altera_avalon_jtag_uart_read
0d049ec0 g     F .text	00000014 malloc
0d052bd0 g     O .bss	00000004 inpcb_cachemiss
0d0029dc g     F .text	00000034 _printf_r
0d045e44 g     F .text	000000c4 inet46_addr
0d052bcc g     O .bss	00000004 inpcb_cachehits
0d00c7a0 g     F .text	00000008 __udivsi3
0d052534 g     O .rwdata	0000000b tcp_outflags
0d05c650 g     O .bss	00000130 tse
0d00cfe0 g     F .text	000000c0 isatty
0d01b494 g     F .text	00000178 alt_tse_sys_enable_mdio_sharing
0d0528f0 g     O .rwdata	00000002 OSStkWidth
0d04c480 g     O .rodata	000000c8 __mprec_tens
0d046bdc g     F .text	0000007c vf_alloc_and_link_vop
0d0528e4 g     O .rwdata	00000002 OSPtrSize
0d052ba0 g     O .bss	00000004 ipr_curr_mem
0d02245c g     F .text	0000006c exit_hook
0d052aa0 g     O .bss	00000004 igmp_cticks
0d01b790 g     F .text	0000008c alt_tse_get_mac_info_index
0d052b2c g     O .bss	00000004 mheap_sem_ptr
0d034a40 g     F .text	00000048 ip4_tcpmss
0d007fec g     F .text	00000008 __locale_charset
0d0528c4 g     O .rwdata	00000002 OSEventTblSize
0d05d398 g     O .bss	00000014 netlist
0d02f3a4 g     F .text	000000a8 soshutdown
0d039b88 g       .text	00000000 OSCtxSw
0d03ac44 g     F .text	0000004c packet_check
0d02723c g     F .text	00000280 dhc_setip
0d05cfd8 g     O .bss	00000014 mbufq
0d02e358 g     F .text	00000050 soabort
0d052a04 g     O .bss	00000004 __malloc_top_pad
0d052a3c g     O .bss	00000004 OSTCBList
0d028e28 g     F .text	00000110 qdel
0d03aac0 g     F .text	00000150 station_state
0d0421a0 g     F .text	00000184 rt_lookup
0d052b5c g     O .bss	00000004 alt_fd_list_lock
0d052890 g     O .rwdata	00000004 __mb_cur_max
0d022f08 g     F .text	0000035c igmp_validate
0d007ff4 g     F .text	0000000c _localeconv_r
0d022178 g     F .text	000002e4 ip_startup
0d02c75c g     F .text	00000298 t_accept
0d0300f8 g     F .text	0000008c soisdisconnecting
0d0096e0 g     F .text	0000003c __i2b
0d0079d0 g     F .text	0000049c __sfvwrite_r
0d019c14 g     F .text	00000058 alt_avalon_sgdma_stop
0d021b30 g     F .text	000003d4 pktdemux
0d05966c g     O .bss	00000c30 OSMemTbl
0d052a40 g     O .bss	00000001 OSTickStepState
0d01c934 g     F .text	00000128 alt_tse_phy_wr_mdio_reg
0d029418 g     F .text	000000ac kbhit
0d02cf20 g     F .text	000001dc t_setsockopt
0d00a2a0 g     F .text	00000070 _sbrk_r
0d03a4dc g     F .text	00000084 alt_program_intel
0d0526f4 g     O .rwdata	00000018 icmpdu_types
0d01cf88 g     F .text	0000070c alt_tse_mac_group_init
0d047500 g     F .text	00000220 vunlink
0d01fc58 g     F .text	00000ae8 tse_mac_init
0d0528e8 g     O .rwdata	00000002 OSQMax
0d024184 g     F .text	000000b0 ccksum
0d046c58 g     F .text	000000d8 vf_alloc_buffer
0d052bc4 g     O .bss	00000004 cachedRoute
0d05295c g     O .rwdata	00000004 lilbufs
0d05a29c g     O .bss	00000800 OSTaskStatStk
0d045798 g     F .text	00000024 md_ftell
0d024234 g     F .text	00000068 cksum
0d0115c4 g     F .text	0000010c OSMemNameGet
0d02df34 g     F .text	00000130 sofree
0d052a94 g     O .bss	00000004 ifNumber
0d0528c8 g     O .rwdata	00000002 OSFlagEn
0d00a934 g     F .text	00000078 _read_r
0d05290e g     O .rwdata	00000002 OSTimeTickHookEn
0d038a8c g     F .text	00000078 alt_dcache_flush
0d0111f8 g     F .text	000000ac OS_FlagUnlink
0d012678 g     F .text	00000180 OSQPost
0d050de0 g     O .rwdata	0000000c __lc_ctype
0d05299c g     O .rwdata	00000004 alt_max_fd
0d016534 g     F .text	00000040 alt_read_query_entry_8bit
0d00f088 g     F .text	0000006c OS_MemCopy
0d052964 g     O .rwdata	00000004 bigbufs
0d0378bc g     F .text	000000d4 tcp_disconnect
0d00f0f4 g     F .text	000000d4 OS_Sched
0d00cbdc g     F .text	00000138 __unpack_d
0d00a6b4 g     F .text	00000110 _fclose_r
0d0114c0 g     F .text	00000104 OSMemGet
0d014a24 g     F .text	000001c4 OSTaskNameSet
0d03a560 g     F .text	00000174 alt_erase_block_intel
0d007150 g     F .text	00000034 fflush
0d052a08 g     O .bss	00000004 __malloc_max_sbrked_mem
0d052a44 g     O .bss	00000004 OSCtxSwCtr
0d05caa4 g     O .bss	00000064 igmpstats
0d039fe0 g     F .text	00000028 OSTimeTickHook
0d0265fc g     F .text	00000104 dhc_rx_offer
0d023b8c g     F .text	00000120 bsd_getsockopt
0d0528d2 g     O .rwdata	00000002 OSFlagNameSize
0d05d3fc g     O .bss	00000018 ire_stats
0d001100 g     F .text	000001e4 LEDManagementTask
0d037b2c g     F .text	000001b8 udp_soinput
0d028d78 g     F .text	000000b0 putq
0d00eb64 g     F .text	00000104 OS_EventTaskRemoveMulti
0d052ab4 g     O .bss	00000004 iniche_net_ready
0d00b9c8 g     F .text	00000074 __adddf3
0d00e958 g     F .text	00000154 OS_EventTaskWaitMulti
0d0484f8 g     F .text	00000048 isvfile
0d02f54c g     F .text	000004c0 sosetopt
0d024d58 g     F .text	000000f4 netmain
0d034a88 g     F .text	0000011c tcp_mss
0d008ca4 g     F .text	00000120 __b2d
0d0458b8 g     F .text	0000031c parse_ipad
0d046bbc g     F .text	00000020 get_vfopen_error
0d0528ea g     O .rwdata	00000002 OSQSize
0d00af88 g     F .text	000005b0 __umoddi3
0d00d100 g     F .text	000000f0 lseek
0d03ad0c g     F .text	000000c4 inet_timer
0d013254 g     F .text	0000027c OSSemPend
0d01cb20 g     F .text	00000278 alt_tse_phy_add_profile_default
0d01e20c g     F .text	00000540 alt_tse_phy_get_cap
0d001d10 g     F .text	00000190 sss_send_menu
0d05288c g     O .rwdata	00000004 _global_impure_ptr
0d024688 g     F .text	00000164 print_eth
0d0470e8 g     F .text	00000050 vfopen
0d03946c g     F .text	00000120 alt_read
0d009a5c g     F .text	000005f4 _realloc_r
0d000928 g     F .text	00000298 alt_NetworkErrorHandler
0d0528d4 g     O .rwdata	00000002 OSLowestPrio
0d05d61c g       *ABS*	00000000 __bss_end
0d038f74 g     F .text	000000f8 alt_iic_isr_register
0d019664 g     F .text	0000013c alt_avalon_sgdma_do_async_transfer
0d02a390 g     F .text	00000134 m_free
0d03a05c g     F .text	00000020 OSTCBInitHook
0d020ed8 g     F .text	00000040 tse_mac_stats
0d028880 g     F .text	000002b8 pk_validate
0d05291a g     O .rwdata	00000002 OSTmrCfgTicksPerSec
0d03975c g     F .text	00000110 alt_tick
0d046938 g     F .text	0000025c in_pcblookup
0d028448 g     F .text	000000cc find_opt
0d00a9ac g     F .text	000005dc __udivdi3
0d02a1e8 g     F .text	000001a8 m_getnbuf
0d028c04 g     F .text	000000ac dump_buf_estats
0d01e0c8 g     F .text	00000144 alt_tse_phy_check_link
0d052b94 g     O .bss	00000004 arpRepsOut
0d0528bc g     O .rwdata	00000002 OSEventEn
0d04c548 g     O .rodata	00000028 __mprec_bigtens
0d00993c g     F .text	00000120 __s2b
0d052916 g     O .rwdata	00000002 OSTmrCfgNameSize
0d00c4d0 g     F .text	00000194 __floatunsidf
0d03a93c g     F .text	000000fc netmain_init
0d01f624 g     F .text	000000f4 marvell_cfg_sgmii
0d01df18 g     F .text	000001b0 alt_tse_phy_restart_an
0d008bc4 g     F .text	00000060 __mcmp
0d052ad0 g     O .bss	00000004 dsc_requests
0d036074 g     F .text	00000488 tcp_respond
0d037f68 g     F .text	0000033c udp4_sockbind
0d052884 g     O .rwdata	00000004 __ctype_ptr
0d052b1c g     O .bss	00000004 old_mode
0d022c10 g     F .text	0000027c igmp_joingroup
0d02b618 g     F .text	00000358 so_icmpdu
0d0072b8 g     F .text	00000018 __fp_lock_all
0d052be4 g     O .bss	00000004 vfs_dir_stale
0d038f2c g     F .text	00000048 alt_ic_irq_enabled
0d05c610 g     O .bss	00000010 pphy_profiles
0d0402b0 g     F .text	000000e4 ip_reasm_process_timer_tick
0d0485ac g     F .text	0000005c vclearerr
0d024098 g     F .text	000000ec bsd_setsockopt
0d02a9fc g     F .text	00000058 mbuf_len
0d011004 g     F .text	000000e4 OS_FlagInit
0d0396c4 g     F .text	00000098 alt_alarm_stop
0d0482ac g     F .text	000001e8 strippath
0d052954 g     O .rwdata	00000004 reqlist
0d024fbc g     F .text	000001a0 tcp_sleep
0d04a3c4 g     F .text	00000024 strtol
0d025698 g     F .text	00000830 dhc_upcall
0d037990 g     F .text	000000e0 tcp_usrclosed
20000000 g       *ABS*	00000000 __alt_mem_descriptor_memory
0d052b08 g     O .bss	00000004 cticks_factor
0d0528f8 g     O .rwdata	00000002 OSTaskIdleStkSize
0d04637c g     F .text	00000254 in_pcbbind
0d052b60 g     O .bss	00000004 alt_irq_active
0d012de0 g     F .text	000000c0 OSSemAccept
0d0117f0 g     F .text	000000f0 OSMemPut
0d0112a4 g     F .text	0000021c OSMemCreate
0d052a48 g     O .bss	00000004 OSIdleCtrMax
0d0001ec g     F .exceptions	000000d0 alt_irq_handler
0d05254c g     O .rwdata	00000028 alt_dev_null
0d052976 g     O .rwdata	00000001 tcprexmtthresh
0d05290c g     O .rwdata	00000002 OSTicksPerSec
0d03c96c g     F .text	00000098 if_killsocks
0d03d424 g     F .text	00000248 ip_write
0d040e40 g     F .text	0000060c ip_rcv_phase2
0d02cce0 g     F .text	00000044 t_getsockname
0d02c9f4 g     F .text	000002a8 t_connect
0d052970 g     O .rwdata	00000004 TCPTV_MSL
0d05cc30 g     O .bss	00000010 memestats
0d01de04 g     F .text	00000114 alt_tse_phy_init
0d0294c4 g     F .text	00000060 getch
0d016a4c g     F .text	000000ac alt_set_flash_algorithm_func
0d0527ec g     O .rwdata	00000080 vfs_root_path
0d02cc9c g     F .text	00000044 t_getpeername
0d019c6c g     F .text	00000070 alt_avalon_sgdma_check_descriptor_status
0d03efac g     F .text	000000a0 ip_reasm_decr_mem_useage
0d030804 g     F .text	00000080 soreserve
0d039b88 g       .text	00000000 OSIntCtxSw
0d029e2c g     F .text	000000f4 npalloc
0d008a90 g     F .text	00000070 __hi0bits
0d052bc0 g     O .bss	00000004 ipraw_eps
0d028514 g     F .text	00000290 pk_init
0d04556c g     F .text	00000180 md_fread
0d049e58 g     F .text	0000001c calloc
0d020740 g     F .text	000002f8 tse_mac_raw_send
0d00c3f8 g     F .text	000000d8 __fixdfsi
0d05d234 g     O .bss	00000064 intimers
0d0308e4 g     F .text	00000048 sbrelease
0d031968 g     F .text	000000f0 ifd_clr
0d031214 g     F .text	00000094 sbdroprecord
0d0247ec g     F .text	00000080 uslash
0d0399e8 g     F .text	00000120 alt_write
0d016600 g     F .text	0000003c alt_write_flash_command_8bit_device_8bit_mode
0d052b90 g     O .bss	00000004 arpRepsIn
0d025508 g     F .text	00000090 dhc_get_srv_ipaddr
0d03af68 g     F .text	00000168 in_timerset
0d052a4c g     O .bss	00000004 OSTCBFreeList
0d0134d0 g     F .text	0000017c OSSemPendAbort
0d034ba4 g     F .text	0000117c tcp_output
0d052b6c g     O .bss	00000004 activehost
0d052994 g     O .rwdata	00000008 alt_dev_list
0d024b2c g     F .text	0000022c parse_args
0d052b20 g     O .bss	00000004 global_TCPwakeup_setIndx
0d0074a8 g     F .text	00000058 _fputc_r
0d02122c g     F .text	00000070 write
0d019e1c g     F .text	0000007c alt_avalon_sgdma_enable_desc_poll
0d029f20 g     F .text	000000b8 npfree
0d002b14 g     F .text	000000e8 _putc_r
0d03bcec g     F .text	00000294 arpReply
0d0242c8 g     F .text	0000007c nextarg
0d052910 g     O .rwdata	00000002 OSVersionNbr
0d03f95c g     F .text	00000594 ip_reasm_process_subsequent_fragments
0d0529d4 g     O .rwdata	00000004 pton_error
0d052ac4 g     O .bss	00000004 dsc_errors
0d053284 g     O .bss	00002000 SSSInitialTaskStk
0d05c780 g     O .bss	00000014 rcvdq
0d031900 g     F .text	00000068 tcp_notify
0d00ceac g     F .text	000000d4 fstat
0d00249c g     F .text	0000002c fprintf
0d02e444 g     F .text	000000d4 soconnect
0d042144 g     F .text	0000005c ip_raw_maxalloc
0d01f818 g     F .text	00000080 DP83848C_link_status_read
0d0260e4 g     F .text	00000518 dhc_discover
0d0178a0 g     F .text	000000dc alt_check_primary_table
0d001b34 g     F .text	000000a8 SSSCreateOSDataStructs
0d0468bc g     F .text	0000007c in_setpeeraddr
0d0528b8 g     O .rwdata	00000004 OSEndiannessTest
0d029524 g     F .text	0000003c clock_init
0d047368 g     F .text	000000e4 vfgets
0d03b320 g     F .text	0000017c et_send
0d00981c g     F .text	00000120 __pow5mult
0d0529f8 g     O .bss	00000004 __nlocale_changed
0d00c7a8 g     F .text	00000008 __umodsi3
0d016080 g     F .text	00000068 alt_flash_cfi_read
0d0167d4 g     F .text	00000034 alt_write_native_8bit
0d045bd4 g     F .text	00000068 inet_addr
0d03ee6c g     F .text	00000098 ip_reasm_check_mem_useage
0d02f44c g     F .text	00000100 sorflush
0d04a3fc g     F .text	00000020 vprintf
0d05cd44 g     O .bss	000000fc global_tcb_ext
0d03daf4 g     F .text	00000488 ip_fragment_lc
0d05c794 g     O .bss	00000300 netstatic
0d02c4fc g     F .text	0000017c t_bind
0d019a78 g     F .text	00000074 alt_avalon_sgdma_construct_mem_to_stream_desc
0d0528ca g     O .rwdata	00000002 OSFlagGrpSize
0d029170 g     F .text	000000e4 udp_close
0d019b70 g     F .text	00000050 alt_avalon_sgdma_register_callback
0d029b10 g     F .text	0000021c alt_iniche_init
0d05d61c g       *ABS*	00000000 end
0d029748 g     F .text	00000088 UNLOCK_NET_RESOURCE
0d01f9f4 g     F .text	00000264 prep_tse_mac
0d02d2a0 g     F .text	000000f0 t_recv
0d01663c g     F .text	0000007c alt_write_flash_command_16bit_device_8bit_mode
0d018eac g     F .text	00000530 altera_avalon_lcd_16207_write
0d047720 g     F .text	000001ac vfread
0d021a48 g     F .text	000000e8 netclose
0d0022f0 g     F .text	000001ac SSSSimpleSocketServerTask
0d049e40 g     F .text	0000000c _atoi_r
0d01a8a8 g     F .text	000001d8 alt_tse_phy_add_profile
0d016b74 g     F .text	00000580 alt_read_cfi_table
0d052980 g     O .rwdata	00000004 tcp_keepintvl
0d017ac4 g     F .text	00000138 altera_avalon_jtag_uart_init
0d00f36c g     F .text	000000c8 OS_TaskStat
0d052ac8 g     O .bss	00000004 dsc_discovers
0d052928 g     O .rwdata	00000004 tse_mac_name
0d0524ec g     O .rwdata	00000018 tcp_protosw
0d04a850 g       *ABS*	00000000 __CTOR_LIST__
0d052be0 g     O .bss	00000004 vfopen_error
0d800000 g       *ABS*	00000000 __alt_stack_pointer
0d052b54 g     O .bss	00000004 tcp_maxidle
0d052af4 g     O .bss	00000004 firstudp
0d019e98 g     F .text	0000005c alt_avalon_sgdma_disable_desc_poll
0d01a4b8 g     F .text	00000090 alt_avalon_timer_sc_init
0d00c848 g     F .text	00000080 __clzsi2
0d0183fc g     F .text	000002dc altera_avalon_jtag_uart_write
0d0198c4 g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
0d015c5c g     F .text	0000009c alt_flash_cfi_init
0d0071dc g     F .text	00000004 __sfp_lock_acquire
0d008984 g     F .text	000000e4 memchr
0d00f034 g     F .text	00000054 OS_MemClr
0d003630 g     F .text	00001eac ___vfprintf_internal_r
0d039c58 g     F .text	00000310 OSTaskStkInit
0d002da8 g     F .text	00000060 _sprintf_r
0d0199b4 g     F .text	00000054 alt_avalon_sgdma_construct_stream_to_mem_desc
0d0076bc g     F .text	00000314 _free_r
0d04400c g     F .text	00000170 igmpv2_chk4_rtr_alert_opt
0d02da18 g     F .text	000000d0 t_socketclose
0d055284 g     O .bss	00002000 LED7SegLightshowTaskStk
0d00e6b4 g     F .text	00000194 OS_EventTaskRdy
0d04a5c8 g     F .text	000001b0 __call_exitprocs
0d002cd4 g     F .text	0000004c __srget_r
0d020a38 g     F .text	000000a8 tse_sgdmaRx_isr
0d052a50 g     O .bss	00000001 OSCPUUsage
0d05ca94 g     O .bss	00000010 nets
0d029688 g     F .text	000000c0 LOCK_NET_RESOURCE
0d0274bc g     F .text	000000e4 dhc_resetip
0d0529fc g     O .bss	00000004 __mlocale_changed
0d020c88 g     F .text	00000250 tse_mac_rcv
0d02c46c g     F .text	00000090 t_socket
0d05289c g     O .rwdata	00000004 __malloc_sbrk_base
0d0002bc g     F .text	00000048 _start
0d03b2cc g     F .text	00000054 etainit
0d052b64 g     O .bss	00000004 _alt_tick_rate
0d03ac90 g     F .text	00000024 mcastlist
0d0121dc g     F .text	00000320 OSQPend
0d05cc40 g     O .bss	000000f0 pktlog
0d043b1c g     F .text	0000014c igmpv2_process_report
0d031acc g     F .text	00000080 ifd_isset
0d04274c g     F .text	00000144 del_route
0d019cdc g     F .text	00000058 alt_avalon_sgdma_open
0d0035d0 g     F .text	00000008 _user_strerror
0d0153e8 g     F .text	0000014c OSTimeDly
0d0012e4 g     F .text	00000058 get_mac_addr
0d02de44 g     F .text	000000f0 solisten
0d0093ac g     F .text	0000014c __lshift
0d052b68 g     O .bss	00000004 _alt_nticks
0d01ca5c g     F .text	000000c4 alt_tse_phy_rd_mdio_reg
0d0211b4 g     F .text	00000078 read
0d0159b0 g     F .text	00000274 alt_sys_init
0d0367a8 g     F .text	0000004c tcp_quench
0d02486c g     F .text	00000184 ns_printf
0d03c7f0 g     F .text	000000e0 isbcast
0d0297d0 g     F .text	00000214 TK_NEWTASK
0d04a490 g     F .text	00000134 __register_exitproc
0d052a51 g     O .bss	00000001 OSTaskCtr
0d03ed80 g     F .text	000000ec ip_reasm_determine_type_of_frag
0d052a80 g     O .bss	00000001 phy_profile_count
0d049fd4 g     F .text	000000f0 strncmp
0d01b710 g     F .text	00000080 alt_tse_get_mac_group_index
0d016574 g     F .text	00000044 alt_read_query_entry_16bit
0d015534 g     F .text	00000170 OSTimeDlyHMSM
0d039684 g     F .text	00000040 alt_remap_uncached
0d041d40 g     F .text	000000c0 ip_raw_close
0d0094f8 g     F .text	000001e8 __multiply
0d05273c g     O .rwdata	000000b0 mdlist
0d017fd4 g     F .text	00000074 altera_avalon_jtag_uart_close
0d0226d8 g     F .text	000000f8 igmp_input
0d03da1c g     F .text	000000d8 ip_raw_write
0d0478cc g     F .text	000003e8 vfwrite_locked
0d04a0c4 g     F .text	000000bc strncpy
0d052acc g     O .bss	00000004 dsc_offers
0d0531e8 g     O .bss	00000028 __malloc_current_mallinfo
0d0528be g     O .rwdata	00000002 OSEventMax
0d045f08 g     F .text	00000074 inet_setport
0d01686c g     F .text	000001e0 alt_set_flash_width_func
0d0090a4 g     F .text	0000017c __d2b
0d01364c g     F .text	00000128 OSSemPost
0d034518 g     F .text	00000190 tcp_dooptions
0d0529f4 g     O .bss	00000004 SSSLEDEventFlag
0d02fffc g     F .text	000000fc soisconnected
0d00e238 g     F .text	000000e4 OSSchedUnlock
0d041c00 g     F .text	00000028 netexit
0d001398 g     F .text	000001dc get_serial_number
0d052ab0 g     O .bss	00000004 nettick_wakes
0d01c8e0 g     F .text	00000054 alt_tse_phy_wr_mdio_addr
0d052b48 g     O .bss	00000001 tcpprintfs
0d03b0d0 g     F .text	000000a8 in_timerkill
0d0439bc g     F .text	00000160 igmpv2_input
0d052adc g     O .bss	00000004 dsc_declines
0d01797c g     F .text	00000058 altera_avalon_jtag_uart_read_fd
0d02429c g     F .text	0000002c do_trap
0d048a2c g     F .text	000000f4 alt_get_fd
0d023cac g     F .text	00000104 bsd_ioctl
0d052a54 g     O .bss	00000004 OSMemFreeList
0d00e38c g     F .text	000000ac OSStatInit
0d02ad0c g     F .text	000001ec tcp_rcv
0d024644 g     F .text	00000044 panic
0d052be8 g     O .bss	00000004 vfs_open_files
0d04862c g     F .text	0000012c alt_busy_sleep
0d021fd4 g     F .text	000001a4 ip2mac
0d010d6c g     F .text	000000d4 OSFlagQuery
0d00cd14 g     F .text	000000c8 __fpcmp_parts_d
0d031620 g     F .text	00000214 sock_select
0d045124 g     F .text	00000284 dhc_setup
0d035f04 g     F .text	00000058 tcp_init
0d052b24 g     O .bss	00000004 cticks
0d052ab9 g     O .bss	00000001 to_nettick
0d0528f4 g     O .rwdata	00000002 OSTaskCreateExtEn
0d00a644 g     F .text	00000070 _close_r
0d02129c g     F .text	0000064c Netinit
0d029dc0 g     F .text	00000038 prep_armintcp
0d04187c g     F .text	00000168 in_addmulti
0d035f5c g     F .text	00000118 tcp_template
0d01ec88 g     F .text	0000031c alt_tse_phy_get_common_speed
0d02aafc g     F .text	00000070 remque
0d03a0e4 g     F .text	00000218 alt_erase_block_amd
0d04a3e8 g     F .text	00000014 _vprintf_r
0d031bbc g     F .text	00000408 tcp_reass
0d0460c8 g     F .text	000001cc tcp_cksum
0d0382a4 g     F .text	000003dc udp4_socksend
0d047138 g     F .text	000001a8 vfclose_locked
0d031a58 g     F .text	00000074 ifd_set
0d049ed4 g     F .text	00000074 memcmp
0d00e698 g     F .text	0000001c OS_Dummy
0d017a2c g     F .text	00000048 altera_avalon_jtag_uart_close_fd
0d028398 g     F .text	000000b0 dhc_set_state
0d052a90 g     O .bss	00000004 NDEBUG
0d05d61c g       *ABS*	00000000 __alt_stack_base
0d0529e4 g     O .bss	00000004 last_flash_sector
0d017a74 g     F .text	00000050 altera_avalon_jtag_uart_ioctl_fd
0d030884 g     F .text	00000060 sbreserve
0d052a81 g     O .bss	00000001 mac_group_count
0d041e00 g     F .text	00000238 ip_raw_input
0d0024fc g     F .text	0000009c _fwrite_r
0d052960 g     O .rwdata	00000004 lilbufsiz
0d031b4c g     F .text	00000070 ifd_get
0d030768 g     F .text	0000009c sbwakeup
0d00564c g     F .text	0000013c __swsetup_r
0d0170f4 g     F .text	000007ac alt_read_cfi_width
0d05aa9c g     O .bss	000001e0 OSQTbl
0d0347d4 g     F .text	0000026c tcp_xmit_timer
0d020ae0 g     F .text	000001a8 tse_sgdma_read_init
0d00be00 g     F .text	00000258 __divdf3
0d007354 g     F .text	000000f0 __sfp
0d001720 g     F .text	0000013c generate_mac_addr
0d03cb00 g     F .text	000001a4 ip_bldhead
0d008f08 g     F .text	00000058 __copybits
0d03092c g     F .text	000000a8 sbappend
0d050dec g     O .rwdata	00000408 __malloc_av_
0d0071e8 g     F .text	00000004 __sinit_lock_release
0d052a58 g     O .bss	00000004 OSTCBHighRdy
0d00ba3c g     F .text	000003c4 __muldf3
0d03d66c g     F .text	000003b0 ip_write2
0d00a3fc g     F .text	00000060 __sread
0d0529c0 g     O .rwdata	00000004 arp_ageout
0d052a5c g     O .bss	00000004 OSQFreeList
0d01d694 g     F .text	00000418 alt_tse_mac_get_phy
0d03ca04 g     F .text	000000fc ip_init
0d04890c g     F .text	00000120 alt_find_file
0d042104 g     F .text	00000040 ip_raw_free
0d03bbd8 g     F .text	00000114 make_arp_entry
0d038b30 g     F .text	000000b4 alt_dev_llist_insert
0d00d4dc g     F .text	00000108 __malloc_lock
0d0024c8 g     F .text	00000034 _fprintf_r
0d00d318 g     F .text	000000bc sbrk
0d037abc g     F .text	00000070 udp_lookup
0d019bc0 g     F .text	00000054 alt_avalon_sgdma_start
0d00d7e4 g     F .text	00000144 OSEventNameSet
0d006f54 g     F .text	000001fc _fflush_r
0d01b9e8 g     F .text	00000098 alt_tse_mac_set_duplex
0d00a590 g     F .text	000000b4 _calloc_r
0d052a60 g     O .bss	00000001 OSRdyGrp
0d045524 g     F .text	00000028 md_fopen
0d052504 g     O .rwdata	00000018 udp_protosw
0d0528a0 g     O .rwdata	00000008 alt_flash_dev_list
0d016700 g     F .text	00000044 alt_write_flash_command_16bit_device_16bit_mode
0d046840 g     F .text	0000007c in_setsockaddr
0d0529dc g       *ABS*	00000000 __bss_start
0d00108c g     F .text	00000074 LED7SegLightshowTask
0d0309d4 g     F .text	000000e0 sbappendrecord
0d05d3ac g     O .bss	00000050 ip_mib
0d002880 g     F .text	00000098 memset
0d02e518 g     F .text	000000a0 sodisconnect
0d000f24 g     F .text	0000007c main
0d052a1c g     O .bss	00000004 alt_envp
0d052a0c g     O .bss	00000004 __malloc_max_total_mem
0d001ca0 g     F .text	00000070 sss_reset_connection
0d02a82c g     F .text	000001d0 m_adj
0d0179d4 g     F .text	00000058 altera_avalon_jtag_uart_write_fd
0d005630 g     F .text	0000001c __swbuf
0d0457bc g     F .text	000000d8 md_fgetc
0d04c6c8 g     O .rodata	00000100 OSUnMapTbl
0d03e654 g     F .text	000002b8 ip_dump
0d025300 g     F .text	00000208 tk_stats
0d05293c g     O .rwdata	00000008 alt_iniche_dev_list
0d057284 g     O .bss	00000078 SSSLEDCommandQTbl
0d0194a8 g     F .text	00000164 altera_avalon_lcd_16207_init
0d052930 g     O .rwdata	00000008 alt_sgdma_list
0d0528ee g     O .rwdata	00000002 OSSemEn
0d052b0c g     O .bss	00000004 OS_TPS
0d02bc38 g     F .text	000007e8 rawip_usrreq
0d0109c4 g     F .text	000003a8 OSFlagPost
0d00a310 g     F .text	00000008 __sclose
0d045de4 g     F .text	00000060 print46_addr
0d800000 g       *ABS*	00000000 __alt_heap_limit
0d00a7c4 g     F .text	00000014 fclose
0d00e848 g     F .text	00000110 OS_EventTaskWait
0d04a180 g     F .text	00000244 _strtol_r
0d024500 g     F .text	00000144 print_uptime
0d00f434 g     F .text	000000c8 OS_TaskStatStkChk
0d05d48c g     O .bss	00000190 _atexit0
0d0146fc g     F .text	00000170 OSTaskDelReq
0d0059a0 g     F .text	000015b4 _dtoa_r
0d008244 g     F .text	00000740 _malloc_r
0d045894 g     F .text	00000024 md_unlink
0d01a768 g     F .text	00000094 tse_mac_SwReset
0d046328 g     F .text	00000054 in_pcbdetach
0d0529a0 g     O .rwdata	00000004 alt_errno
0d0529d0 g     O .rwdata	00000004 mdlist_size
0d00e31c g     F .text	00000070 OSStart
0d01678c g     F .text	00000048 alt_write_flash_command_32bit_device_32bit_mode
0d044a78 g     F .text	00000030 u_mctest_init
0d00d480 g     F .text	0000005c __env_unlock
0d007f34 g     F .text	000000b8 _fwalk
0d014be8 g     F .text	00000218 OSTaskResume
0d0118e0 g     F .text	000000fc OSMemQuery
0d045f7c g     F .text	0000014c convert_ip
0d03ba30 g     F .text	000001a8 find_oldest_arp
0d052900 g     O .rwdata	00000002 OSTaskStatEn
0d052b88 g     O .bss	00000004 arpReqsIn
0d046d30 g     F .text	00000050 vf_free_buffer
0d0160e8 g     F .text	00000164 alt_write_value_to_flash
0d048758 g     F .text	00000154 alt_fcntl
0d0528da g     O .rwdata	00000002 OSMemMax
0d0127f8 g     F .text	00000188 OSQPostFront
0d016808 g     F .text	00000034 alt_write_native_16bit
0d0293e8 g     F .text	00000030 dtrap
0d05296c g     O .rwdata	00000004 kb_last
0d002a10 g     F .text	00000104 putc
0d00c6e0 g     F .text	00000060 __divsi3
0d01b64c g     F .text	00000048 alt_tse_mac_set_common_speed
0d052a61 g     O .bss	00000003 OSRdyTbl
0d0528b4 g     O .rwdata	00000002 OSDebugEn
0d04c5a4 g     O .rodata	00000014 __thenan_df
0d0224c8 g     F .text	000000d0 ip_exit
0d007590 g     F .text	0000012c _malloc_trim_r
0d04a854 g       *ABS*	00000000 __CTOR_END__
0d0528cc g     O .rwdata	00000002 OSFlagNodeSize
0d052ac0 g     O .bss	00000004 dhc_conn
0d02957c g     F .text	0000006c cticks_hook
0d052914 g     O .rwdata	00000002 OSTmrCfgMax
0d03ac10 g     F .text	00000034 sysuptime
0d00a45c g     F .text	000000bc strcmp
0d001574 g     F .text	000001ac generate_and_store_mac_addr
0d040394 g     F .text	000001c8 ip_reasm_delete_ire
0d011c00 g     F .text	00000214 OSQCreate
0d0295e8 g     F .text	0000005c irq_Mask
0d01486c g     F .text	000001b8 OSTaskNameGet
0d052b74 g     O .bss	00000004 nextppp
0d052b00 g     O .bss	00000004 irq_level
0d0218e8 g     F .text	00000160 fixup_subnet_mask
0d012980 g     F .text	00000234 OSQPostOpt
0d00e438 g     F .text	00000240 OSTimeTick
0d03eb78 g     F .text	00000138 ip_copypkt
0d028294 g     F .text	00000090 dhc_alldone
0d0528fc g     O .rwdata	00000002 OSTaskMax
0d04a854 g       *ABS*	00000000 __DTOR_LIST__
0d012ea0 g     F .text	00000114 OSSemCreate
0d052aa4 g     O .bss	00000004 igmp_all_hosts_group
0d052920 g     O .rwdata	00000002 OSTmrWheelSize
0d0306c8 g     F .text	00000038 sbselqueue
0d052aac g     O .bss	00000004 netmain_wakes
0d03bf80 g     F .text	00000260 arprcv
0d024f4c g     F .text	00000070 TK_OSTaskResume
0d023264 g     F .text	000003e0 igmp_print_stats
0d00c0e0 g     F .text	00000088 __nedf2
0d02a078 g     F .text	000000a0 pffindtype
0d0528f6 g     O .rwdata	00000002 OSTaskDelEn
0d052984 g     O .rwdata	00000004 tcp_sendspace
0d047e90 g     F .text	00000134 vftell
0d05cb08 g     O .bss	00000012 eth_prt_buf
0d013774 g     F .text	00000130 OSSemQuery
0d011e14 g     F .text	00000300 OSQDel
0d0124fc g     F .text	0000017c OSQPendAbort
0d01597c g     F .text	00000034 alt_irq_init
0d01b60c g     F .text	00000040 alt_tse_mac_get_common_speed
0d05cf70 g     O .bss	00000018 app_semaphore
0d0395ec g     F .text	00000060 alt_release_fd
0d029a98 g     F .text	00000078 post_app_sem
0d022628 g     F .text	000000b0 igmp_init
0d002d34 g     F .text	00000074 sprintf
0d04c5b8 g     O .rodata	00000100 __clz_tab
0d052ae8 g     O .bss	00000004 dsc_renew
0d0456ec g     F .text	00000080 md_fwrite
0d052a00 g     O .bss	00000004 _PathLocale
0d052b10 g     O .bss	00000004 tcp_sleep_count
0d02ab6c g     F .text	0000007c insque
0d049e2c g     F .text	00000014 atexit
0d052bdc g     O .bss	00000004 vfsfiles
0d00a518 g     F .text	00000078 _write_r
0d04a41c g     F .text	00000050 _vsprintf_r
0d0430e8 g     F .text	000002b8 udp_send
0d00e1ac g     F .text	0000008c OSSchedLock
0d022968 g     F .text	000002a8 igmp_send
0d008094 g     F .text	0000001c setlocale
0d00fc9c g     F .text	0000013c OSFlagCreate
0d0572fc g     O .bss	00002000 LEDManagementTaskStk
0d029644 g     F .text	00000044 irq_Unmask
0d02c678 g     F .text	000000e4 t_listen
0d052888 g     O .rwdata	00000004 _impure_ptr
0d0508a8 g     O .rwdata	00000018 ssstask
0d052a14 g     O .bss	00000004 alt_argc
0d037084 g     F .text	00000704 tcp_usrreq
0d037ce4 g     F .text	00000284 udp_usrreq
0d029fd8 g     F .text	00000054 ncpalloc
0d038ca8 g     F .text	00000064 _do_dtors
0d000000 g       *ABS*	00000000 __alt_mem_ssram32_0
0d0528c6 g     O .rwdata	00000002 OSEventMultiEn
0d0529b8 g     O .rwdata	00000004 pingdelay
0d03b524 g     F .text	00000074 arp_send_pending
0d05c520 g     O .bss	000000e0 tse_mac_if
0d0436cc g     F .text	000002f0 igmpv1_input
0d00a050 g     F .text	000001c4 __srefill_r
0d029d2c g     F .text	00000074 pre_task_setup
0d052b30 g     O .bss	00000004 rcvdq_sem_ptr
0d0238a8 g     F .text	0000012c bsd_getsockname
0d04055c g     F .text	00000148 ip_reasm_mark_compact_rfq
0d0019f0 g     F .text	00000144 FindLastFlashSectorOffset
0d00fdd8 g     F .text	000002a8 OSFlagDel
0d052a64 g     O .bss	00000004 OSEventFreeList
0d025654 g     F .text	00000044 dhc_set_callback
0d000120 g       .exceptions	00000000 alt_irq_entry
0d052b84 g     O .bss	00000004 arpcache
0d049754 g     F .text	00000350 icmp_destun
0d041afc g     F .text	00000070 lookup_mcast
0d048264 g     F .text	00000048 vfslookup
0d04144c g     F .text	00000430 ip_demux
0d008c24 g     F .text	00000080 __ulp
0d00a230 g     F .text	00000040 __isinfd
0d052b14 g     O .bss	00000004 tcp_wakeup_count
0d010318 g     F .text	00000644 OSFlagPend
0d052912 g     O .rwdata	00000002 OSTmrEn
0d0072a0 g     F .text	00000018 __fp_unlock_all
0d0299e4 g     F .text	000000b4 wait_app_sem
0d01960c g     F .text	00000058 altera_avalon_lcd_16207_write_fd
0d007444 g     F .text	00000064 fputc
0d052944 g     O .rwdata	00000004 ipmcfail_str
0d052b28 g     O .bss	00000004 memtrapsize
0d02a508 g     F .text	00000324 m_copy
0d05298c g     O .rwdata	00000008 alt_fs_list
0d05cfec g     O .bss	00000014 mfreeq
0d00f238 g     F .text	00000080 OS_StrCopy
0d02dde8 g     F .text	0000005c sobind
0d0454ac g     F .text	00000078 init_memdev
0d0529dc g     O .bss	00000001 to_ssstask
0d0166b8 g     F .text	00000048 alt_write_flash_command_32bit_device_8bit_mode
0d02abe8 g     F .text	00000124 nptcp_init
0d0528dc g     O .rwdata	00000002 OSMemNameSize
0d05ce40 g     O .bss	000000f0 global_TCPwakeup_set
0d03a024 g     F .text	0000001c OSInitHookEnd
0d030184 g     F .text	000000bc soisdisconnected
0d03b49c g     F .text	00000088 arp_free_pending
0d052908 g     O .rwdata	00000002 OSTCBPrioTblMax
0d008000 g     F .text	00000010 localeconv
0d02e064 g     F .text	000002f4 soclose
0d05cd30 g     O .bss	00000014 bigfreeq
0d052904 g     O .rwdata	00000002 OSTaskStatStkChkEn
0d0529b4 g     O .rwdata	00000004 prompt
0d05297c g     O .rwdata	00000004 tcp_keepidle
0d01eaf0 g     F .text	00000198 alt_tse_phy_set_adv_10
0d02ba64 g     F .text	000001d4 rawip_soinput
0d038da0 g     F .text	00000050 alt_ic_isr_register
0d047cb4 g     F .text	00000060 vfwrite
0d0528d8 g     O .rwdata	00000002 OSMemEn
0d03045c g     F .text	000000ac soqinsque
0d052bb8 g     O .bss	00000004 so_evtmap_delete
0d002598 g     F .text	00000040 fwrite
0d0528e2 g     O .rwdata	00000002 OSMutexEn
0d052ba4 g     O .bss	00000004 h_ireq
0d0529dc g       *ABS*	00000000 _edata
0d03df7c g     F .text	0000062c ip_fragment
0d021070 g     F .text	00000144 iniche_devices_init
0d05d000 g     O .bss	00000028 tcp_saveti
0d024a34 g     F .text	000000f8 con_page
0d05d61c g       *ABS*	00000000 _end
0d02fa0c g     F .text	00000540 sogetopt
0d00cddc g     F .text	0000007c alt_flash_open_dev
0d052a68 g     O .bss	00000001 OSIntNesting
0d01daac g     F .text	00000238 alt_tse_mac_associate_phy
0d0524bc g     O .rwdata	00000030 nettasks
0d028be4 g     F .text	00000020 pk_get_max_intrsafe_buf_len
0d03e90c g     F .text	0000026c iproute
0d02b530 g     F .text	000000e8 np_stripoptions
0d052bbc g     O .bss	00000001 so_evtmap
0d018048 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
0d007500 g     F .text	00000074 _fputs_r
0d0156a4 g     F .text	00000210 OSTimeDlyResume
0d001bdc g     F .text	000000c4 SSSCreateTasks
0d042324 g     F .text	00000428 add_route
0d0101c4 g     F .text	00000154 OSFlagNameSet
0d021f04 g     F .text	000000d0 c_older
0d030ea4 g     F .text	00000090 sbflush
0d04554c g     F .text	00000020 md_fclose
0d0252d4 g     F .text	0000002c tk_yield
0d001ea0 g     F .text	000000c0 sss_handle_accept
0d014e00 g     F .text	000001fc OSTaskStkChk
0d038e8c g     F .text	000000a0 alt_ic_irq_disable
0d02e5b8 g     F .text	00000608 sosend
0d0528de g     O .rwdata	00000002 OSMemSize
0d03e5a8 g     F .text	000000ac ip_mymach
0d019d94 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
0d00a380 g     F .text	0000007c __swrite
0d052afc g     O .bss	00000004 cticks_initialized
0d0529bc g     O .rwdata	00000004 deflength
0d02d4e0 g     F .text	0000022c t_sendto
0d052898 g     O .rwdata	00000004 __malloc_trim_threshold
0d002918 g     F .text	0000006c _perror_r
0d052a6c g     O .bss	00000004 OSTCBCur
0d02dc1c g     F .text	000001cc socreate
0d049e74 g     F .text	00000038 exit
0d05d298 g     O .bss	00000100 arp_table
0d052bf4 g     O .bss	00000004 icmpdu_hook
0d0528e0 g     O .rwdata	00000002 OSMemTblSize
0d007e6c g     F .text	000000c8 _fwalk_reent
0d03b178 g     F .text	00000024 create_apptasks
0d052978 g     O .rwdata	00000004 tcp_ttl
0d009220 g     F .text	0000018c __mdiff
0d00ce58 g     F .text	00000054 alt_flash_close_dev
0d02a02c g     F .text	0000004c ncpfree
0d00c740 g     F .text	00000060 __modsi3
0d052a88 g     O .bss	00000004 MaxLnh
0d01a854 g     F .text	00000054 tse_mac_setGMIImode
0d045d58 g     F .text	0000008c inet_ntop
0d043660 g     F .text	0000002c udp_maxalloc
0d01f530 g     F .text	000000f4 marvell_cfg_gmii
0d800000 g       *ABS*	00000000 __alt_data_end
0d000120 g     F .exceptions	00000000 alt_exception
0d0071e0 g     F .text	00000004 __sfp_lock_release
0d00dfdc g     F .text	00000054 OSInit
0d01dce4 g     F .text	00000120 alt_tse_phy_cfg_pcs
0d015228 g     F .text	00000144 OSTaskQuery
0d03aa38 g     F .text	00000088 icmp_port_du
0d052b58 g     O .bss	00000004 tcp_iss
0d012d34 g     F .text	000000ac OS_QInit
0d049e4c g     F .text	0000000c atoi
0d052968 g     O .rwdata	00000004 bigbufsiz
0d00f2b8 g     F .text	00000058 OS_StrLen
0d0367f4 g     F .text	00000080 tcp_putseq
0d0116d0 g     F .text	00000120 OSMemNameSet
0d04b97c g     O .rodata	00000101 _ctype_
0d030ab4 g     F .text	00000208 sbappendaddr
08000000 g       *ABS*	00000000 __alt_mem_ext_flash
0d052bec g     O .bss	00000004 vfs_total_rw_space
0d0448b4 g     F .text	00000140 ip_getmoptions
0d0528fa g     O .rwdata	00000002 OSTaskProfileEn
0d0433a0 g     F .text	00000130 udpswap
0d052a70 g     O .bss	00000004 OSTime
0d052b34 g     O .bss	00000004 nextslow
0d0368ec g     F .text	000002a0 tcp_slowtimo
0d0364fc g     F .text	00000118 tcp_newtcpcb
0d03c1e0 g     F .text	000001a8 send_via_arp
0d025598 g     F .text	000000bc dhc_init
0d03fef0 g     F .text	00000064 ip_reasm_find_ire
0d05ac7c g     O .bss	00000800 OSTaskIdleStk
0d04a7b8 g     F .text	0000002c _exit
0d048494 g     F .text	00000064 isvfile_locked
0d00a270 g     F .text	00000030 __isnand
0d023f40 g     F .text	00000158 bsd_select
0d0387dc g     F .text	00000154 alt_alarm_start
0d010080 g     F .text	00000144 OSFlagNameGet
0d04368c g     F .text	00000040 udp_free
0d028cb0 g     F .text	000000c8 getq
0d048608 g     F .text	00000024 prep_vfs
0d0158b4 g     F .text	00000064 OSTimeGet
0d0529b0 g     O .rwdata	00000004 name
0d031104 g     F .text	00000110 sbdropend
0d00c7b0 g     F .text	00000098 __muldi3
0d0080b0 g     F .text	00000194 __smakebuf_r
0d01683c g     F .text	00000030 alt_write_native_32bit
0d03c388 g     F .text	00000118 cb_arpent_tmo
0d00355c g     F .text	00000074 strlen
0d04417c g     F .text	00000148 IPADDR_TO_NETP
0d023db0 g     F .text	00000030 bsd_inet_ntoa
0d039fa8 g     F .text	0000001c OSTaskSwHook
0d039284 g     F .text	00000188 open
0d028f38 g     F .text	00000238 udp_open
0d05b47c g     O .bss	00000b40 OSEventTbl
0d030628 g     F .text	00000050 socantsendmore
0d052bf0 g     O .bss	00000004 vfs_total_dyna_files
0d00c1f0 g     F .text	00000088 __gedf2
0d05bfbc g     O .bss	00000510 OSTCBTbl
0d052b8c g     O .bss	00000004 arpReqsOut
0d0138a4 g     F .text	00000104 OSSemSet
0d0529d8 g     O .rwdata	00000004 http_root_path
0d027784 g     F .text	000002bc dhc_extract_opts
0d03f3cc g     F .text	00000590 ip_reasm_compute_overlap
0d015ff0 g     F .text	00000090 alt_flash_cfi_get_info
0d01a6c4 g     F .text	000000a4 tse_mac_aRxRead
0d002e08 g     F .text	000000e0 strchr
0d05cb1a g     O .bss	00000012 ipreturn
0d052bac g     O .bss	00000004 port_prep
0d05253f g     O .rwdata	0000000d tcp_backoff
0d02ff90 g     F .text	0000006c soisconnecting
0d000eac g     F .text	00000078 SSSInitialTask
0d007574 g     F .text	0000001c fputs
0d0529a4 g     O .rwdata	00000004 alt_priority_mask
0d043c68 g     F .text	0000024c igmpv2_process_query
0d0312a8 g     F .text	00000220 t_select
0d012fb4 g     F .text	000002a0 OSSemDel
0d038680 g     F .text	0000015c udp4_sockaddr
0d052a74 g     O .bss	00000004 OSFlagFreeList
0d0465d0 g     F .text	00000210 in_pcbconnect
0d052b4c g     O .bss	00000004 dropline
0d052ba8 g     O .bss	00000004 ire_cticks
0d038df0 g     F .text	0000009c alt_ic_irq_enable
0d0528c0 g     O .rwdata	00000002 OSEventNameSize
0d0054dc g     F .text	00000024 __vfprintf_internal
0d024e4c g     F .text	00000088 tk_netmain
0d0467e0 g     F .text	00000060 in_pcbdisconnect
0d052a78 g     O .bss	00000001 OSStatRdy
0d05c4cc g     O .bss	00000054 OSTCBPrioTbl
0d00d3d4 g     F .text	000000ac __env_lock
0d052906 g     O .rwdata	00000002 OSTaskSwHookEn
0d052718 g     O .rwdata	00000024 mdio
0d01b8fc g     F .text	000000ec alt_tse_mac_set_speed
0d019934 g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
0d023644 g     F .text	00000138 bsd_accept
0d052988 g     O .rwdata	00000004 tcp_recvspace
0d00b948 g     F .text	00000080 __subdf3
0d037a70 g     F .text	0000004c tcpinit
0d052aa8 g     O .bss	00000004 igmp_all_rtrs_group
0d02b9f4 g     F .text	00000070 rawip_lookup
0d03b21c g     F .text	000000b0 fcntl
0d008b00 g     F .text	000000c4 __lo0bits
0d030cbc g     F .text	000001e8 sbcompress
0d0529a8 g     O .rwdata	00000008 alt_alarm_list
0d036614 g     F .text	000000ac tcp_drop
0d0528ce g     O .rwdata	00000002 OSFlagWidth
0d038c44 g     F .text	00000064 _do_ctors
0d01e8e0 g     F .text	00000210 alt_tse_phy_set_adv_100
0d036be8 g     F .text	0000049c tcp_timers
0d022598 g     F .text	00000090 if_netnumber
0d0449f4 g     F .text	00000084 ip_freemoptions
0d02ff4c g     F .text	00000044 sohasoutofband
0d031fc4 g     F .text	00002554 tcp_input
0d02377c g     F .text	0000012c bsd_getpeername
0d023de0 g     F .text	00000160 bsd_recvfrom
0d02101c g     F .text	00000054 close
0d052ad8 g     O .bss	00000004 dsc_bpreplys
0d03a07c g     F .text	00000068 alt_program_amd
0d052a24 g     O .bss	00000004 alt_envsem
0d052a7c g     O .bss	00000004 OSIdleCtrRun
0d00e678 g     F .text	00000020 OSVersion
0d052918 g     O .rwdata	00000002 OSTmrCfgWheelSize
0d01536c g     F .text	0000007c OS_TaskStkClr
0d046b94 g     F .text	00000028 set_vfopen_error
0d00c8c8 g     F .text	00000314 __pack_d
0d0528f2 g     O .rwdata	00000002 OSTaskCreateEn
0d01b694 g     F .text	0000007c alt_tse_get_system_index
0d05251c g     O .rwdata	00000018 rawip_protosw
0d030700 g     F .text	00000068 sbwait
0d00ec68 g     F .text	00000068 OS_EventWaitListInit
0d027a40 g     F .text	0000059c dhc_second
0d01a39c g     F .text	000000ac alt_avalon_sgdma_init
0d052b78 g     O .bss	00000004 port_1s_callout
0d03a040 g     F .text	0000001c OSTaskIdleHook
0d049eac g     F .text	00000014 free
0d0071e4 g     F .text	00000004 __sinit_lock_acquire
0d052a84 g     O .bss	00000001 number_of_tse_mac
0d00971c g     F .text	00000100 __multadd
0d014ffc g     F .text	0000022c OSTaskSuspend
0d008a68 g     F .text	00000028 _Bfree
0d01a548 g     F .text	0000002c no_printf
0d030240 g     F .text	0000021c sonewconn
0d048b20 g     F .text	00000c34 icmprcv
0d02a118 g     F .text	000000d0 pffindproto
0d00f310 g     F .text	0000005c OS_TaskIdle
0d05291e g     O .rwdata	00000002 OSTmrTblSize
0d012bb4 g     F .text	00000180 OSQQuery



Disassembly of section .exceptions:

0d000120 <alt_exception>:
         * Process an exception.  For all exceptions we must preserve all
         * caller saved registers on the stack (See the Nios2 ABI
         * documentation for details).
         */

        addi  sp, sp, -76
 d000120:	deffed04 	addi	sp,sp,-76

#endif

#endif

        stw   ra,  0(sp)
 d000124:	dfc00015 	stw	ra,0(sp)
        /*
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */

        stw   r1,   8(sp)
 d000128:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 d00012c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 d000130:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 d000134:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 d000138:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 d00013c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 d000140:	d9c00815 	stw	r7,32(sp)

        rdctl r5, estatus
 d000144:	000b307a 	rdctl	r5,estatus

        stw   r8,  36(sp)
 d000148:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 d00014c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 d000150:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 d000154:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 d000158:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 d00015c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 d000160:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 d000164:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 d000168:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 d00016c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 d000170:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 d000174:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 d000178:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 d00017c:	10000326 	beq	r2,zero,d00018c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 d000180:	20000226 	beq	r4,zero,d00018c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 d000184:	d0001ec0 	call	d0001ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 d000188:	00000306 	br	d000198 <alt_exception+0x78>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 d00018c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 d000190:	e8bfff17 	ldw	r2,-4(ea)
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 d000194:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 d000198:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 d00019c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 d0001a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 d0001a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 d0001a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 d0001ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 d0001b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 d0001b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 d0001b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 d0001bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 d0001c0:	d9c00817 	ldw	r7,32(sp)
#ifdef ALT_STACK_CHECK
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif
#endif

        ldw   r8,  36(sp)
 d0001c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 d0001c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 d0001cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 d0001d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 d0001d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 d0001d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 d0001dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 d0001e0:	dbc01017 	ldw	r15,64(sp)
#endif

        ldw   sp,  76(sp)

#else
        addi  sp, sp, 76
 d0001e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 d0001e8:	ef80083a 	eret

0d0001ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 d0001ec:	defff904 	addi	sp,sp,-28
 d0001f0:	dfc00615 	stw	ra,24(sp)
 d0001f4:	df000515 	stw	fp,20(sp)
 d0001f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 d0001fc:	d00e0300 	call	d00e030 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 d000200:	0005313a 	rdctl	r2,ipending
 d000204:	e0bffc15 	stw	r2,-16(fp)

  return active;
 d000208:	e0bffc17 	ldw	r2,-16(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 d00020c:	e0bfff15 	stw	r2,-4(fp)

  do
  {
    i = 0;
 d000210:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 d000214:	00800044 	movi	r2,1
 d000218:	e0bffe15 	stw	r2,-8(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 d00021c:	e0ffff17 	ldw	r3,-4(fp)
 d000220:	e0bffe17 	ldw	r2,-8(fp)
 d000224:	1884703a 	and	r2,r3,r2
 d000228:	1005003a 	cmpeq	r2,r2,zero
 d00022c:	1000161e 	bne	r2,zero,d000288 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 d000230:	e0bffd17 	ldw	r2,-12(fp)
 d000234:	00c341b4 	movhi	r3,3334
 d000238:	18f44d04 	addi	r3,r3,-11980
 d00023c:	100490fa 	slli	r2,r2,3
 d000240:	10c5883a 	add	r2,r2,r3
 d000244:	11400017 	ldw	r5,0(r2)
 d000248:	e0bffd17 	ldw	r2,-12(fp)
 d00024c:	00c341b4 	movhi	r3,3334
 d000250:	18f44d04 	addi	r3,r3,-11980
 d000254:	100490fa 	slli	r2,r2,3
 d000258:	10c5883a 	add	r2,r2,r3
 d00025c:	10800104 	addi	r2,r2,4
 d000260:	11000017 	ldw	r4,0(r2)
 d000264:	283ee83a 	callr	r5
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 d000268:	0005313a 	rdctl	r2,ipending
 d00026c:	e0bffb15 	stw	r2,-20(fp)

  return active;
 d000270:	e0bffb17 	ldw	r2,-20(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 d000274:	e0bfff15 	stw	r2,-4(fp)
    
  } while (active);
 d000278:	e0bfff17 	ldw	r2,-4(fp)
 d00027c:	1004c03a 	cmpne	r2,r2,zero
 d000280:	103fe31e 	bne	r2,zero,d000210 <alt_irq_handler+0x24>
 d000284:	00000706 	br	d0002a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 d000288:	e0bffe17 	ldw	r2,-8(fp)
 d00028c:	1085883a 	add	r2,r2,r2
 d000290:	e0bffe15 	stw	r2,-8(fp)
      i++;
 d000294:	e0bffd17 	ldw	r2,-12(fp)
 d000298:	10800044 	addi	r2,r2,1
 d00029c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 d0002a0:	003fde06 	br	d00021c <alt_irq_handler+0x30>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 d0002a4:	d00e0ac0 	call	d00e0ac <OSIntExit>
}
 d0002a8:	e037883a 	mov	sp,fp
 d0002ac:	dfc00117 	ldw	ra,4(sp)
 d0002b0:	df000017 	ldw	fp,0(sp)
 d0002b4:	dec00204 	addi	sp,sp,8
 d0002b8:	f800283a 	ret

Disassembly of section .text:

0d0002bc <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 d0002bc:	00a00014 	movui	r2,32768
#endif

0:
    initd 0(r2)
 d0002c0:	10000033 	initd	0(r2)
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 d0002c4:	10bff804 	addi	r2,r2,-32
    bgt r2, zero, 0b
 d0002c8:	00bffd16 	blt	zero,r2,d0002c0 <_start+0x4>
#if (NIOS2_NUM_OF_SHADOW_REG_SETS == 0)    
    /*
     * Now that the caches are initialized, set up the stack pointer.
     * The value provided by the linker is assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 d0002cc:	06c36034 	movhi	sp,3456
    ori sp, sp, %lo(__alt_stack_pointer)
 d0002d0:	dec00014 	ori	sp,sp,0

    /* Set up the global pointer. */
    movhi gp, %hi(_gp)
 d0002d4:	06834174 	movhi	gp,3333
    ori gp, gp, %lo(_gp)
 d0002d8:	d6aa2114 	ori	gp,gp,43140
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 d0002dc:	00834174 	movhi	r2,3333
    ori r2, r2, %lo(__bss_start)
 d0002e0:	108a7714 	ori	r2,r2,10716

    movhi r3, %hi(__bss_end)
 d0002e4:	00c34174 	movhi	r3,3333
    ori r3, r3, %lo(__bss_end)
 d0002e8:	18f58714 	ori	r3,r3,54812

    beq r2, r3, 1f
 d0002ec:	10c00326 	beq	r2,r3,d0002fc <_start+0x40>

0:
    stw zero, (r2)
 d0002f0:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 d0002f4:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 d0002f8:	10fffd36 	bltu	r2,r3,d0002f0 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 d0002fc:	d00d2500 	call	d00d250 <alt_main>

0d000300 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 d000300:	003fff06 	br	d000300 <alt_after_alt_main>

0d000304 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 d000304:	defff904 	addi	sp,sp,-28
 d000308:	dfc00615 	stw	ra,24(sp)
 d00030c:	df000515 	stw	fp,20(sp)
 d000310:	df000504 	addi	fp,sp,20
 d000314:	e17ffd15 	stw	r5,-12(fp)
 d000318:	e13ffc05 	stb	r4,-16(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 d00031c:	e0bffc03 	ldbu	r2,-16(fp)
 d000320:	1005003a 	cmpeq	r2,r2,zero
 d000324:	10017b1e 	bne	r2,zero,d000914 <alt_uCOSIIErrorHandler+0x610>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 d000328:	00800084 	movi	r2,2
 d00032c:	e0bffb15 	stw	r2,-20(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 d000330:	d00e1ac0 	call	d00e1ac <OSSchedLock>
      
   switch (error_code)
 d000334:	e0bffc03 	ldbu	r2,-16(fp)
 d000338:	e0bffe15 	stw	r2,-8(fp)
 d00033c:	e0fffe17 	ldw	r3,-8(fp)
 d000340:	18800a20 	cmpeqi	r2,r3,40
 d000344:	1000371e 	bne	r2,zero,d000424 <alt_uCOSIIErrorHandler+0x120>
 d000348:	e0fffe17 	ldw	r3,-8(fp)
 d00034c:	18800a48 	cmpgei	r2,r3,41
 d000350:	10001a1e 	bne	r2,zero,d0003bc <alt_uCOSIIErrorHandler+0xb8>
 d000354:	e0fffe17 	ldw	r3,-8(fp)
 d000358:	18800120 	cmpeqi	r2,r3,4
 d00035c:	1000761e 	bne	r2,zero,d000538 <alt_uCOSIIErrorHandler+0x234>
 d000360:	e0fffe17 	ldw	r3,-8(fp)
 d000364:	18800148 	cmpgei	r2,r3,5
 d000368:	10000a1e 	bne	r2,zero,d000394 <alt_uCOSIIErrorHandler+0x90>
 d00036c:	e0fffe17 	ldw	r3,-8(fp)
 d000370:	188000a0 	cmpeqi	r2,r3,2
 d000374:	1000911e 	bne	r2,zero,d0005bc <alt_uCOSIIErrorHandler+0x2b8>
 d000378:	e0fffe17 	ldw	r3,-8(fp)
 d00037c:	188000c8 	cmpgei	r2,r3,3
 d000380:	1000771e 	bne	r2,zero,d000560 <alt_uCOSIIErrorHandler+0x25c>
 d000384:	e0fffe17 	ldw	r3,-8(fp)
 d000388:	18800060 	cmpeqi	r2,r3,1
 d00038c:	10005e1e 	bne	r2,zero,d000508 <alt_uCOSIIErrorHandler+0x204>
 d000390:	0000d806 	br	d0006f4 <alt_uCOSIIErrorHandler+0x3f0>
 d000394:	e0fffe17 	ldw	r3,-8(fp)
 d000398:	18800520 	cmpeqi	r2,r3,20
 d00039c:	10004f1e 	bne	r2,zero,d0004dc <alt_uCOSIIErrorHandler+0x1d8>
 d0003a0:	e0fffe17 	ldw	r3,-8(fp)
 d0003a4:	188007a0 	cmpeqi	r2,r3,30
 d0003a8:	1000ad1e 	bne	r2,zero,d000660 <alt_uCOSIIErrorHandler+0x35c>
 d0003ac:	e0fffe17 	ldw	r3,-8(fp)
 d0003b0:	188002a0 	cmpeqi	r2,r3,10
 d0003b4:	1000761e 	bne	r2,zero,d000590 <alt_uCOSIIErrorHandler+0x28c>
 d0003b8:	0000ce06 	br	d0006f4 <alt_uCOSIIErrorHandler+0x3f0>
 d0003bc:	e0fffe17 	ldw	r3,-8(fp)
 d0003c0:	18801020 	cmpeqi	r2,r3,64
 d0003c4:	10009c1e 	bne	r2,zero,d000638 <alt_uCOSIIErrorHandler+0x334>
 d0003c8:	e0fffe17 	ldw	r3,-8(fp)
 d0003cc:	18801048 	cmpgei	r2,r3,65
 d0003d0:	10000a1e 	bne	r2,zero,d0003fc <alt_uCOSIIErrorHandler+0xf8>
 d0003d4:	e0fffe17 	ldw	r3,-8(fp)
 d0003d8:	18800f60 	cmpeqi	r2,r3,61
 d0003dc:	10008b1e 	bne	r2,zero,d00060c <alt_uCOSIIErrorHandler+0x308>
 d0003e0:	e0fffe17 	ldw	r3,-8(fp)
 d0003e4:	18800fa0 	cmpeqi	r2,r3,62
 d0003e8:	10007e1e 	bne	r2,zero,d0005e4 <alt_uCOSIIErrorHandler+0x2e0>
 d0003ec:	e0fffe17 	ldw	r3,-8(fp)
 d0003f0:	18800aa0 	cmpeqi	r2,r3,42
 d0003f4:	1000151e 	bne	r2,zero,d00044c <alt_uCOSIIErrorHandler+0x148>
 d0003f8:	0000be06 	br	d0006f4 <alt_uCOSIIErrorHandler+0x3f0>
 d0003fc:	e0fffe17 	ldw	r3,-8(fp)
 d000400:	18801920 	cmpeqi	r2,r3,100
 d000404:	1000a11e 	bne	r2,zero,d00068c <alt_uCOSIIErrorHandler+0x388>
 d000408:	e0fffe17 	ldw	r3,-8(fp)
 d00040c:	18803fe0 	cmpeqi	r2,r3,255
 d000410:	1000aa1e 	bne	r2,zero,d0006bc <alt_uCOSIIErrorHandler+0x3b8>
 d000414:	e0fffe17 	ldw	r3,-8(fp)
 d000418:	188010a0 	cmpeqi	r2,r3,66
 d00041c:	10001d1e 	bne	r2,zero,d000494 <alt_uCOSIIErrorHandler+0x190>
 d000420:	0000b406 	br	d0006f4 <alt_uCOSIIErrorHandler+0x3f0>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 d000424:	00834174 	movhi	r2,3333
 d000428:	108a2204 	addi	r2,r2,10376
 d00042c:	10800017 	ldw	r2,0(r2)
 d000430:	11c00317 	ldw	r7,12(r2)
 d000434:	01034174 	movhi	r4,3333
 d000438:	212a1504 	addi	r4,r4,-22444
 d00043c:	01400044 	movi	r5,1
 d000440:	01800c44 	movi	r6,49
 d000444:	d0025980 	call	d002598 <fwrite>
         break;
 d000448:	0000c106 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 d00044c:	00834174 	movhi	r2,3333
 d000450:	108a2204 	addi	r2,r2,10376
 d000454:	10800017 	ldw	r2,0(r2)
 d000458:	11c00317 	ldw	r7,12(r2)
 d00045c:	01034174 	movhi	r4,3333
 d000460:	212a2204 	addi	r4,r4,-22392
 d000464:	01400044 	movi	r5,1
 d000468:	01800c44 	movi	r6,49
 d00046c:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 d000470:	00834174 	movhi	r2,3333
 d000474:	108a2204 	addi	r2,r2,10376
 d000478:	10800017 	ldw	r2,0(r2)
 d00047c:	11000317 	ldw	r4,12(r2)
 d000480:	01434174 	movhi	r5,3333
 d000484:	296a2f04 	addi	r5,r5,-22340
 d000488:	01800504 	movi	r6,20
 d00048c:	d00249c0 	call	d00249c <fprintf>
            OS_LOWEST_PRIO);
         break;
 d000490:	0000af06 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 d000494:	00834174 	movhi	r2,3333
 d000498:	108a2204 	addi	r2,r2,10376
 d00049c:	10800017 	ldw	r2,0(r2)
 d0004a0:	11c00317 	ldw	r7,12(r2)
 d0004a4:	01034174 	movhi	r4,3333
 d0004a8:	212a3c04 	addi	r4,r4,-22288
 d0004ac:	01400044 	movi	r5,1
 d0004b0:	01800a04 	movi	r6,40
 d0004b4:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 d0004b8:	00834174 	movhi	r2,3333
 d0004bc:	108a2204 	addi	r2,r2,10376
 d0004c0:	10800017 	ldw	r2,0(r2)
 d0004c4:	11000317 	ldw	r4,12(r2)
 d0004c8:	01434174 	movhi	r5,3333
 d0004cc:	296a4704 	addi	r5,r5,-22244
 d0004d0:	01800284 	movi	r6,10
 d0004d4:	d00249c0 	call	d00249c <fprintf>
         break;
 d0004d8:	00009d06 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_MBOX_FULL:
         fault_level = NONE;
 d0004dc:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 d0004e0:	00834174 	movhi	r2,3333
 d0004e4:	108a2204 	addi	r2,r2,10376
 d0004e8:	10800017 	ldw	r2,0(r2)
 d0004ec:	11c00317 	ldw	r7,12(r2)
 d0004f0:	01034174 	movhi	r4,3333
 d0004f4:	212a5004 	addi	r4,r4,-22208
 d0004f8:	01400044 	movi	r5,1
 d0004fc:	01800c84 	movi	r6,50
 d000500:	d0025980 	call	d002598 <fwrite>
         break;
 d000504:	00009206 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 d000508:	00800044 	movi	r2,1
 d00050c:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, 
 d000510:	00834174 	movhi	r2,3333
 d000514:	108a2204 	addi	r2,r2,10376
 d000518:	10800017 	ldw	r2,0(r2)
 d00051c:	11c00317 	ldw	r7,12(r2)
 d000520:	01034174 	movhi	r4,3333
 d000524:	212a5d04 	addi	r4,r4,-22156
 d000528:	01400044 	movi	r5,1
 d00052c:	01801244 	movi	r6,73
 d000530:	d0025980 	call	d002598 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 d000534:	00008606 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 d000538:	00834174 	movhi	r2,3333
 d00053c:	108a2204 	addi	r2,r2,10376
 d000540:	10800017 	ldw	r2,0(r2)
 d000544:	11c00317 	ldw	r7,12(r2)
 d000548:	01034174 	movhi	r4,3333
 d00054c:	212a7004 	addi	r4,r4,-22080
 d000550:	01400044 	movi	r5,1
 d000554:	01800c44 	movi	r6,49
 d000558:	d0025980 	call	d002598 <fwrite>
         break;
 d00055c:	00007c06 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 d000560:	00800044 	movi	r2,1
 d000564:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 d000568:	00834174 	movhi	r2,3333
 d00056c:	108a2204 	addi	r2,r2,10376
 d000570:	10800017 	ldw	r2,0(r2)
 d000574:	11c00317 	ldw	r7,12(r2)
 d000578:	01034174 	movhi	r4,3333
 d00057c:	212a7d04 	addi	r4,r4,-22028
 d000580:	01400044 	movi	r5,1
 d000584:	01800a44 	movi	r6,41
 d000588:	d0025980 	call	d002598 <fwrite>
         break;
 d00058c:	00007006 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TIMEOUT:
         fault_level = NONE;
 d000590:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 d000594:	00834174 	movhi	r2,3333
 d000598:	108a2204 	addi	r2,r2,10376
 d00059c:	10800017 	ldw	r2,0(r2)
 d0005a0:	11c00317 	ldw	r7,12(r2)
 d0005a4:	01034174 	movhi	r4,3333
 d0005a8:	212a8804 	addi	r4,r4,-21984
 d0005ac:	01400044 	movi	r5,1
 d0005b0:	01800a04 	movi	r6,40
 d0005b4:	d0025980 	call	d002598 <fwrite>
         break;
 d0005b8:	00006506 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 d0005bc:	00834174 	movhi	r2,3333
 d0005c0:	108a2204 	addi	r2,r2,10376
 d0005c4:	10800017 	ldw	r2,0(r2)
 d0005c8:	11c00317 	ldw	r7,12(r2)
 d0005cc:	01034174 	movhi	r4,3333
 d0005d0:	212a9304 	addi	r4,r4,-21940
 d0005d4:	01400044 	movi	r5,1
 d0005d8:	01800b04 	movi	r6,44
 d0005dc:	d0025980 	call	d002598 <fwrite>
         break;
 d0005e0:	00005b06 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 d0005e4:	00834174 	movhi	r2,3333
 d0005e8:	108a2204 	addi	r2,r2,10376
 d0005ec:	10800017 	ldw	r2,0(r2)
 d0005f0:	11c00317 	ldw	r7,12(r2)
 d0005f4:	01034174 	movhi	r4,3333
 d0005f8:	212a9f04 	addi	r4,r4,-21892
 d0005fc:	01400044 	movi	r5,1
 d000600:	01800884 	movi	r6,34
 d000604:	d0025980 	call	d002598 <fwrite>
         break;
 d000608:	00005106 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 d00060c:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 d000610:	00834174 	movhi	r2,3333
 d000614:	108a2204 	addi	r2,r2,10376
 d000618:	10800017 	ldw	r2,0(r2)
 d00061c:	11c00317 	ldw	r7,12(r2)
 d000620:	01034174 	movhi	r4,3333
 d000624:	212aa804 	addi	r4,r4,-21856
 d000628:	01400044 	movi	r5,1
 d00062c:	01800bc4 	movi	r6,47
 d000630:	d0025980 	call	d002598 <fwrite>
         break;
 d000634:	00004606 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 d000638:	00834174 	movhi	r2,3333
 d00063c:	108a2204 	addi	r2,r2,10376
 d000640:	10800017 	ldw	r2,0(r2)
 d000644:	11c00317 	ldw	r7,12(r2)
 d000648:	01034174 	movhi	r4,3333
 d00064c:	212ab404 	addi	r4,r4,-21808
 d000650:	01400044 	movi	r5,1
 d000654:	018009c4 	movi	r6,39
 d000658:	d0025980 	call	d002598 <fwrite>
         break;
 d00065c:	00003c06 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_Q_FULL:
         fault_level = NONE;
 d000660:	e03ffb15 	stw	zero,-20(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 d000664:	00834174 	movhi	r2,3333
 d000668:	108a2204 	addi	r2,r2,10376
 d00066c:	10800017 	ldw	r2,0(r2)
 d000670:	11c00317 	ldw	r7,12(r2)
 d000674:	01034174 	movhi	r4,3333
 d000678:	212abe04 	addi	r4,r4,-21768
 d00067c:	01400044 	movi	r5,1
 d000680:	01800a84 	movi	r6,42
 d000684:	d0025980 	call	d002598 <fwrite>
         break;
 d000688:	00003106 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 d00068c:	00800044 	movi	r2,1
 d000690:	e0bffb15 	stw	r2,-20(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 d000694:	00834174 	movhi	r2,3333
 d000698:	108a2204 	addi	r2,r2,10376
 d00069c:	10800017 	ldw	r2,0(r2)
 d0006a0:	11c00317 	ldw	r7,12(r2)
 d0006a4:	01034174 	movhi	r4,3333
 d0006a8:	212ac904 	addi	r4,r4,-21724
 d0006ac:	01400044 	movi	r5,1
 d0006b0:	01800c04 	movi	r6,48
 d0006b4:	d0025980 	call	d002598 <fwrite>
         break;
 d0006b8:	00002506 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 d0006bc:	00800084 	movi	r2,2
 d0006c0:	e0bffb15 	stw	r2,-20(fp)
         printf(
 d0006c4:	01034174 	movhi	r4,3333
 d0006c8:	212ad604 	addi	r4,r4,-21672
 d0006cc:	d0029980 	call	d002998 <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 d0006d0:	00834174 	movhi	r2,3333
 d0006d4:	108a2204 	addi	r2,r2,10376
 d0006d8:	10800017 	ldw	r2,0(r2)
 d0006dc:	11000317 	ldw	r4,12(r2)
 d0006e0:	e1bffd17 	ldw	r6,-12(fp)
 d0006e4:	01434174 	movhi	r5,3333
 d0006e8:	296ae604 	addi	r5,r5,-21608
 d0006ec:	d00249c0 	call	d00249c <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 d0006f0:	00001706 	br	d000750 <alt_uCOSIIErrorHandler+0x44c>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 d0006f4:	01034174 	movhi	r4,3333
 d0006f8:	212af104 	addi	r4,r4,-21564
 d0006fc:	d002cc00 	call	d002cc0 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 d000700:	00834174 	movhi	r2,3333
 d000704:	108a2204 	addi	r2,r2,10376
 d000708:	10800017 	ldw	r2,0(r2)
 d00070c:	11c00317 	ldw	r7,12(r2)
 d000710:	01034174 	movhi	r4,3333
 d000714:	212aff04 	addi	r4,r4,-21508
 d000718:	01400044 	movi	r5,1
 d00071c:	01800404 	movi	r6,16
 d000720:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 d000724:	00834174 	movhi	r2,3333
 d000728:	108a2204 	addi	r2,r2,10376
 d00072c:	10800017 	ldw	r2,0(r2)
 d000730:	11000317 	ldw	r4,12(r2)
 d000734:	e1bffc03 	ldbu	r6,-16(fp)
 d000738:	01434174 	movhi	r5,3333
 d00073c:	296b0404 	addi	r5,r5,-21488
 d000740:	d00249c0 	call	d00249c <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 d000744:	01034174 	movhi	r4,3333
 d000748:	212b0904 	addi	r4,r4,-21468
 d00074c:	d0029840 	call	d002984 <perror>

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 d000750:	e0bffb17 	ldw	r2,-20(fp)
 d000754:	e0bfff15 	stw	r2,-4(fp)
 d000758:	e0ffff17 	ldw	r3,-4(fp)
 d00075c:	18800060 	cmpeqi	r2,r3,1
 d000760:	1000071e 	bne	r2,zero,d000780 <alt_uCOSIIErrorHandler+0x47c>
 d000764:	e0ffff17 	ldw	r3,-4(fp)
 d000768:	18800070 	cmpltui	r2,r3,1
 d00076c:	10003f1e 	bne	r2,zero,d00086c <alt_uCOSIIErrorHandler+0x568>
 d000770:	e0ffff17 	ldw	r3,-4(fp)
 d000774:	188000a0 	cmpeqi	r2,r3,2
 d000778:	10001d1e 	bne	r2,zero,d0007f0 <alt_uCOSIIErrorHandler+0x4ec>
 d00077c:	00005806 	br	d0008e0 <alt_uCOSIIErrorHandler+0x5dc>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 d000780:	01034174 	movhi	r4,3333
 d000784:	212b1704 	addi	r4,r4,-21412
 d000788:	d0029980 	call	d002998 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 d00078c:	00834174 	movhi	r2,3333
 d000790:	108a2204 	addi	r2,r2,10376
 d000794:	10800017 	ldw	r2,0(r2)
 d000798:	11c00317 	ldw	r7,12(r2)
 d00079c:	01034174 	movhi	r4,3333
 d0007a0:	212b2404 	addi	r4,r4,-21360
 d0007a4:	01400044 	movi	r5,1
 d0007a8:	01800904 	movi	r6,36
 d0007ac:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 d0007b0:	00834174 	movhi	r2,3333
 d0007b4:	108a2204 	addi	r2,r2,10376
 d0007b8:	10800017 	ldw	r2,0(r2)
 d0007bc:	11c00317 	ldw	r7,12(r2)
 d0007c0:	01034174 	movhi	r4,3333
 d0007c4:	212b2e04 	addi	r4,r4,-21320
 d0007c8:	01400044 	movi	r5,1
 d0007cc:	01800a04 	movi	r6,40
 d0007d0:	d0025980 	call	d002598 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 d0007d4:	d00e2380 	call	d00e238 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 d0007d8:	01003fc4 	movi	r4,255
 d0007dc:	d0142f00 	call	d0142f0 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 d0007e0:	e13ffc03 	ldbu	r4,-16(fp)
 d0007e4:	000b883a 	mov	r5,zero
 d0007e8:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
         break;
 d0007ec:	00004806 	br	d000910 <alt_uCOSIIErrorHandler+0x60c>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 d0007f0:	01034174 	movhi	r4,3333
 d0007f4:	212b3904 	addi	r4,r4,-21276
 d0007f8:	d0029980 	call	d002998 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 d0007fc:	00834174 	movhi	r2,3333
 d000800:	108a2204 	addi	r2,r2,10376
 d000804:	10800017 	ldw	r2,0(r2)
 d000808:	11c00317 	ldw	r7,12(r2)
 d00080c:	01034174 	movhi	r4,3333
 d000810:	212b4704 	addi	r4,r4,-21220
 d000814:	01400044 	movi	r5,1
 d000818:	01800984 	movi	r6,38
 d00081c:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 d000820:	00834174 	movhi	r2,3333
 d000824:	108a2204 	addi	r2,r2,10376
 d000828:	10800017 	ldw	r2,0(r2)
 d00082c:	11c00317 	ldw	r7,12(r2)
 d000830:	01034174 	movhi	r4,3333
 d000834:	212b5104 	addi	r4,r4,-21180
 d000838:	01400044 	movi	r5,1
 d00083c:	01800bc4 	movi	r6,47
 d000840:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 d000844:	00834174 	movhi	r2,3333
 d000848:	108a2204 	addi	r2,r2,10376
 d00084c:	10800017 	ldw	r2,0(r2)
 d000850:	11c00317 	ldw	r7,12(r2)
 d000854:	01034174 	movhi	r4,3333
 d000858:	212b5d04 	addi	r4,r4,-21132
 d00085c:	01400044 	movi	r5,1
 d000860:	01800cc4 	movi	r6,51
 d000864:	d0025980 	call	d002598 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 d000868:	003fff06 	br	d000868 <alt_uCOSIIErrorHandler+0x564>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 d00086c:	00834174 	movhi	r2,3333
 d000870:	108a2204 	addi	r2,r2,10376
 d000874:	10800017 	ldw	r2,0(r2)
 d000878:	11c00317 	ldw	r7,12(r2)
 d00087c:	01034174 	movhi	r4,3333
 d000880:	212b6a04 	addi	r4,r4,-21080
 d000884:	01400044 	movi	r5,1
 d000888:	01800904 	movi	r6,36
 d00088c:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 d000890:	00834174 	movhi	r2,3333
 d000894:	108a2204 	addi	r2,r2,10376
 d000898:	10800017 	ldw	r2,0(r2)
 d00089c:	11c00317 	ldw	r7,12(r2)
 d0008a0:	01034174 	movhi	r4,3333
 d0008a4:	212b7404 	addi	r4,r4,-21040
 d0008a8:	01400044 	movi	r5,1
 d0008ac:	01800c84 	movi	r6,50
 d0008b0:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, 
 d0008b4:	00834174 	movhi	r2,3333
 d0008b8:	108a2204 	addi	r2,r2,10376
 d0008bc:	10800017 	ldw	r2,0(r2)
 d0008c0:	11c00317 	ldw	r7,12(r2)
 d0008c4:	01034174 	movhi	r4,3333
 d0008c8:	212b8104 	addi	r4,r4,-20988
 d0008cc:	01400044 	movi	r5,1
 d0008d0:	01800f84 	movi	r6,62
 d0008d4:	d0025980 	call	d002598 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 d0008d8:	d00e2380 	call	d00e238 <OSSchedUnlock>
         return;   
 d0008dc:	00000d06 	br	d000914 <alt_uCOSIIErrorHandler+0x610>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 d0008e0:	01034174 	movhi	r4,3333
 d0008e4:	212b9104 	addi	r4,r4,-20924
 d0008e8:	d002cc00 	call	d002cc0 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 d0008ec:	00834174 	movhi	r2,3333
 d0008f0:	108a2204 	addi	r2,r2,10376
 d0008f4:	10800017 	ldw	r2,0(r2)
 d0008f8:	11c00317 	ldw	r7,12(r2)
 d0008fc:	01034174 	movhi	r4,3333
 d000900:	212b9f04 	addi	r4,r4,-20868
 d000904:	01400044 	movi	r5,1
 d000908:	01800ac4 	movi	r6,43
 d00090c:	d0025980 	call	d002598 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 d000910:	003fff06 	br	d000910 <alt_uCOSIIErrorHandler+0x60c>
}
 d000914:	e037883a 	mov	sp,fp
 d000918:	dfc00117 	ldw	ra,4(sp)
 d00091c:	df000017 	ldw	fp,0(sp)
 d000920:	dec00204 	addi	sp,sp,8
 d000924:	f800283a 	ret

0d000928 <alt_NetworkErrorHandler>:

void alt_NetworkErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 d000928:	defffa04 	addi	sp,sp,-24
 d00092c:	dfc00515 	stw	ra,20(sp)
 d000930:	df000415 	stw	fp,16(sp)
 d000934:	df000404 	addi	fp,sp,16
 d000938:	e17ffe15 	stw	r5,-8(fp)
 d00093c:	e13ffd05 	stb	r4,-12(fp)
   FAULT_LEVEL fault_level;

   if(error_code == OS_NO_ERR)
 d000940:	e0bffd03 	ldbu	r2,-12(fp)
 d000944:	1005003a 	cmpeq	r2,r2,zero
 d000948:	1000981e 	bne	r2,zero,d000bac <alt_NetworkErrorHandler+0x284>
   {
      return;
   }

   fault_level = SYSTEM;   
 d00094c:	00800084 	movi	r2,2
 d000950:	e0bffc15 	stw	r2,-16(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */  
 d000954:	d00e1ac0 	call	d00e1ac <OSSchedLock>

   if (error_code == EXPANDED_DIAGNOSIS_CODE) 
 d000958:	e0bffd03 	ldbu	r2,-12(fp)
 d00095c:	10803fd8 	cmpnei	r2,r2,255
 d000960:	1000111e 	bne	r2,zero,d0009a8 <alt_NetworkErrorHandler+0x80>
   {
      fault_level = SYSTEM;
 d000964:	00800084 	movi	r2,2
 d000968:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR for expanded diagnosis translation.");    
 d00096c:	01034174 	movhi	r4,3333
 d000970:	212baa04 	addi	r4,r4,-20824
 d000974:	d0029980 	call	d002998 <printf>
      fprintf(stderr, "\n[Network]: %s", (char *)expanded_diagnosis_ptr);
 d000978:	00834174 	movhi	r2,3333
 d00097c:	108a2204 	addi	r2,r2,10376
 d000980:	10800017 	ldw	r2,0(r2)
 d000984:	11000317 	ldw	r4,12(r2)
 d000988:	e1bffe17 	ldw	r6,-8(fp)
 d00098c:	01434174 	movhi	r5,3333
 d000990:	296bb904 	addi	r5,r5,-20764
 d000994:	d00249c0 	call	d00249c <fprintf>
      /* Check errno also in case it has been set. */
      perror("\n[Network]:  ERRNO: ");
 d000998:	01034174 	movhi	r4,3333
 d00099c:	212bbd04 	addi	r4,r4,-20748
 d0009a0:	d0029840 	call	d002984 <perror>
 d0009a4:	00001006 	br	d0009e8 <alt_NetworkErrorHandler+0xc0>
   }
   else 
   {
      fault_level = TASK;
 d0009a8:	00800044 	movi	r2,1
 d0009ac:	e0bffc15 	stw	r2,-16(fp)
      printf("\n[Network]: See STDERR.\n");    
 d0009b0:	01034174 	movhi	r4,3333
 d0009b4:	212bc304 	addi	r4,r4,-20724
 d0009b8:	d002cc00 	call	d002cc0 <puts>
      fprintf(stderr, "\n[Network]: Error_code %d!\n", error_code);        
 d0009bc:	00834174 	movhi	r2,3333
 d0009c0:	108a2204 	addi	r2,r2,10376
 d0009c4:	10800017 	ldw	r2,0(r2)
 d0009c8:	11000317 	ldw	r4,12(r2)
 d0009cc:	e1bffd03 	ldbu	r6,-12(fp)
 d0009d0:	01434174 	movhi	r5,3333
 d0009d4:	296bc904 	addi	r5,r5,-20700
 d0009d8:	d00249c0 	call	d00249c <fprintf>
      perror("\n[Network]:  ERRNO: ");
 d0009dc:	01034174 	movhi	r4,3333
 d0009e0:	212bbd04 	addi	r4,r4,-20748
 d0009e4:	d0029840 	call	d002984 <perror>
   }

   /* Process error based on fault level, reenable scheduler if appropriate. */     
   switch (fault_level) 
 d0009e8:	e0bffc17 	ldw	r2,-16(fp)
 d0009ec:	e0bfff15 	stw	r2,-4(fp)
 d0009f0:	e0ffff17 	ldw	r3,-4(fp)
 d0009f4:	18800060 	cmpeqi	r2,r3,1
 d0009f8:	1000071e 	bne	r2,zero,d000a18 <alt_NetworkErrorHandler+0xf0>
 d0009fc:	e0ffff17 	ldw	r3,-4(fp)
 d000a00:	18800070 	cmpltui	r2,r3,1
 d000a04:	10003f1e 	bne	r2,zero,d000b04 <alt_NetworkErrorHandler+0x1dc>
 d000a08:	e0ffff17 	ldw	r3,-4(fp)
 d000a0c:	188000a0 	cmpeqi	r2,r3,2
 d000a10:	10001d1e 	bne	r2,zero,d000a88 <alt_NetworkErrorHandler+0x160>
 d000a14:	00005806 	br	d000b78 <alt_NetworkErrorHandler+0x250>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is TASK).");
 d000a18:	01034174 	movhi	r4,3333
 d000a1c:	212bd004 	addi	r4,r4,-20672
 d000a20:	d0029980 	call	d002998 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is TASK");
 d000a24:	00834174 	movhi	r2,3333
 d000a28:	108a2204 	addi	r2,r2,10376
 d000a2c:	10800017 	ldw	r2,0(r2)
 d000a30:	11c00317 	ldw	r7,12(r2)
 d000a34:	01034174 	movhi	r4,3333
 d000a38:	212bdc04 	addi	r4,r4,-20624
 d000a3c:	01400044 	movi	r5,1
 d000a40:	018007c4 	movi	r6,31
 d000a44:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[Network]: Task is being deleted.\n");
 d000a48:	00834174 	movhi	r2,3333
 d000a4c:	108a2204 	addi	r2,r2,10376
 d000a50:	10800017 	ldw	r2,0(r2)
 d000a54:	11c00317 	ldw	r7,12(r2)
 d000a58:	01034174 	movhi	r4,3333
 d000a5c:	212be404 	addi	r4,r4,-20592
 d000a60:	01400044 	movi	r5,1
 d000a64:	018008c4 	movi	r6,35
 d000a68:	d0025980 	call	d002598 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 d000a6c:	d00e2380 	call	d00e238 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 d000a70:	01003fc4 	movi	r4,255
 d000a74:	d0142f00 	call	d0142f0 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 d000a78:	e13ffd03 	ldbu	r4,-12(fp)
 d000a7c:	000b883a 	mov	r5,zero
 d000a80:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
         break;
 d000a84:	00004806 	br	d000ba8 <alt_NetworkErrorHandler+0x280>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[Network]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 d000a88:	01034174 	movhi	r4,3333
 d000a8c:	212bed04 	addi	r4,r4,-20556
 d000a90:	d0029980 	call	d002998 <printf>
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is SYSTEM.");
 d000a94:	00834174 	movhi	r2,3333
 d000a98:	108a2204 	addi	r2,r2,10376
 d000a9c:	10800017 	ldw	r2,0(r2)
 d000aa0:	11c00317 	ldw	r7,12(r2)
 d000aa4:	01034174 	movhi	r4,3333
 d000aa8:	212bf904 	addi	r4,r4,-20508
 d000aac:	01400044 	movi	r5,1
 d000ab0:	01800884 	movi	r6,34
 d000ab4:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[Network]: FATAL Error, Restart required.");
 d000ab8:	00834174 	movhi	r2,3333
 d000abc:	108a2204 	addi	r2,r2,10376
 d000ac0:	10800017 	ldw	r2,0(r2)
 d000ac4:	11c00317 	ldw	r7,12(r2)
 d000ac8:	01034174 	movhi	r4,3333
 d000acc:	212c0204 	addi	r4,r4,-20472
 d000ad0:	01400044 	movi	r5,1
 d000ad4:	01800a84 	movi	r6,42
 d000ad8:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[Network]: Locking scheduler - endless loop.\n");
 d000adc:	00834174 	movhi	r2,3333
 d000ae0:	108a2204 	addi	r2,r2,10376
 d000ae4:	10800017 	ldw	r2,0(r2)
 d000ae8:	11c00317 	ldw	r7,12(r2)
 d000aec:	01034174 	movhi	r4,3333
 d000af0:	212c0d04 	addi	r4,r4,-20428
 d000af4:	01400044 	movi	r5,1
 d000af8:	01800b84 	movi	r6,46
 d000afc:	d0025980 	call	d002598 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 d000b00:	003fff06 	br	d000b00 <alt_NetworkErrorHandler+0x1d8>
         break;
      case NONE:
         fprintf(stderr, "\n[Network]: FAULT_LEVEL is NONE.");
 d000b04:	00834174 	movhi	r2,3333
 d000b08:	108a2204 	addi	r2,r2,10376
 d000b0c:	10800017 	ldw	r2,0(r2)
 d000b10:	11c00317 	ldw	r7,12(r2)
 d000b14:	01034174 	movhi	r4,3333
 d000b18:	212c1904 	addi	r4,r4,-20380
 d000b1c:	01400044 	movi	r5,1
 d000b20:	01800804 	movi	r6,32
 d000b24:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[Network]: Informational "
 d000b28:	00834174 	movhi	r2,3333
 d000b2c:	108a2204 	addi	r2,r2,10376
 d000b30:	10800017 	ldw	r2,0(r2)
 d000b34:	11c00317 	ldw	r7,12(r2)
 d000b38:	01034174 	movhi	r4,3333
 d000b3c:	212c2204 	addi	r4,r4,-20344
 d000b40:	01400044 	movi	r5,1
 d000b44:	01800d84 	movi	r6,54
 d000b48:	d0025980 	call	d002598 <fwrite>
                         "error only, control returned");
         fprintf(stderr, 
 d000b4c:	00834174 	movhi	r2,3333
 d000b50:	108a2204 	addi	r2,r2,10376
 d000b54:	10800017 	ldw	r2,0(r2)
 d000b58:	11c00317 	ldw	r7,12(r2)
 d000b5c:	01034174 	movhi	r4,3333
 d000b60:	212c3004 	addi	r4,r4,-20288
 d000b64:	01400044 	movi	r5,1
 d000b68:	01800e44 	movi	r6,57
 d000b6c:	d0025980 	call	d002598 <fwrite>
            "to task to complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 d000b70:	d00e2380 	call	d00e238 <OSSchedUnlock>
         return;
 d000b74:	00000d06 	br	d000bac <alt_NetworkErrorHandler+0x284>
         break;         
      default:
         printf("\n[Network]: See STDERR (FAULT_LEVEL is unknown).\n");    
 d000b78:	01034174 	movhi	r4,3333
 d000b7c:	212c3f04 	addi	r4,r4,-20228
 d000b80:	d002cc00 	call	d002cc0 <puts>
         fprintf(stderr, "\n[Network] FAULT_LEVEL is unknown !?!\n");
 d000b84:	00834174 	movhi	r2,3333
 d000b88:	108a2204 	addi	r2,r2,10376
 d000b8c:	10800017 	ldw	r2,0(r2)
 d000b90:	11c00317 	ldw	r7,12(r2)
 d000b94:	01034174 	movhi	r4,3333
 d000b98:	212c4c04 	addi	r4,r4,-20176
 d000b9c:	01400044 	movi	r5,1
 d000ba0:	01800984 	movi	r6,38
 d000ba4:	d0025980 	call	d002598 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 d000ba8:	003fff06 	br	d000ba8 <alt_NetworkErrorHandler+0x280>
}
 d000bac:	e037883a 	mov	sp,fp
 d000bb0:	dfc00117 	ldw	ra,4(sp)
 d000bb4:	df000017 	ldw	fp,0(sp)
 d000bb8:	dec00204 	addi	sp,sp,8
 d000bbc:	f800283a 	ret

0d000bc0 <alt_SSSErrorHandler>:
   
   
void alt_SSSErrorHandler(INT8U error_code, 
                         void *expanded_diagnosis_ptr)
{
 d000bc0:	defff804 	addi	sp,sp,-32
 d000bc4:	dfc00715 	stw	ra,28(sp)
 d000bc8:	df000615 	stw	fp,24(sp)
 d000bcc:	df000604 	addi	fp,sp,24
 d000bd0:	e17ffc15 	stw	r5,-16(fp)
 d000bd4:	e13ffb05 	stb	r4,-20(fp)
   FAULT_LEVEL fault_level;
   
   if   (error_code == OS_NO_ERR)
 d000bd8:	e0bffb03 	ldbu	r2,-20(fp)
 d000bdc:	1005003a 	cmpeq	r2,r2,zero
 d000be0:	1000ad1e 	bne	r2,zero,d000e98 <alt_SSSErrorHandler+0x2d8>
   {
      return;
   }

   fault_level = (error_code == OS_NO_ERR) ? NONE : SYSTEM;
 d000be4:	e0bffb03 	ldbu	r2,-20(fp)
 d000be8:	1004c03a 	cmpne	r2,r2,zero
 d000bec:	1000021e 	bne	r2,zero,d000bf8 <alt_SSSErrorHandler+0x38>
 d000bf0:	e03ffe15 	stw	zero,-8(fp)
 d000bf4:	00000206 	br	d000c00 <alt_SSSErrorHandler+0x40>
 d000bf8:	00800084 	movi	r2,2
 d000bfc:	e0bffe15 	stw	r2,-8(fp)
 d000c00:	e0fffe17 	ldw	r3,-8(fp)
 d000c04:	e0fffa15 	stw	r3,-24(fp)
   
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 d000c08:	d00e1ac0 	call	d00e1ac <OSSchedLock>
   switch (error_code)
 d000c0c:	e0bffb03 	ldbu	r2,-20(fp)
 d000c10:	e0bffd15 	stw	r2,-12(fp)
 d000c14:	e0fffd17 	ldw	r3,-12(fp)
 d000c18:	188007a0 	cmpeqi	r2,r3,30
 d000c1c:	1000121e 	bne	r2,zero,d000c68 <alt_SSSErrorHandler+0xa8>
 d000c20:	e0fffd17 	ldw	r3,-12(fp)
 d000c24:	18803fe0 	cmpeqi	r2,r3,255
 d000c28:	1000011e 	bne	r2,zero,d000c30 <alt_SSSErrorHandler+0x70>
 d000c2c:	00001906 	br	d000c94 <alt_SSSErrorHandler+0xd4>
   {
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 d000c30:	00800084 	movi	r2,2
 d000c34:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR for expanded diagnosis translation.");    
 d000c38:	01034174 	movhi	r4,3333
 d000c3c:	212c5604 	addi	r4,r4,-20136
 d000c40:	d0029980 	call	d002998 <printf>
         fprintf(stderr, "\n[SSS]: %s", (char *)expanded_diagnosis_ptr);
 d000c44:	00834174 	movhi	r2,3333
 d000c48:	108a2204 	addi	r2,r2,10376
 d000c4c:	10800017 	ldw	r2,0(r2)
 d000c50:	11000317 	ldw	r4,12(r2)
 d000c54:	e1bffc17 	ldw	r6,-16(fp)
 d000c58:	01434174 	movhi	r5,3333
 d000c5c:	296c6404 	addi	r5,r5,-20080
 d000c60:	d00249c0 	call	d00249c <fprintf>
         break;
 d000c64:	00001b06 	br	d000cd4 <alt_SSSErrorHandler+0x114>
         
      case OS_Q_FULL:
         fault_level = NONE;
 d000c68:	e03ffa15 	stw	zero,-24(fp)
         fprintf(stderr,"\n[SSS]: Attempted to post to a full message queue.");
 d000c6c:	00834174 	movhi	r2,3333
 d000c70:	108a2204 	addi	r2,r2,10376
 d000c74:	10800017 	ldw	r2,0(r2)
 d000c78:	11c00317 	ldw	r7,12(r2)
 d000c7c:	01034174 	movhi	r4,3333
 d000c80:	212c6704 	addi	r4,r4,-20068
 d000c84:	01400044 	movi	r5,1
 d000c88:	01800c84 	movi	r6,50
 d000c8c:	d0025980 	call	d002598 <fwrite>
         break;
 d000c90:	00001006 	br	d000cd4 <alt_SSSErrorHandler+0x114>
      
      default:
         fault_level = SYSTEM;
 d000c94:	00800084 	movi	r2,2
 d000c98:	e0bffa15 	stw	r2,-24(fp)
         printf("\n[SSS]: See STDERR.\n");    
 d000c9c:	01034174 	movhi	r4,3333
 d000ca0:	212c7404 	addi	r4,r4,-20016
 d000ca4:	d002cc00 	call	d002cc0 <puts>
         fprintf(stderr, "\n[SSS]: Error_code %d!", error_code);        
 d000ca8:	00834174 	movhi	r2,3333
 d000cac:	108a2204 	addi	r2,r2,10376
 d000cb0:	10800017 	ldw	r2,0(r2)
 d000cb4:	11000317 	ldw	r4,12(r2)
 d000cb8:	e1bffb03 	ldbu	r6,-20(fp)
 d000cbc:	01434174 	movhi	r5,3333
 d000cc0:	296c7904 	addi	r5,r5,-19996
 d000cc4:	d00249c0 	call	d00249c <fprintf>
         perror("\n[SSS]:  ERRNO: ");
 d000cc8:	01034174 	movhi	r4,3333
 d000ccc:	212c7f04 	addi	r4,r4,-19972
 d000cd0:	d0029840 	call	d002984 <perror>
   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */     
   switch (fault_level) 
 d000cd4:	e0bffa17 	ldw	r2,-24(fp)
 d000cd8:	e0bfff15 	stw	r2,-4(fp)
 d000cdc:	e0ffff17 	ldw	r3,-4(fp)
 d000ce0:	18800060 	cmpeqi	r2,r3,1
 d000ce4:	1000071e 	bne	r2,zero,d000d04 <alt_SSSErrorHandler+0x144>
 d000ce8:	e0ffff17 	ldw	r3,-4(fp)
 d000cec:	18800070 	cmpltui	r2,r3,1
 d000cf0:	10003f1e 	bne	r2,zero,d000df0 <alt_SSSErrorHandler+0x230>
 d000cf4:	e0ffff17 	ldw	r3,-4(fp)
 d000cf8:	188000a0 	cmpeqi	r2,r3,2
 d000cfc:	10001d1e 	bne	r2,zero,d000d74 <alt_SSSErrorHandler+0x1b4>
 d000d00:	00005806 	br	d000e64 <alt_SSSErrorHandler+0x2a4>
   {
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is TASK).");
 d000d04:	01034174 	movhi	r4,3333
 d000d08:	212c8404 	addi	r4,r4,-19952
 d000d0c:	d0029980 	call	d002998 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is TASK");
 d000d10:	00834174 	movhi	r2,3333
 d000d14:	108a2204 	addi	r2,r2,10376
 d000d18:	10800017 	ldw	r2,0(r2)
 d000d1c:	11c00317 	ldw	r7,12(r2)
 d000d20:	01034174 	movhi	r4,3333
 d000d24:	212c8f04 	addi	r4,r4,-19908
 d000d28:	01400044 	movi	r5,1
 d000d2c:	018006c4 	movi	r6,27
 d000d30:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[SSS]: Task is being deleted.\n");
 d000d34:	00834174 	movhi	r2,3333
 d000d38:	108a2204 	addi	r2,r2,10376
 d000d3c:	10800017 	ldw	r2,0(r2)
 d000d40:	11c00317 	ldw	r7,12(r2)
 d000d44:	01034174 	movhi	r4,3333
 d000d48:	212c9604 	addi	r4,r4,-19880
 d000d4c:	01400044 	movi	r5,1
 d000d50:	018007c4 	movi	r6,31
 d000d54:	d0025980 	call	d002598 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 d000d58:	d00e2380 	call	d00e238 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 d000d5c:	01003fc4 	movi	r4,255
 d000d60:	d0142f00 	call	d0142f0 <OSTaskDel>
         /* Invoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 d000d64:	e13ffb03 	ldbu	r4,-20(fp)
 d000d68:	000b883a 	mov	r5,zero
 d000d6c:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
         break;
 d000d70:	00004806 	br	d000e94 <alt_SSSErrorHandler+0x2d4>
      case SYSTEM:
          /* Total System Failure, Restart Required */
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 d000d74:	01034174 	movhi	r4,3333
 d000d78:	212c9e04 	addi	r4,r4,-19848
 d000d7c:	d0029980 	call	d002998 <printf>
         fprintf(stderr, "\n[SSS]: FAULT_LEVEL is SYSTEM.");
 d000d80:	00834174 	movhi	r2,3333
 d000d84:	108a2204 	addi	r2,r2,10376
 d000d88:	10800017 	ldw	r2,0(r2)
 d000d8c:	11c00317 	ldw	r7,12(r2)
 d000d90:	01034174 	movhi	r4,3333
 d000d94:	212ca904 	addi	r4,r4,-19804
 d000d98:	01400044 	movi	r5,1
 d000d9c:	01800784 	movi	r6,30
 d000da0:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[SSS]: FATAL Error, Restart required.");
 d000da4:	00834174 	movhi	r2,3333
 d000da8:	108a2204 	addi	r2,r2,10376
 d000dac:	10800017 	ldw	r2,0(r2)
 d000db0:	11c00317 	ldw	r7,12(r2)
 d000db4:	01034174 	movhi	r4,3333
 d000db8:	212cb104 	addi	r4,r4,-19772
 d000dbc:	01400044 	movi	r5,1
 d000dc0:	01800984 	movi	r6,38
 d000dc4:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, "\n[SSS]: Locking scheduler - endless loop.\n");
 d000dc8:	00834174 	movhi	r2,3333
 d000dcc:	108a2204 	addi	r2,r2,10376
 d000dd0:	10800017 	ldw	r2,0(r2)
 d000dd4:	11c00317 	ldw	r7,12(r2)
 d000dd8:	01034174 	movhi	r4,3333
 d000ddc:	212cbb04 	addi	r4,r4,-19732
 d000de0:	01400044 	movi	r5,1
 d000de4:	01800a84 	movi	r6,42
 d000de8:	d0025980 	call	d002598 <fwrite>
         while(1); /* Since scheduler is locked, loop halts all task activity.*/
 d000dec:	003fff06 	br	d000dec <alt_SSSErrorHandler+0x22c>
         break;
      case NONE:
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is NONE.");
 d000df0:	00834174 	movhi	r2,3333
 d000df4:	108a2204 	addi	r2,r2,10376
 d000df8:	10800017 	ldw	r2,0(r2)
 d000dfc:	11c00317 	ldw	r7,12(r2)
 d000e00:	01034174 	movhi	r4,3333
 d000e04:	212cc604 	addi	r4,r4,-19688
 d000e08:	01400044 	movi	r5,1
 d000e0c:	018006c4 	movi	r6,27
 d000e10:	d0025980 	call	d002598 <fwrite>
         fprintf(stderr, 
 d000e14:	00834174 	movhi	r2,3333
 d000e18:	108a2204 	addi	r2,r2,10376
 d000e1c:	10800017 	ldw	r2,0(r2)
 d000e20:	11c00317 	ldw	r7,12(r2)
 d000e24:	01034174 	movhi	r4,3333
 d000e28:	212ccd04 	addi	r4,r4,-19660
 d000e2c:	01400044 	movi	r5,1
 d000e30:	01800f44 	movi	r6,61
 d000e34:	d0025980 	call	d002598 <fwrite>
            "\n[SSS] Informational error only, control returned to task to ");
         fprintf(stderr,
 d000e38:	00834174 	movhi	r2,3333
 d000e3c:	108a2204 	addi	r2,r2,10376
 d000e40:	10800017 	ldw	r2,0(r2)
 d000e44:	11c00317 	ldw	r7,12(r2)
 d000e48:	01034174 	movhi	r4,3333
 d000e4c:	212cdd04 	addi	r4,r4,-19596
 d000e50:	01400044 	movi	r5,1
 d000e54:	01800b84 	movi	r6,46
 d000e58:	d0025980 	call	d002598 <fwrite>
            "complete processing at the application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */ 
 d000e5c:	d00e2380 	call	d00e238 <OSSchedUnlock>
         return;         
 d000e60:	00000d06 	br	d000e98 <alt_SSSErrorHandler+0x2d8>
         break;
      default:
         printf("\n[SSS]: See STDERR (FAULT_LEVEL is Unknown).\n");
 d000e64:	01034174 	movhi	r4,3333
 d000e68:	212ce904 	addi	r4,r4,-19548
 d000e6c:	d002cc00 	call	d002cc0 <puts>
         fprintf(stderr, "\n[SSS] FAULT_LEVEL is unknown!?!\n");
 d000e70:	00834174 	movhi	r2,3333
 d000e74:	108a2204 	addi	r2,r2,10376
 d000e78:	10800017 	ldw	r2,0(r2)
 d000e7c:	11c00317 	ldw	r7,12(r2)
 d000e80:	01034174 	movhi	r4,3333
 d000e84:	212cf504 	addi	r4,r4,-19500
 d000e88:	01400044 	movi	r5,1
 d000e8c:	01800844 	movi	r6,33
 d000e90:	d0025980 	call	d002598 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 d000e94:	003fff06 	br	d000e94 <alt_SSSErrorHandler+0x2d4>
}
 d000e98:	e037883a 	mov	sp,fp
 d000e9c:	dfc00117 	ldw	ra,4(sp)
 d000ea0:	df000017 	ldw	fp,0(sp)
 d000ea4:	dec00204 	addi	sp,sp,8
 d000ea8:	f800283a 	ret

0d000eac <SSSInitialTask>:
/* SSSInitialTask will initialize the NicheStack
 * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
 * RTOS structures and tasks. 
 */
void SSSInitialTask(void *task_data)
{
 d000eac:	defffc04 	addi	sp,sp,-16
 d000eb0:	dfc00315 	stw	ra,12(sp)
 d000eb4:	df000215 	stw	fp,8(sp)
 d000eb8:	df000204 	addi	fp,sp,8
 d000ebc:	e13fff15 	stw	r4,-4(fp)
   * NicheStack is initialized from a task, so that RTOS will have started, and 
   * I/O drivers are available.  Two tasks are created:
   *    "Inet main"  task with priority 2
   *    "clock tick" task with priority 3
   */   
  alt_iniche_init();
 d000ec0:	d029b100 	call	d029b10 <alt_iniche_init>
  netmain(); 
 d000ec4:	d024d580 	call	d024d58 <netmain>

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 d000ec8:	00000206 	br	d000ed4 <SSSInitialTask+0x28>
    TK_SLEEP(1);
 d000ecc:	01000084 	movi	r4,2
 d000ed0:	d0153e80 	call	d0153e8 <OSTimeDly>
  netmain(); 

  /* Wait for the network stack to be ready before proceeding. 
   * iniche_net_ready indicates that TCP/IP stack is ready, and IP address is obtained.
   */
  while (!iniche_net_ready)
 d000ed4:	00834174 	movhi	r2,3333
 d000ed8:	108aad04 	addi	r2,r2,10932
 d000edc:	10800017 	ldw	r2,0(r2)
 d000ee0:	1005003a 	cmpeq	r2,r2,zero
 d000ee4:	103ff91e 	bne	r2,zero,d000ecc <SSSInitialTask+0x20>

  /* Now that the stack is running, perform the application initialization steps */
  
  /* Application Specific Task Launching Code Block Begin */

  printf("\nSimple Socket Server starting up\n");
 d000ee8:	01034174 	movhi	r4,3333
 d000eec:	212d0404 	addi	r4,r4,-19440
 d000ef0:	d002cc00 	call	d002cc0 <puts>

  /* Create the main simple socket server task. */
  TK_NEWTASK(&ssstask);
 d000ef4:	01034174 	movhi	r4,3333
 d000ef8:	21022a04 	addi	r4,r4,2216
 d000efc:	d0297d00 	call	d0297d0 <TK_NEWTASK>
  
  /*create os data structures */
  SSSCreateOSDataStructs(); 
 d000f00:	d001b340 	call	d001b34 <SSSCreateOSDataStructs>

  /* create the other tasks */
  SSSCreateTasks();
 d000f04:	d001bdc0 	call	d001bdc <SSSCreateTasks>

  /* Application Specific Task Launching Code Block End */
  
  /*This task is deleted because there is no need for it to run again */
  error_code = OSTaskDel(OS_PRIO_SELF);
 d000f08:	01003fc4 	movi	r4,255
 d000f0c:	d0142f00 	call	d0142f0 <OSTaskDel>
 d000f10:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 d000f14:	e13ffe03 	ldbu	r4,-8(fp)
 d000f18:	000b883a 	mov	r5,zero
 d000f1c:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
  
  while (1); /* Correct Program Flow should never get here */
 d000f20:	003fff06 	br	d000f20 <SSSInitialTask+0x74>

0d000f24 <main>:

/* Main creates a single task, SSSInitialTask, and starts task scheduler.
 */

int main (int argc, char* argv[], char* envp[])
{
 d000f24:	defff504 	addi	sp,sp,-44
 d000f28:	dfc00a15 	stw	ra,40(sp)
 d000f2c:	df000915 	stw	fp,36(sp)
 d000f30:	df000904 	addi	fp,sp,36
 d000f34:	e13ffd15 	stw	r4,-12(fp)
 d000f38:	e17ffe15 	stw	r5,-8(fp)
 d000f3c:	e1bfff15 	stw	r6,-4(fp)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 d000f40:	0009883a 	mov	r4,zero
 d000f44:	d0159180 	call	d015918 <OSTimeSet>

  /* SSSInitialTask will initialize the NicheStack
   * TCP/IP Stack and then initialize the rest of the Simple Socket Server example 
   * RTOS structures and tasks. 
   */  
  error_code = OSTaskCreateExt(SSSInitialTask,
 d000f48:	01834174 	movhi	r6,3333
 d000f4c:	3194a104 	addi	r6,r6,21124
 d000f50:	00800144 	movi	r2,5
 d000f54:	d8800015 	stw	r2,0(sp)
 d000f58:	00834174 	movhi	r2,3333
 d000f5c:	108ca104 	addi	r2,r2,12932
 d000f60:	d8800115 	stw	r2,4(sp)
 d000f64:	00820004 	movi	r2,2048
 d000f68:	d8800215 	stw	r2,8(sp)
 d000f6c:	d8000315 	stw	zero,12(sp)
 d000f70:	d8000415 	stw	zero,16(sp)
 d000f74:	01034034 	movhi	r4,3328
 d000f78:	2103ab04 	addi	r4,r4,3756
 d000f7c:	000b883a 	mov	r5,zero
 d000f80:	01c00144 	movi	r7,5
 d000f84:	d0140f00 	call	d0140f0 <OSTaskCreateExt>
 d000f88:	e0bffc05 	stb	r2,-16(fp)
                             SSS_INITIAL_TASK_PRIORITY,
                             SSSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 d000f8c:	e13ffc03 	ldbu	r4,-16(fp)
 d000f90:	000b883a 	mov	r5,zero
 d000f94:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 d000f98:	d00e31c0 	call	d00e31c <OSStart>

  
  while(1); /* Correct Program Flow never gets here. */
 d000f9c:	003fff06 	br	d000f9c <main+0x78>

0d000fa0 <led_bit_toggle>:
 * Development Board which controls 8 LEDs, D0 - D7.
 * 
 */
 
void led_bit_toggle(OS_FLAGS bit)
{
 d000fa0:	defffc04 	addi	sp,sp,-16
 d000fa4:	dfc00315 	stw	ra,12(sp)
 d000fa8:	df000215 	stw	fp,8(sp)
 d000fac:	df000204 	addi	fp,sp,8
 d000fb0:	e13fff0d 	sth	r4,-4(fp)
    OS_FLAGS  led_8_val;
    INT8U error_code;
    
    led_8_val = OSFlagQuery(SSSLEDEventFlag, &error_code);
 d000fb4:	00834174 	movhi	r2,3333
 d000fb8:	108a7d04 	addi	r2,r2,10740
 d000fbc:	11000017 	ldw	r4,0(r2)
 d000fc0:	e17ffe84 	addi	r5,fp,-6
 d000fc4:	d010d6c0 	call	d010d6c <OSFlagQuery>
 d000fc8:	e0bffe0d 	sth	r2,-8(fp)
    alt_uCOSIIErrorHandler(error_code, 0);
 d000fcc:	e0bffe83 	ldbu	r2,-6(fp)
 d000fd0:	11003fcc 	andi	r4,r2,255
 d000fd4:	000b883a 	mov	r5,zero
 d000fd8:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
    if (bit & led_8_val)
 d000fdc:	e0ffff0b 	ldhu	r3,-4(fp)
 d000fe0:	e0bffe0b 	ldhu	r2,-8(fp)
 d000fe4:	1884703a 	and	r2,r3,r2
 d000fe8:	10bfffcc 	andi	r2,r2,65535
 d000fec:	1005003a 	cmpeq	r2,r2,zero
 d000ff0:	10000d1e 	bne	r2,zero,d001028 <led_bit_toggle+0x88>
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_CLR, &error_code);
 d000ff4:	00834174 	movhi	r2,3333
 d000ff8:	108a7d04 	addi	r2,r2,10740
 d000ffc:	11000017 	ldw	r4,0(r2)
 d001000:	e17fff0b 	ldhu	r5,-4(fp)
 d001004:	e1fffe84 	addi	r7,fp,-6
 d001008:	000d883a 	mov	r6,zero
 d00100c:	d0109c40 	call	d0109c4 <OSFlagPost>
 d001010:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 d001014:	e0bffe83 	ldbu	r2,-6(fp)
 d001018:	11003fcc 	andi	r4,r2,255
 d00101c:	000b883a 	mov	r5,zero
 d001020:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
 d001024:	00000c06 	br	d001058 <led_bit_toggle+0xb8>
    }
    else
    {
       led_8_val = OSFlagPost(SSSLEDEventFlag, bit, OS_FLAG_SET, &error_code);
 d001028:	00834174 	movhi	r2,3333
 d00102c:	108a7d04 	addi	r2,r2,10740
 d001030:	11000017 	ldw	r4,0(r2)
 d001034:	e17fff0b 	ldhu	r5,-4(fp)
 d001038:	e1fffe84 	addi	r7,fp,-6
 d00103c:	01800044 	movi	r6,1
 d001040:	d0109c40 	call	d0109c4 <OSFlagPost>
 d001044:	e0bffe0d 	sth	r2,-8(fp)
       alt_uCOSIIErrorHandler(error_code, 0);
 d001048:	e0bffe83 	ldbu	r2,-6(fp)
 d00104c:	11003fcc 	andi	r4,r2,255
 d001050:	000b883a 	mov	r5,zero
 d001054:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
    }
    #ifdef LED_PIO_BASE
       IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led_8_val);
 d001058:	e0fffe0b 	ldhu	r3,-8(fp)
 d00105c:	00800404 	movi	r2,16
 d001060:	10c00035 	stwio	r3,0(r2)
       printf("Value for LED_PIO_BASE set to %d.\n", (INT8U)led_8_val);
 d001064:	e0bffe0b 	ldhu	r2,-8(fp)
 d001068:	11403fcc 	andi	r5,r2,255
 d00106c:	01034174 	movhi	r4,3333
 d001070:	212d0d04 	addi	r4,r4,-19404
 d001074:	d0029980 	call	d002998 <printf>
    #endif
      
    return;
}
 d001078:	e037883a 	mov	sp,fp
 d00107c:	dfc00117 	ldw	ra,4(sp)
 d001080:	df000017 	ldw	fp,0(sp)
 d001084:	dec00204 	addi	sp,sp,8
 d001088:	f800283a 	ret

0d00108c <LED7SegLightshowTask>:
 * SSSLEDLightshowSem semaphore controlled in LEDManagementTask.
 * 
 */ 
 
void LED7SegLightshowTask()
{
 d00108c:	defffd04 	addi	sp,sp,-12
 d001090:	dfc00215 	stw	ra,8(sp)
 d001094:	df000115 	stw	fp,4(sp)
 d001098:	df000104 	addi	fp,sp,4
   {
    
      /* Wait 50 milliseconds between pattern updates, to make the pattern slow
       * enough for the human eye, and more impotantly, to give up control so
       * MicroC/OS-II can schedule other lower priority tasks. */ 
      OSTimeDlyHMSM(0,0,0,50);
 d00109c:	0009883a 	mov	r4,zero
 d0010a0:	000b883a 	mov	r5,zero
 d0010a4:	000d883a 	mov	r6,zero
 d0010a8:	01c00c84 	movi	r7,50
 d0010ac:	d0155340 	call	d015534 <OSTimeDlyHMSM>
      
      /* Check that we still have the SSSLEDLightshowSem semaphore. If we don't,
       * then wait until the LEDManagement task gives it back to us. */
      OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 d0010b0:	00834174 	movhi	r2,3333
 d0010b4:	108a7c04 	addi	r2,r2,10736
 d0010b8:	11000017 	ldw	r4,0(r2)
 d0010bc:	e1bfff84 	addi	r6,fp,-2
 d0010c0:	000b883a 	mov	r5,zero
 d0010c4:	d0132540 	call	d013254 <OSSemPend>
      alt_uCOSIIErrorHandler(error_code, 0);
 d0010c8:	e0bfff83 	ldbu	r2,-2(fp)
 d0010cc:	11003fcc 	andi	r4,r2,255
 d0010d0:	000b883a 	mov	r5,zero
 d0010d4:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
      #if SEVEN_SEG_PIO_BASE
         led_7_seg_val = rand();
         IOWR_ALTERA_AVALON_PIO_DATA(SEVEN_SEG_PIO_BASE, led_7_seg_val);
      #endif
      
      error_code = OSSemPost(SSSLEDLightshowSem);
 d0010d8:	00834174 	movhi	r2,3333
 d0010dc:	108a7c04 	addi	r2,r2,10736
 d0010e0:	11000017 	ldw	r4,0(r2)
 d0010e4:	d01364c0 	call	d01364c <OSSemPost>
 d0010e8:	e0bfff85 	stb	r2,-2(fp)
      alt_uCOSIIErrorHandler(error_code, 0);
 d0010ec:	e0bfff83 	ldbu	r2,-2(fp)
 d0010f0:	11003fcc 	andi	r4,r2,255
 d0010f4:	000b883a 	mov	r5,zero
 d0010f8:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
      
   }
 d0010fc:	003fe706 	br	d00109c <LED7SegLightshowTask+0x10>

0d001100 <LEDManagementTask>:
 * The task will read the SSSLedCommandQ for an 
 * in-coming message command from the SSSSimpleSocketServerTask. 
 */
 
void LEDManagementTask()
{
 d001100:	defffa04 	addi	sp,sp,-24
 d001104:	dfc00515 	stw	ra,20(sp)
 d001108:	df000415 	stw	fp,16(sp)
 d00110c:	df000404 	addi	fp,sp,16
  INT32U led_command; 
  INT16U led_7_seg_val;
  BOOLEAN SSSLEDLightshowActive;
  INT8U error_code;
  
  led_7_seg_val = 0;
 d001110:	e03ffc8d 	sth	zero,-14(fp)
  SSSLEDLightshowActive = OS_TRUE;
 d001114:	00800044 	movi	r2,1
 d001118:	e0bffc05 	stb	r2,-16(fp)
 d00111c:	00000006 	br	d001120 <LEDManagementTask+0x20>
  
  while(1)
  {
    led_command = (INT32U)OSQPend(SSSLEDCommandQ, 0, &error_code);
 d001120:	00834174 	movhi	r2,3333
 d001124:	108a7b04 	addi	r2,r2,10732
 d001128:	11000017 	ldw	r4,0(r2)
 d00112c:	e1bffe04 	addi	r6,fp,-8
 d001130:	000b883a 	mov	r5,zero
 d001134:	d0121dc0 	call	d0121dc <OSQPend>
 d001138:	e0bffd15 	stw	r2,-12(fp)
   
    alt_uCOSIIErrorHandler(error_code, 0);
 d00113c:	e0bffe03 	ldbu	r2,-8(fp)
 d001140:	11003fcc 	andi	r4,r2,255
 d001144:	000b883a 	mov	r5,zero
 d001148:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
        
    switch (led_command) {
 d00114c:	e0bffd17 	ldw	r2,-12(fp)
 d001150:	10bff404 	addi	r2,r2,-48
 d001154:	e0bfff15 	stw	r2,-4(fp)
 d001158:	e0ffff17 	ldw	r3,-4(fp)
 d00115c:	18800928 	cmpgeui	r2,r3,36
 d001160:	103fef1e 	bne	r2,zero,d001120 <LEDManagementTask+0x20>
 d001164:	e13fff17 	ldw	r4,-4(fp)
 d001168:	e13fff17 	ldw	r4,-4(fp)
 d00116c:	2105883a 	add	r2,r4,r4
 d001170:	1087883a 	add	r3,r2,r2
 d001174:	00834034 	movhi	r2,3328
 d001178:	10846204 	addi	r2,r2,4488
 d00117c:	1885883a 	add	r2,r3,r2
 d001180:	10800017 	ldw	r2,0(r2)
 d001184:	1000683a 	jmp	r2
 d001188:	0d001218 	cmpnei	r20,at,72
 d00118c:	0d001224 	muli	r20,at,72
 d001190:	0d001230 	cmpltui	r20,at,72
 d001194:	0d00123c 	xorhi	r20,at,72
 d001198:	0d001248 	cmpgei	r20,at,73
 d00119c:	0d001254 	ori	r20,at,73
 d0011a0:	0d001260 	cmpeqi	r20,at,73
 d0011a4:	0d00126c 	andhi	r20,at,73
 d0011a8:	0d001120 	cmpeqi	r20,at,68
 d0011ac:	0d001120 	cmpeqi	r20,at,68
 d0011b0:	0d001120 	cmpeqi	r20,at,68
 d0011b4:	0d001120 	cmpeqi	r20,at,68
 d0011b8:	0d001120 	cmpeqi	r20,at,68
 d0011bc:	0d001120 	cmpeqi	r20,at,68
 d0011c0:	0d001120 	cmpeqi	r20,at,68
 d0011c4:	0d001120 	cmpeqi	r20,at,68
 d0011c8:	0d001120 	cmpeqi	r20,at,68
 d0011cc:	0d001120 	cmpeqi	r20,at,68
 d0011d0:	0d001120 	cmpeqi	r20,at,68
 d0011d4:	0d001120 	cmpeqi	r20,at,68
 d0011d8:	0d001120 	cmpeqi	r20,at,68
 d0011dc:	0d001120 	cmpeqi	r20,at,68
 d0011e0:	0d001120 	cmpeqi	r20,at,68
 d0011e4:	0d001120 	cmpeqi	r20,at,68
 d0011e8:	0d001120 	cmpeqi	r20,at,68
 d0011ec:	0d001120 	cmpeqi	r20,at,68
 d0011f0:	0d001120 	cmpeqi	r20,at,68
 d0011f4:	0d001120 	cmpeqi	r20,at,68
 d0011f8:	0d001120 	cmpeqi	r20,at,68
 d0011fc:	0d001120 	cmpeqi	r20,at,68
 d001200:	0d001120 	cmpeqi	r20,at,68
 d001204:	0d001120 	cmpeqi	r20,at,68
 d001208:	0d001120 	cmpeqi	r20,at,68
 d00120c:	0d001120 	cmpeqi	r20,at,68
 d001210:	0d001120 	cmpeqi	r20,at,68
 d001214:	0d001278 	rdprs	r20,at,73
      case CMD_LEDS_BIT_0_TOGGLE:
         led_bit_toggle(BIT_0);
 d001218:	01000044 	movi	r4,1
 d00121c:	d000fa00 	call	d000fa0 <led_bit_toggle>
         break;
 d001220:	003fbf06 	br	d001120 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_1_TOGGLE:
         led_bit_toggle(BIT_1);
 d001224:	01000084 	movi	r4,2
 d001228:	d000fa00 	call	d000fa0 <led_bit_toggle>
         break;   
 d00122c:	003fbc06 	br	d001120 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_2_TOGGLE:
         led_bit_toggle(BIT_2);
 d001230:	01000104 	movi	r4,4
 d001234:	d000fa00 	call	d000fa0 <led_bit_toggle>
         break;
 d001238:	003fb906 	br	d001120 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_3_TOGGLE:
         led_bit_toggle(BIT_3);
 d00123c:	01000204 	movi	r4,8
 d001240:	d000fa00 	call	d000fa0 <led_bit_toggle>
         break;
 d001244:	003fb606 	br	d001120 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_4_TOGGLE:
         led_bit_toggle(BIT_4);
 d001248:	01000404 	movi	r4,16
 d00124c:	d000fa00 	call	d000fa0 <led_bit_toggle>
         break;
 d001250:	003fb306 	br	d001120 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_5_TOGGLE:
         led_bit_toggle(BIT_5);
 d001254:	01000804 	movi	r4,32
 d001258:	d000fa00 	call	d000fa0 <led_bit_toggle>
         break;
 d00125c:	003fb006 	br	d001120 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_6_TOGGLE:
         led_bit_toggle(BIT_6);
 d001260:	01001004 	movi	r4,64
 d001264:	d000fa00 	call	d000fa0 <led_bit_toggle>
         break;
 d001268:	003fad06 	br	d001120 <LEDManagementTask+0x20>
      case CMD_LEDS_BIT_7_TOGGLE:
         led_bit_toggle(BIT_7);
 d00126c:	01002004 	movi	r4,128
 d001270:	d000fa00 	call	d000fa0 <led_bit_toggle>
         break;
 d001274:	003faa06 	br	d001120 <LEDManagementTask+0x20>
         /* The SSSLEDLightshowSem semaphore is checked by LED7SegLightshowTask 
          * each time it updates 7 segment LED displays, U8 and U9.  Grab the 
          * semaphore (pend) away from the lightshow task to toggle the lightshow off, 
          * and give up the semaphore (post) to turn the lightshow back on.  
          */
         if (SSSLEDLightshowActive == OS_FALSE)
 d001278:	e0bffc03 	ldbu	r2,-16(fp)
 d00127c:	1004c03a 	cmpne	r2,r2,zero
 d001280:	10000c1e 	bne	r2,zero,d0012b4 <LEDManagementTask+0x1b4>
         {
             error_code = OSSemPost(SSSLEDLightshowSem);
 d001284:	00834174 	movhi	r2,3333
 d001288:	108a7c04 	addi	r2,r2,10736
 d00128c:	11000017 	ldw	r4,0(r2)
 d001290:	d01364c0 	call	d01364c <OSSemPost>
 d001294:	e0bffe05 	stb	r2,-8(fp)
             alt_uCOSIIErrorHandler(error_code, 0);
 d001298:	e0bffe03 	ldbu	r2,-8(fp)
 d00129c:	11003fcc 	andi	r4,r2,255
 d0012a0:	000b883a 	mov	r5,zero
 d0012a4:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_TRUE;
 d0012a8:	00800044 	movi	r2,1
 d0012ac:	e0bffc05 	stb	r2,-16(fp)
 d0012b0:	003f9b06 	br	d001120 <LEDManagementTask+0x20>
         }
         else
         {
             OSSemPend(SSSLEDLightshowSem, 0, &error_code);
 d0012b4:	00834174 	movhi	r2,3333
 d0012b8:	108a7c04 	addi	r2,r2,10736
 d0012bc:	11000017 	ldw	r4,0(r2)
 d0012c0:	e1bffe04 	addi	r6,fp,-8
 d0012c4:	000b883a 	mov	r5,zero
 d0012c8:	d0132540 	call	d013254 <OSSemPend>
             alt_uCOSIIErrorHandler(error_code, 0); 
 d0012cc:	e0bffe03 	ldbu	r2,-8(fp)
 d0012d0:	11003fcc 	andi	r4,r2,255
 d0012d4:	000b883a 	mov	r5,zero
 d0012d8:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
             SSSLEDLightshowActive = OS_FALSE;
 d0012dc:	e03ffc05 	stb	zero,-16(fp)
         break;
      default:     
        /* Discard unknown LED commands. */
        break;
    } /* switch led_command */
  } /* while(1) */
 d0012e0:	003f8f06 	br	d001120 <LEDManagementTask+0x20>

0d0012e4 <get_mac_addr>:
* Read the MAC address in a board specific way. Prompt user to enter serial 
* number to generate MAC address if failed to read from flash.
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 d0012e4:	defffb04 	addi	sp,sp,-20
 d0012e8:	dfc00415 	stw	ra,16(sp)
 d0012ec:	df000315 	stw	fp,12(sp)
 d0012f0:	df000304 	addi	fp,sp,12
 d0012f4:	e13ffe15 	stw	r4,-8(fp)
 d0012f8:	e17fff15 	stw	r5,-4(fp)
    error_t error = 0;
 d0012fc:	e03ffd15 	stw	zero,-12(fp)
    
    error = get_board_mac_addr(mac_addr);
 d001300:	e13fff17 	ldw	r4,-4(fp)
 d001304:	d00185c0 	call	d00185c <get_board_mac_addr>
 d001308:	e0bffd15 	stw	r2,-12(fp)
    
    if(error)
 d00130c:	e0bffd17 	ldw	r2,-12(fp)
 d001310:	1005003a 	cmpeq	r2,r2,zero
 d001314:	1000031e 	bne	r2,zero,d001324 <get_mac_addr+0x40>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 d001318:	e13fff17 	ldw	r4,-4(fp)
 d00131c:	d0017200 	call	d001720 <generate_mac_addr>
 d001320:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 d001324:	e0bffd17 	ldw	r2,-12(fp)
}
 d001328:	e037883a 	mov	sp,fp
 d00132c:	dfc00117 	ldw	ra,4(sp)
 d001330:	df000017 	ldw	fp,0(sp)
 d001334:	dec00204 	addi	sp,sp,8
 d001338:	f800283a 	ret

0d00133c <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 d00133c:	defffb04 	addi	sp,sp,-20
 d001340:	df000415 	stw	fp,16(sp)
 d001344:	df000404 	addi	fp,sp,16
 d001348:	e13ffc15 	stw	r4,-16(fp)
 d00134c:	e17ffd15 	stw	r5,-12(fp)
 d001350:	e1bffe15 	stw	r6,-8(fp)
 d001354:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 d001358:	e0bffd17 	ldw	r2,-12(fp)
 d00135c:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 d001360:	e0bfff17 	ldw	r2,-4(fp)
 d001364:	10000015 	stw	zero,0(r2)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 d001368:	e0fffe17 	ldw	r3,-8(fp)
 d00136c:	00804034 	movhi	r2,256
 d001370:	10bfffc4 	addi	r2,r2,-1
 d001374:	18800015 	stw	r2,0(r3)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
 d001378:	e0c00117 	ldw	r3,4(fp)
 d00137c:	00800044 	movi	r2,1
 d001380:	18800015 	stw	r2,0(r3)
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */

    /* Non-standard API: return 1 for success */
    return 1;
 d001384:	00800044 	movi	r2,1
}
 d001388:	e037883a 	mov	sp,fp
 d00138c:	df000017 	ldw	fp,0(sp)
 d001390:	dec00104 	addi	sp,sp,4
 d001394:	f800283a 	ret

0d001398 <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 d001398:	defff804 	addi	sp,sp,-32
 d00139c:	dfc00715 	stw	ra,28(sp)
 d0013a0:	df000615 	stw	fp,24(sp)
 d0013a4:	dc000515 	stw	r16,20(sp)
 d0013a8:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 d0013ac:	e03ffc15 	stw	zero,-16(fp)
    char serial_number[9];
    int i = 0;
 d0013b0:	e03ffb15 	stw	zero,-20(fp)
    
    while(!ser_num)
 d0013b4:	00006506 	br	d00154c <get_serial_number+0x1b4>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 d0013b8:	01034174 	movhi	r4,3333
 d0013bc:	212d1604 	addi	r4,r4,-19368
 d0013c0:	d002cc00 	call	d002cc0 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 d0013c4:	01034174 	movhi	r4,3333
 d0013c8:	212d2604 	addi	r4,r4,-19304
 d0013cc:	d002cc00 	call	d002cc0 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 d0013d0:	01034174 	movhi	r4,3333
 d0013d4:	212d3604 	addi	r4,r4,-19240
 d0013d8:	d0029980 	call	d002998 <printf>
        
        for(i=0; i<9; i++)
 d0013dc:	e03ffb15 	stw	zero,-20(fp)
 d0013e0:	00002806 	br	d001484 <get_serial_number+0xec>
        {
            serial_number[i] = getchar();
 d0013e4:	e43ffb17 	ldw	r16,-20(fp)
 d0013e8:	00834174 	movhi	r2,3333
 d0013ec:	108a2204 	addi	r2,r2,10376
 d0013f0:	10800017 	ldw	r2,0(r2)
 d0013f4:	11000117 	ldw	r4,4(r2)
 d0013f8:	d0025d80 	call	d0025d8 <getc>
 d0013fc:	1007883a 	mov	r3,r2
 d001400:	e0bffd04 	addi	r2,fp,-12
 d001404:	1405883a 	add	r2,r2,r16
 d001408:	10c00005 	stb	r3,0(r2)
            putchar(serial_number[i]);
 d00140c:	e0fffb17 	ldw	r3,-20(fp)
 d001410:	e0bffd04 	addi	r2,fp,-12
 d001414:	10c5883a 	add	r2,r2,r3
 d001418:	10800003 	ldbu	r2,0(r2)
 d00141c:	11003fcc 	andi	r4,r2,255
 d001420:	2100201c 	xori	r4,r4,128
 d001424:	213fe004 	addi	r4,r4,-128
 d001428:	00834174 	movhi	r2,3333
 d00142c:	108a2204 	addi	r2,r2,10376
 d001430:	10800017 	ldw	r2,0(r2)
 d001434:	11400217 	ldw	r5,8(r2)
 d001438:	d002a100 	call	d002a10 <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 d00143c:	e0fffb17 	ldw	r3,-20(fp)
 d001440:	e0bffd04 	addi	r2,fp,-12
 d001444:	10c5883a 	add	r2,r2,r3
 d001448:	10800003 	ldbu	r2,0(r2)
 d00144c:	10803fcc 	andi	r2,r2,255
 d001450:	1080201c 	xori	r2,r2,128
 d001454:	10bfe004 	addi	r2,r2,-128
 d001458:	10800218 	cmpnei	r2,r2,8
 d00145c:	1000061e 	bne	r2,zero,d001478 <get_serial_number+0xe0>
 d001460:	e0bffb17 	ldw	r2,-20(fp)
 d001464:	1004803a 	cmplt	r2,r2,zero
 d001468:	1000031e 	bne	r2,zero,d001478 <get_serial_number+0xe0>
            {
                i--;
 d00146c:	e0bffb17 	ldw	r2,-20(fp)
 d001470:	10bfffc4 	addi	r2,r2,-1
 d001474:	e0bffb15 	stw	r2,-20(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 d001478:	e0bffb17 	ldw	r2,-20(fp)
 d00147c:	10800044 	addi	r2,r2,1
 d001480:	e0bffb15 	stw	r2,-20(fp)
 d001484:	e0bffb17 	ldw	r2,-20(fp)
 d001488:	10800250 	cmplti	r2,r2,9
 d00148c:	103fd51e 	bne	r2,zero,d0013e4 <get_serial_number+0x4c>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 d001490:	01000284 	movi	r4,10
 d001494:	d002bfc0 	call	d002bfc <putchar>
                
        for(i=0; i<9; i++)
 d001498:	e03ffb15 	stw	zero,-20(fp)
 d00149c:	00002806 	br	d001540 <get_serial_number+0x1a8>
        {
            if (isdigit(serial_number[i]))
 d0014a0:	e0fffb17 	ldw	r3,-20(fp)
 d0014a4:	e0bffd04 	addi	r2,fp,-12
 d0014a8:	10c5883a 	add	r2,r2,r3
 d0014ac:	10800003 	ldbu	r2,0(r2)
 d0014b0:	10803fcc 	andi	r2,r2,255
 d0014b4:	1080201c 	xori	r2,r2,128
 d0014b8:	10bfe004 	addi	r2,r2,-128
 d0014bc:	1007883a 	mov	r3,r2
 d0014c0:	00834174 	movhi	r2,3333
 d0014c4:	108a2104 	addi	r2,r2,10372
 d0014c8:	10800017 	ldw	r2,0(r2)
 d0014cc:	1885883a 	add	r2,r3,r2
 d0014d0:	10800003 	ldbu	r2,0(r2)
 d0014d4:	10803fcc 	andi	r2,r2,255
 d0014d8:	1080010c 	andi	r2,r2,4
 d0014dc:	1005003a 	cmpeq	r2,r2,zero
 d0014e0:	1000121e 	bne	r2,zero,d00152c <get_serial_number+0x194>
            {
                ser_num *= 10;
 d0014e4:	e0bffc17 	ldw	r2,-16(fp)
 d0014e8:	108002a4 	muli	r2,r2,10
 d0014ec:	e0bffc15 	stw	r2,-16(fp)
                ser_num += serial_number[i] - '0';
 d0014f0:	e0fffb17 	ldw	r3,-20(fp)
 d0014f4:	e0bffd04 	addi	r2,fp,-12
 d0014f8:	10c5883a 	add	r2,r2,r3
 d0014fc:	10800003 	ldbu	r2,0(r2)
 d001500:	10c03fcc 	andi	r3,r2,255
 d001504:	18c0201c 	xori	r3,r3,128
 d001508:	18ffe004 	addi	r3,r3,-128
 d00150c:	e0bffc17 	ldw	r2,-16(fp)
 d001510:	1885883a 	add	r2,r3,r2
 d001514:	10bff404 	addi	r2,r2,-48
 d001518:	e0bffc15 	stw	r2,-16(fp)
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 d00151c:	e0bffb17 	ldw	r2,-20(fp)
 d001520:	10800044 	addi	r2,r2,1
 d001524:	e0bffb15 	stw	r2,-20(fp)
 d001528:	00000506 	br	d001540 <get_serial_number+0x1a8>
                ser_num *= 10;
                ser_num += serial_number[i] - '0';
            }
            else
            {
                ser_num = 0;
 d00152c:	e03ffc15 	stw	zero,-16(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 d001530:	01034174 	movhi	r4,3333
 d001534:	212d4404 	addi	r4,r4,-19184
 d001538:	d002cc00 	call	d002cc0 <puts>
                break;
 d00153c:	00000306 	br	d00154c <get_serial_number+0x1b4>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 d001540:	e0bffb17 	ldw	r2,-20(fp)
 d001544:	10800250 	cmplti	r2,r2,9
 d001548:	103fd51e 	bne	r2,zero,d0014a0 <get_serial_number+0x108>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 d00154c:	e0bffc17 	ldw	r2,-16(fp)
 d001550:	1005003a 	cmpeq	r2,r2,zero
 d001554:	103f981e 	bne	r2,zero,d0013b8 <get_serial_number+0x20>
                break;
            }
        }
    }
    
    return ser_num;
 d001558:	e0bffc17 	ldw	r2,-16(fp)
}
 d00155c:	e037883a 	mov	sp,fp
 d001560:	dfc00217 	ldw	ra,8(sp)
 d001564:	df000117 	ldw	fp,4(sp)
 d001568:	dc000017 	ldw	r16,0(sp)
 d00156c:	dec00304 	addi	sp,sp,12
 d001570:	f800283a 	ret

0d001574 <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 d001574:	deffef04 	addi	sp,sp,-68
 d001578:	dfc01015 	stw	ra,64(sp)
 d00157c:	df000f15 	stw	fp,60(sp)
 d001580:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 d001584:	00bfffc4 	movi	r2,-1
 d001588:	e0bff715 	stw	r2,-36(fp)
    alt_u32 ser_num = 0;
 d00158c:	e03ff615 	stw	zero,-40(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 d001590:	01034174 	movhi	r4,3333
 d001594:	212d5304 	addi	r4,r4,-19124
 d001598:	d002cc00 	call	d002cc0 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 d00159c:	01034174 	movhi	r4,3333
 d0015a0:	212d6304 	addi	r4,r4,-19060
 d0015a4:	d002cc00 	call	d002cc0 <puts>
    printf("static network settings\n\n");
 d0015a8:	01034174 	movhi	r4,3333
 d0015ac:	212d7404 	addi	r4,r4,-18992
 d0015b0:	d002cc00 	call	d002cc0 <puts>
    
    ser_num = get_serial_number();
 d0015b4:	d0013980 	call	d001398 <get_serial_number>
 d0015b8:	e0bff615 	stw	r2,-40(fp)
  
    if (ser_num)
 d0015bc:	e0bff617 	ldw	r2,-40(fp)
 d0015c0:	1005003a 	cmpeq	r2,r2,zero
 d0015c4:	1000501e 	bne	r2,zero,d001708 <generate_and_store_mac_addr+0x194>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 d0015c8:	00bfff84 	movi	r2,-2
 d0015cc:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 d0015d0:	00801684 	movi	r2,90
 d0015d4:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 d0015d8:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 d0015dc:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 d0015e0:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 d0015e4:	008001c4 	movi	r2,7
 d0015e8:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 d0015ec:	00bffb44 	movi	r2,-19
 d0015f0:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0xFF;
 d0015f4:	00bfffc4 	movi	r2,-1
 d0015f8:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = (ser_num & 0xff00) >> 8;
 d0015fc:	e0bff617 	ldw	r2,-40(fp)
 d001600:	10bfc00c 	andi	r2,r2,65280
 d001604:	1004d23a 	srli	r2,r2,8
 d001608:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = ser_num & 0xff;
 d00160c:	e0bff617 	ldw	r2,-40(fp)
 d001610:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 d001614:	00bfffc4 	movi	r2,-1
 d001618:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 d00161c:	00bfffc4 	movi	r2,-1
 d001620:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 d001624:	e03ffb05 	stb	zero,-20(fp)
        flash_content[13] = IPADDR1;
 d001628:	e03ffb45 	stb	zero,-19(fp)
        flash_content[14] = IPADDR2;
 d00162c:	e03ffb85 	stb	zero,-18(fp)
        flash_content[15] = IPADDR3;
 d001630:	e03ffbc5 	stb	zero,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 d001634:	00bfffc4 	movi	r2,-1
 d001638:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 d00163c:	00bfffc4 	movi	r2,-1
 d001640:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 d001644:	00bfffc4 	movi	r2,-1
 d001648:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 d00164c:	00bfffc4 	movi	r2,-1
 d001650:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 d001654:	00bfffc4 	movi	r2,-1
 d001658:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 d00165c:	00bfffc4 	movi	r2,-1
 d001660:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 d001664:	00bfffc4 	movi	r2,-1
 d001668:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 d00166c:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 d001670:	e03ffe05 	stb	zero,-8(fp)
        flash_content[25] = GWADDR1;
 d001674:	e03ffe45 	stb	zero,-7(fp)
        flash_content[26] = GWADDR2;
 d001678:	e03ffe85 	stb	zero,-6(fp)
        flash_content[27] = GWADDR3;
 d00167c:	e03ffec5 	stb	zero,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 d001680:	00bfffc4 	movi	r2,-1
 d001684:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 d001688:	00bfffc4 	movi	r2,-1
 d00168c:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 d001690:	00bfffc4 	movi	r2,-1
 d001694:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 d001698:	00bfffc4 	movi	r2,-1
 d00169c:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EXT_FLASH_NAME);
 d0016a0:	01034174 	movhi	r4,3333
 d0016a4:	212d7b04 	addi	r4,r4,-18964
 d0016a8:	d00cddc0 	call	d00cddc <alt_flash_open_dev>
 d0016ac:	e0bff515 	stw	r2,-44(fp)
        if (flash_handle)
 d0016b0:	e0bff517 	ldw	r2,-44(fp)
 d0016b4:	1005003a 	cmpeq	r2,r2,zero
 d0016b8:	1000131e 	bne	r2,zero,d001708 <generate_and_store_mac_addr+0x194>
        {
            alt_write_flash(flash_handle,
 d0016bc:	d0a05717 	ldw	r2,-32420(gp)
 d0016c0:	1007883a 	mov	r3,r2
 d0016c4:	e0bff517 	ldw	r2,-44(fp)
 d0016c8:	e0bff115 	stw	r2,-60(fp)
 d0016cc:	e0fff215 	stw	r3,-56(fp)
 d0016d0:	e0bff804 	addi	r2,fp,-32
 d0016d4:	e0bff315 	stw	r2,-52(fp)
 d0016d8:	00800804 	movi	r2,32
 d0016dc:	e0bff415 	stw	r2,-48(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 d0016e0:	e0bff117 	ldw	r2,-60(fp)
 d0016e4:	10800517 	ldw	r2,20(r2)
 d0016e8:	e13ff117 	ldw	r4,-60(fp)
 d0016ec:	e17ff217 	ldw	r5,-56(fp)
 d0016f0:	e1bff317 	ldw	r6,-52(fp)
 d0016f4:	e1fff417 	ldw	r7,-48(fp)
 d0016f8:	103ee83a 	callr	r2
                            last_flash_sector_offset,
                            flash_content,
                            32);
            alt_flash_close_dev(flash_handle);
 d0016fc:	e13ff517 	ldw	r4,-44(fp)
 d001700:	d00ce580 	call	d00ce58 <alt_flash_close_dev>
            error = 0;
 d001704:	e03ff715 	stw	zero,-36(fp)
        }
    }

    return error;    
 d001708:	e0bff717 	ldw	r2,-36(fp)
}
 d00170c:	e037883a 	mov	sp,fp
 d001710:	dfc00117 	ldw	ra,4(sp)
 d001714:	df000017 	ldw	fp,0(sp)
 d001718:	dec00204 	addi	sp,sp,8
 d00171c:	f800283a 	ret

0d001720 <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 d001720:	defff804 	addi	sp,sp,-32
 d001724:	dfc00715 	stw	ra,28(sp)
 d001728:	df000615 	stw	fp,24(sp)
 d00172c:	df000604 	addi	fp,sp,24
 d001730:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 d001734:	00bfffc4 	movi	r2,-1
 d001738:	e0bffe15 	stw	r2,-8(fp)
    alt_u32 ser_num = 0;
 d00173c:	e03ffd15 	stw	zero,-12(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 d001740:	01034174 	movhi	r4,3333
 d001744:	212d7f04 	addi	r4,r4,-18948
 d001748:	d002cc00 	call	d002cc0 <puts>
    printf("a MAC address.\n\n");
 d00174c:	01034174 	movhi	r4,3333
 d001750:	212d8f04 	addi	r4,r4,-18884
 d001754:	d002cc00 	call	d002cc0 <puts>
    
    ser_num = get_serial_number();
 d001758:	d0013980 	call	d001398 <get_serial_number>
 d00175c:	e0bffd15 	stw	r2,-12(fp)
  
    if (ser_num)
 d001760:	e0bffd17 	ldw	r2,-12(fp)
 d001764:	1005003a 	cmpeq	r2,r2,zero
 d001768:	1000361e 	bne	r2,zero,d001844 <generate_mac_addr+0x124>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 d00176c:	e0bfff17 	ldw	r2,-4(fp)
 d001770:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 d001774:	e0bfff17 	ldw	r2,-4(fp)
 d001778:	10c00044 	addi	r3,r2,1
 d00177c:	008001c4 	movi	r2,7
 d001780:	18800005 	stb	r2,0(r3)
        mac_addr[2] = 0xed;
 d001784:	e0bfff17 	ldw	r2,-4(fp)
 d001788:	10c00084 	addi	r3,r2,2
 d00178c:	00bffb44 	movi	r2,-19
 d001790:	18800005 	stb	r2,0(r3)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
 d001794:	e0bfff17 	ldw	r2,-4(fp)
 d001798:	10c000c4 	addi	r3,r2,3
 d00179c:	00bfffc4 	movi	r2,-1
 d0017a0:	18800005 	stb	r2,0(r3)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 d0017a4:	e0bfff17 	ldw	r2,-4(fp)
 d0017a8:	10c00104 	addi	r3,r2,4
 d0017ac:	e0bffd17 	ldw	r2,-12(fp)
 d0017b0:	10bfc00c 	andi	r2,r2,65280
 d0017b4:	1004d23a 	srli	r2,r2,8
 d0017b8:	18800005 	stb	r2,0(r3)
        mac_addr[5] = ser_num & 0xff;
 d0017bc:	e0bfff17 	ldw	r2,-4(fp)
 d0017c0:	10c00144 	addi	r3,r2,5
 d0017c4:	e0bffd17 	ldw	r2,-12(fp)
 d0017c8:	18800005 	stb	r2,0(r3)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 d0017cc:	e0bfff17 	ldw	r2,-4(fp)
 d0017d0:	10800003 	ldbu	r2,0(r2)
 d0017d4:	11403fcc 	andi	r5,r2,255
 d0017d8:	e0bfff17 	ldw	r2,-4(fp)
 d0017dc:	10800044 	addi	r2,r2,1
 d0017e0:	10800003 	ldbu	r2,0(r2)
 d0017e4:	11803fcc 	andi	r6,r2,255
 d0017e8:	e0bfff17 	ldw	r2,-4(fp)
 d0017ec:	10800084 	addi	r2,r2,2
 d0017f0:	10800003 	ldbu	r2,0(r2)
 d0017f4:	11c03fcc 	andi	r7,r2,255
 d0017f8:	e0bfff17 	ldw	r2,-4(fp)
 d0017fc:	108000c4 	addi	r2,r2,3
 d001800:	10800003 	ldbu	r2,0(r2)
 d001804:	10c03fcc 	andi	r3,r2,255
 d001808:	e0bfff17 	ldw	r2,-4(fp)
 d00180c:	10800104 	addi	r2,r2,4
 d001810:	10800003 	ldbu	r2,0(r2)
 d001814:	11003fcc 	andi	r4,r2,255
 d001818:	e0bfff17 	ldw	r2,-4(fp)
 d00181c:	10800144 	addi	r2,r2,5
 d001820:	10800003 	ldbu	r2,0(r2)
 d001824:	10803fcc 	andi	r2,r2,255
 d001828:	d8c00015 	stw	r3,0(sp)
 d00182c:	d9000115 	stw	r4,4(sp)
 d001830:	d8800215 	stw	r2,8(sp)
 d001834:	01034174 	movhi	r4,3333
 d001838:	212d9304 	addi	r4,r4,-18868
 d00183c:	d0029980 	call	d002998 <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 d001840:	e03ffe15 	stw	zero,-8(fp)
    }
  
    return error;    
 d001844:	e0bffe17 	ldw	r2,-8(fp)
}
 d001848:	e037883a 	mov	sp,fp
 d00184c:	dfc00117 	ldw	ra,4(sp)
 d001850:	df000017 	ldw	fp,0(sp)
 d001854:	dec00204 	addi	sp,sp,8
 d001858:	f800283a 	ret

0d00185c <get_board_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 d00185c:	defff804 	addi	sp,sp,-32
 d001860:	dfc00715 	stw	ra,28(sp)
 d001864:	df000615 	stw	fp,24(sp)
 d001868:	df000604 	addi	fp,sp,24
 d00186c:	e13fff15 	stw	r4,-4(fp)
    error_t error = 0;
 d001870:	e03ffe15 	stw	zero,-8(fp)
    alt_u32 signature;
    
    /* Get the flash sector with the MAC address. */
    error = FindLastFlashSectorOffset(&last_flash_sector_offset);
 d001874:	d1205704 	addi	r4,gp,-32420
 d001878:	d0019f00 	call	d0019f0 <FindLastFlashSectorOffset>
 d00187c:	e0bffe15 	stw	r2,-8(fp)
    if (!error)
 d001880:	e0bffe17 	ldw	r2,-8(fp)
 d001884:	1004c03a 	cmpne	r2,r2,zero
 d001888:	1000041e 	bne	r2,zero,d00189c <get_board_mac_addr+0x40>
        last_flash_sector = EXT_FLASH_BASE + last_flash_sector_offset;
 d00188c:	d0a05717 	ldw	r2,-32420(gp)
 d001890:	00c20034 	movhi	r3,2048
 d001894:	10c5883a 	add	r2,r2,r3
 d001898:	d0a05815 	stw	r2,-32416(gp)
     * valid network settings are present, indicated by a signature of 0x00005afe at 
     * the first address of the last flash sector.  This hex value is chosen as the 
     * signature since it looks like the english word "SAFE", meaning that it is 
     * safe to use these network address values.  
    */
    if (!error)
 d00189c:	e0bffe17 	ldw	r2,-8(fp)
 d0018a0:	1004c03a 	cmpne	r2,r2,zero
 d0018a4:	1000081e 	bne	r2,zero,d0018c8 <get_board_mac_addr+0x6c>
    {
        signature = IORD_32DIRECT(last_flash_sector, 0);
 d0018a8:	d0a05817 	ldw	r2,-32416(gp)
 d0018ac:	10800037 	ldwio	r2,0(r2)
 d0018b0:	e0bffd15 	stw	r2,-12(fp)
        if (signature != 0x00005afe)
 d0018b4:	e0bffd17 	ldw	r2,-12(fp)
 d0018b8:	1096bfa0 	cmpeqi	r2,r2,23294
 d0018bc:	1000021e 	bne	r2,zero,d0018c8 <get_board_mac_addr+0x6c>
        {
          error = generate_and_store_mac_addr();
 d0018c0:	d0015740 	call	d001574 <generate_and_store_mac_addr>
 d0018c4:	e0bffe15 	stw	r2,-8(fp)
        }
    }
  
    if (!error)
 d0018c8:	e0bffe17 	ldw	r2,-8(fp)
 d0018cc:	1004c03a 	cmpne	r2,r2,zero
 d0018d0:	1000411e 	bne	r2,zero,d0019d8 <get_board_mac_addr+0x17c>
    {
        mac_addr[0] = IORD_8DIRECT(last_flash_sector, 4);
 d0018d4:	d0a05817 	ldw	r2,-32416(gp)
 d0018d8:	10800104 	addi	r2,r2,4
 d0018dc:	10800023 	ldbuio	r2,0(r2)
 d0018e0:	1007883a 	mov	r3,r2
 d0018e4:	e0bfff17 	ldw	r2,-4(fp)
 d0018e8:	10c00005 	stb	r3,0(r2)
        mac_addr[1] = IORD_8DIRECT(last_flash_sector, 5);
 d0018ec:	e0bfff17 	ldw	r2,-4(fp)
 d0018f0:	10c00044 	addi	r3,r2,1
 d0018f4:	d0a05817 	ldw	r2,-32416(gp)
 d0018f8:	10800144 	addi	r2,r2,5
 d0018fc:	10800023 	ldbuio	r2,0(r2)
 d001900:	18800005 	stb	r2,0(r3)
        mac_addr[2] = IORD_8DIRECT(last_flash_sector, 6);
 d001904:	e0bfff17 	ldw	r2,-4(fp)
 d001908:	10c00084 	addi	r3,r2,2
 d00190c:	d0a05817 	ldw	r2,-32416(gp)
 d001910:	10800184 	addi	r2,r2,6
 d001914:	10800023 	ldbuio	r2,0(r2)
 d001918:	18800005 	stb	r2,0(r3)
        mac_addr[3] = IORD_8DIRECT(last_flash_sector, 7);
 d00191c:	e0bfff17 	ldw	r2,-4(fp)
 d001920:	10c000c4 	addi	r3,r2,3
 d001924:	d0a05817 	ldw	r2,-32416(gp)
 d001928:	108001c4 	addi	r2,r2,7
 d00192c:	10800023 	ldbuio	r2,0(r2)
 d001930:	18800005 	stb	r2,0(r3)
        mac_addr[4] = IORD_8DIRECT(last_flash_sector, 8);
 d001934:	e0bfff17 	ldw	r2,-4(fp)
 d001938:	10c00104 	addi	r3,r2,4
 d00193c:	d0a05817 	ldw	r2,-32416(gp)
 d001940:	10800204 	addi	r2,r2,8
 d001944:	10800023 	ldbuio	r2,0(r2)
 d001948:	18800005 	stb	r2,0(r3)
        mac_addr[5] = IORD_8DIRECT(last_flash_sector, 9);
 d00194c:	e0bfff17 	ldw	r2,-4(fp)
 d001950:	10c00144 	addi	r3,r2,5
 d001954:	d0a05817 	ldw	r2,-32416(gp)
 d001958:	10800244 	addi	r2,r2,9
 d00195c:	10800023 	ldbuio	r2,0(r2)
 d001960:	18800005 	stb	r2,0(r3)
    
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 d001964:	e0bfff17 	ldw	r2,-4(fp)
 d001968:	10800003 	ldbu	r2,0(r2)
 d00196c:	11403fcc 	andi	r5,r2,255
 d001970:	e0bfff17 	ldw	r2,-4(fp)
 d001974:	10800044 	addi	r2,r2,1
 d001978:	10800003 	ldbu	r2,0(r2)
 d00197c:	11803fcc 	andi	r6,r2,255
 d001980:	e0bfff17 	ldw	r2,-4(fp)
 d001984:	10800084 	addi	r2,r2,2
 d001988:	10800003 	ldbu	r2,0(r2)
 d00198c:	11c03fcc 	andi	r7,r2,255
 d001990:	e0bfff17 	ldw	r2,-4(fp)
 d001994:	108000c4 	addi	r2,r2,3
 d001998:	10800003 	ldbu	r2,0(r2)
 d00199c:	10c03fcc 	andi	r3,r2,255
 d0019a0:	e0bfff17 	ldw	r2,-4(fp)
 d0019a4:	10800104 	addi	r2,r2,4
 d0019a8:	10800003 	ldbu	r2,0(r2)
 d0019ac:	11003fcc 	andi	r4,r2,255
 d0019b0:	e0bfff17 	ldw	r2,-4(fp)
 d0019b4:	10800144 	addi	r2,r2,5
 d0019b8:	10800003 	ldbu	r2,0(r2)
 d0019bc:	10803fcc 	andi	r2,r2,255
 d0019c0:	d8c00015 	stw	r3,0(sp)
 d0019c4:	d9000115 	stw	r4,4(sp)
 d0019c8:	d8800215 	stw	r2,8(sp)
 d0019cc:	01034174 	movhi	r4,3333
 d0019d0:	212d9304 	addi	r4,r4,-18868
 d0019d4:	d0029980 	call	d002998 <printf>
            mac_addr[4],
            mac_addr[5]);
    
    }
    
    return error;
 d0019d8:	e0bffe17 	ldw	r2,-8(fp)
}
 d0019dc:	e037883a 	mov	sp,fp
 d0019e0:	dfc00117 	ldw	ra,4(sp)
 d0019e4:	df000017 	ldw	fp,0(sp)
 d0019e8:	dec00204 	addi	sp,sp,8
 d0019ec:	f800283a 	ret

0d0019f0 <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 d0019f0:	defff304 	addi	sp,sp,-52
 d0019f4:	dfc00c15 	stw	ra,48(sp)
 d0019f8:	df000b15 	stw	fp,44(sp)
 d0019fc:	df000b04 	addi	fp,sp,44
 d001a00:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 d001a04:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EXT_FLASH_NAME);
 d001a08:	01034174 	movhi	r4,3333
 d001a0c:	212d7b04 	addi	r4,r4,-18964
 d001a10:	d00cddc0 	call	d00cddc <alt_flash_open_dev>
 d001a14:	e0bffc15 	stw	r2,-16(fp)
    if (fd <= 0)
 d001a18:	e0bffc17 	ldw	r2,-16(fp)
 d001a1c:	1004c03a 	cmpne	r2,r2,zero
 d001a20:	1000021e 	bne	r2,zero,d001a2c <FindLastFlashSectorOffset+0x3c>
        error = -1;
 d001a24:	00bfffc4 	movi	r2,-1
 d001a28:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 d001a2c:	e0bff817 	ldw	r2,-32(fp)
 d001a30:	1004c03a 	cmpne	r2,r2,zero
 d001a34:	10000d1e 	bne	r2,zero,d001a6c <FindLastFlashSectorOffset+0x7c>
 d001a38:	e0bffc17 	ldw	r2,-16(fp)
 d001a3c:	e0bff515 	stw	r2,-44(fp)
 d001a40:	e0bffd04 	addi	r2,fp,-12
 d001a44:	e0bff615 	stw	r2,-40(fp)
 d001a48:	e0bffe04 	addi	r2,fp,-8
 d001a4c:	e0bff715 	stw	r2,-36(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 d001a50:	e0bff517 	ldw	r2,-44(fp)
 d001a54:	10800717 	ldw	r2,28(r2)
 d001a58:	e13ff517 	ldw	r4,-44(fp)
 d001a5c:	e17ff617 	ldw	r5,-40(fp)
 d001a60:	e1bff717 	ldw	r6,-36(fp)
 d001a64:	103ee83a 	callr	r2
        error = alt_get_flash_info(fd, &regions, &numRegions);
 d001a68:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 d001a6c:	e0bff817 	ldw	r2,-32(fp)
 d001a70:	1004c03a 	cmpne	r2,r2,zero
 d001a74:	1000231e 	bne	r2,zero,d001b04 <FindLastFlashSectorOffset+0x114>
    {
        pLastRegion = &(regions[0]);
 d001a78:	e0bffd17 	ldw	r2,-12(fp)
 d001a7c:	e0bffb15 	stw	r2,-20(fp)
        for (n = 1; n < numRegions; n++)
 d001a80:	00800044 	movi	r2,1
 d001a84:	e0bff915 	stw	r2,-28(fp)
 d001a88:	00001206 	br	d001ad4 <FindLastFlashSectorOffset+0xe4>
        {
            if (regions[n].offset > pLastRegion->offset)
 d001a8c:	e0bff917 	ldw	r2,-28(fp)
 d001a90:	1004913a 	slli	r2,r2,4
 d001a94:	1007883a 	mov	r3,r2
 d001a98:	e0bffd17 	ldw	r2,-12(fp)
 d001a9c:	1885883a 	add	r2,r3,r2
 d001aa0:	10c00017 	ldw	r3,0(r2)
 d001aa4:	e0bffb17 	ldw	r2,-20(fp)
 d001aa8:	10800017 	ldw	r2,0(r2)
 d001aac:	10c0060e 	bge	r2,r3,d001ac8 <FindLastFlashSectorOffset+0xd8>
                pLastRegion = &(regions[n]);
 d001ab0:	e0bff917 	ldw	r2,-28(fp)
 d001ab4:	1004913a 	slli	r2,r2,4
 d001ab8:	1007883a 	mov	r3,r2
 d001abc:	e0bffd17 	ldw	r2,-12(fp)
 d001ac0:	1885883a 	add	r2,r3,r2
 d001ac4:	e0bffb15 	stw	r2,-20(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 d001ac8:	e0bff917 	ldw	r2,-28(fp)
 d001acc:	10800044 	addi	r2,r2,1
 d001ad0:	e0bff915 	stw	r2,-28(fp)
 d001ad4:	e0fffe17 	ldw	r3,-8(fp)
 d001ad8:	e0bff917 	ldw	r2,-28(fp)
 d001adc:	10ffeb16 	blt	r2,r3,d001a8c <FindLastFlashSectorOffset+0x9c>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 d001ae0:	e0bffb17 	ldw	r2,-20(fp)
 d001ae4:	10c00017 	ldw	r3,0(r2)
 d001ae8:	e0bffb17 	ldw	r2,-20(fp)
 d001aec:	10800117 	ldw	r2,4(r2)
 d001af0:	1887883a 	add	r3,r3,r2
 d001af4:	e0bffb17 	ldw	r2,-20(fp)
 d001af8:	10800317 	ldw	r2,12(r2)
 d001afc:	1885c83a 	sub	r2,r3,r2
 d001b00:	e0bffa15 	stw	r2,-24(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 d001b04:	e0bff817 	ldw	r2,-32(fp)
 d001b08:	1004c03a 	cmpne	r2,r2,zero
 d001b0c:	1000031e 	bne	r2,zero,d001b1c <FindLastFlashSectorOffset+0x12c>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 d001b10:	e0fffa17 	ldw	r3,-24(fp)
 d001b14:	e0bfff17 	ldw	r2,-4(fp)
 d001b18:	10c00015 	stw	r3,0(r2)

    return (error);
 d001b1c:	e0bff817 	ldw	r2,-32(fp)
}
 d001b20:	e037883a 	mov	sp,fp
 d001b24:	dfc00117 	ldw	ra,4(sp)
 d001b28:	df000017 	ldw	fp,0(sp)
 d001b2c:	dec00204 	addi	sp,sp,8
 d001b30:	f800283a 	ret

0d001b34 <SSSCreateOSDataStructs>:
/*
 * Create our MicroC/OS-II resources. All of the resources beginning with 
 * "SSS" are declared in this file, and created in this function.
 */
void SSSCreateOSDataStructs(void)
{
 d001b34:	defffd04 	addi	sp,sp,-12
 d001b38:	dfc00215 	stw	ra,8(sp)
 d001b3c:	df000115 	stw	fp,4(sp)
 d001b40:	df000104 	addi	fp,sp,4
  /*
  * Create the resource for our MicroC/OS-II Queue for sending commands 
  * received on the TCP/IP socket from the SSSSimpleSocketServerTask()
  * to the LEDManagementTask().
  */
  SSSLEDCommandQ = OSQCreate(&SSSLEDCommandQTbl[0], SSS_LED_COMMAND_Q_SIZE);
 d001b44:	01034174 	movhi	r4,3333
 d001b48:	211ca104 	addi	r4,r4,29316
 d001b4c:	01400784 	movi	r5,30
 d001b50:	d011c000 	call	d011c00 <OSQCreate>
 d001b54:	d0a05a15 	stw	r2,-32408(gp)
  if (!SSSLEDCommandQ)
 d001b58:	d0a05a17 	ldw	r2,-32408(gp)
 d001b5c:	1004c03a 	cmpne	r2,r2,zero
 d001b60:	1000041e 	bne	r2,zero,d001b74 <SSSCreateOSDataStructs+0x40>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 d001b64:	01003fc4 	movi	r4,255
 d001b68:	01434174 	movhi	r5,3333
 d001b6c:	296da204 	addi	r5,r5,-18808
 d001b70:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
  * toggle the lightshow off, and gives up the semaphore to turn the lightshow
  * back on.  The LEDTask does this in response to the CMD_LEDS_LIGHTSHOW
  * command sent from the SSSSimpleSocketServerTask when the user sends the 
  * toggle lightshow command over the TCPIP socket.
  */
  SSSLEDLightshowSem = OSSemCreate(1);
 d001b74:	01000044 	movi	r4,1
 d001b78:	d012ea00 	call	d012ea0 <OSSemCreate>
 d001b7c:	d0a05b15 	stw	r2,-32404(gp)
  if (!SSSLEDLightshowSem)
 d001b80:	d0a05b17 	ldw	r2,-32404(gp)
 d001b84:	1004c03a 	cmpne	r2,r2,zero
 d001b88:	1000041e 	bne	r2,zero,d001b9c <SSSCreateOSDataStructs+0x68>
  {
     alt_uCOSIIErrorHandler(EXPANDED_DIAGNOSIS_CODE, 
 d001b8c:	01003fc4 	movi	r4,255
 d001b90:	01434174 	movhi	r5,3333
 d001b94:	296dab04 	addi	r5,r5,-18772
 d001b98:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
  
 /*
  * Create our MicroC/OS-II LED Event Flag.  Each flag corresponds to one of
  * the LEDs on the Nios Development board, D0 - D7. 
  */   
  SSSLEDEventFlag = OSFlagCreate(0, &error_code);
 d001b9c:	0009883a 	mov	r4,zero
 d001ba0:	e17fff04 	addi	r5,fp,-4
 d001ba4:	d00fc9c0 	call	d00fc9c <OSFlagCreate>
 d001ba8:	d0a05c15 	stw	r2,-32400(gp)
  if (!SSSLEDEventFlag)
 d001bac:	d0a05c17 	ldw	r2,-32400(gp)
 d001bb0:	1004c03a 	cmpne	r2,r2,zero
 d001bb4:	1000041e 	bne	r2,zero,d001bc8 <SSSCreateOSDataStructs+0x94>
  {
     alt_uCOSIIErrorHandler(error_code, 0);
 d001bb8:	e0bfff03 	ldbu	r2,-4(fp)
 d001bbc:	11003fcc 	andi	r4,r2,255
 d001bc0:	000b883a 	mov	r5,zero
 d001bc4:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
  }
}
 d001bc8:	e037883a 	mov	sp,fp
 d001bcc:	dfc00117 	ldw	ra,4(sp)
 d001bd0:	df000017 	ldw	fp,0(sp)
 d001bd4:	dec00204 	addi	sp,sp,8
 d001bd8:	f800283a 	ret

0d001bdc <SSSCreateTasks>:
/* This function creates tasks used in this example which do not use sockets.
 * Tasks which use Interniche sockets must be created with TK_NEWTASK.
 */
 
void SSSCreateTasks(void)
{
 d001bdc:	defff804 	addi	sp,sp,-32
 d001be0:	dfc00715 	stw	ra,28(sp)
 d001be4:	df000615 	stw	fp,24(sp)
 d001be8:	df000604 	addi	fp,sp,24
   INT8U error_code;
  
   error_code = OSTaskCreateExt(LED7SegLightshowTask,
 d001bec:	01834174 	movhi	r6,3333
 d001bf0:	319ca004 	addi	r6,r6,29312
 d001bf4:	00800484 	movi	r2,18
 d001bf8:	d8800015 	stw	r2,0(sp)
 d001bfc:	00834174 	movhi	r2,3333
 d001c00:	1094a104 	addi	r2,r2,21124
 d001c04:	d8800115 	stw	r2,4(sp)
 d001c08:	00820004 	movi	r2,2048
 d001c0c:	d8800215 	stw	r2,8(sp)
 d001c10:	d8000315 	stw	zero,12(sp)
 d001c14:	d8000415 	stw	zero,16(sp)
 d001c18:	01034034 	movhi	r4,3328
 d001c1c:	21042304 	addi	r4,r4,4236
 d001c20:	000b883a 	mov	r5,zero
 d001c24:	01c00484 	movi	r7,18
 d001c28:	d0140f00 	call	d0140f0 <OSTaskCreateExt>
 d001c2c:	e0bfff05 	stb	r2,-4(fp)
                             LED7SegLightshowTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
   
   alt_uCOSIIErrorHandler(error_code, 0);
 d001c30:	e13fff03 	ldbu	r4,-4(fp)
 d001c34:	000b883a 	mov	r5,zero
 d001c38:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>
  
   error_code = OSTaskCreateExt(LEDManagementTask,
 d001c3c:	018341b4 	movhi	r6,3334
 d001c40:	31a4be04 	addi	r6,r6,-27912
 d001c44:	008001c4 	movi	r2,7
 d001c48:	d8800015 	stw	r2,0(sp)
 d001c4c:	00834174 	movhi	r2,3333
 d001c50:	109cbf04 	addi	r2,r2,29436
 d001c54:	d8800115 	stw	r2,4(sp)
 d001c58:	00820004 	movi	r2,2048
 d001c5c:	d8800215 	stw	r2,8(sp)
 d001c60:	d8000315 	stw	zero,12(sp)
 d001c64:	d8000415 	stw	zero,16(sp)
 d001c68:	01034034 	movhi	r4,3328
 d001c6c:	21044004 	addi	r4,r4,4352
 d001c70:	000b883a 	mov	r5,zero
 d001c74:	01c001c4 	movi	r7,7
 d001c78:	d0140f00 	call	d0140f0 <OSTaskCreateExt>
 d001c7c:	e0bfff05 	stb	r2,-4(fp)
                              LEDManagementTaskStk,
                              TASK_STACKSIZE,
                              NULL,
                              0);

   alt_uCOSIIErrorHandler(error_code, 0);
 d001c80:	e13fff03 	ldbu	r4,-4(fp)
 d001c84:	000b883a 	mov	r5,zero
 d001c88:	d0003040 	call	d000304 <alt_uCOSIIErrorHandler>

}
 d001c8c:	e037883a 	mov	sp,fp
 d001c90:	dfc00117 	ldw	ra,4(sp)
 d001c94:	df000017 	ldw	fp,0(sp)
 d001c98:	dec00204 	addi	sp,sp,8
 d001c9c:	f800283a 	ret

0d001ca0 <sss_reset_connection>:
 * to a reliable initial state. Note that we set our socket (FD) number to
 * -1 to easily determine whether the connection is in a "reset, ready to go" 
 * state.
 */
void sss_reset_connection(SSSConn* conn)
{
 d001ca0:	defffd04 	addi	sp,sp,-12
 d001ca4:	dfc00215 	stw	ra,8(sp)
 d001ca8:	df000115 	stw	fp,4(sp)
 d001cac:	df000104 	addi	fp,sp,4
 d001cb0:	e13fff15 	stw	r4,-4(fp)
  memset(conn, 0, sizeof(SSSConn));
 d001cb4:	e0bfff17 	ldw	r2,-4(fp)
 d001cb8:	1009883a 	mov	r4,r2
 d001cbc:	01817c04 	movi	r6,1520
 d001cc0:	000b883a 	mov	r5,zero
 d001cc4:	d0028800 	call	d002880 <memset>

  conn->fd = -1;
 d001cc8:	e0ffff17 	ldw	r3,-4(fp)
 d001ccc:	00bfffc4 	movi	r2,-1
 d001cd0:	18800115 	stw	r2,4(r3)
  conn->state = READY;
 d001cd4:	e0bfff17 	ldw	r2,-4(fp)
 d001cd8:	10000015 	stw	zero,0(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 d001cdc:	e0bfff17 	ldw	r2,-4(fp)
 d001ce0:	10c00304 	addi	r3,r2,12
 d001ce4:	e0bfff17 	ldw	r2,-4(fp)
 d001ce8:	10c17b15 	stw	r3,1516(r2)
  conn->rx_rd_pos = conn->rx_buffer;
 d001cec:	e0bfff17 	ldw	r2,-4(fp)
 d001cf0:	10c00304 	addi	r3,r2,12
 d001cf4:	e0bfff17 	ldw	r2,-4(fp)
 d001cf8:	10c17a15 	stw	r3,1512(r2)
  return;
}
 d001cfc:	e037883a 	mov	sp,fp
 d001d00:	dfc00117 	ldw	ra,4(sp)
 d001d04:	df000017 	ldw	fp,0(sp)
 d001d08:	dec00204 	addi	sp,sp,8
 d001d0c:	f800283a 	ret

0d001d10 <sss_send_menu>:
 * sss_send_menu()
 * 
 * This routine will transmit the menu out to the telent client.
 */
void sss_send_menu(SSSConn* conn)
{
 d001d10:	defe8504 	addi	sp,sp,-1516
 d001d14:	dfc17a15 	stw	ra,1512(sp)
 d001d18:	df017915 	stw	fp,1508(sp)
 d001d1c:	df017904 	addi	fp,sp,1508
 d001d20:	e13fff15 	stw	r4,-4(fp)
  alt_u8  tx_buf[SSS_TX_BUF_SIZE];
  alt_u8 *tx_wr_pos = tx_buf;
 d001d24:	e0be8804 	addi	r2,fp,-1504
 d001d28:	e0be8715 	stw	r2,-1508(fp)

  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 d001d2c:	e0be8717 	ldw	r2,-1508(fp)
 d001d30:	00c34174 	movhi	r3,3333
 d001d34:	18edb504 	addi	r3,r3,-18732
 d001d38:	1009883a 	mov	r4,r2
 d001d3c:	180b883a 	mov	r5,r3
 d001d40:	01800904 	movi	r6,36
 d001d44:	d0027000 	call	d002700 <memcpy>
 d001d48:	e0be8717 	ldw	r2,-1508(fp)
 d001d4c:	108008c4 	addi	r2,r2,35
 d001d50:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Nios II Simple Socket Server Menu\n\r");
 d001d54:	e0be8717 	ldw	r2,-1508(fp)
 d001d58:	00c34174 	movhi	r3,3333
 d001d5c:	18edbe04 	addi	r3,r3,-18696
 d001d60:	1009883a 	mov	r4,r2
 d001d64:	180b883a 	mov	r5,r3
 d001d68:	01800904 	movi	r6,36
 d001d6c:	d0027000 	call	d002700 <memcpy>
 d001d70:	e0be8717 	ldw	r2,-1508(fp)
 d001d74:	108008c4 	addi	r2,r2,35
 d001d78:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 d001d7c:	e0be8717 	ldw	r2,-1508(fp)
 d001d80:	00c34174 	movhi	r3,3333
 d001d84:	18edb504 	addi	r3,r3,-18732
 d001d88:	1009883a 	mov	r4,r2
 d001d8c:	180b883a 	mov	r5,r3
 d001d90:	01800904 	movi	r6,36
 d001d94:	d0027000 	call	d002700 <memcpy>
 d001d98:	e0be8717 	ldw	r2,-1508(fp)
 d001d9c:	108008c4 	addi	r2,r2,35
 d001da0:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"0-7: Toggle board LEDs D0 - D7\n\r");
 d001da4:	e0be8717 	ldw	r2,-1508(fp)
 d001da8:	00c34174 	movhi	r3,3333
 d001dac:	18edc704 	addi	r3,r3,-18660
 d001db0:	1009883a 	mov	r4,r2
 d001db4:	180b883a 	mov	r5,r3
 d001db8:	01800844 	movi	r6,33
 d001dbc:	d0027000 	call	d002700 <memcpy>
 d001dc0:	e0be8717 	ldw	r2,-1508(fp)
 d001dc4:	10800804 	addi	r2,r2,32
 d001dc8:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"S: 7-Segment LED Light Show\n\r");
 d001dcc:	e0be8717 	ldw	r2,-1508(fp)
 d001dd0:	00c34174 	movhi	r3,3333
 d001dd4:	18edd004 	addi	r3,r3,-18624
 d001dd8:	1009883a 	mov	r4,r2
 d001ddc:	180b883a 	mov	r5,r3
 d001de0:	01800784 	movi	r6,30
 d001de4:	d0027000 	call	d002700 <memcpy>
 d001de8:	e0be8717 	ldw	r2,-1508(fp)
 d001dec:	10800744 	addi	r2,r2,29
 d001df0:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Q: Terminate session\n\r");
 d001df4:	e0be8717 	ldw	r2,-1508(fp)
 d001df8:	00c34174 	movhi	r3,3333
 d001dfc:	18edd804 	addi	r3,r3,-18592
 d001e00:	1009883a 	mov	r4,r2
 d001e04:	180b883a 	mov	r5,r3
 d001e08:	018005c4 	movi	r6,23
 d001e0c:	d0027000 	call	d002700 <memcpy>
 d001e10:	e0be8717 	ldw	r2,-1508(fp)
 d001e14:	10800584 	addi	r2,r2,22
 d001e18:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"=================================\n\r");
 d001e1c:	e0be8717 	ldw	r2,-1508(fp)
 d001e20:	00c34174 	movhi	r3,3333
 d001e24:	18edb504 	addi	r3,r3,-18732
 d001e28:	1009883a 	mov	r4,r2
 d001e2c:	180b883a 	mov	r5,r3
 d001e30:	01800904 	movi	r6,36
 d001e34:	d0027000 	call	d002700 <memcpy>
 d001e38:	e0be8717 	ldw	r2,-1508(fp)
 d001e3c:	108008c4 	addi	r2,r2,35
 d001e40:	e0be8715 	stw	r2,-1508(fp)
  tx_wr_pos += sprintf(tx_wr_pos,"Enter your choice & press return:\n\r");
 d001e44:	e0be8717 	ldw	r2,-1508(fp)
 d001e48:	00c34174 	movhi	r3,3333
 d001e4c:	18edde04 	addi	r3,r3,-18568
 d001e50:	1009883a 	mov	r4,r2
 d001e54:	180b883a 	mov	r5,r3
 d001e58:	01800904 	movi	r6,36
 d001e5c:	d0027000 	call	d002700 <memcpy>
 d001e60:	e0be8717 	ldw	r2,-1508(fp)
 d001e64:	108008c4 	addi	r2,r2,35
 d001e68:	e0be8715 	stw	r2,-1508(fp)

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);
 d001e6c:	e0bfff17 	ldw	r2,-4(fp)
 d001e70:	11000117 	ldw	r4,4(r2)
 d001e74:	e17e8804 	addi	r5,fp,-1504
 d001e78:	e0fe8717 	ldw	r3,-1508(fp)
 d001e7c:	e0be8804 	addi	r2,fp,-1504
 d001e80:	188dc83a 	sub	r6,r3,r2
 d001e84:	000f883a 	mov	r7,zero
 d001e88:	d02d70c0 	call	d02d70c <t_send>
  
  return;
}
 d001e8c:	e037883a 	mov	sp,fp
 d001e90:	dfc00117 	ldw	ra,4(sp)
 d001e94:	df000017 	ldw	fp,0(sp)
 d001e98:	dec00204 	addi	sp,sp,8
 d001e9c:	f800283a 	ret

0d001ea0 <sss_handle_accept>:
 * reject the incoming request by immediately closing the new socket.
 * 
 * We'll also print out the client's IP address.
 */
void sss_handle_accept(int listen_socket, SSSConn* conn)
{
 d001ea0:	defff604 	addi	sp,sp,-40
 d001ea4:	dfc00915 	stw	ra,36(sp)
 d001ea8:	df000815 	stw	fp,32(sp)
 d001eac:	df000804 	addi	fp,sp,32
 d001eb0:	e13ffe15 	stw	r4,-8(fp)
 d001eb4:	e17fff15 	stw	r5,-4(fp)
  int                 socket, len;
  struct sockaddr_in  incoming_addr;

  len = sizeof(incoming_addr);
 d001eb8:	00800404 	movi	r2,16
 d001ebc:	e0bff915 	stw	r2,-28(fp)

  if ((conn)->fd == -1)
 d001ec0:	e0bfff17 	ldw	r2,-4(fp)
 d001ec4:	10800117 	ldw	r2,4(r2)
 d001ec8:	10bfffd8 	cmpnei	r2,r2,-1
 d001ecc:	1000191e 	bne	r2,zero,d001f34 <sss_handle_accept+0x94>
  {
     if((socket=accept(listen_socket,(struct sockaddr*)&incoming_addr,&len))<0)
 d001ed0:	e17ffa04 	addi	r5,fp,-24
 d001ed4:	e1bff904 	addi	r6,fp,-28
 d001ed8:	e13ffe17 	ldw	r4,-8(fp)
 d001edc:	d0236440 	call	d023644 <bsd_accept>
 d001ee0:	e0bff815 	stw	r2,-32(fp)
 d001ee4:	e0bff817 	ldw	r2,-32(fp)
 d001ee8:	1004403a 	cmpge	r2,r2,zero
 d001eec:	1000051e 	bne	r2,zero,d001f04 <sss_handle_accept+0x64>
     {
         alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,
 d001ef0:	01003fc4 	movi	r4,255
 d001ef4:	01434174 	movhi	r5,3333
 d001ef8:	296de704 	addi	r5,r5,-18532
 d001efc:	d0009280 	call	d000928 <alt_NetworkErrorHandler>
 d001f00:	00001206 	br	d001f4c <sss_handle_accept+0xac>
                                 "[sss_handle_accept] accept failed");
     }
     else
     {
        (conn)->fd = socket;
 d001f04:	e0bfff17 	ldw	r2,-4(fp)
 d001f08:	e0fff817 	ldw	r3,-32(fp)
 d001f0c:	10c00115 	stw	r3,4(r2)
        sss_send_menu(conn);
 d001f10:	e13fff17 	ldw	r4,-4(fp)
 d001f14:	d001d100 	call	d001d10 <sss_send_menu>
        printf("[sss_handle_accept] accepted connection request from %s\n",
 d001f18:	e13ffb17 	ldw	r4,-20(fp)
 d001f1c:	d023db00 	call	d023db0 <bsd_inet_ntoa>
 d001f20:	100b883a 	mov	r5,r2
 d001f24:	01034174 	movhi	r4,3333
 d001f28:	212df004 	addi	r4,r4,-18496
 d001f2c:	d0029980 	call	d002998 <printf>
 d001f30:	00000606 	br	d001f4c <sss_handle_accept+0xac>
               inet_ntoa(incoming_addr.sin_addr));
     }
  }
  else
  {
    printf("[sss_handle_accept] rejected connection request from %s\n",
 d001f34:	e13ffb17 	ldw	r4,-20(fp)
 d001f38:	d023db00 	call	d023db0 <bsd_inet_ntoa>
 d001f3c:	100b883a 	mov	r5,r2
 d001f40:	01034174 	movhi	r4,3333
 d001f44:	212dff04 	addi	r4,r4,-18436
 d001f48:	d0029980 	call	d002998 <printf>
           inet_ntoa(incoming_addr.sin_addr));
  }

  return;
}
 d001f4c:	e037883a 	mov	sp,fp
 d001f50:	dfc00117 	ldw	ra,4(sp)
 d001f54:	df000017 	ldw	fp,0(sp)
 d001f58:	dec00204 	addi	sp,sp,8
 d001f5c:	f800283a 	ret

0d001f60 <sss_exec_command>:
 * If the user wishes to quit, we set the "close" member of our SSSConn
 * struct, which will be looked at back in sss_handle_receive() when it 
 * comes time to see whether to close the connection or not.
 */
void sss_exec_command(SSSConn* conn)
{
 d001f60:	defe8104 	addi	sp,sp,-1532
 d001f64:	dfc17e15 	stw	ra,1528(sp)
 d001f68:	df017d15 	stw	fp,1524(sp)
 d001f6c:	df017d04 	addi	fp,sp,1524
 d001f70:	e13ffe15 	stw	r4,-8(fp)
   int bytes_to_process = conn->rx_wr_pos - conn->rx_rd_pos;
 d001f74:	e0bffe17 	ldw	r2,-8(fp)
 d001f78:	10817b17 	ldw	r2,1516(r2)
 d001f7c:	1007883a 	mov	r3,r2
 d001f80:	e0bffe17 	ldw	r2,-8(fp)
 d001f84:	10817a17 	ldw	r2,1512(r2)
 d001f88:	1885c83a 	sub	r2,r3,r2
 d001f8c:	e0be8615 	stw	r2,-1512(fp)
   INT8U tx_buf[SSS_TX_BUF_SIZE];
   INT8U *tx_wr_pos = tx_buf;
 d001f90:	e0be8704 	addi	r2,fp,-1508
 d001f94:	e0be8515 	stw	r2,-1516(fp)
    * SSSSimpleSocketServerTask, since the LEDManagementTask does not 
    * have access to the stack of the SSSSimpleSocketServerTask.
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;
 d001f98:	00800c04 	movi	r2,48
 d001f9c:	d0a05915 	stw	r2,-32412(gp)

   while(bytes_to_process--)
 d001fa0:	00004506 	br	d0020b8 <sss_exec_command+0x158>
   {
      SSSCommand = toupper(*(conn->rx_rd_pos++));
 d001fa4:	e0bffe17 	ldw	r2,-8(fp)
 d001fa8:	10c17a17 	ldw	r3,1512(r2)
 d001fac:	18800003 	ldbu	r2,0(r3)
 d001fb0:	10803fcc 	andi	r2,r2,255
 d001fb4:	e0be8315 	stw	r2,-1524(fp)
 d001fb8:	18c00044 	addi	r3,r3,1
 d001fbc:	e0bffe17 	ldw	r2,-8(fp)
 d001fc0:	10c17a15 	stw	r3,1512(r2)
 d001fc4:	00834174 	movhi	r2,3333
 d001fc8:	108a2104 	addi	r2,r2,10372
 d001fcc:	10c00017 	ldw	r3,0(r2)
 d001fd0:	e0be8317 	ldw	r2,-1524(fp)
 d001fd4:	1885883a 	add	r2,r3,r2
 d001fd8:	10800003 	ldbu	r2,0(r2)
 d001fdc:	10803fcc 	andi	r2,r2,255
 d001fe0:	1080008c 	andi	r2,r2,2
 d001fe4:	1005003a 	cmpeq	r2,r2,zero
 d001fe8:	1000041e 	bne	r2,zero,d001ffc <sss_exec_command+0x9c>
 d001fec:	e0be8317 	ldw	r2,-1524(fp)
 d001ff0:	10bff804 	addi	r2,r2,-32
 d001ff4:	e0bfff15 	stw	r2,-4(fp)
 d001ff8:	00000206 	br	d002004 <sss_exec_command+0xa4>
 d001ffc:	e0be8317 	ldw	r2,-1524(fp)
 d002000:	e0bfff15 	stw	r2,-4(fp)
 d002004:	e0bfff17 	ldw	r2,-4(fp)
 d002008:	d0a05915 	stw	r2,-32412(gp)
    
      if(SSSCommand >= ' ' && SSSCommand <= '~')
 d00200c:	d0a05917 	ldw	r2,-32412(gp)
 d002010:	10800830 	cmpltui	r2,r2,32
 d002014:	1000281e 	bne	r2,zero,d0020b8 <sss_exec_command+0x158>
 d002018:	d0a05917 	ldw	r2,-32412(gp)
 d00201c:	10801fe8 	cmpgeui	r2,r2,127
 d002020:	1000251e 	bne	r2,zero,d0020b8 <sss_exec_command+0x158>
      {
         tx_wr_pos += sprintf(tx_wr_pos,
 d002024:	e13e8517 	ldw	r4,-1516(fp)
 d002028:	d0a05917 	ldw	r2,-32412(gp)
 d00202c:	11803fcc 	andi	r6,r2,255
 d002030:	3180201c 	xori	r6,r6,128
 d002034:	31bfe004 	addi	r6,r6,-128
 d002038:	01434174 	movhi	r5,3333
 d00203c:	296e0e04 	addi	r5,r5,-18376
 d002040:	d002d340 	call	d002d34 <sprintf>
 d002044:	1007883a 	mov	r3,r2
 d002048:	e0be8517 	ldw	r2,-1516(fp)
 d00204c:	10c5883a 	add	r2,r2,r3
 d002050:	e0be8515 	stw	r2,-1516(fp)
                              "--> Simple Socket Server Command %c.\n",
                              (char)SSSCommand);
         if (SSSCommand == CMD_QUIT)
 d002054:	d0a05917 	ldw	r2,-32412(gp)
 d002058:	10801458 	cmpnei	r2,r2,81
 d00205c:	10000e1e 	bne	r2,zero,d002098 <sss_exec_command+0x138>
         {
            tx_wr_pos += sprintf(tx_wr_pos,"Terminating connection.\n\n\r");
 d002060:	e0be8517 	ldw	r2,-1516(fp)
 d002064:	00c34174 	movhi	r3,3333
 d002068:	18ee1804 	addi	r3,r3,-18336
 d00206c:	1009883a 	mov	r4,r2
 d002070:	180b883a 	mov	r5,r3
 d002074:	018006c4 	movi	r6,27
 d002078:	d0027000 	call	d002700 <memcpy>
 d00207c:	e0be8517 	ldw	r2,-1516(fp)
 d002080:	10800684 	addi	r2,r2,26
 d002084:	e0be8515 	stw	r2,-1516(fp)
            conn->close = 1;
 d002088:	e0fffe17 	ldw	r3,-8(fp)
 d00208c:	00800044 	movi	r2,1
 d002090:	18800215 	stw	r2,8(r3)
 d002094:	00000806 	br	d0020b8 <sss_exec_command+0x158>
         }
         else
         {
            error_code = OSQPost(SSSLEDCommandQ, (void *)SSSCommand);    
 d002098:	d1205a17 	ldw	r4,-32408(gp)
 d00209c:	d0a05917 	ldw	r2,-32412(gp)
 d0020a0:	100b883a 	mov	r5,r2
 d0020a4:	d0126780 	call	d012678 <OSQPost>
 d0020a8:	e0be8405 	stb	r2,-1520(fp)

            alt_SSSErrorHandler(error_code, 0);
 d0020ac:	e13e8403 	ldbu	r4,-1520(fp)
 d0020b0:	000b883a 	mov	r5,zero
 d0020b4:	d000bc00 	call	d000bc0 <alt_SSSErrorHandler>
    */
   static INT32U SSSCommand;
   
   SSSCommand = CMD_LEDS_BIT_0_TOGGLE;

   while(bytes_to_process--)
 d0020b8:	e0be8617 	ldw	r2,-1512(fp)
 d0020bc:	10bfffc4 	addi	r2,r2,-1
 d0020c0:	e0be8615 	stw	r2,-1512(fp)
 d0020c4:	e0be8617 	ldw	r2,-1512(fp)
 d0020c8:	10bfffd8 	cmpnei	r2,r2,-1
 d0020cc:	103fb51e 	bne	r2,zero,d001fa4 <sss_exec_command+0x44>
            alt_SSSErrorHandler(error_code, 0);
         }
      }
   }             

  send(conn->fd, tx_buf, tx_wr_pos - tx_buf, 0);  
 d0020d0:	e0bffe17 	ldw	r2,-8(fp)
 d0020d4:	11000117 	ldw	r4,4(r2)
 d0020d8:	e17e8704 	addi	r5,fp,-1508
 d0020dc:	e0fe8517 	ldw	r3,-1516(fp)
 d0020e0:	e0be8704 	addi	r2,fp,-1508
 d0020e4:	188dc83a 	sub	r6,r3,r2
 d0020e8:	000f883a 	mov	r7,zero
 d0020ec:	d02d70c0 	call	d02d70c <t_send>
  
  return;
}
 d0020f0:	e037883a 	mov	sp,fp
 d0020f4:	dfc00117 	ldw	ra,4(sp)
 d0020f8:	df000017 	ldw	fp,0(sp)
 d0020fc:	dec00204 	addi	sp,sp,8
 d002100:	f800283a 	ret

0d002104 <sss_handle_receive>:
 * sss_exec_command() routine. Aside from these, we must move incoming
 * (un-processed) data to buffer start as appropriate and keep track of 
 * associated pointers.
 */
void sss_handle_receive(SSSConn* conn)
{
 d002104:	defff904 	addi	sp,sp,-28
 d002108:	dfc00615 	stw	ra,24(sp)
 d00210c:	df000515 	stw	fp,20(sp)
 d002110:	df000504 	addi	fp,sp,20
 d002114:	e13ffe15 	stw	r4,-8(fp)
  int data_used = 0, rx_code = 0;
 d002118:	e03ffd15 	stw	zero,-12(fp)
 d00211c:	e03ffc15 	stw	zero,-16(fp)
  INT8U *lf_addr; 
  
  conn->rx_rd_pos = conn->rx_buffer;
 d002120:	e0bffe17 	ldw	r2,-8(fp)
 d002124:	10c00304 	addi	r3,r2,12
 d002128:	e0bffe17 	ldw	r2,-8(fp)
 d00212c:	10c17a15 	stw	r3,1512(r2)
  conn->rx_wr_pos = conn->rx_buffer;
 d002130:	e0bffe17 	ldw	r2,-8(fp)
 d002134:	10c00304 	addi	r3,r2,12
 d002138:	e0bffe17 	ldw	r2,-8(fp)
 d00213c:	10c17b15 	stw	r3,1516(r2)
  
  printf("[sss_handle_receive] processing RX data\n");
 d002140:	01034174 	movhi	r4,3333
 d002144:	212e1f04 	addi	r4,r4,-18308
 d002148:	d002cc00 	call	d002cc0 <puts>
  
  while(conn->state != CLOSE)
 d00214c:	00005706 	br	d0022ac <sss_handle_receive+0x1a8>
  {
    /* Find the Carriage return which marks the end of the header */
    lf_addr = strchr(conn->rx_buffer, '\n');
 d002150:	e0bffe17 	ldw	r2,-8(fp)
 d002154:	10800304 	addi	r2,r2,12
 d002158:	1009883a 	mov	r4,r2
 d00215c:	01400284 	movi	r5,10
 d002160:	d002e080 	call	d002e08 <strchr>
 d002164:	e0bffb15 	stw	r2,-20(fp)
      
    if(lf_addr)
 d002168:	e0bffb17 	ldw	r2,-20(fp)
 d00216c:	1005003a 	cmpeq	r2,r2,zero
 d002170:	1000031e 	bne	r2,zero,d002180 <sss_handle_receive+0x7c>
    {
      /* go off and do whatever the user wanted us to do */
      sss_exec_command(conn);
 d002174:	e13ffe17 	ldw	r4,-8(fp)
 d002178:	d001f600 	call	d001f60 <sss_exec_command>
 d00217c:	00001c06 	br	d0021f0 <sss_handle_receive+0xec>
    }
    /* No newline received? Then ask the socket for data */
    else
    {
      rx_code = recv(conn->fd, conn->rx_wr_pos, 
 d002180:	e0bffe17 	ldw	r2,-8(fp)
 d002184:	11000117 	ldw	r4,4(r2)
 d002188:	e0bffe17 	ldw	r2,-8(fp)
 d00218c:	10817b17 	ldw	r2,1516(r2)
 d002190:	100b883a 	mov	r5,r2
 d002194:	e0bffe17 	ldw	r2,-8(fp)
 d002198:	10800304 	addi	r2,r2,12
 d00219c:	1007883a 	mov	r3,r2
 d0021a0:	e0bffe17 	ldw	r2,-8(fp)
 d0021a4:	10817b17 	ldw	r2,1516(r2)
 d0021a8:	1885c83a 	sub	r2,r3,r2
 d0021ac:	118176c4 	addi	r6,r2,1499
 d0021b0:	000f883a 	mov	r7,zero
 d0021b4:	d02d2a00 	call	d02d2a0 <t_recv>
 d0021b8:	e0bffc15 	stw	r2,-16(fp)
        SSS_RX_BUF_SIZE - (conn->rx_wr_pos - conn->rx_buffer) -1, 0);
          
     if(rx_code > 0)
 d0021bc:	e0bffc17 	ldw	r2,-16(fp)
 d0021c0:	10800050 	cmplti	r2,r2,1
 d0021c4:	10000a1e 	bne	r2,zero,d0021f0 <sss_handle_receive+0xec>
      {
        conn->rx_wr_pos += rx_code;
 d0021c8:	e0bffe17 	ldw	r2,-8(fp)
 d0021cc:	10c17b17 	ldw	r3,1516(r2)
 d0021d0:	e0bffc17 	ldw	r2,-16(fp)
 d0021d4:	1887883a 	add	r3,r3,r2
 d0021d8:	e0bffe17 	ldw	r2,-8(fp)
 d0021dc:	10c17b15 	stw	r3,1516(r2)
        
        /* Zero terminate so we can use string functions */
        *(conn->rx_wr_pos+1) = 0;
 d0021e0:	e0bffe17 	ldw	r2,-8(fp)
 d0021e4:	10817b17 	ldw	r2,1516(r2)
 d0021e8:	10800044 	addi	r2,r2,1
 d0021ec:	10000005 	stb	zero,0(r2)

    /* 
     * When the quit command is received, update our connection state so that
     * we can exit the while() loop and close the connection
     */
    conn->state = conn->close ? CLOSE : READY;
 d0021f0:	e0bffe17 	ldw	r2,-8(fp)
 d0021f4:	10800217 	ldw	r2,8(r2)
 d0021f8:	1005003a 	cmpeq	r2,r2,zero
 d0021fc:	1000031e 	bne	r2,zero,d00220c <sss_handle_receive+0x108>
 d002200:	00800084 	movi	r2,2
 d002204:	e0bfff15 	stw	r2,-4(fp)
 d002208:	00000106 	br	d002210 <sss_handle_receive+0x10c>
 d00220c:	e03fff15 	stw	zero,-4(fp)
 d002210:	e0bffe17 	ldw	r2,-8(fp)
 d002214:	e0ffff17 	ldw	r3,-4(fp)
 d002218:	10c00015 	stw	r3,0(r2)

    /* Manage buffer */
    data_used = conn->rx_rd_pos - conn->rx_buffer;
 d00221c:	e0bffe17 	ldw	r2,-8(fp)
 d002220:	10817a17 	ldw	r2,1512(r2)
 d002224:	1007883a 	mov	r3,r2
 d002228:	e0bffe17 	ldw	r2,-8(fp)
 d00222c:	10800304 	addi	r2,r2,12
 d002230:	1885c83a 	sub	r2,r3,r2
 d002234:	e0bffd15 	stw	r2,-12(fp)
    memmove(conn->rx_buffer, conn->rx_rd_pos, 
 d002238:	e0bffe17 	ldw	r2,-8(fp)
 d00223c:	11000304 	addi	r4,r2,12
 d002240:	e0bffe17 	ldw	r2,-8(fp)
 d002244:	11417a17 	ldw	r5,1512(r2)
 d002248:	e0bffe17 	ldw	r2,-8(fp)
 d00224c:	10817b17 	ldw	r2,1516(r2)
 d002250:	1007883a 	mov	r3,r2
 d002254:	e0bffe17 	ldw	r2,-8(fp)
 d002258:	10817a17 	ldw	r2,1512(r2)
 d00225c:	1885c83a 	sub	r2,r3,r2
 d002260:	100d883a 	mov	r6,r2
 d002264:	d0027a00 	call	d0027a0 <memmove>
       conn->rx_wr_pos - conn->rx_rd_pos);
    conn->rx_rd_pos = conn->rx_buffer;
 d002268:	e0bffe17 	ldw	r2,-8(fp)
 d00226c:	10c00304 	addi	r3,r2,12
 d002270:	e0bffe17 	ldw	r2,-8(fp)
 d002274:	10c17a15 	stw	r3,1512(r2)
    conn->rx_wr_pos -= data_used;
 d002278:	e0bffe17 	ldw	r2,-8(fp)
 d00227c:	10c17b17 	ldw	r3,1516(r2)
 d002280:	e0bffd17 	ldw	r2,-12(fp)
 d002284:	1887c83a 	sub	r3,r3,r2
 d002288:	e0bffe17 	ldw	r2,-8(fp)
 d00228c:	10c17b15 	stw	r3,1516(r2)
    memset(conn->rx_wr_pos, 0, data_used);
 d002290:	e0bffe17 	ldw	r2,-8(fp)
 d002294:	10817b17 	ldw	r2,1516(r2)
 d002298:	e0fffd17 	ldw	r3,-12(fp)
 d00229c:	1009883a 	mov	r4,r2
 d0022a0:	180d883a 	mov	r6,r3
 d0022a4:	000b883a 	mov	r5,zero
 d0022a8:	d0028800 	call	d002880 <memset>
  conn->rx_rd_pos = conn->rx_buffer;
  conn->rx_wr_pos = conn->rx_buffer;
  
  printf("[sss_handle_receive] processing RX data\n");
  
  while(conn->state != CLOSE)
 d0022ac:	e0bffe17 	ldw	r2,-8(fp)
 d0022b0:	10800017 	ldw	r2,0(r2)
 d0022b4:	10800098 	cmpnei	r2,r2,2
 d0022b8:	103fa51e 	bne	r2,zero,d002150 <sss_handle_receive+0x4c>
    conn->rx_rd_pos = conn->rx_buffer;
    conn->rx_wr_pos -= data_used;
    memset(conn->rx_wr_pos, 0, data_used);
  }

  printf("[sss_handle_receive] closing connection\n");
 d0022bc:	01034174 	movhi	r4,3333
 d0022c0:	212e2904 	addi	r4,r4,-18268
 d0022c4:	d002cc00 	call	d002cc0 <puts>
  close(conn->fd);
 d0022c8:	e0bffe17 	ldw	r2,-8(fp)
 d0022cc:	11000117 	ldw	r4,4(r2)
 d0022d0:	d02101c0 	call	d02101c <close>
  sss_reset_connection(conn);
 d0022d4:	e13ffe17 	ldw	r4,-8(fp)
 d0022d8:	d001ca00 	call	d001ca0 <sss_reset_connection>
  
  return;
}
 d0022dc:	e037883a 	mov	sp,fp
 d0022e0:	dfc00117 	ldw	ra,4(sp)
 d0022e4:	df000017 	ldw	fp,0(sp)
 d0022e8:	dec00204 	addi	sp,sp,8
 d0022ec:	f800283a 	ret

0d0022f0 <SSSSimpleSocketServerTask>:
 * (if a connection is active), the sss data socket. When data arrives, 
 * the approrpriate routine is called to either accept/reject a connection 
 * request, or process incoming data.
 */
void SSSSimpleSocketServerTask()
{
 d0022f0:	deffb604 	addi	sp,sp,-296
 d0022f4:	dfc04915 	stw	ra,292(sp)
 d0022f8:	df004815 	stw	fp,288(sp)
 d0022fc:	df004804 	addi	fp,sp,288
   * protocol and address families respectively. However, there is usually only
   * 1 address per protocol family. Thus PF_INET and AF_INET can be interchanged.
   * In the case of NicheStack, only the use of AF_INET is supported.
   * PF_INET is not supported in NicheStack.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 d002300:	01000084 	movi	r4,2
 d002304:	01400044 	movi	r5,1
 d002308:	000d883a 	mov	r6,zero
 d00230c:	d02c46c0 	call	d02c46c <t_socket>
 d002310:	e0bfba15 	stw	r2,-280(fp)
 d002314:	e0bfba17 	ldw	r2,-280(fp)
 d002318:	1004403a 	cmpge	r2,r2,zero
 d00231c:	1000041e 	bne	r2,zero,d002330 <SSSSimpleSocketServerTask+0x40>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Socket creation failed");
 d002320:	01003fc4 	movi	r4,255
 d002324:	01434174 	movhi	r5,3333
 d002328:	296e3304 	addi	r5,r5,-18228
 d00232c:	d0009280 	call	d000928 <alt_NetworkErrorHandler>
   * port and incoming address. In this case we're binding to SSS_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  addr.sin_family = AF_INET;
 d002330:	00800084 	movi	r2,2
 d002334:	e0bfbb0d 	sth	r2,-276(fp)
  addr.sin_port = htons(SSS_PORT);
 d002338:	00878004 	movi	r2,7680
 d00233c:	e0bfbb8d 	sth	r2,-274(fp)
  addr.sin_addr.s_addr = INADDR_ANY;
 d002340:	e03fbc15 	stw	zero,-272(fp)
  
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 d002344:	e17fbb04 	addi	r5,fp,-276
 d002348:	e13fba17 	ldw	r4,-280(fp)
 d00234c:	01800404 	movi	r6,16
 d002350:	d02c4fc0 	call	d02c4fc <t_bind>
 d002354:	1004403a 	cmpge	r2,r2,zero
 d002358:	1000041e 	bne	r2,zero,d00236c <SSSSimpleSocketServerTask+0x7c>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Bind failed");
 d00235c:	01003fc4 	movi	r4,255
 d002360:	01434174 	movhi	r5,3333
 d002364:	296e3c04 	addi	r5,r5,-18192
 d002368:	d0009280 	call	d000928 <alt_NetworkErrorHandler>
   * Sockets primer, continued...
   * The listen socket is a socket which is waiting for incoming connections.
   * This call to listen will block (i.e. not return) until someone tries to 
   * connect to this port.
   */ 
  if ((listen(fd_listen,1)) < 0)
 d00236c:	e13fba17 	ldw	r4,-280(fp)
 d002370:	01400044 	movi	r5,1
 d002374:	d02c6780 	call	d02c678 <t_listen>
 d002378:	1004403a 	cmpge	r2,r2,zero
 d00237c:	1000041e 	bne	r2,zero,d002390 <SSSSimpleSocketServerTask+0xa0>
  {
    alt_NetworkErrorHandler(EXPANDED_DIAGNOSIS_CODE,"[sss_task] Listen failed");
 d002380:	01003fc4 	movi	r4,255
 d002384:	01434174 	movhi	r5,3333
 d002388:	296e4204 	addi	r5,r5,-18168
 d00238c:	d0009280 	call	d000928 <alt_NetworkErrorHandler>
  }

  /* At this point we have successfully created a socket which is listening
   * on SSS_PORT for connection requests from any remote address.
   */
  sss_reset_connection(&conn);
 d002390:	01034174 	movhi	r4,3333
 d002394:	210afe04 	addi	r4,r4,11256
 d002398:	d001ca00 	call	d001ca0 <sss_reset_connection>
  printf("[sss_task] Simple Socket Server listening on port %d\n", SSS_PORT);
 d00239c:	01034174 	movhi	r4,3333
 d0023a0:	212e4904 	addi	r4,r4,-18140
 d0023a4:	01400784 	movi	r5,30
 d0023a8:	d0029980 	call	d002998 <printf>
 d0023ac:	00000006 	br	d0023b0 <SSSSimpleSocketServerTask+0xc0>
     * 
     *   FD_ZERO  - Zero's out the sockets we're interested in
     *   FD_SET   - Adds a socket to those we're interested in
     *   FD_ISSET - Tests whether the chosen socket is set 
     */
    FD_ZERO(&readfds);
 d0023b0:	e03fbf15 	stw	zero,-260(fp)
    FD_SET(fd_listen, &readfds);
 d0023b4:	e17fbf04 	addi	r5,fp,-260
 d0023b8:	e13fba17 	ldw	r4,-280(fp)
 d0023bc:	d031a580 	call	d031a58 <ifd_set>
    max_socket = fd_listen+1;
 d0023c0:	e0bfba17 	ldw	r2,-280(fp)
 d0023c4:	10800044 	addi	r2,r2,1
 d0023c8:	e0bfb915 	stw	r2,-284(fp)

    if (conn.fd != -1)
 d0023cc:	00834174 	movhi	r2,3333
 d0023d0:	108afe04 	addi	r2,r2,11256
 d0023d4:	10800117 	ldw	r2,4(r2)
 d0023d8:	10bfffe0 	cmpeqi	r2,r2,-1
 d0023dc:	10000f1e 	bne	r2,zero,d00241c <SSSSimpleSocketServerTask+0x12c>
    {
      FD_SET(conn.fd, &readfds);
 d0023e0:	00834174 	movhi	r2,3333
 d0023e4:	108afe04 	addi	r2,r2,11256
 d0023e8:	11000117 	ldw	r4,4(r2)
 d0023ec:	e17fbf04 	addi	r5,fp,-260
 d0023f0:	d031a580 	call	d031a58 <ifd_set>
      if (max_socket <= conn.fd)
 d0023f4:	00834174 	movhi	r2,3333
 d0023f8:	108afe04 	addi	r2,r2,11256
 d0023fc:	10c00117 	ldw	r3,4(r2)
 d002400:	e0bfb917 	ldw	r2,-284(fp)
 d002404:	18800516 	blt	r3,r2,d00241c <SSSSimpleSocketServerTask+0x12c>
      {
        max_socket = conn.fd+1;
 d002408:	00834174 	movhi	r2,3333
 d00240c:	108afe04 	addi	r2,r2,11256
 d002410:	10800117 	ldw	r2,4(r2)
 d002414:	10800044 	addi	r2,r2,1
 d002418:	e0bfb915 	stw	r2,-284(fp)
      }
    }

    select(max_socket, &readfds, NULL, NULL, NULL);
 d00241c:	e17fbf04 	addi	r5,fp,-260
 d002420:	d8000015 	stw	zero,0(sp)
 d002424:	e13fb917 	ldw	r4,-284(fp)
 d002428:	000d883a 	mov	r6,zero
 d00242c:	000f883a 	mov	r7,zero
 d002430:	d023f400 	call	d023f40 <bsd_select>
     * is "set" in readfs, then we have an incoming connection request. We'll
     * call a routine to explicitly accept or deny the incoming connection 
     * request (in this example, we accept a single connection and reject any
     * others that come in while the connection is open).
     */
    if (FD_ISSET(fd_listen, &readfds))
 d002434:	e17fbf04 	addi	r5,fp,-260
 d002438:	e13fba17 	ldw	r4,-280(fp)
 d00243c:	d031acc0 	call	d031acc <ifd_isset>
 d002440:	1005003a 	cmpeq	r2,r2,zero
 d002444:	1000051e 	bne	r2,zero,d00245c <SSSSimpleSocketServerTask+0x16c>
    {
      sss_handle_accept(fd_listen, &conn);
 d002448:	e13fba17 	ldw	r4,-280(fp)
 d00244c:	01434174 	movhi	r5,3333
 d002450:	294afe04 	addi	r5,r5,11256
 d002454:	d001ea00 	call	d001ea0 <sss_handle_accept>
 d002458:	003fd506 	br	d0023b0 <SSSSimpleSocketServerTask+0xc0>
     * incoming data for our sss server, and we call our receiver routine
     * to process it.
     */
    else
    {
      if ((conn.fd != -1) && FD_ISSET(conn.fd, &readfds))
 d00245c:	00834174 	movhi	r2,3333
 d002460:	108afe04 	addi	r2,r2,11256
 d002464:	10800117 	ldw	r2,4(r2)
 d002468:	10bfffe0 	cmpeqi	r2,r2,-1
 d00246c:	103fd01e 	bne	r2,zero,d0023b0 <SSSSimpleSocketServerTask+0xc0>
 d002470:	00834174 	movhi	r2,3333
 d002474:	108afe04 	addi	r2,r2,11256
 d002478:	11000117 	ldw	r4,4(r2)
 d00247c:	e17fbf04 	addi	r5,fp,-260
 d002480:	d031acc0 	call	d031acc <ifd_isset>
 d002484:	1005003a 	cmpeq	r2,r2,zero
 d002488:	103fc91e 	bne	r2,zero,d0023b0 <SSSSimpleSocketServerTask+0xc0>
      {
        sss_handle_receive(&conn);
 d00248c:	01034174 	movhi	r4,3333
 d002490:	210afe04 	addi	r4,r4,11256
 d002494:	d0021040 	call	d002104 <sss_handle_receive>
      }
    }
  } /* while(1) */
 d002498:	003fc506 	br	d0023b0 <SSSSimpleSocketServerTask+0xc0>

0d00249c <fprintf>:
 d00249c:	defffc04 	addi	sp,sp,-16
 d0024a0:	dfc00115 	stw	ra,4(sp)
 d0024a4:	d9800215 	stw	r6,8(sp)
 d0024a8:	d9c00315 	stw	r7,12(sp)
 d0024ac:	d8800204 	addi	r2,sp,8
 d0024b0:	100d883a 	mov	r6,r2
 d0024b4:	d8800015 	stw	r2,0(sp)
 d0024b8:	d0054dc0 	call	d0054dc <__vfprintf_internal>
 d0024bc:	dfc00117 	ldw	ra,4(sp)
 d0024c0:	dec00404 	addi	sp,sp,16
 d0024c4:	f800283a 	ret

0d0024c8 <_fprintf_r>:
 d0024c8:	defffd04 	addi	sp,sp,-12
 d0024cc:	2807883a 	mov	r3,r5
 d0024d0:	dfc00115 	stw	ra,4(sp)
 d0024d4:	d9c00215 	stw	r7,8(sp)
 d0024d8:	d8800204 	addi	r2,sp,8
 d0024dc:	300b883a 	mov	r5,r6
 d0024e0:	1809883a 	mov	r4,r3
 d0024e4:	100d883a 	mov	r6,r2
 d0024e8:	d8800015 	stw	r2,0(sp)
 d0024ec:	d0054dc0 	call	d0054dc <__vfprintf_internal>
 d0024f0:	dfc00117 	ldw	ra,4(sp)
 d0024f4:	dec00304 	addi	sp,sp,12
 d0024f8:	f800283a 	ret

0d0024fc <_fwrite_r>:
 d0024fc:	defff604 	addi	sp,sp,-40
 d002500:	dc400615 	stw	r17,24(sp)
 d002504:	39a3383a 	mul	r17,r7,r6
 d002508:	00800044 	movi	r2,1
 d00250c:	dcc00815 	stw	r19,32(sp)
 d002510:	dc800715 	stw	r18,28(sp)
 d002514:	dc000515 	stw	r16,20(sp)
 d002518:	dfc00915 	stw	ra,36(sp)
 d00251c:	3825883a 	mov	r18,r7
 d002520:	3027883a 	mov	r19,r6
 d002524:	2021883a 	mov	r16,r4
 d002528:	d9400015 	stw	r5,0(sp)
 d00252c:	d8800315 	stw	r2,12(sp)
 d002530:	dc400115 	stw	r17,4(sp)
 d002534:	dc400415 	stw	r17,16(sp)
 d002538:	dec00215 	stw	sp,8(sp)
 d00253c:	20000226 	beq	r4,zero,d002548 <_fwrite_r+0x4c>
 d002540:	20800e17 	ldw	r2,56(r4)
 d002544:	10001226 	beq	r2,zero,d002590 <_fwrite_r+0x94>
 d002548:	d9400a17 	ldw	r5,40(sp)
 d00254c:	8009883a 	mov	r4,r16
 d002550:	d9800204 	addi	r6,sp,8
 d002554:	d0079d00 	call	d0079d0 <__sfvwrite_r>
 d002558:	980b883a 	mov	r5,r19
 d00255c:	10000426 	beq	r2,zero,d002570 <_fwrite_r+0x74>
 d002560:	d9000417 	ldw	r4,16(sp)
 d002564:	8909c83a 	sub	r4,r17,r4
 d002568:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00256c:	1025883a 	mov	r18,r2
 d002570:	9005883a 	mov	r2,r18
 d002574:	dfc00917 	ldw	ra,36(sp)
 d002578:	dcc00817 	ldw	r19,32(sp)
 d00257c:	dc800717 	ldw	r18,28(sp)
 d002580:	dc400617 	ldw	r17,24(sp)
 d002584:	dc000517 	ldw	r16,20(sp)
 d002588:	dec00a04 	addi	sp,sp,40
 d00258c:	f800283a 	ret
 d002590:	d0071ec0 	call	d0071ec <__sinit>
 d002594:	003fec06 	br	d002548 <_fwrite_r+0x4c>

0d002598 <fwrite>:
 d002598:	00834174 	movhi	r2,3333
 d00259c:	108a2204 	addi	r2,r2,10376
 d0025a0:	2017883a 	mov	r11,r4
 d0025a4:	11000017 	ldw	r4,0(r2)
 d0025a8:	defffe04 	addi	sp,sp,-8
 d0025ac:	3013883a 	mov	r9,r6
 d0025b0:	2805883a 	mov	r2,r5
 d0025b4:	d9c00015 	stw	r7,0(sp)
 d0025b8:	580b883a 	mov	r5,r11
 d0025bc:	100d883a 	mov	r6,r2
 d0025c0:	480f883a 	mov	r7,r9
 d0025c4:	dfc00115 	stw	ra,4(sp)
 d0025c8:	d0024fc0 	call	d0024fc <_fwrite_r>
 d0025cc:	dfc00117 	ldw	ra,4(sp)
 d0025d0:	dec00204 	addi	sp,sp,8
 d0025d4:	f800283a 	ret

0d0025d8 <getc>:
 d0025d8:	defffd04 	addi	sp,sp,-12
 d0025dc:	dc400115 	stw	r17,4(sp)
 d0025e0:	04434174 	movhi	r17,3333
 d0025e4:	8c4a2204 	addi	r17,r17,10376
 d0025e8:	88c00017 	ldw	r3,0(r17)
 d0025ec:	dc000015 	stw	r16,0(sp)
 d0025f0:	dfc00215 	stw	ra,8(sp)
 d0025f4:	2021883a 	mov	r16,r4
 d0025f8:	18000326 	beq	r3,zero,d002608 <getc+0x30>
 d0025fc:	18800e17 	ldw	r2,56(r3)
 d002600:	1809883a 	mov	r4,r3
 d002604:	10000e26 	beq	r2,zero,d002640 <getc+0x68>
 d002608:	80800117 	ldw	r2,4(r16)
 d00260c:	800b883a 	mov	r5,r16
 d002610:	10bfffc4 	addi	r2,r2,-1
 d002614:	80800115 	stw	r2,4(r16)
 d002618:	10000f16 	blt	r2,zero,d002658 <getc+0x80>
 d00261c:	80c00017 	ldw	r3,0(r16)
 d002620:	18800003 	ldbu	r2,0(r3)
 d002624:	18c00044 	addi	r3,r3,1
 d002628:	80c00015 	stw	r3,0(r16)
 d00262c:	dfc00217 	ldw	ra,8(sp)
 d002630:	dc400117 	ldw	r17,4(sp)
 d002634:	dc000017 	ldw	r16,0(sp)
 d002638:	dec00304 	addi	sp,sp,12
 d00263c:	f800283a 	ret
 d002640:	d0071ec0 	call	d0071ec <__sinit>
 d002644:	80800117 	ldw	r2,4(r16)
 d002648:	800b883a 	mov	r5,r16
 d00264c:	10bfffc4 	addi	r2,r2,-1
 d002650:	80800115 	stw	r2,4(r16)
 d002654:	103ff10e 	bge	r2,zero,d00261c <getc+0x44>
 d002658:	89000017 	ldw	r4,0(r17)
 d00265c:	dfc00217 	ldw	ra,8(sp)
 d002660:	dc400117 	ldw	r17,4(sp)
 d002664:	dc000017 	ldw	r16,0(sp)
 d002668:	dec00304 	addi	sp,sp,12
 d00266c:	d002cd41 	jmpi	d002cd4 <__srget_r>

0d002670 <_getc_r>:
 d002670:	defffd04 	addi	sp,sp,-12
 d002674:	dc400115 	stw	r17,4(sp)
 d002678:	dc000015 	stw	r16,0(sp)
 d00267c:	dfc00215 	stw	ra,8(sp)
 d002680:	2021883a 	mov	r16,r4
 d002684:	2823883a 	mov	r17,r5
 d002688:	20000226 	beq	r4,zero,d002694 <_getc_r+0x24>
 d00268c:	20800e17 	ldw	r2,56(r4)
 d002690:	10000f26 	beq	r2,zero,d0026d0 <_getc_r+0x60>
 d002694:	88800117 	ldw	r2,4(r17)
 d002698:	8009883a 	mov	r4,r16
 d00269c:	880b883a 	mov	r5,r17
 d0026a0:	10bfffc4 	addi	r2,r2,-1
 d0026a4:	88800115 	stw	r2,4(r17)
 d0026a8:	10001016 	blt	r2,zero,d0026ec <_getc_r+0x7c>
 d0026ac:	88c00017 	ldw	r3,0(r17)
 d0026b0:	18800003 	ldbu	r2,0(r3)
 d0026b4:	18c00044 	addi	r3,r3,1
 d0026b8:	88c00015 	stw	r3,0(r17)
 d0026bc:	dfc00217 	ldw	ra,8(sp)
 d0026c0:	dc400117 	ldw	r17,4(sp)
 d0026c4:	dc000017 	ldw	r16,0(sp)
 d0026c8:	dec00304 	addi	sp,sp,12
 d0026cc:	f800283a 	ret
 d0026d0:	d0071ec0 	call	d0071ec <__sinit>
 d0026d4:	88800117 	ldw	r2,4(r17)
 d0026d8:	8009883a 	mov	r4,r16
 d0026dc:	880b883a 	mov	r5,r17
 d0026e0:	10bfffc4 	addi	r2,r2,-1
 d0026e4:	88800115 	stw	r2,4(r17)
 d0026e8:	103ff00e 	bge	r2,zero,d0026ac <_getc_r+0x3c>
 d0026ec:	dfc00217 	ldw	ra,8(sp)
 d0026f0:	dc400117 	ldw	r17,4(sp)
 d0026f4:	dc000017 	ldw	r16,0(sp)
 d0026f8:	dec00304 	addi	sp,sp,12
 d0026fc:	d002cd41 	jmpi	d002cd4 <__srget_r>

0d002700 <memcpy>:
 d002700:	01c003c4 	movi	r7,15
 d002704:	2007883a 	mov	r3,r4
 d002708:	3980032e 	bgeu	r7,r6,d002718 <memcpy+0x18>
 d00270c:	2904b03a 	or	r2,r5,r4
 d002710:	108000cc 	andi	r2,r2,3
 d002714:	10000926 	beq	r2,zero,d00273c <memcpy+0x3c>
 d002718:	30000626 	beq	r6,zero,d002734 <memcpy+0x34>
 d00271c:	30cd883a 	add	r6,r6,r3
 d002720:	28800003 	ldbu	r2,0(r5)
 d002724:	29400044 	addi	r5,r5,1
 d002728:	18800005 	stb	r2,0(r3)
 d00272c:	18c00044 	addi	r3,r3,1
 d002730:	30fffb1e 	bne	r6,r3,d002720 <memcpy+0x20>
 d002734:	2005883a 	mov	r2,r4
 d002738:	f800283a 	ret
 d00273c:	3811883a 	mov	r8,r7
 d002740:	200f883a 	mov	r7,r4
 d002744:	28c00017 	ldw	r3,0(r5)
 d002748:	31bffc04 	addi	r6,r6,-16
 d00274c:	38c00015 	stw	r3,0(r7)
 d002750:	28800117 	ldw	r2,4(r5)
 d002754:	38800115 	stw	r2,4(r7)
 d002758:	28c00217 	ldw	r3,8(r5)
 d00275c:	38c00215 	stw	r3,8(r7)
 d002760:	28800317 	ldw	r2,12(r5)
 d002764:	29400404 	addi	r5,r5,16
 d002768:	38800315 	stw	r2,12(r7)
 d00276c:	39c00404 	addi	r7,r7,16
 d002770:	41bff436 	bltu	r8,r6,d002744 <memcpy+0x44>
 d002774:	008000c4 	movi	r2,3
 d002778:	1180072e 	bgeu	r2,r6,d002798 <memcpy+0x98>
 d00277c:	1007883a 	mov	r3,r2
 d002780:	28800017 	ldw	r2,0(r5)
 d002784:	31bfff04 	addi	r6,r6,-4
 d002788:	29400104 	addi	r5,r5,4
 d00278c:	38800015 	stw	r2,0(r7)
 d002790:	39c00104 	addi	r7,r7,4
 d002794:	19bffa36 	bltu	r3,r6,d002780 <memcpy+0x80>
 d002798:	3807883a 	mov	r3,r7
 d00279c:	003fde06 	br	d002718 <memcpy+0x18>

0d0027a0 <memmove>:
 d0027a0:	2807883a 	mov	r3,r5
 d0027a4:	2011883a 	mov	r8,r4
 d0027a8:	29000c2e 	bgeu	r5,r4,d0027dc <memmove+0x3c>
 d0027ac:	298f883a 	add	r7,r5,r6
 d0027b0:	21c00a2e 	bgeu	r4,r7,d0027dc <memmove+0x3c>
 d0027b4:	30000726 	beq	r6,zero,d0027d4 <memmove+0x34>
 d0027b8:	2187883a 	add	r3,r4,r6
 d0027bc:	198dc83a 	sub	r6,r3,r6
 d0027c0:	39ffffc4 	addi	r7,r7,-1
 d0027c4:	38800003 	ldbu	r2,0(r7)
 d0027c8:	18ffffc4 	addi	r3,r3,-1
 d0027cc:	18800005 	stb	r2,0(r3)
 d0027d0:	19bffb1e 	bne	r3,r6,d0027c0 <memmove+0x20>
 d0027d4:	2005883a 	mov	r2,r4
 d0027d8:	f800283a 	ret
 d0027dc:	01c003c4 	movi	r7,15
 d0027e0:	39800a36 	bltu	r7,r6,d00280c <memmove+0x6c>
 d0027e4:	303ffb26 	beq	r6,zero,d0027d4 <memmove+0x34>
 d0027e8:	400f883a 	mov	r7,r8
 d0027ec:	320d883a 	add	r6,r6,r8
 d0027f0:	28800003 	ldbu	r2,0(r5)
 d0027f4:	29400044 	addi	r5,r5,1
 d0027f8:	38800005 	stb	r2,0(r7)
 d0027fc:	39c00044 	addi	r7,r7,1
 d002800:	39bffb1e 	bne	r7,r6,d0027f0 <memmove+0x50>
 d002804:	2005883a 	mov	r2,r4
 d002808:	f800283a 	ret
 d00280c:	1904b03a 	or	r2,r3,r4
 d002810:	108000cc 	andi	r2,r2,3
 d002814:	103ff31e 	bne	r2,zero,d0027e4 <memmove+0x44>
 d002818:	3811883a 	mov	r8,r7
 d00281c:	180b883a 	mov	r5,r3
 d002820:	200f883a 	mov	r7,r4
 d002824:	28c00017 	ldw	r3,0(r5)
 d002828:	31bffc04 	addi	r6,r6,-16
 d00282c:	38c00015 	stw	r3,0(r7)
 d002830:	28800117 	ldw	r2,4(r5)
 d002834:	38800115 	stw	r2,4(r7)
 d002838:	28c00217 	ldw	r3,8(r5)
 d00283c:	38c00215 	stw	r3,8(r7)
 d002840:	28800317 	ldw	r2,12(r5)
 d002844:	29400404 	addi	r5,r5,16
 d002848:	38800315 	stw	r2,12(r7)
 d00284c:	39c00404 	addi	r7,r7,16
 d002850:	41bff436 	bltu	r8,r6,d002824 <memmove+0x84>
 d002854:	008000c4 	movi	r2,3
 d002858:	1180072e 	bgeu	r2,r6,d002878 <memmove+0xd8>
 d00285c:	1007883a 	mov	r3,r2
 d002860:	28800017 	ldw	r2,0(r5)
 d002864:	31bfff04 	addi	r6,r6,-4
 d002868:	29400104 	addi	r5,r5,4
 d00286c:	38800015 	stw	r2,0(r7)
 d002870:	39c00104 	addi	r7,r7,4
 d002874:	19bffa36 	bltu	r3,r6,d002860 <memmove+0xc0>
 d002878:	3811883a 	mov	r8,r7
 d00287c:	003fd906 	br	d0027e4 <memmove+0x44>

0d002880 <memset>:
 d002880:	008000c4 	movi	r2,3
 d002884:	29403fcc 	andi	r5,r5,255
 d002888:	2007883a 	mov	r3,r4
 d00288c:	1180022e 	bgeu	r2,r6,d002898 <memset+0x18>
 d002890:	2084703a 	and	r2,r4,r2
 d002894:	10000826 	beq	r2,zero,d0028b8 <memset+0x38>
 d002898:	30000526 	beq	r6,zero,d0028b0 <memset+0x30>
 d00289c:	2805883a 	mov	r2,r5
 d0028a0:	30cd883a 	add	r6,r6,r3
 d0028a4:	18800005 	stb	r2,0(r3)
 d0028a8:	18c00044 	addi	r3,r3,1
 d0028ac:	19bffd1e 	bne	r3,r6,d0028a4 <memset+0x24>
 d0028b0:	2005883a 	mov	r2,r4
 d0028b4:	f800283a 	ret
 d0028b8:	2804923a 	slli	r2,r5,8
 d0028bc:	020003c4 	movi	r8,15
 d0028c0:	200f883a 	mov	r7,r4
 d0028c4:	2884b03a 	or	r2,r5,r2
 d0028c8:	1006943a 	slli	r3,r2,16
 d0028cc:	10c6b03a 	or	r3,r2,r3
 d0028d0:	41800a2e 	bgeu	r8,r6,d0028fc <memset+0x7c>
 d0028d4:	4005883a 	mov	r2,r8
 d0028d8:	31bffc04 	addi	r6,r6,-16
 d0028dc:	38c00015 	stw	r3,0(r7)
 d0028e0:	38c00115 	stw	r3,4(r7)
 d0028e4:	38c00215 	stw	r3,8(r7)
 d0028e8:	38c00315 	stw	r3,12(r7)
 d0028ec:	39c00404 	addi	r7,r7,16
 d0028f0:	11bff936 	bltu	r2,r6,d0028d8 <memset+0x58>
 d0028f4:	008000c4 	movi	r2,3
 d0028f8:	1180052e 	bgeu	r2,r6,d002910 <memset+0x90>
 d0028fc:	31bfff04 	addi	r6,r6,-4
 d002900:	008000c4 	movi	r2,3
 d002904:	38c00015 	stw	r3,0(r7)
 d002908:	39c00104 	addi	r7,r7,4
 d00290c:	11bffb36 	bltu	r2,r6,d0028fc <memset+0x7c>
 d002910:	3807883a 	mov	r3,r7
 d002914:	003fe006 	br	d002898 <memset+0x18>

0d002918 <_perror_r>:
 d002918:	defffe04 	addi	sp,sp,-8
 d00291c:	dc000015 	stw	r16,0(sp)
 d002920:	dfc00115 	stw	ra,4(sp)
 d002924:	2021883a 	mov	r16,r4
 d002928:	28000326 	beq	r5,zero,d002938 <_perror_r+0x20>
 d00292c:	28800007 	ldb	r2,0(r5)
 d002930:	2809883a 	mov	r4,r5
 d002934:	10000c1e 	bne	r2,zero,d002968 <_perror_r+0x50>
 d002938:	81000017 	ldw	r4,0(r16)
 d00293c:	d002ee80 	call	d002ee8 <strerror>
 d002940:	1009883a 	mov	r4,r2
 d002944:	10000226 	beq	r2,zero,d002950 <_perror_r+0x38>
 d002948:	81400317 	ldw	r5,12(r16)
 d00294c:	d0075740 	call	d007574 <fputs>
 d002950:	81400317 	ldw	r5,12(r16)
 d002954:	01000284 	movi	r4,10
 d002958:	dfc00117 	ldw	ra,4(sp)
 d00295c:	dc000017 	ldw	r16,0(sp)
 d002960:	dec00204 	addi	sp,sp,8
 d002964:	d0074441 	jmpi	d007444 <fputc>
 d002968:	81400317 	ldw	r5,12(r16)
 d00296c:	d0075740 	call	d007574 <fputs>
 d002970:	81400317 	ldw	r5,12(r16)
 d002974:	01034174 	movhi	r4,3333
 d002978:	212f0104 	addi	r4,r4,-17404
 d00297c:	d0075740 	call	d007574 <fputs>
 d002980:	003fed06 	br	d002938 <_perror_r+0x20>

0d002984 <perror>:
 d002984:	00834174 	movhi	r2,3333
 d002988:	108a2204 	addi	r2,r2,10376
 d00298c:	200b883a 	mov	r5,r4
 d002990:	11000017 	ldw	r4,0(r2)
 d002994:	d0029181 	jmpi	d002918 <_perror_r>

0d002998 <printf>:
 d002998:	defffb04 	addi	sp,sp,-20
 d00299c:	dfc00115 	stw	ra,4(sp)
 d0029a0:	d9400215 	stw	r5,8(sp)
 d0029a4:	d9800315 	stw	r6,12(sp)
 d0029a8:	d9c00415 	stw	r7,16(sp)
 d0029ac:	00834174 	movhi	r2,3333
 d0029b0:	108a2204 	addi	r2,r2,10376
 d0029b4:	10c00017 	ldw	r3,0(r2)
 d0029b8:	200b883a 	mov	r5,r4
 d0029bc:	d8800204 	addi	r2,sp,8
 d0029c0:	19000217 	ldw	r4,8(r3)
 d0029c4:	100d883a 	mov	r6,r2
 d0029c8:	d8800015 	stw	r2,0(sp)
 d0029cc:	d0054dc0 	call	d0054dc <__vfprintf_internal>
 d0029d0:	dfc00117 	ldw	ra,4(sp)
 d0029d4:	dec00504 	addi	sp,sp,20
 d0029d8:	f800283a 	ret

0d0029dc <_printf_r>:
 d0029dc:	defffc04 	addi	sp,sp,-16
 d0029e0:	dfc00115 	stw	ra,4(sp)
 d0029e4:	d9800215 	stw	r6,8(sp)
 d0029e8:	d9c00315 	stw	r7,12(sp)
 d0029ec:	280d883a 	mov	r6,r5
 d0029f0:	21400217 	ldw	r5,8(r4)
 d0029f4:	d8c00204 	addi	r3,sp,8
 d0029f8:	180f883a 	mov	r7,r3
 d0029fc:	d8c00015 	stw	r3,0(sp)
 d002a00:	d0036300 	call	d003630 <___vfprintf_internal_r>
 d002a04:	dfc00117 	ldw	ra,4(sp)
 d002a08:	dec00404 	addi	sp,sp,16
 d002a0c:	f800283a 	ret

0d002a10 <putc>:
 d002a10:	defffc04 	addi	sp,sp,-16
 d002a14:	dc800215 	stw	r18,8(sp)
 d002a18:	04834174 	movhi	r18,3333
 d002a1c:	948a2204 	addi	r18,r18,10376
 d002a20:	90c00017 	ldw	r3,0(r18)
 d002a24:	dc400115 	stw	r17,4(sp)
 d002a28:	dc000015 	stw	r16,0(sp)
 d002a2c:	dfc00315 	stw	ra,12(sp)
 d002a30:	2023883a 	mov	r17,r4
 d002a34:	2821883a 	mov	r16,r5
 d002a38:	18000226 	beq	r3,zero,d002a44 <putc+0x34>
 d002a3c:	18800e17 	ldw	r2,56(r3)
 d002a40:	10001126 	beq	r2,zero,d002a88 <putc+0x78>
 d002a44:	80800217 	ldw	r2,8(r16)
 d002a48:	10ffffc4 	addi	r3,r2,-1
 d002a4c:	80c00215 	stw	r3,8(r16)
 d002a50:	18001316 	blt	r3,zero,d002aa0 <putc+0x90>
 d002a54:	80800017 	ldw	r2,0(r16)
 d002a58:	14400005 	stb	r17,0(r2)
 d002a5c:	80c00017 	ldw	r3,0(r16)
 d002a60:	18800044 	addi	r2,r3,1
 d002a64:	18c00003 	ldbu	r3,0(r3)
 d002a68:	80800015 	stw	r2,0(r16)
 d002a6c:	1805883a 	mov	r2,r3
 d002a70:	dfc00317 	ldw	ra,12(sp)
 d002a74:	dc800217 	ldw	r18,8(sp)
 d002a78:	dc400117 	ldw	r17,4(sp)
 d002a7c:	dc000017 	ldw	r16,0(sp)
 d002a80:	dec00404 	addi	sp,sp,16
 d002a84:	f800283a 	ret
 d002a88:	1809883a 	mov	r4,r3
 d002a8c:	d0071ec0 	call	d0071ec <__sinit>
 d002a90:	80800217 	ldw	r2,8(r16)
 d002a94:	10ffffc4 	addi	r3,r2,-1
 d002a98:	80c00215 	stw	r3,8(r16)
 d002a9c:	183fed0e 	bge	r3,zero,d002a54 <putc+0x44>
 d002aa0:	80800617 	ldw	r2,24(r16)
 d002aa4:	18800f16 	blt	r3,r2,d002ae4 <putc+0xd4>
 d002aa8:	80800017 	ldw	r2,0(r16)
 d002aac:	14400005 	stb	r17,0(r2)
 d002ab0:	81000017 	ldw	r4,0(r16)
 d002ab4:	00800284 	movi	r2,10
 d002ab8:	20c00003 	ldbu	r3,0(r4)
 d002abc:	18801226 	beq	r3,r2,d002b08 <putc+0xf8>
 d002ac0:	20800044 	addi	r2,r4,1
 d002ac4:	80800015 	stw	r2,0(r16)
 d002ac8:	1805883a 	mov	r2,r3
 d002acc:	dfc00317 	ldw	ra,12(sp)
 d002ad0:	dc800217 	ldw	r18,8(sp)
 d002ad4:	dc400117 	ldw	r17,4(sp)
 d002ad8:	dc000017 	ldw	r16,0(sp)
 d002adc:	dec00404 	addi	sp,sp,16
 d002ae0:	f800283a 	ret
 d002ae4:	91000017 	ldw	r4,0(r18)
 d002ae8:	880b883a 	mov	r5,r17
 d002aec:	800d883a 	mov	r6,r16
 d002af0:	dfc00317 	ldw	ra,12(sp)
 d002af4:	dc800217 	ldw	r18,8(sp)
 d002af8:	dc400117 	ldw	r17,4(sp)
 d002afc:	dc000017 	ldw	r16,0(sp)
 d002b00:	dec00404 	addi	sp,sp,16
 d002b04:	d0055001 	jmpi	d005500 <__swbuf_r>
 d002b08:	91000017 	ldw	r4,0(r18)
 d002b0c:	180b883a 	mov	r5,r3
 d002b10:	003ff606 	br	d002aec <putc+0xdc>

0d002b14 <_putc_r>:
 d002b14:	defffc04 	addi	sp,sp,-16
 d002b18:	dc400215 	stw	r17,8(sp)
 d002b1c:	dc000115 	stw	r16,4(sp)
 d002b20:	dfc00315 	stw	ra,12(sp)
 d002b24:	2021883a 	mov	r16,r4
 d002b28:	2823883a 	mov	r17,r5
 d002b2c:	20000226 	beq	r4,zero,d002b38 <_putc_r+0x24>
 d002b30:	20800e17 	ldw	r2,56(r4)
 d002b34:	10001026 	beq	r2,zero,d002b78 <_putc_r+0x64>
 d002b38:	30800217 	ldw	r2,8(r6)
 d002b3c:	10ffffc4 	addi	r3,r2,-1
 d002b40:	30c00215 	stw	r3,8(r6)
 d002b44:	18001316 	blt	r3,zero,d002b94 <_putc_r+0x80>
 d002b48:	30800017 	ldw	r2,0(r6)
 d002b4c:	14400005 	stb	r17,0(r2)
 d002b50:	30c00017 	ldw	r3,0(r6)
 d002b54:	18800044 	addi	r2,r3,1
 d002b58:	18c00003 	ldbu	r3,0(r3)
 d002b5c:	30800015 	stw	r2,0(r6)
 d002b60:	1805883a 	mov	r2,r3
 d002b64:	dfc00317 	ldw	ra,12(sp)
 d002b68:	dc400217 	ldw	r17,8(sp)
 d002b6c:	dc000117 	ldw	r16,4(sp)
 d002b70:	dec00404 	addi	sp,sp,16
 d002b74:	f800283a 	ret
 d002b78:	d9800015 	stw	r6,0(sp)
 d002b7c:	d0071ec0 	call	d0071ec <__sinit>
 d002b80:	d9800017 	ldw	r6,0(sp)
 d002b84:	30800217 	ldw	r2,8(r6)
 d002b88:	10ffffc4 	addi	r3,r2,-1
 d002b8c:	30c00215 	stw	r3,8(r6)
 d002b90:	183fed0e 	bge	r3,zero,d002b48 <_putc_r+0x34>
 d002b94:	30800617 	ldw	r2,24(r6)
 d002b98:	18800e16 	blt	r3,r2,d002bd4 <_putc_r+0xc0>
 d002b9c:	30800017 	ldw	r2,0(r6)
 d002ba0:	14400005 	stb	r17,0(r2)
 d002ba4:	31000017 	ldw	r4,0(r6)
 d002ba8:	00800284 	movi	r2,10
 d002bac:	20c00003 	ldbu	r3,0(r4)
 d002bb0:	18800f26 	beq	r3,r2,d002bf0 <_putc_r+0xdc>
 d002bb4:	20800044 	addi	r2,r4,1
 d002bb8:	30800015 	stw	r2,0(r6)
 d002bbc:	1805883a 	mov	r2,r3
 d002bc0:	dfc00317 	ldw	ra,12(sp)
 d002bc4:	dc400217 	ldw	r17,8(sp)
 d002bc8:	dc000117 	ldw	r16,4(sp)
 d002bcc:	dec00404 	addi	sp,sp,16
 d002bd0:	f800283a 	ret
 d002bd4:	8009883a 	mov	r4,r16
 d002bd8:	880b883a 	mov	r5,r17
 d002bdc:	dfc00317 	ldw	ra,12(sp)
 d002be0:	dc400217 	ldw	r17,8(sp)
 d002be4:	dc000117 	ldw	r16,4(sp)
 d002be8:	dec00404 	addi	sp,sp,16
 d002bec:	d0055001 	jmpi	d005500 <__swbuf_r>
 d002bf0:	8009883a 	mov	r4,r16
 d002bf4:	180b883a 	mov	r5,r3
 d002bf8:	003ff806 	br	d002bdc <_putc_r+0xc8>

0d002bfc <putchar>:
 d002bfc:	00834174 	movhi	r2,3333
 d002c00:	108a2204 	addi	r2,r2,10376
 d002c04:	11800017 	ldw	r6,0(r2)
 d002c08:	200b883a 	mov	r5,r4
 d002c0c:	3009883a 	mov	r4,r6
 d002c10:	31800217 	ldw	r6,8(r6)
 d002c14:	d002b141 	jmpi	d002b14 <_putc_r>

0d002c18 <_putchar_r>:
 d002c18:	21800217 	ldw	r6,8(r4)
 d002c1c:	d002b141 	jmpi	d002b14 <_putc_r>

0d002c20 <_puts_r>:
 d002c20:	defff604 	addi	sp,sp,-40
 d002c24:	dc400715 	stw	r17,28(sp)
 d002c28:	2023883a 	mov	r17,r4
 d002c2c:	2809883a 	mov	r4,r5
 d002c30:	dfc00915 	stw	ra,36(sp)
 d002c34:	dcc00815 	stw	r19,32(sp)
 d002c38:	2827883a 	mov	r19,r5
 d002c3c:	d00355c0 	call	d00355c <strlen>
 d002c40:	89400217 	ldw	r5,8(r17)
 d002c44:	00c34174 	movhi	r3,3333
 d002c48:	18ef0204 	addi	r3,r3,-17400
 d002c4c:	01c00044 	movi	r7,1
 d002c50:	12000044 	addi	r8,r2,1
 d002c54:	d8c00515 	stw	r3,20(sp)
 d002c58:	d9c00615 	stw	r7,24(sp)
 d002c5c:	d8c00304 	addi	r3,sp,12
 d002c60:	01c00084 	movi	r7,2
 d002c64:	8809883a 	mov	r4,r17
 d002c68:	d80d883a 	mov	r6,sp
 d002c6c:	d8c00015 	stw	r3,0(sp)
 d002c70:	dcc00315 	stw	r19,12(sp)
 d002c74:	da000215 	stw	r8,8(sp)
 d002c78:	d9c00115 	stw	r7,4(sp)
 d002c7c:	d8800415 	stw	r2,16(sp)
 d002c80:	d0079d00 	call	d0079d0 <__sfvwrite_r>
 d002c84:	00ffffc4 	movi	r3,-1
 d002c88:	10000626 	beq	r2,zero,d002ca4 <_puts_r+0x84>
 d002c8c:	1805883a 	mov	r2,r3
 d002c90:	dfc00917 	ldw	ra,36(sp)
 d002c94:	dcc00817 	ldw	r19,32(sp)
 d002c98:	dc400717 	ldw	r17,28(sp)
 d002c9c:	dec00a04 	addi	sp,sp,40
 d002ca0:	f800283a 	ret
 d002ca4:	00c00284 	movi	r3,10
 d002ca8:	1805883a 	mov	r2,r3
 d002cac:	dfc00917 	ldw	ra,36(sp)
 d002cb0:	dcc00817 	ldw	r19,32(sp)
 d002cb4:	dc400717 	ldw	r17,28(sp)
 d002cb8:	dec00a04 	addi	sp,sp,40
 d002cbc:	f800283a 	ret

0d002cc0 <puts>:
 d002cc0:	00834174 	movhi	r2,3333
 d002cc4:	108a2204 	addi	r2,r2,10376
 d002cc8:	200b883a 	mov	r5,r4
 d002ccc:	11000017 	ldw	r4,0(r2)
 d002cd0:	d002c201 	jmpi	d002c20 <_puts_r>

0d002cd4 <__srget_r>:
 d002cd4:	defffe04 	addi	sp,sp,-8
 d002cd8:	dc000015 	stw	r16,0(sp)
 d002cdc:	dfc00115 	stw	ra,4(sp)
 d002ce0:	2821883a 	mov	r16,r5
 d002ce4:	d00a0500 	call	d00a050 <__srefill_r>
 d002ce8:	013fffc4 	movi	r4,-1
 d002cec:	1000071e 	bne	r2,zero,d002d0c <__srget_r+0x38>
 d002cf0:	80800117 	ldw	r2,4(r16)
 d002cf4:	81000017 	ldw	r4,0(r16)
 d002cf8:	10bfffc4 	addi	r2,r2,-1
 d002cfc:	20c00044 	addi	r3,r4,1
 d002d00:	80800115 	stw	r2,4(r16)
 d002d04:	21000003 	ldbu	r4,0(r4)
 d002d08:	80c00015 	stw	r3,0(r16)
 d002d0c:	2005883a 	mov	r2,r4
 d002d10:	dfc00117 	ldw	ra,4(sp)
 d002d14:	dc000017 	ldw	r16,0(sp)
 d002d18:	dec00204 	addi	sp,sp,8
 d002d1c:	f800283a 	ret

0d002d20 <__srget>:
 d002d20:	00834174 	movhi	r2,3333
 d002d24:	108a2204 	addi	r2,r2,10376
 d002d28:	200b883a 	mov	r5,r4
 d002d2c:	11000017 	ldw	r4,0(r2)
 d002d30:	d002cd41 	jmpi	d002cd4 <__srget_r>

0d002d34 <sprintf>:
 d002d34:	deffe504 	addi	sp,sp,-108
 d002d38:	2013883a 	mov	r9,r4
 d002d3c:	dfc01815 	stw	ra,96(sp)
 d002d40:	d9801915 	stw	r6,100(sp)
 d002d44:	d9c01a15 	stw	r7,104(sp)
 d002d48:	d8801904 	addi	r2,sp,100
 d002d4c:	d8800015 	stw	r2,0(sp)
 d002d50:	00834174 	movhi	r2,3333
 d002d54:	108a2204 	addi	r2,r2,10376
 d002d58:	11000017 	ldw	r4,0(r2)
 d002d5c:	d9c00017 	ldw	r7,0(sp)
 d002d60:	00808204 	movi	r2,520
 d002d64:	00e00034 	movhi	r3,32768
 d002d68:	18ffffc4 	addi	r3,r3,-1
 d002d6c:	280d883a 	mov	r6,r5
 d002d70:	d880040d 	sth	r2,16(sp)
 d002d74:	d9400104 	addi	r5,sp,4
 d002d78:	00bfffc4 	movi	r2,-1
 d002d7c:	d8c00615 	stw	r3,24(sp)
 d002d80:	d8c00315 	stw	r3,12(sp)
 d002d84:	da400515 	stw	r9,20(sp)
 d002d88:	d880048d 	sth	r2,18(sp)
 d002d8c:	da400115 	stw	r9,4(sp)
 d002d90:	d0036300 	call	d003630 <___vfprintf_internal_r>
 d002d94:	d8c00117 	ldw	r3,4(sp)
 d002d98:	18000005 	stb	zero,0(r3)
 d002d9c:	dfc01817 	ldw	ra,96(sp)
 d002da0:	dec01b04 	addi	sp,sp,108
 d002da4:	f800283a 	ret

0d002da8 <_sprintf_r>:
 d002da8:	deffe604 	addi	sp,sp,-104
 d002dac:	2813883a 	mov	r9,r5
 d002db0:	dfc01815 	stw	ra,96(sp)
 d002db4:	d9c01915 	stw	r7,100(sp)
 d002db8:	d8801904 	addi	r2,sp,100
 d002dbc:	d8800015 	stw	r2,0(sp)
 d002dc0:	100f883a 	mov	r7,r2
 d002dc4:	00808204 	movi	r2,520
 d002dc8:	00e00034 	movhi	r3,32768
 d002dcc:	18ffffc4 	addi	r3,r3,-1
 d002dd0:	d880040d 	sth	r2,16(sp)
 d002dd4:	d9400104 	addi	r5,sp,4
 d002dd8:	00bfffc4 	movi	r2,-1
 d002ddc:	d8c00615 	stw	r3,24(sp)
 d002de0:	d8c00315 	stw	r3,12(sp)
 d002de4:	da400515 	stw	r9,20(sp)
 d002de8:	d880048d 	sth	r2,18(sp)
 d002dec:	da400115 	stw	r9,4(sp)
 d002df0:	d0036300 	call	d003630 <___vfprintf_internal_r>
 d002df4:	d8c00117 	ldw	r3,4(sp)
 d002df8:	18000005 	stb	zero,0(r3)
 d002dfc:	dfc01817 	ldw	ra,96(sp)
 d002e00:	dec01a04 	addi	sp,sp,104
 d002e04:	f800283a 	ret

0d002e08 <strchr>:
 d002e08:	208000cc 	andi	r2,r4,3
 d002e0c:	2007883a 	mov	r3,r4
 d002e10:	1000311e 	bne	r2,zero,d002ed8 <strchr+0xd0>
 d002e14:	29c03fcc 	andi	r7,r5,255
 d002e18:	0015883a 	mov	r10,zero
 d002e1c:	0007883a 	mov	r3,zero
 d002e20:	01400104 	movi	r5,4
 d002e24:	5004923a 	slli	r2,r10,8
 d002e28:	18c00044 	addi	r3,r3,1
 d002e2c:	3894b03a 	or	r10,r7,r2
 d002e30:	197ffc1e 	bne	r3,r5,d002e24 <strchr+0x1c>
 d002e34:	200d883a 	mov	r6,r4
 d002e38:	21000017 	ldw	r4,0(r4)
 d002e3c:	017fbff4 	movhi	r5,65279
 d002e40:	297fbfc4 	addi	r5,r5,-257
 d002e44:	02202074 	movhi	r8,32897
 d002e48:	42202004 	addi	r8,r8,-32640
 d002e4c:	2145883a 	add	r2,r4,r5
 d002e50:	1204703a 	and	r2,r2,r8
 d002e54:	0106303a 	nor	r3,zero,r4
 d002e58:	10c4703a 	and	r2,r2,r3
 d002e5c:	1000151e 	bne	r2,zero,d002eb4 <strchr+0xac>
 d002e60:	2284f03a 	xor	r2,r4,r10
 d002e64:	1147883a 	add	r3,r2,r5
 d002e68:	1a06703a 	and	r3,r3,r8
 d002e6c:	0084303a 	nor	r2,zero,r2
 d002e70:	10c4703a 	and	r2,r2,r3
 d002e74:	10000f1e 	bne	r2,zero,d002eb4 <strchr+0xac>
 d002e78:	2813883a 	mov	r9,r5
 d002e7c:	00000106 	br	d002e84 <strchr+0x7c>
 d002e80:	18000c1e 	bne	r3,zero,d002eb4 <strchr+0xac>
 d002e84:	31800104 	addi	r6,r6,4
 d002e88:	30800017 	ldw	r2,0(r6)
 d002e8c:	1286f03a 	xor	r3,r2,r10
 d002e90:	124b883a 	add	r5,r2,r9
 d002e94:	1a49883a 	add	r4,r3,r9
 d002e98:	2a0a703a 	and	r5,r5,r8
 d002e9c:	0084303a 	nor	r2,zero,r2
 d002ea0:	2208703a 	and	r4,r4,r8
 d002ea4:	00c6303a 	nor	r3,zero,r3
 d002ea8:	1144703a 	and	r2,r2,r5
 d002eac:	1906703a 	and	r3,r3,r4
 d002eb0:	103ff326 	beq	r2,zero,d002e80 <strchr+0x78>
 d002eb4:	3007883a 	mov	r3,r6
 d002eb8:	00000206 	br	d002ec4 <strchr+0xbc>
 d002ebc:	38800426 	beq	r7,r2,d002ed0 <strchr+0xc8>
 d002ec0:	18c00044 	addi	r3,r3,1
 d002ec4:	18800003 	ldbu	r2,0(r3)
 d002ec8:	103ffc1e 	bne	r2,zero,d002ebc <strchr+0xb4>
 d002ecc:	3800041e 	bne	r7,zero,d002ee0 <strchr+0xd8>
 d002ed0:	1805883a 	mov	r2,r3
 d002ed4:	f800283a 	ret
 d002ed8:	29c03fcc 	andi	r7,r5,255
 d002edc:	003ff906 	br	d002ec4 <strchr+0xbc>
 d002ee0:	0005883a 	mov	r2,zero
 d002ee4:	f800283a 	ret

0d002ee8 <strerror>:
 d002ee8:	deffff04 	addi	sp,sp,-4
 d002eec:	00802184 	movi	r2,134
 d002ef0:	dfc00015 	stw	ra,0(sp)
 d002ef4:	200b883a 	mov	r5,r4
 d002ef8:	11008e36 	bltu	r2,r4,d003134 <strerror+0x24c>
 d002efc:	2105883a 	add	r2,r4,r4
 d002f00:	1085883a 	add	r2,r2,r2
 d002f04:	00c34034 	movhi	r3,3328
 d002f08:	18cbc604 	addi	r3,r3,12056
 d002f0c:	10c5883a 	add	r2,r2,r3
 d002f10:	11000017 	ldw	r4,0(r2)
 d002f14:	2000683a 	jmp	r4
 d002f18:	0d003134 	orhi	r20,at,196
 d002f1c:	0d00316c 	andhi	r20,at,197
 d002f20:	0d003178 	rdprs	r20,at,197
 d002f24:	0d003184 	addi	r20,at,198
 d002f28:	0d003190 	cmplti	r20,at,198
 d002f2c:	0d00319c 	xori	r20,at,198
 d002f30:	0d0031a8 	cmpgeui	r20,at,198
 d002f34:	0d0031b4 	orhi	r20,at,198
 d002f38:	0d0031c0 	call	d0031c <OSCtxSw_SWITCH_PC+0xd002dc>
 d002f3c:	0d0031cc 	andi	r20,at,199
 d002f40:	0d0031d8 	cmpnei	r20,at,199
 d002f44:	0d0031e4 	muli	r20,at,199
 d002f48:	0d0031f0 	cmpltui	r20,at,199
 d002f4c:	0d0031fc 	xorhi	r20,at,199
 d002f50:	0d003208 	cmpgei	r20,at,200
 d002f54:	0d003214 	ori	r20,at,200
 d002f58:	0d003220 	cmpeqi	r20,at,200
 d002f5c:	0d00322c 	andhi	r20,at,200
 d002f60:	0d003238 	rdprs	r20,at,200
 d002f64:	0d003244 	addi	r20,at,201
 d002f68:	0d003250 	cmplti	r20,at,201
 d002f6c:	0d00325c 	xori	r20,at,201
 d002f70:	0d003268 	cmpgeui	r20,at,201
 d002f74:	0d003274 	orhi	r20,at,201
 d002f78:	0d003280 	call	d00328 <OSCtxSw_SWITCH_PC+0xd002e8>
 d002f7c:	0d00328c 	andi	r20,at,202
 d002f80:	0d003298 	cmpnei	r20,at,202
 d002f84:	0d0032a4 	muli	r20,at,202
 d002f88:	0d0032b0 	cmpltui	r20,at,202
 d002f8c:	0d0032bc 	xorhi	r20,at,202
 d002f90:	0d0032c8 	cmpgei	r20,at,203
 d002f94:	0d0032d4 	ori	r20,at,203
 d002f98:	0d0032e0 	cmpeqi	r20,at,203
 d002f9c:	0d0032ec 	andhi	r20,at,203
 d002fa0:	0d0032f8 	rdprs	r20,at,203
 d002fa4:	0d003304 	addi	r20,at,204
 d002fa8:	0d003310 	cmplti	r20,at,204
 d002fac:	0d003134 	orhi	r20,at,196
 d002fb0:	0d003134 	orhi	r20,at,196
 d002fb4:	0d003134 	orhi	r20,at,196
 d002fb8:	0d003134 	orhi	r20,at,196
 d002fbc:	0d003134 	orhi	r20,at,196
 d002fc0:	0d003134 	orhi	r20,at,196
 d002fc4:	0d003134 	orhi	r20,at,196
 d002fc8:	0d003134 	orhi	r20,at,196
 d002fcc:	0d00331c 	xori	r20,at,204
 d002fd0:	0d003328 	cmpgeui	r20,at,204
 d002fd4:	0d003134 	orhi	r20,at,196
 d002fd8:	0d003134 	orhi	r20,at,196
 d002fdc:	0d003134 	orhi	r20,at,196
 d002fe0:	0d003134 	orhi	r20,at,196
 d002fe4:	0d003134 	orhi	r20,at,196
 d002fe8:	0d003134 	orhi	r20,at,196
 d002fec:	0d003134 	orhi	r20,at,196
 d002ff0:	0d003134 	orhi	r20,at,196
 d002ff4:	0d003134 	orhi	r20,at,196
 d002ff8:	0d003134 	orhi	r20,at,196
 d002ffc:	0d003134 	orhi	r20,at,196
 d003000:	0d003134 	orhi	r20,at,196
 d003004:	0d003134 	orhi	r20,at,196
 d003008:	0d003334 	orhi	r20,at,204
 d00300c:	0d003134 	orhi	r20,at,196
 d003010:	0d003340 	call	d00334 <OSCtxSw_SWITCH_PC+0xd002f4>
 d003014:	0d00334c 	andi	r20,at,205
 d003018:	0d003358 	cmpnei	r20,at,205
 d00301c:	0d003364 	muli	r20,at,205
 d003020:	0d003370 	cmpltui	r20,at,205
 d003024:	0d00337c 	xorhi	r20,at,205
 d003028:	0d003388 	cmpgei	r20,at,206
 d00302c:	0d003394 	ori	r20,at,206
 d003030:	0d0033a0 	cmpeqi	r20,at,206
 d003034:	0d0033ac 	andhi	r20,at,206
 d003038:	0d003134 	orhi	r20,at,196
 d00303c:	0d003134 	orhi	r20,at,196
 d003040:	0d0033b8 	rdprs	r20,at,206
 d003044:	0d003134 	orhi	r20,at,196
 d003048:	0d003134 	orhi	r20,at,196
 d00304c:	0d0033c4 	addi	r20,at,207
 d003050:	0d003134 	orhi	r20,at,196
 d003054:	0d003134 	orhi	r20,at,196
 d003058:	0d003134 	orhi	r20,at,196
 d00305c:	0d003134 	orhi	r20,at,196
 d003060:	0d003134 	orhi	r20,at,196
 d003064:	0d0033d0 	cmplti	r20,at,207
 d003068:	0d0033dc 	xori	r20,at,207
 d00306c:	0d0033e8 	cmpgeui	r20,at,207
 d003070:	0d0033f4 	orhi	r20,at,207
 d003074:	0d003400 	call	d00340 <OSCtxSw_SWITCH_PC+0xd00300>
 d003078:	0d00340c 	andi	r20,at,208
 d00307c:	0d003418 	cmpnei	r20,at,208
 d003080:	0d003424 	muli	r20,at,208
 d003084:	0d003430 	cmpltui	r20,at,208
 d003088:	0d00343c 	xorhi	r20,at,208
 d00308c:	0d003134 	orhi	r20,at,196
 d003090:	0d003134 	orhi	r20,at,196
 d003094:	0d003448 	cmpgei	r20,at,209
 d003098:	0d003134 	orhi	r20,at,196
 d00309c:	0d003134 	orhi	r20,at,196
 d0030a0:	0d003134 	orhi	r20,at,196
 d0030a4:	0d003134 	orhi	r20,at,196
 d0030a8:	0d003134 	orhi	r20,at,196
 d0030ac:	0d003134 	orhi	r20,at,196
 d0030b0:	0d003134 	orhi	r20,at,196
 d0030b4:	0d003134 	orhi	r20,at,196
 d0030b8:	0d003134 	orhi	r20,at,196
 d0030bc:	0d003454 	ori	r20,at,209
 d0030c0:	0d003460 	cmpeqi	r20,at,209
 d0030c4:	0d00346c 	andhi	r20,at,209
 d0030c8:	0d003478 	rdprs	r20,at,209
 d0030cc:	0d003484 	addi	r20,at,210
 d0030d0:	0d003490 	cmplti	r20,at,210
 d0030d4:	0d00349c 	xori	r20,at,210
 d0030d8:	0d0034a8 	cmpgeui	r20,at,210
 d0030dc:	0d0034b4 	orhi	r20,at,210
 d0030e0:	0d0034c0 	call	d0034c <OSCtxSw_SWITCH_PC+0xd0030c>
 d0030e4:	0d0034cc 	andi	r20,at,211
 d0030e8:	0d0034d8 	cmpnei	r20,at,211
 d0030ec:	0d0034e4 	muli	r20,at,211
 d0030f0:	0d0034f0 	cmpltui	r20,at,211
 d0030f4:	0d0034fc 	xorhi	r20,at,211
 d0030f8:	0d003508 	cmpgei	r20,at,212
 d0030fc:	0d003514 	ori	r20,at,212
 d003100:	0d003520 	cmpeqi	r20,at,212
 d003104:	0d00352c 	andhi	r20,at,212
 d003108:	0d003538 	rdprs	r20,at,212
 d00310c:	0d003134 	orhi	r20,at,196
 d003110:	0d003134 	orhi	r20,at,196
 d003114:	0d003544 	addi	r20,at,213
 d003118:	0d003550 	cmplti	r20,at,213
 d00311c:	0d003134 	orhi	r20,at,196
 d003120:	0d003134 	orhi	r20,at,196
 d003124:	0d003134 	orhi	r20,at,196
 d003128:	0d003134 	orhi	r20,at,196
 d00312c:	0d003134 	orhi	r20,at,196
 d003130:	0d003160 	cmpeqi	r20,at,197
 d003134:	2809883a 	mov	r4,r5
 d003138:	d0035d00 	call	d0035d0 <_user_strerror>
 d00313c:	10000326 	beq	r2,zero,d00314c <strerror+0x264>
 d003140:	dfc00017 	ldw	ra,0(sp)
 d003144:	dec00104 	addi	sp,sp,4
 d003148:	f800283a 	ret
 d00314c:	00834174 	movhi	r2,3333
 d003150:	10b0fb04 	addi	r2,r2,-15380
 d003154:	dfc00017 	ldw	ra,0(sp)
 d003158:	dec00104 	addi	sp,sp,4
 d00315c:	f800283a 	ret
 d003160:	00834174 	movhi	r2,3333
 d003164:	10afbe04 	addi	r2,r2,-16648
 d003168:	003ff506 	br	d003140 <strerror+0x258>
 d00316c:	00834174 	movhi	r2,3333
 d003170:	10af0e04 	addi	r2,r2,-17352
 d003174:	003ff206 	br	d003140 <strerror+0x258>
 d003178:	00834174 	movhi	r2,3333
 d00317c:	10af1104 	addi	r2,r2,-17340
 d003180:	003fef06 	br	d003140 <strerror+0x258>
 d003184:	00834174 	movhi	r2,3333
 d003188:	10af1804 	addi	r2,r2,-17312
 d00318c:	003fec06 	br	d003140 <strerror+0x258>
 d003190:	00834174 	movhi	r2,3333
 d003194:	10af1c04 	addi	r2,r2,-17296
 d003198:	003fe906 	br	d003140 <strerror+0x258>
 d00319c:	00834174 	movhi	r2,3333
 d0031a0:	10af2204 	addi	r2,r2,-17272
 d0031a4:	003fe606 	br	d003140 <strerror+0x258>
 d0031a8:	00834174 	movhi	r2,3333
 d0031ac:	10af2504 	addi	r2,r2,-17260
 d0031b0:	003fe306 	br	d003140 <strerror+0x258>
 d0031b4:	00834174 	movhi	r2,3333
 d0031b8:	10af2c04 	addi	r2,r2,-17232
 d0031bc:	003fe006 	br	d003140 <strerror+0x258>
 d0031c0:	00834174 	movhi	r2,3333
 d0031c4:	10af3104 	addi	r2,r2,-17212
 d0031c8:	003fdd06 	br	d003140 <strerror+0x258>
 d0031cc:	00834174 	movhi	r2,3333
 d0031d0:	10af3d04 	addi	r2,r2,-17164
 d0031d4:	003fda06 	br	d003140 <strerror+0x258>
 d0031d8:	00834174 	movhi	r2,3333
 d0031dc:	10af4104 	addi	r2,r2,-17148
 d0031e0:	003fd706 	br	d003140 <strerror+0x258>
 d0031e4:	00834174 	movhi	r2,3333
 d0031e8:	10af4c04 	addi	r2,r2,-17104
 d0031ec:	003fd406 	br	d003140 <strerror+0x258>
 d0031f0:	00834174 	movhi	r2,3333
 d0031f4:	10af5104 	addi	r2,r2,-17084
 d0031f8:	003fd106 	br	d003140 <strerror+0x258>
 d0031fc:	00834174 	movhi	r2,3333
 d003200:	10af5604 	addi	r2,r2,-17064
 d003204:	003fce06 	br	d003140 <strerror+0x258>
 d003208:	00834174 	movhi	r2,3333
 d00320c:	10af5b04 	addi	r2,r2,-17044
 d003210:	003fcb06 	br	d003140 <strerror+0x258>
 d003214:	00834174 	movhi	r2,3333
 d003218:	10af5e04 	addi	r2,r2,-17032
 d00321c:	003fc806 	br	d003140 <strerror+0x258>
 d003220:	00834174 	movhi	r2,3333
 d003224:	10af6404 	addi	r2,r2,-17008
 d003228:	003fc506 	br	d003140 <strerror+0x258>
 d00322c:	00834174 	movhi	r2,3333
 d003230:	10af6a04 	addi	r2,r2,-16984
 d003234:	003fc206 	br	d003140 <strerror+0x258>
 d003238:	00834174 	movhi	r2,3333
 d00323c:	10af6d04 	addi	r2,r2,-16972
 d003240:	003fbf06 	br	d003140 <strerror+0x258>
 d003244:	00834174 	movhi	r2,3333
 d003248:	10af7204 	addi	r2,r2,-16952
 d00324c:	003fbc06 	br	d003140 <strerror+0x258>
 d003250:	00834174 	movhi	r2,3333
 d003254:	10af7604 	addi	r2,r2,-16936
 d003258:	003fb906 	br	d003140 <strerror+0x258>
 d00325c:	00834174 	movhi	r2,3333
 d003260:	10af8604 	addi	r2,r2,-16872
 d003264:	003fb606 	br	d003140 <strerror+0x258>
 d003268:	00834174 	movhi	r2,3333
 d00326c:	10af8a04 	addi	r2,r2,-16856
 d003270:	003fb306 	br	d003140 <strerror+0x258>
 d003274:	00834174 	movhi	r2,3333
 d003278:	10af9804 	addi	r2,r2,-16800
 d00327c:	003fb006 	br	d003140 <strerror+0x258>
 d003280:	00834174 	movhi	r2,3333
 d003284:	10afa004 	addi	r2,r2,-16768
 d003288:	003fad06 	br	d003140 <strerror+0x258>
 d00328c:	00834174 	movhi	r2,3333
 d003290:	10afa504 	addi	r2,r2,-16748
 d003294:	003faa06 	br	d003140 <strerror+0x258>
 d003298:	00834174 	movhi	r2,3333
 d00329c:	10afab04 	addi	r2,r2,-16724
 d0032a0:	003fa706 	br	d003140 <strerror+0x258>
 d0032a4:	00834174 	movhi	r2,3333
 d0032a8:	10afaf04 	addi	r2,r2,-16708
 d0032ac:	003fa406 	br	d003140 <strerror+0x258>
 d0032b0:	00834174 	movhi	r2,3333
 d0032b4:	10afb804 	addi	r2,r2,-16672
 d0032b8:	003fa106 	br	d003140 <strerror+0x258>
 d0032bc:	00834174 	movhi	r2,3333
 d0032c0:	10afc204 	addi	r2,r2,-16632
 d0032c4:	003f9e06 	br	d003140 <strerror+0x258>
 d0032c8:	00834174 	movhi	r2,3333
 d0032cc:	10afc604 	addi	r2,r2,-16616
 d0032d0:	003f9b06 	br	d003140 <strerror+0x258>
 d0032d4:	00834174 	movhi	r2,3333
 d0032d8:	10afcc04 	addi	r2,r2,-16592
 d0032dc:	003f9806 	br	d003140 <strerror+0x258>
 d0032e0:	00834174 	movhi	r2,3333
 d0032e4:	10afd004 	addi	r2,r2,-16576
 d0032e8:	003f9506 	br	d003140 <strerror+0x258>
 d0032ec:	00834174 	movhi	r2,3333
 d0032f0:	10afd304 	addi	r2,r2,-16564
 d0032f4:	003f9206 	br	d003140 <strerror+0x258>
 d0032f8:	00834174 	movhi	r2,3333
 d0032fc:	10afd704 	addi	r2,r2,-16548
 d003300:	003f8f06 	br	d003140 <strerror+0x258>
 d003304:	00834174 	movhi	r2,3333
 d003308:	10afdc04 	addi	r2,r2,-16528
 d00330c:	003f8c06 	br	d003140 <strerror+0x258>
 d003310:	00834174 	movhi	r2,3333
 d003314:	10afe304 	addi	r2,r2,-16500
 d003318:	003f8906 	br	d003140 <strerror+0x258>
 d00331c:	00834174 	movhi	r2,3333
 d003320:	10afe804 	addi	r2,r2,-16480
 d003324:	003f8606 	br	d003140 <strerror+0x258>
 d003328:	00834174 	movhi	r2,3333
 d00332c:	10aff104 	addi	r2,r2,-16444
 d003330:	003f8306 	br	d003140 <strerror+0x258>
 d003334:	00834174 	movhi	r2,3333
 d003338:	10aff304 	addi	r2,r2,-16436
 d00333c:	003f8006 	br	d003140 <strerror+0x258>
 d003340:	00834174 	movhi	r2,3333
 d003344:	10aff704 	addi	r2,r2,-16420
 d003348:	003f7d06 	br	d003140 <strerror+0x258>
 d00334c:	00834174 	movhi	r2,3333
 d003350:	10affd04 	addi	r2,r2,-16396
 d003354:	003f7a06 	br	d003140 <strerror+0x258>
 d003358:	00834174 	movhi	r2,3333
 d00335c:	10b00204 	addi	r2,r2,-16376
 d003360:	003f7706 	br	d003140 <strerror+0x258>
 d003364:	00834174 	movhi	r2,3333
 d003368:	10b00a04 	addi	r2,r2,-16344
 d00336c:	003f7406 	br	d003140 <strerror+0x258>
 d003370:	00834174 	movhi	r2,3333
 d003374:	10b00d04 	addi	r2,r2,-16332
 d003378:	003f7106 	br	d003140 <strerror+0x258>
 d00337c:	00834174 	movhi	r2,3333
 d003380:	10b01204 	addi	r2,r2,-16312
 d003384:	003f6e06 	br	d003140 <strerror+0x258>
 d003388:	00834174 	movhi	r2,3333
 d00338c:	10b01804 	addi	r2,r2,-16288
 d003390:	003f6b06 	br	d003140 <strerror+0x258>
 d003394:	00834174 	movhi	r2,3333
 d003398:	10b01c04 	addi	r2,r2,-16272
 d00339c:	003f6806 	br	d003140 <strerror+0x258>
 d0033a0:	00834174 	movhi	r2,3333
 d0033a4:	10b02004 	addi	r2,r2,-16256
 d0033a8:	003f6506 	br	d003140 <strerror+0x258>
 d0033ac:	00834174 	movhi	r2,3333
 d0033b0:	10b02504 	addi	r2,r2,-16236
 d0033b4:	003f6206 	br	d003140 <strerror+0x258>
 d0033b8:	00834174 	movhi	r2,3333
 d0033bc:	10b02e04 	addi	r2,r2,-16200
 d0033c0:	003f5f06 	br	d003140 <strerror+0x258>
 d0033c4:	00834174 	movhi	r2,3333
 d0033c8:	10b03304 	addi	r2,r2,-16180
 d0033cc:	003f5c06 	br	d003140 <strerror+0x258>
 d0033d0:	00834174 	movhi	r2,3333
 d0033d4:	10b03604 	addi	r2,r2,-16168
 d0033d8:	003f5906 	br	d003140 <strerror+0x258>
 d0033dc:	00834174 	movhi	r2,3333
 d0033e0:	10b04004 	addi	r2,r2,-16128
 d0033e4:	003f5606 	br	d003140 <strerror+0x258>
 d0033e8:	00834174 	movhi	r2,3333
 d0033ec:	10b04a04 	addi	r2,r2,-16088
 d0033f0:	003f5306 	br	d003140 <strerror+0x258>
 d0033f4:	00834174 	movhi	r2,3333
 d0033f8:	10b05204 	addi	r2,r2,-16056
 d0033fc:	003f5006 	br	d003140 <strerror+0x258>
 d003400:	00834174 	movhi	r2,3333
 d003404:	10b06204 	addi	r2,r2,-15992
 d003408:	003f4d06 	br	d003140 <strerror+0x258>
 d00340c:	00834174 	movhi	r2,3333
 d003410:	10b06c04 	addi	r2,r2,-15952
 d003414:	003f4a06 	br	d003140 <strerror+0x258>
 d003418:	00834174 	movhi	r2,3333
 d00341c:	10b07304 	addi	r2,r2,-15924
 d003420:	003f4706 	br	d003140 <strerror+0x258>
 d003424:	00834174 	movhi	r2,3333
 d003428:	10b07704 	addi	r2,r2,-15908
 d00342c:	003f4406 	br	d003140 <strerror+0x258>
 d003430:	00834174 	movhi	r2,3333
 d003434:	10b07c04 	addi	r2,r2,-15888
 d003438:	003f4106 	br	d003140 <strerror+0x258>
 d00343c:	00834174 	movhi	r2,3333
 d003440:	10b08304 	addi	r2,r2,-15860
 d003444:	003f3e06 	br	d003140 <strerror+0x258>
 d003448:	00834174 	movhi	r2,3333
 d00344c:	10b0e304 	addi	r2,r2,-15476
 d003450:	003f3b06 	br	d003140 <strerror+0x258>
 d003454:	00834174 	movhi	r2,3333
 d003458:	10b08904 	addi	r2,r2,-15836
 d00345c:	003f3806 	br	d003140 <strerror+0x258>
 d003460:	00834174 	movhi	r2,3333
 d003464:	10b09004 	addi	r2,r2,-15808
 d003468:	003f3506 	br	d003140 <strerror+0x258>
 d00346c:	00834174 	movhi	r2,3333
 d003470:	10b09c04 	addi	r2,r2,-15760
 d003474:	003f3206 	br	d003140 <strerror+0x258>
 d003478:	00834174 	movhi	r2,3333
 d00347c:	10b0a404 	addi	r2,r2,-15728
 d003480:	003f2f06 	br	d003140 <strerror+0x258>
 d003484:	00834174 	movhi	r2,3333
 d003488:	10b0ac04 	addi	r2,r2,-15696
 d00348c:	003f2c06 	br	d003140 <strerror+0x258>
 d003490:	00834174 	movhi	r2,3333
 d003494:	10b0b204 	addi	r2,r2,-15672
 d003498:	003f2906 	br	d003140 <strerror+0x258>
 d00349c:	00834174 	movhi	r2,3333
 d0034a0:	10b0bb04 	addi	r2,r2,-15636
 d0034a4:	003f2606 	br	d003140 <strerror+0x258>
 d0034a8:	00834174 	movhi	r2,3333
 d0034ac:	10b0c004 	addi	r2,r2,-15616
 d0034b0:	003f2306 	br	d003140 <strerror+0x258>
 d0034b4:	00834174 	movhi	r2,3333
 d0034b8:	10b0c604 	addi	r2,r2,-15592
 d0034bc:	003f2006 	br	d003140 <strerror+0x258>
 d0034c0:	00834174 	movhi	r2,3333
 d0034c4:	10afeb04 	addi	r2,r2,-16468
 d0034c8:	003f1d06 	br	d003140 <strerror+0x258>
 d0034cc:	00834174 	movhi	r2,3333
 d0034d0:	10af8f04 	addi	r2,r2,-16836
 d0034d4:	003f1a06 	br	d003140 <strerror+0x258>
 d0034d8:	00834174 	movhi	r2,3333
 d0034dc:	10af0804 	addi	r2,r2,-17376
 d0034e0:	003f1706 	br	d003140 <strerror+0x258>
 d0034e4:	00834174 	movhi	r2,3333
 d0034e8:	10af7a04 	addi	r2,r2,-16920
 d0034ec:	003f1406 	br	d003140 <strerror+0x258>
 d0034f0:	00834174 	movhi	r2,3333
 d0034f4:	10afb304 	addi	r2,r2,-16692
 d0034f8:	003f1106 	br	d003140 <strerror+0x258>
 d0034fc:	00834174 	movhi	r2,3333
 d003500:	10af7e04 	addi	r2,r2,-16904
 d003504:	003f0e06 	br	d003140 <strerror+0x258>
 d003508:	00834174 	movhi	r2,3333
 d00350c:	10af3604 	addi	r2,r2,-17192
 d003510:	003f0b06 	br	d003140 <strerror+0x258>
 d003514:	00834174 	movhi	r2,3333
 d003518:	10af4404 	addi	r2,r2,-17136
 d00351c:	003f0806 	br	d003140 <strerror+0x258>
 d003520:	00834174 	movhi	r2,3333
 d003524:	10af0304 	addi	r2,r2,-17396
 d003528:	003f0506 	br	d003140 <strerror+0x258>
 d00352c:	00834174 	movhi	r2,3333
 d003530:	10b02904 	addi	r2,r2,-16220
 d003534:	003f0206 	br	d003140 <strerror+0x258>
 d003538:	00834174 	movhi	r2,3333
 d00353c:	10b0d504 	addi	r2,r2,-15532
 d003540:	003eff06 	br	d003140 <strerror+0x258>
 d003544:	00834174 	movhi	r2,3333
 d003548:	10b0dc04 	addi	r2,r2,-15504
 d00354c:	003efc06 	br	d003140 <strerror+0x258>
 d003550:	00834174 	movhi	r2,3333
 d003554:	10b0cf04 	addi	r2,r2,-15556
 d003558:	003ef906 	br	d003140 <strerror+0x258>

0d00355c <strlen>:
 d00355c:	208000cc 	andi	r2,r4,3
 d003560:	2011883a 	mov	r8,r4
 d003564:	1000161e 	bne	r2,zero,d0035c0 <strlen+0x64>
 d003568:	20c00017 	ldw	r3,0(r4)
 d00356c:	017fbff4 	movhi	r5,65279
 d003570:	297fbfc4 	addi	r5,r5,-257
 d003574:	01e02074 	movhi	r7,32897
 d003578:	39e02004 	addi	r7,r7,-32640
 d00357c:	1945883a 	add	r2,r3,r5
 d003580:	11c4703a 	and	r2,r2,r7
 d003584:	00c6303a 	nor	r3,zero,r3
 d003588:	1886703a 	and	r3,r3,r2
 d00358c:	18000c1e 	bne	r3,zero,d0035c0 <strlen+0x64>
 d003590:	280d883a 	mov	r6,r5
 d003594:	380b883a 	mov	r5,r7
 d003598:	21000104 	addi	r4,r4,4
 d00359c:	20800017 	ldw	r2,0(r4)
 d0035a0:	1187883a 	add	r3,r2,r6
 d0035a4:	1946703a 	and	r3,r3,r5
 d0035a8:	0084303a 	nor	r2,zero,r2
 d0035ac:	10c4703a 	and	r2,r2,r3
 d0035b0:	103ff926 	beq	r2,zero,d003598 <strlen+0x3c>
 d0035b4:	20800007 	ldb	r2,0(r4)
 d0035b8:	10000326 	beq	r2,zero,d0035c8 <strlen+0x6c>
 d0035bc:	21000044 	addi	r4,r4,1
 d0035c0:	20800007 	ldb	r2,0(r4)
 d0035c4:	103ffd1e 	bne	r2,zero,d0035bc <strlen+0x60>
 d0035c8:	2205c83a 	sub	r2,r4,r8
 d0035cc:	f800283a 	ret

0d0035d0 <_user_strerror>:
 d0035d0:	0005883a 	mov	r2,zero
 d0035d4:	f800283a 	ret

0d0035d8 <__sprint_r>:
 d0035d8:	30800217 	ldw	r2,8(r6)
 d0035dc:	defffe04 	addi	sp,sp,-8
 d0035e0:	dc000015 	stw	r16,0(sp)
 d0035e4:	dfc00115 	stw	ra,4(sp)
 d0035e8:	3021883a 	mov	r16,r6
 d0035ec:	0007883a 	mov	r3,zero
 d0035f0:	1000061e 	bne	r2,zero,d00360c <__sprint_r+0x34>
 d0035f4:	1805883a 	mov	r2,r3
 d0035f8:	30000115 	stw	zero,4(r6)
 d0035fc:	dfc00117 	ldw	ra,4(sp)
 d003600:	dc000017 	ldw	r16,0(sp)
 d003604:	dec00204 	addi	sp,sp,8
 d003608:	f800283a 	ret
 d00360c:	d0079d00 	call	d0079d0 <__sfvwrite_r>
 d003610:	1007883a 	mov	r3,r2
 d003614:	1805883a 	mov	r2,r3
 d003618:	80000115 	stw	zero,4(r16)
 d00361c:	80000215 	stw	zero,8(r16)
 d003620:	dfc00117 	ldw	ra,4(sp)
 d003624:	dc000017 	ldw	r16,0(sp)
 d003628:	dec00204 	addi	sp,sp,8
 d00362c:	f800283a 	ret

0d003630 <___vfprintf_internal_r>:
 d003630:	defea404 	addi	sp,sp,-1392
 d003634:	dd815815 	stw	r22,1376(sp)
 d003638:	dc015215 	stw	r16,1352(sp)
 d00363c:	d9c15115 	stw	r7,1348(sp)
 d003640:	dfc15b15 	stw	ra,1388(sp)
 d003644:	df015a15 	stw	fp,1384(sp)
 d003648:	ddc15915 	stw	r23,1380(sp)
 d00364c:	dd415715 	stw	r21,1372(sp)
 d003650:	dd015615 	stw	r20,1368(sp)
 d003654:	dcc15515 	stw	r19,1364(sp)
 d003658:	dc815415 	stw	r18,1360(sp)
 d00365c:	dc415315 	stw	r17,1356(sp)
 d003660:	282d883a 	mov	r22,r5
 d003664:	3021883a 	mov	r16,r6
 d003668:	d9014f15 	stw	r4,1340(sp)
 d00366c:	d007ff40 	call	d007ff4 <_localeconv_r>
 d003670:	10800017 	ldw	r2,0(r2)
 d003674:	d9c15117 	ldw	r7,1348(sp)
 d003678:	d8814915 	stw	r2,1316(sp)
 d00367c:	d8814f17 	ldw	r2,1340(sp)
 d003680:	10000226 	beq	r2,zero,d00368c <___vfprintf_internal_r+0x5c>
 d003684:	10800e17 	ldw	r2,56(r2)
 d003688:	10020d26 	beq	r2,zero,d003ec0 <___vfprintf_internal_r+0x890>
 d00368c:	b080030b 	ldhu	r2,12(r22)
 d003690:	1080020c 	andi	r2,r2,8
 d003694:	10020e26 	beq	r2,zero,d003ed0 <___vfprintf_internal_r+0x8a0>
 d003698:	b0800417 	ldw	r2,16(r22)
 d00369c:	10020c26 	beq	r2,zero,d003ed0 <___vfprintf_internal_r+0x8a0>
 d0036a0:	b200030b 	ldhu	r8,12(r22)
 d0036a4:	00800284 	movi	r2,10
 d0036a8:	40c0068c 	andi	r3,r8,26
 d0036ac:	18802f1e 	bne	r3,r2,d00376c <___vfprintf_internal_r+0x13c>
 d0036b0:	b080038f 	ldh	r2,14(r22)
 d0036b4:	10002d16 	blt	r2,zero,d00376c <___vfprintf_internal_r+0x13c>
 d0036b8:	b240038b 	ldhu	r9,14(r22)
 d0036bc:	b2800717 	ldw	r10,28(r22)
 d0036c0:	b2c00917 	ldw	r11,36(r22)
 d0036c4:	d9014f17 	ldw	r4,1340(sp)
 d0036c8:	dc402904 	addi	r17,sp,164
 d0036cc:	d8804004 	addi	r2,sp,256
 d0036d0:	00c10004 	movi	r3,1024
 d0036d4:	423fff4c 	andi	r8,r8,65533
 d0036d8:	800d883a 	mov	r6,r16
 d0036dc:	880b883a 	mov	r5,r17
 d0036e0:	da002c0d 	sth	r8,176(sp)
 d0036e4:	da402c8d 	sth	r9,178(sp)
 d0036e8:	da803015 	stw	r10,192(sp)
 d0036ec:	dac03215 	stw	r11,200(sp)
 d0036f0:	d8802d15 	stw	r2,180(sp)
 d0036f4:	d8c02e15 	stw	r3,184(sp)
 d0036f8:	d8802915 	stw	r2,164(sp)
 d0036fc:	d8c02b15 	stw	r3,172(sp)
 d003700:	d8002f15 	stw	zero,188(sp)
 d003704:	d0036300 	call	d003630 <___vfprintf_internal_r>
 d003708:	d8814b15 	stw	r2,1324(sp)
 d00370c:	10000416 	blt	r2,zero,d003720 <___vfprintf_internal_r+0xf0>
 d003710:	d9014f17 	ldw	r4,1340(sp)
 d003714:	880b883a 	mov	r5,r17
 d003718:	d006f540 	call	d006f54 <_fflush_r>
 d00371c:	1002321e 	bne	r2,zero,d003fe8 <___vfprintf_internal_r+0x9b8>
 d003720:	d8802c0b 	ldhu	r2,176(sp)
 d003724:	1080100c 	andi	r2,r2,64
 d003728:	10000326 	beq	r2,zero,d003738 <___vfprintf_internal_r+0x108>
 d00372c:	b080030b 	ldhu	r2,12(r22)
 d003730:	10801014 	ori	r2,r2,64
 d003734:	b080030d 	sth	r2,12(r22)
 d003738:	d8814b17 	ldw	r2,1324(sp)
 d00373c:	dfc15b17 	ldw	ra,1388(sp)
 d003740:	df015a17 	ldw	fp,1384(sp)
 d003744:	ddc15917 	ldw	r23,1380(sp)
 d003748:	dd815817 	ldw	r22,1376(sp)
 d00374c:	dd415717 	ldw	r21,1372(sp)
 d003750:	dd015617 	ldw	r20,1368(sp)
 d003754:	dcc15517 	ldw	r19,1364(sp)
 d003758:	dc815417 	ldw	r18,1360(sp)
 d00375c:	dc415317 	ldw	r17,1356(sp)
 d003760:	dc015217 	ldw	r16,1352(sp)
 d003764:	dec15c04 	addi	sp,sp,1392
 d003768:	f800283a 	ret
 d00376c:	0005883a 	mov	r2,zero
 d003770:	0007883a 	mov	r3,zero
 d003774:	dd401904 	addi	r21,sp,100
 d003778:	d8814215 	stw	r2,1288(sp)
 d00377c:	802f883a 	mov	r23,r16
 d003780:	d8c14315 	stw	r3,1292(sp)
 d003784:	d8014b15 	stw	zero,1324(sp)
 d003788:	d8014815 	stw	zero,1312(sp)
 d00378c:	d8014415 	stw	zero,1296(sp)
 d003790:	d8014715 	stw	zero,1308(sp)
 d003794:	dd400c15 	stw	r21,48(sp)
 d003798:	d8000e15 	stw	zero,56(sp)
 d00379c:	d8000d15 	stw	zero,52(sp)
 d0037a0:	b8800007 	ldb	r2,0(r23)
 d0037a4:	10001926 	beq	r2,zero,d00380c <___vfprintf_internal_r+0x1dc>
 d0037a8:	00c00944 	movi	r3,37
 d0037ac:	10c01726 	beq	r2,r3,d00380c <___vfprintf_internal_r+0x1dc>
 d0037b0:	b821883a 	mov	r16,r23
 d0037b4:	00000106 	br	d0037bc <___vfprintf_internal_r+0x18c>
 d0037b8:	10c00326 	beq	r2,r3,d0037c8 <___vfprintf_internal_r+0x198>
 d0037bc:	84000044 	addi	r16,r16,1
 d0037c0:	80800007 	ldb	r2,0(r16)
 d0037c4:	103ffc1e 	bne	r2,zero,d0037b8 <___vfprintf_internal_r+0x188>
 d0037c8:	85e7c83a 	sub	r19,r16,r23
 d0037cc:	98000e26 	beq	r19,zero,d003808 <___vfprintf_internal_r+0x1d8>
 d0037d0:	dc800e17 	ldw	r18,56(sp)
 d0037d4:	dc400d17 	ldw	r17,52(sp)
 d0037d8:	008001c4 	movi	r2,7
 d0037dc:	94e5883a 	add	r18,r18,r19
 d0037e0:	8c400044 	addi	r17,r17,1
 d0037e4:	adc00015 	stw	r23,0(r21)
 d0037e8:	dc800e15 	stw	r18,56(sp)
 d0037ec:	acc00115 	stw	r19,4(r21)
 d0037f0:	dc400d15 	stw	r17,52(sp)
 d0037f4:	14428b16 	blt	r2,r17,d004224 <___vfprintf_internal_r+0xbf4>
 d0037f8:	ad400204 	addi	r21,r21,8
 d0037fc:	d9014b17 	ldw	r4,1324(sp)
 d003800:	24c9883a 	add	r4,r4,r19
 d003804:	d9014b15 	stw	r4,1324(sp)
 d003808:	802f883a 	mov	r23,r16
 d00380c:	b8800007 	ldb	r2,0(r23)
 d003810:	10013c26 	beq	r2,zero,d003d04 <___vfprintf_internal_r+0x6d4>
 d003814:	bdc00044 	addi	r23,r23,1
 d003818:	d8000405 	stb	zero,16(sp)
 d00381c:	b8c00007 	ldb	r3,0(r23)
 d003820:	04ffffc4 	movi	r19,-1
 d003824:	d8014c15 	stw	zero,1328(sp)
 d003828:	d8014a15 	stw	zero,1320(sp)
 d00382c:	d8c14d15 	stw	r3,1332(sp)
 d003830:	bdc00044 	addi	r23,r23,1
 d003834:	d9414d17 	ldw	r5,1332(sp)
 d003838:	00801604 	movi	r2,88
 d00383c:	28fff804 	addi	r3,r5,-32
 d003840:	10c06036 	bltu	r2,r3,d0039c4 <___vfprintf_internal_r+0x394>
 d003844:	18c5883a 	add	r2,r3,r3
 d003848:	1085883a 	add	r2,r2,r2
 d00384c:	00c34034 	movhi	r3,3328
 d003850:	18ce1804 	addi	r3,r3,14432
 d003854:	10c5883a 	add	r2,r2,r3
 d003858:	11000017 	ldw	r4,0(r2)
 d00385c:	2000683a 	jmp	r4
 d003860:	0d0047d4 	ori	r20,at,287
 d003864:	0d0039c4 	addi	r20,at,231
 d003868:	0d0039c4 	addi	r20,at,231
 d00386c:	0d0047c0 	call	d0047c <OSCtxSw_SWITCH_PC+0xd0043c>
 d003870:	0d0039c4 	addi	r20,at,231
 d003874:	0d0039c4 	addi	r20,at,231
 d003878:	0d0039c4 	addi	r20,at,231
 d00387c:	0d0039c4 	addi	r20,at,231
 d003880:	0d0039c4 	addi	r20,at,231
 d003884:	0d0039c4 	addi	r20,at,231
 d003888:	0d0045a0 	cmpeqi	r20,at,278
 d00388c:	0d0047b0 	cmpltui	r20,at,286
 d003890:	0d0039c4 	addi	r20,at,231
 d003894:	0d0045b8 	rdprs	r20,at,278
 d003898:	0d00484c 	andi	r20,at,289
 d00389c:	0d0039c4 	addi	r20,at,231
 d0038a0:	0d004838 	rdprs	r20,at,288
 d0038a4:	0d004800 	call	d00480 <OSCtxSw_SWITCH_PC+0xd00440>
 d0038a8:	0d004800 	call	d00480 <OSCtxSw_SWITCH_PC+0xd00440>
 d0038ac:	0d004800 	call	d00480 <OSCtxSw_SWITCH_PC+0xd00440>
 d0038b0:	0d004800 	call	d00480 <OSCtxSw_SWITCH_PC+0xd00440>
 d0038b4:	0d004800 	call	d00480 <OSCtxSw_SWITCH_PC+0xd00440>
 d0038b8:	0d004800 	call	d00480 <OSCtxSw_SWITCH_PC+0xd00440>
 d0038bc:	0d004800 	call	d00480 <OSCtxSw_SWITCH_PC+0xd00440>
 d0038c0:	0d004800 	call	d00480 <OSCtxSw_SWITCH_PC+0xd00440>
 d0038c4:	0d004800 	call	d00480 <OSCtxSw_SWITCH_PC+0xd00440>
 d0038c8:	0d0039c4 	addi	r20,at,231
 d0038cc:	0d0039c4 	addi	r20,at,231
 d0038d0:	0d0039c4 	addi	r20,at,231
 d0038d4:	0d0039c4 	addi	r20,at,231
 d0038d8:	0d0039c4 	addi	r20,at,231
 d0038dc:	0d0039c4 	addi	r20,at,231
 d0038e0:	0d0039c4 	addi	r20,at,231
 d0038e4:	0d0039c4 	addi	r20,at,231
 d0038e8:	0d0039c4 	addi	r20,at,231
 d0038ec:	0d0039c4 	addi	r20,at,231
 d0038f0:	0d00401c 	xori	r20,at,256
 d0038f4:	0d004688 	cmpgei	r20,at,282
 d0038f8:	0d0039c4 	addi	r20,at,231
 d0038fc:	0d004688 	cmpgei	r20,at,282
 d003900:	0d0039c4 	addi	r20,at,231
 d003904:	0d0039c4 	addi	r20,at,231
 d003908:	0d0039c4 	addi	r20,at,231
 d00390c:	0d0039c4 	addi	r20,at,231
 d003910:	0d0047ec 	andhi	r20,at,287
 d003914:	0d0039c4 	addi	r20,at,231
 d003918:	0d0039c4 	addi	r20,at,231
 d00391c:	0d0040d0 	cmplti	r20,at,259
 d003920:	0d0039c4 	addi	r20,at,231
 d003924:	0d0039c4 	addi	r20,at,231
 d003928:	0d0039c4 	addi	r20,at,231
 d00392c:	0d0039c4 	addi	r20,at,231
 d003930:	0d0039c4 	addi	r20,at,231
 d003934:	0d00411c 	xori	r20,at,260
 d003938:	0d0039c4 	addi	r20,at,231
 d00393c:	0d0039c4 	addi	r20,at,231
 d003940:	0d00473c 	xorhi	r20,at,284
 d003944:	0d0039c4 	addi	r20,at,231
 d003948:	0d0039c4 	addi	r20,at,231
 d00394c:	0d0039c4 	addi	r20,at,231
 d003950:	0d0039c4 	addi	r20,at,231
 d003954:	0d0039c4 	addi	r20,at,231
 d003958:	0d0039c4 	addi	r20,at,231
 d00395c:	0d0039c4 	addi	r20,at,231
 d003960:	0d0039c4 	addi	r20,at,231
 d003964:	0d0039c4 	addi	r20,at,231
 d003968:	0d0039c4 	addi	r20,at,231
 d00396c:	0d004710 	cmplti	r20,at,284
 d003970:	0d004028 	cmpgeui	r20,at,256
 d003974:	0d004688 	cmpgei	r20,at,282
 d003978:	0d004688 	cmpgei	r20,at,282
 d00397c:	0d004688 	cmpgei	r20,at,282
 d003980:	0d004674 	orhi	r20,at,281
 d003984:	0d004028 	cmpgeui	r20,at,256
 d003988:	0d0039c4 	addi	r20,at,231
 d00398c:	0d0039c4 	addi	r20,at,231
 d003990:	0d0045fc 	xorhi	r20,at,279
 d003994:	0d0039c4 	addi	r20,at,231
 d003998:	0d0045cc 	andi	r20,at,279
 d00399c:	0d0040dc 	xori	r20,at,259
 d0039a0:	0d00462c 	andhi	r20,at,280
 d0039a4:	0d004618 	cmpnei	r20,at,280
 d0039a8:	0d0039c4 	addi	r20,at,231
 d0039ac:	0d0048a8 	cmpgeui	r20,at,290
 d0039b0:	0d0039c4 	addi	r20,at,231
 d0039b4:	0d004128 	cmpgeui	r20,at,260
 d0039b8:	0d0039c4 	addi	r20,at,231
 d0039bc:	0d0039c4 	addi	r20,at,231
 d0039c0:	0d0047a0 	cmpeqi	r20,at,286
 d0039c4:	d9014d17 	ldw	r4,1332(sp)
 d0039c8:	2000ce26 	beq	r4,zero,d003d04 <___vfprintf_internal_r+0x6d4>
 d0039cc:	01400044 	movi	r5,1
 d0039d0:	d9800f04 	addi	r6,sp,60
 d0039d4:	d9c14015 	stw	r7,1280(sp)
 d0039d8:	d9414515 	stw	r5,1300(sp)
 d0039dc:	d9814115 	stw	r6,1284(sp)
 d0039e0:	280f883a 	mov	r7,r5
 d0039e4:	d9000f05 	stb	r4,60(sp)
 d0039e8:	d8000405 	stb	zero,16(sp)
 d0039ec:	d8014615 	stw	zero,1304(sp)
 d0039f0:	d8c14c17 	ldw	r3,1328(sp)
 d0039f4:	1880008c 	andi	r2,r3,2
 d0039f8:	1005003a 	cmpeq	r2,r2,zero
 d0039fc:	d8815015 	stw	r2,1344(sp)
 d003a00:	1000031e 	bne	r2,zero,d003a10 <___vfprintf_internal_r+0x3e0>
 d003a04:	d9014517 	ldw	r4,1300(sp)
 d003a08:	21000084 	addi	r4,r4,2
 d003a0c:	d9014515 	stw	r4,1300(sp)
 d003a10:	d9414c17 	ldw	r5,1328(sp)
 d003a14:	2940210c 	andi	r5,r5,132
 d003a18:	d9414e15 	stw	r5,1336(sp)
 d003a1c:	28002d1e 	bne	r5,zero,d003ad4 <___vfprintf_internal_r+0x4a4>
 d003a20:	d9814a17 	ldw	r6,1320(sp)
 d003a24:	d8814517 	ldw	r2,1300(sp)
 d003a28:	30a1c83a 	sub	r16,r6,r2
 d003a2c:	0400290e 	bge	zero,r16,d003ad4 <___vfprintf_internal_r+0x4a4>
 d003a30:	00800404 	movi	r2,16
 d003a34:	1404580e 	bge	r2,r16,d004b98 <___vfprintf_internal_r+0x1568>
 d003a38:	dc800e17 	ldw	r18,56(sp)
 d003a3c:	dc400d17 	ldw	r17,52(sp)
 d003a40:	1027883a 	mov	r19,r2
 d003a44:	07034174 	movhi	fp,3333
 d003a48:	e7310784 	addi	fp,fp,-15330
 d003a4c:	050001c4 	movi	r20,7
 d003a50:	00000306 	br	d003a60 <___vfprintf_internal_r+0x430>
 d003a54:	843ffc04 	addi	r16,r16,-16
 d003a58:	ad400204 	addi	r21,r21,8
 d003a5c:	9c00130e 	bge	r19,r16,d003aac <___vfprintf_internal_r+0x47c>
 d003a60:	94800404 	addi	r18,r18,16
 d003a64:	8c400044 	addi	r17,r17,1
 d003a68:	af000015 	stw	fp,0(r21)
 d003a6c:	acc00115 	stw	r19,4(r21)
 d003a70:	dc800e15 	stw	r18,56(sp)
 d003a74:	dc400d15 	stw	r17,52(sp)
 d003a78:	a47ff60e 	bge	r20,r17,d003a54 <___vfprintf_internal_r+0x424>
 d003a7c:	d9014f17 	ldw	r4,1340(sp)
 d003a80:	b00b883a 	mov	r5,r22
 d003a84:	d9800c04 	addi	r6,sp,48
 d003a88:	d9c15115 	stw	r7,1348(sp)
 d003a8c:	d0035d80 	call	d0035d8 <__sprint_r>
 d003a90:	d9c15117 	ldw	r7,1348(sp)
 d003a94:	10009e1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d003a98:	843ffc04 	addi	r16,r16,-16
 d003a9c:	dc800e17 	ldw	r18,56(sp)
 d003aa0:	dc400d17 	ldw	r17,52(sp)
 d003aa4:	dd401904 	addi	r21,sp,100
 d003aa8:	9c3fed16 	blt	r19,r16,d003a60 <___vfprintf_internal_r+0x430>
 d003aac:	9425883a 	add	r18,r18,r16
 d003ab0:	8c400044 	addi	r17,r17,1
 d003ab4:	008001c4 	movi	r2,7
 d003ab8:	af000015 	stw	fp,0(r21)
 d003abc:	ac000115 	stw	r16,4(r21)
 d003ac0:	dc800e15 	stw	r18,56(sp)
 d003ac4:	dc400d15 	stw	r17,52(sp)
 d003ac8:	1441f516 	blt	r2,r17,d0042a0 <___vfprintf_internal_r+0xc70>
 d003acc:	ad400204 	addi	r21,r21,8
 d003ad0:	00000206 	br	d003adc <___vfprintf_internal_r+0x4ac>
 d003ad4:	dc800e17 	ldw	r18,56(sp)
 d003ad8:	dc400d17 	ldw	r17,52(sp)
 d003adc:	d8800407 	ldb	r2,16(sp)
 d003ae0:	10000b26 	beq	r2,zero,d003b10 <___vfprintf_internal_r+0x4e0>
 d003ae4:	00800044 	movi	r2,1
 d003ae8:	94800044 	addi	r18,r18,1
 d003aec:	8c400044 	addi	r17,r17,1
 d003af0:	a8800115 	stw	r2,4(r21)
 d003af4:	d8c00404 	addi	r3,sp,16
 d003af8:	008001c4 	movi	r2,7
 d003afc:	a8c00015 	stw	r3,0(r21)
 d003b00:	dc800e15 	stw	r18,56(sp)
 d003b04:	dc400d15 	stw	r17,52(sp)
 d003b08:	1441da16 	blt	r2,r17,d004274 <___vfprintf_internal_r+0xc44>
 d003b0c:	ad400204 	addi	r21,r21,8
 d003b10:	d9015017 	ldw	r4,1344(sp)
 d003b14:	20000b1e 	bne	r4,zero,d003b44 <___vfprintf_internal_r+0x514>
 d003b18:	d8800444 	addi	r2,sp,17
 d003b1c:	94800084 	addi	r18,r18,2
 d003b20:	8c400044 	addi	r17,r17,1
 d003b24:	a8800015 	stw	r2,0(r21)
 d003b28:	00c00084 	movi	r3,2
 d003b2c:	008001c4 	movi	r2,7
 d003b30:	a8c00115 	stw	r3,4(r21)
 d003b34:	dc800e15 	stw	r18,56(sp)
 d003b38:	dc400d15 	stw	r17,52(sp)
 d003b3c:	1441c216 	blt	r2,r17,d004248 <___vfprintf_internal_r+0xc18>
 d003b40:	ad400204 	addi	r21,r21,8
 d003b44:	d9414e17 	ldw	r5,1336(sp)
 d003b48:	00802004 	movi	r2,128
 d003b4c:	2880b126 	beq	r5,r2,d003e14 <___vfprintf_internal_r+0x7e4>
 d003b50:	d8c14617 	ldw	r3,1304(sp)
 d003b54:	19e1c83a 	sub	r16,r3,r7
 d003b58:	0400260e 	bge	zero,r16,d003bf4 <___vfprintf_internal_r+0x5c4>
 d003b5c:	00800404 	movi	r2,16
 d003b60:	1403c90e 	bge	r2,r16,d004a88 <___vfprintf_internal_r+0x1458>
 d003b64:	1027883a 	mov	r19,r2
 d003b68:	07034174 	movhi	fp,3333
 d003b6c:	e7310384 	addi	fp,fp,-15346
 d003b70:	050001c4 	movi	r20,7
 d003b74:	00000306 	br	d003b84 <___vfprintf_internal_r+0x554>
 d003b78:	843ffc04 	addi	r16,r16,-16
 d003b7c:	ad400204 	addi	r21,r21,8
 d003b80:	9c00130e 	bge	r19,r16,d003bd0 <___vfprintf_internal_r+0x5a0>
 d003b84:	94800404 	addi	r18,r18,16
 d003b88:	8c400044 	addi	r17,r17,1
 d003b8c:	af000015 	stw	fp,0(r21)
 d003b90:	acc00115 	stw	r19,4(r21)
 d003b94:	dc800e15 	stw	r18,56(sp)
 d003b98:	dc400d15 	stw	r17,52(sp)
 d003b9c:	a47ff60e 	bge	r20,r17,d003b78 <___vfprintf_internal_r+0x548>
 d003ba0:	d9014f17 	ldw	r4,1340(sp)
 d003ba4:	b00b883a 	mov	r5,r22
 d003ba8:	d9800c04 	addi	r6,sp,48
 d003bac:	d9c15115 	stw	r7,1348(sp)
 d003bb0:	d0035d80 	call	d0035d8 <__sprint_r>
 d003bb4:	d9c15117 	ldw	r7,1348(sp)
 d003bb8:	1000551e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d003bbc:	843ffc04 	addi	r16,r16,-16
 d003bc0:	dc800e17 	ldw	r18,56(sp)
 d003bc4:	dc400d17 	ldw	r17,52(sp)
 d003bc8:	dd401904 	addi	r21,sp,100
 d003bcc:	9c3fed16 	blt	r19,r16,d003b84 <___vfprintf_internal_r+0x554>
 d003bd0:	9425883a 	add	r18,r18,r16
 d003bd4:	8c400044 	addi	r17,r17,1
 d003bd8:	008001c4 	movi	r2,7
 d003bdc:	af000015 	stw	fp,0(r21)
 d003be0:	ac000115 	stw	r16,4(r21)
 d003be4:	dc800e15 	stw	r18,56(sp)
 d003be8:	dc400d15 	stw	r17,52(sp)
 d003bec:	14418216 	blt	r2,r17,d0041f8 <___vfprintf_internal_r+0xbc8>
 d003bf0:	ad400204 	addi	r21,r21,8
 d003bf4:	d9014c17 	ldw	r4,1328(sp)
 d003bf8:	2080400c 	andi	r2,r4,256
 d003bfc:	10004a1e 	bne	r2,zero,d003d28 <___vfprintf_internal_r+0x6f8>
 d003c00:	d9414117 	ldw	r5,1284(sp)
 d003c04:	91e5883a 	add	r18,r18,r7
 d003c08:	8c400044 	addi	r17,r17,1
 d003c0c:	008001c4 	movi	r2,7
 d003c10:	a9400015 	stw	r5,0(r21)
 d003c14:	a9c00115 	stw	r7,4(r21)
 d003c18:	dc800e15 	stw	r18,56(sp)
 d003c1c:	dc400d15 	stw	r17,52(sp)
 d003c20:	14416716 	blt	r2,r17,d0041c0 <___vfprintf_internal_r+0xb90>
 d003c24:	a8c00204 	addi	r3,r21,8
 d003c28:	d9814c17 	ldw	r6,1328(sp)
 d003c2c:	3080010c 	andi	r2,r6,4
 d003c30:	10002826 	beq	r2,zero,d003cd4 <___vfprintf_internal_r+0x6a4>
 d003c34:	d8814a17 	ldw	r2,1320(sp)
 d003c38:	d9014517 	ldw	r4,1300(sp)
 d003c3c:	1121c83a 	sub	r16,r2,r4
 d003c40:	0400240e 	bge	zero,r16,d003cd4 <___vfprintf_internal_r+0x6a4>
 d003c44:	00800404 	movi	r2,16
 d003c48:	14044f0e 	bge	r2,r16,d004d88 <___vfprintf_internal_r+0x1758>
 d003c4c:	dc400d17 	ldw	r17,52(sp)
 d003c50:	1027883a 	mov	r19,r2
 d003c54:	07034174 	movhi	fp,3333
 d003c58:	e7310784 	addi	fp,fp,-15330
 d003c5c:	050001c4 	movi	r20,7
 d003c60:	00000306 	br	d003c70 <___vfprintf_internal_r+0x640>
 d003c64:	843ffc04 	addi	r16,r16,-16
 d003c68:	18c00204 	addi	r3,r3,8
 d003c6c:	9c00110e 	bge	r19,r16,d003cb4 <___vfprintf_internal_r+0x684>
 d003c70:	94800404 	addi	r18,r18,16
 d003c74:	8c400044 	addi	r17,r17,1
 d003c78:	1f000015 	stw	fp,0(r3)
 d003c7c:	1cc00115 	stw	r19,4(r3)
 d003c80:	dc800e15 	stw	r18,56(sp)
 d003c84:	dc400d15 	stw	r17,52(sp)
 d003c88:	a47ff60e 	bge	r20,r17,d003c64 <___vfprintf_internal_r+0x634>
 d003c8c:	d9014f17 	ldw	r4,1340(sp)
 d003c90:	b00b883a 	mov	r5,r22
 d003c94:	d9800c04 	addi	r6,sp,48
 d003c98:	d0035d80 	call	d0035d8 <__sprint_r>
 d003c9c:	10001c1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d003ca0:	843ffc04 	addi	r16,r16,-16
 d003ca4:	dc800e17 	ldw	r18,56(sp)
 d003ca8:	dc400d17 	ldw	r17,52(sp)
 d003cac:	d8c01904 	addi	r3,sp,100
 d003cb0:	9c3fef16 	blt	r19,r16,d003c70 <___vfprintf_internal_r+0x640>
 d003cb4:	9425883a 	add	r18,r18,r16
 d003cb8:	8c400044 	addi	r17,r17,1
 d003cbc:	008001c4 	movi	r2,7
 d003cc0:	1f000015 	stw	fp,0(r3)
 d003cc4:	1c000115 	stw	r16,4(r3)
 d003cc8:	dc800e15 	stw	r18,56(sp)
 d003ccc:	dc400d15 	stw	r17,52(sp)
 d003cd0:	1440cb16 	blt	r2,r17,d004000 <___vfprintf_internal_r+0x9d0>
 d003cd4:	d8814a17 	ldw	r2,1320(sp)
 d003cd8:	d9414517 	ldw	r5,1300(sp)
 d003cdc:	1140010e 	bge	r2,r5,d003ce4 <___vfprintf_internal_r+0x6b4>
 d003ce0:	2805883a 	mov	r2,r5
 d003ce4:	d9814b17 	ldw	r6,1324(sp)
 d003ce8:	308d883a 	add	r6,r6,r2
 d003cec:	d9814b15 	stw	r6,1324(sp)
 d003cf0:	90013b1e 	bne	r18,zero,d0041e0 <___vfprintf_internal_r+0xbb0>
 d003cf4:	d9c14017 	ldw	r7,1280(sp)
 d003cf8:	dd401904 	addi	r21,sp,100
 d003cfc:	d8000d15 	stw	zero,52(sp)
 d003d00:	003ea706 	br	d0037a0 <___vfprintf_internal_r+0x170>
 d003d04:	d8800e17 	ldw	r2,56(sp)
 d003d08:	10053f1e 	bne	r2,zero,d005208 <___vfprintf_internal_r+0x1bd8>
 d003d0c:	d8000d15 	stw	zero,52(sp)
 d003d10:	b080030b 	ldhu	r2,12(r22)
 d003d14:	1080100c 	andi	r2,r2,64
 d003d18:	103e8726 	beq	r2,zero,d003738 <___vfprintf_internal_r+0x108>
 d003d1c:	00bfffc4 	movi	r2,-1
 d003d20:	d8814b15 	stw	r2,1324(sp)
 d003d24:	003e8406 	br	d003738 <___vfprintf_internal_r+0x108>
 d003d28:	d9814d17 	ldw	r6,1332(sp)
 d003d2c:	00801944 	movi	r2,101
 d003d30:	11806e16 	blt	r2,r6,d003eec <___vfprintf_internal_r+0x8bc>
 d003d34:	d9414717 	ldw	r5,1308(sp)
 d003d38:	00c00044 	movi	r3,1
 d003d3c:	1943430e 	bge	r3,r5,d004a4c <___vfprintf_internal_r+0x141c>
 d003d40:	d8814117 	ldw	r2,1284(sp)
 d003d44:	94800044 	addi	r18,r18,1
 d003d48:	8c400044 	addi	r17,r17,1
 d003d4c:	a8800015 	stw	r2,0(r21)
 d003d50:	008001c4 	movi	r2,7
 d003d54:	a8c00115 	stw	r3,4(r21)
 d003d58:	dc800e15 	stw	r18,56(sp)
 d003d5c:	dc400d15 	stw	r17,52(sp)
 d003d60:	1441ca16 	blt	r2,r17,d00448c <___vfprintf_internal_r+0xe5c>
 d003d64:	a8c00204 	addi	r3,r21,8
 d003d68:	d9014917 	ldw	r4,1316(sp)
 d003d6c:	00800044 	movi	r2,1
 d003d70:	94800044 	addi	r18,r18,1
 d003d74:	8c400044 	addi	r17,r17,1
 d003d78:	18800115 	stw	r2,4(r3)
 d003d7c:	008001c4 	movi	r2,7
 d003d80:	19000015 	stw	r4,0(r3)
 d003d84:	dc800e15 	stw	r18,56(sp)
 d003d88:	dc400d15 	stw	r17,52(sp)
 d003d8c:	1441b616 	blt	r2,r17,d004468 <___vfprintf_internal_r+0xe38>
 d003d90:	1cc00204 	addi	r19,r3,8
 d003d94:	d9014217 	ldw	r4,1288(sp)
 d003d98:	d9414317 	ldw	r5,1292(sp)
 d003d9c:	000d883a 	mov	r6,zero
 d003da0:	000f883a 	mov	r7,zero
 d003da4:	d00c0e00 	call	d00c0e0 <__nedf2>
 d003da8:	10017426 	beq	r2,zero,d00437c <___vfprintf_internal_r+0xd4c>
 d003dac:	d9414717 	ldw	r5,1308(sp)
 d003db0:	d9814117 	ldw	r6,1284(sp)
 d003db4:	8c400044 	addi	r17,r17,1
 d003db8:	2c85883a 	add	r2,r5,r18
 d003dbc:	14bfffc4 	addi	r18,r2,-1
 d003dc0:	28bfffc4 	addi	r2,r5,-1
 d003dc4:	30c00044 	addi	r3,r6,1
 d003dc8:	98800115 	stw	r2,4(r19)
 d003dcc:	008001c4 	movi	r2,7
 d003dd0:	98c00015 	stw	r3,0(r19)
 d003dd4:	dc800e15 	stw	r18,56(sp)
 d003dd8:	dc400d15 	stw	r17,52(sp)
 d003ddc:	14418e16 	blt	r2,r17,d004418 <___vfprintf_internal_r+0xde8>
 d003de0:	9cc00204 	addi	r19,r19,8
 d003de4:	d9414817 	ldw	r5,1312(sp)
 d003de8:	d8800804 	addi	r2,sp,32
 d003dec:	8c400044 	addi	r17,r17,1
 d003df0:	9165883a 	add	r18,r18,r5
 d003df4:	98800015 	stw	r2,0(r19)
 d003df8:	008001c4 	movi	r2,7
 d003dfc:	99400115 	stw	r5,4(r19)
 d003e00:	dc800e15 	stw	r18,56(sp)
 d003e04:	dc400d15 	stw	r17,52(sp)
 d003e08:	1440ed16 	blt	r2,r17,d0041c0 <___vfprintf_internal_r+0xb90>
 d003e0c:	98c00204 	addi	r3,r19,8
 d003e10:	003f8506 	br	d003c28 <___vfprintf_internal_r+0x5f8>
 d003e14:	d9814a17 	ldw	r6,1320(sp)
 d003e18:	d8814517 	ldw	r2,1300(sp)
 d003e1c:	30a1c83a 	sub	r16,r6,r2
 d003e20:	043f4b0e 	bge	zero,r16,d003b50 <___vfprintf_internal_r+0x520>
 d003e24:	00800404 	movi	r2,16
 d003e28:	1404340e 	bge	r2,r16,d004efc <___vfprintf_internal_r+0x18cc>
 d003e2c:	1027883a 	mov	r19,r2
 d003e30:	07034174 	movhi	fp,3333
 d003e34:	e7310384 	addi	fp,fp,-15346
 d003e38:	050001c4 	movi	r20,7
 d003e3c:	00000306 	br	d003e4c <___vfprintf_internal_r+0x81c>
 d003e40:	843ffc04 	addi	r16,r16,-16
 d003e44:	ad400204 	addi	r21,r21,8
 d003e48:	9c00130e 	bge	r19,r16,d003e98 <___vfprintf_internal_r+0x868>
 d003e4c:	94800404 	addi	r18,r18,16
 d003e50:	8c400044 	addi	r17,r17,1
 d003e54:	af000015 	stw	fp,0(r21)
 d003e58:	acc00115 	stw	r19,4(r21)
 d003e5c:	dc800e15 	stw	r18,56(sp)
 d003e60:	dc400d15 	stw	r17,52(sp)
 d003e64:	a47ff60e 	bge	r20,r17,d003e40 <___vfprintf_internal_r+0x810>
 d003e68:	d9014f17 	ldw	r4,1340(sp)
 d003e6c:	b00b883a 	mov	r5,r22
 d003e70:	d9800c04 	addi	r6,sp,48
 d003e74:	d9c15115 	stw	r7,1348(sp)
 d003e78:	d0035d80 	call	d0035d8 <__sprint_r>
 d003e7c:	d9c15117 	ldw	r7,1348(sp)
 d003e80:	103fa31e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d003e84:	843ffc04 	addi	r16,r16,-16
 d003e88:	dc800e17 	ldw	r18,56(sp)
 d003e8c:	dc400d17 	ldw	r17,52(sp)
 d003e90:	dd401904 	addi	r21,sp,100
 d003e94:	9c3fed16 	blt	r19,r16,d003e4c <___vfprintf_internal_r+0x81c>
 d003e98:	9425883a 	add	r18,r18,r16
 d003e9c:	8c400044 	addi	r17,r17,1
 d003ea0:	008001c4 	movi	r2,7
 d003ea4:	af000015 	stw	fp,0(r21)
 d003ea8:	ac000115 	stw	r16,4(r21)
 d003eac:	dc800e15 	stw	r18,56(sp)
 d003eb0:	dc400d15 	stw	r17,52(sp)
 d003eb4:	14416116 	blt	r2,r17,d00443c <___vfprintf_internal_r+0xe0c>
 d003eb8:	ad400204 	addi	r21,r21,8
 d003ebc:	003f2406 	br	d003b50 <___vfprintf_internal_r+0x520>
 d003ec0:	d9014f17 	ldw	r4,1340(sp)
 d003ec4:	d0071ec0 	call	d0071ec <__sinit>
 d003ec8:	d9c15117 	ldw	r7,1348(sp)
 d003ecc:	003def06 	br	d00368c <___vfprintf_internal_r+0x5c>
 d003ed0:	d9014f17 	ldw	r4,1340(sp)
 d003ed4:	b00b883a 	mov	r5,r22
 d003ed8:	d9c15115 	stw	r7,1348(sp)
 d003edc:	d00564c0 	call	d00564c <__swsetup_r>
 d003ee0:	d9c15117 	ldw	r7,1348(sp)
 d003ee4:	103dee26 	beq	r2,zero,d0036a0 <___vfprintf_internal_r+0x70>
 d003ee8:	003f8c06 	br	d003d1c <___vfprintf_internal_r+0x6ec>
 d003eec:	d9014217 	ldw	r4,1288(sp)
 d003ef0:	d9414317 	ldw	r5,1292(sp)
 d003ef4:	000d883a 	mov	r6,zero
 d003ef8:	000f883a 	mov	r7,zero
 d003efc:	d00c0580 	call	d00c058 <__eqdf2>
 d003f00:	1000f21e 	bne	r2,zero,d0042cc <___vfprintf_internal_r+0xc9c>
 d003f04:	00834174 	movhi	r2,3333
 d003f08:	10b10304 	addi	r2,r2,-15348
 d003f0c:	94800044 	addi	r18,r18,1
 d003f10:	8c400044 	addi	r17,r17,1
 d003f14:	a8800015 	stw	r2,0(r21)
 d003f18:	00c00044 	movi	r3,1
 d003f1c:	008001c4 	movi	r2,7
 d003f20:	a8c00115 	stw	r3,4(r21)
 d003f24:	dc800e15 	stw	r18,56(sp)
 d003f28:	dc400d15 	stw	r17,52(sp)
 d003f2c:	1442fa16 	blt	r2,r17,d004b18 <___vfprintf_internal_r+0x14e8>
 d003f30:	a8c00204 	addi	r3,r21,8
 d003f34:	d8800517 	ldw	r2,20(sp)
 d003f38:	d9014717 	ldw	r4,1308(sp)
 d003f3c:	11015c0e 	bge	r2,r4,d0044b0 <___vfprintf_internal_r+0xe80>
 d003f40:	dc400d17 	ldw	r17,52(sp)
 d003f44:	d9814917 	ldw	r6,1316(sp)
 d003f48:	00800044 	movi	r2,1
 d003f4c:	94800044 	addi	r18,r18,1
 d003f50:	8c400044 	addi	r17,r17,1
 d003f54:	18800115 	stw	r2,4(r3)
 d003f58:	008001c4 	movi	r2,7
 d003f5c:	19800015 	stw	r6,0(r3)
 d003f60:	dc800e15 	stw	r18,56(sp)
 d003f64:	dc400d15 	stw	r17,52(sp)
 d003f68:	14431016 	blt	r2,r17,d004bac <___vfprintf_internal_r+0x157c>
 d003f6c:	18c00204 	addi	r3,r3,8
 d003f70:	d8814717 	ldw	r2,1308(sp)
 d003f74:	143fffc4 	addi	r16,r2,-1
 d003f78:	043f2b0e 	bge	zero,r16,d003c28 <___vfprintf_internal_r+0x5f8>
 d003f7c:	00800404 	movi	r2,16
 d003f80:	1402a20e 	bge	r2,r16,d004a0c <___vfprintf_internal_r+0x13dc>
 d003f84:	dc400d17 	ldw	r17,52(sp)
 d003f88:	1027883a 	mov	r19,r2
 d003f8c:	07034174 	movhi	fp,3333
 d003f90:	e7310384 	addi	fp,fp,-15346
 d003f94:	050001c4 	movi	r20,7
 d003f98:	00000306 	br	d003fa8 <___vfprintf_internal_r+0x978>
 d003f9c:	18c00204 	addi	r3,r3,8
 d003fa0:	843ffc04 	addi	r16,r16,-16
 d003fa4:	9c029c0e 	bge	r19,r16,d004a18 <___vfprintf_internal_r+0x13e8>
 d003fa8:	94800404 	addi	r18,r18,16
 d003fac:	8c400044 	addi	r17,r17,1
 d003fb0:	1f000015 	stw	fp,0(r3)
 d003fb4:	1cc00115 	stw	r19,4(r3)
 d003fb8:	dc800e15 	stw	r18,56(sp)
 d003fbc:	dc400d15 	stw	r17,52(sp)
 d003fc0:	a47ff60e 	bge	r20,r17,d003f9c <___vfprintf_internal_r+0x96c>
 d003fc4:	d9014f17 	ldw	r4,1340(sp)
 d003fc8:	b00b883a 	mov	r5,r22
 d003fcc:	d9800c04 	addi	r6,sp,48
 d003fd0:	d0035d80 	call	d0035d8 <__sprint_r>
 d003fd4:	103f4e1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d003fd8:	dc800e17 	ldw	r18,56(sp)
 d003fdc:	dc400d17 	ldw	r17,52(sp)
 d003fe0:	d8c01904 	addi	r3,sp,100
 d003fe4:	003fee06 	br	d003fa0 <___vfprintf_internal_r+0x970>
 d003fe8:	d8802c0b 	ldhu	r2,176(sp)
 d003fec:	00ffffc4 	movi	r3,-1
 d003ff0:	d8c14b15 	stw	r3,1324(sp)
 d003ff4:	1080100c 	andi	r2,r2,64
 d003ff8:	103dcc1e 	bne	r2,zero,d00372c <___vfprintf_internal_r+0xfc>
 d003ffc:	003dce06 	br	d003738 <___vfprintf_internal_r+0x108>
 d004000:	d9014f17 	ldw	r4,1340(sp)
 d004004:	b00b883a 	mov	r5,r22
 d004008:	d9800c04 	addi	r6,sp,48
 d00400c:	d0035d80 	call	d0035d8 <__sprint_r>
 d004010:	103f3f1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004014:	dc800e17 	ldw	r18,56(sp)
 d004018:	003f2e06 	br	d003cd4 <___vfprintf_internal_r+0x6a4>
 d00401c:	d9414c17 	ldw	r5,1328(sp)
 d004020:	29400414 	ori	r5,r5,16
 d004024:	d9414c15 	stw	r5,1328(sp)
 d004028:	d9814c17 	ldw	r6,1328(sp)
 d00402c:	3080080c 	andi	r2,r6,32
 d004030:	10014f1e 	bne	r2,zero,d004570 <___vfprintf_internal_r+0xf40>
 d004034:	d8c14c17 	ldw	r3,1328(sp)
 d004038:	1880040c 	andi	r2,r3,16
 d00403c:	1002ea1e 	bne	r2,zero,d004be8 <___vfprintf_internal_r+0x15b8>
 d004040:	d9014c17 	ldw	r4,1328(sp)
 d004044:	2080100c 	andi	r2,r4,64
 d004048:	1002e726 	beq	r2,zero,d004be8 <___vfprintf_internal_r+0x15b8>
 d00404c:	3880000f 	ldh	r2,0(r7)
 d004050:	39c00104 	addi	r7,r7,4
 d004054:	d9c14015 	stw	r7,1280(sp)
 d004058:	1023d7fa 	srai	r17,r2,31
 d00405c:	1021883a 	mov	r16,r2
 d004060:	88037216 	blt	r17,zero,d004e2c <___vfprintf_internal_r+0x17fc>
 d004064:	01000044 	movi	r4,1
 d004068:	98000416 	blt	r19,zero,d00407c <___vfprintf_internal_r+0xa4c>
 d00406c:	d8c14c17 	ldw	r3,1328(sp)
 d004070:	00bfdfc4 	movi	r2,-129
 d004074:	1886703a 	and	r3,r3,r2
 d004078:	d8c14c15 	stw	r3,1328(sp)
 d00407c:	8444b03a 	or	r2,r16,r17
 d004080:	1002261e 	bne	r2,zero,d00491c <___vfprintf_internal_r+0x12ec>
 d004084:	9802251e 	bne	r19,zero,d00491c <___vfprintf_internal_r+0x12ec>
 d004088:	20803fcc 	andi	r2,r4,255
 d00408c:	10029b26 	beq	r2,zero,d004afc <___vfprintf_internal_r+0x14cc>
 d004090:	d8c01904 	addi	r3,sp,100
 d004094:	dd000f04 	addi	r20,sp,60
 d004098:	d8c14115 	stw	r3,1284(sp)
 d00409c:	d8c14117 	ldw	r3,1284(sp)
 d0040a0:	dcc14515 	stw	r19,1300(sp)
 d0040a4:	a0c5c83a 	sub	r2,r20,r3
 d0040a8:	11c00a04 	addi	r7,r2,40
 d0040ac:	99c0010e 	bge	r19,r7,d0040b4 <___vfprintf_internal_r+0xa84>
 d0040b0:	d9c14515 	stw	r7,1300(sp)
 d0040b4:	dcc14615 	stw	r19,1304(sp)
 d0040b8:	d8800407 	ldb	r2,16(sp)
 d0040bc:	103e4c26 	beq	r2,zero,d0039f0 <___vfprintf_internal_r+0x3c0>
 d0040c0:	d8814517 	ldw	r2,1300(sp)
 d0040c4:	10800044 	addi	r2,r2,1
 d0040c8:	d8814515 	stw	r2,1300(sp)
 d0040cc:	003e4806 	br	d0039f0 <___vfprintf_internal_r+0x3c0>
 d0040d0:	d9814c17 	ldw	r6,1328(sp)
 d0040d4:	31800414 	ori	r6,r6,16
 d0040d8:	d9814c15 	stw	r6,1328(sp)
 d0040dc:	d8c14c17 	ldw	r3,1328(sp)
 d0040e0:	1880080c 	andi	r2,r3,32
 d0040e4:	1001271e 	bne	r2,zero,d004584 <___vfprintf_internal_r+0xf54>
 d0040e8:	d9414c17 	ldw	r5,1328(sp)
 d0040ec:	2880040c 	andi	r2,r5,16
 d0040f0:	1002b61e 	bne	r2,zero,d004bcc <___vfprintf_internal_r+0x159c>
 d0040f4:	d9814c17 	ldw	r6,1328(sp)
 d0040f8:	3080100c 	andi	r2,r6,64
 d0040fc:	1002b326 	beq	r2,zero,d004bcc <___vfprintf_internal_r+0x159c>
 d004100:	3c00000b 	ldhu	r16,0(r7)
 d004104:	0009883a 	mov	r4,zero
 d004108:	39c00104 	addi	r7,r7,4
 d00410c:	0023883a 	mov	r17,zero
 d004110:	d9c14015 	stw	r7,1280(sp)
 d004114:	d8000405 	stb	zero,16(sp)
 d004118:	003fd306 	br	d004068 <___vfprintf_internal_r+0xa38>
 d00411c:	d9014c17 	ldw	r4,1328(sp)
 d004120:	21000414 	ori	r4,r4,16
 d004124:	d9014c15 	stw	r4,1328(sp)
 d004128:	d9414c17 	ldw	r5,1328(sp)
 d00412c:	2880080c 	andi	r2,r5,32
 d004130:	1001081e 	bne	r2,zero,d004554 <___vfprintf_internal_r+0xf24>
 d004134:	d8c14c17 	ldw	r3,1328(sp)
 d004138:	1880040c 	andi	r2,r3,16
 d00413c:	1002b01e 	bne	r2,zero,d004c00 <___vfprintf_internal_r+0x15d0>
 d004140:	d9014c17 	ldw	r4,1328(sp)
 d004144:	2080100c 	andi	r2,r4,64
 d004148:	1002ad26 	beq	r2,zero,d004c00 <___vfprintf_internal_r+0x15d0>
 d00414c:	3c00000b 	ldhu	r16,0(r7)
 d004150:	01000044 	movi	r4,1
 d004154:	39c00104 	addi	r7,r7,4
 d004158:	0023883a 	mov	r17,zero
 d00415c:	d9c14015 	stw	r7,1280(sp)
 d004160:	d8000405 	stb	zero,16(sp)
 d004164:	003fc006 	br	d004068 <___vfprintf_internal_r+0xa38>
 d004168:	d9014f17 	ldw	r4,1340(sp)
 d00416c:	b00b883a 	mov	r5,r22
 d004170:	d9800c04 	addi	r6,sp,48
 d004174:	d0035d80 	call	d0035d8 <__sprint_r>
 d004178:	103ee51e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d00417c:	dc800e17 	ldw	r18,56(sp)
 d004180:	d8c01904 	addi	r3,sp,100
 d004184:	d9814c17 	ldw	r6,1328(sp)
 d004188:	3080004c 	andi	r2,r6,1
 d00418c:	1005003a 	cmpeq	r2,r2,zero
 d004190:	103ea51e 	bne	r2,zero,d003c28 <___vfprintf_internal_r+0x5f8>
 d004194:	00800044 	movi	r2,1
 d004198:	dc400d17 	ldw	r17,52(sp)
 d00419c:	18800115 	stw	r2,4(r3)
 d0041a0:	d8814917 	ldw	r2,1316(sp)
 d0041a4:	94800044 	addi	r18,r18,1
 d0041a8:	8c400044 	addi	r17,r17,1
 d0041ac:	18800015 	stw	r2,0(r3)
 d0041b0:	008001c4 	movi	r2,7
 d0041b4:	dc800e15 	stw	r18,56(sp)
 d0041b8:	dc400d15 	stw	r17,52(sp)
 d0041bc:	14421e0e 	bge	r2,r17,d004a38 <___vfprintf_internal_r+0x1408>
 d0041c0:	d9014f17 	ldw	r4,1340(sp)
 d0041c4:	b00b883a 	mov	r5,r22
 d0041c8:	d9800c04 	addi	r6,sp,48
 d0041cc:	d0035d80 	call	d0035d8 <__sprint_r>
 d0041d0:	103ecf1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d0041d4:	dc800e17 	ldw	r18,56(sp)
 d0041d8:	d8c01904 	addi	r3,sp,100
 d0041dc:	003e9206 	br	d003c28 <___vfprintf_internal_r+0x5f8>
 d0041e0:	d9014f17 	ldw	r4,1340(sp)
 d0041e4:	b00b883a 	mov	r5,r22
 d0041e8:	d9800c04 	addi	r6,sp,48
 d0041ec:	d0035d80 	call	d0035d8 <__sprint_r>
 d0041f0:	103ec026 	beq	r2,zero,d003cf4 <___vfprintf_internal_r+0x6c4>
 d0041f4:	003ec606 	br	d003d10 <___vfprintf_internal_r+0x6e0>
 d0041f8:	d9014f17 	ldw	r4,1340(sp)
 d0041fc:	b00b883a 	mov	r5,r22
 d004200:	d9800c04 	addi	r6,sp,48
 d004204:	d9c15115 	stw	r7,1348(sp)
 d004208:	d0035d80 	call	d0035d8 <__sprint_r>
 d00420c:	d9c15117 	ldw	r7,1348(sp)
 d004210:	103ebf1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004214:	dc800e17 	ldw	r18,56(sp)
 d004218:	dc400d17 	ldw	r17,52(sp)
 d00421c:	dd401904 	addi	r21,sp,100
 d004220:	003e7406 	br	d003bf4 <___vfprintf_internal_r+0x5c4>
 d004224:	d9014f17 	ldw	r4,1340(sp)
 d004228:	b00b883a 	mov	r5,r22
 d00422c:	d9800c04 	addi	r6,sp,48
 d004230:	d9c15115 	stw	r7,1348(sp)
 d004234:	d0035d80 	call	d0035d8 <__sprint_r>
 d004238:	d9c15117 	ldw	r7,1348(sp)
 d00423c:	103eb41e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004240:	dd401904 	addi	r21,sp,100
 d004244:	003d6d06 	br	d0037fc <___vfprintf_internal_r+0x1cc>
 d004248:	d9014f17 	ldw	r4,1340(sp)
 d00424c:	b00b883a 	mov	r5,r22
 d004250:	d9800c04 	addi	r6,sp,48
 d004254:	d9c15115 	stw	r7,1348(sp)
 d004258:	d0035d80 	call	d0035d8 <__sprint_r>
 d00425c:	d9c15117 	ldw	r7,1348(sp)
 d004260:	103eab1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004264:	dc800e17 	ldw	r18,56(sp)
 d004268:	dc400d17 	ldw	r17,52(sp)
 d00426c:	dd401904 	addi	r21,sp,100
 d004270:	003e3406 	br	d003b44 <___vfprintf_internal_r+0x514>
 d004274:	d9014f17 	ldw	r4,1340(sp)
 d004278:	b00b883a 	mov	r5,r22
 d00427c:	d9800c04 	addi	r6,sp,48
 d004280:	d9c15115 	stw	r7,1348(sp)
 d004284:	d0035d80 	call	d0035d8 <__sprint_r>
 d004288:	d9c15117 	ldw	r7,1348(sp)
 d00428c:	103ea01e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004290:	dc800e17 	ldw	r18,56(sp)
 d004294:	dc400d17 	ldw	r17,52(sp)
 d004298:	dd401904 	addi	r21,sp,100
 d00429c:	003e1c06 	br	d003b10 <___vfprintf_internal_r+0x4e0>
 d0042a0:	d9014f17 	ldw	r4,1340(sp)
 d0042a4:	b00b883a 	mov	r5,r22
 d0042a8:	d9800c04 	addi	r6,sp,48
 d0042ac:	d9c15115 	stw	r7,1348(sp)
 d0042b0:	d0035d80 	call	d0035d8 <__sprint_r>
 d0042b4:	d9c15117 	ldw	r7,1348(sp)
 d0042b8:	103e951e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d0042bc:	dc800e17 	ldw	r18,56(sp)
 d0042c0:	dc400d17 	ldw	r17,52(sp)
 d0042c4:	dd401904 	addi	r21,sp,100
 d0042c8:	003e0406 	br	d003adc <___vfprintf_internal_r+0x4ac>
 d0042cc:	d9000517 	ldw	r4,20(sp)
 d0042d0:	0102520e 	bge	zero,r4,d004c1c <___vfprintf_internal_r+0x15ec>
 d0042d4:	d9814717 	ldw	r6,1308(sp)
 d0042d8:	21807a16 	blt	r4,r6,d0044c4 <___vfprintf_internal_r+0xe94>
 d0042dc:	d8814117 	ldw	r2,1284(sp)
 d0042e0:	91a5883a 	add	r18,r18,r6
 d0042e4:	8c400044 	addi	r17,r17,1
 d0042e8:	a8800015 	stw	r2,0(r21)
 d0042ec:	008001c4 	movi	r2,7
 d0042f0:	a9800115 	stw	r6,4(r21)
 d0042f4:	dc800e15 	stw	r18,56(sp)
 d0042f8:	dc400d15 	stw	r17,52(sp)
 d0042fc:	1442f616 	blt	r2,r17,d004ed8 <___vfprintf_internal_r+0x18a8>
 d004300:	a8c00204 	addi	r3,r21,8
 d004304:	d9414717 	ldw	r5,1308(sp)
 d004308:	2161c83a 	sub	r16,r4,r5
 d00430c:	043f9d0e 	bge	zero,r16,d004184 <___vfprintf_internal_r+0xb54>
 d004310:	00800404 	movi	r2,16
 d004314:	1402130e 	bge	r2,r16,d004b64 <___vfprintf_internal_r+0x1534>
 d004318:	dc400d17 	ldw	r17,52(sp)
 d00431c:	1027883a 	mov	r19,r2
 d004320:	07034174 	movhi	fp,3333
 d004324:	e7310384 	addi	fp,fp,-15346
 d004328:	050001c4 	movi	r20,7
 d00432c:	00000306 	br	d00433c <___vfprintf_internal_r+0xd0c>
 d004330:	18c00204 	addi	r3,r3,8
 d004334:	843ffc04 	addi	r16,r16,-16
 d004338:	9c020d0e 	bge	r19,r16,d004b70 <___vfprintf_internal_r+0x1540>
 d00433c:	94800404 	addi	r18,r18,16
 d004340:	8c400044 	addi	r17,r17,1
 d004344:	1f000015 	stw	fp,0(r3)
 d004348:	1cc00115 	stw	r19,4(r3)
 d00434c:	dc800e15 	stw	r18,56(sp)
 d004350:	dc400d15 	stw	r17,52(sp)
 d004354:	a47ff60e 	bge	r20,r17,d004330 <___vfprintf_internal_r+0xd00>
 d004358:	d9014f17 	ldw	r4,1340(sp)
 d00435c:	b00b883a 	mov	r5,r22
 d004360:	d9800c04 	addi	r6,sp,48
 d004364:	d0035d80 	call	d0035d8 <__sprint_r>
 d004368:	103e691e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d00436c:	dc800e17 	ldw	r18,56(sp)
 d004370:	dc400d17 	ldw	r17,52(sp)
 d004374:	d8c01904 	addi	r3,sp,100
 d004378:	003fee06 	br	d004334 <___vfprintf_internal_r+0xd04>
 d00437c:	d8814717 	ldw	r2,1308(sp)
 d004380:	143fffc4 	addi	r16,r2,-1
 d004384:	043e970e 	bge	zero,r16,d003de4 <___vfprintf_internal_r+0x7b4>
 d004388:	00800404 	movi	r2,16
 d00438c:	1400180e 	bge	r2,r16,d0043f0 <___vfprintf_internal_r+0xdc0>
 d004390:	1029883a 	mov	r20,r2
 d004394:	07034174 	movhi	fp,3333
 d004398:	e7310384 	addi	fp,fp,-15346
 d00439c:	054001c4 	movi	r21,7
 d0043a0:	00000306 	br	d0043b0 <___vfprintf_internal_r+0xd80>
 d0043a4:	9cc00204 	addi	r19,r19,8
 d0043a8:	843ffc04 	addi	r16,r16,-16
 d0043ac:	a400120e 	bge	r20,r16,d0043f8 <___vfprintf_internal_r+0xdc8>
 d0043b0:	94800404 	addi	r18,r18,16
 d0043b4:	8c400044 	addi	r17,r17,1
 d0043b8:	9f000015 	stw	fp,0(r19)
 d0043bc:	9d000115 	stw	r20,4(r19)
 d0043c0:	dc800e15 	stw	r18,56(sp)
 d0043c4:	dc400d15 	stw	r17,52(sp)
 d0043c8:	ac7ff60e 	bge	r21,r17,d0043a4 <___vfprintf_internal_r+0xd74>
 d0043cc:	d9014f17 	ldw	r4,1340(sp)
 d0043d0:	b00b883a 	mov	r5,r22
 d0043d4:	d9800c04 	addi	r6,sp,48
 d0043d8:	d0035d80 	call	d0035d8 <__sprint_r>
 d0043dc:	103e4c1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d0043e0:	dc800e17 	ldw	r18,56(sp)
 d0043e4:	dc400d17 	ldw	r17,52(sp)
 d0043e8:	dcc01904 	addi	r19,sp,100
 d0043ec:	003fee06 	br	d0043a8 <___vfprintf_internal_r+0xd78>
 d0043f0:	07034174 	movhi	fp,3333
 d0043f4:	e7310384 	addi	fp,fp,-15346
 d0043f8:	9425883a 	add	r18,r18,r16
 d0043fc:	8c400044 	addi	r17,r17,1
 d004400:	008001c4 	movi	r2,7
 d004404:	9f000015 	stw	fp,0(r19)
 d004408:	9c000115 	stw	r16,4(r19)
 d00440c:	dc800e15 	stw	r18,56(sp)
 d004410:	dc400d15 	stw	r17,52(sp)
 d004414:	147e720e 	bge	r2,r17,d003de0 <___vfprintf_internal_r+0x7b0>
 d004418:	d9014f17 	ldw	r4,1340(sp)
 d00441c:	b00b883a 	mov	r5,r22
 d004420:	d9800c04 	addi	r6,sp,48
 d004424:	d0035d80 	call	d0035d8 <__sprint_r>
 d004428:	103e391e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d00442c:	dc800e17 	ldw	r18,56(sp)
 d004430:	dc400d17 	ldw	r17,52(sp)
 d004434:	dcc01904 	addi	r19,sp,100
 d004438:	003e6a06 	br	d003de4 <___vfprintf_internal_r+0x7b4>
 d00443c:	d9014f17 	ldw	r4,1340(sp)
 d004440:	b00b883a 	mov	r5,r22
 d004444:	d9800c04 	addi	r6,sp,48
 d004448:	d9c15115 	stw	r7,1348(sp)
 d00444c:	d0035d80 	call	d0035d8 <__sprint_r>
 d004450:	d9c15117 	ldw	r7,1348(sp)
 d004454:	103e2e1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004458:	dc800e17 	ldw	r18,56(sp)
 d00445c:	dc400d17 	ldw	r17,52(sp)
 d004460:	dd401904 	addi	r21,sp,100
 d004464:	003dba06 	br	d003b50 <___vfprintf_internal_r+0x520>
 d004468:	d9014f17 	ldw	r4,1340(sp)
 d00446c:	b00b883a 	mov	r5,r22
 d004470:	d9800c04 	addi	r6,sp,48
 d004474:	d0035d80 	call	d0035d8 <__sprint_r>
 d004478:	103e251e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d00447c:	dc800e17 	ldw	r18,56(sp)
 d004480:	dc400d17 	ldw	r17,52(sp)
 d004484:	dcc01904 	addi	r19,sp,100
 d004488:	003e4206 	br	d003d94 <___vfprintf_internal_r+0x764>
 d00448c:	d9014f17 	ldw	r4,1340(sp)
 d004490:	b00b883a 	mov	r5,r22
 d004494:	d9800c04 	addi	r6,sp,48
 d004498:	d0035d80 	call	d0035d8 <__sprint_r>
 d00449c:	103e1c1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d0044a0:	dc800e17 	ldw	r18,56(sp)
 d0044a4:	dc400d17 	ldw	r17,52(sp)
 d0044a8:	d8c01904 	addi	r3,sp,100
 d0044ac:	003e2e06 	br	d003d68 <___vfprintf_internal_r+0x738>
 d0044b0:	d9414c17 	ldw	r5,1328(sp)
 d0044b4:	2880004c 	andi	r2,r5,1
 d0044b8:	1005003a 	cmpeq	r2,r2,zero
 d0044bc:	103dda1e 	bne	r2,zero,d003c28 <___vfprintf_internal_r+0x5f8>
 d0044c0:	003e9f06 	br	d003f40 <___vfprintf_internal_r+0x910>
 d0044c4:	d8c14117 	ldw	r3,1284(sp)
 d0044c8:	9125883a 	add	r18,r18,r4
 d0044cc:	8c400044 	addi	r17,r17,1
 d0044d0:	008001c4 	movi	r2,7
 d0044d4:	a8c00015 	stw	r3,0(r21)
 d0044d8:	a9000115 	stw	r4,4(r21)
 d0044dc:	dc800e15 	stw	r18,56(sp)
 d0044e0:	dc400d15 	stw	r17,52(sp)
 d0044e4:	14426616 	blt	r2,r17,d004e80 <___vfprintf_internal_r+0x1850>
 d0044e8:	a8c00204 	addi	r3,r21,8
 d0044ec:	d9414917 	ldw	r5,1316(sp)
 d0044f0:	00800044 	movi	r2,1
 d0044f4:	94800044 	addi	r18,r18,1
 d0044f8:	8c400044 	addi	r17,r17,1
 d0044fc:	18800115 	stw	r2,4(r3)
 d004500:	008001c4 	movi	r2,7
 d004504:	19400015 	stw	r5,0(r3)
 d004508:	dc800e15 	stw	r18,56(sp)
 d00450c:	dc400d15 	stw	r17,52(sp)
 d004510:	2021883a 	mov	r16,r4
 d004514:	14425016 	blt	r2,r17,d004e58 <___vfprintf_internal_r+0x1828>
 d004518:	19400204 	addi	r5,r3,8
 d00451c:	d9814717 	ldw	r6,1308(sp)
 d004520:	8c400044 	addi	r17,r17,1
 d004524:	dc400d15 	stw	r17,52(sp)
 d004528:	3107c83a 	sub	r3,r6,r4
 d00452c:	d9014117 	ldw	r4,1284(sp)
 d004530:	90e5883a 	add	r18,r18,r3
 d004534:	28c00115 	stw	r3,4(r5)
 d004538:	8105883a 	add	r2,r16,r4
 d00453c:	28800015 	stw	r2,0(r5)
 d004540:	008001c4 	movi	r2,7
 d004544:	dc800e15 	stw	r18,56(sp)
 d004548:	147f1d16 	blt	r2,r17,d0041c0 <___vfprintf_internal_r+0xb90>
 d00454c:	28c00204 	addi	r3,r5,8
 d004550:	003db506 	br	d003c28 <___vfprintf_internal_r+0x5f8>
 d004554:	3c000017 	ldw	r16,0(r7)
 d004558:	3c400117 	ldw	r17,4(r7)
 d00455c:	39800204 	addi	r6,r7,8
 d004560:	01000044 	movi	r4,1
 d004564:	d9814015 	stw	r6,1280(sp)
 d004568:	d8000405 	stb	zero,16(sp)
 d00456c:	003ebe06 	br	d004068 <___vfprintf_internal_r+0xa38>
 d004570:	3c000017 	ldw	r16,0(r7)
 d004574:	3c400117 	ldw	r17,4(r7)
 d004578:	38800204 	addi	r2,r7,8
 d00457c:	d8814015 	stw	r2,1280(sp)
 d004580:	003eb706 	br	d004060 <___vfprintf_internal_r+0xa30>
 d004584:	3c000017 	ldw	r16,0(r7)
 d004588:	3c400117 	ldw	r17,4(r7)
 d00458c:	39000204 	addi	r4,r7,8
 d004590:	d9014015 	stw	r4,1280(sp)
 d004594:	0009883a 	mov	r4,zero
 d004598:	d8000405 	stb	zero,16(sp)
 d00459c:	003eb206 	br	d004068 <___vfprintf_internal_r+0xa38>
 d0045a0:	38c00017 	ldw	r3,0(r7)
 d0045a4:	39c00104 	addi	r7,r7,4
 d0045a8:	d8c14a15 	stw	r3,1320(sp)
 d0045ac:	1800d10e 	bge	r3,zero,d0048f4 <___vfprintf_internal_r+0x12c4>
 d0045b0:	00c7c83a 	sub	r3,zero,r3
 d0045b4:	d8c14a15 	stw	r3,1320(sp)
 d0045b8:	d9014c17 	ldw	r4,1328(sp)
 d0045bc:	b8c00007 	ldb	r3,0(r23)
 d0045c0:	21000114 	ori	r4,r4,4
 d0045c4:	d9014c15 	stw	r4,1328(sp)
 d0045c8:	003c9806 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d0045cc:	d9814c17 	ldw	r6,1328(sp)
 d0045d0:	3080080c 	andi	r2,r6,32
 d0045d4:	1001f026 	beq	r2,zero,d004d98 <___vfprintf_internal_r+0x1768>
 d0045d8:	d9014b17 	ldw	r4,1324(sp)
 d0045dc:	38800017 	ldw	r2,0(r7)
 d0045e0:	39c00104 	addi	r7,r7,4
 d0045e4:	d9c14015 	stw	r7,1280(sp)
 d0045e8:	2007d7fa 	srai	r3,r4,31
 d0045ec:	d9c14017 	ldw	r7,1280(sp)
 d0045f0:	11000015 	stw	r4,0(r2)
 d0045f4:	10c00115 	stw	r3,4(r2)
 d0045f8:	003c6906 	br	d0037a0 <___vfprintf_internal_r+0x170>
 d0045fc:	b8c00007 	ldb	r3,0(r23)
 d004600:	00801b04 	movi	r2,108
 d004604:	18824f26 	beq	r3,r2,d004f44 <___vfprintf_internal_r+0x1914>
 d004608:	d9414c17 	ldw	r5,1328(sp)
 d00460c:	29400414 	ori	r5,r5,16
 d004610:	d9414c15 	stw	r5,1328(sp)
 d004614:	003c8506 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d004618:	d9814c17 	ldw	r6,1328(sp)
 d00461c:	b8c00007 	ldb	r3,0(r23)
 d004620:	31800814 	ori	r6,r6,32
 d004624:	d9814c15 	stw	r6,1328(sp)
 d004628:	003c8006 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d00462c:	d8814c17 	ldw	r2,1328(sp)
 d004630:	3c000017 	ldw	r16,0(r7)
 d004634:	00c01e04 	movi	r3,120
 d004638:	10800094 	ori	r2,r2,2
 d00463c:	d8814c15 	stw	r2,1328(sp)
 d004640:	39c00104 	addi	r7,r7,4
 d004644:	01434174 	movhi	r5,3333
 d004648:	2970ec04 	addi	r5,r5,-15440
 d00464c:	00800c04 	movi	r2,48
 d004650:	0023883a 	mov	r17,zero
 d004654:	01000084 	movi	r4,2
 d004658:	d9c14015 	stw	r7,1280(sp)
 d00465c:	d8c14d15 	stw	r3,1332(sp)
 d004660:	d9414415 	stw	r5,1296(sp)
 d004664:	d8800445 	stb	r2,17(sp)
 d004668:	d8c00485 	stb	r3,18(sp)
 d00466c:	d8000405 	stb	zero,16(sp)
 d004670:	003e7d06 	br	d004068 <___vfprintf_internal_r+0xa38>
 d004674:	d8814c17 	ldw	r2,1328(sp)
 d004678:	b8c00007 	ldb	r3,0(r23)
 d00467c:	10801014 	ori	r2,r2,64
 d004680:	d8814c15 	stw	r2,1328(sp)
 d004684:	003c6906 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d004688:	d9414c17 	ldw	r5,1328(sp)
 d00468c:	2880020c 	andi	r2,r5,8
 d004690:	1001df26 	beq	r2,zero,d004e10 <___vfprintf_internal_r+0x17e0>
 d004694:	39800017 	ldw	r6,0(r7)
 d004698:	38800204 	addi	r2,r7,8
 d00469c:	d8814015 	stw	r2,1280(sp)
 d0046a0:	d9814215 	stw	r6,1288(sp)
 d0046a4:	39c00117 	ldw	r7,4(r7)
 d0046a8:	d9c14315 	stw	r7,1292(sp)
 d0046ac:	d9014217 	ldw	r4,1288(sp)
 d0046b0:	d9414317 	ldw	r5,1292(sp)
 d0046b4:	d00a2300 	call	d00a230 <__isinfd>
 d0046b8:	10021726 	beq	r2,zero,d004f18 <___vfprintf_internal_r+0x18e8>
 d0046bc:	d9014217 	ldw	r4,1288(sp)
 d0046c0:	d9414317 	ldw	r5,1292(sp)
 d0046c4:	000d883a 	mov	r6,zero
 d0046c8:	000f883a 	mov	r7,zero
 d0046cc:	d00c2780 	call	d00c278 <__ltdf2>
 d0046d0:	1002ca16 	blt	r2,zero,d0051fc <___vfprintf_internal_r+0x1bcc>
 d0046d4:	d9414d17 	ldw	r5,1332(sp)
 d0046d8:	008011c4 	movi	r2,71
 d0046dc:	11420a16 	blt	r2,r5,d004f08 <___vfprintf_internal_r+0x18d8>
 d0046e0:	01834174 	movhi	r6,3333
 d0046e4:	31b0f104 	addi	r6,r6,-15420
 d0046e8:	d9814115 	stw	r6,1284(sp)
 d0046ec:	d9014c17 	ldw	r4,1328(sp)
 d0046f0:	00c000c4 	movi	r3,3
 d0046f4:	00bfdfc4 	movi	r2,-129
 d0046f8:	2088703a 	and	r4,r4,r2
 d0046fc:	180f883a 	mov	r7,r3
 d004700:	d8c14515 	stw	r3,1300(sp)
 d004704:	d9014c15 	stw	r4,1328(sp)
 d004708:	d8014615 	stw	zero,1304(sp)
 d00470c:	003e6a06 	br	d0040b8 <___vfprintf_internal_r+0xa88>
 d004710:	38800017 	ldw	r2,0(r7)
 d004714:	00c00044 	movi	r3,1
 d004718:	39c00104 	addi	r7,r7,4
 d00471c:	d9c14015 	stw	r7,1280(sp)
 d004720:	d9000f04 	addi	r4,sp,60
 d004724:	180f883a 	mov	r7,r3
 d004728:	d8c14515 	stw	r3,1300(sp)
 d00472c:	d9014115 	stw	r4,1284(sp)
 d004730:	d8800f05 	stb	r2,60(sp)
 d004734:	d8000405 	stb	zero,16(sp)
 d004738:	003cac06 	br	d0039ec <___vfprintf_internal_r+0x3bc>
 d00473c:	01434174 	movhi	r5,3333
 d004740:	2970f704 	addi	r5,r5,-15396
 d004744:	d9414415 	stw	r5,1296(sp)
 d004748:	d9814c17 	ldw	r6,1328(sp)
 d00474c:	3080080c 	andi	r2,r6,32
 d004750:	1000f926 	beq	r2,zero,d004b38 <___vfprintf_internal_r+0x1508>
 d004754:	3c000017 	ldw	r16,0(r7)
 d004758:	3c400117 	ldw	r17,4(r7)
 d00475c:	38800204 	addi	r2,r7,8
 d004760:	d8814015 	stw	r2,1280(sp)
 d004764:	d9414c17 	ldw	r5,1328(sp)
 d004768:	2880004c 	andi	r2,r5,1
 d00476c:	1005003a 	cmpeq	r2,r2,zero
 d004770:	1000b31e 	bne	r2,zero,d004a40 <___vfprintf_internal_r+0x1410>
 d004774:	8444b03a 	or	r2,r16,r17
 d004778:	1000b126 	beq	r2,zero,d004a40 <___vfprintf_internal_r+0x1410>
 d00477c:	d9814d17 	ldw	r6,1332(sp)
 d004780:	29400094 	ori	r5,r5,2
 d004784:	00800c04 	movi	r2,48
 d004788:	01000084 	movi	r4,2
 d00478c:	d9414c15 	stw	r5,1328(sp)
 d004790:	d8800445 	stb	r2,17(sp)
 d004794:	d9800485 	stb	r6,18(sp)
 d004798:	d8000405 	stb	zero,16(sp)
 d00479c:	003e3206 	br	d004068 <___vfprintf_internal_r+0xa38>
 d0047a0:	01834174 	movhi	r6,3333
 d0047a4:	31b0ec04 	addi	r6,r6,-15440
 d0047a8:	d9814415 	stw	r6,1296(sp)
 d0047ac:	003fe606 	br	d004748 <___vfprintf_internal_r+0x1118>
 d0047b0:	00800ac4 	movi	r2,43
 d0047b4:	d8800405 	stb	r2,16(sp)
 d0047b8:	b8c00007 	ldb	r3,0(r23)
 d0047bc:	003c1b06 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d0047c0:	d8814c17 	ldw	r2,1328(sp)
 d0047c4:	b8c00007 	ldb	r3,0(r23)
 d0047c8:	10800054 	ori	r2,r2,1
 d0047cc:	d8814c15 	stw	r2,1328(sp)
 d0047d0:	003c1606 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d0047d4:	d8800407 	ldb	r2,16(sp)
 d0047d8:	1000461e 	bne	r2,zero,d0048f4 <___vfprintf_internal_r+0x12c4>
 d0047dc:	00800804 	movi	r2,32
 d0047e0:	d8800405 	stb	r2,16(sp)
 d0047e4:	b8c00007 	ldb	r3,0(r23)
 d0047e8:	003c1006 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d0047ec:	d9814c17 	ldw	r6,1328(sp)
 d0047f0:	b8c00007 	ldb	r3,0(r23)
 d0047f4:	31800214 	ori	r6,r6,8
 d0047f8:	d9814c15 	stw	r6,1328(sp)
 d0047fc:	003c0b06 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d004800:	0007883a 	mov	r3,zero
 d004804:	01000244 	movi	r4,9
 d004808:	188002a4 	muli	r2,r3,10
 d00480c:	b8c00007 	ldb	r3,0(r23)
 d004810:	d9814d17 	ldw	r6,1332(sp)
 d004814:	bdc00044 	addi	r23,r23,1
 d004818:	d8c14d15 	stw	r3,1332(sp)
 d00481c:	d9414d17 	ldw	r5,1332(sp)
 d004820:	3085883a 	add	r2,r6,r2
 d004824:	10fff404 	addi	r3,r2,-48
 d004828:	28bff404 	addi	r2,r5,-48
 d00482c:	20bff62e 	bgeu	r4,r2,d004808 <___vfprintf_internal_r+0x11d8>
 d004830:	d8c14a15 	stw	r3,1320(sp)
 d004834:	003bff06 	br	d003834 <___vfprintf_internal_r+0x204>
 d004838:	d9414c17 	ldw	r5,1328(sp)
 d00483c:	b8c00007 	ldb	r3,0(r23)
 d004840:	29402014 	ori	r5,r5,128
 d004844:	d9414c15 	stw	r5,1328(sp)
 d004848:	003bf806 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d00484c:	b8c00007 	ldb	r3,0(r23)
 d004850:	00800a84 	movi	r2,42
 d004854:	bdc00044 	addi	r23,r23,1
 d004858:	18831526 	beq	r3,r2,d0054b0 <___vfprintf_internal_r+0x1e80>
 d00485c:	d8c14d15 	stw	r3,1332(sp)
 d004860:	18bff404 	addi	r2,r3,-48
 d004864:	00c00244 	movi	r3,9
 d004868:	18827836 	bltu	r3,r2,d00524c <___vfprintf_internal_r+0x1c1c>
 d00486c:	000d883a 	mov	r6,zero
 d004870:	308002a4 	muli	r2,r6,10
 d004874:	b9800007 	ldb	r6,0(r23)
 d004878:	d9414d17 	ldw	r5,1332(sp)
 d00487c:	bdc00044 	addi	r23,r23,1
 d004880:	d9814d15 	stw	r6,1332(sp)
 d004884:	d9014d17 	ldw	r4,1332(sp)
 d004888:	1145883a 	add	r2,r2,r5
 d00488c:	11bff404 	addi	r6,r2,-48
 d004890:	20bff404 	addi	r2,r4,-48
 d004894:	18bff62e 	bgeu	r3,r2,d004870 <___vfprintf_internal_r+0x1240>
 d004898:	3027883a 	mov	r19,r6
 d00489c:	303be50e 	bge	r6,zero,d003834 <___vfprintf_internal_r+0x204>
 d0048a0:	04ffffc4 	movi	r19,-1
 d0048a4:	003be306 	br	d003834 <___vfprintf_internal_r+0x204>
 d0048a8:	d8000405 	stb	zero,16(sp)
 d0048ac:	39800017 	ldw	r6,0(r7)
 d0048b0:	39c00104 	addi	r7,r7,4
 d0048b4:	d9c14015 	stw	r7,1280(sp)
 d0048b8:	d9814115 	stw	r6,1284(sp)
 d0048bc:	3001c926 	beq	r6,zero,d004fe4 <___vfprintf_internal_r+0x19b4>
 d0048c0:	98000e16 	blt	r19,zero,d0048fc <___vfprintf_internal_r+0x12cc>
 d0048c4:	d9014117 	ldw	r4,1284(sp)
 d0048c8:	000b883a 	mov	r5,zero
 d0048cc:	980d883a 	mov	r6,r19
 d0048d0:	d0089840 	call	d008984 <memchr>
 d0048d4:	10025926 	beq	r2,zero,d00523c <___vfprintf_internal_r+0x1c0c>
 d0048d8:	d8c14117 	ldw	r3,1284(sp)
 d0048dc:	10cfc83a 	sub	r7,r2,r3
 d0048e0:	99c19e16 	blt	r19,r7,d004f5c <___vfprintf_internal_r+0x192c>
 d0048e4:	d9c14515 	stw	r7,1300(sp)
 d0048e8:	38000916 	blt	r7,zero,d004910 <___vfprintf_internal_r+0x12e0>
 d0048ec:	d8014615 	stw	zero,1304(sp)
 d0048f0:	003df106 	br	d0040b8 <___vfprintf_internal_r+0xa88>
 d0048f4:	b8c00007 	ldb	r3,0(r23)
 d0048f8:	003bcc06 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d0048fc:	d9014117 	ldw	r4,1284(sp)
 d004900:	d00355c0 	call	d00355c <strlen>
 d004904:	d8814515 	stw	r2,1300(sp)
 d004908:	100f883a 	mov	r7,r2
 d00490c:	103ff70e 	bge	r2,zero,d0048ec <___vfprintf_internal_r+0x12bc>
 d004910:	d8014515 	stw	zero,1300(sp)
 d004914:	d8014615 	stw	zero,1304(sp)
 d004918:	003de706 	br	d0040b8 <___vfprintf_internal_r+0xa88>
 d00491c:	20c03fcc 	andi	r3,r4,255
 d004920:	00800044 	movi	r2,1
 d004924:	18802d26 	beq	r3,r2,d0049dc <___vfprintf_internal_r+0x13ac>
 d004928:	18800e36 	bltu	r3,r2,d004964 <___vfprintf_internal_r+0x1334>
 d00492c:	00800084 	movi	r2,2
 d004930:	1880fa26 	beq	r3,r2,d004d1c <___vfprintf_internal_r+0x16ec>
 d004934:	01034174 	movhi	r4,3333
 d004938:	2130fc04 	addi	r4,r4,-15376
 d00493c:	d00355c0 	call	d00355c <strlen>
 d004940:	100f883a 	mov	r7,r2
 d004944:	dcc14515 	stw	r19,1300(sp)
 d004948:	9880010e 	bge	r19,r2,d004950 <___vfprintf_internal_r+0x1320>
 d00494c:	d8814515 	stw	r2,1300(sp)
 d004950:	00834174 	movhi	r2,3333
 d004954:	10b0fc04 	addi	r2,r2,-15376
 d004958:	dcc14615 	stw	r19,1304(sp)
 d00495c:	d8814115 	stw	r2,1284(sp)
 d004960:	003dd506 	br	d0040b8 <___vfprintf_internal_r+0xa88>
 d004964:	d9401904 	addi	r5,sp,100
 d004968:	dd000f04 	addi	r20,sp,60
 d00496c:	d9414115 	stw	r5,1284(sp)
 d004970:	880a977a 	slli	r5,r17,29
 d004974:	d9814117 	ldw	r6,1284(sp)
 d004978:	8004d0fa 	srli	r2,r16,3
 d00497c:	8806d0fa 	srli	r3,r17,3
 d004980:	810001cc 	andi	r4,r16,7
 d004984:	2884b03a 	or	r2,r5,r2
 d004988:	31bfffc4 	addi	r6,r6,-1
 d00498c:	21000c04 	addi	r4,r4,48
 d004990:	d9814115 	stw	r6,1284(sp)
 d004994:	10cab03a 	or	r5,r2,r3
 d004998:	31000005 	stb	r4,0(r6)
 d00499c:	1021883a 	mov	r16,r2
 d0049a0:	1823883a 	mov	r17,r3
 d0049a4:	283ff21e 	bne	r5,zero,d004970 <___vfprintf_internal_r+0x1340>
 d0049a8:	d8c14c17 	ldw	r3,1328(sp)
 d0049ac:	1880004c 	andi	r2,r3,1
 d0049b0:	1005003a 	cmpeq	r2,r2,zero
 d0049b4:	103db91e 	bne	r2,zero,d00409c <___vfprintf_internal_r+0xa6c>
 d0049b8:	20803fcc 	andi	r2,r4,255
 d0049bc:	1080201c 	xori	r2,r2,128
 d0049c0:	10bfe004 	addi	r2,r2,-128
 d0049c4:	00c00c04 	movi	r3,48
 d0049c8:	10fdb426 	beq	r2,r3,d00409c <___vfprintf_internal_r+0xa6c>
 d0049cc:	31bfffc4 	addi	r6,r6,-1
 d0049d0:	d9814115 	stw	r6,1284(sp)
 d0049d4:	30c00005 	stb	r3,0(r6)
 d0049d8:	003db006 	br	d00409c <___vfprintf_internal_r+0xa6c>
 d0049dc:	88800068 	cmpgeui	r2,r17,1
 d0049e0:	10002c1e 	bne	r2,zero,d004a94 <___vfprintf_internal_r+0x1464>
 d0049e4:	8800021e 	bne	r17,zero,d0049f0 <___vfprintf_internal_r+0x13c0>
 d0049e8:	00800244 	movi	r2,9
 d0049ec:	14002936 	bltu	r2,r16,d004a94 <___vfprintf_internal_r+0x1464>
 d0049f0:	d90018c4 	addi	r4,sp,99
 d0049f4:	dd000f04 	addi	r20,sp,60
 d0049f8:	d9014115 	stw	r4,1284(sp)
 d0049fc:	d9014117 	ldw	r4,1284(sp)
 d004a00:	80800c04 	addi	r2,r16,48
 d004a04:	20800005 	stb	r2,0(r4)
 d004a08:	003da406 	br	d00409c <___vfprintf_internal_r+0xa6c>
 d004a0c:	dc400d17 	ldw	r17,52(sp)
 d004a10:	07034174 	movhi	fp,3333
 d004a14:	e7310384 	addi	fp,fp,-15346
 d004a18:	9425883a 	add	r18,r18,r16
 d004a1c:	8c400044 	addi	r17,r17,1
 d004a20:	008001c4 	movi	r2,7
 d004a24:	1f000015 	stw	fp,0(r3)
 d004a28:	1c000115 	stw	r16,4(r3)
 d004a2c:	dc800e15 	stw	r18,56(sp)
 d004a30:	dc400d15 	stw	r17,52(sp)
 d004a34:	147de216 	blt	r2,r17,d0041c0 <___vfprintf_internal_r+0xb90>
 d004a38:	18c00204 	addi	r3,r3,8
 d004a3c:	003c7a06 	br	d003c28 <___vfprintf_internal_r+0x5f8>
 d004a40:	01000084 	movi	r4,2
 d004a44:	d8000405 	stb	zero,16(sp)
 d004a48:	003d8706 	br	d004068 <___vfprintf_internal_r+0xa38>
 d004a4c:	d9814c17 	ldw	r6,1328(sp)
 d004a50:	30c4703a 	and	r2,r6,r3
 d004a54:	1005003a 	cmpeq	r2,r2,zero
 d004a58:	103cb926 	beq	r2,zero,d003d40 <___vfprintf_internal_r+0x710>
 d004a5c:	d9014117 	ldw	r4,1284(sp)
 d004a60:	94800044 	addi	r18,r18,1
 d004a64:	8c400044 	addi	r17,r17,1
 d004a68:	008001c4 	movi	r2,7
 d004a6c:	a9000015 	stw	r4,0(r21)
 d004a70:	a8c00115 	stw	r3,4(r21)
 d004a74:	dc800e15 	stw	r18,56(sp)
 d004a78:	dc400d15 	stw	r17,52(sp)
 d004a7c:	147e6616 	blt	r2,r17,d004418 <___vfprintf_internal_r+0xde8>
 d004a80:	acc00204 	addi	r19,r21,8
 d004a84:	003cd706 	br	d003de4 <___vfprintf_internal_r+0x7b4>
 d004a88:	07034174 	movhi	fp,3333
 d004a8c:	e7310384 	addi	fp,fp,-15346
 d004a90:	003c4f06 	br	d003bd0 <___vfprintf_internal_r+0x5a0>
 d004a94:	dd000f04 	addi	r20,sp,60
 d004a98:	dc801904 	addi	r18,sp,100
 d004a9c:	8009883a 	mov	r4,r16
 d004aa0:	880b883a 	mov	r5,r17
 d004aa4:	01800284 	movi	r6,10
 d004aa8:	000f883a 	mov	r7,zero
 d004aac:	d00af880 	call	d00af88 <__umoddi3>
 d004ab0:	12000c04 	addi	r8,r2,48
 d004ab4:	94bfffc4 	addi	r18,r18,-1
 d004ab8:	8009883a 	mov	r4,r16
 d004abc:	880b883a 	mov	r5,r17
 d004ac0:	01800284 	movi	r6,10
 d004ac4:	000f883a 	mov	r7,zero
 d004ac8:	92000005 	stb	r8,0(r18)
 d004acc:	d00a9ac0 	call	d00a9ac <__udivdi3>
 d004ad0:	1009883a 	mov	r4,r2
 d004ad4:	1021883a 	mov	r16,r2
 d004ad8:	18800068 	cmpgeui	r2,r3,1
 d004adc:	1823883a 	mov	r17,r3
 d004ae0:	103fee1e 	bne	r2,zero,d004a9c <___vfprintf_internal_r+0x146c>
 d004ae4:	1800021e 	bne	r3,zero,d004af0 <___vfprintf_internal_r+0x14c0>
 d004ae8:	00800244 	movi	r2,9
 d004aec:	113feb36 	bltu	r2,r4,d004a9c <___vfprintf_internal_r+0x146c>
 d004af0:	94bfffc4 	addi	r18,r18,-1
 d004af4:	dc814115 	stw	r18,1284(sp)
 d004af8:	003fc006 	br	d0049fc <___vfprintf_internal_r+0x13cc>
 d004afc:	d9014c17 	ldw	r4,1328(sp)
 d004b00:	2080004c 	andi	r2,r4,1
 d004b04:	10009a1e 	bne	r2,zero,d004d70 <___vfprintf_internal_r+0x1740>
 d004b08:	d9401904 	addi	r5,sp,100
 d004b0c:	dd000f04 	addi	r20,sp,60
 d004b10:	d9414115 	stw	r5,1284(sp)
 d004b14:	003d6106 	br	d00409c <___vfprintf_internal_r+0xa6c>
 d004b18:	d9014f17 	ldw	r4,1340(sp)
 d004b1c:	b00b883a 	mov	r5,r22
 d004b20:	d9800c04 	addi	r6,sp,48
 d004b24:	d0035d80 	call	d0035d8 <__sprint_r>
 d004b28:	103c791e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004b2c:	dc800e17 	ldw	r18,56(sp)
 d004b30:	d8c01904 	addi	r3,sp,100
 d004b34:	003cff06 	br	d003f34 <___vfprintf_internal_r+0x904>
 d004b38:	d8c14c17 	ldw	r3,1328(sp)
 d004b3c:	1880040c 	andi	r2,r3,16
 d004b40:	1000711e 	bne	r2,zero,d004d08 <___vfprintf_internal_r+0x16d8>
 d004b44:	d9014c17 	ldw	r4,1328(sp)
 d004b48:	2080100c 	andi	r2,r4,64
 d004b4c:	10006e26 	beq	r2,zero,d004d08 <___vfprintf_internal_r+0x16d8>
 d004b50:	3c00000b 	ldhu	r16,0(r7)
 d004b54:	0023883a 	mov	r17,zero
 d004b58:	39c00104 	addi	r7,r7,4
 d004b5c:	d9c14015 	stw	r7,1280(sp)
 d004b60:	003f0006 	br	d004764 <___vfprintf_internal_r+0x1134>
 d004b64:	dc400d17 	ldw	r17,52(sp)
 d004b68:	07034174 	movhi	fp,3333
 d004b6c:	e7310384 	addi	fp,fp,-15346
 d004b70:	9425883a 	add	r18,r18,r16
 d004b74:	8c400044 	addi	r17,r17,1
 d004b78:	008001c4 	movi	r2,7
 d004b7c:	1f000015 	stw	fp,0(r3)
 d004b80:	1c000115 	stw	r16,4(r3)
 d004b84:	dc800e15 	stw	r18,56(sp)
 d004b88:	dc400d15 	stw	r17,52(sp)
 d004b8c:	147d7616 	blt	r2,r17,d004168 <___vfprintf_internal_r+0xb38>
 d004b90:	18c00204 	addi	r3,r3,8
 d004b94:	003d7b06 	br	d004184 <___vfprintf_internal_r+0xb54>
 d004b98:	dc800e17 	ldw	r18,56(sp)
 d004b9c:	dc400d17 	ldw	r17,52(sp)
 d004ba0:	07034174 	movhi	fp,3333
 d004ba4:	e7310784 	addi	fp,fp,-15330
 d004ba8:	003bc006 	br	d003aac <___vfprintf_internal_r+0x47c>
 d004bac:	d9014f17 	ldw	r4,1340(sp)
 d004bb0:	b00b883a 	mov	r5,r22
 d004bb4:	d9800c04 	addi	r6,sp,48
 d004bb8:	d0035d80 	call	d0035d8 <__sprint_r>
 d004bbc:	103c541e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004bc0:	dc800e17 	ldw	r18,56(sp)
 d004bc4:	d8c01904 	addi	r3,sp,100
 d004bc8:	003ce906 	br	d003f70 <___vfprintf_internal_r+0x940>
 d004bcc:	3c000017 	ldw	r16,0(r7)
 d004bd0:	0009883a 	mov	r4,zero
 d004bd4:	39c00104 	addi	r7,r7,4
 d004bd8:	0023883a 	mov	r17,zero
 d004bdc:	d9c14015 	stw	r7,1280(sp)
 d004be0:	d8000405 	stb	zero,16(sp)
 d004be4:	003d2006 	br	d004068 <___vfprintf_internal_r+0xa38>
 d004be8:	38800017 	ldw	r2,0(r7)
 d004bec:	39c00104 	addi	r7,r7,4
 d004bf0:	d9c14015 	stw	r7,1280(sp)
 d004bf4:	1023d7fa 	srai	r17,r2,31
 d004bf8:	1021883a 	mov	r16,r2
 d004bfc:	003d1806 	br	d004060 <___vfprintf_internal_r+0xa30>
 d004c00:	3c000017 	ldw	r16,0(r7)
 d004c04:	01000044 	movi	r4,1
 d004c08:	39c00104 	addi	r7,r7,4
 d004c0c:	0023883a 	mov	r17,zero
 d004c10:	d9c14015 	stw	r7,1280(sp)
 d004c14:	d8000405 	stb	zero,16(sp)
 d004c18:	003d1306 	br	d004068 <___vfprintf_internal_r+0xa38>
 d004c1c:	00834174 	movhi	r2,3333
 d004c20:	10b10304 	addi	r2,r2,-15348
 d004c24:	94800044 	addi	r18,r18,1
 d004c28:	8c400044 	addi	r17,r17,1
 d004c2c:	a8800015 	stw	r2,0(r21)
 d004c30:	00c00044 	movi	r3,1
 d004c34:	008001c4 	movi	r2,7
 d004c38:	a8c00115 	stw	r3,4(r21)
 d004c3c:	dc800e15 	stw	r18,56(sp)
 d004c40:	dc400d15 	stw	r17,52(sp)
 d004c44:	1440ca16 	blt	r2,r17,d004f70 <___vfprintf_internal_r+0x1940>
 d004c48:	a8c00204 	addi	r3,r21,8
 d004c4c:	2000061e 	bne	r4,zero,d004c68 <___vfprintf_internal_r+0x1638>
 d004c50:	d9414717 	ldw	r5,1308(sp)
 d004c54:	2800041e 	bne	r5,zero,d004c68 <___vfprintf_internal_r+0x1638>
 d004c58:	d9814c17 	ldw	r6,1328(sp)
 d004c5c:	3080004c 	andi	r2,r6,1
 d004c60:	1005003a 	cmpeq	r2,r2,zero
 d004c64:	103bf01e 	bne	r2,zero,d003c28 <___vfprintf_internal_r+0x5f8>
 d004c68:	00800044 	movi	r2,1
 d004c6c:	dc400d17 	ldw	r17,52(sp)
 d004c70:	18800115 	stw	r2,4(r3)
 d004c74:	d8814917 	ldw	r2,1316(sp)
 d004c78:	94800044 	addi	r18,r18,1
 d004c7c:	8c400044 	addi	r17,r17,1
 d004c80:	18800015 	stw	r2,0(r3)
 d004c84:	008001c4 	movi	r2,7
 d004c88:	dc800e15 	stw	r18,56(sp)
 d004c8c:	dc400d15 	stw	r17,52(sp)
 d004c90:	1440ca16 	blt	r2,r17,d004fbc <___vfprintf_internal_r+0x198c>
 d004c94:	18c00204 	addi	r3,r3,8
 d004c98:	0121c83a 	sub	r16,zero,r4
 d004c9c:	0400500e 	bge	zero,r16,d004de0 <___vfprintf_internal_r+0x17b0>
 d004ca0:	00800404 	movi	r2,16
 d004ca4:	1400800e 	bge	r2,r16,d004ea8 <___vfprintf_internal_r+0x1878>
 d004ca8:	1027883a 	mov	r19,r2
 d004cac:	07034174 	movhi	fp,3333
 d004cb0:	e7310384 	addi	fp,fp,-15346
 d004cb4:	050001c4 	movi	r20,7
 d004cb8:	00000306 	br	d004cc8 <___vfprintf_internal_r+0x1698>
 d004cbc:	18c00204 	addi	r3,r3,8
 d004cc0:	843ffc04 	addi	r16,r16,-16
 d004cc4:	9c007a0e 	bge	r19,r16,d004eb0 <___vfprintf_internal_r+0x1880>
 d004cc8:	94800404 	addi	r18,r18,16
 d004ccc:	8c400044 	addi	r17,r17,1
 d004cd0:	1f000015 	stw	fp,0(r3)
 d004cd4:	1cc00115 	stw	r19,4(r3)
 d004cd8:	dc800e15 	stw	r18,56(sp)
 d004cdc:	dc400d15 	stw	r17,52(sp)
 d004ce0:	a47ff60e 	bge	r20,r17,d004cbc <___vfprintf_internal_r+0x168c>
 d004ce4:	d9014f17 	ldw	r4,1340(sp)
 d004ce8:	b00b883a 	mov	r5,r22
 d004cec:	d9800c04 	addi	r6,sp,48
 d004cf0:	d0035d80 	call	d0035d8 <__sprint_r>
 d004cf4:	103c061e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004cf8:	dc800e17 	ldw	r18,56(sp)
 d004cfc:	dc400d17 	ldw	r17,52(sp)
 d004d00:	d8c01904 	addi	r3,sp,100
 d004d04:	003fee06 	br	d004cc0 <___vfprintf_internal_r+0x1690>
 d004d08:	3c000017 	ldw	r16,0(r7)
 d004d0c:	0023883a 	mov	r17,zero
 d004d10:	39c00104 	addi	r7,r7,4
 d004d14:	d9c14015 	stw	r7,1280(sp)
 d004d18:	003e9206 	br	d004764 <___vfprintf_internal_r+0x1134>
 d004d1c:	d9401904 	addi	r5,sp,100
 d004d20:	dd000f04 	addi	r20,sp,60
 d004d24:	d9414115 	stw	r5,1284(sp)
 d004d28:	d9814417 	ldw	r6,1296(sp)
 d004d2c:	880a973a 	slli	r5,r17,28
 d004d30:	8004d13a 	srli	r2,r16,4
 d004d34:	810003cc 	andi	r4,r16,15
 d004d38:	3109883a 	add	r4,r6,r4
 d004d3c:	2884b03a 	or	r2,r5,r2
 d004d40:	21400003 	ldbu	r5,0(r4)
 d004d44:	d9014117 	ldw	r4,1284(sp)
 d004d48:	8806d13a 	srli	r3,r17,4
 d004d4c:	1021883a 	mov	r16,r2
 d004d50:	213fffc4 	addi	r4,r4,-1
 d004d54:	d9014115 	stw	r4,1284(sp)
 d004d58:	d9814117 	ldw	r6,1284(sp)
 d004d5c:	10c8b03a 	or	r4,r2,r3
 d004d60:	1823883a 	mov	r17,r3
 d004d64:	31400005 	stb	r5,0(r6)
 d004d68:	203fef1e 	bne	r4,zero,d004d28 <___vfprintf_internal_r+0x16f8>
 d004d6c:	003ccb06 	br	d00409c <___vfprintf_internal_r+0xa6c>
 d004d70:	00800c04 	movi	r2,48
 d004d74:	d98018c4 	addi	r6,sp,99
 d004d78:	dd000f04 	addi	r20,sp,60
 d004d7c:	d88018c5 	stb	r2,99(sp)
 d004d80:	d9814115 	stw	r6,1284(sp)
 d004d84:	003cc506 	br	d00409c <___vfprintf_internal_r+0xa6c>
 d004d88:	dc400d17 	ldw	r17,52(sp)
 d004d8c:	07034174 	movhi	fp,3333
 d004d90:	e7310784 	addi	fp,fp,-15330
 d004d94:	003bc706 	br	d003cb4 <___vfprintf_internal_r+0x684>
 d004d98:	d9414c17 	ldw	r5,1328(sp)
 d004d9c:	2880040c 	andi	r2,r5,16
 d004da0:	10007c26 	beq	r2,zero,d004f94 <___vfprintf_internal_r+0x1964>
 d004da4:	38800017 	ldw	r2,0(r7)
 d004da8:	39c00104 	addi	r7,r7,4
 d004dac:	d9c14015 	stw	r7,1280(sp)
 d004db0:	d9814b17 	ldw	r6,1324(sp)
 d004db4:	d9c14017 	ldw	r7,1280(sp)
 d004db8:	11800015 	stw	r6,0(r2)
 d004dbc:	003a7806 	br	d0037a0 <___vfprintf_internal_r+0x170>
 d004dc0:	d9014f17 	ldw	r4,1340(sp)
 d004dc4:	b00b883a 	mov	r5,r22
 d004dc8:	d9800c04 	addi	r6,sp,48
 d004dcc:	d0035d80 	call	d0035d8 <__sprint_r>
 d004dd0:	103bcf1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004dd4:	dc800e17 	ldw	r18,56(sp)
 d004dd8:	dc400d17 	ldw	r17,52(sp)
 d004ddc:	d8c01904 	addi	r3,sp,100
 d004de0:	d9014717 	ldw	r4,1308(sp)
 d004de4:	d9414117 	ldw	r5,1284(sp)
 d004de8:	8c400044 	addi	r17,r17,1
 d004dec:	9125883a 	add	r18,r18,r4
 d004df0:	008001c4 	movi	r2,7
 d004df4:	19400015 	stw	r5,0(r3)
 d004df8:	19000115 	stw	r4,4(r3)
 d004dfc:	dc800e15 	stw	r18,56(sp)
 d004e00:	dc400d15 	stw	r17,52(sp)
 d004e04:	147cee16 	blt	r2,r17,d0041c0 <___vfprintf_internal_r+0xb90>
 d004e08:	18c00204 	addi	r3,r3,8
 d004e0c:	003b8606 	br	d003c28 <___vfprintf_internal_r+0x5f8>
 d004e10:	38c00017 	ldw	r3,0(r7)
 d004e14:	39000204 	addi	r4,r7,8
 d004e18:	d9014015 	stw	r4,1280(sp)
 d004e1c:	d8c14215 	stw	r3,1288(sp)
 d004e20:	39c00117 	ldw	r7,4(r7)
 d004e24:	d9c14315 	stw	r7,1292(sp)
 d004e28:	003e2006 	br	d0046ac <___vfprintf_internal_r+0x107c>
 d004e2c:	0005883a 	mov	r2,zero
 d004e30:	1409c83a 	sub	r4,r2,r16
 d004e34:	1105803a 	cmpltu	r2,r2,r4
 d004e38:	044bc83a 	sub	r5,zero,r17
 d004e3c:	2885c83a 	sub	r2,r5,r2
 d004e40:	2021883a 	mov	r16,r4
 d004e44:	1023883a 	mov	r17,r2
 d004e48:	01000044 	movi	r4,1
 d004e4c:	00800b44 	movi	r2,45
 d004e50:	d8800405 	stb	r2,16(sp)
 d004e54:	003c8406 	br	d004068 <___vfprintf_internal_r+0xa38>
 d004e58:	d9014f17 	ldw	r4,1340(sp)
 d004e5c:	b00b883a 	mov	r5,r22
 d004e60:	d9800c04 	addi	r6,sp,48
 d004e64:	d0035d80 	call	d0035d8 <__sprint_r>
 d004e68:	103ba91e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004e6c:	dc800e17 	ldw	r18,56(sp)
 d004e70:	dc400d17 	ldw	r17,52(sp)
 d004e74:	d9000517 	ldw	r4,20(sp)
 d004e78:	d9401904 	addi	r5,sp,100
 d004e7c:	003da706 	br	d00451c <___vfprintf_internal_r+0xeec>
 d004e80:	d9014f17 	ldw	r4,1340(sp)
 d004e84:	b00b883a 	mov	r5,r22
 d004e88:	d9800c04 	addi	r6,sp,48
 d004e8c:	d0035d80 	call	d0035d8 <__sprint_r>
 d004e90:	103b9f1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004e94:	dc800e17 	ldw	r18,56(sp)
 d004e98:	dc400d17 	ldw	r17,52(sp)
 d004e9c:	d9000517 	ldw	r4,20(sp)
 d004ea0:	d8c01904 	addi	r3,sp,100
 d004ea4:	003d9106 	br	d0044ec <___vfprintf_internal_r+0xebc>
 d004ea8:	07034174 	movhi	fp,3333
 d004eac:	e7310384 	addi	fp,fp,-15346
 d004eb0:	9425883a 	add	r18,r18,r16
 d004eb4:	8c400044 	addi	r17,r17,1
 d004eb8:	008001c4 	movi	r2,7
 d004ebc:	1f000015 	stw	fp,0(r3)
 d004ec0:	1c000115 	stw	r16,4(r3)
 d004ec4:	dc800e15 	stw	r18,56(sp)
 d004ec8:	dc400d15 	stw	r17,52(sp)
 d004ecc:	147fbc16 	blt	r2,r17,d004dc0 <___vfprintf_internal_r+0x1790>
 d004ed0:	18c00204 	addi	r3,r3,8
 d004ed4:	003fc206 	br	d004de0 <___vfprintf_internal_r+0x17b0>
 d004ed8:	d9014f17 	ldw	r4,1340(sp)
 d004edc:	b00b883a 	mov	r5,r22
 d004ee0:	d9800c04 	addi	r6,sp,48
 d004ee4:	d0035d80 	call	d0035d8 <__sprint_r>
 d004ee8:	103b891e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004eec:	dc800e17 	ldw	r18,56(sp)
 d004ef0:	d9000517 	ldw	r4,20(sp)
 d004ef4:	d8c01904 	addi	r3,sp,100
 d004ef8:	003d0206 	br	d004304 <___vfprintf_internal_r+0xcd4>
 d004efc:	07034174 	movhi	fp,3333
 d004f00:	e7310384 	addi	fp,fp,-15346
 d004f04:	003be406 	br	d003e98 <___vfprintf_internal_r+0x868>
 d004f08:	00834174 	movhi	r2,3333
 d004f0c:	10b0f204 	addi	r2,r2,-15416
 d004f10:	d8814115 	stw	r2,1284(sp)
 d004f14:	003df506 	br	d0046ec <___vfprintf_internal_r+0x10bc>
 d004f18:	d9014217 	ldw	r4,1288(sp)
 d004f1c:	d9414317 	ldw	r5,1292(sp)
 d004f20:	d00a2700 	call	d00a270 <__isnand>
 d004f24:	10003926 	beq	r2,zero,d00500c <___vfprintf_internal_r+0x19dc>
 d004f28:	d9414d17 	ldw	r5,1332(sp)
 d004f2c:	008011c4 	movi	r2,71
 d004f30:	1140ce16 	blt	r2,r5,d00526c <___vfprintf_internal_r+0x1c3c>
 d004f34:	01834174 	movhi	r6,3333
 d004f38:	31b0f304 	addi	r6,r6,-15412
 d004f3c:	d9814115 	stw	r6,1284(sp)
 d004f40:	003dea06 	br	d0046ec <___vfprintf_internal_r+0x10bc>
 d004f44:	d9014c17 	ldw	r4,1328(sp)
 d004f48:	bdc00044 	addi	r23,r23,1
 d004f4c:	b8c00007 	ldb	r3,0(r23)
 d004f50:	21000814 	ori	r4,r4,32
 d004f54:	d9014c15 	stw	r4,1328(sp)
 d004f58:	003a3406 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d004f5c:	dcc14515 	stw	r19,1300(sp)
 d004f60:	98011016 	blt	r19,zero,d0053a4 <___vfprintf_internal_r+0x1d74>
 d004f64:	980f883a 	mov	r7,r19
 d004f68:	d8014615 	stw	zero,1304(sp)
 d004f6c:	003c5206 	br	d0040b8 <___vfprintf_internal_r+0xa88>
 d004f70:	d9014f17 	ldw	r4,1340(sp)
 d004f74:	b00b883a 	mov	r5,r22
 d004f78:	d9800c04 	addi	r6,sp,48
 d004f7c:	d0035d80 	call	d0035d8 <__sprint_r>
 d004f80:	103b631e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004f84:	dc800e17 	ldw	r18,56(sp)
 d004f88:	d9000517 	ldw	r4,20(sp)
 d004f8c:	d8c01904 	addi	r3,sp,100
 d004f90:	003f2e06 	br	d004c4c <___vfprintf_internal_r+0x161c>
 d004f94:	d8c14c17 	ldw	r3,1328(sp)
 d004f98:	1880100c 	andi	r2,r3,64
 d004f9c:	1000a026 	beq	r2,zero,d005220 <___vfprintf_internal_r+0x1bf0>
 d004fa0:	38800017 	ldw	r2,0(r7)
 d004fa4:	39c00104 	addi	r7,r7,4
 d004fa8:	d9c14015 	stw	r7,1280(sp)
 d004fac:	d9014b17 	ldw	r4,1324(sp)
 d004fb0:	d9c14017 	ldw	r7,1280(sp)
 d004fb4:	1100000d 	sth	r4,0(r2)
 d004fb8:	0039f906 	br	d0037a0 <___vfprintf_internal_r+0x170>
 d004fbc:	d9014f17 	ldw	r4,1340(sp)
 d004fc0:	b00b883a 	mov	r5,r22
 d004fc4:	d9800c04 	addi	r6,sp,48
 d004fc8:	d0035d80 	call	d0035d8 <__sprint_r>
 d004fcc:	103b501e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d004fd0:	dc800e17 	ldw	r18,56(sp)
 d004fd4:	dc400d17 	ldw	r17,52(sp)
 d004fd8:	d9000517 	ldw	r4,20(sp)
 d004fdc:	d8c01904 	addi	r3,sp,100
 d004fe0:	003f2d06 	br	d004c98 <___vfprintf_internal_r+0x1668>
 d004fe4:	00800184 	movi	r2,6
 d004fe8:	14c09a36 	bltu	r2,r19,d005254 <___vfprintf_internal_r+0x1c24>
 d004fec:	dcc14515 	stw	r19,1300(sp)
 d004ff0:	9800010e 	bge	r19,zero,d004ff8 <___vfprintf_internal_r+0x19c8>
 d004ff4:	d8014515 	stw	zero,1300(sp)
 d004ff8:	00834174 	movhi	r2,3333
 d004ffc:	10b0f504 	addi	r2,r2,-15404
 d005000:	980f883a 	mov	r7,r19
 d005004:	d8814115 	stw	r2,1284(sp)
 d005008:	003a7806 	br	d0039ec <___vfprintf_internal_r+0x3bc>
 d00500c:	00bfffc4 	movi	r2,-1
 d005010:	9880e226 	beq	r19,r2,d00539c <___vfprintf_internal_r+0x1d6c>
 d005014:	d9414d17 	ldw	r5,1332(sp)
 d005018:	008019c4 	movi	r2,103
 d00501c:	2880dc26 	beq	r5,r2,d005390 <___vfprintf_internal_r+0x1d60>
 d005020:	008011c4 	movi	r2,71
 d005024:	2880da26 	beq	r5,r2,d005390 <___vfprintf_internal_r+0x1d60>
 d005028:	d9414c17 	ldw	r5,1328(sp)
 d00502c:	d9014317 	ldw	r4,1292(sp)
 d005030:	d9814217 	ldw	r6,1288(sp)
 d005034:	29404014 	ori	r5,r5,256
 d005038:	d9414c15 	stw	r5,1328(sp)
 d00503c:	2000cc16 	blt	r4,zero,d005370 <___vfprintf_internal_r+0x1d40>
 d005040:	3021883a 	mov	r16,r6
 d005044:	2023883a 	mov	r17,r4
 d005048:	0039883a 	mov	fp,zero
 d00504c:	d9414d17 	ldw	r5,1332(sp)
 d005050:	00801984 	movi	r2,102
 d005054:	2880b726 	beq	r5,r2,d005334 <___vfprintf_internal_r+0x1d04>
 d005058:	00801184 	movi	r2,70
 d00505c:	2880b526 	beq	r5,r2,d005334 <___vfprintf_internal_r+0x1d04>
 d005060:	00801944 	movi	r2,101
 d005064:	2880c826 	beq	r5,r2,d005388 <___vfprintf_internal_r+0x1d58>
 d005068:	00801144 	movi	r2,69
 d00506c:	2880c626 	beq	r5,r2,d005388 <___vfprintf_internal_r+0x1d58>
 d005070:	9829883a 	mov	r20,r19
 d005074:	d9014f17 	ldw	r4,1340(sp)
 d005078:	d8800504 	addi	r2,sp,20
 d00507c:	880d883a 	mov	r6,r17
 d005080:	d8800115 	stw	r2,4(sp)
 d005084:	d8c00604 	addi	r3,sp,24
 d005088:	d8800704 	addi	r2,sp,28
 d00508c:	800b883a 	mov	r5,r16
 d005090:	01c00084 	movi	r7,2
 d005094:	d8c00215 	stw	r3,8(sp)
 d005098:	d8800315 	stw	r2,12(sp)
 d00509c:	dd000015 	stw	r20,0(sp)
 d0050a0:	d0059a00 	call	d0059a0 <_dtoa_r>
 d0050a4:	d9814d17 	ldw	r6,1332(sp)
 d0050a8:	d8814115 	stw	r2,1284(sp)
 d0050ac:	008019c4 	movi	r2,103
 d0050b0:	30809526 	beq	r6,r2,d005308 <___vfprintf_internal_r+0x1cd8>
 d0050b4:	d8c14d17 	ldw	r3,1332(sp)
 d0050b8:	008011c4 	movi	r2,71
 d0050bc:	18809226 	beq	r3,r2,d005308 <___vfprintf_internal_r+0x1cd8>
 d0050c0:	d9414117 	ldw	r5,1284(sp)
 d0050c4:	d9814d17 	ldw	r6,1332(sp)
 d0050c8:	00801984 	movi	r2,102
 d0050cc:	2d25883a 	add	r18,r5,r20
 d0050d0:	30808626 	beq	r6,r2,d0052ec <___vfprintf_internal_r+0x1cbc>
 d0050d4:	00801184 	movi	r2,70
 d0050d8:	30808426 	beq	r6,r2,d0052ec <___vfprintf_internal_r+0x1cbc>
 d0050dc:	000d883a 	mov	r6,zero
 d0050e0:	000f883a 	mov	r7,zero
 d0050e4:	880b883a 	mov	r5,r17
 d0050e8:	8009883a 	mov	r4,r16
 d0050ec:	d00c0580 	call	d00c058 <__eqdf2>
 d0050f0:	1000751e 	bne	r2,zero,d0052c8 <___vfprintf_internal_r+0x1c98>
 d0050f4:	9005883a 	mov	r2,r18
 d0050f8:	dc800715 	stw	r18,28(sp)
 d0050fc:	d9014117 	ldw	r4,1284(sp)
 d005100:	d9414d17 	ldw	r5,1332(sp)
 d005104:	00c019c4 	movi	r3,103
 d005108:	1125c83a 	sub	r18,r2,r4
 d00510c:	28c06826 	beq	r5,r3,d0052b0 <___vfprintf_internal_r+0x1c80>
 d005110:	008011c4 	movi	r2,71
 d005114:	28806626 	beq	r5,r2,d0052b0 <___vfprintf_internal_r+0x1c80>
 d005118:	d9000517 	ldw	r4,20(sp)
 d00511c:	d8c14d17 	ldw	r3,1332(sp)
 d005120:	00801944 	movi	r2,101
 d005124:	10c05516 	blt	r2,r3,d00527c <___vfprintf_internal_r+0x1c4c>
 d005128:	213fffc4 	addi	r4,r4,-1
 d00512c:	d9000515 	stw	r4,20(sp)
 d005130:	d8c00805 	stb	r3,32(sp)
 d005134:	2021883a 	mov	r16,r4
 d005138:	2000c116 	blt	r4,zero,d005440 <___vfprintf_internal_r+0x1e10>
 d00513c:	00800ac4 	movi	r2,43
 d005140:	d8800845 	stb	r2,33(sp)
 d005144:	00800244 	movi	r2,9
 d005148:	1400af0e 	bge	r2,r16,d005408 <___vfprintf_internal_r+0x1dd8>
 d00514c:	1027883a 	mov	r19,r2
 d005150:	dc400b84 	addi	r17,sp,46
 d005154:	8009883a 	mov	r4,r16
 d005158:	01400284 	movi	r5,10
 d00515c:	d00c7400 	call	d00c740 <__modsi3>
 d005160:	10800c04 	addi	r2,r2,48
 d005164:	8c7fffc4 	addi	r17,r17,-1
 d005168:	8009883a 	mov	r4,r16
 d00516c:	01400284 	movi	r5,10
 d005170:	88800005 	stb	r2,0(r17)
 d005174:	d00c6e00 	call	d00c6e0 <__divsi3>
 d005178:	1021883a 	mov	r16,r2
 d00517c:	98bff516 	blt	r19,r2,d005154 <___vfprintf_internal_r+0x1b24>
 d005180:	10c00c04 	addi	r3,r2,48
 d005184:	d88009c4 	addi	r2,sp,39
 d005188:	108001c4 	addi	r2,r2,7
 d00518c:	897fffc4 	addi	r5,r17,-1
 d005190:	88ffffc5 	stb	r3,-1(r17)
 d005194:	2880a72e 	bgeu	r5,r2,d005434 <___vfprintf_internal_r+0x1e04>
 d005198:	1009883a 	mov	r4,r2
 d00519c:	d9800804 	addi	r6,sp,32
 d0051a0:	d8c00884 	addi	r3,sp,34
 d0051a4:	28800003 	ldbu	r2,0(r5)
 d0051a8:	29400044 	addi	r5,r5,1
 d0051ac:	18800005 	stb	r2,0(r3)
 d0051b0:	18c00044 	addi	r3,r3,1
 d0051b4:	293ffb36 	bltu	r5,r4,d0051a4 <___vfprintf_internal_r+0x1b74>
 d0051b8:	1987c83a 	sub	r3,r3,r6
 d0051bc:	00800044 	movi	r2,1
 d0051c0:	d8c14815 	stw	r3,1312(sp)
 d0051c4:	90cf883a 	add	r7,r18,r3
 d0051c8:	1480960e 	bge	r2,r18,d005424 <___vfprintf_internal_r+0x1df4>
 d0051cc:	39c00044 	addi	r7,r7,1
 d0051d0:	d9c14515 	stw	r7,1300(sp)
 d0051d4:	38003416 	blt	r7,zero,d0052a8 <___vfprintf_internal_r+0x1c78>
 d0051d8:	e0803fcc 	andi	r2,fp,255
 d0051dc:	1080201c 	xori	r2,r2,128
 d0051e0:	10bfe004 	addi	r2,r2,-128
 d0051e4:	10004e26 	beq	r2,zero,d005320 <___vfprintf_internal_r+0x1cf0>
 d0051e8:	00800b44 	movi	r2,45
 d0051ec:	dc814715 	stw	r18,1308(sp)
 d0051f0:	d8014615 	stw	zero,1304(sp)
 d0051f4:	d8800405 	stb	r2,16(sp)
 d0051f8:	003bb106 	br	d0040c0 <___vfprintf_internal_r+0xa90>
 d0051fc:	00800b44 	movi	r2,45
 d005200:	d8800405 	stb	r2,16(sp)
 d005204:	003d3306 	br	d0046d4 <___vfprintf_internal_r+0x10a4>
 d005208:	d9014f17 	ldw	r4,1340(sp)
 d00520c:	b00b883a 	mov	r5,r22
 d005210:	d9800c04 	addi	r6,sp,48
 d005214:	d0035d80 	call	d0035d8 <__sprint_r>
 d005218:	103abd1e 	bne	r2,zero,d003d10 <___vfprintf_internal_r+0x6e0>
 d00521c:	003abb06 	br	d003d0c <___vfprintf_internal_r+0x6dc>
 d005220:	38800017 	ldw	r2,0(r7)
 d005224:	39c00104 	addi	r7,r7,4
 d005228:	d9c14015 	stw	r7,1280(sp)
 d00522c:	d9414b17 	ldw	r5,1324(sp)
 d005230:	d9c14017 	ldw	r7,1280(sp)
 d005234:	11400015 	stw	r5,0(r2)
 d005238:	00395906 	br	d0037a0 <___vfprintf_internal_r+0x170>
 d00523c:	980f883a 	mov	r7,r19
 d005240:	dcc14515 	stw	r19,1300(sp)
 d005244:	d8014615 	stw	zero,1304(sp)
 d005248:	003b9b06 	br	d0040b8 <___vfprintf_internal_r+0xa88>
 d00524c:	0027883a 	mov	r19,zero
 d005250:	00397806 	br	d003834 <___vfprintf_internal_r+0x204>
 d005254:	00c34174 	movhi	r3,3333
 d005258:	18f0f504 	addi	r3,r3,-15404
 d00525c:	100f883a 	mov	r7,r2
 d005260:	d8814515 	stw	r2,1300(sp)
 d005264:	d8c14115 	stw	r3,1284(sp)
 d005268:	0039e006 	br	d0039ec <___vfprintf_internal_r+0x3bc>
 d00526c:	00834174 	movhi	r2,3333
 d005270:	10b0f404 	addi	r2,r2,-15408
 d005274:	d8814115 	stw	r2,1284(sp)
 d005278:	003d1c06 	br	d0046ec <___vfprintf_internal_r+0x10bc>
 d00527c:	d9414d17 	ldw	r5,1332(sp)
 d005280:	00801984 	movi	r2,102
 d005284:	28804926 	beq	r5,r2,d0053ac <___vfprintf_internal_r+0x1d7c>
 d005288:	200f883a 	mov	r7,r4
 d00528c:	24805716 	blt	r4,r18,d0053ec <___vfprintf_internal_r+0x1dbc>
 d005290:	d9414c17 	ldw	r5,1328(sp)
 d005294:	2880004c 	andi	r2,r5,1
 d005298:	10000126 	beq	r2,zero,d0052a0 <___vfprintf_internal_r+0x1c70>
 d00529c:	21c00044 	addi	r7,r4,1
 d0052a0:	d9c14515 	stw	r7,1300(sp)
 d0052a4:	383fcc0e 	bge	r7,zero,d0051d8 <___vfprintf_internal_r+0x1ba8>
 d0052a8:	d8014515 	stw	zero,1300(sp)
 d0052ac:	003fca06 	br	d0051d8 <___vfprintf_internal_r+0x1ba8>
 d0052b0:	d9000517 	ldw	r4,20(sp)
 d0052b4:	00bfff04 	movi	r2,-4
 d0052b8:	1100480e 	bge	r2,r4,d0053dc <___vfprintf_internal_r+0x1dac>
 d0052bc:	99004716 	blt	r19,r4,d0053dc <___vfprintf_internal_r+0x1dac>
 d0052c0:	d8c14d15 	stw	r3,1332(sp)
 d0052c4:	003ff006 	br	d005288 <___vfprintf_internal_r+0x1c58>
 d0052c8:	d8800717 	ldw	r2,28(sp)
 d0052cc:	14bf8b2e 	bgeu	r2,r18,d0050fc <___vfprintf_internal_r+0x1acc>
 d0052d0:	9007883a 	mov	r3,r18
 d0052d4:	01000c04 	movi	r4,48
 d0052d8:	11000005 	stb	r4,0(r2)
 d0052dc:	10800044 	addi	r2,r2,1
 d0052e0:	d8800715 	stw	r2,28(sp)
 d0052e4:	18bffc1e 	bne	r3,r2,d0052d8 <___vfprintf_internal_r+0x1ca8>
 d0052e8:	003f8406 	br	d0050fc <___vfprintf_internal_r+0x1acc>
 d0052ec:	d8814117 	ldw	r2,1284(sp)
 d0052f0:	10c00007 	ldb	r3,0(r2)
 d0052f4:	00800c04 	movi	r2,48
 d0052f8:	18805b26 	beq	r3,r2,d005468 <___vfprintf_internal_r+0x1e38>
 d0052fc:	d9000517 	ldw	r4,20(sp)
 d005300:	9125883a 	add	r18,r18,r4
 d005304:	003f7506 	br	d0050dc <___vfprintf_internal_r+0x1aac>
 d005308:	d9014c17 	ldw	r4,1328(sp)
 d00530c:	2080004c 	andi	r2,r4,1
 d005310:	1005003a 	cmpeq	r2,r2,zero
 d005314:	103f6a26 	beq	r2,zero,d0050c0 <___vfprintf_internal_r+0x1a90>
 d005318:	d8800717 	ldw	r2,28(sp)
 d00531c:	003f7706 	br	d0050fc <___vfprintf_internal_r+0x1acc>
 d005320:	d9c14515 	stw	r7,1300(sp)
 d005324:	38004d16 	blt	r7,zero,d00545c <___vfprintf_internal_r+0x1e2c>
 d005328:	dc814715 	stw	r18,1308(sp)
 d00532c:	d8014615 	stw	zero,1304(sp)
 d005330:	003b6106 	br	d0040b8 <___vfprintf_internal_r+0xa88>
 d005334:	d9014f17 	ldw	r4,1340(sp)
 d005338:	d8800504 	addi	r2,sp,20
 d00533c:	d8800115 	stw	r2,4(sp)
 d005340:	d8c00604 	addi	r3,sp,24
 d005344:	d8800704 	addi	r2,sp,28
 d005348:	800b883a 	mov	r5,r16
 d00534c:	880d883a 	mov	r6,r17
 d005350:	01c000c4 	movi	r7,3
 d005354:	d8c00215 	stw	r3,8(sp)
 d005358:	d8800315 	stw	r2,12(sp)
 d00535c:	dcc00015 	stw	r19,0(sp)
 d005360:	9829883a 	mov	r20,r19
 d005364:	d0059a00 	call	d0059a0 <_dtoa_r>
 d005368:	d8814115 	stw	r2,1284(sp)
 d00536c:	003f5106 	br	d0050b4 <___vfprintf_internal_r+0x1a84>
 d005370:	d8c14217 	ldw	r3,1288(sp)
 d005374:	d9014317 	ldw	r4,1292(sp)
 d005378:	07000b44 	movi	fp,45
 d00537c:	1821883a 	mov	r16,r3
 d005380:	2460003c 	xorhi	r17,r4,32768
 d005384:	003f3106 	br	d00504c <___vfprintf_internal_r+0x1a1c>
 d005388:	9d000044 	addi	r20,r19,1
 d00538c:	003f3906 	br	d005074 <___vfprintf_internal_r+0x1a44>
 d005390:	983f251e 	bne	r19,zero,d005028 <___vfprintf_internal_r+0x19f8>
 d005394:	04c00044 	movi	r19,1
 d005398:	003f2306 	br	d005028 <___vfprintf_internal_r+0x19f8>
 d00539c:	04c00184 	movi	r19,6
 d0053a0:	003f2106 	br	d005028 <___vfprintf_internal_r+0x19f8>
 d0053a4:	d8014515 	stw	zero,1300(sp)
 d0053a8:	003eee06 	br	d004f64 <___vfprintf_internal_r+0x1934>
 d0053ac:	200f883a 	mov	r7,r4
 d0053b0:	0100370e 	bge	zero,r4,d005490 <___vfprintf_internal_r+0x1e60>
 d0053b4:	9800031e 	bne	r19,zero,d0053c4 <___vfprintf_internal_r+0x1d94>
 d0053b8:	d9814c17 	ldw	r6,1328(sp)
 d0053bc:	3080004c 	andi	r2,r6,1
 d0053c0:	103fb726 	beq	r2,zero,d0052a0 <___vfprintf_internal_r+0x1c70>
 d0053c4:	20800044 	addi	r2,r4,1
 d0053c8:	98a7883a 	add	r19,r19,r2
 d0053cc:	dcc14515 	stw	r19,1300(sp)
 d0053d0:	980f883a 	mov	r7,r19
 d0053d4:	983f800e 	bge	r19,zero,d0051d8 <___vfprintf_internal_r+0x1ba8>
 d0053d8:	003fb306 	br	d0052a8 <___vfprintf_internal_r+0x1c78>
 d0053dc:	d9814d17 	ldw	r6,1332(sp)
 d0053e0:	31bfff84 	addi	r6,r6,-2
 d0053e4:	d9814d15 	stw	r6,1332(sp)
 d0053e8:	003f4c06 	br	d00511c <___vfprintf_internal_r+0x1aec>
 d0053ec:	0100180e 	bge	zero,r4,d005450 <___vfprintf_internal_r+0x1e20>
 d0053f0:	00800044 	movi	r2,1
 d0053f4:	1485883a 	add	r2,r2,r18
 d0053f8:	d8814515 	stw	r2,1300(sp)
 d0053fc:	100f883a 	mov	r7,r2
 d005400:	103f750e 	bge	r2,zero,d0051d8 <___vfprintf_internal_r+0x1ba8>
 d005404:	003fa806 	br	d0052a8 <___vfprintf_internal_r+0x1c78>
 d005408:	80c00c04 	addi	r3,r16,48
 d00540c:	00800c04 	movi	r2,48
 d005410:	d8c008c5 	stb	r3,35(sp)
 d005414:	d9800804 	addi	r6,sp,32
 d005418:	d8c00904 	addi	r3,sp,36
 d00541c:	d8800885 	stb	r2,34(sp)
 d005420:	003f6506 	br	d0051b8 <___vfprintf_internal_r+0x1b88>
 d005424:	d9014c17 	ldw	r4,1328(sp)
 d005428:	2084703a 	and	r2,r4,r2
 d00542c:	103f9c26 	beq	r2,zero,d0052a0 <___vfprintf_internal_r+0x1c70>
 d005430:	003f6606 	br	d0051cc <___vfprintf_internal_r+0x1b9c>
 d005434:	d9800804 	addi	r6,sp,32
 d005438:	d8c00884 	addi	r3,sp,34
 d00543c:	003f5e06 	br	d0051b8 <___vfprintf_internal_r+0x1b88>
 d005440:	00800b44 	movi	r2,45
 d005444:	0121c83a 	sub	r16,zero,r4
 d005448:	d8800845 	stb	r2,33(sp)
 d00544c:	003f3d06 	br	d005144 <___vfprintf_internal_r+0x1b14>
 d005450:	00800084 	movi	r2,2
 d005454:	1105c83a 	sub	r2,r2,r4
 d005458:	003fe606 	br	d0053f4 <___vfprintf_internal_r+0x1dc4>
 d00545c:	d8014515 	stw	zero,1300(sp)
 d005460:	dc814715 	stw	r18,1308(sp)
 d005464:	003fb106 	br	d00532c <___vfprintf_internal_r+0x1cfc>
 d005468:	000d883a 	mov	r6,zero
 d00546c:	000f883a 	mov	r7,zero
 d005470:	8009883a 	mov	r4,r16
 d005474:	880b883a 	mov	r5,r17
 d005478:	d00c0e00 	call	d00c0e0 <__nedf2>
 d00547c:	103f9f26 	beq	r2,zero,d0052fc <___vfprintf_internal_r+0x1ccc>
 d005480:	00800044 	movi	r2,1
 d005484:	1509c83a 	sub	r4,r2,r20
 d005488:	d9000515 	stw	r4,20(sp)
 d00548c:	003f9b06 	br	d0052fc <___vfprintf_internal_r+0x1ccc>
 d005490:	98000d1e 	bne	r19,zero,d0054c8 <___vfprintf_internal_r+0x1e98>
 d005494:	d8c14c17 	ldw	r3,1328(sp)
 d005498:	1880004c 	andi	r2,r3,1
 d00549c:	10000a1e 	bne	r2,zero,d0054c8 <___vfprintf_internal_r+0x1e98>
 d0054a0:	01000044 	movi	r4,1
 d0054a4:	200f883a 	mov	r7,r4
 d0054a8:	d9014515 	stw	r4,1300(sp)
 d0054ac:	003f4a06 	br	d0051d8 <___vfprintf_internal_r+0x1ba8>
 d0054b0:	3cc00017 	ldw	r19,0(r7)
 d0054b4:	39c00104 	addi	r7,r7,4
 d0054b8:	983d0e0e 	bge	r19,zero,d0048f4 <___vfprintf_internal_r+0x12c4>
 d0054bc:	b8c00007 	ldb	r3,0(r23)
 d0054c0:	04ffffc4 	movi	r19,-1
 d0054c4:	0038d906 	br	d00382c <___vfprintf_internal_r+0x1fc>
 d0054c8:	9cc00084 	addi	r19,r19,2
 d0054cc:	dcc14515 	stw	r19,1300(sp)
 d0054d0:	980f883a 	mov	r7,r19
 d0054d4:	983f400e 	bge	r19,zero,d0051d8 <___vfprintf_internal_r+0x1ba8>
 d0054d8:	003f7306 	br	d0052a8 <___vfprintf_internal_r+0x1c78>

0d0054dc <__vfprintf_internal>:
 d0054dc:	00834174 	movhi	r2,3333
 d0054e0:	108a2204 	addi	r2,r2,10376
 d0054e4:	2013883a 	mov	r9,r4
 d0054e8:	11000017 	ldw	r4,0(r2)
 d0054ec:	2805883a 	mov	r2,r5
 d0054f0:	300f883a 	mov	r7,r6
 d0054f4:	480b883a 	mov	r5,r9
 d0054f8:	100d883a 	mov	r6,r2
 d0054fc:	d0036301 	jmpi	d003630 <___vfprintf_internal_r>

0d005500 <__swbuf_r>:
 d005500:	defffc04 	addi	sp,sp,-16
 d005504:	dc400215 	stw	r17,8(sp)
 d005508:	dc000115 	stw	r16,4(sp)
 d00550c:	dfc00315 	stw	ra,12(sp)
 d005510:	2023883a 	mov	r17,r4
 d005514:	2821883a 	mov	r16,r5
 d005518:	20000226 	beq	r4,zero,d005524 <__swbuf_r+0x24>
 d00551c:	20800e17 	ldw	r2,56(r4)
 d005520:	10002f26 	beq	r2,zero,d0055e0 <__swbuf_r+0xe0>
 d005524:	3080030b 	ldhu	r2,12(r6)
 d005528:	30c00617 	ldw	r3,24(r6)
 d00552c:	1080020c 	andi	r2,r2,8
 d005530:	30c00215 	stw	r3,8(r6)
 d005534:	10002226 	beq	r2,zero,d0055c0 <__swbuf_r+0xc0>
 d005538:	30c00417 	ldw	r3,16(r6)
 d00553c:	18002026 	beq	r3,zero,d0055c0 <__swbuf_r+0xc0>
 d005540:	31000017 	ldw	r4,0(r6)
 d005544:	30800517 	ldw	r2,20(r6)
 d005548:	20c7c83a 	sub	r3,r4,r3
 d00554c:	18802f0e 	bge	r3,r2,d00560c <__swbuf_r+0x10c>
 d005550:	19400044 	addi	r5,r3,1
 d005554:	30800217 	ldw	r2,8(r6)
 d005558:	84003fcc 	andi	r16,r16,255
 d00555c:	20c00044 	addi	r3,r4,1
 d005560:	10bfffc4 	addi	r2,r2,-1
 d005564:	30800215 	stw	r2,8(r6)
 d005568:	24000005 	stb	r16,0(r4)
 d00556c:	30800517 	ldw	r2,20(r6)
 d005570:	30c00015 	stw	r3,0(r6)
 d005574:	11400c26 	beq	r2,r5,d0055a8 <__swbuf_r+0xa8>
 d005578:	3080030b 	ldhu	r2,12(r6)
 d00557c:	1080004c 	andi	r2,r2,1
 d005580:	1005003a 	cmpeq	r2,r2,zero
 d005584:	10000626 	beq	r2,zero,d0055a0 <__swbuf_r+0xa0>
 d005588:	8005883a 	mov	r2,r16
 d00558c:	dfc00317 	ldw	ra,12(sp)
 d005590:	dc400217 	ldw	r17,8(sp)
 d005594:	dc000117 	ldw	r16,4(sp)
 d005598:	dec00404 	addi	sp,sp,16
 d00559c:	f800283a 	ret
 d0055a0:	00800284 	movi	r2,10
 d0055a4:	80bff81e 	bne	r16,r2,d005588 <__swbuf_r+0x88>
 d0055a8:	8809883a 	mov	r4,r17
 d0055ac:	300b883a 	mov	r5,r6
 d0055b0:	d006f540 	call	d006f54 <_fflush_r>
 d0055b4:	103ff426 	beq	r2,zero,d005588 <__swbuf_r+0x88>
 d0055b8:	043fffc4 	movi	r16,-1
 d0055bc:	003ff206 	br	d005588 <__swbuf_r+0x88>
 d0055c0:	300b883a 	mov	r5,r6
 d0055c4:	8809883a 	mov	r4,r17
 d0055c8:	d9800015 	stw	r6,0(sp)
 d0055cc:	d00564c0 	call	d00564c <__swsetup_r>
 d0055d0:	d9800017 	ldw	r6,0(sp)
 d0055d4:	1000061e 	bne	r2,zero,d0055f0 <__swbuf_r+0xf0>
 d0055d8:	30c00417 	ldw	r3,16(r6)
 d0055dc:	003fd806 	br	d005540 <__swbuf_r+0x40>
 d0055e0:	d9800015 	stw	r6,0(sp)
 d0055e4:	d0071ec0 	call	d0071ec <__sinit>
 d0055e8:	d9800017 	ldw	r6,0(sp)
 d0055ec:	003fcd06 	br	d005524 <__swbuf_r+0x24>
 d0055f0:	3080030b 	ldhu	r2,12(r6)
 d0055f4:	00c00244 	movi	r3,9
 d0055f8:	043fffc4 	movi	r16,-1
 d0055fc:	10801014 	ori	r2,r2,64
 d005600:	3080030d 	sth	r2,12(r6)
 d005604:	88c00015 	stw	r3,0(r17)
 d005608:	003fdf06 	br	d005588 <__swbuf_r+0x88>
 d00560c:	300b883a 	mov	r5,r6
 d005610:	8809883a 	mov	r4,r17
 d005614:	d9800015 	stw	r6,0(sp)
 d005618:	d006f540 	call	d006f54 <_fflush_r>
 d00561c:	d9800017 	ldw	r6,0(sp)
 d005620:	103fe51e 	bne	r2,zero,d0055b8 <__swbuf_r+0xb8>
 d005624:	31000017 	ldw	r4,0(r6)
 d005628:	01400044 	movi	r5,1
 d00562c:	003fc906 	br	d005554 <__swbuf_r+0x54>

0d005630 <__swbuf>:
 d005630:	01834174 	movhi	r6,3333
 d005634:	318a2204 	addi	r6,r6,10376
 d005638:	2007883a 	mov	r3,r4
 d00563c:	31000017 	ldw	r4,0(r6)
 d005640:	280d883a 	mov	r6,r5
 d005644:	180b883a 	mov	r5,r3
 d005648:	d0055001 	jmpi	d005500 <__swbuf_r>

0d00564c <__swsetup_r>:
 d00564c:	00834174 	movhi	r2,3333
 d005650:	108a2204 	addi	r2,r2,10376
 d005654:	10c00017 	ldw	r3,0(r2)
 d005658:	defffd04 	addi	sp,sp,-12
 d00565c:	dc400115 	stw	r17,4(sp)
 d005660:	dc000015 	stw	r16,0(sp)
 d005664:	dfc00215 	stw	ra,8(sp)
 d005668:	2023883a 	mov	r17,r4
 d00566c:	2821883a 	mov	r16,r5
 d005670:	18000226 	beq	r3,zero,d00567c <__swsetup_r+0x30>
 d005674:	18800e17 	ldw	r2,56(r3)
 d005678:	10001f26 	beq	r2,zero,d0056f8 <__swsetup_r+0xac>
 d00567c:	8100030b 	ldhu	r4,12(r16)
 d005680:	2080020c 	andi	r2,r4,8
 d005684:	10002826 	beq	r2,zero,d005728 <__swsetup_r+0xdc>
 d005688:	81400417 	ldw	r5,16(r16)
 d00568c:	28001d26 	beq	r5,zero,d005704 <__swsetup_r+0xb8>
 d005690:	2080004c 	andi	r2,r4,1
 d005694:	1005003a 	cmpeq	r2,r2,zero
 d005698:	10000b26 	beq	r2,zero,d0056c8 <__swsetup_r+0x7c>
 d00569c:	2080008c 	andi	r2,r4,2
 d0056a0:	10001226 	beq	r2,zero,d0056ec <__swsetup_r+0xa0>
 d0056a4:	0005883a 	mov	r2,zero
 d0056a8:	80800215 	stw	r2,8(r16)
 d0056ac:	28000b26 	beq	r5,zero,d0056dc <__swsetup_r+0x90>
 d0056b0:	0005883a 	mov	r2,zero
 d0056b4:	dfc00217 	ldw	ra,8(sp)
 d0056b8:	dc400117 	ldw	r17,4(sp)
 d0056bc:	dc000017 	ldw	r16,0(sp)
 d0056c0:	dec00304 	addi	sp,sp,12
 d0056c4:	f800283a 	ret
 d0056c8:	80800517 	ldw	r2,20(r16)
 d0056cc:	80000215 	stw	zero,8(r16)
 d0056d0:	0085c83a 	sub	r2,zero,r2
 d0056d4:	80800615 	stw	r2,24(r16)
 d0056d8:	283ff51e 	bne	r5,zero,d0056b0 <__swsetup_r+0x64>
 d0056dc:	2080200c 	andi	r2,r4,128
 d0056e0:	103ff326 	beq	r2,zero,d0056b0 <__swsetup_r+0x64>
 d0056e4:	00bfffc4 	movi	r2,-1
 d0056e8:	003ff206 	br	d0056b4 <__swsetup_r+0x68>
 d0056ec:	80800517 	ldw	r2,20(r16)
 d0056f0:	80800215 	stw	r2,8(r16)
 d0056f4:	003fed06 	br	d0056ac <__swsetup_r+0x60>
 d0056f8:	1809883a 	mov	r4,r3
 d0056fc:	d0071ec0 	call	d0071ec <__sinit>
 d005700:	003fde06 	br	d00567c <__swsetup_r+0x30>
 d005704:	20c0a00c 	andi	r3,r4,640
 d005708:	00808004 	movi	r2,512
 d00570c:	18bfe026 	beq	r3,r2,d005690 <__swsetup_r+0x44>
 d005710:	8809883a 	mov	r4,r17
 d005714:	800b883a 	mov	r5,r16
 d005718:	d0080b00 	call	d0080b0 <__smakebuf_r>
 d00571c:	8100030b 	ldhu	r4,12(r16)
 d005720:	81400417 	ldw	r5,16(r16)
 d005724:	003fda06 	br	d005690 <__swsetup_r+0x44>
 d005728:	2080040c 	andi	r2,r4,16
 d00572c:	103fed26 	beq	r2,zero,d0056e4 <__swsetup_r+0x98>
 d005730:	2080010c 	andi	r2,r4,4
 d005734:	10001226 	beq	r2,zero,d005780 <__swsetup_r+0x134>
 d005738:	81400c17 	ldw	r5,48(r16)
 d00573c:	28000526 	beq	r5,zero,d005754 <__swsetup_r+0x108>
 d005740:	80801004 	addi	r2,r16,64
 d005744:	28800226 	beq	r5,r2,d005750 <__swsetup_r+0x104>
 d005748:	8809883a 	mov	r4,r17
 d00574c:	d0076bc0 	call	d0076bc <_free_r>
 d005750:	80000c15 	stw	zero,48(r16)
 d005754:	8080030b 	ldhu	r2,12(r16)
 d005758:	81400417 	ldw	r5,16(r16)
 d00575c:	80000115 	stw	zero,4(r16)
 d005760:	10bff6cc 	andi	r2,r2,65499
 d005764:	8080030d 	sth	r2,12(r16)
 d005768:	81400015 	stw	r5,0(r16)
 d00576c:	8080030b 	ldhu	r2,12(r16)
 d005770:	10800214 	ori	r2,r2,8
 d005774:	113fffcc 	andi	r4,r2,65535
 d005778:	8080030d 	sth	r2,12(r16)
 d00577c:	003fc306 	br	d00568c <__swsetup_r+0x40>
 d005780:	81400417 	ldw	r5,16(r16)
 d005784:	003ff906 	br	d00576c <__swsetup_r+0x120>

0d005788 <quorem>:
 d005788:	28c00417 	ldw	r3,16(r5)
 d00578c:	20800417 	ldw	r2,16(r4)
 d005790:	defff604 	addi	sp,sp,-40
 d005794:	ddc00715 	stw	r23,28(sp)
 d005798:	dd400515 	stw	r21,20(sp)
 d00579c:	dfc00915 	stw	ra,36(sp)
 d0057a0:	df000815 	stw	fp,32(sp)
 d0057a4:	dd800615 	stw	r22,24(sp)
 d0057a8:	dd000415 	stw	r20,16(sp)
 d0057ac:	dcc00315 	stw	r19,12(sp)
 d0057b0:	dc800215 	stw	r18,8(sp)
 d0057b4:	dc400115 	stw	r17,4(sp)
 d0057b8:	dc000015 	stw	r16,0(sp)
 d0057bc:	202f883a 	mov	r23,r4
 d0057c0:	282b883a 	mov	r21,r5
 d0057c4:	10c07416 	blt	r2,r3,d005998 <quorem+0x210>
 d0057c8:	1c7fffc4 	addi	r17,r3,-1
 d0057cc:	8c45883a 	add	r2,r17,r17
 d0057d0:	1085883a 	add	r2,r2,r2
 d0057d4:	2c000504 	addi	r16,r5,20
 d0057d8:	24c00504 	addi	r19,r4,20
 d0057dc:	14ed883a 	add	r22,r2,r19
 d0057e0:	80a5883a 	add	r18,r16,r2
 d0057e4:	b7000017 	ldw	fp,0(r22)
 d0057e8:	91400017 	ldw	r5,0(r18)
 d0057ec:	e009883a 	mov	r4,fp
 d0057f0:	29400044 	addi	r5,r5,1
 d0057f4:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d0057f8:	1029883a 	mov	r20,r2
 d0057fc:	10003c1e 	bne	r2,zero,d0058f0 <quorem+0x168>
 d005800:	a80b883a 	mov	r5,r21
 d005804:	b809883a 	mov	r4,r23
 d005808:	d008bc40 	call	d008bc4 <__mcmp>
 d00580c:	10002b16 	blt	r2,zero,d0058bc <quorem+0x134>
 d005810:	a5000044 	addi	r20,r20,1
 d005814:	980f883a 	mov	r7,r19
 d005818:	0011883a 	mov	r8,zero
 d00581c:	0009883a 	mov	r4,zero
 d005820:	81400017 	ldw	r5,0(r16)
 d005824:	38c00017 	ldw	r3,0(r7)
 d005828:	84000104 	addi	r16,r16,4
 d00582c:	28bfffcc 	andi	r2,r5,65535
 d005830:	2085883a 	add	r2,r4,r2
 d005834:	11bfffcc 	andi	r6,r2,65535
 d005838:	193fffcc 	andi	r4,r3,65535
 d00583c:	1004d43a 	srli	r2,r2,16
 d005840:	280ad43a 	srli	r5,r5,16
 d005844:	2189c83a 	sub	r4,r4,r6
 d005848:	2209883a 	add	r4,r4,r8
 d00584c:	1806d43a 	srli	r3,r3,16
 d005850:	288b883a 	add	r5,r5,r2
 d005854:	200dd43a 	srai	r6,r4,16
 d005858:	28bfffcc 	andi	r2,r5,65535
 d00585c:	1887c83a 	sub	r3,r3,r2
 d005860:	1987883a 	add	r3,r3,r6
 d005864:	3900000d 	sth	r4,0(r7)
 d005868:	38c0008d 	sth	r3,2(r7)
 d00586c:	2808d43a 	srli	r4,r5,16
 d005870:	39c00104 	addi	r7,r7,4
 d005874:	1811d43a 	srai	r8,r3,16
 d005878:	943fe92e 	bgeu	r18,r16,d005820 <quorem+0x98>
 d00587c:	8c45883a 	add	r2,r17,r17
 d005880:	1085883a 	add	r2,r2,r2
 d005884:	9885883a 	add	r2,r19,r2
 d005888:	10c00017 	ldw	r3,0(r2)
 d00588c:	18000b1e 	bne	r3,zero,d0058bc <quorem+0x134>
 d005890:	113fff04 	addi	r4,r2,-4
 d005894:	9900082e 	bgeu	r19,r4,d0058b8 <quorem+0x130>
 d005898:	10bfff17 	ldw	r2,-4(r2)
 d00589c:	10000326 	beq	r2,zero,d0058ac <quorem+0x124>
 d0058a0:	00000506 	br	d0058b8 <quorem+0x130>
 d0058a4:	20800017 	ldw	r2,0(r4)
 d0058a8:	1000031e 	bne	r2,zero,d0058b8 <quorem+0x130>
 d0058ac:	213fff04 	addi	r4,r4,-4
 d0058b0:	8c7fffc4 	addi	r17,r17,-1
 d0058b4:	993ffb36 	bltu	r19,r4,d0058a4 <quorem+0x11c>
 d0058b8:	bc400415 	stw	r17,16(r23)
 d0058bc:	a005883a 	mov	r2,r20
 d0058c0:	dfc00917 	ldw	ra,36(sp)
 d0058c4:	df000817 	ldw	fp,32(sp)
 d0058c8:	ddc00717 	ldw	r23,28(sp)
 d0058cc:	dd800617 	ldw	r22,24(sp)
 d0058d0:	dd400517 	ldw	r21,20(sp)
 d0058d4:	dd000417 	ldw	r20,16(sp)
 d0058d8:	dcc00317 	ldw	r19,12(sp)
 d0058dc:	dc800217 	ldw	r18,8(sp)
 d0058e0:	dc400117 	ldw	r17,4(sp)
 d0058e4:	dc000017 	ldw	r16,0(sp)
 d0058e8:	dec00a04 	addi	sp,sp,40
 d0058ec:	f800283a 	ret
 d0058f0:	980f883a 	mov	r7,r19
 d0058f4:	8011883a 	mov	r8,r16
 d0058f8:	0013883a 	mov	r9,zero
 d0058fc:	000d883a 	mov	r6,zero
 d005900:	40c00017 	ldw	r3,0(r8)
 d005904:	39000017 	ldw	r4,0(r7)
 d005908:	42000104 	addi	r8,r8,4
 d00590c:	18bfffcc 	andi	r2,r3,65535
 d005910:	a085383a 	mul	r2,r20,r2
 d005914:	1806d43a 	srli	r3,r3,16
 d005918:	217fffcc 	andi	r5,r4,65535
 d00591c:	3085883a 	add	r2,r6,r2
 d005920:	11bfffcc 	andi	r6,r2,65535
 d005924:	a0c7383a 	mul	r3,r20,r3
 d005928:	1004d43a 	srli	r2,r2,16
 d00592c:	298bc83a 	sub	r5,r5,r6
 d005930:	2a4b883a 	add	r5,r5,r9
 d005934:	2008d43a 	srli	r4,r4,16
 d005938:	1887883a 	add	r3,r3,r2
 d00593c:	280dd43a 	srai	r6,r5,16
 d005940:	18bfffcc 	andi	r2,r3,65535
 d005944:	2089c83a 	sub	r4,r4,r2
 d005948:	2189883a 	add	r4,r4,r6
 d00594c:	3900008d 	sth	r4,2(r7)
 d005950:	3940000d 	sth	r5,0(r7)
 d005954:	180cd43a 	srli	r6,r3,16
 d005958:	39c00104 	addi	r7,r7,4
 d00595c:	2013d43a 	srai	r9,r4,16
 d005960:	923fe72e 	bgeu	r18,r8,d005900 <quorem+0x178>
 d005964:	e03fa61e 	bne	fp,zero,d005800 <quorem+0x78>
 d005968:	b0ffff04 	addi	r3,r22,-4
 d00596c:	98c0082e 	bgeu	r19,r3,d005990 <quorem+0x208>
 d005970:	b0bfff17 	ldw	r2,-4(r22)
 d005974:	10000326 	beq	r2,zero,d005984 <quorem+0x1fc>
 d005978:	00000506 	br	d005990 <quorem+0x208>
 d00597c:	18800017 	ldw	r2,0(r3)
 d005980:	1000031e 	bne	r2,zero,d005990 <quorem+0x208>
 d005984:	18ffff04 	addi	r3,r3,-4
 d005988:	8c7fffc4 	addi	r17,r17,-1
 d00598c:	98fffb36 	bltu	r19,r3,d00597c <quorem+0x1f4>
 d005990:	bc400415 	stw	r17,16(r23)
 d005994:	003f9a06 	br	d005800 <quorem+0x78>
 d005998:	0005883a 	mov	r2,zero
 d00599c:	003fc806 	br	d0058c0 <quorem+0x138>

0d0059a0 <_dtoa_r>:
 d0059a0:	22001017 	ldw	r8,64(r4)
 d0059a4:	deffda04 	addi	sp,sp,-152
 d0059a8:	dd402115 	stw	r21,132(sp)
 d0059ac:	dd002015 	stw	r20,128(sp)
 d0059b0:	dc801e15 	stw	r18,120(sp)
 d0059b4:	dc401d15 	stw	r17,116(sp)
 d0059b8:	dfc02515 	stw	ra,148(sp)
 d0059bc:	df002415 	stw	fp,144(sp)
 d0059c0:	ddc02315 	stw	r23,140(sp)
 d0059c4:	dd802215 	stw	r22,136(sp)
 d0059c8:	dcc01f15 	stw	r19,124(sp)
 d0059cc:	dc001c15 	stw	r16,112(sp)
 d0059d0:	d9001615 	stw	r4,88(sp)
 d0059d4:	3023883a 	mov	r17,r6
 d0059d8:	2829883a 	mov	r20,r5
 d0059dc:	d9c01715 	stw	r7,92(sp)
 d0059e0:	dc802817 	ldw	r18,160(sp)
 d0059e4:	302b883a 	mov	r21,r6
 d0059e8:	40000a26 	beq	r8,zero,d005a14 <_dtoa_r+0x74>
 d0059ec:	20801117 	ldw	r2,68(r4)
 d0059f0:	400b883a 	mov	r5,r8
 d0059f4:	40800115 	stw	r2,4(r8)
 d0059f8:	20c01117 	ldw	r3,68(r4)
 d0059fc:	00800044 	movi	r2,1
 d005a00:	10c4983a 	sll	r2,r2,r3
 d005a04:	40800215 	stw	r2,8(r8)
 d005a08:	d008a680 	call	d008a68 <_Bfree>
 d005a0c:	d8c01617 	ldw	r3,88(sp)
 d005a10:	18001015 	stw	zero,64(r3)
 d005a14:	8800a316 	blt	r17,zero,d005ca4 <_dtoa_r+0x304>
 d005a18:	90000015 	stw	zero,0(r18)
 d005a1c:	a8dffc2c 	andhi	r3,r21,32752
 d005a20:	009ffc34 	movhi	r2,32752
 d005a24:	18809126 	beq	r3,r2,d005c6c <_dtoa_r+0x2cc>
 d005a28:	000d883a 	mov	r6,zero
 d005a2c:	000f883a 	mov	r7,zero
 d005a30:	a009883a 	mov	r4,r20
 d005a34:	a80b883a 	mov	r5,r21
 d005a38:	dd001215 	stw	r20,72(sp)
 d005a3c:	dd401315 	stw	r21,76(sp)
 d005a40:	d00c0e00 	call	d00c0e0 <__nedf2>
 d005a44:	1000171e 	bne	r2,zero,d005aa4 <_dtoa_r+0x104>
 d005a48:	d9802717 	ldw	r6,156(sp)
 d005a4c:	00800044 	movi	r2,1
 d005a50:	30800015 	stw	r2,0(r6)
 d005a54:	d8802917 	ldw	r2,164(sp)
 d005a58:	10029b26 	beq	r2,zero,d0064c8 <_dtoa_r+0xb28>
 d005a5c:	d9002917 	ldw	r4,164(sp)
 d005a60:	00834174 	movhi	r2,3333
 d005a64:	10b10344 	addi	r2,r2,-15347
 d005a68:	10ffffc4 	addi	r3,r2,-1
 d005a6c:	20800015 	stw	r2,0(r4)
 d005a70:	1805883a 	mov	r2,r3
 d005a74:	dfc02517 	ldw	ra,148(sp)
 d005a78:	df002417 	ldw	fp,144(sp)
 d005a7c:	ddc02317 	ldw	r23,140(sp)
 d005a80:	dd802217 	ldw	r22,136(sp)
 d005a84:	dd402117 	ldw	r21,132(sp)
 d005a88:	dd002017 	ldw	r20,128(sp)
 d005a8c:	dcc01f17 	ldw	r19,124(sp)
 d005a90:	dc801e17 	ldw	r18,120(sp)
 d005a94:	dc401d17 	ldw	r17,116(sp)
 d005a98:	dc001c17 	ldw	r16,112(sp)
 d005a9c:	dec02604 	addi	sp,sp,152
 d005aa0:	f800283a 	ret
 d005aa4:	d9001617 	ldw	r4,88(sp)
 d005aa8:	d9401217 	ldw	r5,72(sp)
 d005aac:	d8800104 	addi	r2,sp,4
 d005ab0:	a80d883a 	mov	r6,r21
 d005ab4:	d9c00204 	addi	r7,sp,8
 d005ab8:	d8800015 	stw	r2,0(sp)
 d005abc:	d0090a40 	call	d0090a4 <__d2b>
 d005ac0:	d8800715 	stw	r2,28(sp)
 d005ac4:	a804d53a 	srli	r2,r21,20
 d005ac8:	1101ffcc 	andi	r4,r2,2047
 d005acc:	20008626 	beq	r4,zero,d005ce8 <_dtoa_r+0x348>
 d005ad0:	d8c01217 	ldw	r3,72(sp)
 d005ad4:	00800434 	movhi	r2,16
 d005ad8:	10bfffc4 	addi	r2,r2,-1
 d005adc:	ddc00117 	ldw	r23,4(sp)
 d005ae0:	a884703a 	and	r2,r21,r2
 d005ae4:	1811883a 	mov	r8,r3
 d005ae8:	124ffc34 	orhi	r9,r2,16368
 d005aec:	25bf0044 	addi	r22,r4,-1023
 d005af0:	d8000815 	stw	zero,32(sp)
 d005af4:	0005883a 	mov	r2,zero
 d005af8:	00cffe34 	movhi	r3,16376
 d005afc:	480b883a 	mov	r5,r9
 d005b00:	4009883a 	mov	r4,r8
 d005b04:	180f883a 	mov	r7,r3
 d005b08:	100d883a 	mov	r6,r2
 d005b0c:	d00b9480 	call	d00b948 <__subdf3>
 d005b10:	0218dbf4 	movhi	r8,25455
 d005b14:	4210d844 	addi	r8,r8,17249
 d005b18:	024ff4f4 	movhi	r9,16339
 d005b1c:	4a61e9c4 	addi	r9,r9,-30809
 d005b20:	480f883a 	mov	r7,r9
 d005b24:	400d883a 	mov	r6,r8
 d005b28:	180b883a 	mov	r5,r3
 d005b2c:	1009883a 	mov	r4,r2
 d005b30:	d00ba3c0 	call	d00ba3c <__muldf3>
 d005b34:	0222d874 	movhi	r8,35681
 d005b38:	42322cc4 	addi	r8,r8,-14157
 d005b3c:	024ff1f4 	movhi	r9,16327
 d005b40:	4a628a04 	addi	r9,r9,-30168
 d005b44:	480f883a 	mov	r7,r9
 d005b48:	400d883a 	mov	r6,r8
 d005b4c:	180b883a 	mov	r5,r3
 d005b50:	1009883a 	mov	r4,r2
 d005b54:	d00b9c80 	call	d00b9c8 <__adddf3>
 d005b58:	b009883a 	mov	r4,r22
 d005b5c:	1021883a 	mov	r16,r2
 d005b60:	1823883a 	mov	r17,r3
 d005b64:	d00c3000 	call	d00c300 <__floatsidf>
 d005b68:	021427f4 	movhi	r8,20639
 d005b6c:	421e7ec4 	addi	r8,r8,31227
 d005b70:	024ff4f4 	movhi	r9,16339
 d005b74:	4a5104c4 	addi	r9,r9,17427
 d005b78:	480f883a 	mov	r7,r9
 d005b7c:	400d883a 	mov	r6,r8
 d005b80:	180b883a 	mov	r5,r3
 d005b84:	1009883a 	mov	r4,r2
 d005b88:	d00ba3c0 	call	d00ba3c <__muldf3>
 d005b8c:	180f883a 	mov	r7,r3
 d005b90:	880b883a 	mov	r5,r17
 d005b94:	100d883a 	mov	r6,r2
 d005b98:	8009883a 	mov	r4,r16
 d005b9c:	d00b9c80 	call	d00b9c8 <__adddf3>
 d005ba0:	1009883a 	mov	r4,r2
 d005ba4:	180b883a 	mov	r5,r3
 d005ba8:	1021883a 	mov	r16,r2
 d005bac:	1823883a 	mov	r17,r3
 d005bb0:	d00c3f80 	call	d00c3f8 <__fixdfsi>
 d005bb4:	000d883a 	mov	r6,zero
 d005bb8:	000f883a 	mov	r7,zero
 d005bbc:	8009883a 	mov	r4,r16
 d005bc0:	880b883a 	mov	r5,r17
 d005bc4:	d8800d15 	stw	r2,52(sp)
 d005bc8:	d00c2780 	call	d00c278 <__ltdf2>
 d005bcc:	10031716 	blt	r2,zero,d00682c <_dtoa_r+0xe8c>
 d005bd0:	d8c00d17 	ldw	r3,52(sp)
 d005bd4:	00800584 	movi	r2,22
 d005bd8:	10c1482e 	bgeu	r2,r3,d0060fc <_dtoa_r+0x75c>
 d005bdc:	01000044 	movi	r4,1
 d005be0:	d9000c15 	stw	r4,48(sp)
 d005be4:	bd85c83a 	sub	r2,r23,r22
 d005be8:	11bfffc4 	addi	r6,r2,-1
 d005bec:	30030b16 	blt	r6,zero,d00681c <_dtoa_r+0xe7c>
 d005bf0:	d9800a15 	stw	r6,40(sp)
 d005bf4:	d8001115 	stw	zero,68(sp)
 d005bf8:	d8c00d17 	ldw	r3,52(sp)
 d005bfc:	1802ff16 	blt	r3,zero,d0067fc <_dtoa_r+0xe5c>
 d005c00:	d9000a17 	ldw	r4,40(sp)
 d005c04:	d8c00915 	stw	r3,36(sp)
 d005c08:	d8001015 	stw	zero,64(sp)
 d005c0c:	20c9883a 	add	r4,r4,r3
 d005c10:	d9000a15 	stw	r4,40(sp)
 d005c14:	d9001717 	ldw	r4,92(sp)
 d005c18:	00800244 	movi	r2,9
 d005c1c:	11004636 	bltu	r2,r4,d005d38 <_dtoa_r+0x398>
 d005c20:	00800144 	movi	r2,5
 d005c24:	11020416 	blt	r2,r4,d006438 <_dtoa_r+0xa98>
 d005c28:	04400044 	movi	r17,1
 d005c2c:	d8c01717 	ldw	r3,92(sp)
 d005c30:	00800144 	movi	r2,5
 d005c34:	10c1ed36 	bltu	r2,r3,d0063ec <_dtoa_r+0xa4c>
 d005c38:	18c5883a 	add	r2,r3,r3
 d005c3c:	1085883a 	add	r2,r2,r2
 d005c40:	00c34034 	movhi	r3,3328
 d005c44:	18d71504 	addi	r3,r3,23636
 d005c48:	10c5883a 	add	r2,r2,r3
 d005c4c:	11000017 	ldw	r4,0(r2)
 d005c50:	2000683a 	jmp	r4
 d005c54:	0d005d40 	call	d005d4 <OSCtxSw_SWITCH_PC+0xd00594>
 d005c58:	0d005d40 	call	d005d4 <OSCtxSw_SWITCH_PC+0xd00594>
 d005c5c:	0d006740 	call	d00674 <OSCtxSw_SWITCH_PC+0xd00634>
 d005c60:	0d006718 	cmpnei	r20,at,412
 d005c64:	0d00675c 	xori	r20,at,413
 d005c68:	0d006768 	cmpgeui	r20,at,413
 d005c6c:	d9002717 	ldw	r4,156(sp)
 d005c70:	0089c3c4 	movi	r2,9999
 d005c74:	20800015 	stw	r2,0(r4)
 d005c78:	a0001026 	beq	r20,zero,d005cbc <_dtoa_r+0x31c>
 d005c7c:	00c34174 	movhi	r3,3333
 d005c80:	18f10f04 	addi	r3,r3,-15300
 d005c84:	d9802917 	ldw	r6,164(sp)
 d005c88:	303f7926 	beq	r6,zero,d005a70 <_dtoa_r+0xd0>
 d005c8c:	188000c7 	ldb	r2,3(r3)
 d005c90:	190000c4 	addi	r4,r3,3
 d005c94:	1000101e 	bne	r2,zero,d005cd8 <_dtoa_r+0x338>
 d005c98:	d8802917 	ldw	r2,164(sp)
 d005c9c:	11000015 	stw	r4,0(r2)
 d005ca0:	003f7306 	br	d005a70 <_dtoa_r+0xd0>
 d005ca4:	00a00034 	movhi	r2,32768
 d005ca8:	10bfffc4 	addi	r2,r2,-1
 d005cac:	00c00044 	movi	r3,1
 d005cb0:	88aa703a 	and	r21,r17,r2
 d005cb4:	90c00015 	stw	r3,0(r18)
 d005cb8:	003f5806 	br	d005a1c <_dtoa_r+0x7c>
 d005cbc:	00800434 	movhi	r2,16
 d005cc0:	10bfffc4 	addi	r2,r2,-1
 d005cc4:	a884703a 	and	r2,r21,r2
 d005cc8:	103fec1e 	bne	r2,zero,d005c7c <_dtoa_r+0x2dc>
 d005ccc:	00c34174 	movhi	r3,3333
 d005cd0:	18f10c04 	addi	r3,r3,-15312
 d005cd4:	003feb06 	br	d005c84 <_dtoa_r+0x2e4>
 d005cd8:	d8802917 	ldw	r2,164(sp)
 d005cdc:	19000204 	addi	r4,r3,8
 d005ce0:	11000015 	stw	r4,0(r2)
 d005ce4:	003f6206 	br	d005a70 <_dtoa_r+0xd0>
 d005ce8:	ddc00117 	ldw	r23,4(sp)
 d005cec:	d8800217 	ldw	r2,8(sp)
 d005cf0:	01000804 	movi	r4,32
 d005cf4:	b8c10c84 	addi	r3,r23,1074
 d005cf8:	18a3883a 	add	r17,r3,r2
 d005cfc:	2441b80e 	bge	r4,r17,d0063e0 <_dtoa_r+0xa40>
 d005d00:	00c01004 	movi	r3,64
 d005d04:	1c47c83a 	sub	r3,r3,r17
 d005d08:	88bff804 	addi	r2,r17,-32
 d005d0c:	a8c6983a 	sll	r3,r21,r3
 d005d10:	a084d83a 	srl	r2,r20,r2
 d005d14:	1888b03a 	or	r4,r3,r2
 d005d18:	d00c4d00 	call	d00c4d0 <__floatunsidf>
 d005d1c:	1011883a 	mov	r8,r2
 d005d20:	00bf8434 	movhi	r2,65040
 d005d24:	01000044 	movi	r4,1
 d005d28:	10d3883a 	add	r9,r2,r3
 d005d2c:	8dbef344 	addi	r22,r17,-1075
 d005d30:	d9000815 	stw	r4,32(sp)
 d005d34:	003f6f06 	br	d005af4 <_dtoa_r+0x154>
 d005d38:	d8001715 	stw	zero,92(sp)
 d005d3c:	04400044 	movi	r17,1
 d005d40:	00bfffc4 	movi	r2,-1
 d005d44:	00c00044 	movi	r3,1
 d005d48:	d8800e15 	stw	r2,56(sp)
 d005d4c:	d8002615 	stw	zero,152(sp)
 d005d50:	d8800f15 	stw	r2,60(sp)
 d005d54:	d8c00b15 	stw	r3,44(sp)
 d005d58:	1021883a 	mov	r16,r2
 d005d5c:	d8801617 	ldw	r2,88(sp)
 d005d60:	10001115 	stw	zero,68(r2)
 d005d64:	d8801617 	ldw	r2,88(sp)
 d005d68:	11401117 	ldw	r5,68(r2)
 d005d6c:	1009883a 	mov	r4,r2
 d005d70:	d008fe80 	call	d008fe8 <_Balloc>
 d005d74:	d8c01617 	ldw	r3,88(sp)
 d005d78:	d8800515 	stw	r2,20(sp)
 d005d7c:	18801015 	stw	r2,64(r3)
 d005d80:	00800384 	movi	r2,14
 d005d84:	14006836 	bltu	r2,r16,d005f28 <_dtoa_r+0x588>
 d005d88:	8805003a 	cmpeq	r2,r17,zero
 d005d8c:	1000661e 	bne	r2,zero,d005f28 <_dtoa_r+0x588>
 d005d90:	d9000d17 	ldw	r4,52(sp)
 d005d94:	0102300e 	bge	zero,r4,d006658 <_dtoa_r+0xcb8>
 d005d98:	208003cc 	andi	r2,r4,15
 d005d9c:	100490fa 	slli	r2,r2,3
 d005da0:	2025d13a 	srai	r18,r4,4
 d005da4:	00c34174 	movhi	r3,3333
 d005da8:	18f12004 	addi	r3,r3,-15232
 d005dac:	10c5883a 	add	r2,r2,r3
 d005db0:	90c0040c 	andi	r3,r18,16
 d005db4:	14000017 	ldw	r16,0(r2)
 d005db8:	14400117 	ldw	r17,4(r2)
 d005dbc:	18036a1e 	bne	r3,zero,d006b68 <_dtoa_r+0x11c8>
 d005dc0:	05800084 	movi	r22,2
 d005dc4:	90001026 	beq	r18,zero,d005e08 <_dtoa_r+0x468>
 d005dc8:	04c34174 	movhi	r19,3333
 d005dcc:	9cf15204 	addi	r19,r19,-15032
 d005dd0:	9080004c 	andi	r2,r18,1
 d005dd4:	1005003a 	cmpeq	r2,r2,zero
 d005dd8:	1000081e 	bne	r2,zero,d005dfc <_dtoa_r+0x45c>
 d005ddc:	99800017 	ldw	r6,0(r19)
 d005de0:	99c00117 	ldw	r7,4(r19)
 d005de4:	880b883a 	mov	r5,r17
 d005de8:	8009883a 	mov	r4,r16
 d005dec:	d00ba3c0 	call	d00ba3c <__muldf3>
 d005df0:	1021883a 	mov	r16,r2
 d005df4:	b5800044 	addi	r22,r22,1
 d005df8:	1823883a 	mov	r17,r3
 d005dfc:	9025d07a 	srai	r18,r18,1
 d005e00:	9cc00204 	addi	r19,r19,8
 d005e04:	903ff21e 	bne	r18,zero,d005dd0 <_dtoa_r+0x430>
 d005e08:	a80b883a 	mov	r5,r21
 d005e0c:	a009883a 	mov	r4,r20
 d005e10:	880f883a 	mov	r7,r17
 d005e14:	800d883a 	mov	r6,r16
 d005e18:	d00be000 	call	d00be00 <__divdf3>
 d005e1c:	1029883a 	mov	r20,r2
 d005e20:	182b883a 	mov	r21,r3
 d005e24:	d8c00c17 	ldw	r3,48(sp)
 d005e28:	1805003a 	cmpeq	r2,r3,zero
 d005e2c:	1000081e 	bne	r2,zero,d005e50 <_dtoa_r+0x4b0>
 d005e30:	0005883a 	mov	r2,zero
 d005e34:	00cffc34 	movhi	r3,16368
 d005e38:	180f883a 	mov	r7,r3
 d005e3c:	a009883a 	mov	r4,r20
 d005e40:	a80b883a 	mov	r5,r21
 d005e44:	100d883a 	mov	r6,r2
 d005e48:	d00c2780 	call	d00c278 <__ltdf2>
 d005e4c:	1003fe16 	blt	r2,zero,d006e48 <_dtoa_r+0x14a8>
 d005e50:	b009883a 	mov	r4,r22
 d005e54:	d00c3000 	call	d00c300 <__floatsidf>
 d005e58:	180b883a 	mov	r5,r3
 d005e5c:	1009883a 	mov	r4,r2
 d005e60:	a00d883a 	mov	r6,r20
 d005e64:	a80f883a 	mov	r7,r21
 d005e68:	d00ba3c0 	call	d00ba3c <__muldf3>
 d005e6c:	0011883a 	mov	r8,zero
 d005e70:	02500734 	movhi	r9,16412
 d005e74:	1009883a 	mov	r4,r2
 d005e78:	180b883a 	mov	r5,r3
 d005e7c:	480f883a 	mov	r7,r9
 d005e80:	400d883a 	mov	r6,r8
 d005e84:	d00b9c80 	call	d00b9c8 <__adddf3>
 d005e88:	d9000f17 	ldw	r4,60(sp)
 d005e8c:	102d883a 	mov	r22,r2
 d005e90:	00bf3034 	movhi	r2,64704
 d005e94:	18b9883a 	add	fp,r3,r2
 d005e98:	e02f883a 	mov	r23,fp
 d005e9c:	20028f1e 	bne	r4,zero,d0068dc <_dtoa_r+0xf3c>
 d005ea0:	0005883a 	mov	r2,zero
 d005ea4:	00d00534 	movhi	r3,16404
 d005ea8:	a009883a 	mov	r4,r20
 d005eac:	a80b883a 	mov	r5,r21
 d005eb0:	180f883a 	mov	r7,r3
 d005eb4:	100d883a 	mov	r6,r2
 d005eb8:	d00b9480 	call	d00b948 <__subdf3>
 d005ebc:	1009883a 	mov	r4,r2
 d005ec0:	e00f883a 	mov	r7,fp
 d005ec4:	180b883a 	mov	r5,r3
 d005ec8:	b00d883a 	mov	r6,r22
 d005ecc:	1025883a 	mov	r18,r2
 d005ed0:	1827883a 	mov	r19,r3
 d005ed4:	d00c1680 	call	d00c168 <__gtdf2>
 d005ed8:	00834f16 	blt	zero,r2,d006c18 <_dtoa_r+0x1278>
 d005edc:	e0e0003c 	xorhi	r3,fp,32768
 d005ee0:	9009883a 	mov	r4,r18
 d005ee4:	980b883a 	mov	r5,r19
 d005ee8:	180f883a 	mov	r7,r3
 d005eec:	b00d883a 	mov	r6,r22
 d005ef0:	d00c2780 	call	d00c278 <__ltdf2>
 d005ef4:	1000080e 	bge	r2,zero,d005f18 <_dtoa_r+0x578>
 d005ef8:	0027883a 	mov	r19,zero
 d005efc:	0025883a 	mov	r18,zero
 d005f00:	d8802617 	ldw	r2,152(sp)
 d005f04:	df000517 	ldw	fp,20(sp)
 d005f08:	d8000615 	stw	zero,24(sp)
 d005f0c:	0084303a 	nor	r2,zero,r2
 d005f10:	d8800d15 	stw	r2,52(sp)
 d005f14:	00019b06 	br	d006584 <_dtoa_r+0xbe4>
 d005f18:	d9801217 	ldw	r6,72(sp)
 d005f1c:	d8801317 	ldw	r2,76(sp)
 d005f20:	3029883a 	mov	r20,r6
 d005f24:	102b883a 	mov	r21,r2
 d005f28:	d8c00217 	ldw	r3,8(sp)
 d005f2c:	18008516 	blt	r3,zero,d006144 <_dtoa_r+0x7a4>
 d005f30:	d9000d17 	ldw	r4,52(sp)
 d005f34:	00800384 	movi	r2,14
 d005f38:	11008216 	blt	r2,r4,d006144 <_dtoa_r+0x7a4>
 d005f3c:	200490fa 	slli	r2,r4,3
 d005f40:	d9802617 	ldw	r6,152(sp)
 d005f44:	00c34174 	movhi	r3,3333
 d005f48:	18f12004 	addi	r3,r3,-15232
 d005f4c:	10c5883a 	add	r2,r2,r3
 d005f50:	14800017 	ldw	r18,0(r2)
 d005f54:	14c00117 	ldw	r19,4(r2)
 d005f58:	30031e16 	blt	r6,zero,d006bd4 <_dtoa_r+0x1234>
 d005f5c:	d9000517 	ldw	r4,20(sp)
 d005f60:	d8c00f17 	ldw	r3,60(sp)
 d005f64:	a823883a 	mov	r17,r21
 d005f68:	a021883a 	mov	r16,r20
 d005f6c:	192b883a 	add	r21,r3,r4
 d005f70:	2039883a 	mov	fp,r4
 d005f74:	00000f06 	br	d005fb4 <_dtoa_r+0x614>
 d005f78:	0005883a 	mov	r2,zero
 d005f7c:	00d00934 	movhi	r3,16420
 d005f80:	5009883a 	mov	r4,r10
 d005f84:	580b883a 	mov	r5,r11
 d005f88:	180f883a 	mov	r7,r3
 d005f8c:	100d883a 	mov	r6,r2
 d005f90:	d00ba3c0 	call	d00ba3c <__muldf3>
 d005f94:	180b883a 	mov	r5,r3
 d005f98:	000d883a 	mov	r6,zero
 d005f9c:	000f883a 	mov	r7,zero
 d005fa0:	1009883a 	mov	r4,r2
 d005fa4:	1021883a 	mov	r16,r2
 d005fa8:	1823883a 	mov	r17,r3
 d005fac:	d00c0e00 	call	d00c0e0 <__nedf2>
 d005fb0:	10004526 	beq	r2,zero,d0060c8 <_dtoa_r+0x728>
 d005fb4:	900d883a 	mov	r6,r18
 d005fb8:	980f883a 	mov	r7,r19
 d005fbc:	8009883a 	mov	r4,r16
 d005fc0:	880b883a 	mov	r5,r17
 d005fc4:	d00be000 	call	d00be00 <__divdf3>
 d005fc8:	180b883a 	mov	r5,r3
 d005fcc:	1009883a 	mov	r4,r2
 d005fd0:	d00c3f80 	call	d00c3f8 <__fixdfsi>
 d005fd4:	1009883a 	mov	r4,r2
 d005fd8:	1029883a 	mov	r20,r2
 d005fdc:	d00c3000 	call	d00c300 <__floatsidf>
 d005fe0:	180f883a 	mov	r7,r3
 d005fe4:	9009883a 	mov	r4,r18
 d005fe8:	980b883a 	mov	r5,r19
 d005fec:	100d883a 	mov	r6,r2
 d005ff0:	d00ba3c0 	call	d00ba3c <__muldf3>
 d005ff4:	180f883a 	mov	r7,r3
 d005ff8:	880b883a 	mov	r5,r17
 d005ffc:	8009883a 	mov	r4,r16
 d006000:	100d883a 	mov	r6,r2
 d006004:	d00b9480 	call	d00b948 <__subdf3>
 d006008:	1015883a 	mov	r10,r2
 d00600c:	a0800c04 	addi	r2,r20,48
 d006010:	e0800005 	stb	r2,0(fp)
 d006014:	e7000044 	addi	fp,fp,1
 d006018:	1817883a 	mov	r11,r3
 d00601c:	e57fd61e 	bne	fp,r21,d005f78 <_dtoa_r+0x5d8>
 d006020:	500d883a 	mov	r6,r10
 d006024:	180f883a 	mov	r7,r3
 d006028:	5009883a 	mov	r4,r10
 d00602c:	180b883a 	mov	r5,r3
 d006030:	d00b9c80 	call	d00b9c8 <__adddf3>
 d006034:	100d883a 	mov	r6,r2
 d006038:	9009883a 	mov	r4,r18
 d00603c:	980b883a 	mov	r5,r19
 d006040:	180f883a 	mov	r7,r3
 d006044:	1021883a 	mov	r16,r2
 d006048:	1823883a 	mov	r17,r3
 d00604c:	d00c2780 	call	d00c278 <__ltdf2>
 d006050:	10000816 	blt	r2,zero,d006074 <_dtoa_r+0x6d4>
 d006054:	980b883a 	mov	r5,r19
 d006058:	800d883a 	mov	r6,r16
 d00605c:	880f883a 	mov	r7,r17
 d006060:	9009883a 	mov	r4,r18
 d006064:	d00c0580 	call	d00c058 <__eqdf2>
 d006068:	1000171e 	bne	r2,zero,d0060c8 <_dtoa_r+0x728>
 d00606c:	a080004c 	andi	r2,r20,1
 d006070:	10001526 	beq	r2,zero,d0060c8 <_dtoa_r+0x728>
 d006074:	d8800d17 	ldw	r2,52(sp)
 d006078:	d8800415 	stw	r2,16(sp)
 d00607c:	e009883a 	mov	r4,fp
 d006080:	213fffc4 	addi	r4,r4,-1
 d006084:	20c00007 	ldb	r3,0(r4)
 d006088:	00800e44 	movi	r2,57
 d00608c:	1880081e 	bne	r3,r2,d0060b0 <_dtoa_r+0x710>
 d006090:	d8800517 	ldw	r2,20(sp)
 d006094:	113ffa1e 	bne	r2,r4,d006080 <_dtoa_r+0x6e0>
 d006098:	d8c00417 	ldw	r3,16(sp)
 d00609c:	d9800517 	ldw	r6,20(sp)
 d0060a0:	00800c04 	movi	r2,48
 d0060a4:	18c00044 	addi	r3,r3,1
 d0060a8:	d8c00415 	stw	r3,16(sp)
 d0060ac:	30800005 	stb	r2,0(r6)
 d0060b0:	20800003 	ldbu	r2,0(r4)
 d0060b4:	d8c00417 	ldw	r3,16(sp)
 d0060b8:	27000044 	addi	fp,r4,1
 d0060bc:	10800044 	addi	r2,r2,1
 d0060c0:	d8c00d15 	stw	r3,52(sp)
 d0060c4:	20800005 	stb	r2,0(r4)
 d0060c8:	d9001617 	ldw	r4,88(sp)
 d0060cc:	d9400717 	ldw	r5,28(sp)
 d0060d0:	d008a680 	call	d008a68 <_Bfree>
 d0060d4:	e0000005 	stb	zero,0(fp)
 d0060d8:	d9800d17 	ldw	r6,52(sp)
 d0060dc:	d8c02717 	ldw	r3,156(sp)
 d0060e0:	d9002917 	ldw	r4,164(sp)
 d0060e4:	30800044 	addi	r2,r6,1
 d0060e8:	18800015 	stw	r2,0(r3)
 d0060ec:	20029c26 	beq	r4,zero,d006b60 <_dtoa_r+0x11c0>
 d0060f0:	d8c00517 	ldw	r3,20(sp)
 d0060f4:	27000015 	stw	fp,0(r4)
 d0060f8:	003e5d06 	br	d005a70 <_dtoa_r+0xd0>
 d0060fc:	d9800d17 	ldw	r6,52(sp)
 d006100:	00c34174 	movhi	r3,3333
 d006104:	18f12004 	addi	r3,r3,-15232
 d006108:	d9001217 	ldw	r4,72(sp)
 d00610c:	300490fa 	slli	r2,r6,3
 d006110:	d9401317 	ldw	r5,76(sp)
 d006114:	10c5883a 	add	r2,r2,r3
 d006118:	12000017 	ldw	r8,0(r2)
 d00611c:	12400117 	ldw	r9,4(r2)
 d006120:	400d883a 	mov	r6,r8
 d006124:	480f883a 	mov	r7,r9
 d006128:	d00c2780 	call	d00c278 <__ltdf2>
 d00612c:	1000030e 	bge	r2,zero,d00613c <_dtoa_r+0x79c>
 d006130:	d8800d17 	ldw	r2,52(sp)
 d006134:	10bfffc4 	addi	r2,r2,-1
 d006138:	d8800d15 	stw	r2,52(sp)
 d00613c:	d8000c15 	stw	zero,48(sp)
 d006140:	003ea806 	br	d005be4 <_dtoa_r+0x244>
 d006144:	d9000b17 	ldw	r4,44(sp)
 d006148:	202cc03a 	cmpne	r22,r4,zero
 d00614c:	b000c71e 	bne	r22,zero,d00646c <_dtoa_r+0xacc>
 d006150:	dc001117 	ldw	r16,68(sp)
 d006154:	dc801017 	ldw	r18,64(sp)
 d006158:	0027883a 	mov	r19,zero
 d00615c:	04000b0e 	bge	zero,r16,d00618c <_dtoa_r+0x7ec>
 d006160:	d8c00a17 	ldw	r3,40(sp)
 d006164:	00c0090e 	bge	zero,r3,d00618c <_dtoa_r+0x7ec>
 d006168:	8005883a 	mov	r2,r16
 d00616c:	1c011316 	blt	r3,r16,d0065bc <_dtoa_r+0xc1c>
 d006170:	d9000a17 	ldw	r4,40(sp)
 d006174:	d9801117 	ldw	r6,68(sp)
 d006178:	80a1c83a 	sub	r16,r16,r2
 d00617c:	2089c83a 	sub	r4,r4,r2
 d006180:	308dc83a 	sub	r6,r6,r2
 d006184:	d9000a15 	stw	r4,40(sp)
 d006188:	d9801115 	stw	r6,68(sp)
 d00618c:	d8801017 	ldw	r2,64(sp)
 d006190:	0080150e 	bge	zero,r2,d0061e8 <_dtoa_r+0x848>
 d006194:	d8c00b17 	ldw	r3,44(sp)
 d006198:	1805003a 	cmpeq	r2,r3,zero
 d00619c:	1001c91e 	bne	r2,zero,d0068c4 <_dtoa_r+0xf24>
 d0061a0:	04800e0e 	bge	zero,r18,d0061dc <_dtoa_r+0x83c>
 d0061a4:	d9001617 	ldw	r4,88(sp)
 d0061a8:	980b883a 	mov	r5,r19
 d0061ac:	900d883a 	mov	r6,r18
 d0061b0:	d00981c0 	call	d00981c <__pow5mult>
 d0061b4:	d9001617 	ldw	r4,88(sp)
 d0061b8:	d9800717 	ldw	r6,28(sp)
 d0061bc:	100b883a 	mov	r5,r2
 d0061c0:	1027883a 	mov	r19,r2
 d0061c4:	d0094f80 	call	d0094f8 <__multiply>
 d0061c8:	d9001617 	ldw	r4,88(sp)
 d0061cc:	d9400717 	ldw	r5,28(sp)
 d0061d0:	1023883a 	mov	r17,r2
 d0061d4:	d008a680 	call	d008a68 <_Bfree>
 d0061d8:	dc400715 	stw	r17,28(sp)
 d0061dc:	d9001017 	ldw	r4,64(sp)
 d0061e0:	248dc83a 	sub	r6,r4,r18
 d0061e4:	30010e1e 	bne	r6,zero,d006620 <_dtoa_r+0xc80>
 d0061e8:	d9001617 	ldw	r4,88(sp)
 d0061ec:	04400044 	movi	r17,1
 d0061f0:	880b883a 	mov	r5,r17
 d0061f4:	d0096e00 	call	d0096e0 <__i2b>
 d0061f8:	d9800917 	ldw	r6,36(sp)
 d0061fc:	1025883a 	mov	r18,r2
 d006200:	0180040e 	bge	zero,r6,d006214 <_dtoa_r+0x874>
 d006204:	d9001617 	ldw	r4,88(sp)
 d006208:	100b883a 	mov	r5,r2
 d00620c:	d00981c0 	call	d00981c <__pow5mult>
 d006210:	1025883a 	mov	r18,r2
 d006214:	d8801717 	ldw	r2,92(sp)
 d006218:	8880f30e 	bge	r17,r2,d0065e8 <_dtoa_r+0xc48>
 d00621c:	0023883a 	mov	r17,zero
 d006220:	d9800917 	ldw	r6,36(sp)
 d006224:	30019e1e 	bne	r6,zero,d0068a0 <_dtoa_r+0xf00>
 d006228:	00c00044 	movi	r3,1
 d00622c:	d9000a17 	ldw	r4,40(sp)
 d006230:	20c5883a 	add	r2,r4,r3
 d006234:	10c007cc 	andi	r3,r2,31
 d006238:	1800841e 	bne	r3,zero,d00644c <_dtoa_r+0xaac>
 d00623c:	00800704 	movi	r2,28
 d006240:	d9000a17 	ldw	r4,40(sp)
 d006244:	d9801117 	ldw	r6,68(sp)
 d006248:	80a1883a 	add	r16,r16,r2
 d00624c:	2089883a 	add	r4,r4,r2
 d006250:	308d883a 	add	r6,r6,r2
 d006254:	d9000a15 	stw	r4,40(sp)
 d006258:	d9801115 	stw	r6,68(sp)
 d00625c:	d8801117 	ldw	r2,68(sp)
 d006260:	0080050e 	bge	zero,r2,d006278 <_dtoa_r+0x8d8>
 d006264:	d9400717 	ldw	r5,28(sp)
 d006268:	d9001617 	ldw	r4,88(sp)
 d00626c:	100d883a 	mov	r6,r2
 d006270:	d0093ac0 	call	d0093ac <__lshift>
 d006274:	d8800715 	stw	r2,28(sp)
 d006278:	d8c00a17 	ldw	r3,40(sp)
 d00627c:	00c0050e 	bge	zero,r3,d006294 <_dtoa_r+0x8f4>
 d006280:	d9001617 	ldw	r4,88(sp)
 d006284:	900b883a 	mov	r5,r18
 d006288:	180d883a 	mov	r6,r3
 d00628c:	d0093ac0 	call	d0093ac <__lshift>
 d006290:	1025883a 	mov	r18,r2
 d006294:	d9000c17 	ldw	r4,48(sp)
 d006298:	2005003a 	cmpeq	r2,r4,zero
 d00629c:	10016f26 	beq	r2,zero,d00685c <_dtoa_r+0xebc>
 d0062a0:	d9000f17 	ldw	r4,60(sp)
 d0062a4:	0102170e 	bge	zero,r4,d006b04 <_dtoa_r+0x1164>
 d0062a8:	d9800b17 	ldw	r6,44(sp)
 d0062ac:	3005003a 	cmpeq	r2,r6,zero
 d0062b0:	1000881e 	bne	r2,zero,d0064d4 <_dtoa_r+0xb34>
 d0062b4:	0400050e 	bge	zero,r16,d0062cc <_dtoa_r+0x92c>
 d0062b8:	d9001617 	ldw	r4,88(sp)
 d0062bc:	980b883a 	mov	r5,r19
 d0062c0:	800d883a 	mov	r6,r16
 d0062c4:	d0093ac0 	call	d0093ac <__lshift>
 d0062c8:	1027883a 	mov	r19,r2
 d0062cc:	8804c03a 	cmpne	r2,r17,zero
 d0062d0:	1002541e 	bne	r2,zero,d006c24 <_dtoa_r+0x1284>
 d0062d4:	980b883a 	mov	r5,r19
 d0062d8:	dd800517 	ldw	r22,20(sp)
 d0062dc:	dcc00615 	stw	r19,24(sp)
 d0062e0:	a700004c 	andi	fp,r20,1
 d0062e4:	2827883a 	mov	r19,r5
 d0062e8:	d9000717 	ldw	r4,28(sp)
 d0062ec:	900b883a 	mov	r5,r18
 d0062f0:	d0057880 	call	d005788 <quorem>
 d0062f4:	d9000717 	ldw	r4,28(sp)
 d0062f8:	d9400617 	ldw	r5,24(sp)
 d0062fc:	1023883a 	mov	r17,r2
 d006300:	8dc00c04 	addi	r23,r17,48
 d006304:	d008bc40 	call	d008bc4 <__mcmp>
 d006308:	d9001617 	ldw	r4,88(sp)
 d00630c:	900b883a 	mov	r5,r18
 d006310:	980d883a 	mov	r6,r19
 d006314:	1029883a 	mov	r20,r2
 d006318:	d0092200 	call	d009220 <__mdiff>
 d00631c:	102b883a 	mov	r21,r2
 d006320:	10800317 	ldw	r2,12(r2)
 d006324:	1001281e 	bne	r2,zero,d0067c8 <_dtoa_r+0xe28>
 d006328:	d9000717 	ldw	r4,28(sp)
 d00632c:	a80b883a 	mov	r5,r21
 d006330:	d008bc40 	call	d008bc4 <__mcmp>
 d006334:	d9001617 	ldw	r4,88(sp)
 d006338:	1021883a 	mov	r16,r2
 d00633c:	a80b883a 	mov	r5,r21
 d006340:	d008a680 	call	d008a68 <_Bfree>
 d006344:	8000041e 	bne	r16,zero,d006358 <_dtoa_r+0x9b8>
 d006348:	d8801717 	ldw	r2,92(sp)
 d00634c:	1000021e 	bne	r2,zero,d006358 <_dtoa_r+0x9b8>
 d006350:	e004c03a 	cmpne	r2,fp,zero
 d006354:	10011726 	beq	r2,zero,d0067b4 <_dtoa_r+0xe14>
 d006358:	a0010616 	blt	r20,zero,d006774 <_dtoa_r+0xdd4>
 d00635c:	a000041e 	bne	r20,zero,d006370 <_dtoa_r+0x9d0>
 d006360:	d8c01717 	ldw	r3,92(sp)
 d006364:	1800021e 	bne	r3,zero,d006370 <_dtoa_r+0x9d0>
 d006368:	e004c03a 	cmpne	r2,fp,zero
 d00636c:	10010126 	beq	r2,zero,d006774 <_dtoa_r+0xdd4>
 d006370:	04023d16 	blt	zero,r16,d006c68 <_dtoa_r+0x12c8>
 d006374:	b5c00005 	stb	r23,0(r22)
 d006378:	d9800517 	ldw	r6,20(sp)
 d00637c:	d9000f17 	ldw	r4,60(sp)
 d006380:	b5800044 	addi	r22,r22,1
 d006384:	3105883a 	add	r2,r6,r4
 d006388:	b0806526 	beq	r22,r2,d006520 <_dtoa_r+0xb80>
 d00638c:	d9400717 	ldw	r5,28(sp)
 d006390:	d9001617 	ldw	r4,88(sp)
 d006394:	01800284 	movi	r6,10
 d006398:	000f883a 	mov	r7,zero
 d00639c:	d00971c0 	call	d00971c <__multadd>
 d0063a0:	d8800715 	stw	r2,28(sp)
 d0063a4:	d8800617 	ldw	r2,24(sp)
 d0063a8:	14c10c26 	beq	r2,r19,d0067dc <_dtoa_r+0xe3c>
 d0063ac:	d9400617 	ldw	r5,24(sp)
 d0063b0:	d9001617 	ldw	r4,88(sp)
 d0063b4:	01800284 	movi	r6,10
 d0063b8:	000f883a 	mov	r7,zero
 d0063bc:	d00971c0 	call	d00971c <__multadd>
 d0063c0:	d9001617 	ldw	r4,88(sp)
 d0063c4:	980b883a 	mov	r5,r19
 d0063c8:	01800284 	movi	r6,10
 d0063cc:	000f883a 	mov	r7,zero
 d0063d0:	d8800615 	stw	r2,24(sp)
 d0063d4:	d00971c0 	call	d00971c <__multadd>
 d0063d8:	1027883a 	mov	r19,r2
 d0063dc:	003fc206 	br	d0062e8 <_dtoa_r+0x948>
 d0063e0:	2445c83a 	sub	r2,r4,r17
 d0063e4:	a088983a 	sll	r4,r20,r2
 d0063e8:	003e4b06 	br	d005d18 <_dtoa_r+0x378>
 d0063ec:	01bfffc4 	movi	r6,-1
 d0063f0:	00800044 	movi	r2,1
 d0063f4:	d9800e15 	stw	r6,56(sp)
 d0063f8:	d9800f15 	stw	r6,60(sp)
 d0063fc:	d8800b15 	stw	r2,44(sp)
 d006400:	d8c01617 	ldw	r3,88(sp)
 d006404:	008005c4 	movi	r2,23
 d006408:	18001115 	stw	zero,68(r3)
 d00640c:	1580082e 	bgeu	r2,r22,d006430 <_dtoa_r+0xa90>
 d006410:	00c00104 	movi	r3,4
 d006414:	0009883a 	mov	r4,zero
 d006418:	18c7883a 	add	r3,r3,r3
 d00641c:	18800504 	addi	r2,r3,20
 d006420:	21000044 	addi	r4,r4,1
 d006424:	b0bffc2e 	bgeu	r22,r2,d006418 <_dtoa_r+0xa78>
 d006428:	d9801617 	ldw	r6,88(sp)
 d00642c:	31001115 	stw	r4,68(r6)
 d006430:	dc000f17 	ldw	r16,60(sp)
 d006434:	003e4b06 	br	d005d64 <_dtoa_r+0x3c4>
 d006438:	d9801717 	ldw	r6,92(sp)
 d00643c:	0023883a 	mov	r17,zero
 d006440:	31bfff04 	addi	r6,r6,-4
 d006444:	d9801715 	stw	r6,92(sp)
 d006448:	003df806 	br	d005c2c <_dtoa_r+0x28c>
 d00644c:	00800804 	movi	r2,32
 d006450:	10c9c83a 	sub	r4,r2,r3
 d006454:	00c00104 	movi	r3,4
 d006458:	19005a16 	blt	r3,r4,d0065c4 <_dtoa_r+0xc24>
 d00645c:	008000c4 	movi	r2,3
 d006460:	113f7e16 	blt	r2,r4,d00625c <_dtoa_r+0x8bc>
 d006464:	20800704 	addi	r2,r4,28
 d006468:	003f7506 	br	d006240 <_dtoa_r+0x8a0>
 d00646c:	d9801717 	ldw	r6,92(sp)
 d006470:	00800044 	movi	r2,1
 d006474:	1180a10e 	bge	r2,r6,d0066fc <_dtoa_r+0xd5c>
 d006478:	d9800f17 	ldw	r6,60(sp)
 d00647c:	d8c01017 	ldw	r3,64(sp)
 d006480:	30bfffc4 	addi	r2,r6,-1
 d006484:	1881c616 	blt	r3,r2,d006ba0 <_dtoa_r+0x1200>
 d006488:	18a5c83a 	sub	r18,r3,r2
 d00648c:	d8800f17 	ldw	r2,60(sp)
 d006490:	10026216 	blt	r2,zero,d006e1c <_dtoa_r+0x147c>
 d006494:	dc001117 	ldw	r16,68(sp)
 d006498:	1007883a 	mov	r3,r2
 d00649c:	d9800a17 	ldw	r6,40(sp)
 d0064a0:	d8801117 	ldw	r2,68(sp)
 d0064a4:	d9001617 	ldw	r4,88(sp)
 d0064a8:	30cd883a 	add	r6,r6,r3
 d0064ac:	10c5883a 	add	r2,r2,r3
 d0064b0:	01400044 	movi	r5,1
 d0064b4:	d9800a15 	stw	r6,40(sp)
 d0064b8:	d8801115 	stw	r2,68(sp)
 d0064bc:	d0096e00 	call	d0096e0 <__i2b>
 d0064c0:	1027883a 	mov	r19,r2
 d0064c4:	003f2506 	br	d00615c <_dtoa_r+0x7bc>
 d0064c8:	00c34174 	movhi	r3,3333
 d0064cc:	18f10304 	addi	r3,r3,-15348
 d0064d0:	003d6706 	br	d005a70 <_dtoa_r+0xd0>
 d0064d4:	dd800517 	ldw	r22,20(sp)
 d0064d8:	04000044 	movi	r16,1
 d0064dc:	00000706 	br	d0064fc <_dtoa_r+0xb5c>
 d0064e0:	d9400717 	ldw	r5,28(sp)
 d0064e4:	d9001617 	ldw	r4,88(sp)
 d0064e8:	01800284 	movi	r6,10
 d0064ec:	000f883a 	mov	r7,zero
 d0064f0:	d00971c0 	call	d00971c <__multadd>
 d0064f4:	d8800715 	stw	r2,28(sp)
 d0064f8:	84000044 	addi	r16,r16,1
 d0064fc:	d9000717 	ldw	r4,28(sp)
 d006500:	900b883a 	mov	r5,r18
 d006504:	d0057880 	call	d005788 <quorem>
 d006508:	15c00c04 	addi	r23,r2,48
 d00650c:	b5c00005 	stb	r23,0(r22)
 d006510:	d8c00f17 	ldw	r3,60(sp)
 d006514:	b5800044 	addi	r22,r22,1
 d006518:	80fff116 	blt	r16,r3,d0064e0 <_dtoa_r+0xb40>
 d00651c:	d8000615 	stw	zero,24(sp)
 d006520:	d9400717 	ldw	r5,28(sp)
 d006524:	d9001617 	ldw	r4,88(sp)
 d006528:	01800044 	movi	r6,1
 d00652c:	d0093ac0 	call	d0093ac <__lshift>
 d006530:	1009883a 	mov	r4,r2
 d006534:	900b883a 	mov	r5,r18
 d006538:	d8800715 	stw	r2,28(sp)
 d00653c:	d008bc40 	call	d008bc4 <__mcmp>
 d006540:	00803c0e 	bge	zero,r2,d006634 <_dtoa_r+0xc94>
 d006544:	b009883a 	mov	r4,r22
 d006548:	213fffc4 	addi	r4,r4,-1
 d00654c:	21400003 	ldbu	r5,0(r4)
 d006550:	00800e44 	movi	r2,57
 d006554:	28c03fcc 	andi	r3,r5,255
 d006558:	18c0201c 	xori	r3,r3,128
 d00655c:	18ffe004 	addi	r3,r3,-128
 d006560:	1881981e 	bne	r3,r2,d006bc4 <_dtoa_r+0x1224>
 d006564:	d9800517 	ldw	r6,20(sp)
 d006568:	21bff71e 	bne	r4,r6,d006548 <_dtoa_r+0xba8>
 d00656c:	d8800d17 	ldw	r2,52(sp)
 d006570:	37000044 	addi	fp,r6,1
 d006574:	10800044 	addi	r2,r2,1
 d006578:	d8800d15 	stw	r2,52(sp)
 d00657c:	00800c44 	movi	r2,49
 d006580:	30800005 	stb	r2,0(r6)
 d006584:	d9001617 	ldw	r4,88(sp)
 d006588:	900b883a 	mov	r5,r18
 d00658c:	d008a680 	call	d008a68 <_Bfree>
 d006590:	983ecd26 	beq	r19,zero,d0060c8 <_dtoa_r+0x728>
 d006594:	d8c00617 	ldw	r3,24(sp)
 d006598:	18000426 	beq	r3,zero,d0065ac <_dtoa_r+0xc0c>
 d00659c:	1cc00326 	beq	r3,r19,d0065ac <_dtoa_r+0xc0c>
 d0065a0:	d9001617 	ldw	r4,88(sp)
 d0065a4:	180b883a 	mov	r5,r3
 d0065a8:	d008a680 	call	d008a68 <_Bfree>
 d0065ac:	d9001617 	ldw	r4,88(sp)
 d0065b0:	980b883a 	mov	r5,r19
 d0065b4:	d008a680 	call	d008a68 <_Bfree>
 d0065b8:	003ec306 	br	d0060c8 <_dtoa_r+0x728>
 d0065bc:	1805883a 	mov	r2,r3
 d0065c0:	003eeb06 	br	d006170 <_dtoa_r+0x7d0>
 d0065c4:	d9800a17 	ldw	r6,40(sp)
 d0065c8:	d8c01117 	ldw	r3,68(sp)
 d0065cc:	20bfff04 	addi	r2,r4,-4
 d0065d0:	308d883a 	add	r6,r6,r2
 d0065d4:	1887883a 	add	r3,r3,r2
 d0065d8:	80a1883a 	add	r16,r16,r2
 d0065dc:	d9800a15 	stw	r6,40(sp)
 d0065e0:	d8c01115 	stw	r3,68(sp)
 d0065e4:	003f1d06 	br	d00625c <_dtoa_r+0x8bc>
 d0065e8:	a03f0c1e 	bne	r20,zero,d00621c <_dtoa_r+0x87c>
 d0065ec:	00800434 	movhi	r2,16
 d0065f0:	10bfffc4 	addi	r2,r2,-1
 d0065f4:	a884703a 	and	r2,r21,r2
 d0065f8:	103f081e 	bne	r2,zero,d00621c <_dtoa_r+0x87c>
 d0065fc:	a89ffc2c 	andhi	r2,r21,32752
 d006600:	103f0626 	beq	r2,zero,d00621c <_dtoa_r+0x87c>
 d006604:	d8c01117 	ldw	r3,68(sp)
 d006608:	d9000a17 	ldw	r4,40(sp)
 d00660c:	18c00044 	addi	r3,r3,1
 d006610:	21000044 	addi	r4,r4,1
 d006614:	d8c01115 	stw	r3,68(sp)
 d006618:	d9000a15 	stw	r4,40(sp)
 d00661c:	003f0006 	br	d006220 <_dtoa_r+0x880>
 d006620:	d9400717 	ldw	r5,28(sp)
 d006624:	d9001617 	ldw	r4,88(sp)
 d006628:	d00981c0 	call	d00981c <__pow5mult>
 d00662c:	d8800715 	stw	r2,28(sp)
 d006630:	003eed06 	br	d0061e8 <_dtoa_r+0x848>
 d006634:	1000021e 	bne	r2,zero,d006640 <_dtoa_r+0xca0>
 d006638:	b880004c 	andi	r2,r23,1
 d00663c:	103fc11e 	bne	r2,zero,d006544 <_dtoa_r+0xba4>
 d006640:	b5bfffc4 	addi	r22,r22,-1
 d006644:	b0c00007 	ldb	r3,0(r22)
 d006648:	00800c04 	movi	r2,48
 d00664c:	18bffc26 	beq	r3,r2,d006640 <_dtoa_r+0xca0>
 d006650:	b7000044 	addi	fp,r22,1
 d006654:	003fcb06 	br	d006584 <_dtoa_r+0xbe4>
 d006658:	d9800d17 	ldw	r6,52(sp)
 d00665c:	018fc83a 	sub	r7,zero,r6
 d006660:	3801f726 	beq	r7,zero,d006e40 <_dtoa_r+0x14a0>
 d006664:	398003cc 	andi	r6,r7,15
 d006668:	300c90fa 	slli	r6,r6,3
 d00666c:	01434174 	movhi	r5,3333
 d006670:	29712004 	addi	r5,r5,-15232
 d006674:	d9001217 	ldw	r4,72(sp)
 d006678:	314d883a 	add	r6,r6,r5
 d00667c:	30c00117 	ldw	r3,4(r6)
 d006680:	30800017 	ldw	r2,0(r6)
 d006684:	d9401317 	ldw	r5,76(sp)
 d006688:	3821d13a 	srai	r16,r7,4
 d00668c:	100d883a 	mov	r6,r2
 d006690:	180f883a 	mov	r7,r3
 d006694:	d00ba3c0 	call	d00ba3c <__muldf3>
 d006698:	1011883a 	mov	r8,r2
 d00669c:	1813883a 	mov	r9,r3
 d0066a0:	1029883a 	mov	r20,r2
 d0066a4:	182b883a 	mov	r21,r3
 d0066a8:	8001e526 	beq	r16,zero,d006e40 <_dtoa_r+0x14a0>
 d0066ac:	05800084 	movi	r22,2
 d0066b0:	04434174 	movhi	r17,3333
 d0066b4:	8c715204 	addi	r17,r17,-15032
 d0066b8:	8080004c 	andi	r2,r16,1
 d0066bc:	1005003a 	cmpeq	r2,r2,zero
 d0066c0:	1000081e 	bne	r2,zero,d0066e4 <_dtoa_r+0xd44>
 d0066c4:	89800017 	ldw	r6,0(r17)
 d0066c8:	89c00117 	ldw	r7,4(r17)
 d0066cc:	480b883a 	mov	r5,r9
 d0066d0:	4009883a 	mov	r4,r8
 d0066d4:	d00ba3c0 	call	d00ba3c <__muldf3>
 d0066d8:	1011883a 	mov	r8,r2
 d0066dc:	b5800044 	addi	r22,r22,1
 d0066e0:	1813883a 	mov	r9,r3
 d0066e4:	8021d07a 	srai	r16,r16,1
 d0066e8:	8c400204 	addi	r17,r17,8
 d0066ec:	803ff21e 	bne	r16,zero,d0066b8 <_dtoa_r+0xd18>
 d0066f0:	4029883a 	mov	r20,r8
 d0066f4:	482b883a 	mov	r21,r9
 d0066f8:	003dca06 	br	d005e24 <_dtoa_r+0x484>
 d0066fc:	d9000817 	ldw	r4,32(sp)
 d006700:	2005003a 	cmpeq	r2,r4,zero
 d006704:	1001f61e 	bne	r2,zero,d006ee0 <_dtoa_r+0x1540>
 d006708:	dc001117 	ldw	r16,68(sp)
 d00670c:	dc801017 	ldw	r18,64(sp)
 d006710:	18c10cc4 	addi	r3,r3,1075
 d006714:	003f6106 	br	d00649c <_dtoa_r+0xafc>
 d006718:	d8000b15 	stw	zero,44(sp)
 d00671c:	d9802617 	ldw	r6,152(sp)
 d006720:	d8c00d17 	ldw	r3,52(sp)
 d006724:	30800044 	addi	r2,r6,1
 d006728:	18ad883a 	add	r22,r3,r2
 d00672c:	b13fffc4 	addi	r4,r22,-1
 d006730:	d9000e15 	stw	r4,56(sp)
 d006734:	0581f60e 	bge	zero,r22,d006f10 <_dtoa_r+0x1570>
 d006738:	dd800f15 	stw	r22,60(sp)
 d00673c:	003f3006 	br	d006400 <_dtoa_r+0xa60>
 d006740:	d8000b15 	stw	zero,44(sp)
 d006744:	d9002617 	ldw	r4,152(sp)
 d006748:	0101eb0e 	bge	zero,r4,d006ef8 <_dtoa_r+0x1558>
 d00674c:	202d883a 	mov	r22,r4
 d006750:	d9000e15 	stw	r4,56(sp)
 d006754:	d9000f15 	stw	r4,60(sp)
 d006758:	003f2906 	br	d006400 <_dtoa_r+0xa60>
 d00675c:	01800044 	movi	r6,1
 d006760:	d9800b15 	stw	r6,44(sp)
 d006764:	003ff706 	br	d006744 <_dtoa_r+0xda4>
 d006768:	01000044 	movi	r4,1
 d00676c:	d9000b15 	stw	r4,44(sp)
 d006770:	003fea06 	br	d00671c <_dtoa_r+0xd7c>
 d006774:	04000c0e 	bge	zero,r16,d0067a8 <_dtoa_r+0xe08>
 d006778:	d9400717 	ldw	r5,28(sp)
 d00677c:	d9001617 	ldw	r4,88(sp)
 d006780:	01800044 	movi	r6,1
 d006784:	d0093ac0 	call	d0093ac <__lshift>
 d006788:	1009883a 	mov	r4,r2
 d00678c:	900b883a 	mov	r5,r18
 d006790:	d8800715 	stw	r2,28(sp)
 d006794:	d008bc40 	call	d008bc4 <__mcmp>
 d006798:	0081e00e 	bge	zero,r2,d006f1c <_dtoa_r+0x157c>
 d00679c:	bdc00044 	addi	r23,r23,1
 d0067a0:	00800e84 	movi	r2,58
 d0067a4:	b881a226 	beq	r23,r2,d006e30 <_dtoa_r+0x1490>
 d0067a8:	b7000044 	addi	fp,r22,1
 d0067ac:	b5c00005 	stb	r23,0(r22)
 d0067b0:	003f7406 	br	d006584 <_dtoa_r+0xbe4>
 d0067b4:	00800e44 	movi	r2,57
 d0067b8:	b8819d26 	beq	r23,r2,d006e30 <_dtoa_r+0x1490>
 d0067bc:	053ffa0e 	bge	zero,r20,d0067a8 <_dtoa_r+0xe08>
 d0067c0:	8dc00c44 	addi	r23,r17,49
 d0067c4:	003ff806 	br	d0067a8 <_dtoa_r+0xe08>
 d0067c8:	d9001617 	ldw	r4,88(sp)
 d0067cc:	a80b883a 	mov	r5,r21
 d0067d0:	04000044 	movi	r16,1
 d0067d4:	d008a680 	call	d008a68 <_Bfree>
 d0067d8:	003edf06 	br	d006358 <_dtoa_r+0x9b8>
 d0067dc:	d9001617 	ldw	r4,88(sp)
 d0067e0:	980b883a 	mov	r5,r19
 d0067e4:	01800284 	movi	r6,10
 d0067e8:	000f883a 	mov	r7,zero
 d0067ec:	d00971c0 	call	d00971c <__multadd>
 d0067f0:	1027883a 	mov	r19,r2
 d0067f4:	d8800615 	stw	r2,24(sp)
 d0067f8:	003ebb06 	br	d0062e8 <_dtoa_r+0x948>
 d0067fc:	d9801117 	ldw	r6,68(sp)
 d006800:	d8800d17 	ldw	r2,52(sp)
 d006804:	d8000915 	stw	zero,36(sp)
 d006808:	308dc83a 	sub	r6,r6,r2
 d00680c:	0087c83a 	sub	r3,zero,r2
 d006810:	d9801115 	stw	r6,68(sp)
 d006814:	d8c01015 	stw	r3,64(sp)
 d006818:	003cfe06 	br	d005c14 <_dtoa_r+0x274>
 d00681c:	018dc83a 	sub	r6,zero,r6
 d006820:	d9801115 	stw	r6,68(sp)
 d006824:	d8000a15 	stw	zero,40(sp)
 d006828:	003cf306 	br	d005bf8 <_dtoa_r+0x258>
 d00682c:	d9000d17 	ldw	r4,52(sp)
 d006830:	d00c3000 	call	d00c300 <__floatsidf>
 d006834:	880b883a 	mov	r5,r17
 d006838:	8009883a 	mov	r4,r16
 d00683c:	180f883a 	mov	r7,r3
 d006840:	100d883a 	mov	r6,r2
 d006844:	d00c0e00 	call	d00c0e0 <__nedf2>
 d006848:	103ce126 	beq	r2,zero,d005bd0 <_dtoa_r+0x230>
 d00684c:	d9800d17 	ldw	r6,52(sp)
 d006850:	31bfffc4 	addi	r6,r6,-1
 d006854:	d9800d15 	stw	r6,52(sp)
 d006858:	003cdd06 	br	d005bd0 <_dtoa_r+0x230>
 d00685c:	d9000717 	ldw	r4,28(sp)
 d006860:	900b883a 	mov	r5,r18
 d006864:	d008bc40 	call	d008bc4 <__mcmp>
 d006868:	103e8d0e 	bge	r2,zero,d0062a0 <_dtoa_r+0x900>
 d00686c:	d9400717 	ldw	r5,28(sp)
 d006870:	d9001617 	ldw	r4,88(sp)
 d006874:	01800284 	movi	r6,10
 d006878:	000f883a 	mov	r7,zero
 d00687c:	d00971c0 	call	d00971c <__multadd>
 d006880:	d9800d17 	ldw	r6,52(sp)
 d006884:	d8800715 	stw	r2,28(sp)
 d006888:	31bfffc4 	addi	r6,r6,-1
 d00688c:	d9800d15 	stw	r6,52(sp)
 d006890:	b001a71e 	bne	r22,zero,d006f30 <_dtoa_r+0x1590>
 d006894:	d8800e17 	ldw	r2,56(sp)
 d006898:	d8800f15 	stw	r2,60(sp)
 d00689c:	003e8006 	br	d0062a0 <_dtoa_r+0x900>
 d0068a0:	90800417 	ldw	r2,16(r18)
 d0068a4:	1085883a 	add	r2,r2,r2
 d0068a8:	1085883a 	add	r2,r2,r2
 d0068ac:	1485883a 	add	r2,r2,r18
 d0068b0:	11000417 	ldw	r4,16(r2)
 d0068b4:	d008a900 	call	d008a90 <__hi0bits>
 d0068b8:	00c00804 	movi	r3,32
 d0068bc:	1887c83a 	sub	r3,r3,r2
 d0068c0:	003e5a06 	br	d00622c <_dtoa_r+0x88c>
 d0068c4:	d9400717 	ldw	r5,28(sp)
 d0068c8:	d9801017 	ldw	r6,64(sp)
 d0068cc:	d9001617 	ldw	r4,88(sp)
 d0068d0:	d00981c0 	call	d00981c <__pow5mult>
 d0068d4:	d8800715 	stw	r2,28(sp)
 d0068d8:	003e4306 	br	d0061e8 <_dtoa_r+0x848>
 d0068dc:	d9800f17 	ldw	r6,60(sp)
 d0068e0:	d8800d17 	ldw	r2,52(sp)
 d0068e4:	d9800315 	stw	r6,12(sp)
 d0068e8:	d8800415 	stw	r2,16(sp)
 d0068ec:	d8c00b17 	ldw	r3,44(sp)
 d0068f0:	1805003a 	cmpeq	r2,r3,zero
 d0068f4:	1000e21e 	bne	r2,zero,d006c80 <_dtoa_r+0x12e0>
 d0068f8:	d9000317 	ldw	r4,12(sp)
 d0068fc:	0005883a 	mov	r2,zero
 d006900:	00cff834 	movhi	r3,16352
 d006904:	200c90fa 	slli	r6,r4,3
 d006908:	01034174 	movhi	r4,3333
 d00690c:	21312004 	addi	r4,r4,-15232
 d006910:	180b883a 	mov	r5,r3
 d006914:	310d883a 	add	r6,r6,r4
 d006918:	327fff17 	ldw	r9,-4(r6)
 d00691c:	323ffe17 	ldw	r8,-8(r6)
 d006920:	1009883a 	mov	r4,r2
 d006924:	480f883a 	mov	r7,r9
 d006928:	400d883a 	mov	r6,r8
 d00692c:	d00be000 	call	d00be00 <__divdf3>
 d006930:	180b883a 	mov	r5,r3
 d006934:	b00d883a 	mov	r6,r22
 d006938:	b80f883a 	mov	r7,r23
 d00693c:	1009883a 	mov	r4,r2
 d006940:	d00b9480 	call	d00b948 <__subdf3>
 d006944:	a80b883a 	mov	r5,r21
 d006948:	a009883a 	mov	r4,r20
 d00694c:	d8c01915 	stw	r3,100(sp)
 d006950:	d8801815 	stw	r2,96(sp)
 d006954:	d00c3f80 	call	d00c3f8 <__fixdfsi>
 d006958:	1009883a 	mov	r4,r2
 d00695c:	1027883a 	mov	r19,r2
 d006960:	d00c3000 	call	d00c300 <__floatsidf>
 d006964:	a80b883a 	mov	r5,r21
 d006968:	a009883a 	mov	r4,r20
 d00696c:	180f883a 	mov	r7,r3
 d006970:	100d883a 	mov	r6,r2
 d006974:	d00b9480 	call	d00b948 <__subdf3>
 d006978:	d9801817 	ldw	r6,96(sp)
 d00697c:	1823883a 	mov	r17,r3
 d006980:	d8801415 	stw	r2,80(sp)
 d006984:	302d883a 	mov	r22,r6
 d006988:	d9800517 	ldw	r6,20(sp)
 d00698c:	9cc00c04 	addi	r19,r19,48
 d006990:	dc401515 	stw	r17,84(sp)
 d006994:	d8c01917 	ldw	r3,100(sp)
 d006998:	34c00005 	stb	r19,0(r6)
 d00699c:	d8800517 	ldw	r2,20(sp)
 d0069a0:	d9401917 	ldw	r5,100(sp)
 d0069a4:	d9801417 	ldw	r6,80(sp)
 d0069a8:	b009883a 	mov	r4,r22
 d0069ac:	880f883a 	mov	r7,r17
 d0069b0:	182f883a 	mov	r23,r3
 d0069b4:	17000044 	addi	fp,r2,1
 d0069b8:	d00c1680 	call	d00c168 <__gtdf2>
 d0069bc:	00804e16 	blt	zero,r2,d006af8 <_dtoa_r+0x1158>
 d0069c0:	d9801417 	ldw	r6,80(sp)
 d0069c4:	0005883a 	mov	r2,zero
 d0069c8:	00cffc34 	movhi	r3,16368
 d0069cc:	180b883a 	mov	r5,r3
 d0069d0:	880f883a 	mov	r7,r17
 d0069d4:	1009883a 	mov	r4,r2
 d0069d8:	d00b9480 	call	d00b948 <__subdf3>
 d0069dc:	d9401917 	ldw	r5,100(sp)
 d0069e0:	180f883a 	mov	r7,r3
 d0069e4:	b009883a 	mov	r4,r22
 d0069e8:	100d883a 	mov	r6,r2
 d0069ec:	d00c1680 	call	d00c168 <__gtdf2>
 d0069f0:	00bda216 	blt	zero,r2,d00607c <_dtoa_r+0x6dc>
 d0069f4:	d8c00317 	ldw	r3,12(sp)
 d0069f8:	00800044 	movi	r2,1
 d0069fc:	10c01216 	blt	r2,r3,d006a48 <_dtoa_r+0x10a8>
 d006a00:	003d4506 	br	d005f18 <_dtoa_r+0x578>
 d006a04:	d9801417 	ldw	r6,80(sp)
 d006a08:	0005883a 	mov	r2,zero
 d006a0c:	00cffc34 	movhi	r3,16368
 d006a10:	180b883a 	mov	r5,r3
 d006a14:	880f883a 	mov	r7,r17
 d006a18:	1009883a 	mov	r4,r2
 d006a1c:	d00b9480 	call	d00b948 <__subdf3>
 d006a20:	d9c01b17 	ldw	r7,108(sp)
 d006a24:	180b883a 	mov	r5,r3
 d006a28:	1009883a 	mov	r4,r2
 d006a2c:	b00d883a 	mov	r6,r22
 d006a30:	d00c2780 	call	d00c278 <__ltdf2>
 d006a34:	103d9116 	blt	r2,zero,d00607c <_dtoa_r+0x6dc>
 d006a38:	d9800517 	ldw	r6,20(sp)
 d006a3c:	d9000317 	ldw	r4,12(sp)
 d006a40:	3105883a 	add	r2,r6,r4
 d006a44:	e0bd3426 	beq	fp,r2,d005f18 <_dtoa_r+0x578>
 d006a48:	04500934 	movhi	r17,16420
 d006a4c:	0021883a 	mov	r16,zero
 d006a50:	b80b883a 	mov	r5,r23
 d006a54:	b009883a 	mov	r4,r22
 d006a58:	800d883a 	mov	r6,r16
 d006a5c:	880f883a 	mov	r7,r17
 d006a60:	d00ba3c0 	call	d00ba3c <__muldf3>
 d006a64:	d9401517 	ldw	r5,84(sp)
 d006a68:	d9001417 	ldw	r4,80(sp)
 d006a6c:	880f883a 	mov	r7,r17
 d006a70:	000d883a 	mov	r6,zero
 d006a74:	d8801a15 	stw	r2,104(sp)
 d006a78:	d8c01b15 	stw	r3,108(sp)
 d006a7c:	d00ba3c0 	call	d00ba3c <__muldf3>
 d006a80:	180b883a 	mov	r5,r3
 d006a84:	1009883a 	mov	r4,r2
 d006a88:	1823883a 	mov	r17,r3
 d006a8c:	1021883a 	mov	r16,r2
 d006a90:	d00c3f80 	call	d00c3f8 <__fixdfsi>
 d006a94:	1009883a 	mov	r4,r2
 d006a98:	102b883a 	mov	r21,r2
 d006a9c:	d00c3000 	call	d00c300 <__floatsidf>
 d006aa0:	880b883a 	mov	r5,r17
 d006aa4:	8009883a 	mov	r4,r16
 d006aa8:	180f883a 	mov	r7,r3
 d006aac:	100d883a 	mov	r6,r2
 d006ab0:	d00b9480 	call	d00b948 <__subdf3>
 d006ab4:	1021883a 	mov	r16,r2
 d006ab8:	d9001b17 	ldw	r4,108(sp)
 d006abc:	1823883a 	mov	r17,r3
 d006ac0:	dc001415 	stw	r16,80(sp)
 d006ac4:	ad400c04 	addi	r21,r21,48
 d006ac8:	dc401515 	stw	r17,84(sp)
 d006acc:	d8801a17 	ldw	r2,104(sp)
 d006ad0:	e5400005 	stb	r21,0(fp)
 d006ad4:	202f883a 	mov	r23,r4
 d006ad8:	d9c01b17 	ldw	r7,108(sp)
 d006adc:	d9001417 	ldw	r4,80(sp)
 d006ae0:	880b883a 	mov	r5,r17
 d006ae4:	100d883a 	mov	r6,r2
 d006ae8:	102d883a 	mov	r22,r2
 d006aec:	e7000044 	addi	fp,fp,1
 d006af0:	d00c2780 	call	d00c278 <__ltdf2>
 d006af4:	103fc30e 	bge	r2,zero,d006a04 <_dtoa_r+0x1064>
 d006af8:	d9000417 	ldw	r4,16(sp)
 d006afc:	d9000d15 	stw	r4,52(sp)
 d006b00:	003d7106 	br	d0060c8 <_dtoa_r+0x728>
 d006b04:	d9801717 	ldw	r6,92(sp)
 d006b08:	00800084 	movi	r2,2
 d006b0c:	11bde60e 	bge	r2,r6,d0062a8 <_dtoa_r+0x908>
 d006b10:	203cfb1e 	bne	r4,zero,d005f00 <_dtoa_r+0x560>
 d006b14:	d9001617 	ldw	r4,88(sp)
 d006b18:	900b883a 	mov	r5,r18
 d006b1c:	01800144 	movi	r6,5
 d006b20:	000f883a 	mov	r7,zero
 d006b24:	d00971c0 	call	d00971c <__multadd>
 d006b28:	d9000717 	ldw	r4,28(sp)
 d006b2c:	100b883a 	mov	r5,r2
 d006b30:	1025883a 	mov	r18,r2
 d006b34:	d008bc40 	call	d008bc4 <__mcmp>
 d006b38:	00bcf10e 	bge	zero,r2,d005f00 <_dtoa_r+0x560>
 d006b3c:	d8c00d17 	ldw	r3,52(sp)
 d006b40:	d9000517 	ldw	r4,20(sp)
 d006b44:	d8000615 	stw	zero,24(sp)
 d006b48:	18c00044 	addi	r3,r3,1
 d006b4c:	d8c00d15 	stw	r3,52(sp)
 d006b50:	00800c44 	movi	r2,49
 d006b54:	27000044 	addi	fp,r4,1
 d006b58:	20800005 	stb	r2,0(r4)
 d006b5c:	003e8906 	br	d006584 <_dtoa_r+0xbe4>
 d006b60:	d8c00517 	ldw	r3,20(sp)
 d006b64:	003bc206 	br	d005a70 <_dtoa_r+0xd0>
 d006b68:	01834174 	movhi	r6,3333
 d006b6c:	31b15204 	addi	r6,r6,-15032
 d006b70:	30c00917 	ldw	r3,36(r6)
 d006b74:	30800817 	ldw	r2,32(r6)
 d006b78:	d9001217 	ldw	r4,72(sp)
 d006b7c:	d9401317 	ldw	r5,76(sp)
 d006b80:	180f883a 	mov	r7,r3
 d006b84:	100d883a 	mov	r6,r2
 d006b88:	d00be000 	call	d00be00 <__divdf3>
 d006b8c:	948003cc 	andi	r18,r18,15
 d006b90:	058000c4 	movi	r22,3
 d006b94:	1029883a 	mov	r20,r2
 d006b98:	182b883a 	mov	r21,r3
 d006b9c:	003c8906 	br	d005dc4 <_dtoa_r+0x424>
 d006ba0:	d9001017 	ldw	r4,64(sp)
 d006ba4:	d9800917 	ldw	r6,36(sp)
 d006ba8:	0025883a 	mov	r18,zero
 d006bac:	1105c83a 	sub	r2,r2,r4
 d006bb0:	2089883a 	add	r4,r4,r2
 d006bb4:	308d883a 	add	r6,r6,r2
 d006bb8:	d9001015 	stw	r4,64(sp)
 d006bbc:	d9800915 	stw	r6,36(sp)
 d006bc0:	003e3206 	br	d00648c <_dtoa_r+0xaec>
 d006bc4:	28800044 	addi	r2,r5,1
 d006bc8:	27000044 	addi	fp,r4,1
 d006bcc:	20800005 	stb	r2,0(r4)
 d006bd0:	003e6c06 	br	d006584 <_dtoa_r+0xbe4>
 d006bd4:	d8800f17 	ldw	r2,60(sp)
 d006bd8:	00bce016 	blt	zero,r2,d005f5c <_dtoa_r+0x5bc>
 d006bdc:	d9800f17 	ldw	r6,60(sp)
 d006be0:	303cc51e 	bne	r6,zero,d005ef8 <_dtoa_r+0x558>
 d006be4:	0005883a 	mov	r2,zero
 d006be8:	00d00534 	movhi	r3,16404
 d006bec:	980b883a 	mov	r5,r19
 d006bf0:	180f883a 	mov	r7,r3
 d006bf4:	9009883a 	mov	r4,r18
 d006bf8:	100d883a 	mov	r6,r2
 d006bfc:	d00ba3c0 	call	d00ba3c <__muldf3>
 d006c00:	180b883a 	mov	r5,r3
 d006c04:	a80f883a 	mov	r7,r21
 d006c08:	1009883a 	mov	r4,r2
 d006c0c:	a00d883a 	mov	r6,r20
 d006c10:	d00c1f00 	call	d00c1f0 <__gedf2>
 d006c14:	103cb80e 	bge	r2,zero,d005ef8 <_dtoa_r+0x558>
 d006c18:	0027883a 	mov	r19,zero
 d006c1c:	0025883a 	mov	r18,zero
 d006c20:	003fc606 	br	d006b3c <_dtoa_r+0x119c>
 d006c24:	99400117 	ldw	r5,4(r19)
 d006c28:	d9001617 	ldw	r4,88(sp)
 d006c2c:	d008fe80 	call	d008fe8 <_Balloc>
 d006c30:	99800417 	ldw	r6,16(r19)
 d006c34:	11000304 	addi	r4,r2,12
 d006c38:	99400304 	addi	r5,r19,12
 d006c3c:	318d883a 	add	r6,r6,r6
 d006c40:	318d883a 	add	r6,r6,r6
 d006c44:	31800204 	addi	r6,r6,8
 d006c48:	1023883a 	mov	r17,r2
 d006c4c:	d0027000 	call	d002700 <memcpy>
 d006c50:	d9001617 	ldw	r4,88(sp)
 d006c54:	880b883a 	mov	r5,r17
 d006c58:	01800044 	movi	r6,1
 d006c5c:	d0093ac0 	call	d0093ac <__lshift>
 d006c60:	100b883a 	mov	r5,r2
 d006c64:	003d9c06 	br	d0062d8 <_dtoa_r+0x938>
 d006c68:	00800e44 	movi	r2,57
 d006c6c:	b8807026 	beq	r23,r2,d006e30 <_dtoa_r+0x1490>
 d006c70:	b8800044 	addi	r2,r23,1
 d006c74:	b7000044 	addi	fp,r22,1
 d006c78:	b0800005 	stb	r2,0(r22)
 d006c7c:	003e4106 	br	d006584 <_dtoa_r+0xbe4>
 d006c80:	d8800317 	ldw	r2,12(sp)
 d006c84:	01834174 	movhi	r6,3333
 d006c88:	31b12004 	addi	r6,r6,-15232
 d006c8c:	b009883a 	mov	r4,r22
 d006c90:	100e90fa 	slli	r7,r2,3
 d006c94:	b80b883a 	mov	r5,r23
 d006c98:	398f883a 	add	r7,r7,r6
 d006c9c:	38bffe17 	ldw	r2,-8(r7)
 d006ca0:	d9800517 	ldw	r6,20(sp)
 d006ca4:	38ffff17 	ldw	r3,-4(r7)
 d006ca8:	37000044 	addi	fp,r6,1
 d006cac:	180f883a 	mov	r7,r3
 d006cb0:	100d883a 	mov	r6,r2
 d006cb4:	d00ba3c0 	call	d00ba3c <__muldf3>
 d006cb8:	a80b883a 	mov	r5,r21
 d006cbc:	a009883a 	mov	r4,r20
 d006cc0:	182f883a 	mov	r23,r3
 d006cc4:	102d883a 	mov	r22,r2
 d006cc8:	d00c3f80 	call	d00c3f8 <__fixdfsi>
 d006ccc:	1009883a 	mov	r4,r2
 d006cd0:	1027883a 	mov	r19,r2
 d006cd4:	d00c3000 	call	d00c300 <__floatsidf>
 d006cd8:	a80b883a 	mov	r5,r21
 d006cdc:	a009883a 	mov	r4,r20
 d006ce0:	180f883a 	mov	r7,r3
 d006ce4:	100d883a 	mov	r6,r2
 d006ce8:	d00b9480 	call	d00b948 <__subdf3>
 d006cec:	180b883a 	mov	r5,r3
 d006cf0:	d8c00517 	ldw	r3,20(sp)
 d006cf4:	9cc00c04 	addi	r19,r19,48
 d006cf8:	1009883a 	mov	r4,r2
 d006cfc:	1cc00005 	stb	r19,0(r3)
 d006d00:	2021883a 	mov	r16,r4
 d006d04:	d9000317 	ldw	r4,12(sp)
 d006d08:	00800044 	movi	r2,1
 d006d0c:	2823883a 	mov	r17,r5
 d006d10:	20802226 	beq	r4,r2,d006d9c <_dtoa_r+0x13fc>
 d006d14:	1029883a 	mov	r20,r2
 d006d18:	0005883a 	mov	r2,zero
 d006d1c:	00d00934 	movhi	r3,16420
 d006d20:	180f883a 	mov	r7,r3
 d006d24:	100d883a 	mov	r6,r2
 d006d28:	880b883a 	mov	r5,r17
 d006d2c:	8009883a 	mov	r4,r16
 d006d30:	d00ba3c0 	call	d00ba3c <__muldf3>
 d006d34:	180b883a 	mov	r5,r3
 d006d38:	1009883a 	mov	r4,r2
 d006d3c:	1823883a 	mov	r17,r3
 d006d40:	1021883a 	mov	r16,r2
 d006d44:	d00c3f80 	call	d00c3f8 <__fixdfsi>
 d006d48:	1009883a 	mov	r4,r2
 d006d4c:	102b883a 	mov	r21,r2
 d006d50:	d00c3000 	call	d00c300 <__floatsidf>
 d006d54:	880b883a 	mov	r5,r17
 d006d58:	8009883a 	mov	r4,r16
 d006d5c:	180f883a 	mov	r7,r3
 d006d60:	100d883a 	mov	r6,r2
 d006d64:	d00b9480 	call	d00b948 <__subdf3>
 d006d68:	180b883a 	mov	r5,r3
 d006d6c:	d8c00517 	ldw	r3,20(sp)
 d006d70:	1009883a 	mov	r4,r2
 d006d74:	ad400c04 	addi	r21,r21,48
 d006d78:	1d05883a 	add	r2,r3,r20
 d006d7c:	15400005 	stb	r21,0(r2)
 d006d80:	2021883a 	mov	r16,r4
 d006d84:	d9000317 	ldw	r4,12(sp)
 d006d88:	a5000044 	addi	r20,r20,1
 d006d8c:	2823883a 	mov	r17,r5
 d006d90:	a13fe11e 	bne	r20,r4,d006d18 <_dtoa_r+0x1378>
 d006d94:	e505883a 	add	r2,fp,r20
 d006d98:	173fffc4 	addi	fp,r2,-1
 d006d9c:	0025883a 	mov	r18,zero
 d006da0:	04cff834 	movhi	r19,16352
 d006da4:	b009883a 	mov	r4,r22
 d006da8:	b80b883a 	mov	r5,r23
 d006dac:	900d883a 	mov	r6,r18
 d006db0:	980f883a 	mov	r7,r19
 d006db4:	d00b9c80 	call	d00b9c8 <__adddf3>
 d006db8:	180b883a 	mov	r5,r3
 d006dbc:	1009883a 	mov	r4,r2
 d006dc0:	800d883a 	mov	r6,r16
 d006dc4:	880f883a 	mov	r7,r17
 d006dc8:	d00c2780 	call	d00c278 <__ltdf2>
 d006dcc:	103cab16 	blt	r2,zero,d00607c <_dtoa_r+0x6dc>
 d006dd0:	0009883a 	mov	r4,zero
 d006dd4:	980b883a 	mov	r5,r19
 d006dd8:	b80f883a 	mov	r7,r23
 d006ddc:	b00d883a 	mov	r6,r22
 d006de0:	d00b9480 	call	d00b948 <__subdf3>
 d006de4:	180b883a 	mov	r5,r3
 d006de8:	880f883a 	mov	r7,r17
 d006dec:	1009883a 	mov	r4,r2
 d006df0:	800d883a 	mov	r6,r16
 d006df4:	d00c1680 	call	d00c168 <__gtdf2>
 d006df8:	00bc470e 	bge	zero,r2,d005f18 <_dtoa_r+0x578>
 d006dfc:	00c00c04 	movi	r3,48
 d006e00:	e73fffc4 	addi	fp,fp,-1
 d006e04:	e0800007 	ldb	r2,0(fp)
 d006e08:	10fffd26 	beq	r2,r3,d006e00 <_dtoa_r+0x1460>
 d006e0c:	d9800417 	ldw	r6,16(sp)
 d006e10:	e7000044 	addi	fp,fp,1
 d006e14:	d9800d15 	stw	r6,52(sp)
 d006e18:	003cab06 	br	d0060c8 <_dtoa_r+0x728>
 d006e1c:	d8c00f17 	ldw	r3,60(sp)
 d006e20:	d9001117 	ldw	r4,68(sp)
 d006e24:	20e1c83a 	sub	r16,r4,r3
 d006e28:	0007883a 	mov	r3,zero
 d006e2c:	003d9b06 	br	d00649c <_dtoa_r+0xafc>
 d006e30:	00800e44 	movi	r2,57
 d006e34:	b0800005 	stb	r2,0(r22)
 d006e38:	b5800044 	addi	r22,r22,1
 d006e3c:	003dc106 	br	d006544 <_dtoa_r+0xba4>
 d006e40:	05800084 	movi	r22,2
 d006e44:	003bf706 	br	d005e24 <_dtoa_r+0x484>
 d006e48:	d9000f17 	ldw	r4,60(sp)
 d006e4c:	013c000e 	bge	zero,r4,d005e50 <_dtoa_r+0x4b0>
 d006e50:	d9800e17 	ldw	r6,56(sp)
 d006e54:	01bc300e 	bge	zero,r6,d005f18 <_dtoa_r+0x578>
 d006e58:	0005883a 	mov	r2,zero
 d006e5c:	00d00934 	movhi	r3,16420
 d006e60:	a80b883a 	mov	r5,r21
 d006e64:	180f883a 	mov	r7,r3
 d006e68:	a009883a 	mov	r4,r20
 d006e6c:	100d883a 	mov	r6,r2
 d006e70:	d00ba3c0 	call	d00ba3c <__muldf3>
 d006e74:	b1000044 	addi	r4,r22,1
 d006e78:	1021883a 	mov	r16,r2
 d006e7c:	1823883a 	mov	r17,r3
 d006e80:	d00c3000 	call	d00c300 <__floatsidf>
 d006e84:	880b883a 	mov	r5,r17
 d006e88:	8009883a 	mov	r4,r16
 d006e8c:	180f883a 	mov	r7,r3
 d006e90:	100d883a 	mov	r6,r2
 d006e94:	d00ba3c0 	call	d00ba3c <__muldf3>
 d006e98:	0011883a 	mov	r8,zero
 d006e9c:	02500734 	movhi	r9,16412
 d006ea0:	180b883a 	mov	r5,r3
 d006ea4:	480f883a 	mov	r7,r9
 d006ea8:	1009883a 	mov	r4,r2
 d006eac:	400d883a 	mov	r6,r8
 d006eb0:	d00b9c80 	call	d00b9c8 <__adddf3>
 d006eb4:	102d883a 	mov	r22,r2
 d006eb8:	00bf3034 	movhi	r2,64704
 d006ebc:	10ef883a 	add	r23,r2,r3
 d006ec0:	d8800d17 	ldw	r2,52(sp)
 d006ec4:	d8c00e17 	ldw	r3,56(sp)
 d006ec8:	8029883a 	mov	r20,r16
 d006ecc:	10bfffc4 	addi	r2,r2,-1
 d006ed0:	882b883a 	mov	r21,r17
 d006ed4:	d8800415 	stw	r2,16(sp)
 d006ed8:	d8c00315 	stw	r3,12(sp)
 d006edc:	003e8306 	br	d0068ec <_dtoa_r+0xf4c>
 d006ee0:	d8800117 	ldw	r2,4(sp)
 d006ee4:	dc001117 	ldw	r16,68(sp)
 d006ee8:	dc801017 	ldw	r18,64(sp)
 d006eec:	00c00d84 	movi	r3,54
 d006ef0:	1887c83a 	sub	r3,r3,r2
 d006ef4:	003d6906 	br	d00649c <_dtoa_r+0xafc>
 d006ef8:	01800044 	movi	r6,1
 d006efc:	3021883a 	mov	r16,r6
 d006f00:	d9800f15 	stw	r6,60(sp)
 d006f04:	d9802615 	stw	r6,152(sp)
 d006f08:	d9800e15 	stw	r6,56(sp)
 d006f0c:	003b9306 	br	d005d5c <_dtoa_r+0x3bc>
 d006f10:	b021883a 	mov	r16,r22
 d006f14:	dd800f15 	stw	r22,60(sp)
 d006f18:	003b9006 	br	d005d5c <_dtoa_r+0x3bc>
 d006f1c:	103e221e 	bne	r2,zero,d0067a8 <_dtoa_r+0xe08>
 d006f20:	b880004c 	andi	r2,r23,1
 d006f24:	1005003a 	cmpeq	r2,r2,zero
 d006f28:	103e1f1e 	bne	r2,zero,d0067a8 <_dtoa_r+0xe08>
 d006f2c:	003e1b06 	br	d00679c <_dtoa_r+0xdfc>
 d006f30:	d9001617 	ldw	r4,88(sp)
 d006f34:	980b883a 	mov	r5,r19
 d006f38:	01800284 	movi	r6,10
 d006f3c:	000f883a 	mov	r7,zero
 d006f40:	d00971c0 	call	d00971c <__multadd>
 d006f44:	d8c00e17 	ldw	r3,56(sp)
 d006f48:	1027883a 	mov	r19,r2
 d006f4c:	d8c00f15 	stw	r3,60(sp)
 d006f50:	003cd306 	br	d0062a0 <_dtoa_r+0x900>

0d006f54 <_fflush_r>:
 d006f54:	defffb04 	addi	sp,sp,-20
 d006f58:	dcc00315 	stw	r19,12(sp)
 d006f5c:	dc800215 	stw	r18,8(sp)
 d006f60:	dfc00415 	stw	ra,16(sp)
 d006f64:	dc400115 	stw	r17,4(sp)
 d006f68:	dc000015 	stw	r16,0(sp)
 d006f6c:	2027883a 	mov	r19,r4
 d006f70:	2825883a 	mov	r18,r5
 d006f74:	20000226 	beq	r4,zero,d006f80 <_fflush_r+0x2c>
 d006f78:	20800e17 	ldw	r2,56(r4)
 d006f7c:	10005626 	beq	r2,zero,d0070d8 <_fflush_r+0x184>
 d006f80:	9100030b 	ldhu	r4,12(r18)
 d006f84:	20ffffcc 	andi	r3,r4,65535
 d006f88:	18e0001c 	xori	r3,r3,32768
 d006f8c:	18e00004 	addi	r3,r3,-32768
 d006f90:	1880020c 	andi	r2,r3,8
 d006f94:	1000261e 	bne	r2,zero,d007030 <_fflush_r+0xdc>
 d006f98:	90c00117 	ldw	r3,4(r18)
 d006f9c:	20820014 	ori	r2,r4,2048
 d006fa0:	9080030d 	sth	r2,12(r18)
 d006fa4:	1009883a 	mov	r4,r2
 d006fa8:	00c0400e 	bge	zero,r3,d0070ac <_fflush_r+0x158>
 d006fac:	92000a17 	ldw	r8,40(r18)
 d006fb0:	40004026 	beq	r8,zero,d0070b4 <_fflush_r+0x160>
 d006fb4:	2084000c 	andi	r2,r4,4096
 d006fb8:	10005326 	beq	r2,zero,d007108 <_fflush_r+0x1b4>
 d006fbc:	94001417 	ldw	r16,80(r18)
 d006fc0:	9080030b 	ldhu	r2,12(r18)
 d006fc4:	1080010c 	andi	r2,r2,4
 d006fc8:	1000481e 	bne	r2,zero,d0070ec <_fflush_r+0x198>
 d006fcc:	91400717 	ldw	r5,28(r18)
 d006fd0:	9809883a 	mov	r4,r19
 d006fd4:	800d883a 	mov	r6,r16
 d006fd8:	000f883a 	mov	r7,zero
 d006fdc:	403ee83a 	callr	r8
 d006fe0:	8080261e 	bne	r16,r2,d00707c <_fflush_r+0x128>
 d006fe4:	9080030b 	ldhu	r2,12(r18)
 d006fe8:	91000417 	ldw	r4,16(r18)
 d006fec:	90000115 	stw	zero,4(r18)
 d006ff0:	10bdffcc 	andi	r2,r2,63487
 d006ff4:	10ffffcc 	andi	r3,r2,65535
 d006ff8:	18c4000c 	andi	r3,r3,4096
 d006ffc:	9080030d 	sth	r2,12(r18)
 d007000:	91000015 	stw	r4,0(r18)
 d007004:	18002b26 	beq	r3,zero,d0070b4 <_fflush_r+0x160>
 d007008:	0007883a 	mov	r3,zero
 d00700c:	1805883a 	mov	r2,r3
 d007010:	94001415 	stw	r16,80(r18)
 d007014:	dfc00417 	ldw	ra,16(sp)
 d007018:	dcc00317 	ldw	r19,12(sp)
 d00701c:	dc800217 	ldw	r18,8(sp)
 d007020:	dc400117 	ldw	r17,4(sp)
 d007024:	dc000017 	ldw	r16,0(sp)
 d007028:	dec00504 	addi	sp,sp,20
 d00702c:	f800283a 	ret
 d007030:	94400417 	ldw	r17,16(r18)
 d007034:	88001f26 	beq	r17,zero,d0070b4 <_fflush_r+0x160>
 d007038:	90800017 	ldw	r2,0(r18)
 d00703c:	18c000cc 	andi	r3,r3,3
 d007040:	94400015 	stw	r17,0(r18)
 d007044:	1461c83a 	sub	r16,r2,r17
 d007048:	18002526 	beq	r3,zero,d0070e0 <_fflush_r+0x18c>
 d00704c:	0005883a 	mov	r2,zero
 d007050:	90800215 	stw	r2,8(r18)
 d007054:	0400170e 	bge	zero,r16,d0070b4 <_fflush_r+0x160>
 d007058:	90c00917 	ldw	r3,36(r18)
 d00705c:	91400717 	ldw	r5,28(r18)
 d007060:	880d883a 	mov	r6,r17
 d007064:	800f883a 	mov	r7,r16
 d007068:	9809883a 	mov	r4,r19
 d00706c:	183ee83a 	callr	r3
 d007070:	88a3883a 	add	r17,r17,r2
 d007074:	80a1c83a 	sub	r16,r16,r2
 d007078:	00bff616 	blt	zero,r2,d007054 <_fflush_r+0x100>
 d00707c:	9080030b 	ldhu	r2,12(r18)
 d007080:	00ffffc4 	movi	r3,-1
 d007084:	10801014 	ori	r2,r2,64
 d007088:	9080030d 	sth	r2,12(r18)
 d00708c:	1805883a 	mov	r2,r3
 d007090:	dfc00417 	ldw	ra,16(sp)
 d007094:	dcc00317 	ldw	r19,12(sp)
 d007098:	dc800217 	ldw	r18,8(sp)
 d00709c:	dc400117 	ldw	r17,4(sp)
 d0070a0:	dc000017 	ldw	r16,0(sp)
 d0070a4:	dec00504 	addi	sp,sp,20
 d0070a8:	f800283a 	ret
 d0070ac:	90800f17 	ldw	r2,60(r18)
 d0070b0:	00bfbe16 	blt	zero,r2,d006fac <_fflush_r+0x58>
 d0070b4:	0007883a 	mov	r3,zero
 d0070b8:	1805883a 	mov	r2,r3
 d0070bc:	dfc00417 	ldw	ra,16(sp)
 d0070c0:	dcc00317 	ldw	r19,12(sp)
 d0070c4:	dc800217 	ldw	r18,8(sp)
 d0070c8:	dc400117 	ldw	r17,4(sp)
 d0070cc:	dc000017 	ldw	r16,0(sp)
 d0070d0:	dec00504 	addi	sp,sp,20
 d0070d4:	f800283a 	ret
 d0070d8:	d0071ec0 	call	d0071ec <__sinit>
 d0070dc:	003fa806 	br	d006f80 <_fflush_r+0x2c>
 d0070e0:	90800517 	ldw	r2,20(r18)
 d0070e4:	90800215 	stw	r2,8(r18)
 d0070e8:	003fda06 	br	d007054 <_fflush_r+0x100>
 d0070ec:	90800117 	ldw	r2,4(r18)
 d0070f0:	90c00c17 	ldw	r3,48(r18)
 d0070f4:	80a1c83a 	sub	r16,r16,r2
 d0070f8:	183fb426 	beq	r3,zero,d006fcc <_fflush_r+0x78>
 d0070fc:	90800f17 	ldw	r2,60(r18)
 d007100:	80a1c83a 	sub	r16,r16,r2
 d007104:	003fb106 	br	d006fcc <_fflush_r+0x78>
 d007108:	91400717 	ldw	r5,28(r18)
 d00710c:	9809883a 	mov	r4,r19
 d007110:	000d883a 	mov	r6,zero
 d007114:	01c00044 	movi	r7,1
 d007118:	403ee83a 	callr	r8
 d00711c:	1021883a 	mov	r16,r2
 d007120:	00bfffc4 	movi	r2,-1
 d007124:	80800226 	beq	r16,r2,d007130 <_fflush_r+0x1dc>
 d007128:	92000a17 	ldw	r8,40(r18)
 d00712c:	003fa406 	br	d006fc0 <_fflush_r+0x6c>
 d007130:	98c00017 	ldw	r3,0(r19)
 d007134:	00800744 	movi	r2,29
 d007138:	18bfde26 	beq	r3,r2,d0070b4 <_fflush_r+0x160>
 d00713c:	9080030b 	ldhu	r2,12(r18)
 d007140:	8007883a 	mov	r3,r16
 d007144:	10801014 	ori	r2,r2,64
 d007148:	9080030d 	sth	r2,12(r18)
 d00714c:	003fcf06 	br	d00708c <_fflush_r+0x138>

0d007150 <fflush>:
 d007150:	01434034 	movhi	r5,3328
 d007154:	295bd504 	addi	r5,r5,28500
 d007158:	2007883a 	mov	r3,r4
 d00715c:	20000526 	beq	r4,zero,d007174 <fflush+0x24>
 d007160:	00834174 	movhi	r2,3333
 d007164:	108a2204 	addi	r2,r2,10376
 d007168:	11000017 	ldw	r4,0(r2)
 d00716c:	180b883a 	mov	r5,r3
 d007170:	d006f541 	jmpi	d006f54 <_fflush_r>
 d007174:	00834174 	movhi	r2,3333
 d007178:	108a2304 	addi	r2,r2,10380
 d00717c:	11000017 	ldw	r4,0(r2)
 d007180:	d007e6c1 	jmpi	d007e6c <_fwalk_reent>

0d007184 <std>:
 d007184:	00834074 	movhi	r2,3329
 d007188:	10a8c404 	addi	r2,r2,-23792
 d00718c:	20800b15 	stw	r2,44(r4)
 d007190:	00834074 	movhi	r2,3329
 d007194:	10a8ff04 	addi	r2,r2,-23556
 d007198:	20800815 	stw	r2,32(r4)
 d00719c:	00c34074 	movhi	r3,3329
 d0071a0:	18e8e004 	addi	r3,r3,-23680
 d0071a4:	00834074 	movhi	r2,3329
 d0071a8:	10a8c604 	addi	r2,r2,-23784
 d0071ac:	2140030d 	sth	r5,12(r4)
 d0071b0:	2180038d 	sth	r6,14(r4)
 d0071b4:	20c00915 	stw	r3,36(r4)
 d0071b8:	20800a15 	stw	r2,40(r4)
 d0071bc:	20000015 	stw	zero,0(r4)
 d0071c0:	20000115 	stw	zero,4(r4)
 d0071c4:	20000215 	stw	zero,8(r4)
 d0071c8:	20000415 	stw	zero,16(r4)
 d0071cc:	20000515 	stw	zero,20(r4)
 d0071d0:	20000615 	stw	zero,24(r4)
 d0071d4:	21000715 	stw	r4,28(r4)
 d0071d8:	f800283a 	ret

0d0071dc <__sfp_lock_acquire>:
 d0071dc:	f800283a 	ret

0d0071e0 <__sfp_lock_release>:
 d0071e0:	f800283a 	ret

0d0071e4 <__sinit_lock_acquire>:
 d0071e4:	f800283a 	ret

0d0071e8 <__sinit_lock_release>:
 d0071e8:	f800283a 	ret

0d0071ec <__sinit>:
 d0071ec:	20800e17 	ldw	r2,56(r4)
 d0071f0:	defffd04 	addi	sp,sp,-12
 d0071f4:	dc400115 	stw	r17,4(sp)
 d0071f8:	dc000015 	stw	r16,0(sp)
 d0071fc:	dfc00215 	stw	ra,8(sp)
 d007200:	04400044 	movi	r17,1
 d007204:	01400104 	movi	r5,4
 d007208:	000d883a 	mov	r6,zero
 d00720c:	2021883a 	mov	r16,r4
 d007210:	2200bb04 	addi	r8,r4,748
 d007214:	200f883a 	mov	r7,r4
 d007218:	10000526 	beq	r2,zero,d007230 <__sinit+0x44>
 d00721c:	dfc00217 	ldw	ra,8(sp)
 d007220:	dc400117 	ldw	r17,4(sp)
 d007224:	dc000017 	ldw	r16,0(sp)
 d007228:	dec00304 	addi	sp,sp,12
 d00722c:	f800283a 	ret
 d007230:	21000117 	ldw	r4,4(r4)
 d007234:	00834034 	movhi	r2,3328
 d007238:	109cb404 	addi	r2,r2,29392
 d00723c:	00c000c4 	movi	r3,3
 d007240:	80800f15 	stw	r2,60(r16)
 d007244:	80c0b915 	stw	r3,740(r16)
 d007248:	8200ba15 	stw	r8,744(r16)
 d00724c:	84400e15 	stw	r17,56(r16)
 d007250:	8000b815 	stw	zero,736(r16)
 d007254:	d0071840 	call	d007184 <std>
 d007258:	81000217 	ldw	r4,8(r16)
 d00725c:	880d883a 	mov	r6,r17
 d007260:	800f883a 	mov	r7,r16
 d007264:	01400284 	movi	r5,10
 d007268:	d0071840 	call	d007184 <std>
 d00726c:	81000317 	ldw	r4,12(r16)
 d007270:	800f883a 	mov	r7,r16
 d007274:	01400484 	movi	r5,18
 d007278:	01800084 	movi	r6,2
 d00727c:	dfc00217 	ldw	ra,8(sp)
 d007280:	dc400117 	ldw	r17,4(sp)
 d007284:	dc000017 	ldw	r16,0(sp)
 d007288:	dec00304 	addi	sp,sp,12
 d00728c:	d0071841 	jmpi	d007184 <std>

0d007290 <__fp_lock>:
 d007290:	0005883a 	mov	r2,zero
 d007294:	f800283a 	ret

0d007298 <__fp_unlock>:
 d007298:	0005883a 	mov	r2,zero
 d00729c:	f800283a 	ret

0d0072a0 <__fp_unlock_all>:
 d0072a0:	00834174 	movhi	r2,3333
 d0072a4:	108a2204 	addi	r2,r2,10376
 d0072a8:	11000017 	ldw	r4,0(r2)
 d0072ac:	01434034 	movhi	r5,3328
 d0072b0:	295ca604 	addi	r5,r5,29336
 d0072b4:	d007f341 	jmpi	d007f34 <_fwalk>

0d0072b8 <__fp_lock_all>:
 d0072b8:	00834174 	movhi	r2,3333
 d0072bc:	108a2204 	addi	r2,r2,10376
 d0072c0:	11000017 	ldw	r4,0(r2)
 d0072c4:	01434034 	movhi	r5,3328
 d0072c8:	295ca404 	addi	r5,r5,29328
 d0072cc:	d007f341 	jmpi	d007f34 <_fwalk>

0d0072d0 <_cleanup_r>:
 d0072d0:	01434074 	movhi	r5,3329
 d0072d4:	2969f104 	addi	r5,r5,-22588
 d0072d8:	d007f341 	jmpi	d007f34 <_fwalk>

0d0072dc <_cleanup>:
 d0072dc:	00834174 	movhi	r2,3333
 d0072e0:	108a2304 	addi	r2,r2,10380
 d0072e4:	11000017 	ldw	r4,0(r2)
 d0072e8:	d0072d01 	jmpi	d0072d0 <_cleanup_r>

0d0072ec <__sfmoreglue>:
 d0072ec:	defffc04 	addi	sp,sp,-16
 d0072f0:	dc400115 	stw	r17,4(sp)
 d0072f4:	2c401724 	muli	r17,r5,92
 d0072f8:	dc800215 	stw	r18,8(sp)
 d0072fc:	2825883a 	mov	r18,r5
 d007300:	89400304 	addi	r5,r17,12
 d007304:	dc000015 	stw	r16,0(sp)
 d007308:	dfc00315 	stw	ra,12(sp)
 d00730c:	d0082440 	call	d008244 <_malloc_r>
 d007310:	0021883a 	mov	r16,zero
 d007314:	880d883a 	mov	r6,r17
 d007318:	000b883a 	mov	r5,zero
 d00731c:	10000626 	beq	r2,zero,d007338 <__sfmoreglue+0x4c>
 d007320:	11000304 	addi	r4,r2,12
 d007324:	14800115 	stw	r18,4(r2)
 d007328:	10000015 	stw	zero,0(r2)
 d00732c:	11000215 	stw	r4,8(r2)
 d007330:	1021883a 	mov	r16,r2
 d007334:	d0028800 	call	d002880 <memset>
 d007338:	8005883a 	mov	r2,r16
 d00733c:	dfc00317 	ldw	ra,12(sp)
 d007340:	dc800217 	ldw	r18,8(sp)
 d007344:	dc400117 	ldw	r17,4(sp)
 d007348:	dc000017 	ldw	r16,0(sp)
 d00734c:	dec00404 	addi	sp,sp,16
 d007350:	f800283a 	ret

0d007354 <__sfp>:
 d007354:	defffd04 	addi	sp,sp,-12
 d007358:	00834174 	movhi	r2,3333
 d00735c:	108a2304 	addi	r2,r2,10380
 d007360:	dc000015 	stw	r16,0(sp)
 d007364:	14000017 	ldw	r16,0(r2)
 d007368:	dc400115 	stw	r17,4(sp)
 d00736c:	dfc00215 	stw	ra,8(sp)
 d007370:	80800e17 	ldw	r2,56(r16)
 d007374:	2023883a 	mov	r17,r4
 d007378:	10002626 	beq	r2,zero,d007414 <__sfp+0xc0>
 d00737c:	8400b804 	addi	r16,r16,736
 d007380:	80800117 	ldw	r2,4(r16)
 d007384:	81000217 	ldw	r4,8(r16)
 d007388:	10ffffc4 	addi	r3,r2,-1
 d00738c:	18000916 	blt	r3,zero,d0073b4 <__sfp+0x60>
 d007390:	2080030f 	ldh	r2,12(r4)
 d007394:	10000b26 	beq	r2,zero,d0073c4 <__sfp+0x70>
 d007398:	017fffc4 	movi	r5,-1
 d00739c:	00000206 	br	d0073a8 <__sfp+0x54>
 d0073a0:	2080030f 	ldh	r2,12(r4)
 d0073a4:	10000726 	beq	r2,zero,d0073c4 <__sfp+0x70>
 d0073a8:	18ffffc4 	addi	r3,r3,-1
 d0073ac:	21001704 	addi	r4,r4,92
 d0073b0:	197ffb1e 	bne	r3,r5,d0073a0 <__sfp+0x4c>
 d0073b4:	80800017 	ldw	r2,0(r16)
 d0073b8:	10001926 	beq	r2,zero,d007420 <__sfp+0xcc>
 d0073bc:	1021883a 	mov	r16,r2
 d0073c0:	003fef06 	br	d007380 <__sfp+0x2c>
 d0073c4:	00bfffc4 	movi	r2,-1
 d0073c8:	00c00044 	movi	r3,1
 d0073cc:	2080038d 	sth	r2,14(r4)
 d0073d0:	20c0030d 	sth	r3,12(r4)
 d0073d4:	20000015 	stw	zero,0(r4)
 d0073d8:	20000215 	stw	zero,8(r4)
 d0073dc:	20000115 	stw	zero,4(r4)
 d0073e0:	20000415 	stw	zero,16(r4)
 d0073e4:	20000515 	stw	zero,20(r4)
 d0073e8:	20000615 	stw	zero,24(r4)
 d0073ec:	20000c15 	stw	zero,48(r4)
 d0073f0:	20000d15 	stw	zero,52(r4)
 d0073f4:	20001115 	stw	zero,68(r4)
 d0073f8:	20001215 	stw	zero,72(r4)
 d0073fc:	2005883a 	mov	r2,r4
 d007400:	dfc00217 	ldw	ra,8(sp)
 d007404:	dc400117 	ldw	r17,4(sp)
 d007408:	dc000017 	ldw	r16,0(sp)
 d00740c:	dec00304 	addi	sp,sp,12
 d007410:	f800283a 	ret
 d007414:	8009883a 	mov	r4,r16
 d007418:	d0071ec0 	call	d0071ec <__sinit>
 d00741c:	003fd706 	br	d00737c <__sfp+0x28>
 d007420:	8809883a 	mov	r4,r17
 d007424:	01400104 	movi	r5,4
 d007428:	d0072ec0 	call	d0072ec <__sfmoreglue>
 d00742c:	80800015 	stw	r2,0(r16)
 d007430:	103fe21e 	bne	r2,zero,d0073bc <__sfp+0x68>
 d007434:	00800304 	movi	r2,12
 d007438:	0009883a 	mov	r4,zero
 d00743c:	88800015 	stw	r2,0(r17)
 d007440:	003fee06 	br	d0073fc <__sfp+0xa8>

0d007444 <fputc>:
 d007444:	defffc04 	addi	sp,sp,-16
 d007448:	dc800215 	stw	r18,8(sp)
 d00744c:	04834174 	movhi	r18,3333
 d007450:	948a2204 	addi	r18,r18,10376
 d007454:	90c00017 	ldw	r3,0(r18)
 d007458:	dc400115 	stw	r17,4(sp)
 d00745c:	dc000015 	stw	r16,0(sp)
 d007460:	dfc00315 	stw	ra,12(sp)
 d007464:	2021883a 	mov	r16,r4
 d007468:	2823883a 	mov	r17,r5
 d00746c:	18000326 	beq	r3,zero,d00747c <fputc+0x38>
 d007470:	18800e17 	ldw	r2,56(r3)
 d007474:	1809883a 	mov	r4,r3
 d007478:	10000926 	beq	r2,zero,d0074a0 <fputc+0x5c>
 d00747c:	91000017 	ldw	r4,0(r18)
 d007480:	800b883a 	mov	r5,r16
 d007484:	880d883a 	mov	r6,r17
 d007488:	dfc00317 	ldw	ra,12(sp)
 d00748c:	dc800217 	ldw	r18,8(sp)
 d007490:	dc400117 	ldw	r17,4(sp)
 d007494:	dc000017 	ldw	r16,0(sp)
 d007498:	dec00404 	addi	sp,sp,16
 d00749c:	d002b141 	jmpi	d002b14 <_putc_r>
 d0074a0:	d0071ec0 	call	d0071ec <__sinit>
 d0074a4:	003ff506 	br	d00747c <fputc+0x38>

0d0074a8 <_fputc_r>:
 d0074a8:	defffc04 	addi	sp,sp,-16
 d0074ac:	dc800215 	stw	r18,8(sp)
 d0074b0:	dc400115 	stw	r17,4(sp)
 d0074b4:	dc000015 	stw	r16,0(sp)
 d0074b8:	dfc00315 	stw	ra,12(sp)
 d0074bc:	2021883a 	mov	r16,r4
 d0074c0:	2823883a 	mov	r17,r5
 d0074c4:	3025883a 	mov	r18,r6
 d0074c8:	20000226 	beq	r4,zero,d0074d4 <_fputc_r+0x2c>
 d0074cc:	20800e17 	ldw	r2,56(r4)
 d0074d0:	10000926 	beq	r2,zero,d0074f8 <_fputc_r+0x50>
 d0074d4:	8009883a 	mov	r4,r16
 d0074d8:	880b883a 	mov	r5,r17
 d0074dc:	900d883a 	mov	r6,r18
 d0074e0:	dfc00317 	ldw	ra,12(sp)
 d0074e4:	dc800217 	ldw	r18,8(sp)
 d0074e8:	dc400117 	ldw	r17,4(sp)
 d0074ec:	dc000017 	ldw	r16,0(sp)
 d0074f0:	dec00404 	addi	sp,sp,16
 d0074f4:	d002b141 	jmpi	d002b14 <_putc_r>
 d0074f8:	d0071ec0 	call	d0071ec <__sinit>
 d0074fc:	003ff506 	br	d0074d4 <_fputc_r+0x2c>

0d007500 <_fputs_r>:
 d007500:	defff804 	addi	sp,sp,-32
 d007504:	dc000515 	stw	r16,20(sp)
 d007508:	2021883a 	mov	r16,r4
 d00750c:	2809883a 	mov	r4,r5
 d007510:	dc400615 	stw	r17,24(sp)
 d007514:	dfc00715 	stw	ra,28(sp)
 d007518:	3023883a 	mov	r17,r6
 d00751c:	d9400015 	stw	r5,0(sp)
 d007520:	d00355c0 	call	d00355c <strlen>
 d007524:	00c00044 	movi	r3,1
 d007528:	d8800115 	stw	r2,4(sp)
 d00752c:	d8c00315 	stw	r3,12(sp)
 d007530:	d8800415 	stw	r2,16(sp)
 d007534:	dec00215 	stw	sp,8(sp)
 d007538:	80000326 	beq	r16,zero,d007548 <_fputs_r+0x48>
 d00753c:	80800e17 	ldw	r2,56(r16)
 d007540:	8009883a 	mov	r4,r16
 d007544:	10000926 	beq	r2,zero,d00756c <_fputs_r+0x6c>
 d007548:	8009883a 	mov	r4,r16
 d00754c:	880b883a 	mov	r5,r17
 d007550:	d9800204 	addi	r6,sp,8
 d007554:	d0079d00 	call	d0079d0 <__sfvwrite_r>
 d007558:	dfc00717 	ldw	ra,28(sp)
 d00755c:	dc400617 	ldw	r17,24(sp)
 d007560:	dc000517 	ldw	r16,20(sp)
 d007564:	dec00804 	addi	sp,sp,32
 d007568:	f800283a 	ret
 d00756c:	d0071ec0 	call	d0071ec <__sinit>
 d007570:	003ff506 	br	d007548 <_fputs_r+0x48>

0d007574 <fputs>:
 d007574:	01834174 	movhi	r6,3333
 d007578:	318a2204 	addi	r6,r6,10376
 d00757c:	2007883a 	mov	r3,r4
 d007580:	31000017 	ldw	r4,0(r6)
 d007584:	280d883a 	mov	r6,r5
 d007588:	180b883a 	mov	r5,r3
 d00758c:	d0075001 	jmpi	d007500 <_fputs_r>

0d007590 <_malloc_trim_r>:
 d007590:	defffb04 	addi	sp,sp,-20
 d007594:	dcc00315 	stw	r19,12(sp)
 d007598:	04c34174 	movhi	r19,3333
 d00759c:	9cc37b04 	addi	r19,r19,3564
 d0075a0:	dc800215 	stw	r18,8(sp)
 d0075a4:	dc400115 	stw	r17,4(sp)
 d0075a8:	dc000015 	stw	r16,0(sp)
 d0075ac:	2823883a 	mov	r17,r5
 d0075b0:	2025883a 	mov	r18,r4
 d0075b4:	dfc00415 	stw	ra,16(sp)
 d0075b8:	d00d4dc0 	call	d00d4dc <__malloc_lock>
 d0075bc:	98800217 	ldw	r2,8(r19)
 d0075c0:	9009883a 	mov	r4,r18
 d0075c4:	000b883a 	mov	r5,zero
 d0075c8:	10c00117 	ldw	r3,4(r2)
 d0075cc:	00bfff04 	movi	r2,-4
 d0075d0:	18a0703a 	and	r16,r3,r2
 d0075d4:	8463c83a 	sub	r17,r16,r17
 d0075d8:	8c43fbc4 	addi	r17,r17,4079
 d0075dc:	8822d33a 	srli	r17,r17,12
 d0075e0:	0083ffc4 	movi	r2,4095
 d0075e4:	8c7fffc4 	addi	r17,r17,-1
 d0075e8:	8822933a 	slli	r17,r17,12
 d0075ec:	1440060e 	bge	r2,r17,d007608 <_malloc_trim_r+0x78>
 d0075f0:	d00a2a00 	call	d00a2a0 <_sbrk_r>
 d0075f4:	98c00217 	ldw	r3,8(r19)
 d0075f8:	9009883a 	mov	r4,r18
 d0075fc:	044bc83a 	sub	r5,zero,r17
 d007600:	80c7883a 	add	r3,r16,r3
 d007604:	10c00926 	beq	r2,r3,d00762c <_malloc_trim_r+0x9c>
 d007608:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d00760c:	0005883a 	mov	r2,zero
 d007610:	dfc00417 	ldw	ra,16(sp)
 d007614:	dcc00317 	ldw	r19,12(sp)
 d007618:	dc800217 	ldw	r18,8(sp)
 d00761c:	dc400117 	ldw	r17,4(sp)
 d007620:	dc000017 	ldw	r16,0(sp)
 d007624:	dec00504 	addi	sp,sp,20
 d007628:	f800283a 	ret
 d00762c:	9009883a 	mov	r4,r18
 d007630:	d00a2a00 	call	d00a2a0 <_sbrk_r>
 d007634:	844dc83a 	sub	r6,r16,r17
 d007638:	00ffffc4 	movi	r3,-1
 d00763c:	9009883a 	mov	r4,r18
 d007640:	000b883a 	mov	r5,zero
 d007644:	01c34174 	movhi	r7,3333
 d007648:	39cc7a04 	addi	r7,r7,12776
 d00764c:	31800054 	ori	r6,r6,1
 d007650:	10c00926 	beq	r2,r3,d007678 <_malloc_trim_r+0xe8>
 d007654:	38800017 	ldw	r2,0(r7)
 d007658:	98c00217 	ldw	r3,8(r19)
 d00765c:	9009883a 	mov	r4,r18
 d007660:	1445c83a 	sub	r2,r2,r17
 d007664:	38800015 	stw	r2,0(r7)
 d007668:	19800115 	stw	r6,4(r3)
 d00766c:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d007670:	00800044 	movi	r2,1
 d007674:	003fe606 	br	d007610 <_malloc_trim_r+0x80>
 d007678:	d00a2a00 	call	d00a2a0 <_sbrk_r>
 d00767c:	99800217 	ldw	r6,8(r19)
 d007680:	100f883a 	mov	r7,r2
 d007684:	9009883a 	mov	r4,r18
 d007688:	1187c83a 	sub	r3,r2,r6
 d00768c:	008003c4 	movi	r2,15
 d007690:	19400054 	ori	r5,r3,1
 d007694:	10ffdc0e 	bge	r2,r3,d007608 <_malloc_trim_r+0x78>
 d007698:	00834174 	movhi	r2,3333
 d00769c:	108a2704 	addi	r2,r2,10396
 d0076a0:	10c00017 	ldw	r3,0(r2)
 d0076a4:	00834174 	movhi	r2,3333
 d0076a8:	108c7a04 	addi	r2,r2,12776
 d0076ac:	31400115 	stw	r5,4(r6)
 d0076b0:	38c7c83a 	sub	r3,r7,r3
 d0076b4:	10c00015 	stw	r3,0(r2)
 d0076b8:	003fd306 	br	d007608 <_malloc_trim_r+0x78>

0d0076bc <_free_r>:
 d0076bc:	defffd04 	addi	sp,sp,-12
 d0076c0:	dc400115 	stw	r17,4(sp)
 d0076c4:	dc000015 	stw	r16,0(sp)
 d0076c8:	dfc00215 	stw	ra,8(sp)
 d0076cc:	2821883a 	mov	r16,r5
 d0076d0:	2023883a 	mov	r17,r4
 d0076d4:	28005a26 	beq	r5,zero,d007840 <_free_r+0x184>
 d0076d8:	d00d4dc0 	call	d00d4dc <__malloc_lock>
 d0076dc:	823ffe04 	addi	r8,r16,-8
 d0076e0:	41400117 	ldw	r5,4(r8)
 d0076e4:	00bfff84 	movi	r2,-2
 d0076e8:	02834174 	movhi	r10,3333
 d0076ec:	52837b04 	addi	r10,r10,3564
 d0076f0:	288e703a 	and	r7,r5,r2
 d0076f4:	41cd883a 	add	r6,r8,r7
 d0076f8:	30c00117 	ldw	r3,4(r6)
 d0076fc:	51000217 	ldw	r4,8(r10)
 d007700:	00bfff04 	movi	r2,-4
 d007704:	1892703a 	and	r9,r3,r2
 d007708:	5017883a 	mov	r11,r10
 d00770c:	31006726 	beq	r6,r4,d0078ac <_free_r+0x1f0>
 d007710:	2880004c 	andi	r2,r5,1
 d007714:	1005003a 	cmpeq	r2,r2,zero
 d007718:	32400115 	stw	r9,4(r6)
 d00771c:	10001a1e 	bne	r2,zero,d007788 <_free_r+0xcc>
 d007720:	000b883a 	mov	r5,zero
 d007724:	3247883a 	add	r3,r6,r9
 d007728:	18800117 	ldw	r2,4(r3)
 d00772c:	1080004c 	andi	r2,r2,1
 d007730:	1000231e 	bne	r2,zero,d0077c0 <_free_r+0x104>
 d007734:	280ac03a 	cmpne	r5,r5,zero
 d007738:	3a4f883a 	add	r7,r7,r9
 d00773c:	2800451e 	bne	r5,zero,d007854 <_free_r+0x198>
 d007740:	31000217 	ldw	r4,8(r6)
 d007744:	00834174 	movhi	r2,3333
 d007748:	10837d04 	addi	r2,r2,3572
 d00774c:	20807b26 	beq	r4,r2,d00793c <_free_r+0x280>
 d007750:	30800317 	ldw	r2,12(r6)
 d007754:	3a07883a 	add	r3,r7,r8
 d007758:	19c00015 	stw	r7,0(r3)
 d00775c:	11000215 	stw	r4,8(r2)
 d007760:	20800315 	stw	r2,12(r4)
 d007764:	38800054 	ori	r2,r7,1
 d007768:	40800115 	stw	r2,4(r8)
 d00776c:	28001a26 	beq	r5,zero,d0077d8 <_free_r+0x11c>
 d007770:	8809883a 	mov	r4,r17
 d007774:	dfc00217 	ldw	ra,8(sp)
 d007778:	dc400117 	ldw	r17,4(sp)
 d00777c:	dc000017 	ldw	r16,0(sp)
 d007780:	dec00304 	addi	sp,sp,12
 d007784:	d00d5e41 	jmpi	d00d5e4 <__malloc_unlock>
 d007788:	80bffe17 	ldw	r2,-8(r16)
 d00778c:	50c00204 	addi	r3,r10,8
 d007790:	4091c83a 	sub	r8,r8,r2
 d007794:	41000217 	ldw	r4,8(r8)
 d007798:	388f883a 	add	r7,r7,r2
 d00779c:	20c06126 	beq	r4,r3,d007924 <_free_r+0x268>
 d0077a0:	40800317 	ldw	r2,12(r8)
 d0077a4:	3247883a 	add	r3,r6,r9
 d0077a8:	000b883a 	mov	r5,zero
 d0077ac:	11000215 	stw	r4,8(r2)
 d0077b0:	20800315 	stw	r2,12(r4)
 d0077b4:	18800117 	ldw	r2,4(r3)
 d0077b8:	1080004c 	andi	r2,r2,1
 d0077bc:	103fdd26 	beq	r2,zero,d007734 <_free_r+0x78>
 d0077c0:	38800054 	ori	r2,r7,1
 d0077c4:	3a07883a 	add	r3,r7,r8
 d0077c8:	280ac03a 	cmpne	r5,r5,zero
 d0077cc:	40800115 	stw	r2,4(r8)
 d0077d0:	19c00015 	stw	r7,0(r3)
 d0077d4:	283fe61e 	bne	r5,zero,d007770 <_free_r+0xb4>
 d0077d8:	00807fc4 	movi	r2,511
 d0077dc:	11c01f2e 	bgeu	r2,r7,d00785c <_free_r+0x1a0>
 d0077e0:	3806d27a 	srli	r3,r7,9
 d0077e4:	1800481e 	bne	r3,zero,d007908 <_free_r+0x24c>
 d0077e8:	3804d0fa 	srli	r2,r7,3
 d0077ec:	100690fa 	slli	r3,r2,3
 d0077f0:	1acd883a 	add	r6,r3,r11
 d0077f4:	31400217 	ldw	r5,8(r6)
 d0077f8:	31405926 	beq	r6,r5,d007960 <_free_r+0x2a4>
 d0077fc:	28800117 	ldw	r2,4(r5)
 d007800:	00ffff04 	movi	r3,-4
 d007804:	10c4703a 	and	r2,r2,r3
 d007808:	3880022e 	bgeu	r7,r2,d007814 <_free_r+0x158>
 d00780c:	29400217 	ldw	r5,8(r5)
 d007810:	317ffa1e 	bne	r6,r5,d0077fc <_free_r+0x140>
 d007814:	29800317 	ldw	r6,12(r5)
 d007818:	41800315 	stw	r6,12(r8)
 d00781c:	41400215 	stw	r5,8(r8)
 d007820:	8809883a 	mov	r4,r17
 d007824:	2a000315 	stw	r8,12(r5)
 d007828:	32000215 	stw	r8,8(r6)
 d00782c:	dfc00217 	ldw	ra,8(sp)
 d007830:	dc400117 	ldw	r17,4(sp)
 d007834:	dc000017 	ldw	r16,0(sp)
 d007838:	dec00304 	addi	sp,sp,12
 d00783c:	d00d5e41 	jmpi	d00d5e4 <__malloc_unlock>
 d007840:	dfc00217 	ldw	ra,8(sp)
 d007844:	dc400117 	ldw	r17,4(sp)
 d007848:	dc000017 	ldw	r16,0(sp)
 d00784c:	dec00304 	addi	sp,sp,12
 d007850:	f800283a 	ret
 d007854:	31000217 	ldw	r4,8(r6)
 d007858:	003fbd06 	br	d007750 <_free_r+0x94>
 d00785c:	3806d0fa 	srli	r3,r7,3
 d007860:	00800044 	movi	r2,1
 d007864:	51400117 	ldw	r5,4(r10)
 d007868:	180890fa 	slli	r4,r3,3
 d00786c:	1807d0ba 	srai	r3,r3,2
 d007870:	22c9883a 	add	r4,r4,r11
 d007874:	21800217 	ldw	r6,8(r4)
 d007878:	10c4983a 	sll	r2,r2,r3
 d00787c:	41000315 	stw	r4,12(r8)
 d007880:	41800215 	stw	r6,8(r8)
 d007884:	288ab03a 	or	r5,r5,r2
 d007888:	22000215 	stw	r8,8(r4)
 d00788c:	8809883a 	mov	r4,r17
 d007890:	51400115 	stw	r5,4(r10)
 d007894:	32000315 	stw	r8,12(r6)
 d007898:	dfc00217 	ldw	ra,8(sp)
 d00789c:	dc400117 	ldw	r17,4(sp)
 d0078a0:	dc000017 	ldw	r16,0(sp)
 d0078a4:	dec00304 	addi	sp,sp,12
 d0078a8:	d00d5e41 	jmpi	d00d5e4 <__malloc_unlock>
 d0078ac:	2880004c 	andi	r2,r5,1
 d0078b0:	3a4d883a 	add	r6,r7,r9
 d0078b4:	1000071e 	bne	r2,zero,d0078d4 <_free_r+0x218>
 d0078b8:	80bffe17 	ldw	r2,-8(r16)
 d0078bc:	4091c83a 	sub	r8,r8,r2
 d0078c0:	41000317 	ldw	r4,12(r8)
 d0078c4:	40c00217 	ldw	r3,8(r8)
 d0078c8:	308d883a 	add	r6,r6,r2
 d0078cc:	20c00215 	stw	r3,8(r4)
 d0078d0:	19000315 	stw	r4,12(r3)
 d0078d4:	00834174 	movhi	r2,3333
 d0078d8:	108a2604 	addi	r2,r2,10392
 d0078dc:	11000017 	ldw	r4,0(r2)
 d0078e0:	30c00054 	ori	r3,r6,1
 d0078e4:	52000215 	stw	r8,8(r10)
 d0078e8:	40c00115 	stw	r3,4(r8)
 d0078ec:	313fa036 	bltu	r6,r4,d007770 <_free_r+0xb4>
 d0078f0:	00834174 	movhi	r2,3333
 d0078f4:	108a8104 	addi	r2,r2,10756
 d0078f8:	11400017 	ldw	r5,0(r2)
 d0078fc:	8809883a 	mov	r4,r17
 d007900:	d0075900 	call	d007590 <_malloc_trim_r>
 d007904:	003f9a06 	br	d007770 <_free_r+0xb4>
 d007908:	00800104 	movi	r2,4
 d00790c:	10c0072e 	bgeu	r2,r3,d00792c <_free_r+0x270>
 d007910:	00800504 	movi	r2,20
 d007914:	10c01936 	bltu	r2,r3,d00797c <_free_r+0x2c0>
 d007918:	188016c4 	addi	r2,r3,91
 d00791c:	100690fa 	slli	r3,r2,3
 d007920:	003fb306 	br	d0077f0 <_free_r+0x134>
 d007924:	01400044 	movi	r5,1
 d007928:	003f7e06 	br	d007724 <_free_r+0x68>
 d00792c:	3804d1ba 	srli	r2,r7,6
 d007930:	10800e04 	addi	r2,r2,56
 d007934:	100690fa 	slli	r3,r2,3
 d007938:	003fad06 	br	d0077f0 <_free_r+0x134>
 d00793c:	22000315 	stw	r8,12(r4)
 d007940:	22000215 	stw	r8,8(r4)
 d007944:	3a05883a 	add	r2,r7,r8
 d007948:	38c00054 	ori	r3,r7,1
 d00794c:	11c00015 	stw	r7,0(r2)
 d007950:	41000215 	stw	r4,8(r8)
 d007954:	40c00115 	stw	r3,4(r8)
 d007958:	41000315 	stw	r4,12(r8)
 d00795c:	003f8406 	br	d007770 <_free_r+0xb4>
 d007960:	1005d0ba 	srai	r2,r2,2
 d007964:	00c00044 	movi	r3,1
 d007968:	51000117 	ldw	r4,4(r10)
 d00796c:	1886983a 	sll	r3,r3,r2
 d007970:	20c8b03a 	or	r4,r4,r3
 d007974:	51000115 	stw	r4,4(r10)
 d007978:	003fa706 	br	d007818 <_free_r+0x15c>
 d00797c:	00801504 	movi	r2,84
 d007980:	10c00436 	bltu	r2,r3,d007994 <_free_r+0x2d8>
 d007984:	3804d33a 	srli	r2,r7,12
 d007988:	10801b84 	addi	r2,r2,110
 d00798c:	100690fa 	slli	r3,r2,3
 d007990:	003f9706 	br	d0077f0 <_free_r+0x134>
 d007994:	00805504 	movi	r2,340
 d007998:	10c00436 	bltu	r2,r3,d0079ac <_free_r+0x2f0>
 d00799c:	3804d3fa 	srli	r2,r7,15
 d0079a0:	10801dc4 	addi	r2,r2,119
 d0079a4:	100690fa 	slli	r3,r2,3
 d0079a8:	003f9106 	br	d0077f0 <_free_r+0x134>
 d0079ac:	00815504 	movi	r2,1364
 d0079b0:	10c0032e 	bgeu	r2,r3,d0079c0 <_free_r+0x304>
 d0079b4:	00801f84 	movi	r2,126
 d0079b8:	00c0fc04 	movi	r3,1008
 d0079bc:	003f8c06 	br	d0077f0 <_free_r+0x134>
 d0079c0:	3804d4ba 	srli	r2,r7,18
 d0079c4:	10801f04 	addi	r2,r2,124
 d0079c8:	100690fa 	slli	r3,r2,3
 d0079cc:	003f8806 	br	d0077f0 <_free_r+0x134>

0d0079d0 <__sfvwrite_r>:
 d0079d0:	30800217 	ldw	r2,8(r6)
 d0079d4:	defff504 	addi	sp,sp,-44
 d0079d8:	df000915 	stw	fp,36(sp)
 d0079dc:	dd800715 	stw	r22,28(sp)
 d0079e0:	dc800315 	stw	r18,12(sp)
 d0079e4:	dfc00a15 	stw	ra,40(sp)
 d0079e8:	ddc00815 	stw	r23,32(sp)
 d0079ec:	dd400615 	stw	r21,24(sp)
 d0079f0:	dd000515 	stw	r20,20(sp)
 d0079f4:	dcc00415 	stw	r19,16(sp)
 d0079f8:	dc400215 	stw	r17,8(sp)
 d0079fc:	dc000115 	stw	r16,4(sp)
 d007a00:	302d883a 	mov	r22,r6
 d007a04:	2039883a 	mov	fp,r4
 d007a08:	2825883a 	mov	r18,r5
 d007a0c:	10001c26 	beq	r2,zero,d007a80 <__sfvwrite_r+0xb0>
 d007a10:	29c0030b 	ldhu	r7,12(r5)
 d007a14:	3880020c 	andi	r2,r7,8
 d007a18:	10002726 	beq	r2,zero,d007ab8 <__sfvwrite_r+0xe8>
 d007a1c:	28800417 	ldw	r2,16(r5)
 d007a20:	10002526 	beq	r2,zero,d007ab8 <__sfvwrite_r+0xe8>
 d007a24:	3880008c 	andi	r2,r7,2
 d007a28:	b5400017 	ldw	r21,0(r22)
 d007a2c:	10002826 	beq	r2,zero,d007ad0 <__sfvwrite_r+0x100>
 d007a30:	0021883a 	mov	r16,zero
 d007a34:	0023883a 	mov	r17,zero
 d007a38:	880d883a 	mov	r6,r17
 d007a3c:	e009883a 	mov	r4,fp
 d007a40:	00810004 	movi	r2,1024
 d007a44:	80006e26 	beq	r16,zero,d007c00 <__sfvwrite_r+0x230>
 d007a48:	800f883a 	mov	r7,r16
 d007a4c:	91400717 	ldw	r5,28(r18)
 d007a50:	1400012e 	bgeu	r2,r16,d007a58 <__sfvwrite_r+0x88>
 d007a54:	100f883a 	mov	r7,r2
 d007a58:	90c00917 	ldw	r3,36(r18)
 d007a5c:	183ee83a 	callr	r3
 d007a60:	1007883a 	mov	r3,r2
 d007a64:	80a1c83a 	sub	r16,r16,r2
 d007a68:	88a3883a 	add	r17,r17,r2
 d007a6c:	00806d0e 	bge	zero,r2,d007c24 <__sfvwrite_r+0x254>
 d007a70:	b0800217 	ldw	r2,8(r22)
 d007a74:	10c5c83a 	sub	r2,r2,r3
 d007a78:	b0800215 	stw	r2,8(r22)
 d007a7c:	103fee1e 	bne	r2,zero,d007a38 <__sfvwrite_r+0x68>
 d007a80:	0009883a 	mov	r4,zero
 d007a84:	2005883a 	mov	r2,r4
 d007a88:	dfc00a17 	ldw	ra,40(sp)
 d007a8c:	df000917 	ldw	fp,36(sp)
 d007a90:	ddc00817 	ldw	r23,32(sp)
 d007a94:	dd800717 	ldw	r22,28(sp)
 d007a98:	dd400617 	ldw	r21,24(sp)
 d007a9c:	dd000517 	ldw	r20,20(sp)
 d007aa0:	dcc00417 	ldw	r19,16(sp)
 d007aa4:	dc800317 	ldw	r18,12(sp)
 d007aa8:	dc400217 	ldw	r17,8(sp)
 d007aac:	dc000117 	ldw	r16,4(sp)
 d007ab0:	dec00b04 	addi	sp,sp,44
 d007ab4:	f800283a 	ret
 d007ab8:	d00564c0 	call	d00564c <__swsetup_r>
 d007abc:	1000e41e 	bne	r2,zero,d007e50 <__sfvwrite_r+0x480>
 d007ac0:	91c0030b 	ldhu	r7,12(r18)
 d007ac4:	b5400017 	ldw	r21,0(r22)
 d007ac8:	3880008c 	andi	r2,r7,2
 d007acc:	103fd81e 	bne	r2,zero,d007a30 <__sfvwrite_r+0x60>
 d007ad0:	3880004c 	andi	r2,r7,1
 d007ad4:	1005003a 	cmpeq	r2,r2,zero
 d007ad8:	10005726 	beq	r2,zero,d007c38 <__sfvwrite_r+0x268>
 d007adc:	0029883a 	mov	r20,zero
 d007ae0:	002f883a 	mov	r23,zero
 d007ae4:	a0004226 	beq	r20,zero,d007bf0 <__sfvwrite_r+0x220>
 d007ae8:	3880800c 	andi	r2,r7,512
 d007aec:	94000217 	ldw	r16,8(r18)
 d007af0:	10008b26 	beq	r2,zero,d007d20 <__sfvwrite_r+0x350>
 d007af4:	800d883a 	mov	r6,r16
 d007af8:	a400a536 	bltu	r20,r16,d007d90 <__sfvwrite_r+0x3c0>
 d007afc:	3881200c 	andi	r2,r7,1152
 d007b00:	10002726 	beq	r2,zero,d007ba0 <__sfvwrite_r+0x1d0>
 d007b04:	90800517 	ldw	r2,20(r18)
 d007b08:	92000417 	ldw	r8,16(r18)
 d007b0c:	91400017 	ldw	r5,0(r18)
 d007b10:	1087883a 	add	r3,r2,r2
 d007b14:	1887883a 	add	r3,r3,r2
 d007b18:	1808d7fa 	srli	r4,r3,31
 d007b1c:	2a21c83a 	sub	r16,r5,r8
 d007b20:	80800044 	addi	r2,r16,1
 d007b24:	20c9883a 	add	r4,r4,r3
 d007b28:	2027d07a 	srai	r19,r4,1
 d007b2c:	a085883a 	add	r2,r20,r2
 d007b30:	980d883a 	mov	r6,r19
 d007b34:	9880022e 	bgeu	r19,r2,d007b40 <__sfvwrite_r+0x170>
 d007b38:	1027883a 	mov	r19,r2
 d007b3c:	100d883a 	mov	r6,r2
 d007b40:	3881000c 	andi	r2,r7,1024
 d007b44:	1000b826 	beq	r2,zero,d007e28 <__sfvwrite_r+0x458>
 d007b48:	300b883a 	mov	r5,r6
 d007b4c:	e009883a 	mov	r4,fp
 d007b50:	d0082440 	call	d008244 <_malloc_r>
 d007b54:	10003126 	beq	r2,zero,d007c1c <__sfvwrite_r+0x24c>
 d007b58:	91400417 	ldw	r5,16(r18)
 d007b5c:	1009883a 	mov	r4,r2
 d007b60:	800d883a 	mov	r6,r16
 d007b64:	1023883a 	mov	r17,r2
 d007b68:	d0027000 	call	d002700 <memcpy>
 d007b6c:	90c0030b 	ldhu	r3,12(r18)
 d007b70:	00beffc4 	movi	r2,-1025
 d007b74:	1886703a 	and	r3,r3,r2
 d007b78:	18c02014 	ori	r3,r3,128
 d007b7c:	90c0030d 	sth	r3,12(r18)
 d007b80:	9c07c83a 	sub	r3,r19,r16
 d007b84:	8c05883a 	add	r2,r17,r16
 d007b88:	a00d883a 	mov	r6,r20
 d007b8c:	a021883a 	mov	r16,r20
 d007b90:	90800015 	stw	r2,0(r18)
 d007b94:	90c00215 	stw	r3,8(r18)
 d007b98:	94400415 	stw	r17,16(r18)
 d007b9c:	94c00515 	stw	r19,20(r18)
 d007ba0:	91000017 	ldw	r4,0(r18)
 d007ba4:	b80b883a 	mov	r5,r23
 d007ba8:	a023883a 	mov	r17,r20
 d007bac:	d0027a00 	call	d0027a0 <memmove>
 d007bb0:	90c00217 	ldw	r3,8(r18)
 d007bb4:	90800017 	ldw	r2,0(r18)
 d007bb8:	a027883a 	mov	r19,r20
 d007bbc:	1c07c83a 	sub	r3,r3,r16
 d007bc0:	1405883a 	add	r2,r2,r16
 d007bc4:	90c00215 	stw	r3,8(r18)
 d007bc8:	a021883a 	mov	r16,r20
 d007bcc:	90800015 	stw	r2,0(r18)
 d007bd0:	b0800217 	ldw	r2,8(r22)
 d007bd4:	1405c83a 	sub	r2,r2,r16
 d007bd8:	b0800215 	stw	r2,8(r22)
 d007bdc:	103fa826 	beq	r2,zero,d007a80 <__sfvwrite_r+0xb0>
 d007be0:	a469c83a 	sub	r20,r20,r17
 d007be4:	91c0030b 	ldhu	r7,12(r18)
 d007be8:	bcef883a 	add	r23,r23,r19
 d007bec:	a03fbe1e 	bne	r20,zero,d007ae8 <__sfvwrite_r+0x118>
 d007bf0:	adc00017 	ldw	r23,0(r21)
 d007bf4:	ad000117 	ldw	r20,4(r21)
 d007bf8:	ad400204 	addi	r21,r21,8
 d007bfc:	003fb906 	br	d007ae4 <__sfvwrite_r+0x114>
 d007c00:	ac400017 	ldw	r17,0(r21)
 d007c04:	ac000117 	ldw	r16,4(r21)
 d007c08:	ad400204 	addi	r21,r21,8
 d007c0c:	003f8a06 	br	d007a38 <__sfvwrite_r+0x68>
 d007c10:	91400417 	ldw	r5,16(r18)
 d007c14:	e009883a 	mov	r4,fp
 d007c18:	d0076bc0 	call	d0076bc <_free_r>
 d007c1c:	00800304 	movi	r2,12
 d007c20:	e0800015 	stw	r2,0(fp)
 d007c24:	9080030b 	ldhu	r2,12(r18)
 d007c28:	013fffc4 	movi	r4,-1
 d007c2c:	10801014 	ori	r2,r2,64
 d007c30:	9080030d 	sth	r2,12(r18)
 d007c34:	003f9306 	br	d007a84 <__sfvwrite_r+0xb4>
 d007c38:	0027883a 	mov	r19,zero
 d007c3c:	002f883a 	mov	r23,zero
 d007c40:	d8000015 	stw	zero,0(sp)
 d007c44:	0029883a 	mov	r20,zero
 d007c48:	98001e26 	beq	r19,zero,d007cc4 <__sfvwrite_r+0x2f4>
 d007c4c:	d8c00017 	ldw	r3,0(sp)
 d007c50:	1804c03a 	cmpne	r2,r3,zero
 d007c54:	10005e26 	beq	r2,zero,d007dd0 <__sfvwrite_r+0x400>
 d007c58:	9821883a 	mov	r16,r19
 d007c5c:	a4c0012e 	bgeu	r20,r19,d007c64 <__sfvwrite_r+0x294>
 d007c60:	a021883a 	mov	r16,r20
 d007c64:	91000017 	ldw	r4,0(r18)
 d007c68:	90800417 	ldw	r2,16(r18)
 d007c6c:	91800217 	ldw	r6,8(r18)
 d007c70:	91c00517 	ldw	r7,20(r18)
 d007c74:	1100022e 	bgeu	r2,r4,d007c80 <__sfvwrite_r+0x2b0>
 d007c78:	31e3883a 	add	r17,r6,r7
 d007c7c:	8c001616 	blt	r17,r16,d007cd8 <__sfvwrite_r+0x308>
 d007c80:	81c03816 	blt	r16,r7,d007d64 <__sfvwrite_r+0x394>
 d007c84:	90c00917 	ldw	r3,36(r18)
 d007c88:	91400717 	ldw	r5,28(r18)
 d007c8c:	e009883a 	mov	r4,fp
 d007c90:	b80d883a 	mov	r6,r23
 d007c94:	183ee83a 	callr	r3
 d007c98:	1023883a 	mov	r17,r2
 d007c9c:	00bfe10e 	bge	zero,r2,d007c24 <__sfvwrite_r+0x254>
 d007ca0:	a469c83a 	sub	r20,r20,r17
 d007ca4:	a0001826 	beq	r20,zero,d007d08 <__sfvwrite_r+0x338>
 d007ca8:	b0800217 	ldw	r2,8(r22)
 d007cac:	1445c83a 	sub	r2,r2,r17
 d007cb0:	b0800215 	stw	r2,8(r22)
 d007cb4:	103f7226 	beq	r2,zero,d007a80 <__sfvwrite_r+0xb0>
 d007cb8:	9c67c83a 	sub	r19,r19,r17
 d007cbc:	bc6f883a 	add	r23,r23,r17
 d007cc0:	983fe21e 	bne	r19,zero,d007c4c <__sfvwrite_r+0x27c>
 d007cc4:	adc00017 	ldw	r23,0(r21)
 d007cc8:	acc00117 	ldw	r19,4(r21)
 d007ccc:	ad400204 	addi	r21,r21,8
 d007cd0:	d8000015 	stw	zero,0(sp)
 d007cd4:	003fdc06 	br	d007c48 <__sfvwrite_r+0x278>
 d007cd8:	b80b883a 	mov	r5,r23
 d007cdc:	880d883a 	mov	r6,r17
 d007ce0:	d0027a00 	call	d0027a0 <memmove>
 d007ce4:	90c00017 	ldw	r3,0(r18)
 d007ce8:	e009883a 	mov	r4,fp
 d007cec:	900b883a 	mov	r5,r18
 d007cf0:	1c47883a 	add	r3,r3,r17
 d007cf4:	90c00015 	stw	r3,0(r18)
 d007cf8:	d006f540 	call	d006f54 <_fflush_r>
 d007cfc:	103fc91e 	bne	r2,zero,d007c24 <__sfvwrite_r+0x254>
 d007d00:	a469c83a 	sub	r20,r20,r17
 d007d04:	a03fe81e 	bne	r20,zero,d007ca8 <__sfvwrite_r+0x2d8>
 d007d08:	e009883a 	mov	r4,fp
 d007d0c:	900b883a 	mov	r5,r18
 d007d10:	d006f540 	call	d006f54 <_fflush_r>
 d007d14:	103fc31e 	bne	r2,zero,d007c24 <__sfvwrite_r+0x254>
 d007d18:	d8000015 	stw	zero,0(sp)
 d007d1c:	003fe206 	br	d007ca8 <__sfvwrite_r+0x2d8>
 d007d20:	91000017 	ldw	r4,0(r18)
 d007d24:	90800417 	ldw	r2,16(r18)
 d007d28:	1100022e 	bgeu	r2,r4,d007d34 <__sfvwrite_r+0x364>
 d007d2c:	8023883a 	mov	r17,r16
 d007d30:	85003136 	bltu	r16,r20,d007df8 <__sfvwrite_r+0x428>
 d007d34:	91c00517 	ldw	r7,20(r18)
 d007d38:	a1c01836 	bltu	r20,r7,d007d9c <__sfvwrite_r+0x3cc>
 d007d3c:	90c00917 	ldw	r3,36(r18)
 d007d40:	91400717 	ldw	r5,28(r18)
 d007d44:	e009883a 	mov	r4,fp
 d007d48:	b80d883a 	mov	r6,r23
 d007d4c:	183ee83a 	callr	r3
 d007d50:	1021883a 	mov	r16,r2
 d007d54:	00bfb30e 	bge	zero,r2,d007c24 <__sfvwrite_r+0x254>
 d007d58:	1023883a 	mov	r17,r2
 d007d5c:	1027883a 	mov	r19,r2
 d007d60:	003f9b06 	br	d007bd0 <__sfvwrite_r+0x200>
 d007d64:	b80b883a 	mov	r5,r23
 d007d68:	800d883a 	mov	r6,r16
 d007d6c:	d0027a00 	call	d0027a0 <memmove>
 d007d70:	90c00217 	ldw	r3,8(r18)
 d007d74:	90800017 	ldw	r2,0(r18)
 d007d78:	8023883a 	mov	r17,r16
 d007d7c:	1c07c83a 	sub	r3,r3,r16
 d007d80:	1405883a 	add	r2,r2,r16
 d007d84:	90c00215 	stw	r3,8(r18)
 d007d88:	90800015 	stw	r2,0(r18)
 d007d8c:	003fc406 	br	d007ca0 <__sfvwrite_r+0x2d0>
 d007d90:	a00d883a 	mov	r6,r20
 d007d94:	a021883a 	mov	r16,r20
 d007d98:	003f8106 	br	d007ba0 <__sfvwrite_r+0x1d0>
 d007d9c:	b80b883a 	mov	r5,r23
 d007da0:	a00d883a 	mov	r6,r20
 d007da4:	d0027a00 	call	d0027a0 <memmove>
 d007da8:	90c00217 	ldw	r3,8(r18)
 d007dac:	90800017 	ldw	r2,0(r18)
 d007db0:	a021883a 	mov	r16,r20
 d007db4:	1d07c83a 	sub	r3,r3,r20
 d007db8:	1505883a 	add	r2,r2,r20
 d007dbc:	a023883a 	mov	r17,r20
 d007dc0:	a027883a 	mov	r19,r20
 d007dc4:	90c00215 	stw	r3,8(r18)
 d007dc8:	90800015 	stw	r2,0(r18)
 d007dcc:	003f8006 	br	d007bd0 <__sfvwrite_r+0x200>
 d007dd0:	b809883a 	mov	r4,r23
 d007dd4:	01400284 	movi	r5,10
 d007dd8:	980d883a 	mov	r6,r19
 d007ddc:	d0089840 	call	d008984 <memchr>
 d007de0:	10001726 	beq	r2,zero,d007e40 <__sfvwrite_r+0x470>
 d007de4:	15c5c83a 	sub	r2,r2,r23
 d007de8:	15000044 	addi	r20,r2,1
 d007dec:	00800044 	movi	r2,1
 d007df0:	d8800015 	stw	r2,0(sp)
 d007df4:	003f9806 	br	d007c58 <__sfvwrite_r+0x288>
 d007df8:	b80b883a 	mov	r5,r23
 d007dfc:	800d883a 	mov	r6,r16
 d007e00:	d0027a00 	call	d0027a0 <memmove>
 d007e04:	90c00017 	ldw	r3,0(r18)
 d007e08:	e009883a 	mov	r4,fp
 d007e0c:	900b883a 	mov	r5,r18
 d007e10:	1c07883a 	add	r3,r3,r16
 d007e14:	90c00015 	stw	r3,0(r18)
 d007e18:	8027883a 	mov	r19,r16
 d007e1c:	d006f540 	call	d006f54 <_fflush_r>
 d007e20:	103f6b26 	beq	r2,zero,d007bd0 <__sfvwrite_r+0x200>
 d007e24:	003f7f06 	br	d007c24 <__sfvwrite_r+0x254>
 d007e28:	400b883a 	mov	r5,r8
 d007e2c:	e009883a 	mov	r4,fp
 d007e30:	d009a5c0 	call	d009a5c <_realloc_r>
 d007e34:	103f7626 	beq	r2,zero,d007c10 <__sfvwrite_r+0x240>
 d007e38:	1023883a 	mov	r17,r2
 d007e3c:	003f5006 	br	d007b80 <__sfvwrite_r+0x1b0>
 d007e40:	00c00044 	movi	r3,1
 d007e44:	9d000044 	addi	r20,r19,1
 d007e48:	d8c00015 	stw	r3,0(sp)
 d007e4c:	003f8206 	br	d007c58 <__sfvwrite_r+0x288>
 d007e50:	9080030b 	ldhu	r2,12(r18)
 d007e54:	00c00244 	movi	r3,9
 d007e58:	013fffc4 	movi	r4,-1
 d007e5c:	10801014 	ori	r2,r2,64
 d007e60:	9080030d 	sth	r2,12(r18)
 d007e64:	e0c00015 	stw	r3,0(fp)
 d007e68:	003f0606 	br	d007a84 <__sfvwrite_r+0xb4>

0d007e6c <_fwalk_reent>:
 d007e6c:	defff704 	addi	sp,sp,-36
 d007e70:	dcc00315 	stw	r19,12(sp)
 d007e74:	24c0b804 	addi	r19,r4,736
 d007e78:	dd800615 	stw	r22,24(sp)
 d007e7c:	dd400515 	stw	r21,20(sp)
 d007e80:	dfc00815 	stw	ra,32(sp)
 d007e84:	ddc00715 	stw	r23,28(sp)
 d007e88:	dd000415 	stw	r20,16(sp)
 d007e8c:	dc800215 	stw	r18,8(sp)
 d007e90:	dc400115 	stw	r17,4(sp)
 d007e94:	dc000015 	stw	r16,0(sp)
 d007e98:	202b883a 	mov	r21,r4
 d007e9c:	282d883a 	mov	r22,r5
 d007ea0:	d0071dc0 	call	d0071dc <__sfp_lock_acquire>
 d007ea4:	98002126 	beq	r19,zero,d007f2c <_fwalk_reent+0xc0>
 d007ea8:	002f883a 	mov	r23,zero
 d007eac:	9c800117 	ldw	r18,4(r19)
 d007eb0:	9c000217 	ldw	r16,8(r19)
 d007eb4:	90bfffc4 	addi	r2,r18,-1
 d007eb8:	10000d16 	blt	r2,zero,d007ef0 <_fwalk_reent+0x84>
 d007ebc:	0023883a 	mov	r17,zero
 d007ec0:	053fffc4 	movi	r20,-1
 d007ec4:	8080030f 	ldh	r2,12(r16)
 d007ec8:	8c400044 	addi	r17,r17,1
 d007ecc:	10000626 	beq	r2,zero,d007ee8 <_fwalk_reent+0x7c>
 d007ed0:	8080038f 	ldh	r2,14(r16)
 d007ed4:	800b883a 	mov	r5,r16
 d007ed8:	a809883a 	mov	r4,r21
 d007edc:	15000226 	beq	r2,r20,d007ee8 <_fwalk_reent+0x7c>
 d007ee0:	b03ee83a 	callr	r22
 d007ee4:	b8aeb03a 	or	r23,r23,r2
 d007ee8:	84001704 	addi	r16,r16,92
 d007eec:	947ff51e 	bne	r18,r17,d007ec4 <_fwalk_reent+0x58>
 d007ef0:	9cc00017 	ldw	r19,0(r19)
 d007ef4:	983fed1e 	bne	r19,zero,d007eac <_fwalk_reent+0x40>
 d007ef8:	d0071e00 	call	d0071e0 <__sfp_lock_release>
 d007efc:	b805883a 	mov	r2,r23
 d007f00:	dfc00817 	ldw	ra,32(sp)
 d007f04:	ddc00717 	ldw	r23,28(sp)
 d007f08:	dd800617 	ldw	r22,24(sp)
 d007f0c:	dd400517 	ldw	r21,20(sp)
 d007f10:	dd000417 	ldw	r20,16(sp)
 d007f14:	dcc00317 	ldw	r19,12(sp)
 d007f18:	dc800217 	ldw	r18,8(sp)
 d007f1c:	dc400117 	ldw	r17,4(sp)
 d007f20:	dc000017 	ldw	r16,0(sp)
 d007f24:	dec00904 	addi	sp,sp,36
 d007f28:	f800283a 	ret
 d007f2c:	002f883a 	mov	r23,zero
 d007f30:	003ff106 	br	d007ef8 <_fwalk_reent+0x8c>

0d007f34 <_fwalk>:
 d007f34:	defff804 	addi	sp,sp,-32
 d007f38:	dcc00315 	stw	r19,12(sp)
 d007f3c:	24c0b804 	addi	r19,r4,736
 d007f40:	dd400515 	stw	r21,20(sp)
 d007f44:	dfc00715 	stw	ra,28(sp)
 d007f48:	dd800615 	stw	r22,24(sp)
 d007f4c:	dd000415 	stw	r20,16(sp)
 d007f50:	dc800215 	stw	r18,8(sp)
 d007f54:	dc400115 	stw	r17,4(sp)
 d007f58:	dc000015 	stw	r16,0(sp)
 d007f5c:	282b883a 	mov	r21,r5
 d007f60:	d0071dc0 	call	d0071dc <__sfp_lock_acquire>
 d007f64:	98001f26 	beq	r19,zero,d007fe4 <_fwalk+0xb0>
 d007f68:	002d883a 	mov	r22,zero
 d007f6c:	9c800117 	ldw	r18,4(r19)
 d007f70:	9c000217 	ldw	r16,8(r19)
 d007f74:	90bfffc4 	addi	r2,r18,-1
 d007f78:	10000c16 	blt	r2,zero,d007fac <_fwalk+0x78>
 d007f7c:	0023883a 	mov	r17,zero
 d007f80:	053fffc4 	movi	r20,-1
 d007f84:	8080030f 	ldh	r2,12(r16)
 d007f88:	8c400044 	addi	r17,r17,1
 d007f8c:	10000526 	beq	r2,zero,d007fa4 <_fwalk+0x70>
 d007f90:	8080038f 	ldh	r2,14(r16)
 d007f94:	8009883a 	mov	r4,r16
 d007f98:	15000226 	beq	r2,r20,d007fa4 <_fwalk+0x70>
 d007f9c:	a83ee83a 	callr	r21
 d007fa0:	b0acb03a 	or	r22,r22,r2
 d007fa4:	84001704 	addi	r16,r16,92
 d007fa8:	947ff61e 	bne	r18,r17,d007f84 <_fwalk+0x50>
 d007fac:	9cc00017 	ldw	r19,0(r19)
 d007fb0:	983fee1e 	bne	r19,zero,d007f6c <_fwalk+0x38>
 d007fb4:	d0071e00 	call	d0071e0 <__sfp_lock_release>
 d007fb8:	b005883a 	mov	r2,r22
 d007fbc:	dfc00717 	ldw	ra,28(sp)
 d007fc0:	dd800617 	ldw	r22,24(sp)
 d007fc4:	dd400517 	ldw	r21,20(sp)
 d007fc8:	dd000417 	ldw	r20,16(sp)
 d007fcc:	dcc00317 	ldw	r19,12(sp)
 d007fd0:	dc800217 	ldw	r18,8(sp)
 d007fd4:	dc400117 	ldw	r17,4(sp)
 d007fd8:	dc000017 	ldw	r16,0(sp)
 d007fdc:	dec00804 	addi	sp,sp,32
 d007fe0:	f800283a 	ret
 d007fe4:	002d883a 	mov	r22,zero
 d007fe8:	003ff206 	br	d007fb4 <_fwalk+0x80>

0d007fec <__locale_charset>:
 d007fec:	d0a00417 	ldw	r2,-32752(gp)
 d007ff0:	f800283a 	ret

0d007ff4 <_localeconv_r>:
 d007ff4:	00834174 	movhi	r2,3333
 d007ff8:	10b11404 	addi	r2,r2,-15280
 d007ffc:	f800283a 	ret

0d008000 <localeconv>:
 d008000:	00834174 	movhi	r2,3333
 d008004:	108a2204 	addi	r2,r2,10376
 d008008:	11000017 	ldw	r4,0(r2)
 d00800c:	d007ff41 	jmpi	d007ff4 <_localeconv_r>

0d008010 <_setlocale_r>:
 d008010:	defffc04 	addi	sp,sp,-16
 d008014:	00c34174 	movhi	r3,3333
 d008018:	18ef0004 	addi	r3,r3,-17408
 d00801c:	dc800215 	stw	r18,8(sp)
 d008020:	dc400115 	stw	r17,4(sp)
 d008024:	dc000015 	stw	r16,0(sp)
 d008028:	2023883a 	mov	r17,r4
 d00802c:	2825883a 	mov	r18,r5
 d008030:	dfc00315 	stw	ra,12(sp)
 d008034:	3021883a 	mov	r16,r6
 d008038:	3009883a 	mov	r4,r6
 d00803c:	180b883a 	mov	r5,r3
 d008040:	30000926 	beq	r6,zero,d008068 <_setlocale_r+0x58>
 d008044:	d00a45c0 	call	d00a45c <strcmp>
 d008048:	8009883a 	mov	r4,r16
 d00804c:	01434174 	movhi	r5,3333
 d008050:	2970fb04 	addi	r5,r5,-15380
 d008054:	10000b1e 	bne	r2,zero,d008084 <_setlocale_r+0x74>
 d008058:	8c000d15 	stw	r16,52(r17)
 d00805c:	8c800c15 	stw	r18,48(r17)
 d008060:	00c34174 	movhi	r3,3333
 d008064:	18ef0004 	addi	r3,r3,-17408
 d008068:	1805883a 	mov	r2,r3
 d00806c:	dfc00317 	ldw	ra,12(sp)
 d008070:	dc800217 	ldw	r18,8(sp)
 d008074:	dc400117 	ldw	r17,4(sp)
 d008078:	dc000017 	ldw	r16,0(sp)
 d00807c:	dec00404 	addi	sp,sp,16
 d008080:	f800283a 	ret
 d008084:	d00a45c0 	call	d00a45c <strcmp>
 d008088:	0007883a 	mov	r3,zero
 d00808c:	103ff226 	beq	r2,zero,d008058 <_setlocale_r+0x48>
 d008090:	003ff506 	br	d008068 <_setlocale_r+0x58>

0d008094 <setlocale>:
 d008094:	01834174 	movhi	r6,3333
 d008098:	318a2204 	addi	r6,r6,10376
 d00809c:	2007883a 	mov	r3,r4
 d0080a0:	31000017 	ldw	r4,0(r6)
 d0080a4:	280d883a 	mov	r6,r5
 d0080a8:	180b883a 	mov	r5,r3
 d0080ac:	d0080101 	jmpi	d008010 <_setlocale_r>

0d0080b0 <__smakebuf_r>:
 d0080b0:	2880030b 	ldhu	r2,12(r5)
 d0080b4:	deffed04 	addi	sp,sp,-76
 d0080b8:	dc401015 	stw	r17,64(sp)
 d0080bc:	1080008c 	andi	r2,r2,2
 d0080c0:	dc000f15 	stw	r16,60(sp)
 d0080c4:	dfc01215 	stw	ra,72(sp)
 d0080c8:	dc801115 	stw	r18,68(sp)
 d0080cc:	2821883a 	mov	r16,r5
 d0080d0:	2023883a 	mov	r17,r4
 d0080d4:	10000b26 	beq	r2,zero,d008104 <__smakebuf_r+0x54>
 d0080d8:	28c010c4 	addi	r3,r5,67
 d0080dc:	00800044 	movi	r2,1
 d0080e0:	28800515 	stw	r2,20(r5)
 d0080e4:	28c00415 	stw	r3,16(r5)
 d0080e8:	28c00015 	stw	r3,0(r5)
 d0080ec:	dfc01217 	ldw	ra,72(sp)
 d0080f0:	dc801117 	ldw	r18,68(sp)
 d0080f4:	dc401017 	ldw	r17,64(sp)
 d0080f8:	dc000f17 	ldw	r16,60(sp)
 d0080fc:	dec01304 	addi	sp,sp,76
 d008100:	f800283a 	ret
 d008104:	2940038f 	ldh	r5,14(r5)
 d008108:	28002116 	blt	r5,zero,d008190 <__smakebuf_r+0xe0>
 d00810c:	d80d883a 	mov	r6,sp
 d008110:	d00a7d80 	call	d00a7d8 <_fstat_r>
 d008114:	10001e16 	blt	r2,zero,d008190 <__smakebuf_r+0xe0>
 d008118:	d8800117 	ldw	r2,4(sp)
 d00811c:	00e00014 	movui	r3,32768
 d008120:	113c000c 	andi	r4,r2,61440
 d008124:	20c03126 	beq	r4,r3,d0081ec <__smakebuf_r+0x13c>
 d008128:	8080030b 	ldhu	r2,12(r16)
 d00812c:	00c80004 	movi	r3,8192
 d008130:	10820014 	ori	r2,r2,2048
 d008134:	8080030d 	sth	r2,12(r16)
 d008138:	20c01e26 	beq	r4,r3,d0081b4 <__smakebuf_r+0x104>
 d00813c:	04810004 	movi	r18,1024
 d008140:	8809883a 	mov	r4,r17
 d008144:	900b883a 	mov	r5,r18
 d008148:	d0082440 	call	d008244 <_malloc_r>
 d00814c:	1009883a 	mov	r4,r2
 d008150:	10003126 	beq	r2,zero,d008218 <__smakebuf_r+0x168>
 d008154:	80c0030b 	ldhu	r3,12(r16)
 d008158:	00834034 	movhi	r2,3328
 d00815c:	109cb404 	addi	r2,r2,29392
 d008160:	88800f15 	stw	r2,60(r17)
 d008164:	18c02014 	ori	r3,r3,128
 d008168:	84800515 	stw	r18,20(r16)
 d00816c:	80c0030d 	sth	r3,12(r16)
 d008170:	81000415 	stw	r4,16(r16)
 d008174:	81000015 	stw	r4,0(r16)
 d008178:	dfc01217 	ldw	ra,72(sp)
 d00817c:	dc801117 	ldw	r18,68(sp)
 d008180:	dc401017 	ldw	r17,64(sp)
 d008184:	dc000f17 	ldw	r16,60(sp)
 d008188:	dec01304 	addi	sp,sp,76
 d00818c:	f800283a 	ret
 d008190:	80c0030b 	ldhu	r3,12(r16)
 d008194:	1880200c 	andi	r2,r3,128
 d008198:	10000426 	beq	r2,zero,d0081ac <__smakebuf_r+0xfc>
 d00819c:	04801004 	movi	r18,64
 d0081a0:	18820014 	ori	r2,r3,2048
 d0081a4:	8080030d 	sth	r2,12(r16)
 d0081a8:	003fe506 	br	d008140 <__smakebuf_r+0x90>
 d0081ac:	04810004 	movi	r18,1024
 d0081b0:	003ffb06 	br	d0081a0 <__smakebuf_r+0xf0>
 d0081b4:	8140038f 	ldh	r5,14(r16)
 d0081b8:	8809883a 	mov	r4,r17
 d0081bc:	d00a84c0 	call	d00a84c <_isatty_r>
 d0081c0:	103fde26 	beq	r2,zero,d00813c <__smakebuf_r+0x8c>
 d0081c4:	8080030b 	ldhu	r2,12(r16)
 d0081c8:	80c010c4 	addi	r3,r16,67
 d0081cc:	04810004 	movi	r18,1024
 d0081d0:	10800054 	ori	r2,r2,1
 d0081d4:	8080030d 	sth	r2,12(r16)
 d0081d8:	00800044 	movi	r2,1
 d0081dc:	80c00415 	stw	r3,16(r16)
 d0081e0:	80800515 	stw	r2,20(r16)
 d0081e4:	80c00015 	stw	r3,0(r16)
 d0081e8:	003fd506 	br	d008140 <__smakebuf_r+0x90>
 d0081ec:	80c00a17 	ldw	r3,40(r16)
 d0081f0:	00834074 	movhi	r2,3329
 d0081f4:	10a8c604 	addi	r2,r2,-23784
 d0081f8:	18bfcb1e 	bne	r3,r2,d008128 <__smakebuf_r+0x78>
 d0081fc:	8080030b 	ldhu	r2,12(r16)
 d008200:	00c10004 	movi	r3,1024
 d008204:	1825883a 	mov	r18,r3
 d008208:	10c4b03a 	or	r2,r2,r3
 d00820c:	8080030d 	sth	r2,12(r16)
 d008210:	80c01315 	stw	r3,76(r16)
 d008214:	003fca06 	br	d008140 <__smakebuf_r+0x90>
 d008218:	8100030b 	ldhu	r4,12(r16)
 d00821c:	2080800c 	andi	r2,r4,512
 d008220:	103fb21e 	bne	r2,zero,d0080ec <__smakebuf_r+0x3c>
 d008224:	80c010c4 	addi	r3,r16,67
 d008228:	21000094 	ori	r4,r4,2
 d00822c:	00800044 	movi	r2,1
 d008230:	80800515 	stw	r2,20(r16)
 d008234:	8100030d 	sth	r4,12(r16)
 d008238:	80c00415 	stw	r3,16(r16)
 d00823c:	80c00015 	stw	r3,0(r16)
 d008240:	003faa06 	br	d0080ec <__smakebuf_r+0x3c>

0d008244 <_malloc_r>:
 d008244:	defff604 	addi	sp,sp,-40
 d008248:	28c002c4 	addi	r3,r5,11
 d00824c:	00800584 	movi	r2,22
 d008250:	dc800215 	stw	r18,8(sp)
 d008254:	dfc00915 	stw	ra,36(sp)
 d008258:	df000815 	stw	fp,32(sp)
 d00825c:	ddc00715 	stw	r23,28(sp)
 d008260:	dd800615 	stw	r22,24(sp)
 d008264:	dd400515 	stw	r21,20(sp)
 d008268:	dd000415 	stw	r20,16(sp)
 d00826c:	dcc00315 	stw	r19,12(sp)
 d008270:	dc400115 	stw	r17,4(sp)
 d008274:	dc000015 	stw	r16,0(sp)
 d008278:	2025883a 	mov	r18,r4
 d00827c:	10c01236 	bltu	r2,r3,d0082c8 <_malloc_r+0x84>
 d008280:	04400404 	movi	r17,16
 d008284:	8940142e 	bgeu	r17,r5,d0082d8 <_malloc_r+0x94>
 d008288:	00800304 	movi	r2,12
 d00828c:	0007883a 	mov	r3,zero
 d008290:	90800015 	stw	r2,0(r18)
 d008294:	1805883a 	mov	r2,r3
 d008298:	dfc00917 	ldw	ra,36(sp)
 d00829c:	df000817 	ldw	fp,32(sp)
 d0082a0:	ddc00717 	ldw	r23,28(sp)
 d0082a4:	dd800617 	ldw	r22,24(sp)
 d0082a8:	dd400517 	ldw	r21,20(sp)
 d0082ac:	dd000417 	ldw	r20,16(sp)
 d0082b0:	dcc00317 	ldw	r19,12(sp)
 d0082b4:	dc800217 	ldw	r18,8(sp)
 d0082b8:	dc400117 	ldw	r17,4(sp)
 d0082bc:	dc000017 	ldw	r16,0(sp)
 d0082c0:	dec00a04 	addi	sp,sp,40
 d0082c4:	f800283a 	ret
 d0082c8:	00bffe04 	movi	r2,-8
 d0082cc:	18a2703a 	and	r17,r3,r2
 d0082d0:	883fed16 	blt	r17,zero,d008288 <_malloc_r+0x44>
 d0082d4:	897fec36 	bltu	r17,r5,d008288 <_malloc_r+0x44>
 d0082d8:	9009883a 	mov	r4,r18
 d0082dc:	d00d4dc0 	call	d00d4dc <__malloc_lock>
 d0082e0:	00807dc4 	movi	r2,503
 d0082e4:	14402b2e 	bgeu	r2,r17,d008394 <_malloc_r+0x150>
 d0082e8:	8806d27a 	srli	r3,r17,9
 d0082ec:	18003f1e 	bne	r3,zero,d0083ec <_malloc_r+0x1a8>
 d0082f0:	880cd0fa 	srli	r6,r17,3
 d0082f4:	300490fa 	slli	r2,r6,3
 d0082f8:	02c34174 	movhi	r11,3333
 d0082fc:	5ac37b04 	addi	r11,r11,3564
 d008300:	12cb883a 	add	r5,r2,r11
 d008304:	2c000317 	ldw	r16,12(r5)
 d008308:	580f883a 	mov	r7,r11
 d00830c:	2c00041e 	bne	r5,r16,d008320 <_malloc_r+0xdc>
 d008310:	00000a06 	br	d00833c <_malloc_r+0xf8>
 d008314:	1800860e 	bge	r3,zero,d008530 <_malloc_r+0x2ec>
 d008318:	84000317 	ldw	r16,12(r16)
 d00831c:	2c000726 	beq	r5,r16,d00833c <_malloc_r+0xf8>
 d008320:	80800117 	ldw	r2,4(r16)
 d008324:	00ffff04 	movi	r3,-4
 d008328:	10c8703a 	and	r4,r2,r3
 d00832c:	2447c83a 	sub	r3,r4,r17
 d008330:	008003c4 	movi	r2,15
 d008334:	10fff70e 	bge	r2,r3,d008314 <_malloc_r+0xd0>
 d008338:	31bfffc4 	addi	r6,r6,-1
 d00833c:	32400044 	addi	r9,r6,1
 d008340:	02834174 	movhi	r10,3333
 d008344:	52837d04 	addi	r10,r10,3572
 d008348:	54000217 	ldw	r16,8(r10)
 d00834c:	8280a026 	beq	r16,r10,d0085d0 <_malloc_r+0x38c>
 d008350:	80800117 	ldw	r2,4(r16)
 d008354:	00ffff04 	movi	r3,-4
 d008358:	10ca703a 	and	r5,r2,r3
 d00835c:	2c4dc83a 	sub	r6,r5,r17
 d008360:	008003c4 	movi	r2,15
 d008364:	11808316 	blt	r2,r6,d008574 <_malloc_r+0x330>
 d008368:	52800315 	stw	r10,12(r10)
 d00836c:	52800215 	stw	r10,8(r10)
 d008370:	30002916 	blt	r6,zero,d008418 <_malloc_r+0x1d4>
 d008374:	8147883a 	add	r3,r16,r5
 d008378:	18800117 	ldw	r2,4(r3)
 d00837c:	9009883a 	mov	r4,r18
 d008380:	10800054 	ori	r2,r2,1
 d008384:	18800115 	stw	r2,4(r3)
 d008388:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d00838c:	80c00204 	addi	r3,r16,8
 d008390:	003fc006 	br	d008294 <_malloc_r+0x50>
 d008394:	02c34174 	movhi	r11,3333
 d008398:	5ac37b04 	addi	r11,r11,3564
 d00839c:	8ac5883a 	add	r2,r17,r11
 d0083a0:	14000317 	ldw	r16,12(r2)
 d0083a4:	580f883a 	mov	r7,r11
 d0083a8:	8806d0fa 	srli	r3,r17,3
 d0083ac:	14006c26 	beq	r2,r16,d008560 <_malloc_r+0x31c>
 d0083b0:	80c00117 	ldw	r3,4(r16)
 d0083b4:	00bfff04 	movi	r2,-4
 d0083b8:	81800317 	ldw	r6,12(r16)
 d0083bc:	1886703a 	and	r3,r3,r2
 d0083c0:	80c7883a 	add	r3,r16,r3
 d0083c4:	18800117 	ldw	r2,4(r3)
 d0083c8:	81400217 	ldw	r5,8(r16)
 d0083cc:	9009883a 	mov	r4,r18
 d0083d0:	10800054 	ori	r2,r2,1
 d0083d4:	18800115 	stw	r2,4(r3)
 d0083d8:	31400215 	stw	r5,8(r6)
 d0083dc:	29800315 	stw	r6,12(r5)
 d0083e0:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d0083e4:	80c00204 	addi	r3,r16,8
 d0083e8:	003faa06 	br	d008294 <_malloc_r+0x50>
 d0083ec:	00800104 	movi	r2,4
 d0083f0:	10c0052e 	bgeu	r2,r3,d008408 <_malloc_r+0x1c4>
 d0083f4:	00800504 	movi	r2,20
 d0083f8:	10c07836 	bltu	r2,r3,d0085dc <_malloc_r+0x398>
 d0083fc:	198016c4 	addi	r6,r3,91
 d008400:	300490fa 	slli	r2,r6,3
 d008404:	003fbc06 	br	d0082f8 <_malloc_r+0xb4>
 d008408:	8804d1ba 	srli	r2,r17,6
 d00840c:	11800e04 	addi	r6,r2,56
 d008410:	300490fa 	slli	r2,r6,3
 d008414:	003fb806 	br	d0082f8 <_malloc_r+0xb4>
 d008418:	00807fc4 	movi	r2,511
 d00841c:	1140bb36 	bltu	r2,r5,d00870c <_malloc_r+0x4c8>
 d008420:	2806d0fa 	srli	r3,r5,3
 d008424:	573ffe04 	addi	fp,r10,-8
 d008428:	00800044 	movi	r2,1
 d00842c:	180890fa 	slli	r4,r3,3
 d008430:	1807d0ba 	srai	r3,r3,2
 d008434:	e1c00117 	ldw	r7,4(fp)
 d008438:	5909883a 	add	r4,r11,r4
 d00843c:	21400217 	ldw	r5,8(r4)
 d008440:	10c4983a 	sll	r2,r2,r3
 d008444:	81000315 	stw	r4,12(r16)
 d008448:	81400215 	stw	r5,8(r16)
 d00844c:	388eb03a 	or	r7,r7,r2
 d008450:	2c000315 	stw	r16,12(r5)
 d008454:	24000215 	stw	r16,8(r4)
 d008458:	e1c00115 	stw	r7,4(fp)
 d00845c:	4807883a 	mov	r3,r9
 d008460:	4800cd16 	blt	r9,zero,d008798 <_malloc_r+0x554>
 d008464:	1807d0ba 	srai	r3,r3,2
 d008468:	00800044 	movi	r2,1
 d00846c:	10c8983a 	sll	r4,r2,r3
 d008470:	39004436 	bltu	r7,r4,d008584 <_malloc_r+0x340>
 d008474:	21c4703a 	and	r2,r4,r7
 d008478:	10000a1e 	bne	r2,zero,d0084a4 <_malloc_r+0x260>
 d00847c:	2109883a 	add	r4,r4,r4
 d008480:	00bfff04 	movi	r2,-4
 d008484:	4884703a 	and	r2,r9,r2
 d008488:	3906703a 	and	r3,r7,r4
 d00848c:	12400104 	addi	r9,r2,4
 d008490:	1800041e 	bne	r3,zero,d0084a4 <_malloc_r+0x260>
 d008494:	2109883a 	add	r4,r4,r4
 d008498:	3904703a 	and	r2,r7,r4
 d00849c:	4a400104 	addi	r9,r9,4
 d0084a0:	103ffc26 	beq	r2,zero,d008494 <_malloc_r+0x250>
 d0084a4:	480490fa 	slli	r2,r9,3
 d0084a8:	4819883a 	mov	r12,r9
 d0084ac:	023fff04 	movi	r8,-4
 d0084b0:	589b883a 	add	r13,r11,r2
 d0084b4:	6807883a 	mov	r3,r13
 d0084b8:	014003c4 	movi	r5,15
 d0084bc:	1c000317 	ldw	r16,12(r3)
 d0084c0:	1c00041e 	bne	r3,r16,d0084d4 <_malloc_r+0x290>
 d0084c4:	0000a706 	br	d008764 <_malloc_r+0x520>
 d0084c8:	3000ab0e 	bge	r6,zero,d008778 <_malloc_r+0x534>
 d0084cc:	84000317 	ldw	r16,12(r16)
 d0084d0:	1c00a426 	beq	r3,r16,d008764 <_malloc_r+0x520>
 d0084d4:	80800117 	ldw	r2,4(r16)
 d0084d8:	1204703a 	and	r2,r2,r8
 d0084dc:	144dc83a 	sub	r6,r2,r17
 d0084e0:	29bff90e 	bge	r5,r6,d0084c8 <_malloc_r+0x284>
 d0084e4:	81000317 	ldw	r4,12(r16)
 d0084e8:	80c00217 	ldw	r3,8(r16)
 d0084ec:	89400054 	ori	r5,r17,1
 d0084f0:	8445883a 	add	r2,r16,r17
 d0084f4:	20c00215 	stw	r3,8(r4)
 d0084f8:	19000315 	stw	r4,12(r3)
 d0084fc:	81400115 	stw	r5,4(r16)
 d008500:	1187883a 	add	r3,r2,r6
 d008504:	31000054 	ori	r4,r6,1
 d008508:	50800315 	stw	r2,12(r10)
 d00850c:	50800215 	stw	r2,8(r10)
 d008510:	19800015 	stw	r6,0(r3)
 d008514:	11000115 	stw	r4,4(r2)
 d008518:	12800215 	stw	r10,8(r2)
 d00851c:	12800315 	stw	r10,12(r2)
 d008520:	9009883a 	mov	r4,r18
 d008524:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d008528:	80c00204 	addi	r3,r16,8
 d00852c:	003f5906 	br	d008294 <_malloc_r+0x50>
 d008530:	8109883a 	add	r4,r16,r4
 d008534:	20800117 	ldw	r2,4(r4)
 d008538:	80c00217 	ldw	r3,8(r16)
 d00853c:	81400317 	ldw	r5,12(r16)
 d008540:	10800054 	ori	r2,r2,1
 d008544:	20800115 	stw	r2,4(r4)
 d008548:	28c00215 	stw	r3,8(r5)
 d00854c:	19400315 	stw	r5,12(r3)
 d008550:	9009883a 	mov	r4,r18
 d008554:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d008558:	80c00204 	addi	r3,r16,8
 d00855c:	003f4d06 	br	d008294 <_malloc_r+0x50>
 d008560:	80800204 	addi	r2,r16,8
 d008564:	14000317 	ldw	r16,12(r2)
 d008568:	143f911e 	bne	r2,r16,d0083b0 <_malloc_r+0x16c>
 d00856c:	1a400084 	addi	r9,r3,2
 d008570:	003f7306 	br	d008340 <_malloc_r+0xfc>
 d008574:	88c00054 	ori	r3,r17,1
 d008578:	8445883a 	add	r2,r16,r17
 d00857c:	80c00115 	stw	r3,4(r16)
 d008580:	003fdf06 	br	d008500 <_malloc_r+0x2bc>
 d008584:	e4000217 	ldw	r16,8(fp)
 d008588:	00bfff04 	movi	r2,-4
 d00858c:	80c00117 	ldw	r3,4(r16)
 d008590:	802d883a 	mov	r22,r16
 d008594:	18aa703a 	and	r21,r3,r2
 d008598:	ac401636 	bltu	r21,r17,d0085f4 <_malloc_r+0x3b0>
 d00859c:	ac49c83a 	sub	r4,r21,r17
 d0085a0:	008003c4 	movi	r2,15
 d0085a4:	1100130e 	bge	r2,r4,d0085f4 <_malloc_r+0x3b0>
 d0085a8:	88800054 	ori	r2,r17,1
 d0085ac:	8447883a 	add	r3,r16,r17
 d0085b0:	80800115 	stw	r2,4(r16)
 d0085b4:	20800054 	ori	r2,r4,1
 d0085b8:	18800115 	stw	r2,4(r3)
 d0085bc:	e0c00215 	stw	r3,8(fp)
 d0085c0:	9009883a 	mov	r4,r18
 d0085c4:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d0085c8:	80c00204 	addi	r3,r16,8
 d0085cc:	003f3106 	br	d008294 <_malloc_r+0x50>
 d0085d0:	39c00117 	ldw	r7,4(r7)
 d0085d4:	573ffe04 	addi	fp,r10,-8
 d0085d8:	003fa006 	br	d00845c <_malloc_r+0x218>
 d0085dc:	00801504 	movi	r2,84
 d0085e0:	10c06736 	bltu	r2,r3,d008780 <_malloc_r+0x53c>
 d0085e4:	8804d33a 	srli	r2,r17,12
 d0085e8:	11801b84 	addi	r6,r2,110
 d0085ec:	300490fa 	slli	r2,r6,3
 d0085f0:	003f4106 	br	d0082f8 <_malloc_r+0xb4>
 d0085f4:	d0a06017 	ldw	r2,-32384(gp)
 d0085f8:	d0e00617 	ldw	r3,-32744(gp)
 d0085fc:	053fffc4 	movi	r20,-1
 d008600:	10800404 	addi	r2,r2,16
 d008604:	88a7883a 	add	r19,r17,r2
 d008608:	1d000326 	beq	r3,r20,d008618 <_malloc_r+0x3d4>
 d00860c:	98c3ffc4 	addi	r3,r19,4095
 d008610:	00bc0004 	movi	r2,-4096
 d008614:	18a6703a 	and	r19,r3,r2
 d008618:	9009883a 	mov	r4,r18
 d00861c:	980b883a 	mov	r5,r19
 d008620:	d00a2a00 	call	d00a2a0 <_sbrk_r>
 d008624:	1009883a 	mov	r4,r2
 d008628:	15000426 	beq	r2,r20,d00863c <_malloc_r+0x3f8>
 d00862c:	854b883a 	add	r5,r16,r21
 d008630:	1029883a 	mov	r20,r2
 d008634:	11405a2e 	bgeu	r2,r5,d0087a0 <_malloc_r+0x55c>
 d008638:	87000c26 	beq	r16,fp,d00866c <_malloc_r+0x428>
 d00863c:	e4000217 	ldw	r16,8(fp)
 d008640:	80c00117 	ldw	r3,4(r16)
 d008644:	00bfff04 	movi	r2,-4
 d008648:	1884703a 	and	r2,r3,r2
 d00864c:	14400336 	bltu	r2,r17,d00865c <_malloc_r+0x418>
 d008650:	1449c83a 	sub	r4,r2,r17
 d008654:	008003c4 	movi	r2,15
 d008658:	113fd316 	blt	r2,r4,d0085a8 <_malloc_r+0x364>
 d00865c:	9009883a 	mov	r4,r18
 d008660:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d008664:	0007883a 	mov	r3,zero
 d008668:	003f0a06 	br	d008294 <_malloc_r+0x50>
 d00866c:	05c34174 	movhi	r23,3333
 d008670:	bdcc7a04 	addi	r23,r23,12776
 d008674:	b8800017 	ldw	r2,0(r23)
 d008678:	988d883a 	add	r6,r19,r2
 d00867c:	b9800015 	stw	r6,0(r23)
 d008680:	d0e00617 	ldw	r3,-32744(gp)
 d008684:	00bfffc4 	movi	r2,-1
 d008688:	18808e26 	beq	r3,r2,d0088c4 <_malloc_r+0x680>
 d00868c:	2145c83a 	sub	r2,r4,r5
 d008690:	3085883a 	add	r2,r6,r2
 d008694:	b8800015 	stw	r2,0(r23)
 d008698:	20c001cc 	andi	r3,r4,7
 d00869c:	18005f1e 	bne	r3,zero,d00881c <_malloc_r+0x5d8>
 d0086a0:	000b883a 	mov	r5,zero
 d0086a4:	a4c5883a 	add	r2,r20,r19
 d0086a8:	1083ffcc 	andi	r2,r2,4095
 d0086ac:	00c40004 	movi	r3,4096
 d0086b0:	1887c83a 	sub	r3,r3,r2
 d0086b4:	28e7883a 	add	r19,r5,r3
 d0086b8:	9009883a 	mov	r4,r18
 d0086bc:	980b883a 	mov	r5,r19
 d0086c0:	d00a2a00 	call	d00a2a0 <_sbrk_r>
 d0086c4:	1007883a 	mov	r3,r2
 d0086c8:	00bfffc4 	movi	r2,-1
 d0086cc:	18807a26 	beq	r3,r2,d0088b8 <_malloc_r+0x674>
 d0086d0:	1d05c83a 	sub	r2,r3,r20
 d0086d4:	9885883a 	add	r2,r19,r2
 d0086d8:	10c00054 	ori	r3,r2,1
 d0086dc:	b8800017 	ldw	r2,0(r23)
 d0086e0:	a021883a 	mov	r16,r20
 d0086e4:	a0c00115 	stw	r3,4(r20)
 d0086e8:	9885883a 	add	r2,r19,r2
 d0086ec:	b8800015 	stw	r2,0(r23)
 d0086f0:	e5000215 	stw	r20,8(fp)
 d0086f4:	b7003626 	beq	r22,fp,d0087d0 <_malloc_r+0x58c>
 d0086f8:	018003c4 	movi	r6,15
 d0086fc:	35404b36 	bltu	r6,r21,d00882c <_malloc_r+0x5e8>
 d008700:	00800044 	movi	r2,1
 d008704:	a0800115 	stw	r2,4(r20)
 d008708:	003fcd06 	br	d008640 <_malloc_r+0x3fc>
 d00870c:	2808d27a 	srli	r4,r5,9
 d008710:	2000371e 	bne	r4,zero,d0087f0 <_malloc_r+0x5ac>
 d008714:	2808d0fa 	srli	r4,r5,3
 d008718:	200690fa 	slli	r3,r4,3
 d00871c:	1ad1883a 	add	r8,r3,r11
 d008720:	41800217 	ldw	r6,8(r8)
 d008724:	41805b26 	beq	r8,r6,d008894 <_malloc_r+0x650>
 d008728:	30800117 	ldw	r2,4(r6)
 d00872c:	00ffff04 	movi	r3,-4
 d008730:	10c4703a 	and	r2,r2,r3
 d008734:	2880022e 	bgeu	r5,r2,d008740 <_malloc_r+0x4fc>
 d008738:	31800217 	ldw	r6,8(r6)
 d00873c:	41bffa1e 	bne	r8,r6,d008728 <_malloc_r+0x4e4>
 d008740:	32000317 	ldw	r8,12(r6)
 d008744:	39c00117 	ldw	r7,4(r7)
 d008748:	82000315 	stw	r8,12(r16)
 d00874c:	81800215 	stw	r6,8(r16)
 d008750:	07034174 	movhi	fp,3333
 d008754:	e7037b04 	addi	fp,fp,3564
 d008758:	34000315 	stw	r16,12(r6)
 d00875c:	44000215 	stw	r16,8(r8)
 d008760:	003f3e06 	br	d00845c <_malloc_r+0x218>
 d008764:	63000044 	addi	r12,r12,1
 d008768:	608000cc 	andi	r2,r12,3
 d00876c:	10005d26 	beq	r2,zero,d0088e4 <_malloc_r+0x6a0>
 d008770:	18c00204 	addi	r3,r3,8
 d008774:	003f5106 	br	d0084bc <_malloc_r+0x278>
 d008778:	8089883a 	add	r4,r16,r2
 d00877c:	003f6d06 	br	d008534 <_malloc_r+0x2f0>
 d008780:	00805504 	movi	r2,340
 d008784:	10c02036 	bltu	r2,r3,d008808 <_malloc_r+0x5c4>
 d008788:	8804d3fa 	srli	r2,r17,15
 d00878c:	11801dc4 	addi	r6,r2,119
 d008790:	300490fa 	slli	r2,r6,3
 d008794:	003ed806 	br	d0082f8 <_malloc_r+0xb4>
 d008798:	48c000c4 	addi	r3,r9,3
 d00879c:	003f3106 	br	d008464 <_malloc_r+0x220>
 d0087a0:	05c34174 	movhi	r23,3333
 d0087a4:	bdcc7a04 	addi	r23,r23,12776
 d0087a8:	b8800017 	ldw	r2,0(r23)
 d0087ac:	988d883a 	add	r6,r19,r2
 d0087b0:	b9800015 	stw	r6,0(r23)
 d0087b4:	293fb21e 	bne	r5,r4,d008680 <_malloc_r+0x43c>
 d0087b8:	2083ffcc 	andi	r2,r4,4095
 d0087bc:	103fb01e 	bne	r2,zero,d008680 <_malloc_r+0x43c>
 d0087c0:	e4000217 	ldw	r16,8(fp)
 d0087c4:	9d45883a 	add	r2,r19,r21
 d0087c8:	10800054 	ori	r2,r2,1
 d0087cc:	80800115 	stw	r2,4(r16)
 d0087d0:	b8c00017 	ldw	r3,0(r23)
 d0087d4:	d0a06117 	ldw	r2,-32380(gp)
 d0087d8:	10c0012e 	bgeu	r2,r3,d0087e0 <_malloc_r+0x59c>
 d0087dc:	d0e06115 	stw	r3,-32380(gp)
 d0087e0:	d0a06217 	ldw	r2,-32376(gp)
 d0087e4:	10ff962e 	bgeu	r2,r3,d008640 <_malloc_r+0x3fc>
 d0087e8:	d0e06215 	stw	r3,-32376(gp)
 d0087ec:	003f9406 	br	d008640 <_malloc_r+0x3fc>
 d0087f0:	00800104 	movi	r2,4
 d0087f4:	11001e36 	bltu	r2,r4,d008870 <_malloc_r+0x62c>
 d0087f8:	2804d1ba 	srli	r2,r5,6
 d0087fc:	11000e04 	addi	r4,r2,56
 d008800:	200690fa 	slli	r3,r4,3
 d008804:	003fc506 	br	d00871c <_malloc_r+0x4d8>
 d008808:	00815504 	movi	r2,1364
 d00880c:	10c01d2e 	bgeu	r2,r3,d008884 <_malloc_r+0x640>
 d008810:	01801f84 	movi	r6,126
 d008814:	0080fc04 	movi	r2,1008
 d008818:	003eb706 	br	d0082f8 <_malloc_r+0xb4>
 d00881c:	00800204 	movi	r2,8
 d008820:	10cbc83a 	sub	r5,r2,r3
 d008824:	2169883a 	add	r20,r4,r5
 d008828:	003f9e06 	br	d0086a4 <_malloc_r+0x460>
 d00882c:	00bffe04 	movi	r2,-8
 d008830:	a93ffd04 	addi	r4,r21,-12
 d008834:	2088703a 	and	r4,r4,r2
 d008838:	b10b883a 	add	r5,r22,r4
 d00883c:	00c00144 	movi	r3,5
 d008840:	28c00215 	stw	r3,8(r5)
 d008844:	28c00115 	stw	r3,4(r5)
 d008848:	b0800117 	ldw	r2,4(r22)
 d00884c:	1080004c 	andi	r2,r2,1
 d008850:	2084b03a 	or	r2,r4,r2
 d008854:	b0800115 	stw	r2,4(r22)
 d008858:	313fdd2e 	bgeu	r6,r4,d0087d0 <_malloc_r+0x58c>
 d00885c:	b1400204 	addi	r5,r22,8
 d008860:	9009883a 	mov	r4,r18
 d008864:	d0076bc0 	call	d0076bc <_free_r>
 d008868:	e4000217 	ldw	r16,8(fp)
 d00886c:	003fd806 	br	d0087d0 <_malloc_r+0x58c>
 d008870:	00800504 	movi	r2,20
 d008874:	11001536 	bltu	r2,r4,d0088cc <_malloc_r+0x688>
 d008878:	210016c4 	addi	r4,r4,91
 d00887c:	200690fa 	slli	r3,r4,3
 d008880:	003fa606 	br	d00871c <_malloc_r+0x4d8>
 d008884:	8804d4ba 	srli	r2,r17,18
 d008888:	11801f04 	addi	r6,r2,124
 d00888c:	300490fa 	slli	r2,r6,3
 d008890:	003e9906 	br	d0082f8 <_malloc_r+0xb4>
 d008894:	2009d0ba 	srai	r4,r4,2
 d008898:	01434174 	movhi	r5,3333
 d00889c:	29437b04 	addi	r5,r5,3564
 d0088a0:	00c00044 	movi	r3,1
 d0088a4:	28800117 	ldw	r2,4(r5)
 d0088a8:	1906983a 	sll	r3,r3,r4
 d0088ac:	10c4b03a 	or	r2,r2,r3
 d0088b0:	28800115 	stw	r2,4(r5)
 d0088b4:	003fa306 	br	d008744 <_malloc_r+0x500>
 d0088b8:	0027883a 	mov	r19,zero
 d0088bc:	00c00044 	movi	r3,1
 d0088c0:	003f8606 	br	d0086dc <_malloc_r+0x498>
 d0088c4:	d1200615 	stw	r4,-32744(gp)
 d0088c8:	003f7306 	br	d008698 <_malloc_r+0x454>
 d0088cc:	00801504 	movi	r2,84
 d0088d0:	11001936 	bltu	r2,r4,d008938 <_malloc_r+0x6f4>
 d0088d4:	2804d33a 	srli	r2,r5,12
 d0088d8:	11001b84 	addi	r4,r2,110
 d0088dc:	200690fa 	slli	r3,r4,3
 d0088e0:	003f8e06 	br	d00871c <_malloc_r+0x4d8>
 d0088e4:	480b883a 	mov	r5,r9
 d0088e8:	6807883a 	mov	r3,r13
 d0088ec:	288000cc 	andi	r2,r5,3
 d0088f0:	18fffe04 	addi	r3,r3,-8
 d0088f4:	297fffc4 	addi	r5,r5,-1
 d0088f8:	10001526 	beq	r2,zero,d008950 <_malloc_r+0x70c>
 d0088fc:	18800217 	ldw	r2,8(r3)
 d008900:	10fffa26 	beq	r2,r3,d0088ec <_malloc_r+0x6a8>
 d008904:	2109883a 	add	r4,r4,r4
 d008908:	393f1e36 	bltu	r7,r4,d008584 <_malloc_r+0x340>
 d00890c:	203f1d26 	beq	r4,zero,d008584 <_malloc_r+0x340>
 d008910:	21c4703a 	and	r2,r4,r7
 d008914:	10000226 	beq	r2,zero,d008920 <_malloc_r+0x6dc>
 d008918:	6013883a 	mov	r9,r12
 d00891c:	003ee106 	br	d0084a4 <_malloc_r+0x260>
 d008920:	2109883a 	add	r4,r4,r4
 d008924:	3904703a 	and	r2,r7,r4
 d008928:	63000104 	addi	r12,r12,4
 d00892c:	103ffc26 	beq	r2,zero,d008920 <_malloc_r+0x6dc>
 d008930:	6013883a 	mov	r9,r12
 d008934:	003edb06 	br	d0084a4 <_malloc_r+0x260>
 d008938:	00805504 	movi	r2,340
 d00893c:	11000836 	bltu	r2,r4,d008960 <_malloc_r+0x71c>
 d008940:	2804d3fa 	srli	r2,r5,15
 d008944:	11001dc4 	addi	r4,r2,119
 d008948:	200690fa 	slli	r3,r4,3
 d00894c:	003f7306 	br	d00871c <_malloc_r+0x4d8>
 d008950:	0104303a 	nor	r2,zero,r4
 d008954:	388e703a 	and	r7,r7,r2
 d008958:	e1c00115 	stw	r7,4(fp)
 d00895c:	003fe906 	br	d008904 <_malloc_r+0x6c0>
 d008960:	00815504 	movi	r2,1364
 d008964:	1100032e 	bgeu	r2,r4,d008974 <_malloc_r+0x730>
 d008968:	01001f84 	movi	r4,126
 d00896c:	00c0fc04 	movi	r3,1008
 d008970:	003f6a06 	br	d00871c <_malloc_r+0x4d8>
 d008974:	2804d4ba 	srli	r2,r5,18
 d008978:	11001f04 	addi	r4,r2,124
 d00897c:	200690fa 	slli	r3,r4,3
 d008980:	003f6606 	br	d00871c <_malloc_r+0x4d8>

0d008984 <memchr>:
 d008984:	008000c4 	movi	r2,3
 d008988:	29403fcc 	andi	r5,r5,255
 d00898c:	2007883a 	mov	r3,r4
 d008990:	1180022e 	bgeu	r2,r6,d00899c <memchr+0x18>
 d008994:	2084703a 	and	r2,r4,r2
 d008998:	10000b26 	beq	r2,zero,d0089c8 <memchr+0x44>
 d00899c:	313fffc4 	addi	r4,r6,-1
 d0089a0:	3000051e 	bne	r6,zero,d0089b8 <memchr+0x34>
 d0089a4:	00002c06 	br	d008a58 <memchr+0xd4>
 d0089a8:	213fffc4 	addi	r4,r4,-1
 d0089ac:	00bfffc4 	movi	r2,-1
 d0089b0:	18c00044 	addi	r3,r3,1
 d0089b4:	20802826 	beq	r4,r2,d008a58 <memchr+0xd4>
 d0089b8:	18800003 	ldbu	r2,0(r3)
 d0089bc:	28bffa1e 	bne	r5,r2,d0089a8 <memchr+0x24>
 d0089c0:	1805883a 	mov	r2,r3
 d0089c4:	f800283a 	ret
 d0089c8:	0011883a 	mov	r8,zero
 d0089cc:	0007883a 	mov	r3,zero
 d0089d0:	01c00104 	movi	r7,4
 d0089d4:	4004923a 	slli	r2,r8,8
 d0089d8:	18c00044 	addi	r3,r3,1
 d0089dc:	1151883a 	add	r8,r2,r5
 d0089e0:	19fffc1e 	bne	r3,r7,d0089d4 <memchr+0x50>
 d0089e4:	02bfbff4 	movhi	r10,65279
 d0089e8:	52bfbfc4 	addi	r10,r10,-257
 d0089ec:	02602074 	movhi	r9,32897
 d0089f0:	4a602004 	addi	r9,r9,-32640
 d0089f4:	02c000c4 	movi	r11,3
 d0089f8:	20800017 	ldw	r2,0(r4)
 d0089fc:	31bfff04 	addi	r6,r6,-4
 d008a00:	200f883a 	mov	r7,r4
 d008a04:	1204f03a 	xor	r2,r2,r8
 d008a08:	1287883a 	add	r3,r2,r10
 d008a0c:	1a46703a 	and	r3,r3,r9
 d008a10:	0084303a 	nor	r2,zero,r2
 d008a14:	10c4703a 	and	r2,r2,r3
 d008a18:	10000b26 	beq	r2,zero,d008a48 <memchr+0xc4>
 d008a1c:	20800003 	ldbu	r2,0(r4)
 d008a20:	28800f26 	beq	r5,r2,d008a60 <memchr+0xdc>
 d008a24:	20800043 	ldbu	r2,1(r4)
 d008a28:	21c00044 	addi	r7,r4,1
 d008a2c:	28800c26 	beq	r5,r2,d008a60 <memchr+0xdc>
 d008a30:	20800083 	ldbu	r2,2(r4)
 d008a34:	21c00084 	addi	r7,r4,2
 d008a38:	28800926 	beq	r5,r2,d008a60 <memchr+0xdc>
 d008a3c:	208000c3 	ldbu	r2,3(r4)
 d008a40:	21c000c4 	addi	r7,r4,3
 d008a44:	28800626 	beq	r5,r2,d008a60 <memchr+0xdc>
 d008a48:	21000104 	addi	r4,r4,4
 d008a4c:	59bfea36 	bltu	r11,r6,d0089f8 <memchr+0x74>
 d008a50:	2007883a 	mov	r3,r4
 d008a54:	003fd106 	br	d00899c <memchr+0x18>
 d008a58:	0005883a 	mov	r2,zero
 d008a5c:	f800283a 	ret
 d008a60:	3805883a 	mov	r2,r7
 d008a64:	f800283a 	ret

0d008a68 <_Bfree>:
 d008a68:	28000826 	beq	r5,zero,d008a8c <_Bfree+0x24>
 d008a6c:	28800117 	ldw	r2,4(r5)
 d008a70:	21001317 	ldw	r4,76(r4)
 d008a74:	1085883a 	add	r2,r2,r2
 d008a78:	1085883a 	add	r2,r2,r2
 d008a7c:	1105883a 	add	r2,r2,r4
 d008a80:	10c00017 	ldw	r3,0(r2)
 d008a84:	28c00015 	stw	r3,0(r5)
 d008a88:	11400015 	stw	r5,0(r2)
 d008a8c:	f800283a 	ret

0d008a90 <__hi0bits>:
 d008a90:	20bfffec 	andhi	r2,r4,65535
 d008a94:	10001426 	beq	r2,zero,d008ae8 <__hi0bits+0x58>
 d008a98:	0007883a 	mov	r3,zero
 d008a9c:	20bfc02c 	andhi	r2,r4,65280
 d008aa0:	1000021e 	bne	r2,zero,d008aac <__hi0bits+0x1c>
 d008aa4:	2008923a 	slli	r4,r4,8
 d008aa8:	18c00204 	addi	r3,r3,8
 d008aac:	20bc002c 	andhi	r2,r4,61440
 d008ab0:	1000021e 	bne	r2,zero,d008abc <__hi0bits+0x2c>
 d008ab4:	2008913a 	slli	r4,r4,4
 d008ab8:	18c00104 	addi	r3,r3,4
 d008abc:	20b0002c 	andhi	r2,r4,49152
 d008ac0:	1000031e 	bne	r2,zero,d008ad0 <__hi0bits+0x40>
 d008ac4:	2105883a 	add	r2,r4,r4
 d008ac8:	18c00084 	addi	r3,r3,2
 d008acc:	1089883a 	add	r4,r2,r2
 d008ad0:	20000316 	blt	r4,zero,d008ae0 <__hi0bits+0x50>
 d008ad4:	2090002c 	andhi	r2,r4,16384
 d008ad8:	10000626 	beq	r2,zero,d008af4 <__hi0bits+0x64>
 d008adc:	18c00044 	addi	r3,r3,1
 d008ae0:	1805883a 	mov	r2,r3
 d008ae4:	f800283a 	ret
 d008ae8:	2008943a 	slli	r4,r4,16
 d008aec:	00c00404 	movi	r3,16
 d008af0:	003fea06 	br	d008a9c <__hi0bits+0xc>
 d008af4:	00c00804 	movi	r3,32
 d008af8:	1805883a 	mov	r2,r3
 d008afc:	f800283a 	ret

0d008b00 <__lo0bits>:
 d008b00:	20c00017 	ldw	r3,0(r4)
 d008b04:	188001cc 	andi	r2,r3,7
 d008b08:	10000a26 	beq	r2,zero,d008b34 <__lo0bits+0x34>
 d008b0c:	1880004c 	andi	r2,r3,1
 d008b10:	1005003a 	cmpeq	r2,r2,zero
 d008b14:	10002126 	beq	r2,zero,d008b9c <__lo0bits+0x9c>
 d008b18:	1880008c 	andi	r2,r3,2
 d008b1c:	1000251e 	bne	r2,zero,d008bb4 <__lo0bits+0xb4>
 d008b20:	1804d0ba 	srli	r2,r3,2
 d008b24:	01400084 	movi	r5,2
 d008b28:	20800015 	stw	r2,0(r4)
 d008b2c:	2805883a 	mov	r2,r5
 d008b30:	f800283a 	ret
 d008b34:	18bfffcc 	andi	r2,r3,65535
 d008b38:	10001526 	beq	r2,zero,d008b90 <__lo0bits+0x90>
 d008b3c:	000b883a 	mov	r5,zero
 d008b40:	18803fcc 	andi	r2,r3,255
 d008b44:	1000021e 	bne	r2,zero,d008b50 <__lo0bits+0x50>
 d008b48:	1806d23a 	srli	r3,r3,8
 d008b4c:	29400204 	addi	r5,r5,8
 d008b50:	188003cc 	andi	r2,r3,15
 d008b54:	1000021e 	bne	r2,zero,d008b60 <__lo0bits+0x60>
 d008b58:	1806d13a 	srli	r3,r3,4
 d008b5c:	29400104 	addi	r5,r5,4
 d008b60:	188000cc 	andi	r2,r3,3
 d008b64:	1000021e 	bne	r2,zero,d008b70 <__lo0bits+0x70>
 d008b68:	1806d0ba 	srli	r3,r3,2
 d008b6c:	29400084 	addi	r5,r5,2
 d008b70:	1880004c 	andi	r2,r3,1
 d008b74:	1000031e 	bne	r2,zero,d008b84 <__lo0bits+0x84>
 d008b78:	1806d07a 	srli	r3,r3,1
 d008b7c:	18000a26 	beq	r3,zero,d008ba8 <__lo0bits+0xa8>
 d008b80:	29400044 	addi	r5,r5,1
 d008b84:	2805883a 	mov	r2,r5
 d008b88:	20c00015 	stw	r3,0(r4)
 d008b8c:	f800283a 	ret
 d008b90:	1806d43a 	srli	r3,r3,16
 d008b94:	01400404 	movi	r5,16
 d008b98:	003fe906 	br	d008b40 <__lo0bits+0x40>
 d008b9c:	000b883a 	mov	r5,zero
 d008ba0:	2805883a 	mov	r2,r5
 d008ba4:	f800283a 	ret
 d008ba8:	01400804 	movi	r5,32
 d008bac:	2805883a 	mov	r2,r5
 d008bb0:	f800283a 	ret
 d008bb4:	1804d07a 	srli	r2,r3,1
 d008bb8:	01400044 	movi	r5,1
 d008bbc:	20800015 	stw	r2,0(r4)
 d008bc0:	003fda06 	br	d008b2c <__lo0bits+0x2c>

0d008bc4 <__mcmp>:
 d008bc4:	20800417 	ldw	r2,16(r4)
 d008bc8:	28c00417 	ldw	r3,16(r5)
 d008bcc:	10cfc83a 	sub	r7,r2,r3
 d008bd0:	38000c1e 	bne	r7,zero,d008c04 <__mcmp+0x40>
 d008bd4:	18c5883a 	add	r2,r3,r3
 d008bd8:	1085883a 	add	r2,r2,r2
 d008bdc:	10c00504 	addi	r3,r2,20
 d008be0:	21000504 	addi	r4,r4,20
 d008be4:	28cb883a 	add	r5,r5,r3
 d008be8:	2085883a 	add	r2,r4,r2
 d008bec:	10bfff04 	addi	r2,r2,-4
 d008bf0:	297fff04 	addi	r5,r5,-4
 d008bf4:	11800017 	ldw	r6,0(r2)
 d008bf8:	28c00017 	ldw	r3,0(r5)
 d008bfc:	30c0031e 	bne	r6,r3,d008c0c <__mcmp+0x48>
 d008c00:	20bffa36 	bltu	r4,r2,d008bec <__mcmp+0x28>
 d008c04:	3805883a 	mov	r2,r7
 d008c08:	f800283a 	ret
 d008c0c:	30c00336 	bltu	r6,r3,d008c1c <__mcmp+0x58>
 d008c10:	01c00044 	movi	r7,1
 d008c14:	3805883a 	mov	r2,r7
 d008c18:	f800283a 	ret
 d008c1c:	01ffffc4 	movi	r7,-1
 d008c20:	003ff806 	br	d008c04 <__mcmp+0x40>

0d008c24 <__ulp>:
 d008c24:	295ffc2c 	andhi	r5,r5,32752
 d008c28:	013f3034 	movhi	r4,64704
 d008c2c:	290b883a 	add	r5,r5,r4
 d008c30:	0145c83a 	sub	r2,zero,r5
 d008c34:	1007d53a 	srai	r3,r2,20
 d008c38:	000d883a 	mov	r6,zero
 d008c3c:	0140040e 	bge	zero,r5,d008c50 <__ulp+0x2c>
 d008c40:	280f883a 	mov	r7,r5
 d008c44:	3807883a 	mov	r3,r7
 d008c48:	3005883a 	mov	r2,r6
 d008c4c:	f800283a 	ret
 d008c50:	008004c4 	movi	r2,19
 d008c54:	193ffb04 	addi	r4,r3,-20
 d008c58:	10c00c0e 	bge	r2,r3,d008c8c <__ulp+0x68>
 d008c5c:	008007c4 	movi	r2,31
 d008c60:	1107c83a 	sub	r3,r2,r4
 d008c64:	00800784 	movi	r2,30
 d008c68:	01400044 	movi	r5,1
 d008c6c:	11000216 	blt	r2,r4,d008c78 <__ulp+0x54>
 d008c70:	00800044 	movi	r2,1
 d008c74:	10ca983a 	sll	r5,r2,r3
 d008c78:	000f883a 	mov	r7,zero
 d008c7c:	280d883a 	mov	r6,r5
 d008c80:	3807883a 	mov	r3,r7
 d008c84:	3005883a 	mov	r2,r6
 d008c88:	f800283a 	ret
 d008c8c:	00800234 	movhi	r2,8
 d008c90:	10cfd83a 	sra	r7,r2,r3
 d008c94:	000d883a 	mov	r6,zero
 d008c98:	3005883a 	mov	r2,r6
 d008c9c:	3807883a 	mov	r3,r7
 d008ca0:	f800283a 	ret

0d008ca4 <__b2d>:
 d008ca4:	20800417 	ldw	r2,16(r4)
 d008ca8:	defff904 	addi	sp,sp,-28
 d008cac:	dd000415 	stw	r20,16(sp)
 d008cb0:	1085883a 	add	r2,r2,r2
 d008cb4:	25000504 	addi	r20,r4,20
 d008cb8:	1085883a 	add	r2,r2,r2
 d008cbc:	dc000015 	stw	r16,0(sp)
 d008cc0:	a0a1883a 	add	r16,r20,r2
 d008cc4:	dd400515 	stw	r21,20(sp)
 d008cc8:	857fff17 	ldw	r21,-4(r16)
 d008ccc:	dc400115 	stw	r17,4(sp)
 d008cd0:	dfc00615 	stw	ra,24(sp)
 d008cd4:	a809883a 	mov	r4,r21
 d008cd8:	2823883a 	mov	r17,r5
 d008cdc:	dcc00315 	stw	r19,12(sp)
 d008ce0:	dc800215 	stw	r18,8(sp)
 d008ce4:	d008a900 	call	d008a90 <__hi0bits>
 d008ce8:	100b883a 	mov	r5,r2
 d008cec:	00800804 	movi	r2,32
 d008cf0:	1145c83a 	sub	r2,r2,r5
 d008cf4:	88800015 	stw	r2,0(r17)
 d008cf8:	00800284 	movi	r2,10
 d008cfc:	80ffff04 	addi	r3,r16,-4
 d008d00:	11401416 	blt	r2,r5,d008d54 <__b2d+0xb0>
 d008d04:	008002c4 	movi	r2,11
 d008d08:	1149c83a 	sub	r4,r2,r5
 d008d0c:	a0c02736 	bltu	r20,r3,d008dac <__b2d+0x108>
 d008d10:	000d883a 	mov	r6,zero
 d008d14:	28800544 	addi	r2,r5,21
 d008d18:	a906d83a 	srl	r3,r21,r4
 d008d1c:	a884983a 	sll	r2,r21,r2
 d008d20:	1ccffc34 	orhi	r19,r3,16368
 d008d24:	11a4b03a 	or	r18,r2,r6
 d008d28:	9005883a 	mov	r2,r18
 d008d2c:	9807883a 	mov	r3,r19
 d008d30:	dfc00617 	ldw	ra,24(sp)
 d008d34:	dd400517 	ldw	r21,20(sp)
 d008d38:	dd000417 	ldw	r20,16(sp)
 d008d3c:	dcc00317 	ldw	r19,12(sp)
 d008d40:	dc800217 	ldw	r18,8(sp)
 d008d44:	dc400117 	ldw	r17,4(sp)
 d008d48:	dc000017 	ldw	r16,0(sp)
 d008d4c:	dec00704 	addi	sp,sp,28
 d008d50:	f800283a 	ret
 d008d54:	a0c00e36 	bltu	r20,r3,d008d90 <__b2d+0xec>
 d008d58:	293ffd44 	addi	r4,r5,-11
 d008d5c:	000d883a 	mov	r6,zero
 d008d60:	20000f26 	beq	r4,zero,d008da0 <__b2d+0xfc>
 d008d64:	00800804 	movi	r2,32
 d008d68:	110bc83a 	sub	r5,r2,r4
 d008d6c:	a0c01236 	bltu	r20,r3,d008db8 <__b2d+0x114>
 d008d70:	000f883a 	mov	r7,zero
 d008d74:	a904983a 	sll	r2,r21,r4
 d008d78:	3146d83a 	srl	r3,r6,r5
 d008d7c:	3108983a 	sll	r4,r6,r4
 d008d80:	108ffc34 	orhi	r2,r2,16368
 d008d84:	18a6b03a 	or	r19,r3,r2
 d008d88:	3924b03a 	or	r18,r7,r4
 d008d8c:	003fe606 	br	d008d28 <__b2d+0x84>
 d008d90:	293ffd44 	addi	r4,r5,-11
 d008d94:	81bffe17 	ldw	r6,-8(r16)
 d008d98:	80fffe04 	addi	r3,r16,-8
 d008d9c:	203ff11e 	bne	r4,zero,d008d64 <__b2d+0xc0>
 d008da0:	accffc34 	orhi	r19,r21,16368
 d008da4:	3025883a 	mov	r18,r6
 d008da8:	003fdf06 	br	d008d28 <__b2d+0x84>
 d008dac:	18bfff17 	ldw	r2,-4(r3)
 d008db0:	110cd83a 	srl	r6,r2,r4
 d008db4:	003fd706 	br	d008d14 <__b2d+0x70>
 d008db8:	18bfff17 	ldw	r2,-4(r3)
 d008dbc:	114ed83a 	srl	r7,r2,r5
 d008dc0:	003fec06 	br	d008d74 <__b2d+0xd0>

0d008dc4 <__ratio>:
 d008dc4:	defff904 	addi	sp,sp,-28
 d008dc8:	dc400215 	stw	r17,8(sp)
 d008dcc:	2823883a 	mov	r17,r5
 d008dd0:	d80b883a 	mov	r5,sp
 d008dd4:	dfc00615 	stw	ra,24(sp)
 d008dd8:	dd000515 	stw	r20,20(sp)
 d008ddc:	dcc00415 	stw	r19,16(sp)
 d008de0:	dc800315 	stw	r18,12(sp)
 d008de4:	2025883a 	mov	r18,r4
 d008de8:	d008ca40 	call	d008ca4 <__b2d>
 d008dec:	8809883a 	mov	r4,r17
 d008df0:	d9400104 	addi	r5,sp,4
 d008df4:	1027883a 	mov	r19,r2
 d008df8:	1829883a 	mov	r20,r3
 d008dfc:	d008ca40 	call	d008ca4 <__b2d>
 d008e00:	89000417 	ldw	r4,16(r17)
 d008e04:	91c00417 	ldw	r7,16(r18)
 d008e08:	d9800117 	ldw	r6,4(sp)
 d008e0c:	180b883a 	mov	r5,r3
 d008e10:	390fc83a 	sub	r7,r7,r4
 d008e14:	1009883a 	mov	r4,r2
 d008e18:	d8800017 	ldw	r2,0(sp)
 d008e1c:	380e917a 	slli	r7,r7,5
 d008e20:	2011883a 	mov	r8,r4
 d008e24:	1185c83a 	sub	r2,r2,r6
 d008e28:	11c5883a 	add	r2,r2,r7
 d008e2c:	1006953a 	slli	r3,r2,20
 d008e30:	2813883a 	mov	r9,r5
 d008e34:	00800d0e 	bge	zero,r2,d008e6c <__ratio+0xa8>
 d008e38:	1d29883a 	add	r20,r3,r20
 d008e3c:	a00b883a 	mov	r5,r20
 d008e40:	480f883a 	mov	r7,r9
 d008e44:	9809883a 	mov	r4,r19
 d008e48:	400d883a 	mov	r6,r8
 d008e4c:	d00be000 	call	d00be00 <__divdf3>
 d008e50:	dfc00617 	ldw	ra,24(sp)
 d008e54:	dd000517 	ldw	r20,20(sp)
 d008e58:	dcc00417 	ldw	r19,16(sp)
 d008e5c:	dc800317 	ldw	r18,12(sp)
 d008e60:	dc400217 	ldw	r17,8(sp)
 d008e64:	dec00704 	addi	sp,sp,28
 d008e68:	f800283a 	ret
 d008e6c:	28d3c83a 	sub	r9,r5,r3
 d008e70:	003ff206 	br	d008e3c <__ratio+0x78>

0d008e74 <_mprec_log10>:
 d008e74:	defffe04 	addi	sp,sp,-8
 d008e78:	008005c4 	movi	r2,23
 d008e7c:	dc000015 	stw	r16,0(sp)
 d008e80:	dfc00115 	stw	ra,4(sp)
 d008e84:	2021883a 	mov	r16,r4
 d008e88:	11000c16 	blt	r2,r4,d008ebc <_mprec_log10+0x48>
 d008e8c:	200490fa 	slli	r2,r4,3
 d008e90:	00c34174 	movhi	r3,3333
 d008e94:	18f12004 	addi	r3,r3,-15232
 d008e98:	10c5883a 	add	r2,r2,r3
 d008e9c:	12400117 	ldw	r9,4(r2)
 d008ea0:	12000017 	ldw	r8,0(r2)
 d008ea4:	4807883a 	mov	r3,r9
 d008ea8:	4005883a 	mov	r2,r8
 d008eac:	dfc00117 	ldw	ra,4(sp)
 d008eb0:	dc000017 	ldw	r16,0(sp)
 d008eb4:	dec00204 	addi	sp,sp,8
 d008eb8:	f800283a 	ret
 d008ebc:	0011883a 	mov	r8,zero
 d008ec0:	024ffc34 	movhi	r9,16368
 d008ec4:	0005883a 	mov	r2,zero
 d008ec8:	00d00934 	movhi	r3,16420
 d008ecc:	480b883a 	mov	r5,r9
 d008ed0:	4009883a 	mov	r4,r8
 d008ed4:	180f883a 	mov	r7,r3
 d008ed8:	100d883a 	mov	r6,r2
 d008edc:	d00ba3c0 	call	d00ba3c <__muldf3>
 d008ee0:	843fffc4 	addi	r16,r16,-1
 d008ee4:	1011883a 	mov	r8,r2
 d008ee8:	1813883a 	mov	r9,r3
 d008eec:	803ff51e 	bne	r16,zero,d008ec4 <_mprec_log10+0x50>
 d008ef0:	4005883a 	mov	r2,r8
 d008ef4:	4807883a 	mov	r3,r9
 d008ef8:	dfc00117 	ldw	ra,4(sp)
 d008efc:	dc000017 	ldw	r16,0(sp)
 d008f00:	dec00204 	addi	sp,sp,8
 d008f04:	f800283a 	ret

0d008f08 <__copybits>:
 d008f08:	297fffc4 	addi	r5,r5,-1
 d008f0c:	30800417 	ldw	r2,16(r6)
 d008f10:	280bd17a 	srai	r5,r5,5
 d008f14:	31800504 	addi	r6,r6,20
 d008f18:	1085883a 	add	r2,r2,r2
 d008f1c:	294b883a 	add	r5,r5,r5
 d008f20:	294b883a 	add	r5,r5,r5
 d008f24:	1085883a 	add	r2,r2,r2
 d008f28:	290b883a 	add	r5,r5,r4
 d008f2c:	3087883a 	add	r3,r6,r2
 d008f30:	29400104 	addi	r5,r5,4
 d008f34:	30c0052e 	bgeu	r6,r3,d008f4c <__copybits+0x44>
 d008f38:	30800017 	ldw	r2,0(r6)
 d008f3c:	31800104 	addi	r6,r6,4
 d008f40:	20800015 	stw	r2,0(r4)
 d008f44:	21000104 	addi	r4,r4,4
 d008f48:	30fffb36 	bltu	r6,r3,d008f38 <__copybits+0x30>
 d008f4c:	2140032e 	bgeu	r4,r5,d008f5c <__copybits+0x54>
 d008f50:	20000015 	stw	zero,0(r4)
 d008f54:	21000104 	addi	r4,r4,4
 d008f58:	217ffd36 	bltu	r4,r5,d008f50 <__copybits+0x48>
 d008f5c:	f800283a 	ret

0d008f60 <__any_on>:
 d008f60:	20800417 	ldw	r2,16(r4)
 d008f64:	2807d17a 	srai	r3,r5,5
 d008f68:	21000504 	addi	r4,r4,20
 d008f6c:	10c00d0e 	bge	r2,r3,d008fa4 <__any_on+0x44>
 d008f70:	1085883a 	add	r2,r2,r2
 d008f74:	1085883a 	add	r2,r2,r2
 d008f78:	208d883a 	add	r6,r4,r2
 d008f7c:	2180182e 	bgeu	r4,r6,d008fe0 <__any_on+0x80>
 d008f80:	30bfff17 	ldw	r2,-4(r6)
 d008f84:	30ffff04 	addi	r3,r6,-4
 d008f88:	1000041e 	bne	r2,zero,d008f9c <__any_on+0x3c>
 d008f8c:	20c0142e 	bgeu	r4,r3,d008fe0 <__any_on+0x80>
 d008f90:	18ffff04 	addi	r3,r3,-4
 d008f94:	18800017 	ldw	r2,0(r3)
 d008f98:	103ffc26 	beq	r2,zero,d008f8c <__any_on+0x2c>
 d008f9c:	00800044 	movi	r2,1
 d008fa0:	f800283a 	ret
 d008fa4:	18800a0e 	bge	r3,r2,d008fd0 <__any_on+0x70>
 d008fa8:	294007cc 	andi	r5,r5,31
 d008fac:	28000826 	beq	r5,zero,d008fd0 <__any_on+0x70>
 d008fb0:	18c5883a 	add	r2,r3,r3
 d008fb4:	1085883a 	add	r2,r2,r2
 d008fb8:	208d883a 	add	r6,r4,r2
 d008fbc:	30c00017 	ldw	r3,0(r6)
 d008fc0:	1944d83a 	srl	r2,r3,r5
 d008fc4:	1144983a 	sll	r2,r2,r5
 d008fc8:	18bff41e 	bne	r3,r2,d008f9c <__any_on+0x3c>
 d008fcc:	003feb06 	br	d008f7c <__any_on+0x1c>
 d008fd0:	18c5883a 	add	r2,r3,r3
 d008fd4:	1085883a 	add	r2,r2,r2
 d008fd8:	208d883a 	add	r6,r4,r2
 d008fdc:	003fe706 	br	d008f7c <__any_on+0x1c>
 d008fe0:	0005883a 	mov	r2,zero
 d008fe4:	f800283a 	ret

0d008fe8 <_Balloc>:
 d008fe8:	20c01317 	ldw	r3,76(r4)
 d008fec:	defffb04 	addi	sp,sp,-20
 d008ff0:	dcc00315 	stw	r19,12(sp)
 d008ff4:	dc800215 	stw	r18,8(sp)
 d008ff8:	dfc00415 	stw	ra,16(sp)
 d008ffc:	2825883a 	mov	r18,r5
 d009000:	dc400115 	stw	r17,4(sp)
 d009004:	dc000015 	stw	r16,0(sp)
 d009008:	2027883a 	mov	r19,r4
 d00900c:	01800404 	movi	r6,16
 d009010:	01400104 	movi	r5,4
 d009014:	18001726 	beq	r3,zero,d009074 <_Balloc+0x8c>
 d009018:	01400044 	movi	r5,1
 d00901c:	9485883a 	add	r2,r18,r18
 d009020:	2ca2983a 	sll	r17,r5,r18
 d009024:	1085883a 	add	r2,r2,r2
 d009028:	10c7883a 	add	r3,r2,r3
 d00902c:	1c000017 	ldw	r16,0(r3)
 d009030:	8c4d883a 	add	r6,r17,r17
 d009034:	318d883a 	add	r6,r6,r6
 d009038:	9809883a 	mov	r4,r19
 d00903c:	31800504 	addi	r6,r6,20
 d009040:	80001226 	beq	r16,zero,d00908c <_Balloc+0xa4>
 d009044:	80800017 	ldw	r2,0(r16)
 d009048:	18800015 	stw	r2,0(r3)
 d00904c:	80000415 	stw	zero,16(r16)
 d009050:	80000315 	stw	zero,12(r16)
 d009054:	8005883a 	mov	r2,r16
 d009058:	dfc00417 	ldw	ra,16(sp)
 d00905c:	dcc00317 	ldw	r19,12(sp)
 d009060:	dc800217 	ldw	r18,8(sp)
 d009064:	dc400117 	ldw	r17,4(sp)
 d009068:	dc000017 	ldw	r16,0(sp)
 d00906c:	dec00504 	addi	sp,sp,20
 d009070:	f800283a 	ret
 d009074:	d00a5900 	call	d00a590 <_calloc_r>
 d009078:	1007883a 	mov	r3,r2
 d00907c:	0021883a 	mov	r16,zero
 d009080:	98801315 	stw	r2,76(r19)
 d009084:	103fe41e 	bne	r2,zero,d009018 <_Balloc+0x30>
 d009088:	003ff206 	br	d009054 <_Balloc+0x6c>
 d00908c:	d00a5900 	call	d00a590 <_calloc_r>
 d009090:	103ff026 	beq	r2,zero,d009054 <_Balloc+0x6c>
 d009094:	1021883a 	mov	r16,r2
 d009098:	14800115 	stw	r18,4(r2)
 d00909c:	14400215 	stw	r17,8(r2)
 d0090a0:	003fea06 	br	d00904c <_Balloc+0x64>

0d0090a4 <__d2b>:
 d0090a4:	defff504 	addi	sp,sp,-44
 d0090a8:	dcc00515 	stw	r19,20(sp)
 d0090ac:	04c00044 	movi	r19,1
 d0090b0:	dc000215 	stw	r16,8(sp)
 d0090b4:	2821883a 	mov	r16,r5
 d0090b8:	980b883a 	mov	r5,r19
 d0090bc:	ddc00915 	stw	r23,36(sp)
 d0090c0:	dd800815 	stw	r22,32(sp)
 d0090c4:	dd400715 	stw	r21,28(sp)
 d0090c8:	dd000615 	stw	r20,24(sp)
 d0090cc:	dc800415 	stw	r18,16(sp)
 d0090d0:	dc400315 	stw	r17,12(sp)
 d0090d4:	dfc00a15 	stw	ra,40(sp)
 d0090d8:	3023883a 	mov	r17,r6
 d0090dc:	382d883a 	mov	r22,r7
 d0090e0:	ddc00b17 	ldw	r23,44(sp)
 d0090e4:	d008fe80 	call	d008fe8 <_Balloc>
 d0090e8:	1025883a 	mov	r18,r2
 d0090ec:	00a00034 	movhi	r2,32768
 d0090f0:	10bfffc4 	addi	r2,r2,-1
 d0090f4:	8888703a 	and	r4,r17,r2
 d0090f8:	202ad53a 	srli	r21,r4,20
 d0090fc:	00800434 	movhi	r2,16
 d009100:	10bfffc4 	addi	r2,r2,-1
 d009104:	8886703a 	and	r3,r17,r2
 d009108:	a829003a 	cmpeq	r20,r21,zero
 d00910c:	800b883a 	mov	r5,r16
 d009110:	d8c00115 	stw	r3,4(sp)
 d009114:	94000504 	addi	r16,r18,20
 d009118:	a000021e 	bne	r20,zero,d009124 <__d2b+0x80>
 d00911c:	18c00434 	orhi	r3,r3,16
 d009120:	d8c00115 	stw	r3,4(sp)
 d009124:	28002726 	beq	r5,zero,d0091c4 <__d2b+0x120>
 d009128:	d809883a 	mov	r4,sp
 d00912c:	d9400015 	stw	r5,0(sp)
 d009130:	d008b000 	call	d008b00 <__lo0bits>
 d009134:	100d883a 	mov	r6,r2
 d009138:	10003526 	beq	r2,zero,d009210 <__d2b+0x16c>
 d00913c:	d8c00117 	ldw	r3,4(sp)
 d009140:	00800804 	movi	r2,32
 d009144:	1185c83a 	sub	r2,r2,r6
 d009148:	d9000017 	ldw	r4,0(sp)
 d00914c:	1886983a 	sll	r3,r3,r2
 d009150:	1906b03a 	or	r3,r3,r4
 d009154:	90c00515 	stw	r3,20(r18)
 d009158:	d8c00117 	ldw	r3,4(sp)
 d00915c:	1986d83a 	srl	r3,r3,r6
 d009160:	d8c00115 	stw	r3,4(sp)
 d009164:	180b003a 	cmpeq	r5,r3,zero
 d009168:	00800084 	movi	r2,2
 d00916c:	114bc83a 	sub	r5,r2,r5
 d009170:	80c00115 	stw	r3,4(r16)
 d009174:	91400415 	stw	r5,16(r18)
 d009178:	a0001a1e 	bne	r20,zero,d0091e4 <__d2b+0x140>
 d00917c:	3545883a 	add	r2,r6,r21
 d009180:	10bef344 	addi	r2,r2,-1075
 d009184:	00c00d44 	movi	r3,53
 d009188:	b0800015 	stw	r2,0(r22)
 d00918c:	1987c83a 	sub	r3,r3,r6
 d009190:	b8c00015 	stw	r3,0(r23)
 d009194:	9005883a 	mov	r2,r18
 d009198:	dfc00a17 	ldw	ra,40(sp)
 d00919c:	ddc00917 	ldw	r23,36(sp)
 d0091a0:	dd800817 	ldw	r22,32(sp)
 d0091a4:	dd400717 	ldw	r21,28(sp)
 d0091a8:	dd000617 	ldw	r20,24(sp)
 d0091ac:	dcc00517 	ldw	r19,20(sp)
 d0091b0:	dc800417 	ldw	r18,16(sp)
 d0091b4:	dc400317 	ldw	r17,12(sp)
 d0091b8:	dc000217 	ldw	r16,8(sp)
 d0091bc:	dec00b04 	addi	sp,sp,44
 d0091c0:	f800283a 	ret
 d0091c4:	d9000104 	addi	r4,sp,4
 d0091c8:	d008b000 	call	d008b00 <__lo0bits>
 d0091cc:	11800804 	addi	r6,r2,32
 d0091d0:	d8800117 	ldw	r2,4(sp)
 d0091d4:	94c00415 	stw	r19,16(r18)
 d0091d8:	980b883a 	mov	r5,r19
 d0091dc:	90800515 	stw	r2,20(r18)
 d0091e0:	a03fe626 	beq	r20,zero,d00917c <__d2b+0xd8>
 d0091e4:	2945883a 	add	r2,r5,r5
 d0091e8:	1085883a 	add	r2,r2,r2
 d0091ec:	1405883a 	add	r2,r2,r16
 d0091f0:	113fff17 	ldw	r4,-4(r2)
 d0091f4:	30fef384 	addi	r3,r6,-1074
 d0091f8:	2820917a 	slli	r16,r5,5
 d0091fc:	b0c00015 	stw	r3,0(r22)
 d009200:	d008a900 	call	d008a90 <__hi0bits>
 d009204:	80a1c83a 	sub	r16,r16,r2
 d009208:	bc000015 	stw	r16,0(r23)
 d00920c:	003fe106 	br	d009194 <__d2b+0xf0>
 d009210:	d8800017 	ldw	r2,0(sp)
 d009214:	90800515 	stw	r2,20(r18)
 d009218:	d8c00117 	ldw	r3,4(sp)
 d00921c:	003fd106 	br	d009164 <__d2b+0xc0>

0d009220 <__mdiff>:
 d009220:	defffb04 	addi	sp,sp,-20
 d009224:	dc000015 	stw	r16,0(sp)
 d009228:	2821883a 	mov	r16,r5
 d00922c:	dc800215 	stw	r18,8(sp)
 d009230:	300b883a 	mov	r5,r6
 d009234:	2025883a 	mov	r18,r4
 d009238:	8009883a 	mov	r4,r16
 d00923c:	dc400115 	stw	r17,4(sp)
 d009240:	dfc00415 	stw	ra,16(sp)
 d009244:	dcc00315 	stw	r19,12(sp)
 d009248:	3023883a 	mov	r17,r6
 d00924c:	d008bc40 	call	d008bc4 <__mcmp>
 d009250:	10004226 	beq	r2,zero,d00935c <__mdiff+0x13c>
 d009254:	10005016 	blt	r2,zero,d009398 <__mdiff+0x178>
 d009258:	0027883a 	mov	r19,zero
 d00925c:	81400117 	ldw	r5,4(r16)
 d009260:	9009883a 	mov	r4,r18
 d009264:	d008fe80 	call	d008fe8 <_Balloc>
 d009268:	1019883a 	mov	r12,r2
 d00926c:	82800417 	ldw	r10,16(r16)
 d009270:	88800417 	ldw	r2,16(r17)
 d009274:	81800504 	addi	r6,r16,20
 d009278:	5287883a 	add	r3,r10,r10
 d00927c:	1085883a 	add	r2,r2,r2
 d009280:	18c7883a 	add	r3,r3,r3
 d009284:	1085883a 	add	r2,r2,r2
 d009288:	8a000504 	addi	r8,r17,20
 d00928c:	64c00315 	stw	r19,12(r12)
 d009290:	30db883a 	add	r13,r6,r3
 d009294:	4097883a 	add	r11,r8,r2
 d009298:	61c00504 	addi	r7,r12,20
 d00929c:	0013883a 	mov	r9,zero
 d0092a0:	31000017 	ldw	r4,0(r6)
 d0092a4:	41400017 	ldw	r5,0(r8)
 d0092a8:	42000104 	addi	r8,r8,4
 d0092ac:	20bfffcc 	andi	r2,r4,65535
 d0092b0:	28ffffcc 	andi	r3,r5,65535
 d0092b4:	10c5c83a 	sub	r2,r2,r3
 d0092b8:	1245883a 	add	r2,r2,r9
 d0092bc:	2008d43a 	srli	r4,r4,16
 d0092c0:	280ad43a 	srli	r5,r5,16
 d0092c4:	1007d43a 	srai	r3,r2,16
 d0092c8:	3880000d 	sth	r2,0(r7)
 d0092cc:	2149c83a 	sub	r4,r4,r5
 d0092d0:	20c9883a 	add	r4,r4,r3
 d0092d4:	3900008d 	sth	r4,2(r7)
 d0092d8:	31800104 	addi	r6,r6,4
 d0092dc:	39c00104 	addi	r7,r7,4
 d0092e0:	2013d43a 	srai	r9,r4,16
 d0092e4:	42ffee36 	bltu	r8,r11,d0092a0 <__mdiff+0x80>
 d0092e8:	33400c2e 	bgeu	r6,r13,d00931c <__mdiff+0xfc>
 d0092ec:	30800017 	ldw	r2,0(r6)
 d0092f0:	31800104 	addi	r6,r6,4
 d0092f4:	10ffffcc 	andi	r3,r2,65535
 d0092f8:	1a47883a 	add	r3,r3,r9
 d0092fc:	1004d43a 	srli	r2,r2,16
 d009300:	1809d43a 	srai	r4,r3,16
 d009304:	38c0000d 	sth	r3,0(r7)
 d009308:	1105883a 	add	r2,r2,r4
 d00930c:	3880008d 	sth	r2,2(r7)
 d009310:	1013d43a 	srai	r9,r2,16
 d009314:	39c00104 	addi	r7,r7,4
 d009318:	337ff436 	bltu	r6,r13,d0092ec <__mdiff+0xcc>
 d00931c:	38bfff17 	ldw	r2,-4(r7)
 d009320:	38ffff04 	addi	r3,r7,-4
 d009324:	1000041e 	bne	r2,zero,d009338 <__mdiff+0x118>
 d009328:	18ffff04 	addi	r3,r3,-4
 d00932c:	18800017 	ldw	r2,0(r3)
 d009330:	52bfffc4 	addi	r10,r10,-1
 d009334:	103ffc26 	beq	r2,zero,d009328 <__mdiff+0x108>
 d009338:	6005883a 	mov	r2,r12
 d00933c:	62800415 	stw	r10,16(r12)
 d009340:	dfc00417 	ldw	ra,16(sp)
 d009344:	dcc00317 	ldw	r19,12(sp)
 d009348:	dc800217 	ldw	r18,8(sp)
 d00934c:	dc400117 	ldw	r17,4(sp)
 d009350:	dc000017 	ldw	r16,0(sp)
 d009354:	dec00504 	addi	sp,sp,20
 d009358:	f800283a 	ret
 d00935c:	9009883a 	mov	r4,r18
 d009360:	000b883a 	mov	r5,zero
 d009364:	d008fe80 	call	d008fe8 <_Balloc>
 d009368:	1019883a 	mov	r12,r2
 d00936c:	00800044 	movi	r2,1
 d009370:	60800415 	stw	r2,16(r12)
 d009374:	6005883a 	mov	r2,r12
 d009378:	60000515 	stw	zero,20(r12)
 d00937c:	dfc00417 	ldw	ra,16(sp)
 d009380:	dcc00317 	ldw	r19,12(sp)
 d009384:	dc800217 	ldw	r18,8(sp)
 d009388:	dc400117 	ldw	r17,4(sp)
 d00938c:	dc000017 	ldw	r16,0(sp)
 d009390:	dec00504 	addi	sp,sp,20
 d009394:	f800283a 	ret
 d009398:	880d883a 	mov	r6,r17
 d00939c:	04c00044 	movi	r19,1
 d0093a0:	8023883a 	mov	r17,r16
 d0093a4:	3021883a 	mov	r16,r6
 d0093a8:	003fac06 	br	d00925c <__mdiff+0x3c>

0d0093ac <__lshift>:
 d0093ac:	defff904 	addi	sp,sp,-28
 d0093b0:	28800417 	ldw	r2,16(r5)
 d0093b4:	dc000015 	stw	r16,0(sp)
 d0093b8:	3021d17a 	srai	r16,r6,5
 d0093bc:	28c00217 	ldw	r3,8(r5)
 d0093c0:	10800044 	addi	r2,r2,1
 d0093c4:	dc400115 	stw	r17,4(sp)
 d0093c8:	80a3883a 	add	r17,r16,r2
 d0093cc:	dd400515 	stw	r21,20(sp)
 d0093d0:	dd000415 	stw	r20,16(sp)
 d0093d4:	dc800215 	stw	r18,8(sp)
 d0093d8:	dfc00615 	stw	ra,24(sp)
 d0093dc:	2825883a 	mov	r18,r5
 d0093e0:	dcc00315 	stw	r19,12(sp)
 d0093e4:	3029883a 	mov	r20,r6
 d0093e8:	202b883a 	mov	r21,r4
 d0093ec:	29400117 	ldw	r5,4(r5)
 d0093f0:	1c40030e 	bge	r3,r17,d009400 <__lshift+0x54>
 d0093f4:	18c7883a 	add	r3,r3,r3
 d0093f8:	29400044 	addi	r5,r5,1
 d0093fc:	1c7ffd16 	blt	r3,r17,d0093f4 <__lshift+0x48>
 d009400:	a809883a 	mov	r4,r21
 d009404:	d008fe80 	call	d008fe8 <_Balloc>
 d009408:	1027883a 	mov	r19,r2
 d00940c:	11400504 	addi	r5,r2,20
 d009410:	0400090e 	bge	zero,r16,d009438 <__lshift+0x8c>
 d009414:	2805883a 	mov	r2,r5
 d009418:	0007883a 	mov	r3,zero
 d00941c:	18c00044 	addi	r3,r3,1
 d009420:	10000015 	stw	zero,0(r2)
 d009424:	10800104 	addi	r2,r2,4
 d009428:	80fffc1e 	bne	r16,r3,d00941c <__lshift+0x70>
 d00942c:	8405883a 	add	r2,r16,r16
 d009430:	1085883a 	add	r2,r2,r2
 d009434:	288b883a 	add	r5,r5,r2
 d009438:	90800417 	ldw	r2,16(r18)
 d00943c:	91000504 	addi	r4,r18,20
 d009440:	a18007cc 	andi	r6,r20,31
 d009444:	1085883a 	add	r2,r2,r2
 d009448:	1085883a 	add	r2,r2,r2
 d00944c:	208f883a 	add	r7,r4,r2
 d009450:	30001e26 	beq	r6,zero,d0094cc <__lshift+0x120>
 d009454:	00800804 	movi	r2,32
 d009458:	1191c83a 	sub	r8,r2,r6
 d00945c:	0007883a 	mov	r3,zero
 d009460:	20800017 	ldw	r2,0(r4)
 d009464:	1184983a 	sll	r2,r2,r6
 d009468:	1884b03a 	or	r2,r3,r2
 d00946c:	28800015 	stw	r2,0(r5)
 d009470:	20c00017 	ldw	r3,0(r4)
 d009474:	21000104 	addi	r4,r4,4
 d009478:	29400104 	addi	r5,r5,4
 d00947c:	1a06d83a 	srl	r3,r3,r8
 d009480:	21fff736 	bltu	r4,r7,d009460 <__lshift+0xb4>
 d009484:	28c00015 	stw	r3,0(r5)
 d009488:	18000126 	beq	r3,zero,d009490 <__lshift+0xe4>
 d00948c:	8c400044 	addi	r17,r17,1
 d009490:	88bfffc4 	addi	r2,r17,-1
 d009494:	98800415 	stw	r2,16(r19)
 d009498:	a809883a 	mov	r4,r21
 d00949c:	900b883a 	mov	r5,r18
 d0094a0:	d008a680 	call	d008a68 <_Bfree>
 d0094a4:	9805883a 	mov	r2,r19
 d0094a8:	dfc00617 	ldw	ra,24(sp)
 d0094ac:	dd400517 	ldw	r21,20(sp)
 d0094b0:	dd000417 	ldw	r20,16(sp)
 d0094b4:	dcc00317 	ldw	r19,12(sp)
 d0094b8:	dc800217 	ldw	r18,8(sp)
 d0094bc:	dc400117 	ldw	r17,4(sp)
 d0094c0:	dc000017 	ldw	r16,0(sp)
 d0094c4:	dec00704 	addi	sp,sp,28
 d0094c8:	f800283a 	ret
 d0094cc:	20800017 	ldw	r2,0(r4)
 d0094d0:	21000104 	addi	r4,r4,4
 d0094d4:	28800015 	stw	r2,0(r5)
 d0094d8:	29400104 	addi	r5,r5,4
 d0094dc:	21ffec2e 	bgeu	r4,r7,d009490 <__lshift+0xe4>
 d0094e0:	20800017 	ldw	r2,0(r4)
 d0094e4:	21000104 	addi	r4,r4,4
 d0094e8:	28800015 	stw	r2,0(r5)
 d0094ec:	29400104 	addi	r5,r5,4
 d0094f0:	21fff636 	bltu	r4,r7,d0094cc <__lshift+0x120>
 d0094f4:	003fe606 	br	d009490 <__lshift+0xe4>

0d0094f8 <__multiply>:
 d0094f8:	defff904 	addi	sp,sp,-28
 d0094fc:	dcc00315 	stw	r19,12(sp)
 d009500:	dc800215 	stw	r18,8(sp)
 d009504:	2cc00417 	ldw	r19,16(r5)
 d009508:	34800417 	ldw	r18,16(r6)
 d00950c:	dd000415 	stw	r20,16(sp)
 d009510:	dc400115 	stw	r17,4(sp)
 d009514:	dfc00615 	stw	ra,24(sp)
 d009518:	dd400515 	stw	r21,20(sp)
 d00951c:	dc000015 	stw	r16,0(sp)
 d009520:	2823883a 	mov	r17,r5
 d009524:	3029883a 	mov	r20,r6
 d009528:	9c80040e 	bge	r19,r18,d00953c <__multiply+0x44>
 d00952c:	9027883a 	mov	r19,r18
 d009530:	2c800417 	ldw	r18,16(r5)
 d009534:	2829883a 	mov	r20,r5
 d009538:	3023883a 	mov	r17,r6
 d00953c:	88800217 	ldw	r2,8(r17)
 d009540:	9ca1883a 	add	r16,r19,r18
 d009544:	89400117 	ldw	r5,4(r17)
 d009548:	1400010e 	bge	r2,r16,d009550 <__multiply+0x58>
 d00954c:	29400044 	addi	r5,r5,1
 d009550:	d008fe80 	call	d008fe8 <_Balloc>
 d009554:	102b883a 	mov	r21,r2
 d009558:	8405883a 	add	r2,r16,r16
 d00955c:	1085883a 	add	r2,r2,r2
 d009560:	a9000504 	addi	r4,r21,20
 d009564:	209d883a 	add	r14,r4,r2
 d009568:	2380042e 	bgeu	r4,r14,d00957c <__multiply+0x84>
 d00956c:	2005883a 	mov	r2,r4
 d009570:	10000015 	stw	zero,0(r2)
 d009574:	10800104 	addi	r2,r2,4
 d009578:	13bffd36 	bltu	r2,r14,d009570 <__multiply+0x78>
 d00957c:	9485883a 	add	r2,r18,r18
 d009580:	9cc7883a 	add	r3,r19,r19
 d009584:	a1800504 	addi	r6,r20,20
 d009588:	1085883a 	add	r2,r2,r2
 d00958c:	8b400504 	addi	r13,r17,20
 d009590:	18c7883a 	add	r3,r3,r3
 d009594:	309f883a 	add	r15,r6,r2
 d009598:	68d7883a 	add	r11,r13,r3
 d00959c:	33c03b2e 	bgeu	r6,r15,d00968c <__multiply+0x194>
 d0095a0:	2019883a 	mov	r12,r4
 d0095a4:	30800017 	ldw	r2,0(r6)
 d0095a8:	127fffcc 	andi	r9,r2,65535
 d0095ac:	48001826 	beq	r9,zero,d009610 <__multiply+0x118>
 d0095b0:	6811883a 	mov	r8,r13
 d0095b4:	600f883a 	mov	r7,r12
 d0095b8:	0015883a 	mov	r10,zero
 d0095bc:	40c00017 	ldw	r3,0(r8)
 d0095c0:	39400017 	ldw	r5,0(r7)
 d0095c4:	42000104 	addi	r8,r8,4
 d0095c8:	193fffcc 	andi	r4,r3,65535
 d0095cc:	4909383a 	mul	r4,r9,r4
 d0095d0:	1806d43a 	srli	r3,r3,16
 d0095d4:	28bfffcc 	andi	r2,r5,65535
 d0095d8:	5085883a 	add	r2,r10,r2
 d0095dc:	2089883a 	add	r4,r4,r2
 d0095e0:	48c7383a 	mul	r3,r9,r3
 d0095e4:	280ad43a 	srli	r5,r5,16
 d0095e8:	2004d43a 	srli	r2,r4,16
 d0095ec:	3900000d 	sth	r4,0(r7)
 d0095f0:	1947883a 	add	r3,r3,r5
 d0095f4:	10c5883a 	add	r2,r2,r3
 d0095f8:	3880008d 	sth	r2,2(r7)
 d0095fc:	1014d43a 	srli	r10,r2,16
 d009600:	39c00104 	addi	r7,r7,4
 d009604:	42ffed36 	bltu	r8,r11,d0095bc <__multiply+0xc4>
 d009608:	3a800015 	stw	r10,0(r7)
 d00960c:	30800017 	ldw	r2,0(r6)
 d009610:	1012d43a 	srli	r9,r2,16
 d009614:	48001926 	beq	r9,zero,d00967c <__multiply+0x184>
 d009618:	60800017 	ldw	r2,0(r12)
 d00961c:	6811883a 	mov	r8,r13
 d009620:	600f883a 	mov	r7,r12
 d009624:	0015883a 	mov	r10,zero
 d009628:	100b883a 	mov	r5,r2
 d00962c:	41000017 	ldw	r4,0(r8)
 d009630:	2806d43a 	srli	r3,r5,16
 d009634:	3880000d 	sth	r2,0(r7)
 d009638:	20bfffcc 	andi	r2,r4,65535
 d00963c:	4885383a 	mul	r2,r9,r2
 d009640:	50c7883a 	add	r3,r10,r3
 d009644:	2008d43a 	srli	r4,r4,16
 d009648:	10c5883a 	add	r2,r2,r3
 d00964c:	3880008d 	sth	r2,2(r7)
 d009650:	39c00104 	addi	r7,r7,4
 d009654:	39400017 	ldw	r5,0(r7)
 d009658:	4909383a 	mul	r4,r9,r4
 d00965c:	1004d43a 	srli	r2,r2,16
 d009660:	28ffffcc 	andi	r3,r5,65535
 d009664:	20c9883a 	add	r4,r4,r3
 d009668:	1105883a 	add	r2,r2,r4
 d00966c:	42000104 	addi	r8,r8,4
 d009670:	1014d43a 	srli	r10,r2,16
 d009674:	42ffed36 	bltu	r8,r11,d00962c <__multiply+0x134>
 d009678:	38800015 	stw	r2,0(r7)
 d00967c:	31800104 	addi	r6,r6,4
 d009680:	33c0022e 	bgeu	r6,r15,d00968c <__multiply+0x194>
 d009684:	63000104 	addi	r12,r12,4
 d009688:	003fc606 	br	d0095a4 <__multiply+0xac>
 d00968c:	0400090e 	bge	zero,r16,d0096b4 <__multiply+0x1bc>
 d009690:	70bfff17 	ldw	r2,-4(r14)
 d009694:	70ffff04 	addi	r3,r14,-4
 d009698:	10000326 	beq	r2,zero,d0096a8 <__multiply+0x1b0>
 d00969c:	00000506 	br	d0096b4 <__multiply+0x1bc>
 d0096a0:	18800017 	ldw	r2,0(r3)
 d0096a4:	1000031e 	bne	r2,zero,d0096b4 <__multiply+0x1bc>
 d0096a8:	843fffc4 	addi	r16,r16,-1
 d0096ac:	18ffff04 	addi	r3,r3,-4
 d0096b0:	803ffb1e 	bne	r16,zero,d0096a0 <__multiply+0x1a8>
 d0096b4:	a805883a 	mov	r2,r21
 d0096b8:	ac000415 	stw	r16,16(r21)
 d0096bc:	dfc00617 	ldw	ra,24(sp)
 d0096c0:	dd400517 	ldw	r21,20(sp)
 d0096c4:	dd000417 	ldw	r20,16(sp)
 d0096c8:	dcc00317 	ldw	r19,12(sp)
 d0096cc:	dc800217 	ldw	r18,8(sp)
 d0096d0:	dc400117 	ldw	r17,4(sp)
 d0096d4:	dc000017 	ldw	r16,0(sp)
 d0096d8:	dec00704 	addi	sp,sp,28
 d0096dc:	f800283a 	ret

0d0096e0 <__i2b>:
 d0096e0:	defffd04 	addi	sp,sp,-12
 d0096e4:	dc000015 	stw	r16,0(sp)
 d0096e8:	04000044 	movi	r16,1
 d0096ec:	dc800115 	stw	r18,4(sp)
 d0096f0:	2825883a 	mov	r18,r5
 d0096f4:	800b883a 	mov	r5,r16
 d0096f8:	dfc00215 	stw	ra,8(sp)
 d0096fc:	d008fe80 	call	d008fe8 <_Balloc>
 d009700:	14000415 	stw	r16,16(r2)
 d009704:	14800515 	stw	r18,20(r2)
 d009708:	dfc00217 	ldw	ra,8(sp)
 d00970c:	dc800117 	ldw	r18,4(sp)
 d009710:	dc000017 	ldw	r16,0(sp)
 d009714:	dec00304 	addi	sp,sp,12
 d009718:	f800283a 	ret

0d00971c <__multadd>:
 d00971c:	defffa04 	addi	sp,sp,-24
 d009720:	dc800215 	stw	r18,8(sp)
 d009724:	2c800417 	ldw	r18,16(r5)
 d009728:	dd000415 	stw	r20,16(sp)
 d00972c:	dcc00315 	stw	r19,12(sp)
 d009730:	dc000015 	stw	r16,0(sp)
 d009734:	dfc00515 	stw	ra,20(sp)
 d009738:	3821883a 	mov	r16,r7
 d00973c:	dc400115 	stw	r17,4(sp)
 d009740:	2827883a 	mov	r19,r5
 d009744:	2029883a 	mov	r20,r4
 d009748:	2a000504 	addi	r8,r5,20
 d00974c:	000f883a 	mov	r7,zero
 d009750:	40800017 	ldw	r2,0(r8)
 d009754:	39c00044 	addi	r7,r7,1
 d009758:	10ffffcc 	andi	r3,r2,65535
 d00975c:	1987383a 	mul	r3,r3,r6
 d009760:	1004d43a 	srli	r2,r2,16
 d009764:	1c07883a 	add	r3,r3,r16
 d009768:	180ad43a 	srli	r5,r3,16
 d00976c:	1185383a 	mul	r2,r2,r6
 d009770:	18ffffcc 	andi	r3,r3,65535
 d009774:	1145883a 	add	r2,r2,r5
 d009778:	1008943a 	slli	r4,r2,16
 d00977c:	1020d43a 	srli	r16,r2,16
 d009780:	20c9883a 	add	r4,r4,r3
 d009784:	41000015 	stw	r4,0(r8)
 d009788:	42000104 	addi	r8,r8,4
 d00978c:	3cbff016 	blt	r7,r18,d009750 <__multadd+0x34>
 d009790:	80000826 	beq	r16,zero,d0097b4 <__multadd+0x98>
 d009794:	98800217 	ldw	r2,8(r19)
 d009798:	90800f0e 	bge	r18,r2,d0097d8 <__multadd+0xbc>
 d00979c:	9485883a 	add	r2,r18,r18
 d0097a0:	1085883a 	add	r2,r2,r2
 d0097a4:	14c5883a 	add	r2,r2,r19
 d0097a8:	90c00044 	addi	r3,r18,1
 d0097ac:	14000515 	stw	r16,20(r2)
 d0097b0:	98c00415 	stw	r3,16(r19)
 d0097b4:	9805883a 	mov	r2,r19
 d0097b8:	dfc00517 	ldw	ra,20(sp)
 d0097bc:	dd000417 	ldw	r20,16(sp)
 d0097c0:	dcc00317 	ldw	r19,12(sp)
 d0097c4:	dc800217 	ldw	r18,8(sp)
 d0097c8:	dc400117 	ldw	r17,4(sp)
 d0097cc:	dc000017 	ldw	r16,0(sp)
 d0097d0:	dec00604 	addi	sp,sp,24
 d0097d4:	f800283a 	ret
 d0097d8:	99400117 	ldw	r5,4(r19)
 d0097dc:	a009883a 	mov	r4,r20
 d0097e0:	29400044 	addi	r5,r5,1
 d0097e4:	d008fe80 	call	d008fe8 <_Balloc>
 d0097e8:	99800417 	ldw	r6,16(r19)
 d0097ec:	99400304 	addi	r5,r19,12
 d0097f0:	11000304 	addi	r4,r2,12
 d0097f4:	318d883a 	add	r6,r6,r6
 d0097f8:	318d883a 	add	r6,r6,r6
 d0097fc:	31800204 	addi	r6,r6,8
 d009800:	1023883a 	mov	r17,r2
 d009804:	d0027000 	call	d002700 <memcpy>
 d009808:	980b883a 	mov	r5,r19
 d00980c:	a009883a 	mov	r4,r20
 d009810:	d008a680 	call	d008a68 <_Bfree>
 d009814:	8827883a 	mov	r19,r17
 d009818:	003fe006 	br	d00979c <__multadd+0x80>

0d00981c <__pow5mult>:
 d00981c:	defffa04 	addi	sp,sp,-24
 d009820:	308000cc 	andi	r2,r6,3
 d009824:	dd000415 	stw	r20,16(sp)
 d009828:	dcc00315 	stw	r19,12(sp)
 d00982c:	dc000015 	stw	r16,0(sp)
 d009830:	dfc00515 	stw	ra,20(sp)
 d009834:	dc800215 	stw	r18,8(sp)
 d009838:	dc400115 	stw	r17,4(sp)
 d00983c:	3021883a 	mov	r16,r6
 d009840:	2027883a 	mov	r19,r4
 d009844:	2829883a 	mov	r20,r5
 d009848:	10002b1e 	bne	r2,zero,d0098f8 <__pow5mult+0xdc>
 d00984c:	8025d0ba 	srai	r18,r16,2
 d009850:	90001b26 	beq	r18,zero,d0098c0 <__pow5mult+0xa4>
 d009854:	9c001217 	ldw	r16,72(r19)
 d009858:	8000081e 	bne	r16,zero,d00987c <__pow5mult+0x60>
 d00985c:	00003006 	br	d009920 <__pow5mult+0x104>
 d009860:	800b883a 	mov	r5,r16
 d009864:	800d883a 	mov	r6,r16
 d009868:	9809883a 	mov	r4,r19
 d00986c:	90001426 	beq	r18,zero,d0098c0 <__pow5mult+0xa4>
 d009870:	80800017 	ldw	r2,0(r16)
 d009874:	10001b26 	beq	r2,zero,d0098e4 <__pow5mult+0xc8>
 d009878:	1021883a 	mov	r16,r2
 d00987c:	9080004c 	andi	r2,r18,1
 d009880:	1005003a 	cmpeq	r2,r2,zero
 d009884:	9025d07a 	srai	r18,r18,1
 d009888:	800d883a 	mov	r6,r16
 d00988c:	9809883a 	mov	r4,r19
 d009890:	a00b883a 	mov	r5,r20
 d009894:	103ff21e 	bne	r2,zero,d009860 <__pow5mult+0x44>
 d009898:	d0094f80 	call	d0094f8 <__multiply>
 d00989c:	a00b883a 	mov	r5,r20
 d0098a0:	9809883a 	mov	r4,r19
 d0098a4:	1023883a 	mov	r17,r2
 d0098a8:	d008a680 	call	d008a68 <_Bfree>
 d0098ac:	8829883a 	mov	r20,r17
 d0098b0:	800b883a 	mov	r5,r16
 d0098b4:	800d883a 	mov	r6,r16
 d0098b8:	9809883a 	mov	r4,r19
 d0098bc:	903fec1e 	bne	r18,zero,d009870 <__pow5mult+0x54>
 d0098c0:	a005883a 	mov	r2,r20
 d0098c4:	dfc00517 	ldw	ra,20(sp)
 d0098c8:	dd000417 	ldw	r20,16(sp)
 d0098cc:	dcc00317 	ldw	r19,12(sp)
 d0098d0:	dc800217 	ldw	r18,8(sp)
 d0098d4:	dc400117 	ldw	r17,4(sp)
 d0098d8:	dc000017 	ldw	r16,0(sp)
 d0098dc:	dec00604 	addi	sp,sp,24
 d0098e0:	f800283a 	ret
 d0098e4:	d0094f80 	call	d0094f8 <__multiply>
 d0098e8:	80800015 	stw	r2,0(r16)
 d0098ec:	1021883a 	mov	r16,r2
 d0098f0:	10000015 	stw	zero,0(r2)
 d0098f4:	003fe106 	br	d00987c <__pow5mult+0x60>
 d0098f8:	1085883a 	add	r2,r2,r2
 d0098fc:	00c34174 	movhi	r3,3333
 d009900:	18f16604 	addi	r3,r3,-14952
 d009904:	1085883a 	add	r2,r2,r2
 d009908:	10c5883a 	add	r2,r2,r3
 d00990c:	11bfff17 	ldw	r6,-4(r2)
 d009910:	000f883a 	mov	r7,zero
 d009914:	d00971c0 	call	d00971c <__multadd>
 d009918:	1029883a 	mov	r20,r2
 d00991c:	003fcb06 	br	d00984c <__pow5mult+0x30>
 d009920:	9809883a 	mov	r4,r19
 d009924:	01409c44 	movi	r5,625
 d009928:	d0096e00 	call	d0096e0 <__i2b>
 d00992c:	98801215 	stw	r2,72(r19)
 d009930:	1021883a 	mov	r16,r2
 d009934:	10000015 	stw	zero,0(r2)
 d009938:	003fd006 	br	d00987c <__pow5mult+0x60>

0d00993c <__s2b>:
 d00993c:	defff904 	addi	sp,sp,-28
 d009940:	dcc00315 	stw	r19,12(sp)
 d009944:	dc800215 	stw	r18,8(sp)
 d009948:	2827883a 	mov	r19,r5
 d00994c:	2025883a 	mov	r18,r4
 d009950:	01400244 	movi	r5,9
 d009954:	39000204 	addi	r4,r7,8
 d009958:	dd000415 	stw	r20,16(sp)
 d00995c:	dc400115 	stw	r17,4(sp)
 d009960:	dfc00615 	stw	ra,24(sp)
 d009964:	dd400515 	stw	r21,20(sp)
 d009968:	dc000015 	stw	r16,0(sp)
 d00996c:	3829883a 	mov	r20,r7
 d009970:	3023883a 	mov	r17,r6
 d009974:	d00c6e00 	call	d00c6e0 <__divsi3>
 d009978:	00c00044 	movi	r3,1
 d00997c:	1880350e 	bge	r3,r2,d009a54 <__s2b+0x118>
 d009980:	000b883a 	mov	r5,zero
 d009984:	18c7883a 	add	r3,r3,r3
 d009988:	29400044 	addi	r5,r5,1
 d00998c:	18bffd16 	blt	r3,r2,d009984 <__s2b+0x48>
 d009990:	9009883a 	mov	r4,r18
 d009994:	d008fe80 	call	d008fe8 <_Balloc>
 d009998:	1011883a 	mov	r8,r2
 d00999c:	d8800717 	ldw	r2,28(sp)
 d0099a0:	00c00044 	movi	r3,1
 d0099a4:	01800244 	movi	r6,9
 d0099a8:	40800515 	stw	r2,20(r8)
 d0099ac:	40c00415 	stw	r3,16(r8)
 d0099b0:	3440260e 	bge	r6,r17,d009a4c <__s2b+0x110>
 d0099b4:	3021883a 	mov	r16,r6
 d0099b8:	99ab883a 	add	r21,r19,r6
 d0099bc:	9c05883a 	add	r2,r19,r16
 d0099c0:	11c00007 	ldb	r7,0(r2)
 d0099c4:	400b883a 	mov	r5,r8
 d0099c8:	9009883a 	mov	r4,r18
 d0099cc:	39fff404 	addi	r7,r7,-48
 d0099d0:	01800284 	movi	r6,10
 d0099d4:	d00971c0 	call	d00971c <__multadd>
 d0099d8:	84000044 	addi	r16,r16,1
 d0099dc:	1011883a 	mov	r8,r2
 d0099e0:	8c3ff61e 	bne	r17,r16,d0099bc <__s2b+0x80>
 d0099e4:	ac45883a 	add	r2,r21,r17
 d0099e8:	117ffe04 	addi	r5,r2,-8
 d0099ec:	880d883a 	mov	r6,r17
 d0099f0:	35000c0e 	bge	r6,r20,d009a24 <__s2b+0xe8>
 d0099f4:	a185c83a 	sub	r2,r20,r6
 d0099f8:	2821883a 	mov	r16,r5
 d0099fc:	28a3883a 	add	r17,r5,r2
 d009a00:	81c00007 	ldb	r7,0(r16)
 d009a04:	400b883a 	mov	r5,r8
 d009a08:	9009883a 	mov	r4,r18
 d009a0c:	39fff404 	addi	r7,r7,-48
 d009a10:	01800284 	movi	r6,10
 d009a14:	d00971c0 	call	d00971c <__multadd>
 d009a18:	84000044 	addi	r16,r16,1
 d009a1c:	1011883a 	mov	r8,r2
 d009a20:	847ff71e 	bne	r16,r17,d009a00 <__s2b+0xc4>
 d009a24:	4005883a 	mov	r2,r8
 d009a28:	dfc00617 	ldw	ra,24(sp)
 d009a2c:	dd400517 	ldw	r21,20(sp)
 d009a30:	dd000417 	ldw	r20,16(sp)
 d009a34:	dcc00317 	ldw	r19,12(sp)
 d009a38:	dc800217 	ldw	r18,8(sp)
 d009a3c:	dc400117 	ldw	r17,4(sp)
 d009a40:	dc000017 	ldw	r16,0(sp)
 d009a44:	dec00704 	addi	sp,sp,28
 d009a48:	f800283a 	ret
 d009a4c:	99400284 	addi	r5,r19,10
 d009a50:	003fe706 	br	d0099f0 <__s2b+0xb4>
 d009a54:	000b883a 	mov	r5,zero
 d009a58:	003fcd06 	br	d009990 <__s2b+0x54>

0d009a5c <_realloc_r>:
 d009a5c:	defff404 	addi	sp,sp,-48
 d009a60:	dd800815 	stw	r22,32(sp)
 d009a64:	dc800415 	stw	r18,16(sp)
 d009a68:	dc400315 	stw	r17,12(sp)
 d009a6c:	dfc00b15 	stw	ra,44(sp)
 d009a70:	df000a15 	stw	fp,40(sp)
 d009a74:	ddc00915 	stw	r23,36(sp)
 d009a78:	dd400715 	stw	r21,28(sp)
 d009a7c:	dd000615 	stw	r20,24(sp)
 d009a80:	dcc00515 	stw	r19,20(sp)
 d009a84:	dc000215 	stw	r16,8(sp)
 d009a88:	2825883a 	mov	r18,r5
 d009a8c:	3023883a 	mov	r17,r6
 d009a90:	202d883a 	mov	r22,r4
 d009a94:	2800c926 	beq	r5,zero,d009dbc <_realloc_r+0x360>
 d009a98:	d00d4dc0 	call	d00d4dc <__malloc_lock>
 d009a9c:	943ffe04 	addi	r16,r18,-8
 d009aa0:	88c002c4 	addi	r3,r17,11
 d009aa4:	00800584 	movi	r2,22
 d009aa8:	82000117 	ldw	r8,4(r16)
 d009aac:	10c01b2e 	bgeu	r2,r3,d009b1c <_realloc_r+0xc0>
 d009ab0:	00bffe04 	movi	r2,-8
 d009ab4:	188e703a 	and	r7,r3,r2
 d009ab8:	3839883a 	mov	fp,r7
 d009abc:	38001a16 	blt	r7,zero,d009b28 <_realloc_r+0xcc>
 d009ac0:	e4401936 	bltu	fp,r17,d009b28 <_realloc_r+0xcc>
 d009ac4:	013fff04 	movi	r4,-4
 d009ac8:	4126703a 	and	r19,r8,r4
 d009acc:	99c02616 	blt	r19,r7,d009b68 <_realloc_r+0x10c>
 d009ad0:	802b883a 	mov	r21,r16
 d009ad4:	9829883a 	mov	r20,r19
 d009ad8:	84000204 	addi	r16,r16,8
 d009adc:	a80f883a 	mov	r7,r21
 d009ae0:	a70dc83a 	sub	r6,r20,fp
 d009ae4:	008003c4 	movi	r2,15
 d009ae8:	1180c136 	bltu	r2,r6,d009df0 <_realloc_r+0x394>
 d009aec:	38800117 	ldw	r2,4(r7)
 d009af0:	a549883a 	add	r4,r20,r21
 d009af4:	1080004c 	andi	r2,r2,1
 d009af8:	a084b03a 	or	r2,r20,r2
 d009afc:	38800115 	stw	r2,4(r7)
 d009b00:	20c00117 	ldw	r3,4(r4)
 d009b04:	18c00054 	ori	r3,r3,1
 d009b08:	20c00115 	stw	r3,4(r4)
 d009b0c:	b009883a 	mov	r4,r22
 d009b10:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d009b14:	8023883a 	mov	r17,r16
 d009b18:	00000606 	br	d009b34 <_realloc_r+0xd8>
 d009b1c:	01c00404 	movi	r7,16
 d009b20:	3839883a 	mov	fp,r7
 d009b24:	e47fe72e 	bgeu	fp,r17,d009ac4 <_realloc_r+0x68>
 d009b28:	00800304 	movi	r2,12
 d009b2c:	0023883a 	mov	r17,zero
 d009b30:	b0800015 	stw	r2,0(r22)
 d009b34:	8805883a 	mov	r2,r17
 d009b38:	dfc00b17 	ldw	ra,44(sp)
 d009b3c:	df000a17 	ldw	fp,40(sp)
 d009b40:	ddc00917 	ldw	r23,36(sp)
 d009b44:	dd800817 	ldw	r22,32(sp)
 d009b48:	dd400717 	ldw	r21,28(sp)
 d009b4c:	dd000617 	ldw	r20,24(sp)
 d009b50:	dcc00517 	ldw	r19,20(sp)
 d009b54:	dc800417 	ldw	r18,16(sp)
 d009b58:	dc400317 	ldw	r17,12(sp)
 d009b5c:	dc000217 	ldw	r16,8(sp)
 d009b60:	dec00c04 	addi	sp,sp,48
 d009b64:	f800283a 	ret
 d009b68:	00834174 	movhi	r2,3333
 d009b6c:	10837b04 	addi	r2,r2,3564
 d009b70:	12400217 	ldw	r9,8(r2)
 d009b74:	84cd883a 	add	r6,r16,r19
 d009b78:	802b883a 	mov	r21,r16
 d009b7c:	3240b926 	beq	r6,r9,d009e64 <_realloc_r+0x408>
 d009b80:	31400117 	ldw	r5,4(r6)
 d009b84:	00bfff84 	movi	r2,-2
 d009b88:	2884703a 	and	r2,r5,r2
 d009b8c:	1185883a 	add	r2,r2,r6
 d009b90:	10c00117 	ldw	r3,4(r2)
 d009b94:	18c0004c 	andi	r3,r3,1
 d009b98:	1807003a 	cmpeq	r3,r3,zero
 d009b9c:	1800a326 	beq	r3,zero,d009e2c <_realloc_r+0x3d0>
 d009ba0:	2908703a 	and	r4,r5,r4
 d009ba4:	9929883a 	add	r20,r19,r4
 d009ba8:	a1c0a30e 	bge	r20,r7,d009e38 <_realloc_r+0x3dc>
 d009bac:	4080004c 	andi	r2,r8,1
 d009bb0:	1000551e 	bne	r2,zero,d009d08 <_realloc_r+0x2ac>
 d009bb4:	80800017 	ldw	r2,0(r16)
 d009bb8:	80afc83a 	sub	r23,r16,r2
 d009bbc:	b8c00117 	ldw	r3,4(r23)
 d009bc0:	00bfff04 	movi	r2,-4
 d009bc4:	1884703a 	and	r2,r3,r2
 d009bc8:	30002e26 	beq	r6,zero,d009c84 <_realloc_r+0x228>
 d009bcc:	3240b926 	beq	r6,r9,d009eb4 <_realloc_r+0x458>
 d009bd0:	98a9883a 	add	r20,r19,r2
 d009bd4:	2509883a 	add	r4,r4,r20
 d009bd8:	d9000015 	stw	r4,0(sp)
 d009bdc:	21c02a16 	blt	r4,r7,d009c88 <_realloc_r+0x22c>
 d009be0:	30800317 	ldw	r2,12(r6)
 d009be4:	30c00217 	ldw	r3,8(r6)
 d009be8:	01400904 	movi	r5,36
 d009bec:	99bfff04 	addi	r6,r19,-4
 d009bf0:	18800315 	stw	r2,12(r3)
 d009bf4:	10c00215 	stw	r3,8(r2)
 d009bf8:	b9000317 	ldw	r4,12(r23)
 d009bfc:	b8800217 	ldw	r2,8(r23)
 d009c00:	b82b883a 	mov	r21,r23
 d009c04:	bc000204 	addi	r16,r23,8
 d009c08:	20800215 	stw	r2,8(r4)
 d009c0c:	11000315 	stw	r4,12(r2)
 d009c10:	2980e436 	bltu	r5,r6,d009fa4 <_realloc_r+0x548>
 d009c14:	008004c4 	movi	r2,19
 d009c18:	9009883a 	mov	r4,r18
 d009c1c:	8011883a 	mov	r8,r16
 d009c20:	11800f2e 	bgeu	r2,r6,d009c60 <_realloc_r+0x204>
 d009c24:	90800017 	ldw	r2,0(r18)
 d009c28:	ba000404 	addi	r8,r23,16
 d009c2c:	91000204 	addi	r4,r18,8
 d009c30:	b8800215 	stw	r2,8(r23)
 d009c34:	90c00117 	ldw	r3,4(r18)
 d009c38:	008006c4 	movi	r2,27
 d009c3c:	b8c00315 	stw	r3,12(r23)
 d009c40:	1180072e 	bgeu	r2,r6,d009c60 <_realloc_r+0x204>
 d009c44:	90c00217 	ldw	r3,8(r18)
 d009c48:	ba000604 	addi	r8,r23,24
 d009c4c:	91000404 	addi	r4,r18,16
 d009c50:	b8c00415 	stw	r3,16(r23)
 d009c54:	90800317 	ldw	r2,12(r18)
 d009c58:	b8800515 	stw	r2,20(r23)
 d009c5c:	3140e726 	beq	r6,r5,d009ffc <_realloc_r+0x5a0>
 d009c60:	20800017 	ldw	r2,0(r4)
 d009c64:	dd000017 	ldw	r20,0(sp)
 d009c68:	b80f883a 	mov	r7,r23
 d009c6c:	40800015 	stw	r2,0(r8)
 d009c70:	20c00117 	ldw	r3,4(r4)
 d009c74:	40c00115 	stw	r3,4(r8)
 d009c78:	20800217 	ldw	r2,8(r4)
 d009c7c:	40800215 	stw	r2,8(r8)
 d009c80:	003f9706 	br	d009ae0 <_realloc_r+0x84>
 d009c84:	98a9883a 	add	r20,r19,r2
 d009c88:	a1c01f16 	blt	r20,r7,d009d08 <_realloc_r+0x2ac>
 d009c8c:	b8c00317 	ldw	r3,12(r23)
 d009c90:	b8800217 	ldw	r2,8(r23)
 d009c94:	99bfff04 	addi	r6,r19,-4
 d009c98:	01400904 	movi	r5,36
 d009c9c:	b82b883a 	mov	r21,r23
 d009ca0:	18800215 	stw	r2,8(r3)
 d009ca4:	10c00315 	stw	r3,12(r2)
 d009ca8:	bc000204 	addi	r16,r23,8
 d009cac:	2980c336 	bltu	r5,r6,d009fbc <_realloc_r+0x560>
 d009cb0:	008004c4 	movi	r2,19
 d009cb4:	9009883a 	mov	r4,r18
 d009cb8:	8011883a 	mov	r8,r16
 d009cbc:	11800f2e 	bgeu	r2,r6,d009cfc <_realloc_r+0x2a0>
 d009cc0:	90800017 	ldw	r2,0(r18)
 d009cc4:	ba000404 	addi	r8,r23,16
 d009cc8:	91000204 	addi	r4,r18,8
 d009ccc:	b8800215 	stw	r2,8(r23)
 d009cd0:	90c00117 	ldw	r3,4(r18)
 d009cd4:	008006c4 	movi	r2,27
 d009cd8:	b8c00315 	stw	r3,12(r23)
 d009cdc:	1180072e 	bgeu	r2,r6,d009cfc <_realloc_r+0x2a0>
 d009ce0:	90c00217 	ldw	r3,8(r18)
 d009ce4:	ba000604 	addi	r8,r23,24
 d009ce8:	91000404 	addi	r4,r18,16
 d009cec:	b8c00415 	stw	r3,16(r23)
 d009cf0:	90800317 	ldw	r2,12(r18)
 d009cf4:	b8800515 	stw	r2,20(r23)
 d009cf8:	3140c726 	beq	r6,r5,d00a018 <_realloc_r+0x5bc>
 d009cfc:	20800017 	ldw	r2,0(r4)
 d009d00:	b80f883a 	mov	r7,r23
 d009d04:	003fd906 	br	d009c6c <_realloc_r+0x210>
 d009d08:	880b883a 	mov	r5,r17
 d009d0c:	b009883a 	mov	r4,r22
 d009d10:	d0082440 	call	d008244 <_malloc_r>
 d009d14:	1023883a 	mov	r17,r2
 d009d18:	10002526 	beq	r2,zero,d009db0 <_realloc_r+0x354>
 d009d1c:	80800117 	ldw	r2,4(r16)
 d009d20:	00ffff84 	movi	r3,-2
 d009d24:	893ffe04 	addi	r4,r17,-8
 d009d28:	10c4703a 	and	r2,r2,r3
 d009d2c:	8085883a 	add	r2,r16,r2
 d009d30:	20809526 	beq	r4,r2,d009f88 <_realloc_r+0x52c>
 d009d34:	99bfff04 	addi	r6,r19,-4
 d009d38:	01c00904 	movi	r7,36
 d009d3c:	39804536 	bltu	r7,r6,d009e54 <_realloc_r+0x3f8>
 d009d40:	008004c4 	movi	r2,19
 d009d44:	9009883a 	mov	r4,r18
 d009d48:	880b883a 	mov	r5,r17
 d009d4c:	11800f2e 	bgeu	r2,r6,d009d8c <_realloc_r+0x330>
 d009d50:	90800017 	ldw	r2,0(r18)
 d009d54:	89400204 	addi	r5,r17,8
 d009d58:	91000204 	addi	r4,r18,8
 d009d5c:	88800015 	stw	r2,0(r17)
 d009d60:	90c00117 	ldw	r3,4(r18)
 d009d64:	008006c4 	movi	r2,27
 d009d68:	88c00115 	stw	r3,4(r17)
 d009d6c:	1180072e 	bgeu	r2,r6,d009d8c <_realloc_r+0x330>
 d009d70:	90c00217 	ldw	r3,8(r18)
 d009d74:	89400404 	addi	r5,r17,16
 d009d78:	91000404 	addi	r4,r18,16
 d009d7c:	88c00215 	stw	r3,8(r17)
 d009d80:	90800317 	ldw	r2,12(r18)
 d009d84:	88800315 	stw	r2,12(r17)
 d009d88:	31c09126 	beq	r6,r7,d009fd0 <_realloc_r+0x574>
 d009d8c:	20800017 	ldw	r2,0(r4)
 d009d90:	28800015 	stw	r2,0(r5)
 d009d94:	20c00117 	ldw	r3,4(r4)
 d009d98:	28c00115 	stw	r3,4(r5)
 d009d9c:	20800217 	ldw	r2,8(r4)
 d009da0:	28800215 	stw	r2,8(r5)
 d009da4:	900b883a 	mov	r5,r18
 d009da8:	b009883a 	mov	r4,r22
 d009dac:	d0076bc0 	call	d0076bc <_free_r>
 d009db0:	b009883a 	mov	r4,r22
 d009db4:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d009db8:	003f5e06 	br	d009b34 <_realloc_r+0xd8>
 d009dbc:	300b883a 	mov	r5,r6
 d009dc0:	dfc00b17 	ldw	ra,44(sp)
 d009dc4:	df000a17 	ldw	fp,40(sp)
 d009dc8:	ddc00917 	ldw	r23,36(sp)
 d009dcc:	dd800817 	ldw	r22,32(sp)
 d009dd0:	dd400717 	ldw	r21,28(sp)
 d009dd4:	dd000617 	ldw	r20,24(sp)
 d009dd8:	dcc00517 	ldw	r19,20(sp)
 d009ddc:	dc800417 	ldw	r18,16(sp)
 d009de0:	dc400317 	ldw	r17,12(sp)
 d009de4:	dc000217 	ldw	r16,8(sp)
 d009de8:	dec00c04 	addi	sp,sp,48
 d009dec:	d0082441 	jmpi	d008244 <_malloc_r>
 d009df0:	38800117 	ldw	r2,4(r7)
 d009df4:	e54b883a 	add	r5,fp,r21
 d009df8:	31000054 	ori	r4,r6,1
 d009dfc:	1080004c 	andi	r2,r2,1
 d009e00:	1704b03a 	or	r2,r2,fp
 d009e04:	38800115 	stw	r2,4(r7)
 d009e08:	29000115 	stw	r4,4(r5)
 d009e0c:	2987883a 	add	r3,r5,r6
 d009e10:	18800117 	ldw	r2,4(r3)
 d009e14:	29400204 	addi	r5,r5,8
 d009e18:	b009883a 	mov	r4,r22
 d009e1c:	10800054 	ori	r2,r2,1
 d009e20:	18800115 	stw	r2,4(r3)
 d009e24:	d0076bc0 	call	d0076bc <_free_r>
 d009e28:	003f3806 	br	d009b0c <_realloc_r+0xb0>
 d009e2c:	000d883a 	mov	r6,zero
 d009e30:	0009883a 	mov	r4,zero
 d009e34:	003f5d06 	br	d009bac <_realloc_r+0x150>
 d009e38:	30c00217 	ldw	r3,8(r6)
 d009e3c:	30800317 	ldw	r2,12(r6)
 d009e40:	800f883a 	mov	r7,r16
 d009e44:	84000204 	addi	r16,r16,8
 d009e48:	10c00215 	stw	r3,8(r2)
 d009e4c:	18800315 	stw	r2,12(r3)
 d009e50:	003f2306 	br	d009ae0 <_realloc_r+0x84>
 d009e54:	8809883a 	mov	r4,r17
 d009e58:	900b883a 	mov	r5,r18
 d009e5c:	d0027a00 	call	d0027a0 <memmove>
 d009e60:	003fd006 	br	d009da4 <_realloc_r+0x348>
 d009e64:	30800117 	ldw	r2,4(r6)
 d009e68:	e0c00404 	addi	r3,fp,16
 d009e6c:	1108703a 	and	r4,r2,r4
 d009e70:	9905883a 	add	r2,r19,r4
 d009e74:	10ff4d16 	blt	r2,r3,d009bac <_realloc_r+0x150>
 d009e78:	1705c83a 	sub	r2,r2,fp
 d009e7c:	870b883a 	add	r5,r16,fp
 d009e80:	10800054 	ori	r2,r2,1
 d009e84:	28800115 	stw	r2,4(r5)
 d009e88:	80c00117 	ldw	r3,4(r16)
 d009e8c:	00834174 	movhi	r2,3333
 d009e90:	10837b04 	addi	r2,r2,3564
 d009e94:	b009883a 	mov	r4,r22
 d009e98:	18c0004c 	andi	r3,r3,1
 d009e9c:	e0c6b03a 	or	r3,fp,r3
 d009ea0:	11400215 	stw	r5,8(r2)
 d009ea4:	80c00115 	stw	r3,4(r16)
 d009ea8:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d009eac:	84400204 	addi	r17,r16,8
 d009eb0:	003f2006 	br	d009b34 <_realloc_r+0xd8>
 d009eb4:	98a9883a 	add	r20,r19,r2
 d009eb8:	2509883a 	add	r4,r4,r20
 d009ebc:	e0800404 	addi	r2,fp,16
 d009ec0:	d9000115 	stw	r4,4(sp)
 d009ec4:	20bf7016 	blt	r4,r2,d009c88 <_realloc_r+0x22c>
 d009ec8:	b8c00317 	ldw	r3,12(r23)
 d009ecc:	b8800217 	ldw	r2,8(r23)
 d009ed0:	99bfff04 	addi	r6,r19,-4
 d009ed4:	01400904 	movi	r5,36
 d009ed8:	18800215 	stw	r2,8(r3)
 d009edc:	10c00315 	stw	r3,12(r2)
 d009ee0:	bc400204 	addi	r17,r23,8
 d009ee4:	29804136 	bltu	r5,r6,d009fec <_realloc_r+0x590>
 d009ee8:	008004c4 	movi	r2,19
 d009eec:	9009883a 	mov	r4,r18
 d009ef0:	880f883a 	mov	r7,r17
 d009ef4:	11800f2e 	bgeu	r2,r6,d009f34 <_realloc_r+0x4d8>
 d009ef8:	90800017 	ldw	r2,0(r18)
 d009efc:	b9c00404 	addi	r7,r23,16
 d009f00:	91000204 	addi	r4,r18,8
 d009f04:	b8800215 	stw	r2,8(r23)
 d009f08:	90c00117 	ldw	r3,4(r18)
 d009f0c:	008006c4 	movi	r2,27
 d009f10:	b8c00315 	stw	r3,12(r23)
 d009f14:	1180072e 	bgeu	r2,r6,d009f34 <_realloc_r+0x4d8>
 d009f18:	90c00217 	ldw	r3,8(r18)
 d009f1c:	b9c00604 	addi	r7,r23,24
 d009f20:	91000404 	addi	r4,r18,16
 d009f24:	b8c00415 	stw	r3,16(r23)
 d009f28:	90800317 	ldw	r2,12(r18)
 d009f2c:	b8800515 	stw	r2,20(r23)
 d009f30:	31404026 	beq	r6,r5,d00a034 <_realloc_r+0x5d8>
 d009f34:	20800017 	ldw	r2,0(r4)
 d009f38:	38800015 	stw	r2,0(r7)
 d009f3c:	20c00117 	ldw	r3,4(r4)
 d009f40:	38c00115 	stw	r3,4(r7)
 d009f44:	20800217 	ldw	r2,8(r4)
 d009f48:	38800215 	stw	r2,8(r7)
 d009f4c:	d8c00117 	ldw	r3,4(sp)
 d009f50:	bf0b883a 	add	r5,r23,fp
 d009f54:	b009883a 	mov	r4,r22
 d009f58:	1f05c83a 	sub	r2,r3,fp
 d009f5c:	10800054 	ori	r2,r2,1
 d009f60:	28800115 	stw	r2,4(r5)
 d009f64:	b8c00117 	ldw	r3,4(r23)
 d009f68:	00834174 	movhi	r2,3333
 d009f6c:	10837b04 	addi	r2,r2,3564
 d009f70:	11400215 	stw	r5,8(r2)
 d009f74:	18c0004c 	andi	r3,r3,1
 d009f78:	e0c6b03a 	or	r3,fp,r3
 d009f7c:	b8c00115 	stw	r3,4(r23)
 d009f80:	d00d5e40 	call	d00d5e4 <__malloc_unlock>
 d009f84:	003eeb06 	br	d009b34 <_realloc_r+0xd8>
 d009f88:	20800117 	ldw	r2,4(r4)
 d009f8c:	00ffff04 	movi	r3,-4
 d009f90:	800f883a 	mov	r7,r16
 d009f94:	10c4703a 	and	r2,r2,r3
 d009f98:	98a9883a 	add	r20,r19,r2
 d009f9c:	84000204 	addi	r16,r16,8
 d009fa0:	003ecf06 	br	d009ae0 <_realloc_r+0x84>
 d009fa4:	900b883a 	mov	r5,r18
 d009fa8:	8009883a 	mov	r4,r16
 d009fac:	d0027a00 	call	d0027a0 <memmove>
 d009fb0:	dd000017 	ldw	r20,0(sp)
 d009fb4:	b80f883a 	mov	r7,r23
 d009fb8:	003ec906 	br	d009ae0 <_realloc_r+0x84>
 d009fbc:	900b883a 	mov	r5,r18
 d009fc0:	8009883a 	mov	r4,r16
 d009fc4:	d0027a00 	call	d0027a0 <memmove>
 d009fc8:	b80f883a 	mov	r7,r23
 d009fcc:	003ec406 	br	d009ae0 <_realloc_r+0x84>
 d009fd0:	90c00417 	ldw	r3,16(r18)
 d009fd4:	89400604 	addi	r5,r17,24
 d009fd8:	91000604 	addi	r4,r18,24
 d009fdc:	88c00415 	stw	r3,16(r17)
 d009fe0:	90800517 	ldw	r2,20(r18)
 d009fe4:	88800515 	stw	r2,20(r17)
 d009fe8:	003f6806 	br	d009d8c <_realloc_r+0x330>
 d009fec:	900b883a 	mov	r5,r18
 d009ff0:	8809883a 	mov	r4,r17
 d009ff4:	d0027a00 	call	d0027a0 <memmove>
 d009ff8:	003fd406 	br	d009f4c <_realloc_r+0x4f0>
 d009ffc:	90c00417 	ldw	r3,16(r18)
 d00a000:	91000604 	addi	r4,r18,24
 d00a004:	ba000804 	addi	r8,r23,32
 d00a008:	b8c00615 	stw	r3,24(r23)
 d00a00c:	90800517 	ldw	r2,20(r18)
 d00a010:	b8800715 	stw	r2,28(r23)
 d00a014:	003f1206 	br	d009c60 <_realloc_r+0x204>
 d00a018:	90c00417 	ldw	r3,16(r18)
 d00a01c:	91000604 	addi	r4,r18,24
 d00a020:	ba000804 	addi	r8,r23,32
 d00a024:	b8c00615 	stw	r3,24(r23)
 d00a028:	90800517 	ldw	r2,20(r18)
 d00a02c:	b8800715 	stw	r2,28(r23)
 d00a030:	003f3206 	br	d009cfc <_realloc_r+0x2a0>
 d00a034:	90c00417 	ldw	r3,16(r18)
 d00a038:	91000604 	addi	r4,r18,24
 d00a03c:	b9c00804 	addi	r7,r23,32
 d00a040:	b8c00615 	stw	r3,24(r23)
 d00a044:	90800517 	ldw	r2,20(r18)
 d00a048:	b8800715 	stw	r2,28(r23)
 d00a04c:	003fb906 	br	d009f34 <_realloc_r+0x4d8>

0d00a050 <__srefill_r>:
 d00a050:	defffd04 	addi	sp,sp,-12
 d00a054:	dc400115 	stw	r17,4(sp)
 d00a058:	dc000015 	stw	r16,0(sp)
 d00a05c:	dfc00215 	stw	ra,8(sp)
 d00a060:	2023883a 	mov	r17,r4
 d00a064:	2821883a 	mov	r16,r5
 d00a068:	20000226 	beq	r4,zero,d00a074 <__srefill_r+0x24>
 d00a06c:	20800e17 	ldw	r2,56(r4)
 d00a070:	10004126 	beq	r2,zero,d00a178 <__srefill_r+0x128>
 d00a074:	80c0030b 	ldhu	r3,12(r16)
 d00a078:	80000115 	stw	zero,4(r16)
 d00a07c:	1880080c 	andi	r2,r3,32
 d00a080:	1000361e 	bne	r2,zero,d00a15c <__srefill_r+0x10c>
 d00a084:	1880010c 	andi	r2,r3,4
 d00a088:	1000211e 	bne	r2,zero,d00a110 <__srefill_r+0xc0>
 d00a08c:	1880040c 	andi	r2,r3,16
 d00a090:	10005026 	beq	r2,zero,d00a1d4 <__srefill_r+0x184>
 d00a094:	1880020c 	andi	r2,r3,8
 d00a098:	1000541e 	bne	r2,zero,d00a1ec <__srefill_r+0x19c>
 d00a09c:	8080030b 	ldhu	r2,12(r16)
 d00a0a0:	10800114 	ori	r2,r2,4
 d00a0a4:	8080030d 	sth	r2,12(r16)
 d00a0a8:	80800417 	ldw	r2,16(r16)
 d00a0ac:	10004526 	beq	r2,zero,d00a1c4 <__srefill_r+0x174>
 d00a0b0:	8080030b 	ldhu	r2,12(r16)
 d00a0b4:	108000cc 	andi	r2,r2,3
 d00a0b8:	1000361e 	bne	r2,zero,d00a194 <__srefill_r+0x144>
 d00a0bc:	81800417 	ldw	r6,16(r16)
 d00a0c0:	80c00817 	ldw	r3,32(r16)
 d00a0c4:	81400717 	ldw	r5,28(r16)
 d00a0c8:	81c00517 	ldw	r7,20(r16)
 d00a0cc:	8809883a 	mov	r4,r17
 d00a0d0:	81800015 	stw	r6,0(r16)
 d00a0d4:	183ee83a 	callr	r3
 d00a0d8:	80c0030b 	ldhu	r3,12(r16)
 d00a0dc:	1009883a 	mov	r4,r2
 d00a0e0:	80800115 	stw	r2,4(r16)
 d00a0e4:	00b7ffc4 	movi	r2,-8193
 d00a0e8:	1884703a 	and	r2,r3,r2
 d00a0ec:	8080030d 	sth	r2,12(r16)
 d00a0f0:	0100230e 	bge	zero,r4,d00a180 <__srefill_r+0x130>
 d00a0f4:	0009883a 	mov	r4,zero
 d00a0f8:	2005883a 	mov	r2,r4
 d00a0fc:	dfc00217 	ldw	ra,8(sp)
 d00a100:	dc400117 	ldw	r17,4(sp)
 d00a104:	dc000017 	ldw	r16,0(sp)
 d00a108:	dec00304 	addi	sp,sp,12
 d00a10c:	f800283a 	ret
 d00a110:	81400c17 	ldw	r5,48(r16)
 d00a114:	283fe426 	beq	r5,zero,d00a0a8 <__srefill_r+0x58>
 d00a118:	80801004 	addi	r2,r16,64
 d00a11c:	28800226 	beq	r5,r2,d00a128 <__srefill_r+0xd8>
 d00a120:	8809883a 	mov	r4,r17
 d00a124:	d0076bc0 	call	d0076bc <_free_r>
 d00a128:	80800f17 	ldw	r2,60(r16)
 d00a12c:	80000c15 	stw	zero,48(r16)
 d00a130:	80800115 	stw	r2,4(r16)
 d00a134:	103fdc26 	beq	r2,zero,d00a0a8 <__srefill_r+0x58>
 d00a138:	80800e17 	ldw	r2,56(r16)
 d00a13c:	0009883a 	mov	r4,zero
 d00a140:	80800015 	stw	r2,0(r16)
 d00a144:	2005883a 	mov	r2,r4
 d00a148:	dfc00217 	ldw	ra,8(sp)
 d00a14c:	dc400117 	ldw	r17,4(sp)
 d00a150:	dc000017 	ldw	r16,0(sp)
 d00a154:	dec00304 	addi	sp,sp,12
 d00a158:	f800283a 	ret
 d00a15c:	013fffc4 	movi	r4,-1
 d00a160:	2005883a 	mov	r2,r4
 d00a164:	dfc00217 	ldw	ra,8(sp)
 d00a168:	dc400117 	ldw	r17,4(sp)
 d00a16c:	dc000017 	ldw	r16,0(sp)
 d00a170:	dec00304 	addi	sp,sp,12
 d00a174:	f800283a 	ret
 d00a178:	d0071ec0 	call	d0071ec <__sinit>
 d00a17c:	003fbd06 	br	d00a074 <__srefill_r+0x24>
 d00a180:	20000b1e 	bne	r4,zero,d00a1b0 <__srefill_r+0x160>
 d00a184:	10800814 	ori	r2,r2,32
 d00a188:	013fffc4 	movi	r4,-1
 d00a18c:	8080030d 	sth	r2,12(r16)
 d00a190:	003fd906 	br	d00a0f8 <__srefill_r+0xa8>
 d00a194:	00834174 	movhi	r2,3333
 d00a198:	108a2304 	addi	r2,r2,10380
 d00a19c:	11000017 	ldw	r4,0(r2)
 d00a1a0:	01434074 	movhi	r5,3329
 d00a1a4:	29688504 	addi	r5,r5,-24044
 d00a1a8:	d007f340 	call	d007f34 <_fwalk>
 d00a1ac:	003fc306 	br	d00a0bc <__srefill_r+0x6c>
 d00a1b0:	10801014 	ori	r2,r2,64
 d00a1b4:	013fffc4 	movi	r4,-1
 d00a1b8:	8080030d 	sth	r2,12(r16)
 d00a1bc:	80000115 	stw	zero,4(r16)
 d00a1c0:	003fcd06 	br	d00a0f8 <__srefill_r+0xa8>
 d00a1c4:	8809883a 	mov	r4,r17
 d00a1c8:	800b883a 	mov	r5,r16
 d00a1cc:	d0080b00 	call	d0080b0 <__smakebuf_r>
 d00a1d0:	003fb706 	br	d00a0b0 <__srefill_r+0x60>
 d00a1d4:	18c01014 	ori	r3,r3,64
 d00a1d8:	00800244 	movi	r2,9
 d00a1dc:	013fffc4 	movi	r4,-1
 d00a1e0:	88800015 	stw	r2,0(r17)
 d00a1e4:	80c0030d 	sth	r3,12(r16)
 d00a1e8:	003fc306 	br	d00a0f8 <__srefill_r+0xa8>
 d00a1ec:	8809883a 	mov	r4,r17
 d00a1f0:	800b883a 	mov	r5,r16
 d00a1f4:	d006f540 	call	d006f54 <_fflush_r>
 d00a1f8:	103fd81e 	bne	r2,zero,d00a15c <__srefill_r+0x10c>
 d00a1fc:	8080030b 	ldhu	r2,12(r16)
 d00a200:	80000215 	stw	zero,8(r16)
 d00a204:	80000615 	stw	zero,24(r16)
 d00a208:	10bffdcc 	andi	r2,r2,65527
 d00a20c:	8080030d 	sth	r2,12(r16)
 d00a210:	003fa206 	br	d00a09c <__srefill_r+0x4c>

0d00a214 <lflush>:
 d00a214:	20c0030b 	ldhu	r3,12(r4)
 d00a218:	01400244 	movi	r5,9
 d00a21c:	0005883a 	mov	r2,zero
 d00a220:	18c0024c 	andi	r3,r3,9
 d00a224:	19400126 	beq	r3,r5,d00a22c <lflush+0x18>
 d00a228:	f800283a 	ret
 d00a22c:	d0071501 	jmpi	d007150 <fflush>

0d00a230 <__isinfd>:
 d00a230:	200d883a 	mov	r6,r4
 d00a234:	0109c83a 	sub	r4,zero,r4
 d00a238:	2188b03a 	or	r4,r4,r6
 d00a23c:	2008d7fa 	srli	r4,r4,31
 d00a240:	00a00034 	movhi	r2,32768
 d00a244:	10bfffc4 	addi	r2,r2,-1
 d00a248:	1144703a 	and	r2,r2,r5
 d00a24c:	2088b03a 	or	r4,r4,r2
 d00a250:	009ffc34 	movhi	r2,32752
 d00a254:	1105c83a 	sub	r2,r2,r4
 d00a258:	0087c83a 	sub	r3,zero,r2
 d00a25c:	10c4b03a 	or	r2,r2,r3
 d00a260:	1004d7fa 	srli	r2,r2,31
 d00a264:	00c00044 	movi	r3,1
 d00a268:	1885c83a 	sub	r2,r3,r2
 d00a26c:	f800283a 	ret

0d00a270 <__isnand>:
 d00a270:	200d883a 	mov	r6,r4
 d00a274:	0109c83a 	sub	r4,zero,r4
 d00a278:	2188b03a 	or	r4,r4,r6
 d00a27c:	2008d7fa 	srli	r4,r4,31
 d00a280:	00a00034 	movhi	r2,32768
 d00a284:	10bfffc4 	addi	r2,r2,-1
 d00a288:	1144703a 	and	r2,r2,r5
 d00a28c:	2088b03a 	or	r4,r4,r2
 d00a290:	009ffc34 	movhi	r2,32752
 d00a294:	1105c83a 	sub	r2,r2,r4
 d00a298:	1004d7fa 	srli	r2,r2,31
 d00a29c:	f800283a 	ret

0d00a2a0 <_sbrk_r>:
 d00a2a0:	defffd04 	addi	sp,sp,-12
 d00a2a4:	dc000015 	stw	r16,0(sp)
 d00a2a8:	04034174 	movhi	r16,3333
 d00a2ac:	840a8404 	addi	r16,r16,10768
 d00a2b0:	dc400115 	stw	r17,4(sp)
 d00a2b4:	80000015 	stw	zero,0(r16)
 d00a2b8:	2023883a 	mov	r17,r4
 d00a2bc:	2809883a 	mov	r4,r5
 d00a2c0:	dfc00215 	stw	ra,8(sp)
 d00a2c4:	d00d3180 	call	d00d318 <sbrk>
 d00a2c8:	1007883a 	mov	r3,r2
 d00a2cc:	00bfffc4 	movi	r2,-1
 d00a2d0:	18800626 	beq	r3,r2,d00a2ec <_sbrk_r+0x4c>
 d00a2d4:	1805883a 	mov	r2,r3
 d00a2d8:	dfc00217 	ldw	ra,8(sp)
 d00a2dc:	dc400117 	ldw	r17,4(sp)
 d00a2e0:	dc000017 	ldw	r16,0(sp)
 d00a2e4:	dec00304 	addi	sp,sp,12
 d00a2e8:	f800283a 	ret
 d00a2ec:	80800017 	ldw	r2,0(r16)
 d00a2f0:	103ff826 	beq	r2,zero,d00a2d4 <_sbrk_r+0x34>
 d00a2f4:	88800015 	stw	r2,0(r17)
 d00a2f8:	1805883a 	mov	r2,r3
 d00a2fc:	dfc00217 	ldw	ra,8(sp)
 d00a300:	dc400117 	ldw	r17,4(sp)
 d00a304:	dc000017 	ldw	r16,0(sp)
 d00a308:	dec00304 	addi	sp,sp,12
 d00a30c:	f800283a 	ret

0d00a310 <__sclose>:
 d00a310:	2940038f 	ldh	r5,14(r5)
 d00a314:	d00a6441 	jmpi	d00a644 <_close_r>

0d00a318 <__sseek>:
 d00a318:	defffe04 	addi	sp,sp,-8
 d00a31c:	dc000015 	stw	r16,0(sp)
 d00a320:	2821883a 	mov	r16,r5
 d00a324:	2940038f 	ldh	r5,14(r5)
 d00a328:	dfc00115 	stw	ra,4(sp)
 d00a32c:	d00a8bc0 	call	d00a8bc <_lseek_r>
 d00a330:	1007883a 	mov	r3,r2
 d00a334:	00bfffc4 	movi	r2,-1
 d00a338:	18800926 	beq	r3,r2,d00a360 <__sseek+0x48>
 d00a33c:	8080030b 	ldhu	r2,12(r16)
 d00a340:	80c01415 	stw	r3,80(r16)
 d00a344:	10840014 	ori	r2,r2,4096
 d00a348:	8080030d 	sth	r2,12(r16)
 d00a34c:	1805883a 	mov	r2,r3
 d00a350:	dfc00117 	ldw	ra,4(sp)
 d00a354:	dc000017 	ldw	r16,0(sp)
 d00a358:	dec00204 	addi	sp,sp,8
 d00a35c:	f800283a 	ret
 d00a360:	8080030b 	ldhu	r2,12(r16)
 d00a364:	10bbffcc 	andi	r2,r2,61439
 d00a368:	8080030d 	sth	r2,12(r16)
 d00a36c:	1805883a 	mov	r2,r3
 d00a370:	dfc00117 	ldw	ra,4(sp)
 d00a374:	dc000017 	ldw	r16,0(sp)
 d00a378:	dec00204 	addi	sp,sp,8
 d00a37c:	f800283a 	ret

0d00a380 <__swrite>:
 d00a380:	2880030b 	ldhu	r2,12(r5)
 d00a384:	defffb04 	addi	sp,sp,-20
 d00a388:	dcc00315 	stw	r19,12(sp)
 d00a38c:	1080400c 	andi	r2,r2,256
 d00a390:	dc800215 	stw	r18,8(sp)
 d00a394:	dc400115 	stw	r17,4(sp)
 d00a398:	dc000015 	stw	r16,0(sp)
 d00a39c:	3027883a 	mov	r19,r6
 d00a3a0:	3825883a 	mov	r18,r7
 d00a3a4:	dfc00415 	stw	ra,16(sp)
 d00a3a8:	2821883a 	mov	r16,r5
 d00a3ac:	000d883a 	mov	r6,zero
 d00a3b0:	01c00084 	movi	r7,2
 d00a3b4:	2023883a 	mov	r17,r4
 d00a3b8:	10000226 	beq	r2,zero,d00a3c4 <__swrite+0x44>
 d00a3bc:	2940038f 	ldh	r5,14(r5)
 d00a3c0:	d00a8bc0 	call	d00a8bc <_lseek_r>
 d00a3c4:	8080030b 	ldhu	r2,12(r16)
 d00a3c8:	8140038f 	ldh	r5,14(r16)
 d00a3cc:	8809883a 	mov	r4,r17
 d00a3d0:	10bbffcc 	andi	r2,r2,61439
 d00a3d4:	980d883a 	mov	r6,r19
 d00a3d8:	900f883a 	mov	r7,r18
 d00a3dc:	8080030d 	sth	r2,12(r16)
 d00a3e0:	dfc00417 	ldw	ra,16(sp)
 d00a3e4:	dcc00317 	ldw	r19,12(sp)
 d00a3e8:	dc800217 	ldw	r18,8(sp)
 d00a3ec:	dc400117 	ldw	r17,4(sp)
 d00a3f0:	dc000017 	ldw	r16,0(sp)
 d00a3f4:	dec00504 	addi	sp,sp,20
 d00a3f8:	d00a5181 	jmpi	d00a518 <_write_r>

0d00a3fc <__sread>:
 d00a3fc:	defffe04 	addi	sp,sp,-8
 d00a400:	dc000015 	stw	r16,0(sp)
 d00a404:	2821883a 	mov	r16,r5
 d00a408:	2940038f 	ldh	r5,14(r5)
 d00a40c:	dfc00115 	stw	ra,4(sp)
 d00a410:	d00a9340 	call	d00a934 <_read_r>
 d00a414:	1007883a 	mov	r3,r2
 d00a418:	10000816 	blt	r2,zero,d00a43c <__sread+0x40>
 d00a41c:	80801417 	ldw	r2,80(r16)
 d00a420:	10c5883a 	add	r2,r2,r3
 d00a424:	80801415 	stw	r2,80(r16)
 d00a428:	1805883a 	mov	r2,r3
 d00a42c:	dfc00117 	ldw	ra,4(sp)
 d00a430:	dc000017 	ldw	r16,0(sp)
 d00a434:	dec00204 	addi	sp,sp,8
 d00a438:	f800283a 	ret
 d00a43c:	8080030b 	ldhu	r2,12(r16)
 d00a440:	10bbffcc 	andi	r2,r2,61439
 d00a444:	8080030d 	sth	r2,12(r16)
 d00a448:	1805883a 	mov	r2,r3
 d00a44c:	dfc00117 	ldw	ra,4(sp)
 d00a450:	dc000017 	ldw	r16,0(sp)
 d00a454:	dec00204 	addi	sp,sp,8
 d00a458:	f800283a 	ret

0d00a45c <strcmp>:
 d00a45c:	2144b03a 	or	r2,r4,r5
 d00a460:	108000cc 	andi	r2,r2,3
 d00a464:	10001d1e 	bne	r2,zero,d00a4dc <strcmp+0x80>
 d00a468:	200f883a 	mov	r7,r4
 d00a46c:	28800017 	ldw	r2,0(r5)
 d00a470:	21000017 	ldw	r4,0(r4)
 d00a474:	280d883a 	mov	r6,r5
 d00a478:	2080161e 	bne	r4,r2,d00a4d4 <strcmp+0x78>
 d00a47c:	023fbff4 	movhi	r8,65279
 d00a480:	423fbfc4 	addi	r8,r8,-257
 d00a484:	2207883a 	add	r3,r4,r8
 d00a488:	01602074 	movhi	r5,32897
 d00a48c:	29602004 	addi	r5,r5,-32640
 d00a490:	1946703a 	and	r3,r3,r5
 d00a494:	0104303a 	nor	r2,zero,r4
 d00a498:	10c4703a 	and	r2,r2,r3
 d00a49c:	10001c1e 	bne	r2,zero,d00a510 <strcmp+0xb4>
 d00a4a0:	4013883a 	mov	r9,r8
 d00a4a4:	2811883a 	mov	r8,r5
 d00a4a8:	00000106 	br	d00a4b0 <strcmp+0x54>
 d00a4ac:	1800181e 	bne	r3,zero,d00a510 <strcmp+0xb4>
 d00a4b0:	39c00104 	addi	r7,r7,4
 d00a4b4:	39000017 	ldw	r4,0(r7)
 d00a4b8:	31800104 	addi	r6,r6,4
 d00a4bc:	31400017 	ldw	r5,0(r6)
 d00a4c0:	2245883a 	add	r2,r4,r9
 d00a4c4:	1204703a 	and	r2,r2,r8
 d00a4c8:	0106303a 	nor	r3,zero,r4
 d00a4cc:	1886703a 	and	r3,r3,r2
 d00a4d0:	217ff626 	beq	r4,r5,d00a4ac <strcmp+0x50>
 d00a4d4:	3809883a 	mov	r4,r7
 d00a4d8:	300b883a 	mov	r5,r6
 d00a4dc:	20c00007 	ldb	r3,0(r4)
 d00a4e0:	1800051e 	bne	r3,zero,d00a4f8 <strcmp+0x9c>
 d00a4e4:	00000606 	br	d00a500 <strcmp+0xa4>
 d00a4e8:	21000044 	addi	r4,r4,1
 d00a4ec:	20c00007 	ldb	r3,0(r4)
 d00a4f0:	29400044 	addi	r5,r5,1
 d00a4f4:	18000226 	beq	r3,zero,d00a500 <strcmp+0xa4>
 d00a4f8:	28800007 	ldb	r2,0(r5)
 d00a4fc:	18bffa26 	beq	r3,r2,d00a4e8 <strcmp+0x8c>
 d00a500:	20c00003 	ldbu	r3,0(r4)
 d00a504:	28800003 	ldbu	r2,0(r5)
 d00a508:	1885c83a 	sub	r2,r3,r2
 d00a50c:	f800283a 	ret
 d00a510:	0005883a 	mov	r2,zero
 d00a514:	f800283a 	ret

0d00a518 <_write_r>:
 d00a518:	defffd04 	addi	sp,sp,-12
 d00a51c:	dc000015 	stw	r16,0(sp)
 d00a520:	04034174 	movhi	r16,3333
 d00a524:	840a8404 	addi	r16,r16,10768
 d00a528:	dc400115 	stw	r17,4(sp)
 d00a52c:	80000015 	stw	zero,0(r16)
 d00a530:	2023883a 	mov	r17,r4
 d00a534:	2809883a 	mov	r4,r5
 d00a538:	300b883a 	mov	r5,r6
 d00a53c:	380d883a 	mov	r6,r7
 d00a540:	dfc00215 	stw	ra,8(sp)
 d00a544:	d02122c0 	call	d02122c <write>
 d00a548:	1007883a 	mov	r3,r2
 d00a54c:	00bfffc4 	movi	r2,-1
 d00a550:	18800626 	beq	r3,r2,d00a56c <_write_r+0x54>
 d00a554:	1805883a 	mov	r2,r3
 d00a558:	dfc00217 	ldw	ra,8(sp)
 d00a55c:	dc400117 	ldw	r17,4(sp)
 d00a560:	dc000017 	ldw	r16,0(sp)
 d00a564:	dec00304 	addi	sp,sp,12
 d00a568:	f800283a 	ret
 d00a56c:	80800017 	ldw	r2,0(r16)
 d00a570:	103ff826 	beq	r2,zero,d00a554 <_write_r+0x3c>
 d00a574:	88800015 	stw	r2,0(r17)
 d00a578:	1805883a 	mov	r2,r3
 d00a57c:	dfc00217 	ldw	ra,8(sp)
 d00a580:	dc400117 	ldw	r17,4(sp)
 d00a584:	dc000017 	ldw	r16,0(sp)
 d00a588:	dec00304 	addi	sp,sp,12
 d00a58c:	f800283a 	ret

0d00a590 <_calloc_r>:
 d00a590:	298b383a 	mul	r5,r5,r6
 d00a594:	defffe04 	addi	sp,sp,-8
 d00a598:	dc000015 	stw	r16,0(sp)
 d00a59c:	dfc00115 	stw	ra,4(sp)
 d00a5a0:	d0082440 	call	d008244 <_malloc_r>
 d00a5a4:	1021883a 	mov	r16,r2
 d00a5a8:	01c00904 	movi	r7,36
 d00a5ac:	10000d26 	beq	r2,zero,d00a5e4 <_calloc_r+0x54>
 d00a5b0:	10ffff17 	ldw	r3,-4(r2)
 d00a5b4:	1009883a 	mov	r4,r2
 d00a5b8:	00bfff04 	movi	r2,-4
 d00a5bc:	1886703a 	and	r3,r3,r2
 d00a5c0:	1887883a 	add	r3,r3,r2
 d00a5c4:	180d883a 	mov	r6,r3
 d00a5c8:	000b883a 	mov	r5,zero
 d00a5cc:	38c01736 	bltu	r7,r3,d00a62c <_calloc_r+0x9c>
 d00a5d0:	008004c4 	movi	r2,19
 d00a5d4:	10c00836 	bltu	r2,r3,d00a5f8 <_calloc_r+0x68>
 d00a5d8:	20000215 	stw	zero,8(r4)
 d00a5dc:	20000015 	stw	zero,0(r4)
 d00a5e0:	20000115 	stw	zero,4(r4)
 d00a5e4:	8005883a 	mov	r2,r16
 d00a5e8:	dfc00117 	ldw	ra,4(sp)
 d00a5ec:	dc000017 	ldw	r16,0(sp)
 d00a5f0:	dec00204 	addi	sp,sp,8
 d00a5f4:	f800283a 	ret
 d00a5f8:	008006c4 	movi	r2,27
 d00a5fc:	80000015 	stw	zero,0(r16)
 d00a600:	80000115 	stw	zero,4(r16)
 d00a604:	81000204 	addi	r4,r16,8
 d00a608:	10fff32e 	bgeu	r2,r3,d00a5d8 <_calloc_r+0x48>
 d00a60c:	80000215 	stw	zero,8(r16)
 d00a610:	80000315 	stw	zero,12(r16)
 d00a614:	81000404 	addi	r4,r16,16
 d00a618:	19ffef1e 	bne	r3,r7,d00a5d8 <_calloc_r+0x48>
 d00a61c:	81000604 	addi	r4,r16,24
 d00a620:	80000415 	stw	zero,16(r16)
 d00a624:	80000515 	stw	zero,20(r16)
 d00a628:	003feb06 	br	d00a5d8 <_calloc_r+0x48>
 d00a62c:	d0028800 	call	d002880 <memset>
 d00a630:	8005883a 	mov	r2,r16
 d00a634:	dfc00117 	ldw	ra,4(sp)
 d00a638:	dc000017 	ldw	r16,0(sp)
 d00a63c:	dec00204 	addi	sp,sp,8
 d00a640:	f800283a 	ret

0d00a644 <_close_r>:
 d00a644:	defffd04 	addi	sp,sp,-12
 d00a648:	dc000015 	stw	r16,0(sp)
 d00a64c:	04034174 	movhi	r16,3333
 d00a650:	840a8404 	addi	r16,r16,10768
 d00a654:	dc400115 	stw	r17,4(sp)
 d00a658:	80000015 	stw	zero,0(r16)
 d00a65c:	2023883a 	mov	r17,r4
 d00a660:	2809883a 	mov	r4,r5
 d00a664:	dfc00215 	stw	ra,8(sp)
 d00a668:	d02101c0 	call	d02101c <close>
 d00a66c:	1007883a 	mov	r3,r2
 d00a670:	00bfffc4 	movi	r2,-1
 d00a674:	18800626 	beq	r3,r2,d00a690 <_close_r+0x4c>
 d00a678:	1805883a 	mov	r2,r3
 d00a67c:	dfc00217 	ldw	ra,8(sp)
 d00a680:	dc400117 	ldw	r17,4(sp)
 d00a684:	dc000017 	ldw	r16,0(sp)
 d00a688:	dec00304 	addi	sp,sp,12
 d00a68c:	f800283a 	ret
 d00a690:	80800017 	ldw	r2,0(r16)
 d00a694:	103ff826 	beq	r2,zero,d00a678 <_close_r+0x34>
 d00a698:	88800015 	stw	r2,0(r17)
 d00a69c:	1805883a 	mov	r2,r3
 d00a6a0:	dfc00217 	ldw	ra,8(sp)
 d00a6a4:	dc400117 	ldw	r17,4(sp)
 d00a6a8:	dc000017 	ldw	r16,0(sp)
 d00a6ac:	dec00304 	addi	sp,sp,12
 d00a6b0:	f800283a 	ret

0d00a6b4 <_fclose_r>:
 d00a6b4:	defffc04 	addi	sp,sp,-16
 d00a6b8:	dc400115 	stw	r17,4(sp)
 d00a6bc:	dc000015 	stw	r16,0(sp)
 d00a6c0:	dfc00315 	stw	ra,12(sp)
 d00a6c4:	dc800215 	stw	r18,8(sp)
 d00a6c8:	2821883a 	mov	r16,r5
 d00a6cc:	2023883a 	mov	r17,r4
 d00a6d0:	28002926 	beq	r5,zero,d00a778 <_fclose_r+0xc4>
 d00a6d4:	d0071dc0 	call	d0071dc <__sfp_lock_acquire>
 d00a6d8:	88000226 	beq	r17,zero,d00a6e4 <_fclose_r+0x30>
 d00a6dc:	88800e17 	ldw	r2,56(r17)
 d00a6e0:	10002d26 	beq	r2,zero,d00a798 <_fclose_r+0xe4>
 d00a6e4:	8080030f 	ldh	r2,12(r16)
 d00a6e8:	10002226 	beq	r2,zero,d00a774 <_fclose_r+0xc0>
 d00a6ec:	8809883a 	mov	r4,r17
 d00a6f0:	800b883a 	mov	r5,r16
 d00a6f4:	d006f540 	call	d006f54 <_fflush_r>
 d00a6f8:	1025883a 	mov	r18,r2
 d00a6fc:	80800b17 	ldw	r2,44(r16)
 d00a700:	10000426 	beq	r2,zero,d00a714 <_fclose_r+0x60>
 d00a704:	81400717 	ldw	r5,28(r16)
 d00a708:	8809883a 	mov	r4,r17
 d00a70c:	103ee83a 	callr	r2
 d00a710:	10002a16 	blt	r2,zero,d00a7bc <_fclose_r+0x108>
 d00a714:	8080030b 	ldhu	r2,12(r16)
 d00a718:	1080200c 	andi	r2,r2,128
 d00a71c:	1000231e 	bne	r2,zero,d00a7ac <_fclose_r+0xf8>
 d00a720:	81400c17 	ldw	r5,48(r16)
 d00a724:	28000526 	beq	r5,zero,d00a73c <_fclose_r+0x88>
 d00a728:	80801004 	addi	r2,r16,64
 d00a72c:	28800226 	beq	r5,r2,d00a738 <_fclose_r+0x84>
 d00a730:	8809883a 	mov	r4,r17
 d00a734:	d0076bc0 	call	d0076bc <_free_r>
 d00a738:	80000c15 	stw	zero,48(r16)
 d00a73c:	81401117 	ldw	r5,68(r16)
 d00a740:	28000326 	beq	r5,zero,d00a750 <_fclose_r+0x9c>
 d00a744:	8809883a 	mov	r4,r17
 d00a748:	d0076bc0 	call	d0076bc <_free_r>
 d00a74c:	80001115 	stw	zero,68(r16)
 d00a750:	8000030d 	sth	zero,12(r16)
 d00a754:	d0071e00 	call	d0071e0 <__sfp_lock_release>
 d00a758:	9005883a 	mov	r2,r18
 d00a75c:	dfc00317 	ldw	ra,12(sp)
 d00a760:	dc800217 	ldw	r18,8(sp)
 d00a764:	dc400117 	ldw	r17,4(sp)
 d00a768:	dc000017 	ldw	r16,0(sp)
 d00a76c:	dec00404 	addi	sp,sp,16
 d00a770:	f800283a 	ret
 d00a774:	d0071e00 	call	d0071e0 <__sfp_lock_release>
 d00a778:	0025883a 	mov	r18,zero
 d00a77c:	9005883a 	mov	r2,r18
 d00a780:	dfc00317 	ldw	ra,12(sp)
 d00a784:	dc800217 	ldw	r18,8(sp)
 d00a788:	dc400117 	ldw	r17,4(sp)
 d00a78c:	dc000017 	ldw	r16,0(sp)
 d00a790:	dec00404 	addi	sp,sp,16
 d00a794:	f800283a 	ret
 d00a798:	8809883a 	mov	r4,r17
 d00a79c:	d0071ec0 	call	d0071ec <__sinit>
 d00a7a0:	8080030f 	ldh	r2,12(r16)
 d00a7a4:	103fd11e 	bne	r2,zero,d00a6ec <_fclose_r+0x38>
 d00a7a8:	003ff206 	br	d00a774 <_fclose_r+0xc0>
 d00a7ac:	81400417 	ldw	r5,16(r16)
 d00a7b0:	8809883a 	mov	r4,r17
 d00a7b4:	d0076bc0 	call	d0076bc <_free_r>
 d00a7b8:	003fd906 	br	d00a720 <_fclose_r+0x6c>
 d00a7bc:	04bfffc4 	movi	r18,-1
 d00a7c0:	003fd406 	br	d00a714 <_fclose_r+0x60>

0d00a7c4 <fclose>:
 d00a7c4:	00834174 	movhi	r2,3333
 d00a7c8:	108a2204 	addi	r2,r2,10376
 d00a7cc:	200b883a 	mov	r5,r4
 d00a7d0:	11000017 	ldw	r4,0(r2)
 d00a7d4:	d00a6b41 	jmpi	d00a6b4 <_fclose_r>

0d00a7d8 <_fstat_r>:
 d00a7d8:	defffd04 	addi	sp,sp,-12
 d00a7dc:	dc000015 	stw	r16,0(sp)
 d00a7e0:	04034174 	movhi	r16,3333
 d00a7e4:	840a8404 	addi	r16,r16,10768
 d00a7e8:	dc400115 	stw	r17,4(sp)
 d00a7ec:	80000015 	stw	zero,0(r16)
 d00a7f0:	2023883a 	mov	r17,r4
 d00a7f4:	2809883a 	mov	r4,r5
 d00a7f8:	300b883a 	mov	r5,r6
 d00a7fc:	dfc00215 	stw	ra,8(sp)
 d00a800:	d00ceac0 	call	d00ceac <fstat>
 d00a804:	1007883a 	mov	r3,r2
 d00a808:	00bfffc4 	movi	r2,-1
 d00a80c:	18800626 	beq	r3,r2,d00a828 <_fstat_r+0x50>
 d00a810:	1805883a 	mov	r2,r3
 d00a814:	dfc00217 	ldw	ra,8(sp)
 d00a818:	dc400117 	ldw	r17,4(sp)
 d00a81c:	dc000017 	ldw	r16,0(sp)
 d00a820:	dec00304 	addi	sp,sp,12
 d00a824:	f800283a 	ret
 d00a828:	80800017 	ldw	r2,0(r16)
 d00a82c:	103ff826 	beq	r2,zero,d00a810 <_fstat_r+0x38>
 d00a830:	88800015 	stw	r2,0(r17)
 d00a834:	1805883a 	mov	r2,r3
 d00a838:	dfc00217 	ldw	ra,8(sp)
 d00a83c:	dc400117 	ldw	r17,4(sp)
 d00a840:	dc000017 	ldw	r16,0(sp)
 d00a844:	dec00304 	addi	sp,sp,12
 d00a848:	f800283a 	ret

0d00a84c <_isatty_r>:
 d00a84c:	defffd04 	addi	sp,sp,-12
 d00a850:	dc000015 	stw	r16,0(sp)
 d00a854:	04034174 	movhi	r16,3333
 d00a858:	840a8404 	addi	r16,r16,10768
 d00a85c:	dc400115 	stw	r17,4(sp)
 d00a860:	80000015 	stw	zero,0(r16)
 d00a864:	2023883a 	mov	r17,r4
 d00a868:	2809883a 	mov	r4,r5
 d00a86c:	dfc00215 	stw	ra,8(sp)
 d00a870:	d00cfe00 	call	d00cfe0 <isatty>
 d00a874:	1007883a 	mov	r3,r2
 d00a878:	00bfffc4 	movi	r2,-1
 d00a87c:	18800626 	beq	r3,r2,d00a898 <_isatty_r+0x4c>
 d00a880:	1805883a 	mov	r2,r3
 d00a884:	dfc00217 	ldw	ra,8(sp)
 d00a888:	dc400117 	ldw	r17,4(sp)
 d00a88c:	dc000017 	ldw	r16,0(sp)
 d00a890:	dec00304 	addi	sp,sp,12
 d00a894:	f800283a 	ret
 d00a898:	80800017 	ldw	r2,0(r16)
 d00a89c:	103ff826 	beq	r2,zero,d00a880 <_isatty_r+0x34>
 d00a8a0:	88800015 	stw	r2,0(r17)
 d00a8a4:	1805883a 	mov	r2,r3
 d00a8a8:	dfc00217 	ldw	ra,8(sp)
 d00a8ac:	dc400117 	ldw	r17,4(sp)
 d00a8b0:	dc000017 	ldw	r16,0(sp)
 d00a8b4:	dec00304 	addi	sp,sp,12
 d00a8b8:	f800283a 	ret

0d00a8bc <_lseek_r>:
 d00a8bc:	defffd04 	addi	sp,sp,-12
 d00a8c0:	dc000015 	stw	r16,0(sp)
 d00a8c4:	04034174 	movhi	r16,3333
 d00a8c8:	840a8404 	addi	r16,r16,10768
 d00a8cc:	dc400115 	stw	r17,4(sp)
 d00a8d0:	80000015 	stw	zero,0(r16)
 d00a8d4:	2023883a 	mov	r17,r4
 d00a8d8:	2809883a 	mov	r4,r5
 d00a8dc:	300b883a 	mov	r5,r6
 d00a8e0:	380d883a 	mov	r6,r7
 d00a8e4:	dfc00215 	stw	ra,8(sp)
 d00a8e8:	d00d1000 	call	d00d100 <lseek>
 d00a8ec:	1007883a 	mov	r3,r2
 d00a8f0:	00bfffc4 	movi	r2,-1
 d00a8f4:	18800626 	beq	r3,r2,d00a910 <_lseek_r+0x54>
 d00a8f8:	1805883a 	mov	r2,r3
 d00a8fc:	dfc00217 	ldw	ra,8(sp)
 d00a900:	dc400117 	ldw	r17,4(sp)
 d00a904:	dc000017 	ldw	r16,0(sp)
 d00a908:	dec00304 	addi	sp,sp,12
 d00a90c:	f800283a 	ret
 d00a910:	80800017 	ldw	r2,0(r16)
 d00a914:	103ff826 	beq	r2,zero,d00a8f8 <_lseek_r+0x3c>
 d00a918:	88800015 	stw	r2,0(r17)
 d00a91c:	1805883a 	mov	r2,r3
 d00a920:	dfc00217 	ldw	ra,8(sp)
 d00a924:	dc400117 	ldw	r17,4(sp)
 d00a928:	dc000017 	ldw	r16,0(sp)
 d00a92c:	dec00304 	addi	sp,sp,12
 d00a930:	f800283a 	ret

0d00a934 <_read_r>:
 d00a934:	defffd04 	addi	sp,sp,-12
 d00a938:	dc000015 	stw	r16,0(sp)
 d00a93c:	04034174 	movhi	r16,3333
 d00a940:	840a8404 	addi	r16,r16,10768
 d00a944:	dc400115 	stw	r17,4(sp)
 d00a948:	80000015 	stw	zero,0(r16)
 d00a94c:	2023883a 	mov	r17,r4
 d00a950:	2809883a 	mov	r4,r5
 d00a954:	300b883a 	mov	r5,r6
 d00a958:	380d883a 	mov	r6,r7
 d00a95c:	dfc00215 	stw	ra,8(sp)
 d00a960:	d0211b40 	call	d0211b4 <read>
 d00a964:	1007883a 	mov	r3,r2
 d00a968:	00bfffc4 	movi	r2,-1
 d00a96c:	18800626 	beq	r3,r2,d00a988 <_read_r+0x54>
 d00a970:	1805883a 	mov	r2,r3
 d00a974:	dfc00217 	ldw	ra,8(sp)
 d00a978:	dc400117 	ldw	r17,4(sp)
 d00a97c:	dc000017 	ldw	r16,0(sp)
 d00a980:	dec00304 	addi	sp,sp,12
 d00a984:	f800283a 	ret
 d00a988:	80800017 	ldw	r2,0(r16)
 d00a98c:	103ff826 	beq	r2,zero,d00a970 <_read_r+0x3c>
 d00a990:	88800015 	stw	r2,0(r17)
 d00a994:	1805883a 	mov	r2,r3
 d00a998:	dfc00217 	ldw	ra,8(sp)
 d00a99c:	dc400117 	ldw	r17,4(sp)
 d00a9a0:	dc000017 	ldw	r16,0(sp)
 d00a9a4:	dec00304 	addi	sp,sp,12
 d00a9a8:	f800283a 	ret

0d00a9ac <__udivdi3>:
 d00a9ac:	defff004 	addi	sp,sp,-64
 d00a9b0:	2005883a 	mov	r2,r4
 d00a9b4:	3011883a 	mov	r8,r6
 d00a9b8:	df000e15 	stw	fp,56(sp)
 d00a9bc:	dd000a15 	stw	r20,40(sp)
 d00a9c0:	dc000615 	stw	r16,24(sp)
 d00a9c4:	dfc00f15 	stw	ra,60(sp)
 d00a9c8:	ddc00d15 	stw	r23,52(sp)
 d00a9cc:	dd800c15 	stw	r22,48(sp)
 d00a9d0:	dd400b15 	stw	r21,44(sp)
 d00a9d4:	dcc00915 	stw	r19,36(sp)
 d00a9d8:	dc800815 	stw	r18,32(sp)
 d00a9dc:	dc400715 	stw	r17,28(sp)
 d00a9e0:	4021883a 	mov	r16,r8
 d00a9e4:	1039883a 	mov	fp,r2
 d00a9e8:	2829883a 	mov	r20,r5
 d00a9ec:	38003b1e 	bne	r7,zero,d00aadc <__udivdi3+0x130>
 d00a9f0:	2a005c36 	bltu	r5,r8,d00ab64 <__udivdi3+0x1b8>
 d00a9f4:	4000a626 	beq	r8,zero,d00ac90 <__udivdi3+0x2e4>
 d00a9f8:	00bfffd4 	movui	r2,65535
 d00a9fc:	14009e36 	bltu	r2,r16,d00ac78 <__udivdi3+0x2cc>
 d00aa00:	00803fc4 	movi	r2,255
 d00aa04:	14013d36 	bltu	r2,r16,d00aefc <__udivdi3+0x550>
 d00aa08:	000b883a 	mov	r5,zero
 d00aa0c:	0005883a 	mov	r2,zero
 d00aa10:	8084d83a 	srl	r2,r16,r2
 d00aa14:	01034174 	movhi	r4,3333
 d00aa18:	21316e04 	addi	r4,r4,-14920
 d00aa1c:	01800804 	movi	r6,32
 d00aa20:	1105883a 	add	r2,r2,r4
 d00aa24:	10c00003 	ldbu	r3,0(r2)
 d00aa28:	28c7883a 	add	r3,r5,r3
 d00aa2c:	30edc83a 	sub	r22,r6,r3
 d00aa30:	b000ee1e 	bne	r22,zero,d00adec <__udivdi3+0x440>
 d00aa34:	802ad43a 	srli	r21,r16,16
 d00aa38:	00800044 	movi	r2,1
 d00aa3c:	a423c83a 	sub	r17,r20,r16
 d00aa40:	85ffffcc 	andi	r23,r16,65535
 d00aa44:	d8800315 	stw	r2,12(sp)
 d00aa48:	8809883a 	mov	r4,r17
 d00aa4c:	a80b883a 	mov	r5,r21
 d00aa50:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00aa54:	8809883a 	mov	r4,r17
 d00aa58:	a80b883a 	mov	r5,r21
 d00aa5c:	102d883a 	mov	r22,r2
 d00aa60:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00aa64:	1004943a 	slli	r2,r2,16
 d00aa68:	e006d43a 	srli	r3,fp,16
 d00aa6c:	bda3383a 	mul	r17,r23,r22
 d00aa70:	10c4b03a 	or	r2,r2,r3
 d00aa74:	1440042e 	bgeu	r2,r17,d00aa88 <__udivdi3+0xdc>
 d00aa78:	1405883a 	add	r2,r2,r16
 d00aa7c:	b5bfffc4 	addi	r22,r22,-1
 d00aa80:	14000136 	bltu	r2,r16,d00aa88 <__udivdi3+0xdc>
 d00aa84:	14413d36 	bltu	r2,r17,d00af7c <__udivdi3+0x5d0>
 d00aa88:	1463c83a 	sub	r17,r2,r17
 d00aa8c:	8809883a 	mov	r4,r17
 d00aa90:	a80b883a 	mov	r5,r21
 d00aa94:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00aa98:	8809883a 	mov	r4,r17
 d00aa9c:	a80b883a 	mov	r5,r21
 d00aaa0:	1029883a 	mov	r20,r2
 d00aaa4:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00aaa8:	1004943a 	slli	r2,r2,16
 d00aaac:	bd09383a 	mul	r4,r23,r20
 d00aab0:	e0ffffcc 	andi	r3,fp,65535
 d00aab4:	10c4b03a 	or	r2,r2,r3
 d00aab8:	1100042e 	bgeu	r2,r4,d00aacc <__udivdi3+0x120>
 d00aabc:	8085883a 	add	r2,r16,r2
 d00aac0:	a53fffc4 	addi	r20,r20,-1
 d00aac4:	14000136 	bltu	r2,r16,d00aacc <__udivdi3+0x120>
 d00aac8:	11012036 	bltu	r2,r4,d00af4c <__udivdi3+0x5a0>
 d00aacc:	b004943a 	slli	r2,r22,16
 d00aad0:	d9000317 	ldw	r4,12(sp)
 d00aad4:	a084b03a 	or	r2,r20,r2
 d00aad8:	00001506 	br	d00ab30 <__udivdi3+0x184>
 d00aadc:	380d883a 	mov	r6,r7
 d00aae0:	29c06236 	bltu	r5,r7,d00ac6c <__udivdi3+0x2c0>
 d00aae4:	00bfffd4 	movui	r2,65535
 d00aae8:	11c05a36 	bltu	r2,r7,d00ac54 <__udivdi3+0x2a8>
 d00aaec:	00803fc4 	movi	r2,255
 d00aaf0:	11c0fc36 	bltu	r2,r7,d00aee4 <__udivdi3+0x538>
 d00aaf4:	000b883a 	mov	r5,zero
 d00aaf8:	0005883a 	mov	r2,zero
 d00aafc:	3084d83a 	srl	r2,r6,r2
 d00ab00:	01034174 	movhi	r4,3333
 d00ab04:	21316e04 	addi	r4,r4,-14920
 d00ab08:	01c00804 	movi	r7,32
 d00ab0c:	1105883a 	add	r2,r2,r4
 d00ab10:	10c00003 	ldbu	r3,0(r2)
 d00ab14:	28c7883a 	add	r3,r5,r3
 d00ab18:	38efc83a 	sub	r23,r7,r3
 d00ab1c:	b800691e 	bne	r23,zero,d00acc4 <__udivdi3+0x318>
 d00ab20:	35000136 	bltu	r6,r20,d00ab28 <__udivdi3+0x17c>
 d00ab24:	e4005136 	bltu	fp,r16,d00ac6c <__udivdi3+0x2c0>
 d00ab28:	00800044 	movi	r2,1
 d00ab2c:	0009883a 	mov	r4,zero
 d00ab30:	2007883a 	mov	r3,r4
 d00ab34:	dfc00f17 	ldw	ra,60(sp)
 d00ab38:	df000e17 	ldw	fp,56(sp)
 d00ab3c:	ddc00d17 	ldw	r23,52(sp)
 d00ab40:	dd800c17 	ldw	r22,48(sp)
 d00ab44:	dd400b17 	ldw	r21,44(sp)
 d00ab48:	dd000a17 	ldw	r20,40(sp)
 d00ab4c:	dcc00917 	ldw	r19,36(sp)
 d00ab50:	dc800817 	ldw	r18,32(sp)
 d00ab54:	dc400717 	ldw	r17,28(sp)
 d00ab58:	dc000617 	ldw	r16,24(sp)
 d00ab5c:	dec01004 	addi	sp,sp,64
 d00ab60:	f800283a 	ret
 d00ab64:	00bfffd4 	movui	r2,65535
 d00ab68:	12005036 	bltu	r2,r8,d00acac <__udivdi3+0x300>
 d00ab6c:	00803fc4 	movi	r2,255
 d00ab70:	1200e836 	bltu	r2,r8,d00af14 <__udivdi3+0x568>
 d00ab74:	000b883a 	mov	r5,zero
 d00ab78:	0005883a 	mov	r2,zero
 d00ab7c:	8084d83a 	srl	r2,r16,r2
 d00ab80:	01034174 	movhi	r4,3333
 d00ab84:	21316e04 	addi	r4,r4,-14920
 d00ab88:	01800804 	movi	r6,32
 d00ab8c:	1105883a 	add	r2,r2,r4
 d00ab90:	10c00003 	ldbu	r3,0(r2)
 d00ab94:	28c7883a 	add	r3,r5,r3
 d00ab98:	30cbc83a 	sub	r5,r6,r3
 d00ab9c:	28000626 	beq	r5,zero,d00abb8 <__udivdi3+0x20c>
 d00aba0:	3145c83a 	sub	r2,r6,r5
 d00aba4:	e084d83a 	srl	r2,fp,r2
 d00aba8:	a146983a 	sll	r3,r20,r5
 d00abac:	e178983a 	sll	fp,fp,r5
 d00abb0:	8160983a 	sll	r16,r16,r5
 d00abb4:	18a8b03a 	or	r20,r3,r2
 d00abb8:	802ad43a 	srli	r21,r16,16
 d00abbc:	a009883a 	mov	r4,r20
 d00abc0:	85ffffcc 	andi	r23,r16,65535
 d00abc4:	a80b883a 	mov	r5,r21
 d00abc8:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00abcc:	a009883a 	mov	r4,r20
 d00abd0:	a80b883a 	mov	r5,r21
 d00abd4:	102d883a 	mov	r22,r2
 d00abd8:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00abdc:	1004943a 	slli	r2,r2,16
 d00abe0:	e006d43a 	srli	r3,fp,16
 d00abe4:	bda3383a 	mul	r17,r23,r22
 d00abe8:	10c4b03a 	or	r2,r2,r3
 d00abec:	1440042e 	bgeu	r2,r17,d00ac00 <__udivdi3+0x254>
 d00abf0:	1405883a 	add	r2,r2,r16
 d00abf4:	b5bfffc4 	addi	r22,r22,-1
 d00abf8:	14000136 	bltu	r2,r16,d00ac00 <__udivdi3+0x254>
 d00abfc:	1440d536 	bltu	r2,r17,d00af54 <__udivdi3+0x5a8>
 d00ac00:	1463c83a 	sub	r17,r2,r17
 d00ac04:	8809883a 	mov	r4,r17
 d00ac08:	a80b883a 	mov	r5,r21
 d00ac0c:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00ac10:	8809883a 	mov	r4,r17
 d00ac14:	a80b883a 	mov	r5,r21
 d00ac18:	1029883a 	mov	r20,r2
 d00ac1c:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00ac20:	1004943a 	slli	r2,r2,16
 d00ac24:	bd09383a 	mul	r4,r23,r20
 d00ac28:	e0ffffcc 	andi	r3,fp,65535
 d00ac2c:	10c4b03a 	or	r2,r2,r3
 d00ac30:	1100042e 	bgeu	r2,r4,d00ac44 <__udivdi3+0x298>
 d00ac34:	8085883a 	add	r2,r16,r2
 d00ac38:	a53fffc4 	addi	r20,r20,-1
 d00ac3c:	14000136 	bltu	r2,r16,d00ac44 <__udivdi3+0x298>
 d00ac40:	1100c736 	bltu	r2,r4,d00af60 <__udivdi3+0x5b4>
 d00ac44:	b004943a 	slli	r2,r22,16
 d00ac48:	0009883a 	mov	r4,zero
 d00ac4c:	a084b03a 	or	r2,r20,r2
 d00ac50:	003fb706 	br	d00ab30 <__udivdi3+0x184>
 d00ac54:	00804034 	movhi	r2,256
 d00ac58:	10bfffc4 	addi	r2,r2,-1
 d00ac5c:	11c0a436 	bltu	r2,r7,d00aef0 <__udivdi3+0x544>
 d00ac60:	01400404 	movi	r5,16
 d00ac64:	2805883a 	mov	r2,r5
 d00ac68:	003fa406 	br	d00aafc <__udivdi3+0x150>
 d00ac6c:	0005883a 	mov	r2,zero
 d00ac70:	0009883a 	mov	r4,zero
 d00ac74:	003fae06 	br	d00ab30 <__udivdi3+0x184>
 d00ac78:	00804034 	movhi	r2,256
 d00ac7c:	10bfffc4 	addi	r2,r2,-1
 d00ac80:	1400a136 	bltu	r2,r16,d00af08 <__udivdi3+0x55c>
 d00ac84:	01400404 	movi	r5,16
 d00ac88:	2805883a 	mov	r2,r5
 d00ac8c:	003f6006 	br	d00aa10 <__udivdi3+0x64>
 d00ac90:	01000044 	movi	r4,1
 d00ac94:	000b883a 	mov	r5,zero
 d00ac98:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00ac9c:	1021883a 	mov	r16,r2
 d00aca0:	00bfffd4 	movui	r2,65535
 d00aca4:	143ff436 	bltu	r2,r16,d00ac78 <__udivdi3+0x2cc>
 d00aca8:	003f5506 	br	d00aa00 <__udivdi3+0x54>
 d00acac:	00804034 	movhi	r2,256
 d00acb0:	10bfffc4 	addi	r2,r2,-1
 d00acb4:	12009a36 	bltu	r2,r8,d00af20 <__udivdi3+0x574>
 d00acb8:	01400404 	movi	r5,16
 d00acbc:	2805883a 	mov	r2,r5
 d00acc0:	003fae06 	br	d00ab7c <__udivdi3+0x1d0>
 d00acc4:	3dc5c83a 	sub	r2,r7,r23
 d00acc8:	35c8983a 	sll	r4,r6,r23
 d00accc:	8086d83a 	srl	r3,r16,r2
 d00acd0:	a0a2d83a 	srl	r17,r20,r2
 d00acd4:	e084d83a 	srl	r2,fp,r2
 d00acd8:	20eab03a 	or	r21,r4,r3
 d00acdc:	a82cd43a 	srli	r22,r21,16
 d00ace0:	a5c6983a 	sll	r3,r20,r23
 d00ace4:	8809883a 	mov	r4,r17
 d00ace8:	b00b883a 	mov	r5,r22
 d00acec:	1886b03a 	or	r3,r3,r2
 d00acf0:	d8c00215 	stw	r3,8(sp)
 d00acf4:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00acf8:	8809883a 	mov	r4,r17
 d00acfc:	b00b883a 	mov	r5,r22
 d00ad00:	1029883a 	mov	r20,r2
 d00ad04:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00ad08:	a8ffffcc 	andi	r3,r21,65535
 d00ad0c:	d8c00515 	stw	r3,20(sp)
 d00ad10:	d9000217 	ldw	r4,8(sp)
 d00ad14:	d9400517 	ldw	r5,20(sp)
 d00ad18:	1004943a 	slli	r2,r2,16
 d00ad1c:	2006d43a 	srli	r3,r4,16
 d00ad20:	85e0983a 	sll	r16,r16,r23
 d00ad24:	2d23383a 	mul	r17,r5,r20
 d00ad28:	10c4b03a 	or	r2,r2,r3
 d00ad2c:	dc000015 	stw	r16,0(sp)
 d00ad30:	1440032e 	bgeu	r2,r17,d00ad40 <__udivdi3+0x394>
 d00ad34:	1545883a 	add	r2,r2,r21
 d00ad38:	a53fffc4 	addi	r20,r20,-1
 d00ad3c:	15407f2e 	bgeu	r2,r21,d00af3c <__udivdi3+0x590>
 d00ad40:	1463c83a 	sub	r17,r2,r17
 d00ad44:	8809883a 	mov	r4,r17
 d00ad48:	b00b883a 	mov	r5,r22
 d00ad4c:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00ad50:	8809883a 	mov	r4,r17
 d00ad54:	b00b883a 	mov	r5,r22
 d00ad58:	1021883a 	mov	r16,r2
 d00ad5c:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00ad60:	d8c00517 	ldw	r3,20(sp)
 d00ad64:	d9000217 	ldw	r4,8(sp)
 d00ad68:	1004943a 	slli	r2,r2,16
 d00ad6c:	1c0f383a 	mul	r7,r3,r16
 d00ad70:	20ffffcc 	andi	r3,r4,65535
 d00ad74:	10e2b03a 	or	r17,r2,r3
 d00ad78:	89c0032e 	bgeu	r17,r7,d00ad88 <__udivdi3+0x3dc>
 d00ad7c:	8d63883a 	add	r17,r17,r21
 d00ad80:	843fffc4 	addi	r16,r16,-1
 d00ad84:	8d40692e 	bgeu	r17,r21,d00af2c <__udivdi3+0x580>
 d00ad88:	a008943a 	slli	r4,r20,16
 d00ad8c:	d9400017 	ldw	r5,0(sp)
 d00ad90:	89e3c83a 	sub	r17,r17,r7
 d00ad94:	8110b03a 	or	r8,r16,r4
 d00ad98:	280cd43a 	srli	r6,r5,16
 d00ad9c:	28ffffcc 	andi	r3,r5,65535
 d00ada0:	40bfffcc 	andi	r2,r8,65535
 d00ada4:	400ad43a 	srli	r5,r8,16
 d00ada8:	10d3383a 	mul	r9,r2,r3
 d00adac:	1185383a 	mul	r2,r2,r6
 d00adb0:	28c7383a 	mul	r3,r5,r3
 d00adb4:	4808d43a 	srli	r4,r9,16
 d00adb8:	298b383a 	mul	r5,r5,r6
 d00adbc:	10c5883a 	add	r2,r2,r3
 d00adc0:	2089883a 	add	r4,r4,r2
 d00adc4:	20c0022e 	bgeu	r4,r3,d00add0 <__udivdi3+0x424>
 d00adc8:	00800074 	movhi	r2,1
 d00adcc:	288b883a 	add	r5,r5,r2
 d00add0:	2004d43a 	srli	r2,r4,16
 d00add4:	288b883a 	add	r5,r5,r2
 d00add8:	89403f36 	bltu	r17,r5,d00aed8 <__udivdi3+0x52c>
 d00addc:	89403926 	beq	r17,r5,d00aec4 <__udivdi3+0x518>
 d00ade0:	4005883a 	mov	r2,r8
 d00ade4:	0009883a 	mov	r4,zero
 d00ade8:	003f5106 	br	d00ab30 <__udivdi3+0x184>
 d00adec:	85a0983a 	sll	r16,r16,r22
 d00adf0:	3585c83a 	sub	r2,r6,r22
 d00adf4:	a0a2d83a 	srl	r17,r20,r2
 d00adf8:	802ad43a 	srli	r21,r16,16
 d00adfc:	e084d83a 	srl	r2,fp,r2
 d00ae00:	a586983a 	sll	r3,r20,r22
 d00ae04:	8809883a 	mov	r4,r17
 d00ae08:	a80b883a 	mov	r5,r21
 d00ae0c:	1886b03a 	or	r3,r3,r2
 d00ae10:	d8c00115 	stw	r3,4(sp)
 d00ae14:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00ae18:	8809883a 	mov	r4,r17
 d00ae1c:	a80b883a 	mov	r5,r21
 d00ae20:	d8800415 	stw	r2,16(sp)
 d00ae24:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00ae28:	d9000117 	ldw	r4,4(sp)
 d00ae2c:	d9400417 	ldw	r5,16(sp)
 d00ae30:	1004943a 	slli	r2,r2,16
 d00ae34:	85ffffcc 	andi	r23,r16,65535
 d00ae38:	2006d43a 	srli	r3,r4,16
 d00ae3c:	b963383a 	mul	r17,r23,r5
 d00ae40:	10c4b03a 	or	r2,r2,r3
 d00ae44:	1440042e 	bgeu	r2,r17,d00ae58 <__udivdi3+0x4ac>
 d00ae48:	297fffc4 	addi	r5,r5,-1
 d00ae4c:	1405883a 	add	r2,r2,r16
 d00ae50:	d9400415 	stw	r5,16(sp)
 d00ae54:	1400442e 	bgeu	r2,r16,d00af68 <__udivdi3+0x5bc>
 d00ae58:	1463c83a 	sub	r17,r2,r17
 d00ae5c:	8809883a 	mov	r4,r17
 d00ae60:	a80b883a 	mov	r5,r21
 d00ae64:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00ae68:	8809883a 	mov	r4,r17
 d00ae6c:	a80b883a 	mov	r5,r21
 d00ae70:	1029883a 	mov	r20,r2
 d00ae74:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00ae78:	d9400117 	ldw	r5,4(sp)
 d00ae7c:	1004943a 	slli	r2,r2,16
 d00ae80:	bd09383a 	mul	r4,r23,r20
 d00ae84:	28ffffcc 	andi	r3,r5,65535
 d00ae88:	10c6b03a 	or	r3,r2,r3
 d00ae8c:	1900062e 	bgeu	r3,r4,d00aea8 <__udivdi3+0x4fc>
 d00ae90:	1c07883a 	add	r3,r3,r16
 d00ae94:	a53fffc4 	addi	r20,r20,-1
 d00ae98:	1c000336 	bltu	r3,r16,d00aea8 <__udivdi3+0x4fc>
 d00ae9c:	1900022e 	bgeu	r3,r4,d00aea8 <__udivdi3+0x4fc>
 d00aea0:	a53fffc4 	addi	r20,r20,-1
 d00aea4:	1c07883a 	add	r3,r3,r16
 d00aea8:	d9400417 	ldw	r5,16(sp)
 d00aeac:	e5b8983a 	sll	fp,fp,r22
 d00aeb0:	1923c83a 	sub	r17,r3,r4
 d00aeb4:	2804943a 	slli	r2,r5,16
 d00aeb8:	a0a8b03a 	or	r20,r20,r2
 d00aebc:	dd000315 	stw	r20,12(sp)
 d00aec0:	003ee106 	br	d00aa48 <__udivdi3+0x9c>
 d00aec4:	2004943a 	slli	r2,r4,16
 d00aec8:	e5c8983a 	sll	r4,fp,r23
 d00aecc:	48ffffcc 	andi	r3,r9,65535
 d00aed0:	10c5883a 	add	r2,r2,r3
 d00aed4:	20bfc22e 	bgeu	r4,r2,d00ade0 <__udivdi3+0x434>
 d00aed8:	40bfffc4 	addi	r2,r8,-1
 d00aedc:	0009883a 	mov	r4,zero
 d00aee0:	003f1306 	br	d00ab30 <__udivdi3+0x184>
 d00aee4:	01400204 	movi	r5,8
 d00aee8:	2805883a 	mov	r2,r5
 d00aeec:	003f0306 	br	d00aafc <__udivdi3+0x150>
 d00aef0:	01400604 	movi	r5,24
 d00aef4:	2805883a 	mov	r2,r5
 d00aef8:	003f0006 	br	d00aafc <__udivdi3+0x150>
 d00aefc:	01400204 	movi	r5,8
 d00af00:	2805883a 	mov	r2,r5
 d00af04:	003ec206 	br	d00aa10 <__udivdi3+0x64>
 d00af08:	01400604 	movi	r5,24
 d00af0c:	2805883a 	mov	r2,r5
 d00af10:	003ebf06 	br	d00aa10 <__udivdi3+0x64>
 d00af14:	01400204 	movi	r5,8
 d00af18:	2805883a 	mov	r2,r5
 d00af1c:	003f1706 	br	d00ab7c <__udivdi3+0x1d0>
 d00af20:	01400604 	movi	r5,24
 d00af24:	2805883a 	mov	r2,r5
 d00af28:	003f1406 	br	d00ab7c <__udivdi3+0x1d0>
 d00af2c:	89ff962e 	bgeu	r17,r7,d00ad88 <__udivdi3+0x3dc>
 d00af30:	8d63883a 	add	r17,r17,r21
 d00af34:	843fffc4 	addi	r16,r16,-1
 d00af38:	003f9306 	br	d00ad88 <__udivdi3+0x3dc>
 d00af3c:	147f802e 	bgeu	r2,r17,d00ad40 <__udivdi3+0x394>
 d00af40:	a53fffc4 	addi	r20,r20,-1
 d00af44:	1545883a 	add	r2,r2,r21
 d00af48:	003f7d06 	br	d00ad40 <__udivdi3+0x394>
 d00af4c:	a53fffc4 	addi	r20,r20,-1
 d00af50:	003ede06 	br	d00aacc <__udivdi3+0x120>
 d00af54:	b5bfffc4 	addi	r22,r22,-1
 d00af58:	1405883a 	add	r2,r2,r16
 d00af5c:	003f2806 	br	d00ac00 <__udivdi3+0x254>
 d00af60:	a53fffc4 	addi	r20,r20,-1
 d00af64:	003f3706 	br	d00ac44 <__udivdi3+0x298>
 d00af68:	147fbb2e 	bgeu	r2,r17,d00ae58 <__udivdi3+0x4ac>
 d00af6c:	297fffc4 	addi	r5,r5,-1
 d00af70:	1405883a 	add	r2,r2,r16
 d00af74:	d9400415 	stw	r5,16(sp)
 d00af78:	003fb706 	br	d00ae58 <__udivdi3+0x4ac>
 d00af7c:	b5bfffc4 	addi	r22,r22,-1
 d00af80:	1405883a 	add	r2,r2,r16
 d00af84:	003ec006 	br	d00aa88 <__udivdi3+0xdc>

0d00af88 <__umoddi3>:
 d00af88:	defff104 	addi	sp,sp,-60
 d00af8c:	dd800b15 	stw	r22,44(sp)
 d00af90:	dd000915 	stw	r20,36(sp)
 d00af94:	dc000515 	stw	r16,20(sp)
 d00af98:	dfc00e15 	stw	ra,56(sp)
 d00af9c:	df000d15 	stw	fp,52(sp)
 d00afa0:	ddc00c15 	stw	r23,48(sp)
 d00afa4:	dd400a15 	stw	r21,40(sp)
 d00afa8:	dcc00815 	stw	r19,32(sp)
 d00afac:	dc800715 	stw	r18,28(sp)
 d00afb0:	dc400615 	stw	r17,24(sp)
 d00afb4:	3021883a 	mov	r16,r6
 d00afb8:	202d883a 	mov	r22,r4
 d00afbc:	2829883a 	mov	r20,r5
 d00afc0:	38002b1e 	bne	r7,zero,d00b070 <__umoddi3+0xe8>
 d00afc4:	29805036 	bltu	r5,r6,d00b108 <__umoddi3+0x180>
 d00afc8:	30008a26 	beq	r6,zero,d00b1f4 <__umoddi3+0x26c>
 d00afcc:	00bfffd4 	movui	r2,65535
 d00afd0:	14008236 	bltu	r2,r16,d00b1dc <__umoddi3+0x254>
 d00afd4:	00803fc4 	movi	r2,255
 d00afd8:	14013636 	bltu	r2,r16,d00b4b4 <__umoddi3+0x52c>
 d00afdc:	000b883a 	mov	r5,zero
 d00afe0:	0005883a 	mov	r2,zero
 d00afe4:	8084d83a 	srl	r2,r16,r2
 d00afe8:	01034174 	movhi	r4,3333
 d00afec:	21316e04 	addi	r4,r4,-14920
 d00aff0:	01800804 	movi	r6,32
 d00aff4:	1105883a 	add	r2,r2,r4
 d00aff8:	10c00003 	ldbu	r3,0(r2)
 d00affc:	28c7883a 	add	r3,r5,r3
 d00b000:	30efc83a 	sub	r23,r6,r3
 d00b004:	b800941e 	bne	r23,zero,d00b258 <__umoddi3+0x2d0>
 d00b008:	802ad43a 	srli	r21,r16,16
 d00b00c:	a423c83a 	sub	r17,r20,r16
 d00b010:	0039883a 	mov	fp,zero
 d00b014:	853fffcc 	andi	r20,r16,65535
 d00b018:	8809883a 	mov	r4,r17
 d00b01c:	a80b883a 	mov	r5,r21
 d00b020:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00b024:	8809883a 	mov	r4,r17
 d00b028:	a80b883a 	mov	r5,r21
 d00b02c:	a0a3383a 	mul	r17,r20,r2
 d00b030:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00b034:	1004943a 	slli	r2,r2,16
 d00b038:	b006d43a 	srli	r3,r22,16
 d00b03c:	10c4b03a 	or	r2,r2,r3
 d00b040:	1440032e 	bgeu	r2,r17,d00b050 <__umoddi3+0xc8>
 d00b044:	1405883a 	add	r2,r2,r16
 d00b048:	14000136 	bltu	r2,r16,d00b050 <__umoddi3+0xc8>
 d00b04c:	14413536 	bltu	r2,r17,d00b524 <__umoddi3+0x59c>
 d00b050:	1463c83a 	sub	r17,r2,r17
 d00b054:	8809883a 	mov	r4,r17
 d00b058:	a80b883a 	mov	r5,r21
 d00b05c:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00b060:	8809883a 	mov	r4,r17
 d00b064:	a0a3383a 	mul	r17,r20,r2
 d00b068:	a80b883a 	mov	r5,r21
 d00b06c:	00004d06 	br	d00b1a4 <__umoddi3+0x21c>
 d00b070:	380d883a 	mov	r6,r7
 d00b074:	29c0102e 	bgeu	r5,r7,d00b0b8 <__umoddi3+0x130>
 d00b078:	2011883a 	mov	r8,r4
 d00b07c:	2813883a 	mov	r9,r5
 d00b080:	4005883a 	mov	r2,r8
 d00b084:	4807883a 	mov	r3,r9
 d00b088:	dfc00e17 	ldw	ra,56(sp)
 d00b08c:	df000d17 	ldw	fp,52(sp)
 d00b090:	ddc00c17 	ldw	r23,48(sp)
 d00b094:	dd800b17 	ldw	r22,44(sp)
 d00b098:	dd400a17 	ldw	r21,40(sp)
 d00b09c:	dd000917 	ldw	r20,36(sp)
 d00b0a0:	dcc00817 	ldw	r19,32(sp)
 d00b0a4:	dc800717 	ldw	r18,28(sp)
 d00b0a8:	dc400617 	ldw	r17,24(sp)
 d00b0ac:	dc000517 	ldw	r16,20(sp)
 d00b0b0:	dec00f04 	addi	sp,sp,60
 d00b0b4:	f800283a 	ret
 d00b0b8:	00bfffd4 	movui	r2,65535
 d00b0bc:	11c05a36 	bltu	r2,r7,d00b228 <__umoddi3+0x2a0>
 d00b0c0:	00803fc4 	movi	r2,255
 d00b0c4:	11c0fe36 	bltu	r2,r7,d00b4c0 <__umoddi3+0x538>
 d00b0c8:	000b883a 	mov	r5,zero
 d00b0cc:	0005883a 	mov	r2,zero
 d00b0d0:	3084d83a 	srl	r2,r6,r2
 d00b0d4:	01034174 	movhi	r4,3333
 d00b0d8:	21316e04 	addi	r4,r4,-14920
 d00b0dc:	01c00804 	movi	r7,32
 d00b0e0:	1105883a 	add	r2,r2,r4
 d00b0e4:	10c00003 	ldbu	r3,0(r2)
 d00b0e8:	28c7883a 	add	r3,r5,r3
 d00b0ec:	38ebc83a 	sub	r21,r7,r3
 d00b0f0:	a800851e 	bne	r21,zero,d00b308 <__umoddi3+0x380>
 d00b0f4:	35005236 	bltu	r6,r20,d00b240 <__umoddi3+0x2b8>
 d00b0f8:	b400512e 	bgeu	r22,r16,d00b240 <__umoddi3+0x2b8>
 d00b0fc:	b011883a 	mov	r8,r22
 d00b100:	a013883a 	mov	r9,r20
 d00b104:	003fde06 	br	d00b080 <__umoddi3+0xf8>
 d00b108:	00bfffd4 	movui	r2,65535
 d00b10c:	11804036 	bltu	r2,r6,d00b210 <__umoddi3+0x288>
 d00b110:	00803fc4 	movi	r2,255
 d00b114:	1180ed36 	bltu	r2,r6,d00b4cc <__umoddi3+0x544>
 d00b118:	000b883a 	mov	r5,zero
 d00b11c:	0005883a 	mov	r2,zero
 d00b120:	8084d83a 	srl	r2,r16,r2
 d00b124:	01034174 	movhi	r4,3333
 d00b128:	21316e04 	addi	r4,r4,-14920
 d00b12c:	01800804 	movi	r6,32
 d00b130:	1105883a 	add	r2,r2,r4
 d00b134:	10c00003 	ldbu	r3,0(r2)
 d00b138:	28c7883a 	add	r3,r5,r3
 d00b13c:	30c7c83a 	sub	r3,r6,r3
 d00b140:	1800bf1e 	bne	r3,zero,d00b440 <__umoddi3+0x4b8>
 d00b144:	0039883a 	mov	fp,zero
 d00b148:	802ad43a 	srli	r21,r16,16
 d00b14c:	a009883a 	mov	r4,r20
 d00b150:	85ffffcc 	andi	r23,r16,65535
 d00b154:	a80b883a 	mov	r5,r21
 d00b158:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00b15c:	a009883a 	mov	r4,r20
 d00b160:	a80b883a 	mov	r5,r21
 d00b164:	b8a3383a 	mul	r17,r23,r2
 d00b168:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00b16c:	1004943a 	slli	r2,r2,16
 d00b170:	b006d43a 	srli	r3,r22,16
 d00b174:	10c4b03a 	or	r2,r2,r3
 d00b178:	1440032e 	bgeu	r2,r17,d00b188 <__umoddi3+0x200>
 d00b17c:	1405883a 	add	r2,r2,r16
 d00b180:	14000136 	bltu	r2,r16,d00b188 <__umoddi3+0x200>
 d00b184:	1440e536 	bltu	r2,r17,d00b51c <__umoddi3+0x594>
 d00b188:	1463c83a 	sub	r17,r2,r17
 d00b18c:	8809883a 	mov	r4,r17
 d00b190:	a80b883a 	mov	r5,r21
 d00b194:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00b198:	8809883a 	mov	r4,r17
 d00b19c:	b8a3383a 	mul	r17,r23,r2
 d00b1a0:	a80b883a 	mov	r5,r21
 d00b1a4:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00b1a8:	1004943a 	slli	r2,r2,16
 d00b1ac:	b0ffffcc 	andi	r3,r22,65535
 d00b1b0:	10c4b03a 	or	r2,r2,r3
 d00b1b4:	1440042e 	bgeu	r2,r17,d00b1c8 <__umoddi3+0x240>
 d00b1b8:	1405883a 	add	r2,r2,r16
 d00b1bc:	14000236 	bltu	r2,r16,d00b1c8 <__umoddi3+0x240>
 d00b1c0:	1440012e 	bgeu	r2,r17,d00b1c8 <__umoddi3+0x240>
 d00b1c4:	1405883a 	add	r2,r2,r16
 d00b1c8:	1445c83a 	sub	r2,r2,r17
 d00b1cc:	1724d83a 	srl	r18,r2,fp
 d00b1d0:	0013883a 	mov	r9,zero
 d00b1d4:	9011883a 	mov	r8,r18
 d00b1d8:	003fa906 	br	d00b080 <__umoddi3+0xf8>
 d00b1dc:	00804034 	movhi	r2,256
 d00b1e0:	10bfffc4 	addi	r2,r2,-1
 d00b1e4:	1400b036 	bltu	r2,r16,d00b4a8 <__umoddi3+0x520>
 d00b1e8:	01400404 	movi	r5,16
 d00b1ec:	2805883a 	mov	r2,r5
 d00b1f0:	003f7c06 	br	d00afe4 <__umoddi3+0x5c>
 d00b1f4:	01000044 	movi	r4,1
 d00b1f8:	000b883a 	mov	r5,zero
 d00b1fc:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00b200:	1021883a 	mov	r16,r2
 d00b204:	00bfffd4 	movui	r2,65535
 d00b208:	143ff436 	bltu	r2,r16,d00b1dc <__umoddi3+0x254>
 d00b20c:	003f7106 	br	d00afd4 <__umoddi3+0x4c>
 d00b210:	00804034 	movhi	r2,256
 d00b214:	10bfffc4 	addi	r2,r2,-1
 d00b218:	1180af36 	bltu	r2,r6,d00b4d8 <__umoddi3+0x550>
 d00b21c:	01400404 	movi	r5,16
 d00b220:	2805883a 	mov	r2,r5
 d00b224:	003fbe06 	br	d00b120 <__umoddi3+0x198>
 d00b228:	00804034 	movhi	r2,256
 d00b22c:	10bfffc4 	addi	r2,r2,-1
 d00b230:	11c0ac36 	bltu	r2,r7,d00b4e4 <__umoddi3+0x55c>
 d00b234:	01400404 	movi	r5,16
 d00b238:	2805883a 	mov	r2,r5
 d00b23c:	003fa406 	br	d00b0d0 <__umoddi3+0x148>
 d00b240:	b409c83a 	sub	r4,r22,r16
 d00b244:	b105803a 	cmpltu	r2,r22,r4
 d00b248:	a187c83a 	sub	r3,r20,r6
 d00b24c:	18a9c83a 	sub	r20,r3,r2
 d00b250:	202d883a 	mov	r22,r4
 d00b254:	003fa906 	br	d00b0fc <__umoddi3+0x174>
 d00b258:	85e0983a 	sll	r16,r16,r23
 d00b25c:	35c5c83a 	sub	r2,r6,r23
 d00b260:	a0a2d83a 	srl	r17,r20,r2
 d00b264:	802ad43a 	srli	r21,r16,16
 d00b268:	b084d83a 	srl	r2,r22,r2
 d00b26c:	a5c6983a 	sll	r3,r20,r23
 d00b270:	8809883a 	mov	r4,r17
 d00b274:	a80b883a 	mov	r5,r21
 d00b278:	1886b03a 	or	r3,r3,r2
 d00b27c:	d8c00115 	stw	r3,4(sp)
 d00b280:	853fffcc 	andi	r20,r16,65535
 d00b284:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00b288:	8809883a 	mov	r4,r17
 d00b28c:	a80b883a 	mov	r5,r21
 d00b290:	a0a3383a 	mul	r17,r20,r2
 d00b294:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00b298:	d9000117 	ldw	r4,4(sp)
 d00b29c:	1004943a 	slli	r2,r2,16
 d00b2a0:	b839883a 	mov	fp,r23
 d00b2a4:	2006d43a 	srli	r3,r4,16
 d00b2a8:	10c4b03a 	or	r2,r2,r3
 d00b2ac:	1440022e 	bgeu	r2,r17,d00b2b8 <__umoddi3+0x330>
 d00b2b0:	1405883a 	add	r2,r2,r16
 d00b2b4:	1400962e 	bgeu	r2,r16,d00b510 <__umoddi3+0x588>
 d00b2b8:	1463c83a 	sub	r17,r2,r17
 d00b2bc:	8809883a 	mov	r4,r17
 d00b2c0:	a80b883a 	mov	r5,r21
 d00b2c4:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00b2c8:	8809883a 	mov	r4,r17
 d00b2cc:	a80b883a 	mov	r5,r21
 d00b2d0:	a0a3383a 	mul	r17,r20,r2
 d00b2d4:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00b2d8:	d9400117 	ldw	r5,4(sp)
 d00b2dc:	1004943a 	slli	r2,r2,16
 d00b2e0:	28ffffcc 	andi	r3,r5,65535
 d00b2e4:	10c4b03a 	or	r2,r2,r3
 d00b2e8:	1440042e 	bgeu	r2,r17,d00b2fc <__umoddi3+0x374>
 d00b2ec:	1405883a 	add	r2,r2,r16
 d00b2f0:	14000236 	bltu	r2,r16,d00b2fc <__umoddi3+0x374>
 d00b2f4:	1440012e 	bgeu	r2,r17,d00b2fc <__umoddi3+0x374>
 d00b2f8:	1405883a 	add	r2,r2,r16
 d00b2fc:	b5ec983a 	sll	r22,r22,r23
 d00b300:	1463c83a 	sub	r17,r2,r17
 d00b304:	003f4406 	br	d00b018 <__umoddi3+0x90>
 d00b308:	3d4fc83a 	sub	r7,r7,r21
 d00b30c:	3546983a 	sll	r3,r6,r21
 d00b310:	81c4d83a 	srl	r2,r16,r7
 d00b314:	a1e2d83a 	srl	r17,r20,r7
 d00b318:	a54c983a 	sll	r6,r20,r21
 d00b31c:	18aeb03a 	or	r23,r3,r2
 d00b320:	b828d43a 	srli	r20,r23,16
 d00b324:	b1c4d83a 	srl	r2,r22,r7
 d00b328:	8809883a 	mov	r4,r17
 d00b32c:	a00b883a 	mov	r5,r20
 d00b330:	308cb03a 	or	r6,r6,r2
 d00b334:	d9c00315 	stw	r7,12(sp)
 d00b338:	d9800215 	stw	r6,8(sp)
 d00b33c:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00b340:	8809883a 	mov	r4,r17
 d00b344:	a00b883a 	mov	r5,r20
 d00b348:	1039883a 	mov	fp,r2
 d00b34c:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00b350:	b8ffffcc 	andi	r3,r23,65535
 d00b354:	d8c00415 	stw	r3,16(sp)
 d00b358:	d9000217 	ldw	r4,8(sp)
 d00b35c:	d9400417 	ldw	r5,16(sp)
 d00b360:	1004943a 	slli	r2,r2,16
 d00b364:	2006d43a 	srli	r3,r4,16
 d00b368:	8560983a 	sll	r16,r16,r21
 d00b36c:	2f23383a 	mul	r17,r5,fp
 d00b370:	10c4b03a 	or	r2,r2,r3
 d00b374:	dc000015 	stw	r16,0(sp)
 d00b378:	b56c983a 	sll	r22,r22,r21
 d00b37c:	1440032e 	bgeu	r2,r17,d00b38c <__umoddi3+0x404>
 d00b380:	15c5883a 	add	r2,r2,r23
 d00b384:	e73fffc4 	addi	fp,fp,-1
 d00b388:	15c05d2e 	bgeu	r2,r23,d00b500 <__umoddi3+0x578>
 d00b38c:	1463c83a 	sub	r17,r2,r17
 d00b390:	8809883a 	mov	r4,r17
 d00b394:	a00b883a 	mov	r5,r20
 d00b398:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d00b39c:	8809883a 	mov	r4,r17
 d00b3a0:	a00b883a 	mov	r5,r20
 d00b3a4:	1021883a 	mov	r16,r2
 d00b3a8:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d00b3ac:	d8c00417 	ldw	r3,16(sp)
 d00b3b0:	d9000217 	ldw	r4,8(sp)
 d00b3b4:	1004943a 	slli	r2,r2,16
 d00b3b8:	1c23383a 	mul	r17,r3,r16
 d00b3bc:	20ffffcc 	andi	r3,r4,65535
 d00b3c0:	10ceb03a 	or	r7,r2,r3
 d00b3c4:	3c40032e 	bgeu	r7,r17,d00b3d4 <__umoddi3+0x44c>
 d00b3c8:	3dcf883a 	add	r7,r7,r23
 d00b3cc:	843fffc4 	addi	r16,r16,-1
 d00b3d0:	3dc0472e 	bgeu	r7,r23,d00b4f0 <__umoddi3+0x568>
 d00b3d4:	e004943a 	slli	r2,fp,16
 d00b3d8:	d9400017 	ldw	r5,0(sp)
 d00b3dc:	3c4fc83a 	sub	r7,r7,r17
 d00b3e0:	8084b03a 	or	r2,r16,r2
 d00b3e4:	28ffffcc 	andi	r3,r5,65535
 d00b3e8:	280cd43a 	srli	r6,r5,16
 d00b3ec:	100ad43a 	srli	r5,r2,16
 d00b3f0:	10bfffcc 	andi	r2,r2,65535
 d00b3f4:	10d1383a 	mul	r8,r2,r3
 d00b3f8:	28c7383a 	mul	r3,r5,r3
 d00b3fc:	1185383a 	mul	r2,r2,r6
 d00b400:	4008d43a 	srli	r4,r8,16
 d00b404:	298b383a 	mul	r5,r5,r6
 d00b408:	10c5883a 	add	r2,r2,r3
 d00b40c:	2089883a 	add	r4,r4,r2
 d00b410:	20c0022e 	bgeu	r4,r3,d00b41c <__umoddi3+0x494>
 d00b414:	00800074 	movhi	r2,1
 d00b418:	288b883a 	add	r5,r5,r2
 d00b41c:	2004d43a 	srli	r2,r4,16
 d00b420:	2008943a 	slli	r4,r4,16
 d00b424:	40ffffcc 	andi	r3,r8,65535
 d00b428:	288b883a 	add	r5,r5,r2
 d00b42c:	20c9883a 	add	r4,r4,r3
 d00b430:	39400b36 	bltu	r7,r5,d00b460 <__umoddi3+0x4d8>
 d00b434:	39403d26 	beq	r7,r5,d00b52c <__umoddi3+0x5a4>
 d00b438:	394bc83a 	sub	r5,r7,r5
 d00b43c:	00000f06 	br	d00b47c <__umoddi3+0x4f4>
 d00b440:	30c5c83a 	sub	r2,r6,r3
 d00b444:	1839883a 	mov	fp,r3
 d00b448:	b084d83a 	srl	r2,r22,r2
 d00b44c:	a0c6983a 	sll	r3,r20,r3
 d00b450:	8720983a 	sll	r16,r16,fp
 d00b454:	b72c983a 	sll	r22,r22,fp
 d00b458:	18a8b03a 	or	r20,r3,r2
 d00b45c:	003f3a06 	br	d00b148 <__umoddi3+0x1c0>
 d00b460:	d8c00017 	ldw	r3,0(sp)
 d00b464:	20c5c83a 	sub	r2,r4,r3
 d00b468:	2089803a 	cmpltu	r4,r4,r2
 d00b46c:	2dc7c83a 	sub	r3,r5,r23
 d00b470:	1907c83a 	sub	r3,r3,r4
 d00b474:	38cbc83a 	sub	r5,r7,r3
 d00b478:	1009883a 	mov	r4,r2
 d00b47c:	b105c83a 	sub	r2,r22,r4
 d00b480:	b087803a 	cmpltu	r3,r22,r2
 d00b484:	28c7c83a 	sub	r3,r5,r3
 d00b488:	d9400317 	ldw	r5,12(sp)
 d00b48c:	1544d83a 	srl	r2,r2,r21
 d00b490:	1948983a 	sll	r4,r3,r5
 d00b494:	1d46d83a 	srl	r3,r3,r21
 d00b498:	20a4b03a 	or	r18,r4,r2
 d00b49c:	9011883a 	mov	r8,r18
 d00b4a0:	1813883a 	mov	r9,r3
 d00b4a4:	003ef606 	br	d00b080 <__umoddi3+0xf8>
 d00b4a8:	01400604 	movi	r5,24
 d00b4ac:	2805883a 	mov	r2,r5
 d00b4b0:	003ecc06 	br	d00afe4 <__umoddi3+0x5c>
 d00b4b4:	01400204 	movi	r5,8
 d00b4b8:	2805883a 	mov	r2,r5
 d00b4bc:	003ec906 	br	d00afe4 <__umoddi3+0x5c>
 d00b4c0:	01400204 	movi	r5,8
 d00b4c4:	2805883a 	mov	r2,r5
 d00b4c8:	003f0106 	br	d00b0d0 <__umoddi3+0x148>
 d00b4cc:	01400204 	movi	r5,8
 d00b4d0:	2805883a 	mov	r2,r5
 d00b4d4:	003f1206 	br	d00b120 <__umoddi3+0x198>
 d00b4d8:	01400604 	movi	r5,24
 d00b4dc:	2805883a 	mov	r2,r5
 d00b4e0:	003f0f06 	br	d00b120 <__umoddi3+0x198>
 d00b4e4:	01400604 	movi	r5,24
 d00b4e8:	2805883a 	mov	r2,r5
 d00b4ec:	003ef806 	br	d00b0d0 <__umoddi3+0x148>
 d00b4f0:	3c7fb82e 	bgeu	r7,r17,d00b3d4 <__umoddi3+0x44c>
 d00b4f4:	843fffc4 	addi	r16,r16,-1
 d00b4f8:	3dcf883a 	add	r7,r7,r23
 d00b4fc:	003fb506 	br	d00b3d4 <__umoddi3+0x44c>
 d00b500:	147fa22e 	bgeu	r2,r17,d00b38c <__umoddi3+0x404>
 d00b504:	e73fffc4 	addi	fp,fp,-1
 d00b508:	15c5883a 	add	r2,r2,r23
 d00b50c:	003f9f06 	br	d00b38c <__umoddi3+0x404>
 d00b510:	147f692e 	bgeu	r2,r17,d00b2b8 <__umoddi3+0x330>
 d00b514:	1405883a 	add	r2,r2,r16
 d00b518:	003f6706 	br	d00b2b8 <__umoddi3+0x330>
 d00b51c:	1405883a 	add	r2,r2,r16
 d00b520:	003f1906 	br	d00b188 <__umoddi3+0x200>
 d00b524:	1405883a 	add	r2,r2,r16
 d00b528:	003ec906 	br	d00b050 <__umoddi3+0xc8>
 d00b52c:	b13fcc36 	bltu	r22,r4,d00b460 <__umoddi3+0x4d8>
 d00b530:	000b883a 	mov	r5,zero
 d00b534:	003fd106 	br	d00b47c <__umoddi3+0x4f4>

0d00b538 <_fpadd_parts>:
 d00b538:	defff804 	addi	sp,sp,-32
 d00b53c:	dcc00315 	stw	r19,12(sp)
 d00b540:	2027883a 	mov	r19,r4
 d00b544:	21000017 	ldw	r4,0(r4)
 d00b548:	00c00044 	movi	r3,1
 d00b54c:	dd400515 	stw	r21,20(sp)
 d00b550:	dd000415 	stw	r20,16(sp)
 d00b554:	ddc00715 	stw	r23,28(sp)
 d00b558:	dd800615 	stw	r22,24(sp)
 d00b55c:	dc800215 	stw	r18,8(sp)
 d00b560:	dc400115 	stw	r17,4(sp)
 d00b564:	dc000015 	stw	r16,0(sp)
 d00b568:	282b883a 	mov	r21,r5
 d00b56c:	3029883a 	mov	r20,r6
 d00b570:	1900632e 	bgeu	r3,r4,d00b700 <_fpadd_parts+0x1c8>
 d00b574:	28800017 	ldw	r2,0(r5)
 d00b578:	1880812e 	bgeu	r3,r2,d00b780 <_fpadd_parts+0x248>
 d00b57c:	00c00104 	movi	r3,4
 d00b580:	20c0dc26 	beq	r4,r3,d00b8f4 <_fpadd_parts+0x3bc>
 d00b584:	10c07e26 	beq	r2,r3,d00b780 <_fpadd_parts+0x248>
 d00b588:	00c00084 	movi	r3,2
 d00b58c:	10c06726 	beq	r2,r3,d00b72c <_fpadd_parts+0x1f4>
 d00b590:	20c07b26 	beq	r4,r3,d00b780 <_fpadd_parts+0x248>
 d00b594:	9dc00217 	ldw	r23,8(r19)
 d00b598:	28c00217 	ldw	r3,8(r5)
 d00b59c:	9c400317 	ldw	r17,12(r19)
 d00b5a0:	2bc00317 	ldw	r15,12(r5)
 d00b5a4:	b8cdc83a 	sub	r6,r23,r3
 d00b5a8:	9c800417 	ldw	r18,16(r19)
 d00b5ac:	2c000417 	ldw	r16,16(r5)
 d00b5b0:	3009883a 	mov	r4,r6
 d00b5b4:	30009716 	blt	r6,zero,d00b814 <_fpadd_parts+0x2dc>
 d00b5b8:	00800fc4 	movi	r2,63
 d00b5bc:	11806b16 	blt	r2,r6,d00b76c <_fpadd_parts+0x234>
 d00b5c0:	0100a40e 	bge	zero,r4,d00b854 <_fpadd_parts+0x31c>
 d00b5c4:	35bff804 	addi	r22,r6,-32
 d00b5c8:	b000bc16 	blt	r22,zero,d00b8bc <_fpadd_parts+0x384>
 d00b5cc:	8596d83a 	srl	r11,r16,r22
 d00b5d0:	0019883a 	mov	r12,zero
 d00b5d4:	0013883a 	mov	r9,zero
 d00b5d8:	01000044 	movi	r4,1
 d00b5dc:	0015883a 	mov	r10,zero
 d00b5e0:	b000be16 	blt	r22,zero,d00b8dc <_fpadd_parts+0x3a4>
 d00b5e4:	2590983a 	sll	r8,r4,r22
 d00b5e8:	000f883a 	mov	r7,zero
 d00b5ec:	00bfffc4 	movi	r2,-1
 d00b5f0:	3889883a 	add	r4,r7,r2
 d00b5f4:	408b883a 	add	r5,r8,r2
 d00b5f8:	21cd803a 	cmpltu	r6,r4,r7
 d00b5fc:	314b883a 	add	r5,r6,r5
 d00b600:	7904703a 	and	r2,r15,r4
 d00b604:	8146703a 	and	r3,r16,r5
 d00b608:	10c4b03a 	or	r2,r2,r3
 d00b60c:	10000226 	beq	r2,zero,d00b618 <_fpadd_parts+0xe0>
 d00b610:	02400044 	movi	r9,1
 d00b614:	0015883a 	mov	r10,zero
 d00b618:	5a5eb03a 	or	r15,r11,r9
 d00b61c:	62a0b03a 	or	r16,r12,r10
 d00b620:	99400117 	ldw	r5,4(r19)
 d00b624:	a8800117 	ldw	r2,4(r21)
 d00b628:	28806e26 	beq	r5,r2,d00b7e4 <_fpadd_parts+0x2ac>
 d00b62c:	28006626 	beq	r5,zero,d00b7c8 <_fpadd_parts+0x290>
 d00b630:	7c45c83a 	sub	r2,r15,r17
 d00b634:	7889803a 	cmpltu	r4,r15,r2
 d00b638:	8487c83a 	sub	r3,r16,r18
 d00b63c:	1909c83a 	sub	r4,r3,r4
 d00b640:	100d883a 	mov	r6,r2
 d00b644:	200f883a 	mov	r7,r4
 d00b648:	38007716 	blt	r7,zero,d00b828 <_fpadd_parts+0x2f0>
 d00b64c:	a5c00215 	stw	r23,8(r20)
 d00b650:	a1c00415 	stw	r7,16(r20)
 d00b654:	a0000115 	stw	zero,4(r20)
 d00b658:	a1800315 	stw	r6,12(r20)
 d00b65c:	a2000317 	ldw	r8,12(r20)
 d00b660:	a2400417 	ldw	r9,16(r20)
 d00b664:	00bfffc4 	movi	r2,-1
 d00b668:	408b883a 	add	r5,r8,r2
 d00b66c:	2a09803a 	cmpltu	r4,r5,r8
 d00b670:	488d883a 	add	r6,r9,r2
 d00b674:	01c40034 	movhi	r7,4096
 d00b678:	39ffffc4 	addi	r7,r7,-1
 d00b67c:	218d883a 	add	r6,r4,r6
 d00b680:	39801736 	bltu	r7,r6,d00b6e0 <_fpadd_parts+0x1a8>
 d00b684:	31c06526 	beq	r6,r7,d00b81c <_fpadd_parts+0x2e4>
 d00b688:	a3000217 	ldw	r12,8(r20)
 d00b68c:	4209883a 	add	r4,r8,r8
 d00b690:	00bfffc4 	movi	r2,-1
 d00b694:	220f803a 	cmpltu	r7,r4,r8
 d00b698:	4a4b883a 	add	r5,r9,r9
 d00b69c:	394f883a 	add	r7,r7,r5
 d00b6a0:	2095883a 	add	r10,r4,r2
 d00b6a4:	3897883a 	add	r11,r7,r2
 d00b6a8:	510d803a 	cmpltu	r6,r10,r4
 d00b6ac:	6099883a 	add	r12,r12,r2
 d00b6b0:	32d7883a 	add	r11,r6,r11
 d00b6b4:	00840034 	movhi	r2,4096
 d00b6b8:	10bfffc4 	addi	r2,r2,-1
 d00b6bc:	2011883a 	mov	r8,r4
 d00b6c0:	3813883a 	mov	r9,r7
 d00b6c4:	a1000315 	stw	r4,12(r20)
 d00b6c8:	a1c00415 	stw	r7,16(r20)
 d00b6cc:	a3000215 	stw	r12,8(r20)
 d00b6d0:	12c00336 	bltu	r2,r11,d00b6e0 <_fpadd_parts+0x1a8>
 d00b6d4:	58bfed1e 	bne	r11,r2,d00b68c <_fpadd_parts+0x154>
 d00b6d8:	00bfff84 	movi	r2,-2
 d00b6dc:	12bfeb2e 	bgeu	r2,r10,d00b68c <_fpadd_parts+0x154>
 d00b6e0:	a2800417 	ldw	r10,16(r20)
 d00b6e4:	008000c4 	movi	r2,3
 d00b6e8:	00c80034 	movhi	r3,8192
 d00b6ec:	18ffffc4 	addi	r3,r3,-1
 d00b6f0:	a2400317 	ldw	r9,12(r20)
 d00b6f4:	a0800015 	stw	r2,0(r20)
 d00b6f8:	1a802336 	bltu	r3,r10,d00b788 <_fpadd_parts+0x250>
 d00b6fc:	a027883a 	mov	r19,r20
 d00b700:	9805883a 	mov	r2,r19
 d00b704:	ddc00717 	ldw	r23,28(sp)
 d00b708:	dd800617 	ldw	r22,24(sp)
 d00b70c:	dd400517 	ldw	r21,20(sp)
 d00b710:	dd000417 	ldw	r20,16(sp)
 d00b714:	dcc00317 	ldw	r19,12(sp)
 d00b718:	dc800217 	ldw	r18,8(sp)
 d00b71c:	dc400117 	ldw	r17,4(sp)
 d00b720:	dc000017 	ldw	r16,0(sp)
 d00b724:	dec00804 	addi	sp,sp,32
 d00b728:	f800283a 	ret
 d00b72c:	20fff41e 	bne	r4,r3,d00b700 <_fpadd_parts+0x1c8>
 d00b730:	31000015 	stw	r4,0(r6)
 d00b734:	98800117 	ldw	r2,4(r19)
 d00b738:	30800115 	stw	r2,4(r6)
 d00b73c:	98c00217 	ldw	r3,8(r19)
 d00b740:	30c00215 	stw	r3,8(r6)
 d00b744:	98800317 	ldw	r2,12(r19)
 d00b748:	30800315 	stw	r2,12(r6)
 d00b74c:	98c00417 	ldw	r3,16(r19)
 d00b750:	30c00415 	stw	r3,16(r6)
 d00b754:	98800117 	ldw	r2,4(r19)
 d00b758:	28c00117 	ldw	r3,4(r5)
 d00b75c:	3027883a 	mov	r19,r6
 d00b760:	10c4703a 	and	r2,r2,r3
 d00b764:	30800115 	stw	r2,4(r6)
 d00b768:	003fe506 	br	d00b700 <_fpadd_parts+0x1c8>
 d00b76c:	1dc02616 	blt	r3,r23,d00b808 <_fpadd_parts+0x2d0>
 d00b770:	0023883a 	mov	r17,zero
 d00b774:	182f883a 	mov	r23,r3
 d00b778:	0025883a 	mov	r18,zero
 d00b77c:	003fa806 	br	d00b620 <_fpadd_parts+0xe8>
 d00b780:	a827883a 	mov	r19,r21
 d00b784:	003fde06 	br	d00b700 <_fpadd_parts+0x1c8>
 d00b788:	01800044 	movi	r6,1
 d00b78c:	500497fa 	slli	r2,r10,31
 d00b790:	4808d07a 	srli	r4,r9,1
 d00b794:	518ad83a 	srl	r5,r10,r6
 d00b798:	a2000217 	ldw	r8,8(r20)
 d00b79c:	1108b03a 	or	r4,r2,r4
 d00b7a0:	0007883a 	mov	r3,zero
 d00b7a4:	4984703a 	and	r2,r9,r6
 d00b7a8:	208cb03a 	or	r6,r4,r2
 d00b7ac:	28ceb03a 	or	r7,r5,r3
 d00b7b0:	42000044 	addi	r8,r8,1
 d00b7b4:	a027883a 	mov	r19,r20
 d00b7b8:	a1c00415 	stw	r7,16(r20)
 d00b7bc:	a2000215 	stw	r8,8(r20)
 d00b7c0:	a1800315 	stw	r6,12(r20)
 d00b7c4:	003fce06 	br	d00b700 <_fpadd_parts+0x1c8>
 d00b7c8:	8bc5c83a 	sub	r2,r17,r15
 d00b7cc:	8889803a 	cmpltu	r4,r17,r2
 d00b7d0:	9407c83a 	sub	r3,r18,r16
 d00b7d4:	1909c83a 	sub	r4,r3,r4
 d00b7d8:	100d883a 	mov	r6,r2
 d00b7dc:	200f883a 	mov	r7,r4
 d00b7e0:	003f9906 	br	d00b648 <_fpadd_parts+0x110>
 d00b7e4:	8bc5883a 	add	r2,r17,r15
 d00b7e8:	1449803a 	cmpltu	r4,r2,r17
 d00b7ec:	9407883a 	add	r3,r18,r16
 d00b7f0:	20c9883a 	add	r4,r4,r3
 d00b7f4:	a1400115 	stw	r5,4(r20)
 d00b7f8:	a5c00215 	stw	r23,8(r20)
 d00b7fc:	a0800315 	stw	r2,12(r20)
 d00b800:	a1000415 	stw	r4,16(r20)
 d00b804:	003fb606 	br	d00b6e0 <_fpadd_parts+0x1a8>
 d00b808:	001f883a 	mov	r15,zero
 d00b80c:	0021883a 	mov	r16,zero
 d00b810:	003f8306 	br	d00b620 <_fpadd_parts+0xe8>
 d00b814:	018dc83a 	sub	r6,zero,r6
 d00b818:	003f6706 	br	d00b5b8 <_fpadd_parts+0x80>
 d00b81c:	00bfff84 	movi	r2,-2
 d00b820:	117faf36 	bltu	r2,r5,d00b6e0 <_fpadd_parts+0x1a8>
 d00b824:	003f9806 	br	d00b688 <_fpadd_parts+0x150>
 d00b828:	0005883a 	mov	r2,zero
 d00b82c:	1189c83a 	sub	r4,r2,r6
 d00b830:	1105803a 	cmpltu	r2,r2,r4
 d00b834:	01cbc83a 	sub	r5,zero,r7
 d00b838:	2885c83a 	sub	r2,r5,r2
 d00b83c:	01800044 	movi	r6,1
 d00b840:	a1800115 	stw	r6,4(r20)
 d00b844:	a5c00215 	stw	r23,8(r20)
 d00b848:	a1000315 	stw	r4,12(r20)
 d00b84c:	a0800415 	stw	r2,16(r20)
 d00b850:	003f8206 	br	d00b65c <_fpadd_parts+0x124>
 d00b854:	203f7226 	beq	r4,zero,d00b620 <_fpadd_parts+0xe8>
 d00b858:	35bff804 	addi	r22,r6,-32
 d00b85c:	b9af883a 	add	r23,r23,r6
 d00b860:	b0003116 	blt	r22,zero,d00b928 <_fpadd_parts+0x3f0>
 d00b864:	959ad83a 	srl	r13,r18,r22
 d00b868:	001d883a 	mov	r14,zero
 d00b86c:	000f883a 	mov	r7,zero
 d00b870:	01000044 	movi	r4,1
 d00b874:	0011883a 	mov	r8,zero
 d00b878:	b0002516 	blt	r22,zero,d00b910 <_fpadd_parts+0x3d8>
 d00b87c:	2594983a 	sll	r10,r4,r22
 d00b880:	0013883a 	mov	r9,zero
 d00b884:	00bfffc4 	movi	r2,-1
 d00b888:	4889883a 	add	r4,r9,r2
 d00b88c:	508b883a 	add	r5,r10,r2
 d00b890:	224d803a 	cmpltu	r6,r4,r9
 d00b894:	314b883a 	add	r5,r6,r5
 d00b898:	8904703a 	and	r2,r17,r4
 d00b89c:	9146703a 	and	r3,r18,r5
 d00b8a0:	10c4b03a 	or	r2,r2,r3
 d00b8a4:	10000226 	beq	r2,zero,d00b8b0 <_fpadd_parts+0x378>
 d00b8a8:	01c00044 	movi	r7,1
 d00b8ac:	0011883a 	mov	r8,zero
 d00b8b0:	69e2b03a 	or	r17,r13,r7
 d00b8b4:	7224b03a 	or	r18,r14,r8
 d00b8b8:	003f5906 	br	d00b620 <_fpadd_parts+0xe8>
 d00b8bc:	8407883a 	add	r3,r16,r16
 d00b8c0:	008007c4 	movi	r2,31
 d00b8c4:	1185c83a 	sub	r2,r2,r6
 d00b8c8:	1886983a 	sll	r3,r3,r2
 d00b8cc:	7996d83a 	srl	r11,r15,r6
 d00b8d0:	8198d83a 	srl	r12,r16,r6
 d00b8d4:	1ad6b03a 	or	r11,r3,r11
 d00b8d8:	003f3e06 	br	d00b5d4 <_fpadd_parts+0x9c>
 d00b8dc:	2006d07a 	srli	r3,r4,1
 d00b8e0:	008007c4 	movi	r2,31
 d00b8e4:	1185c83a 	sub	r2,r2,r6
 d00b8e8:	1890d83a 	srl	r8,r3,r2
 d00b8ec:	218e983a 	sll	r7,r4,r6
 d00b8f0:	003f3e06 	br	d00b5ec <_fpadd_parts+0xb4>
 d00b8f4:	113f821e 	bne	r2,r4,d00b700 <_fpadd_parts+0x1c8>
 d00b8f8:	28c00117 	ldw	r3,4(r5)
 d00b8fc:	98800117 	ldw	r2,4(r19)
 d00b900:	10ff7f26 	beq	r2,r3,d00b700 <_fpadd_parts+0x1c8>
 d00b904:	04c34174 	movhi	r19,3333
 d00b908:	9cf16904 	addi	r19,r19,-14940
 d00b90c:	003f7c06 	br	d00b700 <_fpadd_parts+0x1c8>
 d00b910:	2006d07a 	srli	r3,r4,1
 d00b914:	008007c4 	movi	r2,31
 d00b918:	1185c83a 	sub	r2,r2,r6
 d00b91c:	1894d83a 	srl	r10,r3,r2
 d00b920:	2192983a 	sll	r9,r4,r6
 d00b924:	003fd706 	br	d00b884 <_fpadd_parts+0x34c>
 d00b928:	9487883a 	add	r3,r18,r18
 d00b92c:	008007c4 	movi	r2,31
 d00b930:	1185c83a 	sub	r2,r2,r6
 d00b934:	1886983a 	sll	r3,r3,r2
 d00b938:	899ad83a 	srl	r13,r17,r6
 d00b93c:	919cd83a 	srl	r14,r18,r6
 d00b940:	1b5ab03a 	or	r13,r3,r13
 d00b944:	003fc906 	br	d00b86c <_fpadd_parts+0x334>

0d00b948 <__subdf3>:
 d00b948:	deffea04 	addi	sp,sp,-88
 d00b94c:	dcc01415 	stw	r19,80(sp)
 d00b950:	dcc00404 	addi	r19,sp,16
 d00b954:	2011883a 	mov	r8,r4
 d00b958:	2813883a 	mov	r9,r5
 d00b95c:	dc401315 	stw	r17,76(sp)
 d00b960:	d809883a 	mov	r4,sp
 d00b964:	980b883a 	mov	r5,r19
 d00b968:	dc400904 	addi	r17,sp,36
 d00b96c:	dfc01515 	stw	ra,84(sp)
 d00b970:	da400115 	stw	r9,4(sp)
 d00b974:	d9c00315 	stw	r7,12(sp)
 d00b978:	da000015 	stw	r8,0(sp)
 d00b97c:	d9800215 	stw	r6,8(sp)
 d00b980:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00b984:	d9000204 	addi	r4,sp,8
 d00b988:	880b883a 	mov	r5,r17
 d00b98c:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00b990:	d8800a17 	ldw	r2,40(sp)
 d00b994:	880b883a 	mov	r5,r17
 d00b998:	9809883a 	mov	r4,r19
 d00b99c:	d9800e04 	addi	r6,sp,56
 d00b9a0:	1080005c 	xori	r2,r2,1
 d00b9a4:	d8800a15 	stw	r2,40(sp)
 d00b9a8:	d00b5380 	call	d00b538 <_fpadd_parts>
 d00b9ac:	1009883a 	mov	r4,r2
 d00b9b0:	d00c8c80 	call	d00c8c8 <__pack_d>
 d00b9b4:	dfc01517 	ldw	ra,84(sp)
 d00b9b8:	dcc01417 	ldw	r19,80(sp)
 d00b9bc:	dc401317 	ldw	r17,76(sp)
 d00b9c0:	dec01604 	addi	sp,sp,88
 d00b9c4:	f800283a 	ret

0d00b9c8 <__adddf3>:
 d00b9c8:	deffea04 	addi	sp,sp,-88
 d00b9cc:	dcc01415 	stw	r19,80(sp)
 d00b9d0:	dcc00404 	addi	r19,sp,16
 d00b9d4:	2011883a 	mov	r8,r4
 d00b9d8:	2813883a 	mov	r9,r5
 d00b9dc:	dc401315 	stw	r17,76(sp)
 d00b9e0:	d809883a 	mov	r4,sp
 d00b9e4:	980b883a 	mov	r5,r19
 d00b9e8:	dc400904 	addi	r17,sp,36
 d00b9ec:	dfc01515 	stw	ra,84(sp)
 d00b9f0:	da400115 	stw	r9,4(sp)
 d00b9f4:	d9c00315 	stw	r7,12(sp)
 d00b9f8:	da000015 	stw	r8,0(sp)
 d00b9fc:	d9800215 	stw	r6,8(sp)
 d00ba00:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00ba04:	d9000204 	addi	r4,sp,8
 d00ba08:	880b883a 	mov	r5,r17
 d00ba0c:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00ba10:	d9800e04 	addi	r6,sp,56
 d00ba14:	9809883a 	mov	r4,r19
 d00ba18:	880b883a 	mov	r5,r17
 d00ba1c:	d00b5380 	call	d00b538 <_fpadd_parts>
 d00ba20:	1009883a 	mov	r4,r2
 d00ba24:	d00c8c80 	call	d00c8c8 <__pack_d>
 d00ba28:	dfc01517 	ldw	ra,84(sp)
 d00ba2c:	dcc01417 	ldw	r19,80(sp)
 d00ba30:	dc401317 	ldw	r17,76(sp)
 d00ba34:	dec01604 	addi	sp,sp,88
 d00ba38:	f800283a 	ret

0d00ba3c <__muldf3>:
 d00ba3c:	deffe004 	addi	sp,sp,-128
 d00ba40:	dc401815 	stw	r17,96(sp)
 d00ba44:	dc400404 	addi	r17,sp,16
 d00ba48:	2011883a 	mov	r8,r4
 d00ba4c:	2813883a 	mov	r9,r5
 d00ba50:	dc001715 	stw	r16,92(sp)
 d00ba54:	d809883a 	mov	r4,sp
 d00ba58:	880b883a 	mov	r5,r17
 d00ba5c:	dc000904 	addi	r16,sp,36
 d00ba60:	dfc01f15 	stw	ra,124(sp)
 d00ba64:	da400115 	stw	r9,4(sp)
 d00ba68:	d9c00315 	stw	r7,12(sp)
 d00ba6c:	da000015 	stw	r8,0(sp)
 d00ba70:	d9800215 	stw	r6,8(sp)
 d00ba74:	ddc01e15 	stw	r23,120(sp)
 d00ba78:	dd801d15 	stw	r22,116(sp)
 d00ba7c:	dd401c15 	stw	r21,112(sp)
 d00ba80:	dd001b15 	stw	r20,108(sp)
 d00ba84:	dcc01a15 	stw	r19,104(sp)
 d00ba88:	dc801915 	stw	r18,100(sp)
 d00ba8c:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00ba90:	d9000204 	addi	r4,sp,8
 d00ba94:	800b883a 	mov	r5,r16
 d00ba98:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00ba9c:	d9000417 	ldw	r4,16(sp)
 d00baa0:	00800044 	movi	r2,1
 d00baa4:	1100102e 	bgeu	r2,r4,d00bae8 <__muldf3+0xac>
 d00baa8:	d8c00917 	ldw	r3,36(sp)
 d00baac:	10c0062e 	bgeu	r2,r3,d00bac8 <__muldf3+0x8c>
 d00bab0:	00800104 	movi	r2,4
 d00bab4:	20800a26 	beq	r4,r2,d00bae0 <__muldf3+0xa4>
 d00bab8:	1880cc26 	beq	r3,r2,d00bdec <__muldf3+0x3b0>
 d00babc:	00800084 	movi	r2,2
 d00bac0:	20800926 	beq	r4,r2,d00bae8 <__muldf3+0xac>
 d00bac4:	1880191e 	bne	r3,r2,d00bb2c <__muldf3+0xf0>
 d00bac8:	d8c00a17 	ldw	r3,40(sp)
 d00bacc:	d8800517 	ldw	r2,20(sp)
 d00bad0:	8009883a 	mov	r4,r16
 d00bad4:	10c4c03a 	cmpne	r2,r2,r3
 d00bad8:	d8800a15 	stw	r2,40(sp)
 d00badc:	00000706 	br	d00bafc <__muldf3+0xc0>
 d00bae0:	00800084 	movi	r2,2
 d00bae4:	1880c326 	beq	r3,r2,d00bdf4 <__muldf3+0x3b8>
 d00bae8:	d8800517 	ldw	r2,20(sp)
 d00baec:	d8c00a17 	ldw	r3,40(sp)
 d00baf0:	8809883a 	mov	r4,r17
 d00baf4:	10c4c03a 	cmpne	r2,r2,r3
 d00baf8:	d8800515 	stw	r2,20(sp)
 d00bafc:	d00c8c80 	call	d00c8c8 <__pack_d>
 d00bb00:	dfc01f17 	ldw	ra,124(sp)
 d00bb04:	ddc01e17 	ldw	r23,120(sp)
 d00bb08:	dd801d17 	ldw	r22,116(sp)
 d00bb0c:	dd401c17 	ldw	r21,112(sp)
 d00bb10:	dd001b17 	ldw	r20,108(sp)
 d00bb14:	dcc01a17 	ldw	r19,104(sp)
 d00bb18:	dc801917 	ldw	r18,100(sp)
 d00bb1c:	dc401817 	ldw	r17,96(sp)
 d00bb20:	dc001717 	ldw	r16,92(sp)
 d00bb24:	dec02004 	addi	sp,sp,128
 d00bb28:	f800283a 	ret
 d00bb2c:	dd800717 	ldw	r22,28(sp)
 d00bb30:	dc800c17 	ldw	r18,48(sp)
 d00bb34:	002b883a 	mov	r21,zero
 d00bb38:	0023883a 	mov	r17,zero
 d00bb3c:	a80b883a 	mov	r5,r21
 d00bb40:	b00d883a 	mov	r6,r22
 d00bb44:	880f883a 	mov	r7,r17
 d00bb48:	ddc00817 	ldw	r23,32(sp)
 d00bb4c:	dcc00d17 	ldw	r19,52(sp)
 d00bb50:	9009883a 	mov	r4,r18
 d00bb54:	d00c7b00 	call	d00c7b0 <__muldi3>
 d00bb58:	001b883a 	mov	r13,zero
 d00bb5c:	680f883a 	mov	r7,r13
 d00bb60:	b009883a 	mov	r4,r22
 d00bb64:	000b883a 	mov	r5,zero
 d00bb68:	980d883a 	mov	r6,r19
 d00bb6c:	b82d883a 	mov	r22,r23
 d00bb70:	002f883a 	mov	r23,zero
 d00bb74:	db401615 	stw	r13,88(sp)
 d00bb78:	d8801315 	stw	r2,76(sp)
 d00bb7c:	d8c01415 	stw	r3,80(sp)
 d00bb80:	dcc01515 	stw	r19,84(sp)
 d00bb84:	d00c7b00 	call	d00c7b0 <__muldi3>
 d00bb88:	b00d883a 	mov	r6,r22
 d00bb8c:	000b883a 	mov	r5,zero
 d00bb90:	9009883a 	mov	r4,r18
 d00bb94:	b80f883a 	mov	r7,r23
 d00bb98:	1021883a 	mov	r16,r2
 d00bb9c:	1823883a 	mov	r17,r3
 d00bba0:	d00c7b00 	call	d00c7b0 <__muldi3>
 d00bba4:	8085883a 	add	r2,r16,r2
 d00bba8:	140d803a 	cmpltu	r6,r2,r16
 d00bbac:	88c7883a 	add	r3,r17,r3
 d00bbb0:	30cd883a 	add	r6,r6,r3
 d00bbb4:	1029883a 	mov	r20,r2
 d00bbb8:	302b883a 	mov	r21,r6
 d00bbbc:	da801317 	ldw	r10,76(sp)
 d00bbc0:	dac01417 	ldw	r11,80(sp)
 d00bbc4:	db001517 	ldw	r12,84(sp)
 d00bbc8:	db401617 	ldw	r13,88(sp)
 d00bbcc:	3440612e 	bgeu	r6,r17,d00bd54 <__muldf3+0x318>
 d00bbd0:	0009883a 	mov	r4,zero
 d00bbd4:	5105883a 	add	r2,r10,r4
 d00bbd8:	128d803a 	cmpltu	r6,r2,r10
 d00bbdc:	5d07883a 	add	r3,r11,r20
 d00bbe0:	30cd883a 	add	r6,r6,r3
 d00bbe4:	0021883a 	mov	r16,zero
 d00bbe8:	04400044 	movi	r17,1
 d00bbec:	1025883a 	mov	r18,r2
 d00bbf0:	3027883a 	mov	r19,r6
 d00bbf4:	32c06236 	bltu	r6,r11,d00bd80 <__muldf3+0x344>
 d00bbf8:	59807a26 	beq	r11,r6,d00bde4 <__muldf3+0x3a8>
 d00bbfc:	680b883a 	mov	r5,r13
 d00bc00:	b80f883a 	mov	r7,r23
 d00bc04:	6009883a 	mov	r4,r12
 d00bc08:	b00d883a 	mov	r6,r22
 d00bc0c:	d00c7b00 	call	d00c7b0 <__muldi3>
 d00bc10:	1009883a 	mov	r4,r2
 d00bc14:	000f883a 	mov	r7,zero
 d00bc18:	1545883a 	add	r2,r2,r21
 d00bc1c:	1111803a 	cmpltu	r8,r2,r4
 d00bc20:	19c7883a 	add	r3,r3,r7
 d00bc24:	40c7883a 	add	r3,r8,r3
 d00bc28:	88cb883a 	add	r5,r17,r3
 d00bc2c:	d8c00617 	ldw	r3,24(sp)
 d00bc30:	8089883a 	add	r4,r16,r2
 d00bc34:	d8800b17 	ldw	r2,44(sp)
 d00bc38:	18c00104 	addi	r3,r3,4
 d00bc3c:	240d803a 	cmpltu	r6,r4,r16
 d00bc40:	10c7883a 	add	r3,r2,r3
 d00bc44:	2013883a 	mov	r9,r4
 d00bc48:	d8800a17 	ldw	r2,40(sp)
 d00bc4c:	d9000517 	ldw	r4,20(sp)
 d00bc50:	314d883a 	add	r6,r6,r5
 d00bc54:	3015883a 	mov	r10,r6
 d00bc58:	2088c03a 	cmpne	r4,r4,r2
 d00bc5c:	00880034 	movhi	r2,8192
 d00bc60:	10bfffc4 	addi	r2,r2,-1
 d00bc64:	d9000f15 	stw	r4,60(sp)
 d00bc68:	d8c01015 	stw	r3,64(sp)
 d00bc6c:	1180162e 	bgeu	r2,r6,d00bcc8 <__muldf3+0x28c>
 d00bc70:	1811883a 	mov	r8,r3
 d00bc74:	101f883a 	mov	r15,r2
 d00bc78:	980497fa 	slli	r2,r19,31
 d00bc7c:	9016d07a 	srli	r11,r18,1
 d00bc80:	500697fa 	slli	r3,r10,31
 d00bc84:	480cd07a 	srli	r6,r9,1
 d00bc88:	500ed07a 	srli	r7,r10,1
 d00bc8c:	12d6b03a 	or	r11,r2,r11
 d00bc90:	00800044 	movi	r2,1
 d00bc94:	198cb03a 	or	r6,r3,r6
 d00bc98:	4888703a 	and	r4,r9,r2
 d00bc9c:	9818d07a 	srli	r12,r19,1
 d00bca0:	001b883a 	mov	r13,zero
 d00bca4:	03a00034 	movhi	r14,32768
 d00bca8:	3013883a 	mov	r9,r6
 d00bcac:	3815883a 	mov	r10,r7
 d00bcb0:	4091883a 	add	r8,r8,r2
 d00bcb4:	20000226 	beq	r4,zero,d00bcc0 <__muldf3+0x284>
 d00bcb8:	5b64b03a 	or	r18,r11,r13
 d00bcbc:	63a6b03a 	or	r19,r12,r14
 d00bcc0:	7abfed36 	bltu	r15,r10,d00bc78 <__muldf3+0x23c>
 d00bcc4:	da001015 	stw	r8,64(sp)
 d00bcc8:	00840034 	movhi	r2,4096
 d00bccc:	10bfffc4 	addi	r2,r2,-1
 d00bcd0:	12801436 	bltu	r2,r10,d00bd24 <__muldf3+0x2e8>
 d00bcd4:	da001017 	ldw	r8,64(sp)
 d00bcd8:	101f883a 	mov	r15,r2
 d00bcdc:	4a45883a 	add	r2,r9,r9
 d00bce0:	124d803a 	cmpltu	r6,r2,r9
 d00bce4:	5287883a 	add	r3,r10,r10
 d00bce8:	9497883a 	add	r11,r18,r18
 d00bcec:	5c8f803a 	cmpltu	r7,r11,r18
 d00bcf0:	9cd9883a 	add	r12,r19,r19
 d00bcf4:	01000044 	movi	r4,1
 d00bcf8:	30cd883a 	add	r6,r6,r3
 d00bcfc:	3b0f883a 	add	r7,r7,r12
 d00bd00:	423fffc4 	addi	r8,r8,-1
 d00bd04:	1013883a 	mov	r9,r2
 d00bd08:	3015883a 	mov	r10,r6
 d00bd0c:	111ab03a 	or	r13,r2,r4
 d00bd10:	98003016 	blt	r19,zero,d00bdd4 <__muldf3+0x398>
 d00bd14:	5825883a 	mov	r18,r11
 d00bd18:	3827883a 	mov	r19,r7
 d00bd1c:	7abfef2e 	bgeu	r15,r10,d00bcdc <__muldf3+0x2a0>
 d00bd20:	da001015 	stw	r8,64(sp)
 d00bd24:	00803fc4 	movi	r2,255
 d00bd28:	488e703a 	and	r7,r9,r2
 d00bd2c:	00802004 	movi	r2,128
 d00bd30:	0007883a 	mov	r3,zero
 d00bd34:	0011883a 	mov	r8,zero
 d00bd38:	38801826 	beq	r7,r2,d00bd9c <__muldf3+0x360>
 d00bd3c:	008000c4 	movi	r2,3
 d00bd40:	d9000e04 	addi	r4,sp,56
 d00bd44:	da801215 	stw	r10,72(sp)
 d00bd48:	d8800e15 	stw	r2,56(sp)
 d00bd4c:	da401115 	stw	r9,68(sp)
 d00bd50:	003f6a06 	br	d00bafc <__muldf3+0xc0>
 d00bd54:	89802126 	beq	r17,r6,d00bddc <__muldf3+0x3a0>
 d00bd58:	0009883a 	mov	r4,zero
 d00bd5c:	5105883a 	add	r2,r10,r4
 d00bd60:	128d803a 	cmpltu	r6,r2,r10
 d00bd64:	5d07883a 	add	r3,r11,r20
 d00bd68:	30cd883a 	add	r6,r6,r3
 d00bd6c:	0021883a 	mov	r16,zero
 d00bd70:	0023883a 	mov	r17,zero
 d00bd74:	1025883a 	mov	r18,r2
 d00bd78:	3027883a 	mov	r19,r6
 d00bd7c:	32ff9e2e 	bgeu	r6,r11,d00bbf8 <__muldf3+0x1bc>
 d00bd80:	00800044 	movi	r2,1
 d00bd84:	8089883a 	add	r4,r16,r2
 d00bd88:	240d803a 	cmpltu	r6,r4,r16
 d00bd8c:	344d883a 	add	r6,r6,r17
 d00bd90:	2021883a 	mov	r16,r4
 d00bd94:	3023883a 	mov	r17,r6
 d00bd98:	003f9806 	br	d00bbfc <__muldf3+0x1c0>
 d00bd9c:	403fe71e 	bne	r8,zero,d00bd3c <__muldf3+0x300>
 d00bda0:	01004004 	movi	r4,256
 d00bda4:	4904703a 	and	r2,r9,r4
 d00bda8:	10c4b03a 	or	r2,r2,r3
 d00bdac:	103fe31e 	bne	r2,zero,d00bd3c <__muldf3+0x300>
 d00bdb0:	94c4b03a 	or	r2,r18,r19
 d00bdb4:	103fe126 	beq	r2,zero,d00bd3c <__muldf3+0x300>
 d00bdb8:	49c5883a 	add	r2,r9,r7
 d00bdbc:	1251803a 	cmpltu	r8,r2,r9
 d00bdc0:	4291883a 	add	r8,r8,r10
 d00bdc4:	013fc004 	movi	r4,-256
 d00bdc8:	1112703a 	and	r9,r2,r4
 d00bdcc:	4015883a 	mov	r10,r8
 d00bdd0:	003fda06 	br	d00bd3c <__muldf3+0x300>
 d00bdd4:	6813883a 	mov	r9,r13
 d00bdd8:	003fce06 	br	d00bd14 <__muldf3+0x2d8>
 d00bddc:	143f7c36 	bltu	r2,r16,d00bbd0 <__muldf3+0x194>
 d00bde0:	003fdd06 	br	d00bd58 <__muldf3+0x31c>
 d00bde4:	12bf852e 	bgeu	r2,r10,d00bbfc <__muldf3+0x1c0>
 d00bde8:	003fe506 	br	d00bd80 <__muldf3+0x344>
 d00bdec:	00800084 	movi	r2,2
 d00bdf0:	20bf351e 	bne	r4,r2,d00bac8 <__muldf3+0x8c>
 d00bdf4:	01034174 	movhi	r4,3333
 d00bdf8:	21316904 	addi	r4,r4,-14940
 d00bdfc:	003f3f06 	br	d00bafc <__muldf3+0xc0>

0d00be00 <__divdf3>:
 d00be00:	deffed04 	addi	sp,sp,-76
 d00be04:	dcc01115 	stw	r19,68(sp)
 d00be08:	dcc00404 	addi	r19,sp,16
 d00be0c:	2011883a 	mov	r8,r4
 d00be10:	2813883a 	mov	r9,r5
 d00be14:	dc000e15 	stw	r16,56(sp)
 d00be18:	d809883a 	mov	r4,sp
 d00be1c:	980b883a 	mov	r5,r19
 d00be20:	dc000904 	addi	r16,sp,36
 d00be24:	dfc01215 	stw	ra,72(sp)
 d00be28:	da400115 	stw	r9,4(sp)
 d00be2c:	d9c00315 	stw	r7,12(sp)
 d00be30:	da000015 	stw	r8,0(sp)
 d00be34:	d9800215 	stw	r6,8(sp)
 d00be38:	dc801015 	stw	r18,64(sp)
 d00be3c:	dc400f15 	stw	r17,60(sp)
 d00be40:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00be44:	d9000204 	addi	r4,sp,8
 d00be48:	800b883a 	mov	r5,r16
 d00be4c:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00be50:	d9000417 	ldw	r4,16(sp)
 d00be54:	00800044 	movi	r2,1
 d00be58:	11000b2e 	bgeu	r2,r4,d00be88 <__divdf3+0x88>
 d00be5c:	d9400917 	ldw	r5,36(sp)
 d00be60:	1140762e 	bgeu	r2,r5,d00c03c <__divdf3+0x23c>
 d00be64:	d8800517 	ldw	r2,20(sp)
 d00be68:	d8c00a17 	ldw	r3,40(sp)
 d00be6c:	01800104 	movi	r6,4
 d00be70:	10c4f03a 	xor	r2,r2,r3
 d00be74:	d8800515 	stw	r2,20(sp)
 d00be78:	21800226 	beq	r4,r6,d00be84 <__divdf3+0x84>
 d00be7c:	00800084 	movi	r2,2
 d00be80:	2080141e 	bne	r4,r2,d00bed4 <__divdf3+0xd4>
 d00be84:	29000926 	beq	r5,r4,d00beac <__divdf3+0xac>
 d00be88:	9809883a 	mov	r4,r19
 d00be8c:	d00c8c80 	call	d00c8c8 <__pack_d>
 d00be90:	dfc01217 	ldw	ra,72(sp)
 d00be94:	dcc01117 	ldw	r19,68(sp)
 d00be98:	dc801017 	ldw	r18,64(sp)
 d00be9c:	dc400f17 	ldw	r17,60(sp)
 d00bea0:	dc000e17 	ldw	r16,56(sp)
 d00bea4:	dec01304 	addi	sp,sp,76
 d00bea8:	f800283a 	ret
 d00beac:	01034174 	movhi	r4,3333
 d00beb0:	21316904 	addi	r4,r4,-14940
 d00beb4:	d00c8c80 	call	d00c8c8 <__pack_d>
 d00beb8:	dfc01217 	ldw	ra,72(sp)
 d00bebc:	dcc01117 	ldw	r19,68(sp)
 d00bec0:	dc801017 	ldw	r18,64(sp)
 d00bec4:	dc400f17 	ldw	r17,60(sp)
 d00bec8:	dc000e17 	ldw	r16,56(sp)
 d00becc:	dec01304 	addi	sp,sp,76
 d00bed0:	f800283a 	ret
 d00bed4:	29805b26 	beq	r5,r6,d00c044 <__divdf3+0x244>
 d00bed8:	28802d26 	beq	r5,r2,d00bf90 <__divdf3+0x190>
 d00bedc:	d8c00617 	ldw	r3,24(sp)
 d00bee0:	d8800b17 	ldw	r2,44(sp)
 d00bee4:	d9c00817 	ldw	r7,32(sp)
 d00bee8:	dc400d17 	ldw	r17,52(sp)
 d00beec:	188bc83a 	sub	r5,r3,r2
 d00bef0:	d9800717 	ldw	r6,28(sp)
 d00bef4:	dc000c17 	ldw	r16,48(sp)
 d00bef8:	d9400615 	stw	r5,24(sp)
 d00befc:	3c403836 	bltu	r7,r17,d00bfe0 <__divdf3+0x1e0>
 d00bf00:	89c03626 	beq	r17,r7,d00bfdc <__divdf3+0x1dc>
 d00bf04:	0015883a 	mov	r10,zero
 d00bf08:	001d883a 	mov	r14,zero
 d00bf0c:	02c40034 	movhi	r11,4096
 d00bf10:	001f883a 	mov	r15,zero
 d00bf14:	003f883a 	mov	ra,zero
 d00bf18:	04800f44 	movi	r18,61
 d00bf1c:	00000f06 	br	d00bf5c <__divdf3+0x15c>
 d00bf20:	601d883a 	mov	r14,r12
 d00bf24:	681f883a 	mov	r15,r13
 d00bf28:	400d883a 	mov	r6,r8
 d00bf2c:	100f883a 	mov	r7,r2
 d00bf30:	3191883a 	add	r8,r6,r6
 d00bf34:	5808d07a 	srli	r4,r11,1
 d00bf38:	4185803a 	cmpltu	r2,r8,r6
 d00bf3c:	39d3883a 	add	r9,r7,r7
 d00bf40:	28c6b03a 	or	r3,r5,r3
 d00bf44:	1245883a 	add	r2,r2,r9
 d00bf48:	1815883a 	mov	r10,r3
 d00bf4c:	2017883a 	mov	r11,r4
 d00bf50:	400d883a 	mov	r6,r8
 d00bf54:	100f883a 	mov	r7,r2
 d00bf58:	fc801726 	beq	ra,r18,d00bfb8 <__divdf3+0x1b8>
 d00bf5c:	580a97fa 	slli	r5,r11,31
 d00bf60:	5006d07a 	srli	r3,r10,1
 d00bf64:	ffc00044 	addi	ra,ra,1
 d00bf68:	3c7ff136 	bltu	r7,r17,d00bf30 <__divdf3+0x130>
 d00bf6c:	3411c83a 	sub	r8,r6,r16
 d00bf70:	3205803a 	cmpltu	r2,r6,r8
 d00bf74:	3c53c83a 	sub	r9,r7,r17
 d00bf78:	7298b03a 	or	r12,r14,r10
 d00bf7c:	7adab03a 	or	r13,r15,r11
 d00bf80:	4885c83a 	sub	r2,r9,r2
 d00bf84:	89ffe61e 	bne	r17,r7,d00bf20 <__divdf3+0x120>
 d00bf88:	343fe936 	bltu	r6,r16,d00bf30 <__divdf3+0x130>
 d00bf8c:	003fe406 	br	d00bf20 <__divdf3+0x120>
 d00bf90:	9809883a 	mov	r4,r19
 d00bf94:	d9800415 	stw	r6,16(sp)
 d00bf98:	d00c8c80 	call	d00c8c8 <__pack_d>
 d00bf9c:	dfc01217 	ldw	ra,72(sp)
 d00bfa0:	dcc01117 	ldw	r19,68(sp)
 d00bfa4:	dc801017 	ldw	r18,64(sp)
 d00bfa8:	dc400f17 	ldw	r17,60(sp)
 d00bfac:	dc000e17 	ldw	r16,56(sp)
 d00bfb0:	dec01304 	addi	sp,sp,76
 d00bfb4:	f800283a 	ret
 d00bfb8:	00803fc4 	movi	r2,255
 d00bfbc:	7090703a 	and	r8,r14,r2
 d00bfc0:	00802004 	movi	r2,128
 d00bfc4:	0007883a 	mov	r3,zero
 d00bfc8:	0013883a 	mov	r9,zero
 d00bfcc:	40800d26 	beq	r8,r2,d00c004 <__divdf3+0x204>
 d00bfd0:	dbc00815 	stw	r15,32(sp)
 d00bfd4:	db800715 	stw	r14,28(sp)
 d00bfd8:	003fab06 	br	d00be88 <__divdf3+0x88>
 d00bfdc:	343fc92e 	bgeu	r6,r16,d00bf04 <__divdf3+0x104>
 d00bfe0:	3185883a 	add	r2,r6,r6
 d00bfe4:	1189803a 	cmpltu	r4,r2,r6
 d00bfe8:	39c7883a 	add	r3,r7,r7
 d00bfec:	20c9883a 	add	r4,r4,r3
 d00bff0:	297fffc4 	addi	r5,r5,-1
 d00bff4:	100d883a 	mov	r6,r2
 d00bff8:	200f883a 	mov	r7,r4
 d00bffc:	d9400615 	stw	r5,24(sp)
 d00c000:	003fc006 	br	d00bf04 <__divdf3+0x104>
 d00c004:	483ff21e 	bne	r9,zero,d00bfd0 <__divdf3+0x1d0>
 d00c008:	01004004 	movi	r4,256
 d00c00c:	7104703a 	and	r2,r14,r4
 d00c010:	10c4b03a 	or	r2,r2,r3
 d00c014:	103fee1e 	bne	r2,zero,d00bfd0 <__divdf3+0x1d0>
 d00c018:	31c4b03a 	or	r2,r6,r7
 d00c01c:	103fec26 	beq	r2,zero,d00bfd0 <__divdf3+0x1d0>
 d00c020:	7205883a 	add	r2,r14,r8
 d00c024:	1391803a 	cmpltu	r8,r2,r14
 d00c028:	43d1883a 	add	r8,r8,r15
 d00c02c:	013fc004 	movi	r4,-256
 d00c030:	111c703a 	and	r14,r2,r4
 d00c034:	401f883a 	mov	r15,r8
 d00c038:	003fe506 	br	d00bfd0 <__divdf3+0x1d0>
 d00c03c:	8009883a 	mov	r4,r16
 d00c040:	003f9206 	br	d00be8c <__divdf3+0x8c>
 d00c044:	9809883a 	mov	r4,r19
 d00c048:	d8000715 	stw	zero,28(sp)
 d00c04c:	d8000815 	stw	zero,32(sp)
 d00c050:	d8000615 	stw	zero,24(sp)
 d00c054:	003f8d06 	br	d00be8c <__divdf3+0x8c>

0d00c058 <__eqdf2>:
 d00c058:	deffef04 	addi	sp,sp,-68
 d00c05c:	dc400f15 	stw	r17,60(sp)
 d00c060:	dc400404 	addi	r17,sp,16
 d00c064:	2005883a 	mov	r2,r4
 d00c068:	2807883a 	mov	r3,r5
 d00c06c:	dc000e15 	stw	r16,56(sp)
 d00c070:	d809883a 	mov	r4,sp
 d00c074:	880b883a 	mov	r5,r17
 d00c078:	dc000904 	addi	r16,sp,36
 d00c07c:	d8c00115 	stw	r3,4(sp)
 d00c080:	d8800015 	stw	r2,0(sp)
 d00c084:	d9800215 	stw	r6,8(sp)
 d00c088:	dfc01015 	stw	ra,64(sp)
 d00c08c:	d9c00315 	stw	r7,12(sp)
 d00c090:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c094:	d9000204 	addi	r4,sp,8
 d00c098:	800b883a 	mov	r5,r16
 d00c09c:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c0a0:	d8800417 	ldw	r2,16(sp)
 d00c0a4:	00c00044 	movi	r3,1
 d00c0a8:	180d883a 	mov	r6,r3
 d00c0ac:	1880062e 	bgeu	r3,r2,d00c0c8 <__eqdf2+0x70>
 d00c0b0:	d8800917 	ldw	r2,36(sp)
 d00c0b4:	8809883a 	mov	r4,r17
 d00c0b8:	800b883a 	mov	r5,r16
 d00c0bc:	1880022e 	bgeu	r3,r2,d00c0c8 <__eqdf2+0x70>
 d00c0c0:	d00cd140 	call	d00cd14 <__fpcmp_parts_d>
 d00c0c4:	100d883a 	mov	r6,r2
 d00c0c8:	3005883a 	mov	r2,r6
 d00c0cc:	dfc01017 	ldw	ra,64(sp)
 d00c0d0:	dc400f17 	ldw	r17,60(sp)
 d00c0d4:	dc000e17 	ldw	r16,56(sp)
 d00c0d8:	dec01104 	addi	sp,sp,68
 d00c0dc:	f800283a 	ret

0d00c0e0 <__nedf2>:
 d00c0e0:	deffef04 	addi	sp,sp,-68
 d00c0e4:	dc400f15 	stw	r17,60(sp)
 d00c0e8:	dc400404 	addi	r17,sp,16
 d00c0ec:	2005883a 	mov	r2,r4
 d00c0f0:	2807883a 	mov	r3,r5
 d00c0f4:	dc000e15 	stw	r16,56(sp)
 d00c0f8:	d809883a 	mov	r4,sp
 d00c0fc:	880b883a 	mov	r5,r17
 d00c100:	dc000904 	addi	r16,sp,36
 d00c104:	d8c00115 	stw	r3,4(sp)
 d00c108:	d8800015 	stw	r2,0(sp)
 d00c10c:	d9800215 	stw	r6,8(sp)
 d00c110:	dfc01015 	stw	ra,64(sp)
 d00c114:	d9c00315 	stw	r7,12(sp)
 d00c118:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c11c:	d9000204 	addi	r4,sp,8
 d00c120:	800b883a 	mov	r5,r16
 d00c124:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c128:	d8800417 	ldw	r2,16(sp)
 d00c12c:	00c00044 	movi	r3,1
 d00c130:	180d883a 	mov	r6,r3
 d00c134:	1880062e 	bgeu	r3,r2,d00c150 <__nedf2+0x70>
 d00c138:	d8800917 	ldw	r2,36(sp)
 d00c13c:	8809883a 	mov	r4,r17
 d00c140:	800b883a 	mov	r5,r16
 d00c144:	1880022e 	bgeu	r3,r2,d00c150 <__nedf2+0x70>
 d00c148:	d00cd140 	call	d00cd14 <__fpcmp_parts_d>
 d00c14c:	100d883a 	mov	r6,r2
 d00c150:	3005883a 	mov	r2,r6
 d00c154:	dfc01017 	ldw	ra,64(sp)
 d00c158:	dc400f17 	ldw	r17,60(sp)
 d00c15c:	dc000e17 	ldw	r16,56(sp)
 d00c160:	dec01104 	addi	sp,sp,68
 d00c164:	f800283a 	ret

0d00c168 <__gtdf2>:
 d00c168:	deffef04 	addi	sp,sp,-68
 d00c16c:	dc400f15 	stw	r17,60(sp)
 d00c170:	dc400404 	addi	r17,sp,16
 d00c174:	2005883a 	mov	r2,r4
 d00c178:	2807883a 	mov	r3,r5
 d00c17c:	dc000e15 	stw	r16,56(sp)
 d00c180:	d809883a 	mov	r4,sp
 d00c184:	880b883a 	mov	r5,r17
 d00c188:	dc000904 	addi	r16,sp,36
 d00c18c:	d8c00115 	stw	r3,4(sp)
 d00c190:	d8800015 	stw	r2,0(sp)
 d00c194:	d9800215 	stw	r6,8(sp)
 d00c198:	dfc01015 	stw	ra,64(sp)
 d00c19c:	d9c00315 	stw	r7,12(sp)
 d00c1a0:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c1a4:	d9000204 	addi	r4,sp,8
 d00c1a8:	800b883a 	mov	r5,r16
 d00c1ac:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c1b0:	d8800417 	ldw	r2,16(sp)
 d00c1b4:	00c00044 	movi	r3,1
 d00c1b8:	01bfffc4 	movi	r6,-1
 d00c1bc:	1880062e 	bgeu	r3,r2,d00c1d8 <__gtdf2+0x70>
 d00c1c0:	d8800917 	ldw	r2,36(sp)
 d00c1c4:	8809883a 	mov	r4,r17
 d00c1c8:	800b883a 	mov	r5,r16
 d00c1cc:	1880022e 	bgeu	r3,r2,d00c1d8 <__gtdf2+0x70>
 d00c1d0:	d00cd140 	call	d00cd14 <__fpcmp_parts_d>
 d00c1d4:	100d883a 	mov	r6,r2
 d00c1d8:	3005883a 	mov	r2,r6
 d00c1dc:	dfc01017 	ldw	ra,64(sp)
 d00c1e0:	dc400f17 	ldw	r17,60(sp)
 d00c1e4:	dc000e17 	ldw	r16,56(sp)
 d00c1e8:	dec01104 	addi	sp,sp,68
 d00c1ec:	f800283a 	ret

0d00c1f0 <__gedf2>:
 d00c1f0:	deffef04 	addi	sp,sp,-68
 d00c1f4:	dc400f15 	stw	r17,60(sp)
 d00c1f8:	dc400404 	addi	r17,sp,16
 d00c1fc:	2005883a 	mov	r2,r4
 d00c200:	2807883a 	mov	r3,r5
 d00c204:	dc000e15 	stw	r16,56(sp)
 d00c208:	d809883a 	mov	r4,sp
 d00c20c:	880b883a 	mov	r5,r17
 d00c210:	dc000904 	addi	r16,sp,36
 d00c214:	d8c00115 	stw	r3,4(sp)
 d00c218:	d8800015 	stw	r2,0(sp)
 d00c21c:	d9800215 	stw	r6,8(sp)
 d00c220:	dfc01015 	stw	ra,64(sp)
 d00c224:	d9c00315 	stw	r7,12(sp)
 d00c228:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c22c:	d9000204 	addi	r4,sp,8
 d00c230:	800b883a 	mov	r5,r16
 d00c234:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c238:	d8800417 	ldw	r2,16(sp)
 d00c23c:	00c00044 	movi	r3,1
 d00c240:	01bfffc4 	movi	r6,-1
 d00c244:	1880062e 	bgeu	r3,r2,d00c260 <__gedf2+0x70>
 d00c248:	d8800917 	ldw	r2,36(sp)
 d00c24c:	8809883a 	mov	r4,r17
 d00c250:	800b883a 	mov	r5,r16
 d00c254:	1880022e 	bgeu	r3,r2,d00c260 <__gedf2+0x70>
 d00c258:	d00cd140 	call	d00cd14 <__fpcmp_parts_d>
 d00c25c:	100d883a 	mov	r6,r2
 d00c260:	3005883a 	mov	r2,r6
 d00c264:	dfc01017 	ldw	ra,64(sp)
 d00c268:	dc400f17 	ldw	r17,60(sp)
 d00c26c:	dc000e17 	ldw	r16,56(sp)
 d00c270:	dec01104 	addi	sp,sp,68
 d00c274:	f800283a 	ret

0d00c278 <__ltdf2>:
 d00c278:	deffef04 	addi	sp,sp,-68
 d00c27c:	dc400f15 	stw	r17,60(sp)
 d00c280:	dc400404 	addi	r17,sp,16
 d00c284:	2005883a 	mov	r2,r4
 d00c288:	2807883a 	mov	r3,r5
 d00c28c:	dc000e15 	stw	r16,56(sp)
 d00c290:	d809883a 	mov	r4,sp
 d00c294:	880b883a 	mov	r5,r17
 d00c298:	dc000904 	addi	r16,sp,36
 d00c29c:	d8c00115 	stw	r3,4(sp)
 d00c2a0:	d8800015 	stw	r2,0(sp)
 d00c2a4:	d9800215 	stw	r6,8(sp)
 d00c2a8:	dfc01015 	stw	ra,64(sp)
 d00c2ac:	d9c00315 	stw	r7,12(sp)
 d00c2b0:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c2b4:	d9000204 	addi	r4,sp,8
 d00c2b8:	800b883a 	mov	r5,r16
 d00c2bc:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c2c0:	d8800417 	ldw	r2,16(sp)
 d00c2c4:	00c00044 	movi	r3,1
 d00c2c8:	180d883a 	mov	r6,r3
 d00c2cc:	1880062e 	bgeu	r3,r2,d00c2e8 <__ltdf2+0x70>
 d00c2d0:	d8800917 	ldw	r2,36(sp)
 d00c2d4:	8809883a 	mov	r4,r17
 d00c2d8:	800b883a 	mov	r5,r16
 d00c2dc:	1880022e 	bgeu	r3,r2,d00c2e8 <__ltdf2+0x70>
 d00c2e0:	d00cd140 	call	d00cd14 <__fpcmp_parts_d>
 d00c2e4:	100d883a 	mov	r6,r2
 d00c2e8:	3005883a 	mov	r2,r6
 d00c2ec:	dfc01017 	ldw	ra,64(sp)
 d00c2f0:	dc400f17 	ldw	r17,60(sp)
 d00c2f4:	dc000e17 	ldw	r16,56(sp)
 d00c2f8:	dec01104 	addi	sp,sp,68
 d00c2fc:	f800283a 	ret

0d00c300 <__floatsidf>:
 d00c300:	2006d7fa 	srli	r3,r4,31
 d00c304:	defff604 	addi	sp,sp,-40
 d00c308:	008000c4 	movi	r2,3
 d00c30c:	dfc00915 	stw	ra,36(sp)
 d00c310:	dcc00815 	stw	r19,32(sp)
 d00c314:	dc800715 	stw	r18,28(sp)
 d00c318:	dc400615 	stw	r17,24(sp)
 d00c31c:	dc000515 	stw	r16,20(sp)
 d00c320:	d8800015 	stw	r2,0(sp)
 d00c324:	d8c00115 	stw	r3,4(sp)
 d00c328:	20000f1e 	bne	r4,zero,d00c368 <__floatsidf+0x68>
 d00c32c:	00800084 	movi	r2,2
 d00c330:	d8800015 	stw	r2,0(sp)
 d00c334:	d809883a 	mov	r4,sp
 d00c338:	d00c8c80 	call	d00c8c8 <__pack_d>
 d00c33c:	1009883a 	mov	r4,r2
 d00c340:	180b883a 	mov	r5,r3
 d00c344:	2005883a 	mov	r2,r4
 d00c348:	2807883a 	mov	r3,r5
 d00c34c:	dfc00917 	ldw	ra,36(sp)
 d00c350:	dcc00817 	ldw	r19,32(sp)
 d00c354:	dc800717 	ldw	r18,28(sp)
 d00c358:	dc400617 	ldw	r17,24(sp)
 d00c35c:	dc000517 	ldw	r16,20(sp)
 d00c360:	dec00a04 	addi	sp,sp,40
 d00c364:	f800283a 	ret
 d00c368:	00800f04 	movi	r2,60
 d00c36c:	1807003a 	cmpeq	r3,r3,zero
 d00c370:	d8800215 	stw	r2,8(sp)
 d00c374:	18001126 	beq	r3,zero,d00c3bc <__floatsidf+0xbc>
 d00c378:	0027883a 	mov	r19,zero
 d00c37c:	2025883a 	mov	r18,r4
 d00c380:	d9000315 	stw	r4,12(sp)
 d00c384:	dcc00415 	stw	r19,16(sp)
 d00c388:	d00c8480 	call	d00c848 <__clzsi2>
 d00c38c:	11000744 	addi	r4,r2,29
 d00c390:	013fe80e 	bge	zero,r4,d00c334 <__floatsidf+0x34>
 d00c394:	10bfff44 	addi	r2,r2,-3
 d00c398:	10000c16 	blt	r2,zero,d00c3cc <__floatsidf+0xcc>
 d00c39c:	90a2983a 	sll	r17,r18,r2
 d00c3a0:	0021883a 	mov	r16,zero
 d00c3a4:	d8800217 	ldw	r2,8(sp)
 d00c3a8:	dc400415 	stw	r17,16(sp)
 d00c3ac:	dc000315 	stw	r16,12(sp)
 d00c3b0:	1105c83a 	sub	r2,r2,r4
 d00c3b4:	d8800215 	stw	r2,8(sp)
 d00c3b8:	003fde06 	br	d00c334 <__floatsidf+0x34>
 d00c3bc:	00a00034 	movhi	r2,32768
 d00c3c0:	20800a26 	beq	r4,r2,d00c3ec <__floatsidf+0xec>
 d00c3c4:	0109c83a 	sub	r4,zero,r4
 d00c3c8:	003feb06 	br	d00c378 <__floatsidf+0x78>
 d00c3cc:	9006d07a 	srli	r3,r18,1
 d00c3d0:	008007c4 	movi	r2,31
 d00c3d4:	1105c83a 	sub	r2,r2,r4
 d00c3d8:	1886d83a 	srl	r3,r3,r2
 d00c3dc:	9922983a 	sll	r17,r19,r4
 d00c3e0:	9120983a 	sll	r16,r18,r4
 d00c3e4:	1c62b03a 	or	r17,r3,r17
 d00c3e8:	003fee06 	br	d00c3a4 <__floatsidf+0xa4>
 d00c3ec:	0009883a 	mov	r4,zero
 d00c3f0:	01707834 	movhi	r5,49632
 d00c3f4:	003fd306 	br	d00c344 <__floatsidf+0x44>

0d00c3f8 <__fixdfsi>:
 d00c3f8:	defff804 	addi	sp,sp,-32
 d00c3fc:	2005883a 	mov	r2,r4
 d00c400:	2807883a 	mov	r3,r5
 d00c404:	d809883a 	mov	r4,sp
 d00c408:	d9400204 	addi	r5,sp,8
 d00c40c:	d8c00115 	stw	r3,4(sp)
 d00c410:	d8800015 	stw	r2,0(sp)
 d00c414:	dfc00715 	stw	ra,28(sp)
 d00c418:	d00cbdc0 	call	d00cbdc <__unpack_d>
 d00c41c:	d8c00217 	ldw	r3,8(sp)
 d00c420:	00800084 	movi	r2,2
 d00c424:	1880051e 	bne	r3,r2,d00c43c <__fixdfsi+0x44>
 d00c428:	0007883a 	mov	r3,zero
 d00c42c:	1805883a 	mov	r2,r3
 d00c430:	dfc00717 	ldw	ra,28(sp)
 d00c434:	dec00804 	addi	sp,sp,32
 d00c438:	f800283a 	ret
 d00c43c:	00800044 	movi	r2,1
 d00c440:	10fff92e 	bgeu	r2,r3,d00c428 <__fixdfsi+0x30>
 d00c444:	00800104 	movi	r2,4
 d00c448:	18800426 	beq	r3,r2,d00c45c <__fixdfsi+0x64>
 d00c44c:	d8c00417 	ldw	r3,16(sp)
 d00c450:	183ff516 	blt	r3,zero,d00c428 <__fixdfsi+0x30>
 d00c454:	00800784 	movi	r2,30
 d00c458:	10c0080e 	bge	r2,r3,d00c47c <__fixdfsi+0x84>
 d00c45c:	d8800317 	ldw	r2,12(sp)
 d00c460:	1000121e 	bne	r2,zero,d00c4ac <__fixdfsi+0xb4>
 d00c464:	00e00034 	movhi	r3,32768
 d00c468:	18ffffc4 	addi	r3,r3,-1
 d00c46c:	1805883a 	mov	r2,r3
 d00c470:	dfc00717 	ldw	ra,28(sp)
 d00c474:	dec00804 	addi	sp,sp,32
 d00c478:	f800283a 	ret
 d00c47c:	00800f04 	movi	r2,60
 d00c480:	10d1c83a 	sub	r8,r2,r3
 d00c484:	40bff804 	addi	r2,r8,-32
 d00c488:	d9800517 	ldw	r6,20(sp)
 d00c48c:	d9c00617 	ldw	r7,24(sp)
 d00c490:	10000816 	blt	r2,zero,d00c4b4 <__fixdfsi+0xbc>
 d00c494:	3888d83a 	srl	r4,r7,r2
 d00c498:	d8800317 	ldw	r2,12(sp)
 d00c49c:	2007883a 	mov	r3,r4
 d00c4a0:	103fe226 	beq	r2,zero,d00c42c <__fixdfsi+0x34>
 d00c4a4:	0107c83a 	sub	r3,zero,r4
 d00c4a8:	003fe006 	br	d00c42c <__fixdfsi+0x34>
 d00c4ac:	00e00034 	movhi	r3,32768
 d00c4b0:	003fde06 	br	d00c42c <__fixdfsi+0x34>
 d00c4b4:	39c7883a 	add	r3,r7,r7
 d00c4b8:	008007c4 	movi	r2,31
 d00c4bc:	1205c83a 	sub	r2,r2,r8
 d00c4c0:	1886983a 	sll	r3,r3,r2
 d00c4c4:	3208d83a 	srl	r4,r6,r8
 d00c4c8:	1908b03a 	or	r4,r3,r4
 d00c4cc:	003ff206 	br	d00c498 <__fixdfsi+0xa0>

0d00c4d0 <__floatunsidf>:
 d00c4d0:	defff204 	addi	sp,sp,-56
 d00c4d4:	dfc00d15 	stw	ra,52(sp)
 d00c4d8:	ddc00c15 	stw	r23,48(sp)
 d00c4dc:	dd800b15 	stw	r22,44(sp)
 d00c4e0:	dd400a15 	stw	r21,40(sp)
 d00c4e4:	dd000915 	stw	r20,36(sp)
 d00c4e8:	dcc00815 	stw	r19,32(sp)
 d00c4ec:	dc800715 	stw	r18,28(sp)
 d00c4f0:	dc400615 	stw	r17,24(sp)
 d00c4f4:	dc000515 	stw	r16,20(sp)
 d00c4f8:	d8000115 	stw	zero,4(sp)
 d00c4fc:	20000f1e 	bne	r4,zero,d00c53c <__floatunsidf+0x6c>
 d00c500:	00800084 	movi	r2,2
 d00c504:	d8800015 	stw	r2,0(sp)
 d00c508:	d809883a 	mov	r4,sp
 d00c50c:	d00c8c80 	call	d00c8c8 <__pack_d>
 d00c510:	dfc00d17 	ldw	ra,52(sp)
 d00c514:	ddc00c17 	ldw	r23,48(sp)
 d00c518:	dd800b17 	ldw	r22,44(sp)
 d00c51c:	dd400a17 	ldw	r21,40(sp)
 d00c520:	dd000917 	ldw	r20,36(sp)
 d00c524:	dcc00817 	ldw	r19,32(sp)
 d00c528:	dc800717 	ldw	r18,28(sp)
 d00c52c:	dc400617 	ldw	r17,24(sp)
 d00c530:	dc000517 	ldw	r16,20(sp)
 d00c534:	dec00e04 	addi	sp,sp,56
 d00c538:	f800283a 	ret
 d00c53c:	008000c4 	movi	r2,3
 d00c540:	00c00f04 	movi	r3,60
 d00c544:	002f883a 	mov	r23,zero
 d00c548:	202d883a 	mov	r22,r4
 d00c54c:	d8800015 	stw	r2,0(sp)
 d00c550:	d8c00215 	stw	r3,8(sp)
 d00c554:	d9000315 	stw	r4,12(sp)
 d00c558:	ddc00415 	stw	r23,16(sp)
 d00c55c:	d00c8480 	call	d00c848 <__clzsi2>
 d00c560:	12400744 	addi	r9,r2,29
 d00c564:	48000b16 	blt	r9,zero,d00c594 <__floatunsidf+0xc4>
 d00c568:	483fe726 	beq	r9,zero,d00c508 <__floatunsidf+0x38>
 d00c56c:	10bfff44 	addi	r2,r2,-3
 d00c570:	10002e16 	blt	r2,zero,d00c62c <__floatunsidf+0x15c>
 d00c574:	b0a2983a 	sll	r17,r22,r2
 d00c578:	0021883a 	mov	r16,zero
 d00c57c:	d8800217 	ldw	r2,8(sp)
 d00c580:	dc400415 	stw	r17,16(sp)
 d00c584:	dc000315 	stw	r16,12(sp)
 d00c588:	1245c83a 	sub	r2,r2,r9
 d00c58c:	d8800215 	stw	r2,8(sp)
 d00c590:	003fdd06 	br	d00c508 <__floatunsidf+0x38>
 d00c594:	0255c83a 	sub	r10,zero,r9
 d00c598:	51bff804 	addi	r6,r10,-32
 d00c59c:	30001b16 	blt	r6,zero,d00c60c <__floatunsidf+0x13c>
 d00c5a0:	b9a8d83a 	srl	r20,r23,r6
 d00c5a4:	002b883a 	mov	r21,zero
 d00c5a8:	000f883a 	mov	r7,zero
 d00c5ac:	01000044 	movi	r4,1
 d00c5b0:	0011883a 	mov	r8,zero
 d00c5b4:	30002516 	blt	r6,zero,d00c64c <__floatunsidf+0x17c>
 d00c5b8:	21a6983a 	sll	r19,r4,r6
 d00c5bc:	0025883a 	mov	r18,zero
 d00c5c0:	00bfffc4 	movi	r2,-1
 d00c5c4:	9089883a 	add	r4,r18,r2
 d00c5c8:	988b883a 	add	r5,r19,r2
 d00c5cc:	248d803a 	cmpltu	r6,r4,r18
 d00c5d0:	314b883a 	add	r5,r6,r5
 d00c5d4:	b104703a 	and	r2,r22,r4
 d00c5d8:	b946703a 	and	r3,r23,r5
 d00c5dc:	10c4b03a 	or	r2,r2,r3
 d00c5e0:	10000226 	beq	r2,zero,d00c5ec <__floatunsidf+0x11c>
 d00c5e4:	01c00044 	movi	r7,1
 d00c5e8:	0011883a 	mov	r8,zero
 d00c5ec:	d9000217 	ldw	r4,8(sp)
 d00c5f0:	a1c4b03a 	or	r2,r20,r7
 d00c5f4:	aa06b03a 	or	r3,r21,r8
 d00c5f8:	2249c83a 	sub	r4,r4,r9
 d00c5fc:	d8c00415 	stw	r3,16(sp)
 d00c600:	d9000215 	stw	r4,8(sp)
 d00c604:	d8800315 	stw	r2,12(sp)
 d00c608:	003fbf06 	br	d00c508 <__floatunsidf+0x38>
 d00c60c:	bdc7883a 	add	r3,r23,r23
 d00c610:	008007c4 	movi	r2,31
 d00c614:	1285c83a 	sub	r2,r2,r10
 d00c618:	1886983a 	sll	r3,r3,r2
 d00c61c:	b2a8d83a 	srl	r20,r22,r10
 d00c620:	baaad83a 	srl	r21,r23,r10
 d00c624:	1d28b03a 	or	r20,r3,r20
 d00c628:	003fdf06 	br	d00c5a8 <__floatunsidf+0xd8>
 d00c62c:	b006d07a 	srli	r3,r22,1
 d00c630:	008007c4 	movi	r2,31
 d00c634:	1245c83a 	sub	r2,r2,r9
 d00c638:	1886d83a 	srl	r3,r3,r2
 d00c63c:	ba62983a 	sll	r17,r23,r9
 d00c640:	b260983a 	sll	r16,r22,r9
 d00c644:	1c62b03a 	or	r17,r3,r17
 d00c648:	003fcc06 	br	d00c57c <__floatunsidf+0xac>
 d00c64c:	2006d07a 	srli	r3,r4,1
 d00c650:	008007c4 	movi	r2,31
 d00c654:	1285c83a 	sub	r2,r2,r10
 d00c658:	18a6d83a 	srl	r19,r3,r2
 d00c65c:	22a4983a 	sll	r18,r4,r10
 d00c660:	003fd706 	br	d00c5c0 <__floatunsidf+0xf0>

0d00c664 <udivmodsi4>:
 d00c664:	29001b2e 	bgeu	r5,r4,d00c6d4 <udivmodsi4+0x70>
 d00c668:	28001a16 	blt	r5,zero,d00c6d4 <udivmodsi4+0x70>
 d00c66c:	00800044 	movi	r2,1
 d00c670:	0007883a 	mov	r3,zero
 d00c674:	01c007c4 	movi	r7,31
 d00c678:	00000306 	br	d00c688 <udivmodsi4+0x24>
 d00c67c:	19c01326 	beq	r3,r7,d00c6cc <udivmodsi4+0x68>
 d00c680:	18c00044 	addi	r3,r3,1
 d00c684:	28000416 	blt	r5,zero,d00c698 <udivmodsi4+0x34>
 d00c688:	294b883a 	add	r5,r5,r5
 d00c68c:	1085883a 	add	r2,r2,r2
 d00c690:	293ffa36 	bltu	r5,r4,d00c67c <udivmodsi4+0x18>
 d00c694:	10000d26 	beq	r2,zero,d00c6cc <udivmodsi4+0x68>
 d00c698:	0007883a 	mov	r3,zero
 d00c69c:	21400236 	bltu	r4,r5,d00c6a8 <udivmodsi4+0x44>
 d00c6a0:	2149c83a 	sub	r4,r4,r5
 d00c6a4:	1886b03a 	or	r3,r3,r2
 d00c6a8:	1004d07a 	srli	r2,r2,1
 d00c6ac:	280ad07a 	srli	r5,r5,1
 d00c6b0:	103ffa1e 	bne	r2,zero,d00c69c <udivmodsi4+0x38>
 d00c6b4:	30000226 	beq	r6,zero,d00c6c0 <udivmodsi4+0x5c>
 d00c6b8:	2005883a 	mov	r2,r4
 d00c6bc:	f800283a 	ret
 d00c6c0:	1809883a 	mov	r4,r3
 d00c6c4:	2005883a 	mov	r2,r4
 d00c6c8:	f800283a 	ret
 d00c6cc:	0007883a 	mov	r3,zero
 d00c6d0:	003ff806 	br	d00c6b4 <udivmodsi4+0x50>
 d00c6d4:	00800044 	movi	r2,1
 d00c6d8:	0007883a 	mov	r3,zero
 d00c6dc:	003fef06 	br	d00c69c <udivmodsi4+0x38>

0d00c6e0 <__divsi3>:
 d00c6e0:	defffe04 	addi	sp,sp,-8
 d00c6e4:	dc000015 	stw	r16,0(sp)
 d00c6e8:	dfc00115 	stw	ra,4(sp)
 d00c6ec:	0021883a 	mov	r16,zero
 d00c6f0:	20000c16 	blt	r4,zero,d00c724 <__divsi3+0x44>
 d00c6f4:	000d883a 	mov	r6,zero
 d00c6f8:	28000e16 	blt	r5,zero,d00c734 <__divsi3+0x54>
 d00c6fc:	d00c6640 	call	d00c664 <udivmodsi4>
 d00c700:	1007883a 	mov	r3,r2
 d00c704:	8005003a 	cmpeq	r2,r16,zero
 d00c708:	1000011e 	bne	r2,zero,d00c710 <__divsi3+0x30>
 d00c70c:	00c7c83a 	sub	r3,zero,r3
 d00c710:	1805883a 	mov	r2,r3
 d00c714:	dfc00117 	ldw	ra,4(sp)
 d00c718:	dc000017 	ldw	r16,0(sp)
 d00c71c:	dec00204 	addi	sp,sp,8
 d00c720:	f800283a 	ret
 d00c724:	0109c83a 	sub	r4,zero,r4
 d00c728:	04000044 	movi	r16,1
 d00c72c:	000d883a 	mov	r6,zero
 d00c730:	283ff20e 	bge	r5,zero,d00c6fc <__divsi3+0x1c>
 d00c734:	014bc83a 	sub	r5,zero,r5
 d00c738:	8021003a 	cmpeq	r16,r16,zero
 d00c73c:	003fef06 	br	d00c6fc <__divsi3+0x1c>

0d00c740 <__modsi3>:
 d00c740:	deffff04 	addi	sp,sp,-4
 d00c744:	dfc00015 	stw	ra,0(sp)
 d00c748:	01800044 	movi	r6,1
 d00c74c:	2807883a 	mov	r3,r5
 d00c750:	20000416 	blt	r4,zero,d00c764 <__modsi3+0x24>
 d00c754:	28000c16 	blt	r5,zero,d00c788 <__modsi3+0x48>
 d00c758:	dfc00017 	ldw	ra,0(sp)
 d00c75c:	dec00104 	addi	sp,sp,4
 d00c760:	d00c6641 	jmpi	d00c664 <udivmodsi4>
 d00c764:	0109c83a 	sub	r4,zero,r4
 d00c768:	28000b16 	blt	r5,zero,d00c798 <__modsi3+0x58>
 d00c76c:	180b883a 	mov	r5,r3
 d00c770:	01800044 	movi	r6,1
 d00c774:	d00c6640 	call	d00c664 <udivmodsi4>
 d00c778:	0085c83a 	sub	r2,zero,r2
 d00c77c:	dfc00017 	ldw	ra,0(sp)
 d00c780:	dec00104 	addi	sp,sp,4
 d00c784:	f800283a 	ret
 d00c788:	014bc83a 	sub	r5,zero,r5
 d00c78c:	dfc00017 	ldw	ra,0(sp)
 d00c790:	dec00104 	addi	sp,sp,4
 d00c794:	d00c6641 	jmpi	d00c664 <udivmodsi4>
 d00c798:	0147c83a 	sub	r3,zero,r5
 d00c79c:	003ff306 	br	d00c76c <__modsi3+0x2c>

0d00c7a0 <__udivsi3>:
 d00c7a0:	000d883a 	mov	r6,zero
 d00c7a4:	d00c6641 	jmpi	d00c664 <udivmodsi4>

0d00c7a8 <__umodsi3>:
 d00c7a8:	01800044 	movi	r6,1
 d00c7ac:	d00c6641 	jmpi	d00c664 <udivmodsi4>

0d00c7b0 <__muldi3>:
 d00c7b0:	2011883a 	mov	r8,r4
 d00c7b4:	427fffcc 	andi	r9,r8,65535
 d00c7b8:	4018d43a 	srli	r12,r8,16
 d00c7bc:	32bfffcc 	andi	r10,r6,65535
 d00c7c0:	3016d43a 	srli	r11,r6,16
 d00c7c4:	4a85383a 	mul	r2,r9,r10
 d00c7c8:	6295383a 	mul	r10,r12,r10
 d00c7cc:	4ad3383a 	mul	r9,r9,r11
 d00c7d0:	113fffcc 	andi	r4,r2,65535
 d00c7d4:	1004d43a 	srli	r2,r2,16
 d00c7d8:	4a93883a 	add	r9,r9,r10
 d00c7dc:	3807883a 	mov	r3,r7
 d00c7e0:	1245883a 	add	r2,r2,r9
 d00c7e4:	280f883a 	mov	r7,r5
 d00c7e8:	180b883a 	mov	r5,r3
 d00c7ec:	1006943a 	slli	r3,r2,16
 d00c7f0:	defffd04 	addi	sp,sp,-12
 d00c7f4:	dc800215 	stw	r18,8(sp)
 d00c7f8:	1907883a 	add	r3,r3,r4
 d00c7fc:	dc400115 	stw	r17,4(sp)
 d00c800:	dc000015 	stw	r16,0(sp)
 d00c804:	4165383a 	mul	r18,r8,r5
 d00c808:	31e3383a 	mul	r17,r6,r7
 d00c80c:	1012d43a 	srli	r9,r2,16
 d00c810:	62d9383a 	mul	r12,r12,r11
 d00c814:	181f883a 	mov	r15,r3
 d00c818:	1280022e 	bgeu	r2,r10,d00c824 <__muldi3+0x74>
 d00c81c:	00800074 	movhi	r2,1
 d00c820:	6099883a 	add	r12,r12,r2
 d00c824:	624d883a 	add	r6,r12,r9
 d00c828:	9187883a 	add	r3,r18,r6
 d00c82c:	88c7883a 	add	r3,r17,r3
 d00c830:	7805883a 	mov	r2,r15
 d00c834:	dc800217 	ldw	r18,8(sp)
 d00c838:	dc400117 	ldw	r17,4(sp)
 d00c83c:	dc000017 	ldw	r16,0(sp)
 d00c840:	dec00304 	addi	sp,sp,12
 d00c844:	f800283a 	ret

0d00c848 <__clzsi2>:
 d00c848:	00bfffd4 	movui	r2,65535
 d00c84c:	11000e36 	bltu	r2,r4,d00c888 <__clzsi2+0x40>
 d00c850:	00803fc4 	movi	r2,255
 d00c854:	01400204 	movi	r5,8
 d00c858:	0007883a 	mov	r3,zero
 d00c85c:	11001036 	bltu	r2,r4,d00c8a0 <__clzsi2+0x58>
 d00c860:	000b883a 	mov	r5,zero
 d00c864:	20c6d83a 	srl	r3,r4,r3
 d00c868:	00834174 	movhi	r2,3333
 d00c86c:	10b16e04 	addi	r2,r2,-14920
 d00c870:	1887883a 	add	r3,r3,r2
 d00c874:	18800003 	ldbu	r2,0(r3)
 d00c878:	00c00804 	movi	r3,32
 d00c87c:	2885883a 	add	r2,r5,r2
 d00c880:	1885c83a 	sub	r2,r3,r2
 d00c884:	f800283a 	ret
 d00c888:	01400404 	movi	r5,16
 d00c88c:	00804034 	movhi	r2,256
 d00c890:	10bfffc4 	addi	r2,r2,-1
 d00c894:	2807883a 	mov	r3,r5
 d00c898:	113ff22e 	bgeu	r2,r4,d00c864 <__clzsi2+0x1c>
 d00c89c:	01400604 	movi	r5,24
 d00c8a0:	2807883a 	mov	r3,r5
 d00c8a4:	20c6d83a 	srl	r3,r4,r3
 d00c8a8:	00834174 	movhi	r2,3333
 d00c8ac:	10b16e04 	addi	r2,r2,-14920
 d00c8b0:	1887883a 	add	r3,r3,r2
 d00c8b4:	18800003 	ldbu	r2,0(r3)
 d00c8b8:	00c00804 	movi	r3,32
 d00c8bc:	2885883a 	add	r2,r5,r2
 d00c8c0:	1885c83a 	sub	r2,r3,r2
 d00c8c4:	f800283a 	ret

0d00c8c8 <__pack_d>:
 d00c8c8:	20c00017 	ldw	r3,0(r4)
 d00c8cc:	defffd04 	addi	sp,sp,-12
 d00c8d0:	dc000015 	stw	r16,0(sp)
 d00c8d4:	dc800215 	stw	r18,8(sp)
 d00c8d8:	dc400115 	stw	r17,4(sp)
 d00c8dc:	00800044 	movi	r2,1
 d00c8e0:	22000317 	ldw	r8,12(r4)
 d00c8e4:	001f883a 	mov	r15,zero
 d00c8e8:	22400417 	ldw	r9,16(r4)
 d00c8ec:	24000117 	ldw	r16,4(r4)
 d00c8f0:	10c0552e 	bgeu	r2,r3,d00ca48 <__pack_d+0x180>
 d00c8f4:	00800104 	movi	r2,4
 d00c8f8:	18804f26 	beq	r3,r2,d00ca38 <__pack_d+0x170>
 d00c8fc:	00800084 	movi	r2,2
 d00c900:	18800226 	beq	r3,r2,d00c90c <__pack_d+0x44>
 d00c904:	4244b03a 	or	r2,r8,r9
 d00c908:	10001a1e 	bne	r2,zero,d00c974 <__pack_d+0xac>
 d00c90c:	000d883a 	mov	r6,zero
 d00c910:	000f883a 	mov	r7,zero
 d00c914:	0011883a 	mov	r8,zero
 d00c918:	00800434 	movhi	r2,16
 d00c91c:	10bfffc4 	addi	r2,r2,-1
 d00c920:	301d883a 	mov	r14,r6
 d00c924:	3884703a 	and	r2,r7,r2
 d00c928:	400a953a 	slli	r5,r8,20
 d00c92c:	79bffc2c 	andhi	r6,r15,65520
 d00c930:	308cb03a 	or	r6,r6,r2
 d00c934:	00e00434 	movhi	r3,32784
 d00c938:	18ffffc4 	addi	r3,r3,-1
 d00c93c:	800497fa 	slli	r2,r16,31
 d00c940:	30c6703a 	and	r3,r6,r3
 d00c944:	1946b03a 	or	r3,r3,r5
 d00c948:	01600034 	movhi	r5,32768
 d00c94c:	297fffc4 	addi	r5,r5,-1
 d00c950:	194a703a 	and	r5,r3,r5
 d00c954:	288ab03a 	or	r5,r5,r2
 d00c958:	2807883a 	mov	r3,r5
 d00c95c:	7005883a 	mov	r2,r14
 d00c960:	dc800217 	ldw	r18,8(sp)
 d00c964:	dc400117 	ldw	r17,4(sp)
 d00c968:	dc000017 	ldw	r16,0(sp)
 d00c96c:	dec00304 	addi	sp,sp,12
 d00c970:	f800283a 	ret
 d00c974:	21000217 	ldw	r4,8(r4)
 d00c978:	00bf0084 	movi	r2,-1022
 d00c97c:	20803f16 	blt	r4,r2,d00ca7c <__pack_d+0x1b4>
 d00c980:	0080ffc4 	movi	r2,1023
 d00c984:	11002c16 	blt	r2,r4,d00ca38 <__pack_d+0x170>
 d00c988:	00803fc4 	movi	r2,255
 d00c98c:	408c703a 	and	r6,r8,r2
 d00c990:	00802004 	movi	r2,128
 d00c994:	0007883a 	mov	r3,zero
 d00c998:	000f883a 	mov	r7,zero
 d00c99c:	2280ffc4 	addi	r10,r4,1023
 d00c9a0:	30801e26 	beq	r6,r2,d00ca1c <__pack_d+0x154>
 d00c9a4:	00801fc4 	movi	r2,127
 d00c9a8:	4089883a 	add	r4,r8,r2
 d00c9ac:	220d803a 	cmpltu	r6,r4,r8
 d00c9b0:	324d883a 	add	r6,r6,r9
 d00c9b4:	2011883a 	mov	r8,r4
 d00c9b8:	3013883a 	mov	r9,r6
 d00c9bc:	00880034 	movhi	r2,8192
 d00c9c0:	10bfffc4 	addi	r2,r2,-1
 d00c9c4:	12400d36 	bltu	r2,r9,d00c9fc <__pack_d+0x134>
 d00c9c8:	4804963a 	slli	r2,r9,24
 d00c9cc:	400cd23a 	srli	r6,r8,8
 d00c9d0:	480ed23a 	srli	r7,r9,8
 d00c9d4:	013fffc4 	movi	r4,-1
 d00c9d8:	118cb03a 	or	r6,r2,r6
 d00c9dc:	01400434 	movhi	r5,16
 d00c9e0:	297fffc4 	addi	r5,r5,-1
 d00c9e4:	3104703a 	and	r2,r6,r4
 d00c9e8:	3946703a 	and	r3,r7,r5
 d00c9ec:	5201ffcc 	andi	r8,r10,2047
 d00c9f0:	100d883a 	mov	r6,r2
 d00c9f4:	180f883a 	mov	r7,r3
 d00c9f8:	003fc706 	br	d00c918 <__pack_d+0x50>
 d00c9fc:	480897fa 	slli	r4,r9,31
 d00ca00:	4004d07a 	srli	r2,r8,1
 d00ca04:	4806d07a 	srli	r3,r9,1
 d00ca08:	52800044 	addi	r10,r10,1
 d00ca0c:	2084b03a 	or	r2,r4,r2
 d00ca10:	1011883a 	mov	r8,r2
 d00ca14:	1813883a 	mov	r9,r3
 d00ca18:	003feb06 	br	d00c9c8 <__pack_d+0x100>
 d00ca1c:	383fe11e 	bne	r7,zero,d00c9a4 <__pack_d+0xdc>
 d00ca20:	01004004 	movi	r4,256
 d00ca24:	4104703a 	and	r2,r8,r4
 d00ca28:	10c4b03a 	or	r2,r2,r3
 d00ca2c:	103fe326 	beq	r2,zero,d00c9bc <__pack_d+0xf4>
 d00ca30:	3005883a 	mov	r2,r6
 d00ca34:	003fdc06 	br	d00c9a8 <__pack_d+0xe0>
 d00ca38:	000d883a 	mov	r6,zero
 d00ca3c:	000f883a 	mov	r7,zero
 d00ca40:	0201ffc4 	movi	r8,2047
 d00ca44:	003fb406 	br	d00c918 <__pack_d+0x50>
 d00ca48:	0005883a 	mov	r2,zero
 d00ca4c:	00c00234 	movhi	r3,8
 d00ca50:	408cb03a 	or	r6,r8,r2
 d00ca54:	48ceb03a 	or	r7,r9,r3
 d00ca58:	013fffc4 	movi	r4,-1
 d00ca5c:	01400434 	movhi	r5,16
 d00ca60:	297fffc4 	addi	r5,r5,-1
 d00ca64:	3104703a 	and	r2,r6,r4
 d00ca68:	3946703a 	and	r3,r7,r5
 d00ca6c:	100d883a 	mov	r6,r2
 d00ca70:	180f883a 	mov	r7,r3
 d00ca74:	0201ffc4 	movi	r8,2047
 d00ca78:	003fa706 	br	d00c918 <__pack_d+0x50>
 d00ca7c:	1109c83a 	sub	r4,r2,r4
 d00ca80:	00800e04 	movi	r2,56
 d00ca84:	11004316 	blt	r2,r4,d00cb94 <__pack_d+0x2cc>
 d00ca88:	21fff804 	addi	r7,r4,-32
 d00ca8c:	38004516 	blt	r7,zero,d00cba4 <__pack_d+0x2dc>
 d00ca90:	49d8d83a 	srl	r12,r9,r7
 d00ca94:	001b883a 	mov	r13,zero
 d00ca98:	0023883a 	mov	r17,zero
 d00ca9c:	01400044 	movi	r5,1
 d00caa0:	0025883a 	mov	r18,zero
 d00caa4:	38004716 	blt	r7,zero,d00cbc4 <__pack_d+0x2fc>
 d00caa8:	29d6983a 	sll	r11,r5,r7
 d00caac:	0015883a 	mov	r10,zero
 d00cab0:	00bfffc4 	movi	r2,-1
 d00cab4:	5089883a 	add	r4,r10,r2
 d00cab8:	588b883a 	add	r5,r11,r2
 d00cabc:	228d803a 	cmpltu	r6,r4,r10
 d00cac0:	314b883a 	add	r5,r6,r5
 d00cac4:	4104703a 	and	r2,r8,r4
 d00cac8:	4946703a 	and	r3,r9,r5
 d00cacc:	10c4b03a 	or	r2,r2,r3
 d00cad0:	10000226 	beq	r2,zero,d00cadc <__pack_d+0x214>
 d00cad4:	04400044 	movi	r17,1
 d00cad8:	0025883a 	mov	r18,zero
 d00cadc:	00803fc4 	movi	r2,255
 d00cae0:	644eb03a 	or	r7,r12,r17
 d00cae4:	3892703a 	and	r9,r7,r2
 d00cae8:	00802004 	movi	r2,128
 d00caec:	6c90b03a 	or	r8,r13,r18
 d00caf0:	0015883a 	mov	r10,zero
 d00caf4:	48801626 	beq	r9,r2,d00cb50 <__pack_d+0x288>
 d00caf8:	01001fc4 	movi	r4,127
 d00cafc:	3905883a 	add	r2,r7,r4
 d00cb00:	11cd803a 	cmpltu	r6,r2,r7
 d00cb04:	320d883a 	add	r6,r6,r8
 d00cb08:	100f883a 	mov	r7,r2
 d00cb0c:	00840034 	movhi	r2,4096
 d00cb10:	10bfffc4 	addi	r2,r2,-1
 d00cb14:	3011883a 	mov	r8,r6
 d00cb18:	0007883a 	mov	r3,zero
 d00cb1c:	11801b36 	bltu	r2,r6,d00cb8c <__pack_d+0x2c4>
 d00cb20:	4004963a 	slli	r2,r8,24
 d00cb24:	3808d23a 	srli	r4,r7,8
 d00cb28:	400ad23a 	srli	r5,r8,8
 d00cb2c:	1813883a 	mov	r9,r3
 d00cb30:	1108b03a 	or	r4,r2,r4
 d00cb34:	00bfffc4 	movi	r2,-1
 d00cb38:	00c00434 	movhi	r3,16
 d00cb3c:	18ffffc4 	addi	r3,r3,-1
 d00cb40:	208c703a 	and	r6,r4,r2
 d00cb44:	28ce703a 	and	r7,r5,r3
 d00cb48:	4a01ffcc 	andi	r8,r9,2047
 d00cb4c:	003f7206 	br	d00c918 <__pack_d+0x50>
 d00cb50:	503fe91e 	bne	r10,zero,d00caf8 <__pack_d+0x230>
 d00cb54:	01004004 	movi	r4,256
 d00cb58:	3904703a 	and	r2,r7,r4
 d00cb5c:	0007883a 	mov	r3,zero
 d00cb60:	10c4b03a 	or	r2,r2,r3
 d00cb64:	10000626 	beq	r2,zero,d00cb80 <__pack_d+0x2b8>
 d00cb68:	3a45883a 	add	r2,r7,r9
 d00cb6c:	11cd803a 	cmpltu	r6,r2,r7
 d00cb70:	320d883a 	add	r6,r6,r8
 d00cb74:	100f883a 	mov	r7,r2
 d00cb78:	3011883a 	mov	r8,r6
 d00cb7c:	0007883a 	mov	r3,zero
 d00cb80:	00840034 	movhi	r2,4096
 d00cb84:	10bfffc4 	addi	r2,r2,-1
 d00cb88:	123fe52e 	bgeu	r2,r8,d00cb20 <__pack_d+0x258>
 d00cb8c:	00c00044 	movi	r3,1
 d00cb90:	003fe306 	br	d00cb20 <__pack_d+0x258>
 d00cb94:	0009883a 	mov	r4,zero
 d00cb98:	0013883a 	mov	r9,zero
 d00cb9c:	000b883a 	mov	r5,zero
 d00cba0:	003fe406 	br	d00cb34 <__pack_d+0x26c>
 d00cba4:	4a47883a 	add	r3,r9,r9
 d00cba8:	008007c4 	movi	r2,31
 d00cbac:	1105c83a 	sub	r2,r2,r4
 d00cbb0:	1886983a 	sll	r3,r3,r2
 d00cbb4:	4118d83a 	srl	r12,r8,r4
 d00cbb8:	491ad83a 	srl	r13,r9,r4
 d00cbbc:	1b18b03a 	or	r12,r3,r12
 d00cbc0:	003fb506 	br	d00ca98 <__pack_d+0x1d0>
 d00cbc4:	2806d07a 	srli	r3,r5,1
 d00cbc8:	008007c4 	movi	r2,31
 d00cbcc:	1105c83a 	sub	r2,r2,r4
 d00cbd0:	1896d83a 	srl	r11,r3,r2
 d00cbd4:	2914983a 	sll	r10,r5,r4
 d00cbd8:	003fb506 	br	d00cab0 <__pack_d+0x1e8>

0d00cbdc <__unpack_d>:
 d00cbdc:	20c00117 	ldw	r3,4(r4)
 d00cbe0:	22400017 	ldw	r9,0(r4)
 d00cbe4:	00800434 	movhi	r2,16
 d00cbe8:	10bfffc4 	addi	r2,r2,-1
 d00cbec:	1808d53a 	srli	r4,r3,20
 d00cbf0:	180cd7fa 	srli	r6,r3,31
 d00cbf4:	1894703a 	and	r10,r3,r2
 d00cbf8:	2201ffcc 	andi	r8,r4,2047
 d00cbfc:	281b883a 	mov	r13,r5
 d00cc00:	4817883a 	mov	r11,r9
 d00cc04:	29800115 	stw	r6,4(r5)
 d00cc08:	5019883a 	mov	r12,r10
 d00cc0c:	40001e1e 	bne	r8,zero,d00cc88 <__unpack_d+0xac>
 d00cc10:	4a84b03a 	or	r2,r9,r10
 d00cc14:	10001926 	beq	r2,zero,d00cc7c <__unpack_d+0xa0>
 d00cc18:	4804d63a 	srli	r2,r9,24
 d00cc1c:	500c923a 	slli	r6,r10,8
 d00cc20:	013f0084 	movi	r4,-1022
 d00cc24:	00c40034 	movhi	r3,4096
 d00cc28:	18ffffc4 	addi	r3,r3,-1
 d00cc2c:	118cb03a 	or	r6,r2,r6
 d00cc30:	008000c4 	movi	r2,3
 d00cc34:	480a923a 	slli	r5,r9,8
 d00cc38:	68800015 	stw	r2,0(r13)
 d00cc3c:	69000215 	stw	r4,8(r13)
 d00cc40:	19800b36 	bltu	r3,r6,d00cc70 <__unpack_d+0x94>
 d00cc44:	200f883a 	mov	r7,r4
 d00cc48:	1811883a 	mov	r8,r3
 d00cc4c:	2945883a 	add	r2,r5,r5
 d00cc50:	1149803a 	cmpltu	r4,r2,r5
 d00cc54:	3187883a 	add	r3,r6,r6
 d00cc58:	20c9883a 	add	r4,r4,r3
 d00cc5c:	100b883a 	mov	r5,r2
 d00cc60:	200d883a 	mov	r6,r4
 d00cc64:	39ffffc4 	addi	r7,r7,-1
 d00cc68:	413ff82e 	bgeu	r8,r4,d00cc4c <__unpack_d+0x70>
 d00cc6c:	69c00215 	stw	r7,8(r13)
 d00cc70:	69800415 	stw	r6,16(r13)
 d00cc74:	69400315 	stw	r5,12(r13)
 d00cc78:	f800283a 	ret
 d00cc7c:	00800084 	movi	r2,2
 d00cc80:	28800015 	stw	r2,0(r5)
 d00cc84:	f800283a 	ret
 d00cc88:	0081ffc4 	movi	r2,2047
 d00cc8c:	40800f26 	beq	r8,r2,d00cccc <__unpack_d+0xf0>
 d00cc90:	480cd63a 	srli	r6,r9,24
 d00cc94:	5006923a 	slli	r3,r10,8
 d00cc98:	4804923a 	slli	r2,r9,8
 d00cc9c:	0009883a 	mov	r4,zero
 d00cca0:	30c6b03a 	or	r3,r6,r3
 d00cca4:	01440034 	movhi	r5,4096
 d00cca8:	110cb03a 	or	r6,r2,r4
 d00ccac:	423f0044 	addi	r8,r8,-1023
 d00ccb0:	194eb03a 	or	r7,r3,r5
 d00ccb4:	008000c4 	movi	r2,3
 d00ccb8:	69c00415 	stw	r7,16(r13)
 d00ccbc:	6a000215 	stw	r8,8(r13)
 d00ccc0:	68800015 	stw	r2,0(r13)
 d00ccc4:	69800315 	stw	r6,12(r13)
 d00ccc8:	f800283a 	ret
 d00cccc:	4a84b03a 	or	r2,r9,r10
 d00ccd0:	1000031e 	bne	r2,zero,d00cce0 <__unpack_d+0x104>
 d00ccd4:	00800104 	movi	r2,4
 d00ccd8:	28800015 	stw	r2,0(r5)
 d00ccdc:	f800283a 	ret
 d00cce0:	0009883a 	mov	r4,zero
 d00cce4:	01400234 	movhi	r5,8
 d00cce8:	4904703a 	and	r2,r9,r4
 d00ccec:	5146703a 	and	r3,r10,r5
 d00ccf0:	10c4b03a 	or	r2,r2,r3
 d00ccf4:	10000526 	beq	r2,zero,d00cd0c <__unpack_d+0x130>
 d00ccf8:	00800044 	movi	r2,1
 d00ccfc:	68800015 	stw	r2,0(r13)
 d00cd00:	6b000415 	stw	r12,16(r13)
 d00cd04:	6ac00315 	stw	r11,12(r13)
 d00cd08:	f800283a 	ret
 d00cd0c:	68000015 	stw	zero,0(r13)
 d00cd10:	003ffb06 	br	d00cd00 <__unpack_d+0x124>

0d00cd14 <__fpcmp_parts_d>:
 d00cd14:	21800017 	ldw	r6,0(r4)
 d00cd18:	00c00044 	movi	r3,1
 d00cd1c:	19800a2e 	bgeu	r3,r6,d00cd48 <__fpcmp_parts_d+0x34>
 d00cd20:	28800017 	ldw	r2,0(r5)
 d00cd24:	1880082e 	bgeu	r3,r2,d00cd48 <__fpcmp_parts_d+0x34>
 d00cd28:	00c00104 	movi	r3,4
 d00cd2c:	30c02626 	beq	r6,r3,d00cdc8 <__fpcmp_parts_d+0xb4>
 d00cd30:	10c02226 	beq	r2,r3,d00cdbc <__fpcmp_parts_d+0xa8>
 d00cd34:	00c00084 	movi	r3,2
 d00cd38:	30c00526 	beq	r6,r3,d00cd50 <__fpcmp_parts_d+0x3c>
 d00cd3c:	10c0071e 	bne	r2,r3,d00cd5c <__fpcmp_parts_d+0x48>
 d00cd40:	20800117 	ldw	r2,4(r4)
 d00cd44:	1000091e 	bne	r2,zero,d00cd6c <__fpcmp_parts_d+0x58>
 d00cd48:	00800044 	movi	r2,1
 d00cd4c:	f800283a 	ret
 d00cd50:	10c01a1e 	bne	r2,r3,d00cdbc <__fpcmp_parts_d+0xa8>
 d00cd54:	0005883a 	mov	r2,zero
 d00cd58:	f800283a 	ret
 d00cd5c:	22000117 	ldw	r8,4(r4)
 d00cd60:	28800117 	ldw	r2,4(r5)
 d00cd64:	40800326 	beq	r8,r2,d00cd74 <__fpcmp_parts_d+0x60>
 d00cd68:	403ff726 	beq	r8,zero,d00cd48 <__fpcmp_parts_d+0x34>
 d00cd6c:	00bfffc4 	movi	r2,-1
 d00cd70:	f800283a 	ret
 d00cd74:	20c00217 	ldw	r3,8(r4)
 d00cd78:	28800217 	ldw	r2,8(r5)
 d00cd7c:	10fffa16 	blt	r2,r3,d00cd68 <__fpcmp_parts_d+0x54>
 d00cd80:	18800916 	blt	r3,r2,d00cda8 <__fpcmp_parts_d+0x94>
 d00cd84:	21c00417 	ldw	r7,16(r4)
 d00cd88:	28c00417 	ldw	r3,16(r5)
 d00cd8c:	21800317 	ldw	r6,12(r4)
 d00cd90:	28800317 	ldw	r2,12(r5)
 d00cd94:	19fff436 	bltu	r3,r7,d00cd68 <__fpcmp_parts_d+0x54>
 d00cd98:	38c00526 	beq	r7,r3,d00cdb0 <__fpcmp_parts_d+0x9c>
 d00cd9c:	38c00236 	bltu	r7,r3,d00cda8 <__fpcmp_parts_d+0x94>
 d00cda0:	19ffec1e 	bne	r3,r7,d00cd54 <__fpcmp_parts_d+0x40>
 d00cda4:	30bfeb2e 	bgeu	r6,r2,d00cd54 <__fpcmp_parts_d+0x40>
 d00cda8:	403fe71e 	bne	r8,zero,d00cd48 <__fpcmp_parts_d+0x34>
 d00cdac:	003fef06 	br	d00cd6c <__fpcmp_parts_d+0x58>
 d00cdb0:	11bffa2e 	bgeu	r2,r6,d00cd9c <__fpcmp_parts_d+0x88>
 d00cdb4:	403fe426 	beq	r8,zero,d00cd48 <__fpcmp_parts_d+0x34>
 d00cdb8:	003fec06 	br	d00cd6c <__fpcmp_parts_d+0x58>
 d00cdbc:	28800117 	ldw	r2,4(r5)
 d00cdc0:	103fe11e 	bne	r2,zero,d00cd48 <__fpcmp_parts_d+0x34>
 d00cdc4:	003fe906 	br	d00cd6c <__fpcmp_parts_d+0x58>
 d00cdc8:	11bfdd1e 	bne	r2,r6,d00cd40 <__fpcmp_parts_d+0x2c>
 d00cdcc:	28c00117 	ldw	r3,4(r5)
 d00cdd0:	20800117 	ldw	r2,4(r4)
 d00cdd4:	1885c83a 	sub	r2,r3,r2
 d00cdd8:	f800283a 	ret

0d00cddc <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 d00cddc:	defffb04 	addi	sp,sp,-20
 d00cde0:	dfc00415 	stw	ra,16(sp)
 d00cde4:	df000315 	stw	fp,12(sp)
 d00cde8:	df000304 	addi	fp,sp,12
 d00cdec:	e13ffe15 	stw	r4,-8(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 d00cdf0:	e13ffe17 	ldw	r4,-8(fp)
 d00cdf4:	d1600704 	addi	r5,gp,-32740
 d00cdf8:	d038d0c0 	call	d038d0c <alt_find_dev>
 d00cdfc:	e0bffd15 	stw	r2,-12(fp)

  if ((dev) && dev->open)
 d00ce00:	e0bffd17 	ldw	r2,-12(fp)
 d00ce04:	1005003a 	cmpeq	r2,r2,zero
 d00ce08:	10000b1e 	bne	r2,zero,d00ce38 <alt_flash_open_dev+0x5c>
 d00ce0c:	e0bffd17 	ldw	r2,-12(fp)
 d00ce10:	10800317 	ldw	r2,12(r2)
 d00ce14:	1005003a 	cmpeq	r2,r2,zero
 d00ce18:	1000071e 	bne	r2,zero,d00ce38 <alt_flash_open_dev+0x5c>
  {
    return dev->open(dev, name);
 d00ce1c:	e0bffd17 	ldw	r2,-12(fp)
 d00ce20:	10800317 	ldw	r2,12(r2)
 d00ce24:	e13ffd17 	ldw	r4,-12(fp)
 d00ce28:	e17ffe17 	ldw	r5,-8(fp)
 d00ce2c:	103ee83a 	callr	r2
 d00ce30:	e0bfff15 	stw	r2,-4(fp)
 d00ce34:	00000206 	br	d00ce40 <alt_flash_open_dev+0x64>
  }

  return dev;
 d00ce38:	e0bffd17 	ldw	r2,-12(fp)
 d00ce3c:	e0bfff15 	stw	r2,-4(fp)
 d00ce40:	e0bfff17 	ldw	r2,-4(fp)
}
 d00ce44:	e037883a 	mov	sp,fp
 d00ce48:	dfc00117 	ldw	ra,4(sp)
 d00ce4c:	df000017 	ldw	fp,0(sp)
 d00ce50:	dec00204 	addi	sp,sp,8
 d00ce54:	f800283a 	ret

0d00ce58 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 d00ce58:	defffd04 	addi	sp,sp,-12
 d00ce5c:	dfc00215 	stw	ra,8(sp)
 d00ce60:	df000115 	stw	fp,4(sp)
 d00ce64:	df000104 	addi	fp,sp,4
 d00ce68:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 d00ce6c:	e0bfff17 	ldw	r2,-4(fp)
 d00ce70:	1005003a 	cmpeq	r2,r2,zero
 d00ce74:	1000081e 	bne	r2,zero,d00ce98 <alt_flash_close_dev+0x40>
 d00ce78:	e0bfff17 	ldw	r2,-4(fp)
 d00ce7c:	10800417 	ldw	r2,16(r2)
 d00ce80:	1005003a 	cmpeq	r2,r2,zero
 d00ce84:	1000041e 	bne	r2,zero,d00ce98 <alt_flash_close_dev+0x40>
  {
    fd->close(fd);
 d00ce88:	e0bfff17 	ldw	r2,-4(fp)
 d00ce8c:	10800417 	ldw	r2,16(r2)
 d00ce90:	e13fff17 	ldw	r4,-4(fp)
 d00ce94:	103ee83a 	callr	r2
  }
  return;
}
 d00ce98:	e037883a 	mov	sp,fp
 d00ce9c:	dfc00117 	ldw	ra,4(sp)
 d00cea0:	df000017 	ldw	fp,0(sp)
 d00cea4:	dec00204 	addi	sp,sp,8
 d00cea8:	f800283a 	ret

0d00ceac <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 d00ceac:	defff904 	addi	sp,sp,-28
 d00ceb0:	dfc00615 	stw	ra,24(sp)
 d00ceb4:	df000515 	stw	fp,20(sp)
 d00ceb8:	df000504 	addi	fp,sp,20
 d00cebc:	e13ffc15 	stw	r4,-16(fp)
 d00cec0:	e17ffd15 	stw	r5,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d00cec4:	e0bffc17 	ldw	r2,-16(fp)
 d00cec8:	1004803a 	cmplt	r2,r2,zero
 d00cecc:	1000081e 	bne	r2,zero,d00cef0 <fstat+0x44>
 d00ced0:	e0bffc17 	ldw	r2,-16(fp)
 d00ced4:	10800324 	muli	r2,r2,12
 d00ced8:	1007883a 	mov	r3,r2
 d00cedc:	00834174 	movhi	r2,3333
 d00cee0:	10895d04 	addi	r2,r2,9588
 d00cee4:	1887883a 	add	r3,r3,r2
 d00cee8:	e0ffff15 	stw	r3,-4(fp)
 d00ceec:	00000106 	br	d00cef4 <fstat+0x48>
 d00cef0:	e03fff15 	stw	zero,-4(fp)
 d00cef4:	e0bfff17 	ldw	r2,-4(fp)
 d00cef8:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 d00cefc:	e0bffb17 	ldw	r2,-20(fp)
 d00cf00:	1005003a 	cmpeq	r2,r2,zero
 d00cf04:	1000121e 	bne	r2,zero,d00cf50 <fstat+0xa4>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 d00cf08:	e0bffb17 	ldw	r2,-20(fp)
 d00cf0c:	10800017 	ldw	r2,0(r2)
 d00cf10:	10800817 	ldw	r2,32(r2)
 d00cf14:	1005003a 	cmpeq	r2,r2,zero
 d00cf18:	1000081e 	bne	r2,zero,d00cf3c <fstat+0x90>
    {
      return fd->dev->fstat(fd, st);
 d00cf1c:	e0bffb17 	ldw	r2,-20(fp)
 d00cf20:	10800017 	ldw	r2,0(r2)
 d00cf24:	10800817 	ldw	r2,32(r2)
 d00cf28:	e13ffb17 	ldw	r4,-20(fp)
 d00cf2c:	e17ffd17 	ldw	r5,-12(fp)
 d00cf30:	103ee83a 	callr	r2
 d00cf34:	e0bffe15 	stw	r2,-8(fp)
 d00cf38:	00000b06 	br	d00cf68 <fstat+0xbc>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 d00cf3c:	e0fffd17 	ldw	r3,-12(fp)
 d00cf40:	00880004 	movi	r2,8192
 d00cf44:	18800115 	stw	r2,4(r3)
      return 0;
 d00cf48:	e03ffe15 	stw	zero,-8(fp)
 d00cf4c:	00000606 	br	d00cf68 <fstat+0xbc>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 d00cf50:	d00cf800 	call	d00cf80 <alt_get_errno>
 d00cf54:	1007883a 	mov	r3,r2
 d00cf58:	00801444 	movi	r2,81
 d00cf5c:	18800015 	stw	r2,0(r3)
    return -1;
 d00cf60:	00bfffc4 	movi	r2,-1
 d00cf64:	e0bffe15 	stw	r2,-8(fp)
 d00cf68:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 d00cf6c:	e037883a 	mov	sp,fp
 d00cf70:	dfc00117 	ldw	ra,4(sp)
 d00cf74:	df000017 	ldw	fp,0(sp)
 d00cf78:	dec00204 	addi	sp,sp,8
 d00cf7c:	f800283a 	ret

0d00cf80 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d00cf80:	defffd04 	addi	sp,sp,-12
 d00cf84:	dfc00215 	stw	ra,8(sp)
 d00cf88:	df000115 	stw	fp,4(sp)
 d00cf8c:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d00cf90:	00834174 	movhi	r2,3333
 d00cf94:	108a6804 	addi	r2,r2,10656
 d00cf98:	10800017 	ldw	r2,0(r2)
 d00cf9c:	1005003a 	cmpeq	r2,r2,zero
 d00cfa0:	1000061e 	bne	r2,zero,d00cfbc <alt_get_errno+0x3c>
 d00cfa4:	00834174 	movhi	r2,3333
 d00cfa8:	108a6804 	addi	r2,r2,10656
 d00cfac:	10800017 	ldw	r2,0(r2)
 d00cfb0:	103ee83a 	callr	r2
 d00cfb4:	e0bfff15 	stw	r2,-4(fp)
 d00cfb8:	00000306 	br	d00cfc8 <alt_get_errno+0x48>
 d00cfbc:	00834174 	movhi	r2,3333
 d00cfc0:	108a8404 	addi	r2,r2,10768
 d00cfc4:	e0bfff15 	stw	r2,-4(fp)
 d00cfc8:	e0bfff17 	ldw	r2,-4(fp)
}
 d00cfcc:	e037883a 	mov	sp,fp
 d00cfd0:	dfc00117 	ldw	ra,4(sp)
 d00cfd4:	df000017 	ldw	fp,0(sp)
 d00cfd8:	dec00204 	addi	sp,sp,8
 d00cfdc:	f800283a 	ret

0d00cfe0 <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 d00cfe0:	deffeb04 	addi	sp,sp,-84
 d00cfe4:	dfc01415 	stw	ra,80(sp)
 d00cfe8:	df001315 	stw	fp,76(sp)
 d00cfec:	df001304 	addi	fp,sp,76
 d00cff0:	e13ffd15 	stw	r4,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d00cff4:	e0bffd17 	ldw	r2,-12(fp)
 d00cff8:	1004803a 	cmplt	r2,r2,zero
 d00cffc:	1000081e 	bne	r2,zero,d00d020 <isatty+0x40>
 d00d000:	e0bffd17 	ldw	r2,-12(fp)
 d00d004:	10800324 	muli	r2,r2,12
 d00d008:	1007883a 	mov	r3,r2
 d00d00c:	00834174 	movhi	r2,3333
 d00d010:	10895d04 	addi	r2,r2,9588
 d00d014:	1887883a 	add	r3,r3,r2
 d00d018:	e0ffff15 	stw	r3,-4(fp)
 d00d01c:	00000106 	br	d00d024 <isatty+0x44>
 d00d020:	e03fff15 	stw	zero,-4(fp)
 d00d024:	e0bfff17 	ldw	r2,-4(fp)
 d00d028:	e0bfed15 	stw	r2,-76(fp)
  
  if (fd)
 d00d02c:	e0bfed17 	ldw	r2,-76(fp)
 d00d030:	1005003a 	cmpeq	r2,r2,zero
 d00d034:	10000f1e 	bne	r2,zero,d00d074 <isatty+0x94>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 d00d038:	e0bfed17 	ldw	r2,-76(fp)
 d00d03c:	10800017 	ldw	r2,0(r2)
 d00d040:	10800817 	ldw	r2,32(r2)
 d00d044:	1004c03a 	cmpne	r2,r2,zero
 d00d048:	1000031e 	bne	r2,zero,d00d058 <isatty+0x78>
    {
      return 1;
 d00d04c:	00800044 	movi	r2,1
 d00d050:	e0bffe15 	stw	r2,-8(fp)
 d00d054:	00000c06 	br	d00d088 <isatty+0xa8>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 d00d058:	e17fee04 	addi	r5,fp,-72
 d00d05c:	e13ffd17 	ldw	r4,-12(fp)
 d00d060:	d00ceac0 	call	d00ceac <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 d00d064:	e0bfef17 	ldw	r2,-68(fp)
 d00d068:	10880020 	cmpeqi	r2,r2,8192
 d00d06c:	e0bffe15 	stw	r2,-8(fp)
 d00d070:	00000506 	br	d00d088 <isatty+0xa8>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 d00d074:	d00d0a00 	call	d00d0a0 <alt_get_errno>
 d00d078:	1007883a 	mov	r3,r2
 d00d07c:	00801444 	movi	r2,81
 d00d080:	18800015 	stw	r2,0(r3)
    return 0;
 d00d084:	e03ffe15 	stw	zero,-8(fp)
 d00d088:	e0bffe17 	ldw	r2,-8(fp)
  }
}
 d00d08c:	e037883a 	mov	sp,fp
 d00d090:	dfc00117 	ldw	ra,4(sp)
 d00d094:	df000017 	ldw	fp,0(sp)
 d00d098:	dec00204 	addi	sp,sp,8
 d00d09c:	f800283a 	ret

0d00d0a0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d00d0a0:	defffd04 	addi	sp,sp,-12
 d00d0a4:	dfc00215 	stw	ra,8(sp)
 d00d0a8:	df000115 	stw	fp,4(sp)
 d00d0ac:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d00d0b0:	00834174 	movhi	r2,3333
 d00d0b4:	108a6804 	addi	r2,r2,10656
 d00d0b8:	10800017 	ldw	r2,0(r2)
 d00d0bc:	1005003a 	cmpeq	r2,r2,zero
 d00d0c0:	1000061e 	bne	r2,zero,d00d0dc <alt_get_errno+0x3c>
 d00d0c4:	00834174 	movhi	r2,3333
 d00d0c8:	108a6804 	addi	r2,r2,10656
 d00d0cc:	10800017 	ldw	r2,0(r2)
 d00d0d0:	103ee83a 	callr	r2
 d00d0d4:	e0bfff15 	stw	r2,-4(fp)
 d00d0d8:	00000306 	br	d00d0e8 <alt_get_errno+0x48>
 d00d0dc:	00834174 	movhi	r2,3333
 d00d0e0:	108a8404 	addi	r2,r2,10768
 d00d0e4:	e0bfff15 	stw	r2,-4(fp)
 d00d0e8:	e0bfff17 	ldw	r2,-4(fp)
}
 d00d0ec:	e037883a 	mov	sp,fp
 d00d0f0:	dfc00117 	ldw	ra,4(sp)
 d00d0f4:	df000017 	ldw	fp,0(sp)
 d00d0f8:	dec00204 	addi	sp,sp,8
 d00d0fc:	f800283a 	ret

0d00d100 <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 d00d100:	defff804 	addi	sp,sp,-32
 d00d104:	dfc00715 	stw	ra,28(sp)
 d00d108:	df000615 	stw	fp,24(sp)
 d00d10c:	df000604 	addi	fp,sp,24
 d00d110:	e13ffc15 	stw	r4,-16(fp)
 d00d114:	e17ffd15 	stw	r5,-12(fp)
 d00d118:	e1bffe15 	stw	r6,-8(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 d00d11c:	e03ffa15 	stw	zero,-24(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d00d120:	e0bffc17 	ldw	r2,-16(fp)
 d00d124:	1004803a 	cmplt	r2,r2,zero
 d00d128:	1000081e 	bne	r2,zero,d00d14c <lseek+0x4c>
 d00d12c:	e0bffc17 	ldw	r2,-16(fp)
 d00d130:	10800324 	muli	r2,r2,12
 d00d134:	1007883a 	mov	r3,r2
 d00d138:	00834174 	movhi	r2,3333
 d00d13c:	10895d04 	addi	r2,r2,9588
 d00d140:	1887883a 	add	r3,r3,r2
 d00d144:	e0ffff15 	stw	r3,-4(fp)
 d00d148:	00000106 	br	d00d150 <lseek+0x50>
 d00d14c:	e03fff15 	stw	zero,-4(fp)
 d00d150:	e0bfff17 	ldw	r2,-4(fp)
 d00d154:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd) 
 d00d158:	e0bffb17 	ldw	r2,-20(fp)
 d00d15c:	1005003a 	cmpeq	r2,r2,zero
 d00d160:	1000111e 	bne	r2,zero,d00d1a8 <lseek+0xa8>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 d00d164:	e0bffb17 	ldw	r2,-20(fp)
 d00d168:	10800017 	ldw	r2,0(r2)
 d00d16c:	10800717 	ldw	r2,28(r2)
 d00d170:	1005003a 	cmpeq	r2,r2,zero
 d00d174:	1000091e 	bne	r2,zero,d00d19c <lseek+0x9c>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 d00d178:	e0bffb17 	ldw	r2,-20(fp)
 d00d17c:	10800017 	ldw	r2,0(r2)
 d00d180:	10800717 	ldw	r2,28(r2)
 d00d184:	e13ffb17 	ldw	r4,-20(fp)
 d00d188:	e17ffd17 	ldw	r5,-12(fp)
 d00d18c:	e1bffe17 	ldw	r6,-8(fp)
 d00d190:	103ee83a 	callr	r2
 d00d194:	e0bffa15 	stw	r2,-24(fp)
 d00d198:	00000506 	br	d00d1b0 <lseek+0xb0>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 d00d19c:	00bfde84 	movi	r2,-134
 d00d1a0:	e0bffa15 	stw	r2,-24(fp)
 d00d1a4:	00000206 	br	d00d1b0 <lseek+0xb0>
    }
  }
  else  
  {
    rc = -EBADFD;
 d00d1a8:	00bfebc4 	movi	r2,-81
 d00d1ac:	e0bffa15 	stw	r2,-24(fp)
  }

  if (rc < 0)
 d00d1b0:	e0bffa17 	ldw	r2,-24(fp)
 d00d1b4:	1004403a 	cmpge	r2,r2,zero
 d00d1b8:	1000071e 	bne	r2,zero,d00d1d8 <lseek+0xd8>
  {
    ALT_ERRNO = -rc;
 d00d1bc:	d00d1f00 	call	d00d1f0 <alt_get_errno>
 d00d1c0:	1007883a 	mov	r3,r2
 d00d1c4:	e0bffa17 	ldw	r2,-24(fp)
 d00d1c8:	0085c83a 	sub	r2,zero,r2
 d00d1cc:	18800015 	stw	r2,0(r3)
    rc = -1;
 d00d1d0:	00bfffc4 	movi	r2,-1
 d00d1d4:	e0bffa15 	stw	r2,-24(fp)
  }

  return rc;
 d00d1d8:	e0bffa17 	ldw	r2,-24(fp)
}
 d00d1dc:	e037883a 	mov	sp,fp
 d00d1e0:	dfc00117 	ldw	ra,4(sp)
 d00d1e4:	df000017 	ldw	fp,0(sp)
 d00d1e8:	dec00204 	addi	sp,sp,8
 d00d1ec:	f800283a 	ret

0d00d1f0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d00d1f0:	defffd04 	addi	sp,sp,-12
 d00d1f4:	dfc00215 	stw	ra,8(sp)
 d00d1f8:	df000115 	stw	fp,4(sp)
 d00d1fc:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d00d200:	00834174 	movhi	r2,3333
 d00d204:	108a6804 	addi	r2,r2,10656
 d00d208:	10800017 	ldw	r2,0(r2)
 d00d20c:	1005003a 	cmpeq	r2,r2,zero
 d00d210:	1000061e 	bne	r2,zero,d00d22c <alt_get_errno+0x3c>
 d00d214:	00834174 	movhi	r2,3333
 d00d218:	108a6804 	addi	r2,r2,10656
 d00d21c:	10800017 	ldw	r2,0(r2)
 d00d220:	103ee83a 	callr	r2
 d00d224:	e0bfff15 	stw	r2,-4(fp)
 d00d228:	00000306 	br	d00d238 <alt_get_errno+0x48>
 d00d22c:	00834174 	movhi	r2,3333
 d00d230:	108a8404 	addi	r2,r2,10768
 d00d234:	e0bfff15 	stw	r2,-4(fp)
 d00d238:	e0bfff17 	ldw	r2,-4(fp)
}
 d00d23c:	e037883a 	mov	sp,fp
 d00d240:	dfc00117 	ldw	ra,4(sp)
 d00d244:	df000017 	ldw	fp,0(sp)
 d00d248:	dec00204 	addi	sp,sp,8
 d00d24c:	f800283a 	ret

0d00d250 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 d00d250:	defffb04 	addi	sp,sp,-20
 d00d254:	dfc00415 	stw	ra,16(sp)
 d00d258:	df000315 	stw	fp,12(sp)
 d00d25c:	df000304 	addi	fp,sp,12
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 d00d260:	0009883a 	mov	r4,zero
 d00d264:	d01597c0 	call	d01597c <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 d00d268:	d00dfdc0 	call	d00dfdc <OSInit>
 d00d26c:	01000044 	movi	r4,1
 d00d270:	d012ea00 	call	d012ea0 <OSSemCreate>
 d00d274:	1007883a 	mov	r3,r2
 d00d278:	00834174 	movhi	r2,3333
 d00d27c:	108a8904 	addi	r2,r2,10788
 d00d280:	10c00015 	stw	r3,0(r2)
 d00d284:	01000044 	movi	r4,1
 d00d288:	d012ea00 	call	d012ea0 <OSSemCreate>
 d00d28c:	1007883a 	mov	r3,r2
 d00d290:	00834174 	movhi	r2,3333
 d00d294:	108a8b04 	addi	r2,r2,10796
 d00d298:	10c00015 	stw	r3,0(r2)
 d00d29c:	00834174 	movhi	r2,3333
 d00d2a0:	108ad704 	addi	r2,r2,11100
 d00d2a4:	e0bffd15 	stw	r2,-12(fp)
 d00d2a8:	00800044 	movi	r2,1
 d00d2ac:	e0bffe0d 	sth	r2,-8(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 d00d2b0:	e13ffe0b 	ldhu	r4,-8(fp)
 d00d2b4:	d012ea00 	call	d012ea0 <OSSemCreate>
 d00d2b8:	1007883a 	mov	r3,r2
 d00d2bc:	e0bffd17 	ldw	r2,-12(fp)
 d00d2c0:	10c00015 	stw	r3,0(r2)
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 d00d2c4:	d0159b00 	call	d0159b0 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 d00d2c8:	01034174 	movhi	r4,3333
 d00d2cc:	2131ae04 	addi	r4,r4,-14664
 d00d2d0:	01434174 	movhi	r5,3333
 d00d2d4:	2971ae04 	addi	r5,r5,-14664
 d00d2d8:	01834174 	movhi	r6,3333
 d00d2dc:	31b1ae04 	addi	r6,r6,-14664
 d00d2e0:	d0391300 	call	d039130 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 d00d2e4:	d038c440 	call	d038c44 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 d00d2e8:	01034134 	movhi	r4,3332
 d00d2ec:	21232a04 	addi	r4,r4,-29528
 d00d2f0:	d049e2c0 	call	d049e2c <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 d00d2f4:	d1206417 	ldw	r4,-32368(gp)
 d00d2f8:	d1606517 	ldw	r5,-32364(gp)
 d00d2fc:	d1a06617 	ldw	r6,-32360(gp)
 d00d300:	d000f240 	call	d000f24 <main>
 d00d304:	e0bfff15 	stw	r2,-4(fp)
  close(STDOUT_FILENO);
 d00d308:	01000044 	movi	r4,1
 d00d30c:	d02101c0 	call	d02101c <close>
  exit (result);
 d00d310:	e13fff17 	ldw	r4,-4(fp)
 d00d314:	d049e740 	call	d049e74 <exit>

0d00d318 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 d00d318:	defff804 	addi	sp,sp,-32
 d00d31c:	df000715 	stw	fp,28(sp)
 d00d320:	df000704 	addi	fp,sp,28
 d00d324:	e13ffe15 	stw	r4,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00d328:	0005303a 	rdctl	r2,status
 d00d32c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00d330:	e0fffb17 	ldw	r3,-20(fp)
 d00d334:	00bfff84 	movi	r2,-2
 d00d338:	1884703a 	and	r2,r3,r2
 d00d33c:	1001703a 	wrctl	status,r2
  
  return context;
 d00d340:	e0bffb17 	ldw	r2,-20(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 d00d344:	e0bffd15 	stw	r2,-12(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 d00d348:	d0a00917 	ldw	r2,-32732(gp)
 d00d34c:	10c000c4 	addi	r3,r2,3
 d00d350:	00bfff04 	movi	r2,-4
 d00d354:	1884703a 	and	r2,r3,r2
 d00d358:	d0a00915 	stw	r2,-32732(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 d00d35c:	d0e00917 	ldw	r3,-32732(gp)
 d00d360:	e0bffe17 	ldw	r2,-8(fp)
 d00d364:	1887883a 	add	r3,r3,r2
 d00d368:	00836034 	movhi	r2,3456
 d00d36c:	10800004 	addi	r2,r2,0
 d00d370:	10c0072e 	bgeu	r2,r3,d00d390 <sbrk+0x78>
 d00d374:	e0bffd17 	ldw	r2,-12(fp)
 d00d378:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00d37c:	e0bffa17 	ldw	r2,-24(fp)
 d00d380:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 d00d384:	00bfffc4 	movi	r2,-1
 d00d388:	e0bfff15 	stw	r2,-4(fp)
 d00d38c:	00000c06 	br	d00d3c0 <sbrk+0xa8>
  }
#endif

  prev_heap_end = heap_end; 
 d00d390:	d0a00917 	ldw	r2,-32732(gp)
 d00d394:	e0bffc15 	stw	r2,-16(fp)
  heap_end += incr; 
 d00d398:	d0e00917 	ldw	r3,-32732(gp)
 d00d39c:	e0bffe17 	ldw	r2,-8(fp)
 d00d3a0:	1885883a 	add	r2,r3,r2
 d00d3a4:	d0a00915 	stw	r2,-32732(gp)
 d00d3a8:	e0bffd17 	ldw	r2,-12(fp)
 d00d3ac:	e0bff915 	stw	r2,-28(fp)
 d00d3b0:	e0bff917 	ldw	r2,-28(fp)
 d00d3b4:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 d00d3b8:	e0bffc17 	ldw	r2,-16(fp)
 d00d3bc:	e0bfff15 	stw	r2,-4(fp)
 d00d3c0:	e0bfff17 	ldw	r2,-4(fp)
} 
 d00d3c4:	e037883a 	mov	sp,fp
 d00d3c8:	df000017 	ldw	fp,0(sp)
 d00d3cc:	dec00104 	addi	sp,sp,4
 d00d3d0:	f800283a 	ret

0d00d3d4 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 d00d3d4:	deffdf04 	addi	sp,sp,-132
 d00d3d8:	dfc02015 	stw	ra,128(sp)
 d00d3dc:	df001f15 	stw	fp,124(sp)
 d00d3e0:	df001f04 	addi	fp,sp,124
 d00d3e4:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 d00d3e8:	e17fe204 	addi	r5,fp,-120
 d00d3ec:	01003fc4 	movi	r4,255
 d00d3f0:	d0152280 	call	d015228 <OSTaskQuery>
 d00d3f4:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 d00d3f8:	e0bffe83 	ldbu	r2,-6(fp)
 d00d3fc:	10803fcc 	andi	r2,r2,255
 d00d400:	1004c03a 	cmpne	r2,r2,zero
 d00d404:	1000191e 	bne	r2,zero,d00d46c <__env_lock+0x98>
    return;

  id = tcb.OSTCBPrio;
 d00d408:	e0bfee83 	ldbu	r2,-70(fp)
 d00d40c:	10803fcc 	andi	r2,r2,255
 d00d410:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 d00d414:	d1206817 	ldw	r4,-32352(gp)
 d00d418:	e17ffd04 	addi	r5,fp,-12
 d00d41c:	d0137740 	call	d013774 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 d00d420:	e0bffe43 	ldbu	r2,-7(fp)
 d00d424:	10803fcc 	andi	r2,r2,255
 d00d428:	1005003a 	cmpeq	r2,r2,zero
 d00d42c:	1000071e 	bne	r2,zero,d00d44c <__env_lock+0x78>
 d00d430:	d0e00a17 	ldw	r3,-32728(gp)
 d00d434:	e0bfe117 	ldw	r2,-124(fp)
 d00d438:	10c0041e 	bne	r2,r3,d00d44c <__env_lock+0x78>
  {
    /* we do; just count the recursion */

    locks++;
 d00d43c:	d0a06717 	ldw	r2,-32356(gp)
 d00d440:	10800044 	addi	r2,r2,1
 d00d444:	d0a06715 	stw	r2,-32356(gp)
  id = tcb.OSTCBPrio;
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
  if( semdata.OSEventGrp && id == lockid ) 
 d00d448:	00000806 	br	d00d46c <__env_lock+0x98>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 d00d44c:	d1206817 	ldw	r4,-32352(gp)
 d00d450:	e1bffe84 	addi	r6,fp,-6
 d00d454:	000b883a 	mov	r5,zero
 d00d458:	d0132540 	call	d013254 <OSSemPend>
    locks  = 1;
 d00d45c:	00800044 	movi	r2,1
 d00d460:	d0a06715 	stw	r2,-32356(gp)
    lockid = id;
 d00d464:	e0bfe117 	ldw	r2,-124(fp)
 d00d468:	d0a00a15 	stw	r2,-32728(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 d00d46c:	e037883a 	mov	sp,fp
 d00d470:	dfc00117 	ldw	ra,4(sp)
 d00d474:	df000017 	ldw	fp,0(sp)
 d00d478:	dec00204 	addi	sp,sp,8
 d00d47c:	f800283a 	ret

0d00d480 <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 d00d480:	defffd04 	addi	sp,sp,-12
 d00d484:	dfc00215 	stw	ra,8(sp)
 d00d488:	df000115 	stw	fp,4(sp)
 d00d48c:	df000104 	addi	fp,sp,4
 d00d490:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 d00d494:	d0a06717 	ldw	r2,-32356(gp)
 d00d498:	1005003a 	cmpeq	r2,r2,zero
 d00d49c:	10000a1e 	bne	r2,zero,d00d4c8 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 d00d4a0:	d0a06717 	ldw	r2,-32356(gp)
 d00d4a4:	10bfffc4 	addi	r2,r2,-1
 d00d4a8:	d0a06715 	stw	r2,-32356(gp)
 d00d4ac:	d0a06717 	ldw	r2,-32356(gp)
 d00d4b0:	1004c03a 	cmpne	r2,r2,zero
 d00d4b4:	1000041e 	bne	r2,zero,d00d4c8 <__env_unlock+0x48>
  {
    lockid = -1;
 d00d4b8:	00bfffc4 	movi	r2,-1
 d00d4bc:	d0a00a15 	stw	r2,-32728(gp)
    OSSemPost( alt_envsem );
 d00d4c0:	d1206817 	ldw	r4,-32352(gp)
 d00d4c4:	d01364c0 	call	d01364c <OSSemPost>
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 d00d4c8:	e037883a 	mov	sp,fp
 d00d4cc:	dfc00117 	ldw	ra,4(sp)
 d00d4d0:	df000017 	ldw	fp,0(sp)
 d00d4d4:	dec00204 	addi	sp,sp,8
 d00d4d8:	f800283a 	ret

0d00d4dc <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 d00d4dc:	deffdb04 	addi	sp,sp,-148
 d00d4e0:	dfc02415 	stw	ra,144(sp)
 d00d4e4:	df002315 	stw	fp,140(sp)
 d00d4e8:	df002304 	addi	fp,sp,140
 d00d4ec:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00d4f0:	e03fe015 	stw	zero,-128(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 d00d4f4:	00834174 	movhi	r2,3333
 d00d4f8:	108a8c44 	addi	r2,r2,10801
 d00d4fc:	10800003 	ldbu	r2,0(r2)
 d00d500:	10803fcc 	andi	r2,r2,255
 d00d504:	10800058 	cmpnei	r2,r2,1
 d00d508:	1000311e 	bne	r2,zero,d00d5d0 <__malloc_lock+0xf4>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 d00d50c:	e17fe204 	addi	r5,fp,-120
 d00d510:	01003fc4 	movi	r4,255
 d00d514:	d0152280 	call	d015228 <OSTaskQuery>
 d00d518:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 d00d51c:	e0bffe83 	ldbu	r2,-6(fp)
 d00d520:	10803fcc 	andi	r2,r2,255
 d00d524:	1004c03a 	cmpne	r2,r2,zero
 d00d528:	1000291e 	bne	r2,zero,d00d5d0 <__malloc_lock+0xf4>
    return;

  id = tcb.OSTCBPrio;
 d00d52c:	e0bfee83 	ldbu	r2,-70(fp)
 d00d530:	10803fcc 	andi	r2,r2,255
 d00d534:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 d00d538:	d1206a17 	ldw	r4,-32344(gp)
 d00d53c:	e17ffd04 	addi	r5,fp,-12
 d00d540:	d0137740 	call	d013774 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00d544:	0005303a 	rdctl	r2,status
 d00d548:	e0bfdf15 	stw	r2,-132(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00d54c:	e0ffdf17 	ldw	r3,-132(fp)
 d00d550:	00bfff84 	movi	r2,-2
 d00d554:	1884703a 	and	r2,r3,r2
 d00d558:	1001703a 	wrctl	status,r2
  
  return context;
 d00d55c:	e0bfdf17 	ldw	r2,-132(fp)
  
  OS_ENTER_CRITICAL();
 d00d560:	e0bfe015 	stw	r2,-128(fp)

  if( !semdata.OSCnt && id == lockid ) 
 d00d564:	e0bffd0b 	ldhu	r2,-12(fp)
 d00d568:	10bfffcc 	andi	r2,r2,65535
 d00d56c:	1004c03a 	cmpne	r2,r2,zero
 d00d570:	10000b1e 	bne	r2,zero,d00d5a0 <__malloc_lock+0xc4>
 d00d574:	d0e00b17 	ldw	r3,-32724(gp)
 d00d578:	e0bfe117 	ldw	r2,-124(fp)
 d00d57c:	10c0081e 	bne	r2,r3,d00d5a0 <__malloc_lock+0xc4>
  {
    /* we do; just count the recursion */
    locks++;
 d00d580:	d0a06917 	ldw	r2,-32348(gp)
 d00d584:	10800044 	addi	r2,r2,1
 d00d588:	d0a06915 	stw	r2,-32348(gp)
 d00d58c:	e0bfe017 	ldw	r2,-128(fp)
 d00d590:	e0bfde15 	stw	r2,-136(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00d594:	e0bfde17 	ldw	r2,-136(fp)
 d00d598:	1001703a 	wrctl	status,r2

  OSSemQuery( alt_heapsem, &semdata );
  
  OS_ENTER_CRITICAL();

  if( !semdata.OSCnt && id == lockid ) 
 d00d59c:	00000c06 	br	d00d5d0 <__malloc_lock+0xf4>
 d00d5a0:	e0bfe017 	ldw	r2,-128(fp)
 d00d5a4:	e0bfdd15 	stw	r2,-140(fp)
 d00d5a8:	e0bfdd17 	ldw	r2,-140(fp)
 d00d5ac:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 d00d5b0:	d1206a17 	ldw	r4,-32344(gp)
 d00d5b4:	e1bffe84 	addi	r6,fp,-6
 d00d5b8:	000b883a 	mov	r5,zero
 d00d5bc:	d0132540 	call	d013254 <OSSemPend>
    locks  = 1;
 d00d5c0:	00800044 	movi	r2,1
 d00d5c4:	d0a06915 	stw	r2,-32348(gp)
    lockid = id;
 d00d5c8:	e0bfe117 	ldw	r2,-124(fp)
 d00d5cc:	d0a00b15 	stw	r2,-32724(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 d00d5d0:	e037883a 	mov	sp,fp
 d00d5d4:	dfc00117 	ldw	ra,4(sp)
 d00d5d8:	df000017 	ldw	fp,0(sp)
 d00d5dc:	dec00204 	addi	sp,sp,8
 d00d5e0:	f800283a 	ret

0d00d5e4 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 d00d5e4:	defff804 	addi	sp,sp,-32
 d00d5e8:	dfc00715 	stw	ra,28(sp)
 d00d5ec:	df000615 	stw	fp,24(sp)
 d00d5f0:	df000604 	addi	fp,sp,24
 d00d5f4:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00d5f8:	e03ffe15 	stw	zero,-8(fp)
#endif 

  if (OSRunning != OS_TRUE)
 d00d5fc:	00834174 	movhi	r2,3333
 d00d600:	108a8c44 	addi	r2,r2,10801
 d00d604:	10800003 	ldbu	r2,0(r2)
 d00d608:	10803fcc 	andi	r2,r2,255
 d00d60c:	10800058 	cmpnei	r2,r2,1
 d00d610:	1000231e 	bne	r2,zero,d00d6a0 <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00d614:	0005303a 	rdctl	r2,status
 d00d618:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00d61c:	e0fffd17 	ldw	r3,-12(fp)
 d00d620:	00bfff84 	movi	r2,-2
 d00d624:	1884703a 	and	r2,r3,r2
 d00d628:	1001703a 	wrctl	status,r2
  
  return context;
 d00d62c:	e0bffd17 	ldw	r2,-12(fp)
      return;

  OS_ENTER_CRITICAL();
 d00d630:	e0bffe15 	stw	r2,-8(fp)
  if (locks == 0)
 d00d634:	d0a06917 	ldw	r2,-32348(gp)
 d00d638:	1004c03a 	cmpne	r2,r2,zero
 d00d63c:	1000051e 	bne	r2,zero,d00d654 <__malloc_unlock+0x70>
 d00d640:	e0bffe17 	ldw	r2,-8(fp)
 d00d644:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00d648:	e0bffc17 	ldw	r2,-16(fp)
 d00d64c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 d00d650:	00001306 	br	d00d6a0 <__malloc_unlock+0xbc>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 d00d654:	d0a06917 	ldw	r2,-32348(gp)
 d00d658:	10bfffc4 	addi	r2,r2,-1
 d00d65c:	d0a06915 	stw	r2,-32348(gp)
 d00d660:	d0a06917 	ldw	r2,-32348(gp)
 d00d664:	1004c03a 	cmpne	r2,r2,zero
 d00d668:	1000091e 	bne	r2,zero,d00d690 <__malloc_unlock+0xac>
  {
    lockid = -1;
 d00d66c:	00bfffc4 	movi	r2,-1
 d00d670:	d0a00b15 	stw	r2,-32724(gp)
 d00d674:	e0bffe17 	ldw	r2,-8(fp)
 d00d678:	e0bffb15 	stw	r2,-20(fp)
 d00d67c:	e0bffb17 	ldw	r2,-20(fp)
 d00d680:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 d00d684:	d1206a17 	ldw	r4,-32344(gp)
 d00d688:	d01364c0 	call	d01364c <OSSemPost>
 d00d68c:	00000406 	br	d00d6a0 <__malloc_unlock+0xbc>
 d00d690:	e0bffe17 	ldw	r2,-8(fp)
 d00d694:	e0bffa15 	stw	r2,-24(fp)
 d00d698:	e0bffa17 	ldw	r2,-24(fp)
 d00d69c:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 d00d6a0:	e037883a 	mov	sp,fp
 d00d6a4:	dfc00117 	ldw	ra,4(sp)
 d00d6a8:	df000017 	ldw	fp,0(sp)
 d00d6ac:	dec00204 	addi	sp,sp,8
 d00d6b0:	f800283a 	ret

0d00d6b4 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 d00d6b4:	defff604 	addi	sp,sp,-40
 d00d6b8:	dfc00915 	stw	ra,36(sp)
 d00d6bc:	df000815 	stw	fp,32(sp)
 d00d6c0:	df000804 	addi	fp,sp,32
 d00d6c4:	e13ffc15 	stw	r4,-16(fp)
 d00d6c8:	e17ffd15 	stw	r5,-12(fp)
 d00d6cc:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00d6d0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d00d6d4:	e0bffe17 	ldw	r2,-8(fp)
 d00d6d8:	1004c03a 	cmpne	r2,r2,zero
 d00d6dc:	1000021e 	bne	r2,zero,d00d6e8 <OSEventNameGet+0x34>
        return (0);
 d00d6e0:	e03fff15 	stw	zero,-4(fp)
 d00d6e4:	00003906 	br	d00d7cc <OSEventNameGet+0x118>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 d00d6e8:	e0bffc17 	ldw	r2,-16(fp)
 d00d6ec:	1004c03a 	cmpne	r2,r2,zero
 d00d6f0:	1000051e 	bne	r2,zero,d00d708 <OSEventNameGet+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 d00d6f4:	e0fffe17 	ldw	r3,-8(fp)
 d00d6f8:	00800104 	movi	r2,4
 d00d6fc:	18800005 	stb	r2,0(r3)
        return (0);
 d00d700:	e03fff15 	stw	zero,-4(fp)
 d00d704:	00003106 	br	d00d7cc <OSEventNameGet+0x118>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d00d708:	e0bffd17 	ldw	r2,-12(fp)
 d00d70c:	1004c03a 	cmpne	r2,r2,zero
 d00d710:	1000051e 	bne	r2,zero,d00d728 <OSEventNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 d00d714:	e0fffe17 	ldw	r3,-8(fp)
 d00d718:	00800304 	movi	r2,12
 d00d71c:	18800005 	stb	r2,0(r3)
        return (0);
 d00d720:	e03fff15 	stw	zero,-4(fp)
 d00d724:	00002906 	br	d00d7cc <OSEventNameGet+0x118>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d00d728:	d0a07903 	ldbu	r2,-32284(gp)
 d00d72c:	10803fcc 	andi	r2,r2,255
 d00d730:	1005003a 	cmpeq	r2,r2,zero
 d00d734:	1000051e 	bne	r2,zero,d00d74c <OSEventNameGet+0x98>
        *perr  = OS_ERR_NAME_GET_ISR;
 d00d738:	e0fffe17 	ldw	r3,-8(fp)
 d00d73c:	00800444 	movi	r2,17
 d00d740:	18800005 	stb	r2,0(r3)
        return (0);
 d00d744:	e03fff15 	stw	zero,-4(fp)
 d00d748:	00002006 	br	d00d7cc <OSEventNameGet+0x118>
    }
    switch (pevent->OSEventType) {
 d00d74c:	e0bffc17 	ldw	r2,-16(fp)
 d00d750:	10800003 	ldbu	r2,0(r2)
 d00d754:	10803fcc 	andi	r2,r2,255
 d00d758:	10bfffc4 	addi	r2,r2,-1
 d00d75c:	10800128 	cmpgeui	r2,r2,4
 d00d760:	1000161e 	bne	r2,zero,d00d7bc <OSEventNameGet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00d764:	0005303a 	rdctl	r2,status
 d00d768:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00d76c:	e0fff917 	ldw	r3,-28(fp)
 d00d770:	00bfff84 	movi	r2,-2
 d00d774:	1884703a 	and	r2,r3,r2
 d00d778:	1001703a 	wrctl	status,r2
  
  return context;
 d00d77c:	e0bff917 	ldw	r2,-28(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 d00d780:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 d00d784:	e0bffc17 	ldw	r2,-16(fp)
 d00d788:	11400384 	addi	r5,r2,14
 d00d78c:	e13ffd17 	ldw	r4,-12(fp)
 d00d790:	d00f2380 	call	d00f238 <OS_StrCopy>
 d00d794:	e0bffb05 	stb	r2,-20(fp)
 d00d798:	e0bffa17 	ldw	r2,-24(fp)
 d00d79c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00d7a0:	e0bff817 	ldw	r2,-32(fp)
 d00d7a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d00d7a8:	e0bffe17 	ldw	r2,-8(fp)
 d00d7ac:	10000005 	stb	zero,0(r2)
    return (len);
 d00d7b0:	e0bffb03 	ldbu	r2,-20(fp)
 d00d7b4:	e0bfff15 	stw	r2,-4(fp)
 d00d7b8:	00000406 	br	d00d7cc <OSEventNameGet+0x118>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 d00d7bc:	e0fffe17 	ldw	r3,-8(fp)
 d00d7c0:	00800044 	movi	r2,1
 d00d7c4:	18800005 	stb	r2,0(r3)
             return (0);
 d00d7c8:	e03fff15 	stw	zero,-4(fp)
 d00d7cc:	e0bfff17 	ldw	r2,-4(fp)
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
 d00d7d0:	e037883a 	mov	sp,fp
 d00d7d4:	dfc00117 	ldw	ra,4(sp)
 d00d7d8:	df000017 	ldw	fp,0(sp)
 d00d7dc:	dec00204 	addi	sp,sp,8
 d00d7e0:	f800283a 	ret

0d00d7e4 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 d00d7e4:	defff604 	addi	sp,sp,-40
 d00d7e8:	dfc00915 	stw	ra,36(sp)
 d00d7ec:	df000815 	stw	fp,32(sp)
 d00d7f0:	df000804 	addi	fp,sp,32
 d00d7f4:	e13ffd15 	stw	r4,-12(fp)
 d00d7f8:	e17ffe15 	stw	r5,-8(fp)
 d00d7fc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00d800:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d00d804:	e0bfff17 	ldw	r2,-4(fp)
 d00d808:	1005003a 	cmpeq	r2,r2,zero
 d00d80c:	1000411e 	bne	r2,zero,d00d914 <OSEventNameSet+0x130>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 d00d810:	e0bffd17 	ldw	r2,-12(fp)
 d00d814:	1004c03a 	cmpne	r2,r2,zero
 d00d818:	1000041e 	bne	r2,zero,d00d82c <OSEventNameSet+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 d00d81c:	e0ffff17 	ldw	r3,-4(fp)
 d00d820:	00800104 	movi	r2,4
 d00d824:	18800005 	stb	r2,0(r3)
        return;
 d00d828:	00003a06 	br	d00d914 <OSEventNameSet+0x130>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d00d82c:	e0bffe17 	ldw	r2,-8(fp)
 d00d830:	1004c03a 	cmpne	r2,r2,zero
 d00d834:	1000041e 	bne	r2,zero,d00d848 <OSEventNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 d00d838:	e0ffff17 	ldw	r3,-4(fp)
 d00d83c:	00800304 	movi	r2,12
 d00d840:	18800005 	stb	r2,0(r3)
        return;
 d00d844:	00003306 	br	d00d914 <OSEventNameSet+0x130>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d00d848:	d0a07903 	ldbu	r2,-32284(gp)
 d00d84c:	10803fcc 	andi	r2,r2,255
 d00d850:	1005003a 	cmpeq	r2,r2,zero
 d00d854:	1000041e 	bne	r2,zero,d00d868 <OSEventNameSet+0x84>
        *perr = OS_ERR_NAME_SET_ISR;
 d00d858:	e0ffff17 	ldw	r3,-4(fp)
 d00d85c:	00800484 	movi	r2,18
 d00d860:	18800005 	stb	r2,0(r3)
        return;
 d00d864:	00002b06 	br	d00d914 <OSEventNameSet+0x130>
    }
    switch (pevent->OSEventType) {
 d00d868:	e0bffd17 	ldw	r2,-12(fp)
 d00d86c:	10800003 	ldbu	r2,0(r2)
 d00d870:	10803fcc 	andi	r2,r2,255
 d00d874:	10bfffc4 	addi	r2,r2,-1
 d00d878:	10800128 	cmpgeui	r2,r2,4
 d00d87c:	10000f1e 	bne	r2,zero,d00d8bc <OSEventNameSet+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00d880:	0005303a 	rdctl	r2,status
 d00d884:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00d888:	e0fffa17 	ldw	r3,-24(fp)
 d00d88c:	00bfff84 	movi	r2,-2
 d00d890:	1884703a 	and	r2,r3,r2
 d00d894:	1001703a 	wrctl	status,r2
  
  return context;
 d00d898:	e0bffa17 	ldw	r2,-24(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 d00d89c:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 d00d8a0:	e13ffe17 	ldw	r4,-8(fp)
 d00d8a4:	d00f2b80 	call	d00f2b8 <OS_StrLen>
 d00d8a8:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 d00d8ac:	e0bffc03 	ldbu	r2,-16(fp)
 d00d8b0:	10800828 	cmpgeui	r2,r2,32
 d00d8b4:	1000051e 	bne	r2,zero,d00d8cc <OSEventNameSet+0xe8>
 d00d8b8:	00000c06 	br	d00d8ec <OSEventNameSet+0x108>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 d00d8bc:	e0ffff17 	ldw	r3,-4(fp)
 d00d8c0:	00800044 	movi	r2,1
 d00d8c4:	18800005 	stb	r2,0(r3)
             return;
 d00d8c8:	00001206 	br	d00d914 <OSEventNameSet+0x130>
 d00d8cc:	e0bffb17 	ldw	r2,-20(fp)
 d00d8d0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00d8d4:	e0bff917 	ldw	r2,-28(fp)
 d00d8d8:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 d00d8dc:	e0ffff17 	ldw	r3,-4(fp)
 d00d8e0:	008002c4 	movi	r2,11
 d00d8e4:	18800005 	stb	r2,0(r3)
        return;
 d00d8e8:	00000a06 	br	d00d914 <OSEventNameSet+0x130>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 d00d8ec:	e0bffd17 	ldw	r2,-12(fp)
 d00d8f0:	11000384 	addi	r4,r2,14
 d00d8f4:	e17ffe17 	ldw	r5,-8(fp)
 d00d8f8:	d00f2380 	call	d00f238 <OS_StrCopy>
 d00d8fc:	e0bffb17 	ldw	r2,-20(fp)
 d00d900:	e0bff815 	stw	r2,-32(fp)
 d00d904:	e0bff817 	ldw	r2,-32(fp)
 d00d908:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d00d90c:	e0bfff17 	ldw	r2,-4(fp)
 d00d910:	10000005 	stb	zero,0(r2)
}
 d00d914:	e037883a 	mov	sp,fp
 d00d918:	dfc00117 	ldw	ra,4(sp)
 d00d91c:	df000017 	ldw	fp,0(sp)
 d00d920:	dec00204 	addi	sp,sp,8
 d00d924:	f800283a 	ret

0d00d928 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 d00d928:	deffe704 	addi	sp,sp,-100
 d00d92c:	dfc01815 	stw	ra,96(sp)
 d00d930:	df001715 	stw	fp,92(sp)
 d00d934:	df001704 	addi	fp,sp,92
 d00d938:	e13ff615 	stw	r4,-40(fp)
 d00d93c:	e17ff715 	stw	r5,-36(fp)
 d00d940:	e1bff815 	stw	r6,-32(fp)
 d00d944:	e1fff90d 	sth	r7,-28(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 d00d948:	e03ff015 	stw	zero,-64(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 d00d94c:	e0800217 	ldw	r2,8(fp)
 d00d950:	1004c03a 	cmpne	r2,r2,zero
 d00d954:	1000021e 	bne	r2,zero,d00d960 <OSEventPendMulti+0x38>
        return (0);
 d00d958:	e03fff15 	stw	zero,-4(fp)
 d00d95c:	00019906 	br	d00dfc4 <OSEventPendMulti+0x69c>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 d00d960:	e0bff617 	ldw	r2,-40(fp)
 d00d964:	1004c03a 	cmpne	r2,r2,zero
 d00d968:	1000051e 	bne	r2,zero,d00d980 <OSEventPendMulti+0x58>
       *perr =  OS_ERR_PEVENT_NULL;
 d00d96c:	e0c00217 	ldw	r3,8(fp)
 d00d970:	00800104 	movi	r2,4
 d00d974:	18800005 	stb	r2,0(r3)
        return (0);
 d00d978:	e03fff15 	stw	zero,-4(fp)
 d00d97c:	00019106 	br	d00dfc4 <OSEventPendMulti+0x69c>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 d00d980:	e0bff717 	ldw	r2,-36(fp)
 d00d984:	1004c03a 	cmpne	r2,r2,zero
 d00d988:	1000051e 	bne	r2,zero,d00d9a0 <OSEventPendMulti+0x78>
       *perr =  OS_ERR_PEVENT_NULL;
 d00d98c:	e0c00217 	ldw	r3,8(fp)
 d00d990:	00800104 	movi	r2,4
 d00d994:	18800005 	stb	r2,0(r3)
        return (0);
 d00d998:	e03fff15 	stw	zero,-4(fp)
 d00d99c:	00018906 	br	d00dfc4 <OSEventPendMulti+0x69c>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 d00d9a0:	e0bff817 	ldw	r2,-32(fp)
 d00d9a4:	1004c03a 	cmpne	r2,r2,zero
 d00d9a8:	1000051e 	bne	r2,zero,d00d9c0 <OSEventPendMulti+0x98>
       *perr =  OS_ERR_PEVENT_NULL;
 d00d9ac:	e0c00217 	ldw	r3,8(fp)
 d00d9b0:	00800104 	movi	r2,4
 d00d9b4:	18800005 	stb	r2,0(r3)
        return (0);
 d00d9b8:	e03fff15 	stw	zero,-4(fp)
 d00d9bc:	00018106 	br	d00dfc4 <OSEventPendMulti+0x69c>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 d00d9c0:	e0bff717 	ldw	r2,-36(fp)
 d00d9c4:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 d00d9c8:	e0bff617 	ldw	r2,-40(fp)
 d00d9cc:	e0bff515 	stw	r2,-44(fp)
    pevent      = *pevents;
 d00d9d0:	e0bff517 	ldw	r2,-44(fp)
 d00d9d4:	10800017 	ldw	r2,0(r2)
 d00d9d8:	e0bff415 	stw	r2,-48(fp)
    while  (pevent != (OS_EVENT *)0) {
 d00d9dc:	00001806 	br	d00da40 <OSEventPendMulti+0x118>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 d00d9e0:	e0bff417 	ldw	r2,-48(fp)
 d00d9e4:	10800003 	ldbu	r2,0(r2)
 d00d9e8:	10803fcc 	andi	r2,r2,255
 d00d9ec:	e0bffe15 	stw	r2,-8(fp)
 d00d9f0:	e0fffe17 	ldw	r3,-8(fp)
 d00d9f4:	188000a0 	cmpeqi	r2,r3,2
 d00d9f8:	10000b1e 	bne	r2,zero,d00da28 <OSEventPendMulti+0x100>
 d00d9fc:	e0fffe17 	ldw	r3,-8(fp)
 d00da00:	188000e0 	cmpeqi	r2,r3,3
 d00da04:	1000081e 	bne	r2,zero,d00da28 <OSEventPendMulti+0x100>
 d00da08:	e0fffe17 	ldw	r3,-8(fp)
 d00da0c:	18800060 	cmpeqi	r2,r3,1
 d00da10:	1000051e 	bne	r2,zero,d00da28 <OSEventPendMulti+0x100>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 d00da14:	e0c00217 	ldw	r3,8(fp)
 d00da18:	00800044 	movi	r2,1
 d00da1c:	18800005 	stb	r2,0(r3)
                 return (0);
 d00da20:	e03fff15 	stw	zero,-4(fp)
 d00da24:	00016706 	br	d00dfc4 <OSEventPendMulti+0x69c>
        }
        pevents++;
 d00da28:	e0bff517 	ldw	r2,-44(fp)
 d00da2c:	10800104 	addi	r2,r2,4
 d00da30:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 d00da34:	e0bff517 	ldw	r2,-44(fp)
 d00da38:	10800017 	ldw	r2,0(r2)
 d00da3c:	e0bff415 	stw	r2,-48(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 d00da40:	e0bff417 	ldw	r2,-48(fp)
 d00da44:	1004c03a 	cmpne	r2,r2,zero
 d00da48:	103fe51e 	bne	r2,zero,d00d9e0 <OSEventPendMulti+0xb8>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 d00da4c:	d0a07903 	ldbu	r2,-32284(gp)
 d00da50:	10803fcc 	andi	r2,r2,255
 d00da54:	1005003a 	cmpeq	r2,r2,zero
 d00da58:	1000051e 	bne	r2,zero,d00da70 <OSEventPendMulti+0x148>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 d00da5c:	e0c00217 	ldw	r3,8(fp)
 d00da60:	00800084 	movi	r2,2
 d00da64:	18800005 	stb	r2,0(r3)
        return (0);
 d00da68:	e03fff15 	stw	zero,-4(fp)
 d00da6c:	00015506 	br	d00dfc4 <OSEventPendMulti+0x69c>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 d00da70:	d0a06b03 	ldbu	r2,-32340(gp)
 d00da74:	10803fcc 	andi	r2,r2,255
 d00da78:	1005003a 	cmpeq	r2,r2,zero
 d00da7c:	1000051e 	bne	r2,zero,d00da94 <OSEventPendMulti+0x16c>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 d00da80:	e0c00217 	ldw	r3,8(fp)
 d00da84:	00800344 	movi	r2,13
 d00da88:	18800005 	stb	r2,0(r3)
        return (0);
 d00da8c:	e03fff15 	stw	zero,-4(fp)
 d00da90:	00014c06 	br	d00dfc4 <OSEventPendMulti+0x69c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00da94:	0005303a 	rdctl	r2,status
 d00da98:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00da9c:	e0ffef17 	ldw	r3,-68(fp)
 d00daa0:	00bfff84 	movi	r2,-2
 d00daa4:	1884703a 	and	r2,r3,r2
 d00daa8:	1001703a 	wrctl	status,r2
  
  return context;
 d00daac:	e0bfef17 	ldw	r2,-68(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 d00dab0:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
 d00dab4:	e03ff205 	stb	zero,-56(fp)
    events_rdy_nbr =  0;
 d00dab8:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 d00dabc:	e03ff105 	stb	zero,-60(fp)
    pevents        =  pevents_pend;
 d00dac0:	e0bff617 	ldw	r2,-40(fp)
 d00dac4:	e0bff515 	stw	r2,-44(fp)
    pevent         = *pevents;
 d00dac8:	e0bff517 	ldw	r2,-44(fp)
 d00dacc:	10800017 	ldw	r2,0(r2)
 d00dad0:	e0bff415 	stw	r2,-48(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 d00dad4:	00008f06 	br	d00dd14 <OSEventPendMulti+0x3ec>
        switch (pevent->OSEventType) {
 d00dad8:	e0bff417 	ldw	r2,-48(fp)
 d00dadc:	10800003 	ldbu	r2,0(r2)
 d00dae0:	10803fcc 	andi	r2,r2,255
 d00dae4:	e0bffd15 	stw	r2,-12(fp)
 d00dae8:	e0fffd17 	ldw	r3,-12(fp)
 d00daec:	188000a0 	cmpeqi	r2,r3,2
 d00daf0:	1000441e 	bne	r2,zero,d00dc04 <OSEventPendMulti+0x2dc>
 d00daf4:	e0fffd17 	ldw	r3,-12(fp)
 d00daf8:	188000e0 	cmpeqi	r2,r3,3
 d00dafc:	1000041e 	bne	r2,zero,d00db10 <OSEventPendMulti+0x1e8>
 d00db00:	e0fffd17 	ldw	r3,-12(fp)
 d00db04:	18800060 	cmpeqi	r2,r3,1
 d00db08:	1000211e 	bne	r2,zero,d00db90 <OSEventPendMulti+0x268>
 d00db0c:	00006f06 	br	d00dccc <OSEventPendMulti+0x3a4>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 d00db10:	e0bff417 	ldw	r2,-48(fp)
 d00db14:	1080020b 	ldhu	r2,8(r2)
 d00db18:	10bfffcc 	andi	r2,r2,65535
 d00db1c:	1005003a 	cmpeq	r2,r2,zero
 d00db20:	1000171e 	bne	r2,zero,d00db80 <OSEventPendMulti+0x258>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 d00db24:	e0bff417 	ldw	r2,-48(fp)
 d00db28:	1080020b 	ldhu	r2,8(r2)
 d00db2c:	10bfffc4 	addi	r2,r2,-1
 d00db30:	1007883a 	mov	r3,r2
 d00db34:	e0bff417 	ldw	r2,-48(fp)
 d00db38:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 d00db3c:	e0fff717 	ldw	r3,-36(fp)
 d00db40:	e0bff417 	ldw	r2,-48(fp)
 d00db44:	18800015 	stw	r2,0(r3)
 d00db48:	e0bff717 	ldw	r2,-36(fp)
 d00db4c:	10800104 	addi	r2,r2,4
 d00db50:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   =  OS_TRUE;
 d00db54:	00800044 	movi	r2,1
 d00db58:	e0bff205 	stb	r2,-56(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 d00db5c:	e0bff817 	ldw	r2,-32(fp)
 d00db60:	10000015 	stw	zero,0(r2)
 d00db64:	e0bff817 	ldw	r2,-32(fp)
 d00db68:	10800104 	addi	r2,r2,4
 d00db6c:	e0bff815 	stw	r2,-32(fp)
                      events_rdy_nbr++;
 d00db70:	e0bff18b 	ldhu	r2,-58(fp)
 d00db74:	10800044 	addi	r2,r2,1
 d00db78:	e0bff18d 	sth	r2,-58(fp)
 d00db7c:	00005f06 	br	d00dcfc <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 d00db80:	e0bff103 	ldbu	r2,-60(fp)
 d00db84:	10800054 	ori	r2,r2,1
 d00db88:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 d00db8c:	00005b06 	br	d00dcfc <OSEventPendMulti+0x3d4>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 d00db90:	e0bff417 	ldw	r2,-48(fp)
 d00db94:	10800117 	ldw	r2,4(r2)
 d00db98:	1005003a 	cmpeq	r2,r2,zero
 d00db9c:	1000151e 	bne	r2,zero,d00dbf4 <OSEventPendMulti+0x2cc>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 d00dba0:	e0bff417 	ldw	r2,-48(fp)
 d00dba4:	10c00117 	ldw	r3,4(r2)
 d00dba8:	e0bff817 	ldw	r2,-32(fp)
 d00dbac:	10c00015 	stw	r3,0(r2)
 d00dbb0:	e0bff817 	ldw	r2,-32(fp)
 d00dbb4:	10800104 	addi	r2,r2,4
 d00dbb8:	e0bff815 	stw	r2,-32(fp)
                     pevent->OSEventPtr  = (void *)0;
 d00dbbc:	e0bff417 	ldw	r2,-48(fp)
 d00dbc0:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 d00dbc4:	e0fff717 	ldw	r3,-36(fp)
 d00dbc8:	e0bff417 	ldw	r2,-48(fp)
 d00dbcc:	18800015 	stw	r2,0(r3)
 d00dbd0:	e0bff717 	ldw	r2,-36(fp)
 d00dbd4:	10800104 	addi	r2,r2,4
 d00dbd8:	e0bff715 	stw	r2,-36(fp)
                      events_rdy         =  OS_TRUE;
 d00dbdc:	00800044 	movi	r2,1
 d00dbe0:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 d00dbe4:	e0bff18b 	ldhu	r2,-58(fp)
 d00dbe8:	10800044 	addi	r2,r2,1
 d00dbec:	e0bff18d 	sth	r2,-58(fp)
 d00dbf0:	00004206 	br	d00dcfc <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 d00dbf4:	e0bff103 	ldbu	r2,-60(fp)
 d00dbf8:	10800094 	ori	r2,r2,2
 d00dbfc:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 d00dc00:	00003e06 	br	d00dcfc <OSEventPendMulti+0x3d4>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 d00dc04:	e0bff417 	ldw	r2,-48(fp)
 d00dc08:	10800117 	ldw	r2,4(r2)
 d00dc0c:	e0bff315 	stw	r2,-52(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 d00dc10:	e0bff317 	ldw	r2,-52(fp)
 d00dc14:	1080058b 	ldhu	r2,22(r2)
 d00dc18:	10bfffcc 	andi	r2,r2,65535
 d00dc1c:	1005003a 	cmpeq	r2,r2,zero
 d00dc20:	1000261e 	bne	r2,zero,d00dcbc <OSEventPendMulti+0x394>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 d00dc24:	e0bff317 	ldw	r2,-52(fp)
 d00dc28:	11000417 	ldw	r4,16(r2)
 d00dc2c:	20c00017 	ldw	r3,0(r4)
 d00dc30:	e0bff817 	ldw	r2,-32(fp)
 d00dc34:	10c00015 	stw	r3,0(r2)
 d00dc38:	e0bff817 	ldw	r2,-32(fp)
 d00dc3c:	10800104 	addi	r2,r2,4
 d00dc40:	e0bff815 	stw	r2,-32(fp)
 d00dc44:	20c00104 	addi	r3,r4,4
 d00dc48:	e0bff317 	ldw	r2,-52(fp)
 d00dc4c:	10c00415 	stw	r3,16(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 d00dc50:	e0bff317 	ldw	r2,-52(fp)
 d00dc54:	10c00417 	ldw	r3,16(r2)
 d00dc58:	e0bff317 	ldw	r2,-52(fp)
 d00dc5c:	10800217 	ldw	r2,8(r2)
 d00dc60:	1880041e 	bne	r3,r2,d00dc74 <OSEventPendMulti+0x34c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 d00dc64:	e0bff317 	ldw	r2,-52(fp)
 d00dc68:	10c00117 	ldw	r3,4(r2)
 d00dc6c:	e0bff317 	ldw	r2,-52(fp)
 d00dc70:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 d00dc74:	e0bff317 	ldw	r2,-52(fp)
 d00dc78:	1080058b 	ldhu	r2,22(r2)
 d00dc7c:	10bfffc4 	addi	r2,r2,-1
 d00dc80:	1007883a 	mov	r3,r2
 d00dc84:	e0bff317 	ldw	r2,-52(fp)
 d00dc88:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 d00dc8c:	e0fff717 	ldw	r3,-36(fp)
 d00dc90:	e0bff417 	ldw	r2,-48(fp)
 d00dc94:	18800015 	stw	r2,0(r3)
 d00dc98:	e0bff717 	ldw	r2,-36(fp)
 d00dc9c:	10800104 	addi	r2,r2,4
 d00dca0:	e0bff715 	stw	r2,-36(fp)
                      events_rdy   = OS_TRUE;
 d00dca4:	00800044 	movi	r2,1
 d00dca8:	e0bff205 	stb	r2,-56(fp)
                      events_rdy_nbr++;
 d00dcac:	e0bff18b 	ldhu	r2,-58(fp)
 d00dcb0:	10800044 	addi	r2,r2,1
 d00dcb4:	e0bff18d 	sth	r2,-58(fp)
 d00dcb8:	00001006 	br	d00dcfc <OSEventPendMulti+0x3d4>

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 d00dcbc:	e0bff103 	ldbu	r2,-60(fp)
 d00dcc0:	10800114 	ori	r2,r2,4
 d00dcc4:	e0bff105 	stb	r2,-60(fp)
                 }
                 break;
 d00dcc8:	00000c06 	br	d00dcfc <OSEventPendMulti+0x3d4>
 d00dccc:	e0bff017 	ldw	r2,-64(fp)
 d00dcd0:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00dcd4:	e0bfee17 	ldw	r2,-72(fp)
 d00dcd8:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 d00dcdc:	e0bff717 	ldw	r2,-36(fp)
 d00dce0:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 d00dce4:	e0c00217 	ldw	r3,8(fp)
 d00dce8:	00800044 	movi	r2,1
 d00dcec:	18800005 	stb	r2,0(r3)
                 return (events_rdy_nbr);
 d00dcf0:	e0bff18b 	ldhu	r2,-58(fp)
 d00dcf4:	e0bfff15 	stw	r2,-4(fp)
 d00dcf8:	0000b206 	br	d00dfc4 <OSEventPendMulti+0x69c>
        }
        pevents++;
 d00dcfc:	e0bff517 	ldw	r2,-44(fp)
 d00dd00:	10800104 	addi	r2,r2,4
 d00dd04:	e0bff515 	stw	r2,-44(fp)
        pevent = *pevents;
 d00dd08:	e0bff517 	ldw	r2,-44(fp)
 d00dd0c:	10800017 	ldw	r2,0(r2)
 d00dd10:	e0bff415 	stw	r2,-48(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 d00dd14:	e0bff417 	ldw	r2,-48(fp)
 d00dd18:	1004c03a 	cmpne	r2,r2,zero
 d00dd1c:	103f6e1e 	bne	r2,zero,d00dad8 <OSEventPendMulti+0x1b0>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 d00dd20:	e0bff203 	ldbu	r2,-56(fp)
 d00dd24:	10800058 	cmpnei	r2,r2,1
 d00dd28:	10000b1e 	bne	r2,zero,d00dd58 <OSEventPendMulti+0x430>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 d00dd2c:	e0bff717 	ldw	r2,-36(fp)
 d00dd30:	10000015 	stw	zero,0(r2)
 d00dd34:	e0bff017 	ldw	r2,-64(fp)
 d00dd38:	e0bfed15 	stw	r2,-76(fp)
 d00dd3c:	e0bfed17 	ldw	r2,-76(fp)
 d00dd40:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 d00dd44:	e0800217 	ldw	r2,8(fp)
 d00dd48:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 d00dd4c:	e0fff18b 	ldhu	r3,-58(fp)
 d00dd50:	e0ffff15 	stw	r3,-4(fp)
 d00dd54:	00009b06 	br	d00dfc4 <OSEventPendMulti+0x69c>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 d00dd58:	d1207a17 	ldw	r4,-32280(gp)
 d00dd5c:	d0a07a17 	ldw	r2,-32280(gp)
 d00dd60:	10c00c03 	ldbu	r3,48(r2)
 d00dd64:	e0bff103 	ldbu	r2,-60(fp)
 d00dd68:	1884b03a 	or	r2,r3,r2
 d00dd6c:	1007883a 	mov	r3,r2
 d00dd70:	00bfe004 	movi	r2,-128
 d00dd74:	1884b03a 	or	r2,r3,r2
 d00dd78:	20800c05 	stb	r2,48(r4)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 d00dd7c:	d0a07a17 	ldw	r2,-32280(gp)
 d00dd80:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 d00dd84:	d0e07a17 	ldw	r3,-32280(gp)
 d00dd88:	e0bff90b 	ldhu	r2,-28(fp)
 d00dd8c:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 d00dd90:	e13ff617 	ldw	r4,-40(fp)
 d00dd94:	d00e9580 	call	d00e958 <OS_EventTaskWaitMulti>
 d00dd98:	e0bff017 	ldw	r2,-64(fp)
 d00dd9c:	e0bfec15 	stw	r2,-80(fp)
 d00dda0:	e0bfec17 	ldw	r2,-80(fp)
 d00dda4:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 d00dda8:	d00f0f40 	call	d00f0f4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00ddac:	0005303a 	rdctl	r2,status
 d00ddb0:	e0bfeb15 	stw	r2,-84(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00ddb4:	e0ffeb17 	ldw	r3,-84(fp)
 d00ddb8:	00bfff84 	movi	r2,-2
 d00ddbc:	1884703a 	and	r2,r3,r2
 d00ddc0:	1001703a 	wrctl	status,r2
  
  return context;
 d00ddc4:	e0bfeb17 	ldw	r2,-84(fp)
    OS_ENTER_CRITICAL();
 d00ddc8:	e0bff015 	stw	r2,-64(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 d00ddcc:	d0a07a17 	ldw	r2,-32280(gp)
 d00ddd0:	10800c43 	ldbu	r2,49(r2)
 d00ddd4:	10803fcc 	andi	r2,r2,255
 d00ddd8:	e0bffc15 	stw	r2,-16(fp)
 d00dddc:	e0fffc17 	ldw	r3,-16(fp)
 d00dde0:	1805003a 	cmpeq	r2,r3,zero
 d00dde4:	1000041e 	bne	r2,zero,d00ddf8 <OSEventPendMulti+0x4d0>
 d00dde8:	e0fffc17 	ldw	r3,-16(fp)
 d00ddec:	188000a0 	cmpeqi	r2,r3,2
 d00ddf0:	1000011e 	bne	r2,zero,d00ddf8 <OSEventPendMulti+0x4d0>
 d00ddf4:	00001906 	br	d00de5c <OSEventPendMulti+0x534>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 d00ddf8:	d0a07a17 	ldw	r2,-32280(gp)
 d00ddfc:	10800717 	ldw	r2,28(r2)
 d00de00:	e0bff415 	stw	r2,-48(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 d00de04:	e0bff417 	ldw	r2,-48(fp)
 d00de08:	1005003a 	cmpeq	r2,r2,zero
 d00de0c:	10000c1e 	bne	r2,zero,d00de40 <OSEventPendMulti+0x518>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 d00de10:	e0fff717 	ldw	r3,-36(fp)
 d00de14:	e0bff417 	ldw	r2,-48(fp)
 d00de18:	18800015 	stw	r2,0(r3)
 d00de1c:	e0bff717 	ldw	r2,-36(fp)
 d00de20:	10800104 	addi	r2,r2,4
 d00de24:	e0bff715 	stw	r2,-36(fp)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 d00de28:	e0bff717 	ldw	r2,-36(fp)
 d00de2c:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 d00de30:	e0bff18b 	ldhu	r2,-58(fp)
 d00de34:	10800044 	addi	r2,r2,1
 d00de38:	e0bff18d 	sth	r2,-58(fp)
 d00de3c:	00000a06 	br	d00de68 <OSEventPendMulti+0x540>

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 d00de40:	d0a07a17 	ldw	r2,-32280(gp)
 d00de44:	00c00044 	movi	r3,1
 d00de48:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 d00de4c:	d1207a17 	ldw	r4,-32280(gp)
 d00de50:	e17ff617 	ldw	r5,-40(fp)
 d00de54:	d00eb640 	call	d00eb64 <OS_EventTaskRemoveMulti>
             }
			 break;
 d00de58:	00000306 	br	d00de68 <OSEventPendMulti+0x540>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 d00de5c:	d1207a17 	ldw	r4,-32280(gp)
 d00de60:	e17ff617 	ldw	r5,-40(fp)
 d00de64:	d00eb640 	call	d00eb64 <OS_EventTaskRemoveMulti>
             break;
    }

    switch (OSTCBCur->OSTCBStatPend) {
 d00de68:	d0a07a17 	ldw	r2,-32280(gp)
 d00de6c:	10800c43 	ldbu	r2,49(r2)
 d00de70:	10803fcc 	andi	r2,r2,255
 d00de74:	e0bffb15 	stw	r2,-20(fp)
 d00de78:	e0fffb17 	ldw	r3,-20(fp)
 d00de7c:	1805003a 	cmpeq	r2,r3,zero
 d00de80:	1000041e 	bne	r2,zero,d00de94 <OSEventPendMulti+0x56c>
 d00de84:	e0fffb17 	ldw	r3,-20(fp)
 d00de88:	188000a0 	cmpeqi	r2,r3,2
 d00de8c:	10002c1e 	bne	r2,zero,d00df40 <OSEventPendMulti+0x618>
 d00de90:	00003406 	br	d00df64 <OSEventPendMulti+0x63c>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 d00de94:	e0bff417 	ldw	r2,-48(fp)
 d00de98:	10800003 	ldbu	r2,0(r2)
 d00de9c:	10803fcc 	andi	r2,r2,255
 d00dea0:	e0bffa15 	stw	r2,-24(fp)
 d00dea4:	e0fffa17 	ldw	r3,-24(fp)
 d00dea8:	18800050 	cmplti	r2,r3,1
 d00deac:	1000151e 	bne	r2,zero,d00df04 <OSEventPendMulti+0x5dc>
 d00deb0:	e0fffa17 	ldw	r3,-24(fp)
 d00deb4:	188000d0 	cmplti	r2,r3,3
 d00deb8:	10000a1e 	bne	r2,zero,d00dee4 <OSEventPendMulti+0x5bc>
 d00debc:	e0fffa17 	ldw	r3,-24(fp)
 d00dec0:	188000e0 	cmpeqi	r2,r3,3
 d00dec4:	1000011e 	bne	r2,zero,d00decc <OSEventPendMulti+0x5a4>
 d00dec8:	00000e06 	br	d00df04 <OSEventPendMulti+0x5dc>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 d00decc:	e0bff817 	ldw	r2,-32(fp)
 d00ded0:	10000015 	stw	zero,0(r2)
 d00ded4:	e0bff817 	ldw	r2,-32(fp)
 d00ded8:	10800104 	addi	r2,r2,4
 d00dedc:	e0bff815 	stw	r2,-32(fp)
                      break;
 d00dee0:	00001406 	br	d00df34 <OSEventPendMulti+0x60c>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 d00dee4:	d0a07a17 	ldw	r2,-32280(gp)
 d00dee8:	10c00917 	ldw	r3,36(r2)
 d00deec:	e0bff817 	ldw	r2,-32(fp)
 d00def0:	10c00015 	stw	r3,0(r2)
 d00def4:	e0bff817 	ldw	r2,-32(fp)
 d00def8:	10800104 	addi	r2,r2,4
 d00defc:	e0bff815 	stw	r2,-32(fp)
                      break;
 d00df00:	00000c06 	br	d00df34 <OSEventPendMulti+0x60c>
 d00df04:	e0bff017 	ldw	r2,-64(fp)
 d00df08:	e0bfea15 	stw	r2,-88(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00df0c:	e0bfea17 	ldw	r2,-88(fp)
 d00df10:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 d00df14:	e0bff717 	ldw	r2,-36(fp)
 d00df18:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 d00df1c:	e0c00217 	ldw	r3,8(fp)
 d00df20:	00800044 	movi	r2,1
 d00df24:	18800005 	stb	r2,0(r3)
                      return (events_rdy_nbr);
 d00df28:	e0bff18b 	ldhu	r2,-58(fp)
 d00df2c:	e0bfff15 	stw	r2,-4(fp)
 d00df30:	00002406 	br	d00dfc4 <OSEventPendMulti+0x69c>
             }
            *perr = OS_ERR_NONE;
 d00df34:	e0800217 	ldw	r2,8(fp)
 d00df38:	10000005 	stb	zero,0(r2)
             break;
 d00df3c:	00001106 	br	d00df84 <OSEventPendMulti+0x65c>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 d00df40:	e0bff817 	ldw	r2,-32(fp)
 d00df44:	10000015 	stw	zero,0(r2)
 d00df48:	e0bff817 	ldw	r2,-32(fp)
 d00df4c:	10800104 	addi	r2,r2,4
 d00df50:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 d00df54:	e0c00217 	ldw	r3,8(fp)
 d00df58:	00800384 	movi	r2,14
 d00df5c:	18800005 	stb	r2,0(r3)
             break;
 d00df60:	00000806 	br	d00df84 <OSEventPendMulti+0x65c>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 d00df64:	e0bff817 	ldw	r2,-32(fp)
 d00df68:	10000015 	stw	zero,0(r2)
 d00df6c:	e0bff817 	ldw	r2,-32(fp)
 d00df70:	10800104 	addi	r2,r2,4
 d00df74:	e0bff815 	stw	r2,-32(fp)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 d00df78:	e0c00217 	ldw	r3,8(fp)
 d00df7c:	00800284 	movi	r2,10
 d00df80:	18800005 	stb	r2,0(r3)
             break;
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 d00df84:	d0a07a17 	ldw	r2,-32280(gp)
 d00df88:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 d00df8c:	d0a07a17 	ldw	r2,-32280(gp)
 d00df90:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 d00df94:	d0a07a17 	ldw	r2,-32280(gp)
 d00df98:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 d00df9c:	d0a07a17 	ldw	r2,-32280(gp)
 d00dfa0:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 d00dfa4:	d0a07a17 	ldw	r2,-32280(gp)
 d00dfa8:	10000915 	stw	zero,36(r2)
 d00dfac:	e0bff017 	ldw	r2,-64(fp)
 d00dfb0:	e0bfe915 	stw	r2,-92(fp)
 d00dfb4:	e0bfe917 	ldw	r2,-92(fp)
 d00dfb8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 d00dfbc:	e0fff18b 	ldhu	r3,-58(fp)
 d00dfc0:	e0ffff15 	stw	r3,-4(fp)
 d00dfc4:	e0bfff17 	ldw	r2,-4(fp)
}
 d00dfc8:	e037883a 	mov	sp,fp
 d00dfcc:	dfc00117 	ldw	ra,4(sp)
 d00dfd0:	df000017 	ldw	fp,0(sp)
 d00dfd4:	dec00204 	addi	sp,sp,8
 d00dfd8:	f800283a 	ret

0d00dfdc <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 d00dfdc:	defffe04 	addi	sp,sp,-8
 d00dfe0:	dfc00115 	stw	ra,4(sp)
 d00dfe4:	df000015 	stw	fp,0(sp)
 d00dfe8:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 d00dfec:	d03a0080 	call	d03a008 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 d00dff0:	d00edac0 	call	d00edac <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 d00dff4:	d00edf00 	call	d00edf0 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 d00dff8:	d00ef540 	call	d00ef54 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 d00dffc:	d00ecd00 	call	d00ecd0 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 d00e000:	d0110040 	call	d011004 <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 d00e004:	d0119dc0 	call	d0119dc <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 d00e008:	d012d340 	call	d012d34 <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 d00e00c:	d00ee5c0 	call	d00ee5c <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 d00e010:	d00eed80 	call	d00eed8 <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 d00e014:	d03a0240 	call	d03a024 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 d00e018:	d00f7dc0 	call	d00f7dc <OSDebugInit>
#endif
}
 d00e01c:	e037883a 	mov	sp,fp
 d00e020:	dfc00117 	ldw	ra,4(sp)
 d00e024:	df000017 	ldw	fp,0(sp)
 d00e028:	dec00204 	addi	sp,sp,8
 d00e02c:	f800283a 	ret

0d00e030 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 d00e030:	defffc04 	addi	sp,sp,-16
 d00e034:	df000315 	stw	fp,12(sp)
 d00e038:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d00e03c:	e03fff15 	stw	zero,-4(fp)
#endif

    if (OSRunning == OS_TRUE) {
 d00e040:	d0a06b43 	ldbu	r2,-32339(gp)
 d00e044:	10803fcc 	andi	r2,r2,255
 d00e048:	10800058 	cmpnei	r2,r2,1
 d00e04c:	1000131e 	bne	r2,zero,d00e09c <OSIntEnter+0x6c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e050:	0005303a 	rdctl	r2,status
 d00e054:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e058:	e0fffe17 	ldw	r3,-8(fp)
 d00e05c:	00bfff84 	movi	r2,-2
 d00e060:	1884703a 	and	r2,r3,r2
 d00e064:	1001703a 	wrctl	status,r2
  
  return context;
 d00e068:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 d00e06c:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting < 255u) {
 d00e070:	d0a07903 	ldbu	r2,-32284(gp)
 d00e074:	10803fcc 	andi	r2,r2,255
 d00e078:	10803fe0 	cmpeqi	r2,r2,255
 d00e07c:	1000031e 	bne	r2,zero,d00e08c <OSIntEnter+0x5c>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 d00e080:	d0a07903 	ldbu	r2,-32284(gp)
 d00e084:	10800044 	addi	r2,r2,1
 d00e088:	d0a07905 	stb	r2,-32284(gp)
 d00e08c:	e0bfff17 	ldw	r2,-4(fp)
 d00e090:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e094:	e0bffd17 	ldw	r2,-12(fp)
 d00e098:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
    }
}
 d00e09c:	e037883a 	mov	sp,fp
 d00e0a0:	df000017 	ldw	fp,0(sp)
 d00e0a4:	dec00104 	addi	sp,sp,4
 d00e0a8:	f800283a 	ret

0d00e0ac <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 d00e0ac:	defffb04 	addi	sp,sp,-20
 d00e0b0:	dfc00415 	stw	ra,16(sp)
 d00e0b4:	df000315 	stw	fp,12(sp)
 d00e0b8:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d00e0bc:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {
 d00e0c0:	d0a06b43 	ldbu	r2,-32339(gp)
 d00e0c4:	10803fcc 	andi	r2,r2,255
 d00e0c8:	10800058 	cmpnei	r2,r2,1
 d00e0cc:	1000321e 	bne	r2,zero,d00e198 <OSIntExit+0xec>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e0d0:	0005303a 	rdctl	r2,status
 d00e0d4:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e0d8:	e0fffe17 	ldw	r3,-8(fp)
 d00e0dc:	00bfff84 	movi	r2,-2
 d00e0e0:	1884703a 	and	r2,r3,r2
 d00e0e4:	1001703a 	wrctl	status,r2
  
  return context;
 d00e0e8:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 d00e0ec:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 d00e0f0:	d0a07903 	ldbu	r2,-32284(gp)
 d00e0f4:	10803fcc 	andi	r2,r2,255
 d00e0f8:	1005003a 	cmpeq	r2,r2,zero
 d00e0fc:	1000031e 	bne	r2,zero,d00e10c <OSIntExit+0x60>
            OSIntNesting--;
 d00e100:	d0a07903 	ldbu	r2,-32284(gp)
 d00e104:	10bfffc4 	addi	r2,r2,-1
 d00e108:	d0a07905 	stb	r2,-32284(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 d00e10c:	d0a07903 	ldbu	r2,-32284(gp)
 d00e110:	10803fcc 	andi	r2,r2,255
 d00e114:	1004c03a 	cmpne	r2,r2,zero
 d00e118:	10001b1e 	bne	r2,zero,d00e188 <OSIntExit+0xdc>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 d00e11c:	d0a06b03 	ldbu	r2,-32340(gp)
 d00e120:	10803fcc 	andi	r2,r2,255
 d00e124:	1004c03a 	cmpne	r2,r2,zero
 d00e128:	1000171e 	bne	r2,zero,d00e188 <OSIntExit+0xdc>
                OS_SchedNew();
 d00e12c:	d00f1c80 	call	d00f1c8 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 d00e130:	d0a06d03 	ldbu	r2,-32332(gp)
 d00e134:	d0e06d43 	ldbu	r3,-32331(gp)
 d00e138:	11003fcc 	andi	r4,r2,255
 d00e13c:	18803fcc 	andi	r2,r3,255
 d00e140:	20801126 	beq	r4,r2,d00e188 <OSIntExit+0xdc>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 d00e144:	d0a06d03 	ldbu	r2,-32332(gp)
 d00e148:	10803fcc 	andi	r2,r2,255
 d00e14c:	00c341b4 	movhi	r3,3334
 d00e150:	18f13304 	addi	r3,r3,-15156
 d00e154:	1085883a 	add	r2,r2,r2
 d00e158:	1085883a 	add	r2,r2,r2
 d00e15c:	10c5883a 	add	r2,r2,r3
 d00e160:	10800017 	ldw	r2,0(r2)
 d00e164:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 d00e168:	d0e07517 	ldw	r3,-32300(gp)
 d00e16c:	18800e17 	ldw	r2,56(r3)
 d00e170:	10800044 	addi	r2,r2,1
 d00e174:	18800e15 	stw	r2,56(r3)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 d00e178:	d0a07017 	ldw	r2,-32320(gp)
 d00e17c:	10800044 	addi	r2,r2,1
 d00e180:	d0a07015 	stw	r2,-32320(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 d00e184:	d039b880 	call	d039b88 <OSCtxSw>
 d00e188:	e0bfff17 	ldw	r2,-4(fp)
 d00e18c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e190:	e0bffd17 	ldw	r2,-12(fp)
 d00e194:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 d00e198:	e037883a 	mov	sp,fp
 d00e19c:	dfc00117 	ldw	ra,4(sp)
 d00e1a0:	df000017 	ldw	fp,0(sp)
 d00e1a4:	dec00204 	addi	sp,sp,8
 d00e1a8:	f800283a 	ret

0d00e1ac <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 d00e1ac:	defffc04 	addi	sp,sp,-16
 d00e1b0:	df000315 	stw	fp,12(sp)
 d00e1b4:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00e1b8:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 d00e1bc:	d0a06b43 	ldbu	r2,-32339(gp)
 d00e1c0:	10803fcc 	andi	r2,r2,255
 d00e1c4:	10800058 	cmpnei	r2,r2,1
 d00e1c8:	1000171e 	bne	r2,zero,d00e228 <OSSchedLock+0x7c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e1cc:	0005303a 	rdctl	r2,status
 d00e1d0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e1d4:	e0fffe17 	ldw	r3,-8(fp)
 d00e1d8:	00bfff84 	movi	r2,-2
 d00e1dc:	1884703a 	and	r2,r3,r2
 d00e1e0:	1001703a 	wrctl	status,r2
  
  return context;
 d00e1e4:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 d00e1e8:	e0bfff15 	stw	r2,-4(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 d00e1ec:	d0a07903 	ldbu	r2,-32284(gp)
 d00e1f0:	10803fcc 	andi	r2,r2,255
 d00e1f4:	1004c03a 	cmpne	r2,r2,zero
 d00e1f8:	1000071e 	bne	r2,zero,d00e218 <OSSchedLock+0x6c>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 d00e1fc:	d0a06b03 	ldbu	r2,-32340(gp)
 d00e200:	10803fcc 	andi	r2,r2,255
 d00e204:	10803fe0 	cmpeqi	r2,r2,255
 d00e208:	1000031e 	bne	r2,zero,d00e218 <OSSchedLock+0x6c>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 d00e20c:	d0a06b03 	ldbu	r2,-32340(gp)
 d00e210:	10800044 	addi	r2,r2,1
 d00e214:	d0a06b05 	stb	r2,-32340(gp)
 d00e218:	e0bfff17 	ldw	r2,-4(fp)
 d00e21c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e220:	e0bffd17 	ldw	r2,-12(fp)
 d00e224:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 d00e228:	e037883a 	mov	sp,fp
 d00e22c:	df000017 	ldw	fp,0(sp)
 d00e230:	dec00104 	addi	sp,sp,4
 d00e234:	f800283a 	ret

0d00e238 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 d00e238:	defff804 	addi	sp,sp,-32
 d00e23c:	dfc00715 	stw	ra,28(sp)
 d00e240:	df000615 	stw	fp,24(sp)
 d00e244:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d00e248:	e03fff15 	stw	zero,-4(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 d00e24c:	d0a06b43 	ldbu	r2,-32339(gp)
 d00e250:	10803fcc 	andi	r2,r2,255
 d00e254:	10800058 	cmpnei	r2,r2,1
 d00e258:	10002b1e 	bne	r2,zero,d00e308 <OSSchedUnlock+0xd0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e25c:	0005303a 	rdctl	r2,status
 d00e260:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e264:	e0fffe17 	ldw	r3,-8(fp)
 d00e268:	00bfff84 	movi	r2,-2
 d00e26c:	1884703a 	and	r2,r3,r2
 d00e270:	1001703a 	wrctl	status,r2
  
  return context;
 d00e274:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 d00e278:	e0bfff15 	stw	r2,-4(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 d00e27c:	d0a06b03 	ldbu	r2,-32340(gp)
 d00e280:	10803fcc 	andi	r2,r2,255
 d00e284:	1005003a 	cmpeq	r2,r2,zero
 d00e288:	10001b1e 	bne	r2,zero,d00e2f8 <OSSchedUnlock+0xc0>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 d00e28c:	d0a06b03 	ldbu	r2,-32340(gp)
 d00e290:	10bfffc4 	addi	r2,r2,-1
 d00e294:	d0a06b05 	stb	r2,-32340(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 d00e298:	d0a06b03 	ldbu	r2,-32340(gp)
 d00e29c:	10803fcc 	andi	r2,r2,255
 d00e2a0:	1004c03a 	cmpne	r2,r2,zero
 d00e2a4:	10000f1e 	bne	r2,zero,d00e2e4 <OSSchedUnlock+0xac>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 d00e2a8:	d0a07903 	ldbu	r2,-32284(gp)
 d00e2ac:	10803fcc 	andi	r2,r2,255
 d00e2b0:	1004c03a 	cmpne	r2,r2,zero
 d00e2b4:	1000061e 	bne	r2,zero,d00e2d0 <OSSchedUnlock+0x98>
 d00e2b8:	e0bfff17 	ldw	r2,-4(fp)
 d00e2bc:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e2c0:	e0bffd17 	ldw	r2,-12(fp)
 d00e2c4:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 d00e2c8:	d00f0f40 	call	d00f0f4 <OS_Sched>
 d00e2cc:	00000e06 	br	d00e308 <OSSchedUnlock+0xd0>
 d00e2d0:	e0bfff17 	ldw	r2,-4(fp)
 d00e2d4:	e0bffc15 	stw	r2,-16(fp)
 d00e2d8:	e0bffc17 	ldw	r2,-16(fp)
 d00e2dc:	1001703a 	wrctl	status,r2
 d00e2e0:	00000906 	br	d00e308 <OSSchedUnlock+0xd0>
 d00e2e4:	e0bfff17 	ldw	r2,-4(fp)
 d00e2e8:	e0bffb15 	stw	r2,-20(fp)
 d00e2ec:	e0bffb17 	ldw	r2,-20(fp)
 d00e2f0:	1001703a 	wrctl	status,r2
 d00e2f4:	00000406 	br	d00e308 <OSSchedUnlock+0xd0>
 d00e2f8:	e0bfff17 	ldw	r2,-4(fp)
 d00e2fc:	e0bffa15 	stw	r2,-24(fp)
 d00e300:	e0bffa17 	ldw	r2,-24(fp)
 d00e304:	1001703a 	wrctl	status,r2
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 d00e308:	e037883a 	mov	sp,fp
 d00e30c:	dfc00117 	ldw	ra,4(sp)
 d00e310:	df000017 	ldw	fp,0(sp)
 d00e314:	dec00204 	addi	sp,sp,8
 d00e318:	f800283a 	ret

0d00e31c <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 d00e31c:	defffe04 	addi	sp,sp,-8
 d00e320:	dfc00115 	stw	ra,4(sp)
 d00e324:	df000015 	stw	fp,0(sp)
 d00e328:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 d00e32c:	d0a06b43 	ldbu	r2,-32339(gp)
 d00e330:	10803fcc 	andi	r2,r2,255
 d00e334:	1004c03a 	cmpne	r2,r2,zero
 d00e338:	10000f1e 	bne	r2,zero,d00e378 <OSStart+0x5c>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 d00e33c:	d00f1c80 	call	d00f1c8 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 d00e340:	d0a06d03 	ldbu	r2,-32332(gp)
 d00e344:	d0a06d45 	stb	r2,-32331(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 d00e348:	d0a06d03 	ldbu	r2,-32332(gp)
 d00e34c:	10803fcc 	andi	r2,r2,255
 d00e350:	00c341b4 	movhi	r3,3334
 d00e354:	18f13304 	addi	r3,r3,-15156
 d00e358:	1085883a 	add	r2,r2,r2
 d00e35c:	1085883a 	add	r2,r2,r2
 d00e360:	10c5883a 	add	r2,r2,r3
 d00e364:	10800017 	ldw	r2,0(r2)
 d00e368:	d0a07515 	stw	r2,-32300(gp)
        OSTCBCur      = OSTCBHighRdy;
 d00e36c:	d0a07517 	ldw	r2,-32300(gp)
 d00e370:	d0a07a15 	stw	r2,-32280(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 d00e374:	d039c140 	call	d039c14 <OSStartHighRdy>
    }
}
 d00e378:	e037883a 	mov	sp,fp
 d00e37c:	dfc00117 	ldw	ra,4(sp)
 d00e380:	df000017 	ldw	fp,0(sp)
 d00e384:	dec00204 	addi	sp,sp,8
 d00e388:	f800283a 	ret

0d00e38c <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 d00e38c:	defff904 	addi	sp,sp,-28
 d00e390:	dfc00615 	stw	ra,24(sp)
 d00e394:	df000515 	stw	fp,20(sp)
 d00e398:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00e39c:	e03fff15 	stw	zero,-4(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 d00e3a0:	01000084 	movi	r4,2
 d00e3a4:	d0153e80 	call	d0153e8 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e3a8:	0005303a 	rdctl	r2,status
 d00e3ac:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e3b0:	e0fffe17 	ldw	r3,-8(fp)
 d00e3b4:	00bfff84 	movi	r2,-2
 d00e3b8:	1884703a 	and	r2,r3,r2
 d00e3bc:	1001703a 	wrctl	status,r2
  
  return context;
 d00e3c0:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 d00e3c4:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 d00e3c8:	d0206c15 	stw	zero,-32336(gp)
 d00e3cc:	e0bfff17 	ldw	r2,-4(fp)
 d00e3d0:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e3d4:	e0bffd17 	ldw	r2,-12(fp)
 d00e3d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 d00e3dc:	01000284 	movi	r4,10
 d00e3e0:	d0153e80 	call	d0153e8 <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e3e4:	0005303a 	rdctl	r2,status
 d00e3e8:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e3ec:	e0fffc17 	ldw	r3,-16(fp)
 d00e3f0:	00bfff84 	movi	r2,-2
 d00e3f4:	1884703a 	and	r2,r3,r2
 d00e3f8:	1001703a 	wrctl	status,r2
  
  return context;
 d00e3fc:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 d00e400:	e0bfff15 	stw	r2,-4(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 d00e404:	d0a06c17 	ldw	r2,-32336(gp)
 d00e408:	d0a07115 	stw	r2,-32316(gp)
    OSStatRdy    = OS_TRUE;
 d00e40c:	00800044 	movi	r2,1
 d00e410:	d0a07d05 	stb	r2,-32268(gp)
 d00e414:	e0bfff17 	ldw	r2,-4(fp)
 d00e418:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e41c:	e0bffb17 	ldw	r2,-20(fp)
 d00e420:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 d00e424:	e037883a 	mov	sp,fp
 d00e428:	dfc00117 	ldw	ra,4(sp)
 d00e42c:	df000017 	ldw	fp,0(sp)
 d00e430:	dec00204 	addi	sp,sp,8
 d00e434:	f800283a 	ret

0d00e438 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 d00e438:	defff604 	addi	sp,sp,-40
 d00e43c:	dfc00915 	stw	ra,36(sp)
 d00e440:	df000815 	stw	fp,32(sp)
 d00e444:	df000804 	addi	fp,sp,32
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d00e448:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 d00e44c:	d039fe00 	call	d039fe0 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e450:	0005303a 	rdctl	r2,status
 d00e454:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e458:	e0fffb17 	ldw	r3,-20(fp)
 d00e45c:	00bfff84 	movi	r2,-2
 d00e460:	1884703a 	and	r2,r3,r2
 d00e464:	1001703a 	wrctl	status,r2
  
  return context;
 d00e468:	e0bffb17 	ldw	r2,-20(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 d00e46c:	e0bffc15 	stw	r2,-16(fp)
    OSTime++;
 d00e470:	d0a07b17 	ldw	r2,-32276(gp)
 d00e474:	10800044 	addi	r2,r2,1
 d00e478:	d0a07b15 	stw	r2,-32276(gp)
 d00e47c:	e0bffc17 	ldw	r2,-16(fp)
 d00e480:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e484:	e0bffa17 	ldw	r2,-24(fp)
 d00e488:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 d00e48c:	d0a06b43 	ldbu	r2,-32339(gp)
 d00e490:	10803fcc 	andi	r2,r2,255
 d00e494:	10800058 	cmpnei	r2,r2,1
 d00e498:	1000721e 	bne	r2,zero,d00e664 <OSTimeTick+0x22c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 d00e49c:	d0a06f03 	ldbu	r2,-32324(gp)
 d00e4a0:	10803fcc 	andi	r2,r2,255
 d00e4a4:	e0bfff15 	stw	r2,-4(fp)
 d00e4a8:	e0ffff17 	ldw	r3,-4(fp)
 d00e4ac:	18800060 	cmpeqi	r2,r3,1
 d00e4b0:	10000a1e 	bne	r2,zero,d00e4dc <OSTimeTick+0xa4>
 d00e4b4:	e0ffff17 	ldw	r3,-4(fp)
 d00e4b8:	188000a0 	cmpeqi	r2,r3,2
 d00e4bc:	1000091e 	bne	r2,zero,d00e4e4 <OSTimeTick+0xac>
 d00e4c0:	e0ffff17 	ldw	r3,-4(fp)
 d00e4c4:	1805003a 	cmpeq	r2,r3,zero
 d00e4c8:	1000011e 	bne	r2,zero,d00e4d0 <OSTimeTick+0x98>
 d00e4cc:	00000a06 	br	d00e4f8 <OSTimeTick+0xc0>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 d00e4d0:	00800044 	movi	r2,1
 d00e4d4:	e0bffd05 	stb	r2,-12(fp)
                 break;
 d00e4d8:	00000a06 	br	d00e504 <OSTimeTick+0xcc>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 d00e4dc:	e03ffd05 	stb	zero,-12(fp)
                 break;
 d00e4e0:	00000806 	br	d00e504 <OSTimeTick+0xcc>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 d00e4e4:	00800044 	movi	r2,1
 d00e4e8:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 d00e4ec:	00800044 	movi	r2,1
 d00e4f0:	d0a06f05 	stb	r2,-32324(gp)
                 break;
 d00e4f4:	00000306 	br	d00e504 <OSTimeTick+0xcc>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 d00e4f8:	00800044 	movi	r2,1
 d00e4fc:	e0bffd05 	stb	r2,-12(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 d00e500:	d0206f05 	stb	zero,-32324(gp)
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 d00e504:	e0bffd03 	ldbu	r2,-12(fp)
 d00e508:	1005003a 	cmpeq	r2,r2,zero
 d00e50c:	1000551e 	bne	r2,zero,d00e664 <OSTimeTick+0x22c>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 d00e510:	d0a06e17 	ldw	r2,-32328(gp)
 d00e514:	e0bffe15 	stw	r2,-8(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 d00e518:	00004d06 	br	d00e650 <OSTimeTick+0x218>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00e51c:	0005303a 	rdctl	r2,status
 d00e520:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00e524:	e0fff917 	ldw	r3,-28(fp)
 d00e528:	00bfff84 	movi	r2,-2
 d00e52c:	1884703a 	and	r2,r3,r2
 d00e530:	1001703a 	wrctl	status,r2
  
  return context;
 d00e534:	e0bff917 	ldw	r2,-28(fp)
            OS_ENTER_CRITICAL();
 d00e538:	e0bffc15 	stw	r2,-16(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 d00e53c:	e0bffe17 	ldw	r2,-8(fp)
 d00e540:	10800b8b 	ldhu	r2,46(r2)
 d00e544:	10bfffcc 	andi	r2,r2,65535
 d00e548:	1005003a 	cmpeq	r2,r2,zero
 d00e54c:	1000391e 	bne	r2,zero,d00e634 <OSTimeTick+0x1fc>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 d00e550:	e0bffe17 	ldw	r2,-8(fp)
 d00e554:	10800b8b 	ldhu	r2,46(r2)
 d00e558:	10bfffc4 	addi	r2,r2,-1
 d00e55c:	1007883a 	mov	r3,r2
 d00e560:	e0bffe17 	ldw	r2,-8(fp)
 d00e564:	10c00b8d 	sth	r3,46(r2)
 d00e568:	e0bffe17 	ldw	r2,-8(fp)
 d00e56c:	10800b8b 	ldhu	r2,46(r2)
 d00e570:	10bfffcc 	andi	r2,r2,65535
 d00e574:	1004c03a 	cmpne	r2,r2,zero
 d00e578:	10002e1e 	bne	r2,zero,d00e634 <OSTimeTick+0x1fc>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 d00e57c:	e0bffe17 	ldw	r2,-8(fp)
 d00e580:	10800c03 	ldbu	r2,48(r2)
 d00e584:	10803fcc 	andi	r2,r2,255
 d00e588:	10800dcc 	andi	r2,r2,55
 d00e58c:	1005003a 	cmpeq	r2,r2,zero
 d00e590:	10000b1e 	bne	r2,zero,d00e5c0 <OSTimeTick+0x188>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 d00e594:	e0bffe17 	ldw	r2,-8(fp)
 d00e598:	10c00c03 	ldbu	r3,48(r2)
 d00e59c:	00bff204 	movi	r2,-56
 d00e5a0:	1884703a 	and	r2,r3,r2
 d00e5a4:	1007883a 	mov	r3,r2
 d00e5a8:	e0bffe17 	ldw	r2,-8(fp)
 d00e5ac:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 d00e5b0:	e0fffe17 	ldw	r3,-8(fp)
 d00e5b4:	00800044 	movi	r2,1
 d00e5b8:	18800c45 	stb	r2,49(r3)
 d00e5bc:	00000206 	br	d00e5c8 <OSTimeTick+0x190>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 d00e5c0:	e0bffe17 	ldw	r2,-8(fp)
 d00e5c4:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 d00e5c8:	e0bffe17 	ldw	r2,-8(fp)
 d00e5cc:	10800c03 	ldbu	r2,48(r2)
 d00e5d0:	10803fcc 	andi	r2,r2,255
 d00e5d4:	1080020c 	andi	r2,r2,8
 d00e5d8:	1004c03a 	cmpne	r2,r2,zero
 d00e5dc:	1000151e 	bne	r2,zero,d00e634 <OSTimeTick+0x1fc>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 d00e5e0:	e0bffe17 	ldw	r2,-8(fp)
 d00e5e4:	10c00d83 	ldbu	r3,54(r2)
 d00e5e8:	d0a07703 	ldbu	r2,-32292(gp)
 d00e5ec:	1884b03a 	or	r2,r3,r2
 d00e5f0:	d0a07705 	stb	r2,-32292(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d00e5f4:	e0bffe17 	ldw	r2,-8(fp)
 d00e5f8:	10800d03 	ldbu	r2,52(r2)
 d00e5fc:	11003fcc 	andi	r4,r2,255
 d00e600:	e0bffe17 	ldw	r2,-8(fp)
 d00e604:	10800d03 	ldbu	r2,52(r2)
 d00e608:	10c03fcc 	andi	r3,r2,255
 d00e60c:	d0a07744 	addi	r2,gp,-32291
 d00e610:	1885883a 	add	r2,r3,r2
 d00e614:	10c00003 	ldbu	r3,0(r2)
 d00e618:	e0bffe17 	ldw	r2,-8(fp)
 d00e61c:	10800d43 	ldbu	r2,53(r2)
 d00e620:	1884b03a 	or	r2,r3,r2
 d00e624:	1007883a 	mov	r3,r2
 d00e628:	d0a07744 	addi	r2,gp,-32291
 d00e62c:	2085883a 	add	r2,r4,r2
 d00e630:	10c00005 	stb	r3,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 d00e634:	e0bffe17 	ldw	r2,-8(fp)
 d00e638:	10800517 	ldw	r2,20(r2)
 d00e63c:	e0bffe15 	stw	r2,-8(fp)
 d00e640:	e0bffc17 	ldw	r2,-16(fp)
 d00e644:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00e648:	e0bff817 	ldw	r2,-32(fp)
 d00e64c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 d00e650:	e0bffe17 	ldw	r2,-8(fp)
 d00e654:	10800c83 	ldbu	r2,50(r2)
 d00e658:	10803fcc 	andi	r2,r2,255
 d00e65c:	10800518 	cmpnei	r2,r2,20
 d00e660:	103fae1e 	bne	r2,zero,d00e51c <OSTimeTick+0xe4>
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 d00e664:	e037883a 	mov	sp,fp
 d00e668:	dfc00117 	ldw	ra,4(sp)
 d00e66c:	df000017 	ldw	fp,0(sp)
 d00e670:	dec00204 	addi	sp,sp,8
 d00e674:	f800283a 	ret

0d00e678 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 d00e678:	deffff04 	addi	sp,sp,-4
 d00e67c:	df000015 	stw	fp,0(sp)
 d00e680:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 d00e684:	00804784 	movi	r2,286
}
 d00e688:	e037883a 	mov	sp,fp
 d00e68c:	df000017 	ldw	fp,0(sp)
 d00e690:	dec00104 	addi	sp,sp,4
 d00e694:	f800283a 	ret

0d00e698 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 d00e698:	deffff04 	addi	sp,sp,-4
 d00e69c:	df000015 	stw	fp,0(sp)
 d00e6a0:	d839883a 	mov	fp,sp
}
 d00e6a4:	e037883a 	mov	sp,fp
 d00e6a8:	df000017 	ldw	fp,0(sp)
 d00e6ac:	dec00104 	addi	sp,sp,4
 d00e6b0:	f800283a 	ret

0d00e6b4 <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 d00e6b4:	defff804 	addi	sp,sp,-32
 d00e6b8:	dfc00715 	stw	ra,28(sp)
 d00e6bc:	df000615 	stw	fp,24(sp)
 d00e6c0:	df000604 	addi	fp,sp,24
 d00e6c4:	e13ffc15 	stw	r4,-16(fp)
 d00e6c8:	e17ffd15 	stw	r5,-12(fp)
 d00e6cc:	e1bffe05 	stb	r6,-8(fp)
 d00e6d0:	e1ffff05 	stb	r7,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 d00e6d4:	e0bffc17 	ldw	r2,-16(fp)
 d00e6d8:	10800283 	ldbu	r2,10(r2)
 d00e6dc:	10c03fcc 	andi	r3,r2,255
 d00e6e0:	00834174 	movhi	r2,3333
 d00e6e4:	10b1b204 	addi	r2,r2,-14648
 d00e6e8:	10c5883a 	add	r2,r2,r3
 d00e6ec:	10800003 	ldbu	r2,0(r2)
 d00e6f0:	e0bffa85 	stb	r2,-22(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 d00e6f4:	e0fffa83 	ldbu	r3,-22(fp)
 d00e6f8:	e0bffc17 	ldw	r2,-16(fp)
 d00e6fc:	1885883a 	add	r2,r3,r2
 d00e700:	10800204 	addi	r2,r2,8
 d00e704:	108000c3 	ldbu	r2,3(r2)
 d00e708:	10c03fcc 	andi	r3,r2,255
 d00e70c:	00834174 	movhi	r2,3333
 d00e710:	10b1b204 	addi	r2,r2,-14648
 d00e714:	10c5883a 	add	r2,r2,r3
 d00e718:	10800003 	ldbu	r2,0(r2)
 d00e71c:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 d00e720:	e0bffa83 	ldbu	r2,-22(fp)
 d00e724:	100490fa 	slli	r2,r2,3
 d00e728:	1007883a 	mov	r3,r2
 d00e72c:	e0bffa43 	ldbu	r2,-23(fp)
 d00e730:	1885883a 	add	r2,r3,r2
 d00e734:	e0bffa05 	stb	r2,-24(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 d00e738:	e0bffa03 	ldbu	r2,-24(fp)
 d00e73c:	00c341b4 	movhi	r3,3334
 d00e740:	18f13304 	addi	r3,r3,-15156
 d00e744:	1085883a 	add	r2,r2,r2
 d00e748:	1085883a 	add	r2,r2,r2
 d00e74c:	10c5883a 	add	r2,r2,r3
 d00e750:	10800017 	ldw	r2,0(r2)
 d00e754:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 d00e758:	e0bffb17 	ldw	r2,-20(fp)
 d00e75c:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 d00e760:	e0fffb17 	ldw	r3,-20(fp)
 d00e764:	e0bffd17 	ldw	r2,-12(fp)
 d00e768:	18800915 	stw	r2,36(r3)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 d00e76c:	e0bffb17 	ldw	r2,-20(fp)
 d00e770:	10800c03 	ldbu	r2,48(r2)
 d00e774:	1007883a 	mov	r3,r2
 d00e778:	e0bffe03 	ldbu	r2,-8(fp)
 d00e77c:	0084303a 	nor	r2,zero,r2
 d00e780:	1884703a 	and	r2,r3,r2
 d00e784:	1007883a 	mov	r3,r2
 d00e788:	e0bffb17 	ldw	r2,-20(fp)
 d00e78c:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 d00e790:	e0fffb17 	ldw	r3,-20(fp)
 d00e794:	e0bfff03 	ldbu	r2,-4(fp)
 d00e798:	18800c45 	stb	r2,49(r3)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 d00e79c:	e0bffb17 	ldw	r2,-20(fp)
 d00e7a0:	10800c03 	ldbu	r2,48(r2)
 d00e7a4:	10803fcc 	andi	r2,r2,255
 d00e7a8:	1080020c 	andi	r2,r2,8
 d00e7ac:	1004c03a 	cmpne	r2,r2,zero
 d00e7b0:	1000111e 	bne	r2,zero,d00e7f8 <OS_EventTaskRdy+0x144>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 d00e7b4:	e0bffb17 	ldw	r2,-20(fp)
 d00e7b8:	10c00d83 	ldbu	r3,54(r2)
 d00e7bc:	d0a07703 	ldbu	r2,-32292(gp)
 d00e7c0:	1884b03a 	or	r2,r3,r2
 d00e7c4:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 d00e7c8:	e13ffa83 	ldbu	r4,-22(fp)
 d00e7cc:	e0fffa83 	ldbu	r3,-22(fp)
 d00e7d0:	d0a07744 	addi	r2,gp,-32291
 d00e7d4:	1885883a 	add	r2,r3,r2
 d00e7d8:	10c00003 	ldbu	r3,0(r2)
 d00e7dc:	e0bffb17 	ldw	r2,-20(fp)
 d00e7e0:	10800d43 	ldbu	r2,53(r2)
 d00e7e4:	1884b03a 	or	r2,r3,r2
 d00e7e8:	1007883a 	mov	r3,r2
 d00e7ec:	d0a07744 	addi	r2,gp,-32291
 d00e7f0:	2085883a 	add	r2,r4,r2
 d00e7f4:	10c00005 	stb	r3,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 d00e7f8:	e13ffb17 	ldw	r4,-20(fp)
 d00e7fc:	e17ffc17 	ldw	r5,-16(fp)
 d00e800:	d00eaac0 	call	d00eaac <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 d00e804:	e0bffb17 	ldw	r2,-20(fp)
 d00e808:	10800817 	ldw	r2,32(r2)
 d00e80c:	1005003a 	cmpeq	r2,r2,zero
 d00e810:	1000071e 	bne	r2,zero,d00e830 <OS_EventTaskRdy+0x17c>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 d00e814:	e0bffb17 	ldw	r2,-20(fp)
 d00e818:	11400817 	ldw	r5,32(r2)
 d00e81c:	e13ffb17 	ldw	r4,-20(fp)
 d00e820:	d00eb640 	call	d00eb64 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 d00e824:	e0fffb17 	ldw	r3,-20(fp)
 d00e828:	e0bffc17 	ldw	r2,-16(fp)
 d00e82c:	18800715 	stw	r2,28(r3)
    }
#endif

    return (prio);
 d00e830:	e0bffa03 	ldbu	r2,-24(fp)
}
 d00e834:	e037883a 	mov	sp,fp
 d00e838:	dfc00117 	ldw	ra,4(sp)
 d00e83c:	df000017 	ldw	fp,0(sp)
 d00e840:	dec00204 	addi	sp,sp,8
 d00e844:	f800283a 	ret

0d00e848 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 d00e848:	defffd04 	addi	sp,sp,-12
 d00e84c:	df000215 	stw	fp,8(sp)
 d00e850:	df000204 	addi	fp,sp,8
 d00e854:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 d00e858:	d0e07a17 	ldw	r3,-32280(gp)
 d00e85c:	e0bfff17 	ldw	r2,-4(fp)
 d00e860:	18800715 	stw	r2,28(r3)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 d00e864:	d0a07a17 	ldw	r2,-32280(gp)
 d00e868:	10800d03 	ldbu	r2,52(r2)
 d00e86c:	11003fcc 	andi	r4,r2,255
 d00e870:	d0a07a17 	ldw	r2,-32280(gp)
 d00e874:	10800d03 	ldbu	r2,52(r2)
 d00e878:	10c03fcc 	andi	r3,r2,255
 d00e87c:	e0bfff17 	ldw	r2,-4(fp)
 d00e880:	1885883a 	add	r2,r3,r2
 d00e884:	10800204 	addi	r2,r2,8
 d00e888:	10c000c3 	ldbu	r3,3(r2)
 d00e88c:	d0a07a17 	ldw	r2,-32280(gp)
 d00e890:	10800d43 	ldbu	r2,53(r2)
 d00e894:	1884b03a 	or	r2,r3,r2
 d00e898:	1007883a 	mov	r3,r2
 d00e89c:	e0bfff17 	ldw	r2,-4(fp)
 d00e8a0:	2085883a 	add	r2,r4,r2
 d00e8a4:	10800204 	addi	r2,r2,8
 d00e8a8:	10c000c5 	stb	r3,3(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 d00e8ac:	e0bfff17 	ldw	r2,-4(fp)
 d00e8b0:	10c00283 	ldbu	r3,10(r2)
 d00e8b4:	d0a07a17 	ldw	r2,-32280(gp)
 d00e8b8:	10800d83 	ldbu	r2,54(r2)
 d00e8bc:	1884b03a 	or	r2,r3,r2
 d00e8c0:	1007883a 	mov	r3,r2
 d00e8c4:	e0bfff17 	ldw	r2,-4(fp)
 d00e8c8:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 d00e8cc:	d0a07a17 	ldw	r2,-32280(gp)
 d00e8d0:	10800d03 	ldbu	r2,52(r2)
 d00e8d4:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 d00e8d8:	e13ffe03 	ldbu	r4,-8(fp)
 d00e8dc:	e0fffe03 	ldbu	r3,-8(fp)
 d00e8e0:	d0a07744 	addi	r2,gp,-32291
 d00e8e4:	1885883a 	add	r2,r3,r2
 d00e8e8:	10800003 	ldbu	r2,0(r2)
 d00e8ec:	1007883a 	mov	r3,r2
 d00e8f0:	d0a07a17 	ldw	r2,-32280(gp)
 d00e8f4:	10800d43 	ldbu	r2,53(r2)
 d00e8f8:	0084303a 	nor	r2,zero,r2
 d00e8fc:	1884703a 	and	r2,r3,r2
 d00e900:	1007883a 	mov	r3,r2
 d00e904:	d0a07744 	addi	r2,gp,-32291
 d00e908:	2085883a 	add	r2,r4,r2
 d00e90c:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 d00e910:	e0fffe03 	ldbu	r3,-8(fp)
 d00e914:	d0a07744 	addi	r2,gp,-32291
 d00e918:	1885883a 	add	r2,r3,r2
 d00e91c:	10800003 	ldbu	r2,0(r2)
 d00e920:	10803fcc 	andi	r2,r2,255
 d00e924:	1004c03a 	cmpne	r2,r2,zero
 d00e928:	1000071e 	bne	r2,zero,d00e948 <OS_EventTaskWait+0x100>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 d00e92c:	d0a07a17 	ldw	r2,-32280(gp)
 d00e930:	10800d83 	ldbu	r2,54(r2)
 d00e934:	0084303a 	nor	r2,zero,r2
 d00e938:	1007883a 	mov	r3,r2
 d00e93c:	d0a07703 	ldbu	r2,-32292(gp)
 d00e940:	1884703a 	and	r2,r3,r2
 d00e944:	d0a07705 	stb	r2,-32292(gp)
    }
}
 d00e948:	e037883a 	mov	sp,fp
 d00e94c:	df000017 	ldw	fp,0(sp)
 d00e950:	dec00104 	addi	sp,sp,4
 d00e954:	f800283a 	ret

0d00e958 <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 d00e958:	defffb04 	addi	sp,sp,-20
 d00e95c:	df000415 	stw	fp,16(sp)
 d00e960:	df000404 	addi	fp,sp,16
 d00e964:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 d00e968:	d0a07a17 	ldw	r2,-32280(gp)
 d00e96c:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 d00e970:	d0e07a17 	ldw	r3,-32280(gp)
 d00e974:	e0bfff17 	ldw	r2,-4(fp)
 d00e978:	18800815 	stw	r2,32(r3)

    pevents =  pevents_wait;
 d00e97c:	e0bfff17 	ldw	r2,-4(fp)
 d00e980:	e0bffe15 	stw	r2,-8(fp)
    pevent  = *pevents;
 d00e984:	e0bffe17 	ldw	r2,-8(fp)
 d00e988:	10800017 	ldw	r2,0(r2)
 d00e98c:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 d00e990:	00002006 	br	d00ea14 <OS_EventTaskWaitMulti+0xbc>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 d00e994:	d0a07a17 	ldw	r2,-32280(gp)
 d00e998:	10800d03 	ldbu	r2,52(r2)
 d00e99c:	11003fcc 	andi	r4,r2,255
 d00e9a0:	d0a07a17 	ldw	r2,-32280(gp)
 d00e9a4:	10800d03 	ldbu	r2,52(r2)
 d00e9a8:	10c03fcc 	andi	r3,r2,255
 d00e9ac:	e0bffd17 	ldw	r2,-12(fp)
 d00e9b0:	1885883a 	add	r2,r3,r2
 d00e9b4:	10800204 	addi	r2,r2,8
 d00e9b8:	10c000c3 	ldbu	r3,3(r2)
 d00e9bc:	d0a07a17 	ldw	r2,-32280(gp)
 d00e9c0:	10800d43 	ldbu	r2,53(r2)
 d00e9c4:	1884b03a 	or	r2,r3,r2
 d00e9c8:	1007883a 	mov	r3,r2
 d00e9cc:	e0bffd17 	ldw	r2,-12(fp)
 d00e9d0:	2085883a 	add	r2,r4,r2
 d00e9d4:	10800204 	addi	r2,r2,8
 d00e9d8:	10c000c5 	stb	r3,3(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 d00e9dc:	e0bffd17 	ldw	r2,-12(fp)
 d00e9e0:	10c00283 	ldbu	r3,10(r2)
 d00e9e4:	d0a07a17 	ldw	r2,-32280(gp)
 d00e9e8:	10800d83 	ldbu	r2,54(r2)
 d00e9ec:	1884b03a 	or	r2,r3,r2
 d00e9f0:	1007883a 	mov	r3,r2
 d00e9f4:	e0bffd17 	ldw	r2,-12(fp)
 d00e9f8:	10c00285 	stb	r3,10(r2)
        pevents++;
 d00e9fc:	e0bffe17 	ldw	r2,-8(fp)
 d00ea00:	10800104 	addi	r2,r2,4
 d00ea04:	e0bffe15 	stw	r2,-8(fp)
        pevent = *pevents;
 d00ea08:	e0bffe17 	ldw	r2,-8(fp)
 d00ea0c:	10800017 	ldw	r2,0(r2)
 d00ea10:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 d00ea14:	e0bffd17 	ldw	r2,-12(fp)
 d00ea18:	1004c03a 	cmpne	r2,r2,zero
 d00ea1c:	103fdd1e 	bne	r2,zero,d00e994 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 d00ea20:	d0a07a17 	ldw	r2,-32280(gp)
 d00ea24:	10800d03 	ldbu	r2,52(r2)
 d00ea28:	e0bffc05 	stb	r2,-16(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 d00ea2c:	e13ffc03 	ldbu	r4,-16(fp)
 d00ea30:	e0fffc03 	ldbu	r3,-16(fp)
 d00ea34:	d0a07744 	addi	r2,gp,-32291
 d00ea38:	1885883a 	add	r2,r3,r2
 d00ea3c:	10800003 	ldbu	r2,0(r2)
 d00ea40:	1007883a 	mov	r3,r2
 d00ea44:	d0a07a17 	ldw	r2,-32280(gp)
 d00ea48:	10800d43 	ldbu	r2,53(r2)
 d00ea4c:	0084303a 	nor	r2,zero,r2
 d00ea50:	1884703a 	and	r2,r3,r2
 d00ea54:	1007883a 	mov	r3,r2
 d00ea58:	d0a07744 	addi	r2,gp,-32291
 d00ea5c:	2085883a 	add	r2,r4,r2
 d00ea60:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 d00ea64:	e0fffc03 	ldbu	r3,-16(fp)
 d00ea68:	d0a07744 	addi	r2,gp,-32291
 d00ea6c:	1885883a 	add	r2,r3,r2
 d00ea70:	10800003 	ldbu	r2,0(r2)
 d00ea74:	10803fcc 	andi	r2,r2,255
 d00ea78:	1004c03a 	cmpne	r2,r2,zero
 d00ea7c:	1000071e 	bne	r2,zero,d00ea9c <OS_EventTaskWaitMulti+0x144>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 d00ea80:	d0a07a17 	ldw	r2,-32280(gp)
 d00ea84:	10800d83 	ldbu	r2,54(r2)
 d00ea88:	0084303a 	nor	r2,zero,r2
 d00ea8c:	1007883a 	mov	r3,r2
 d00ea90:	d0a07703 	ldbu	r2,-32292(gp)
 d00ea94:	1884703a 	and	r2,r3,r2
 d00ea98:	d0a07705 	stb	r2,-32292(gp)
    }
}
 d00ea9c:	e037883a 	mov	sp,fp
 d00eaa0:	df000017 	ldw	fp,0(sp)
 d00eaa4:	dec00104 	addi	sp,sp,4
 d00eaa8:	f800283a 	ret

0d00eaac <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 d00eaac:	defffc04 	addi	sp,sp,-16
 d00eab0:	df000315 	stw	fp,12(sp)
 d00eab4:	df000304 	addi	fp,sp,12
 d00eab8:	e13ffe15 	stw	r4,-8(fp)
 d00eabc:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 d00eac0:	e0bffe17 	ldw	r2,-8(fp)
 d00eac4:	10800d03 	ldbu	r2,52(r2)
 d00eac8:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 d00eacc:	e13ffd03 	ldbu	r4,-12(fp)
 d00ead0:	e0fffd03 	ldbu	r3,-12(fp)
 d00ead4:	e0bfff17 	ldw	r2,-4(fp)
 d00ead8:	1885883a 	add	r2,r3,r2
 d00eadc:	10800204 	addi	r2,r2,8
 d00eae0:	108000c3 	ldbu	r2,3(r2)
 d00eae4:	1007883a 	mov	r3,r2
 d00eae8:	e0bffe17 	ldw	r2,-8(fp)
 d00eaec:	10800d43 	ldbu	r2,53(r2)
 d00eaf0:	0084303a 	nor	r2,zero,r2
 d00eaf4:	1884703a 	and	r2,r3,r2
 d00eaf8:	1007883a 	mov	r3,r2
 d00eafc:	e0bfff17 	ldw	r2,-4(fp)
 d00eb00:	2085883a 	add	r2,r4,r2
 d00eb04:	10800204 	addi	r2,r2,8
 d00eb08:	10c000c5 	stb	r3,3(r2)
    if (pevent->OSEventTbl[y] == 0) {
 d00eb0c:	e0fffd03 	ldbu	r3,-12(fp)
 d00eb10:	e0bfff17 	ldw	r2,-4(fp)
 d00eb14:	1885883a 	add	r2,r3,r2
 d00eb18:	10800204 	addi	r2,r2,8
 d00eb1c:	108000c3 	ldbu	r2,3(r2)
 d00eb20:	10803fcc 	andi	r2,r2,255
 d00eb24:	1004c03a 	cmpne	r2,r2,zero
 d00eb28:	10000a1e 	bne	r2,zero,d00eb54 <OS_EventTaskRemove+0xa8>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 d00eb2c:	e0bfff17 	ldw	r2,-4(fp)
 d00eb30:	10800283 	ldbu	r2,10(r2)
 d00eb34:	1007883a 	mov	r3,r2
 d00eb38:	e0bffe17 	ldw	r2,-8(fp)
 d00eb3c:	10800d83 	ldbu	r2,54(r2)
 d00eb40:	0084303a 	nor	r2,zero,r2
 d00eb44:	1884703a 	and	r2,r3,r2
 d00eb48:	1007883a 	mov	r3,r2
 d00eb4c:	e0bfff17 	ldw	r2,-4(fp)
 d00eb50:	10c00285 	stb	r3,10(r2)
    }
}
 d00eb54:	e037883a 	mov	sp,fp
 d00eb58:	df000017 	ldw	fp,0(sp)
 d00eb5c:	dec00104 	addi	sp,sp,4
 d00eb60:	f800283a 	ret

0d00eb64 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 d00eb64:	defffa04 	addi	sp,sp,-24
 d00eb68:	df000515 	stw	fp,20(sp)
 d00eb6c:	df000504 	addi	fp,sp,20
 d00eb70:	e13ffe15 	stw	r4,-8(fp)
 d00eb74:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 d00eb78:	e0bffe17 	ldw	r2,-8(fp)
 d00eb7c:	10800d03 	ldbu	r2,52(r2)
 d00eb80:	e0bffb85 	stb	r2,-18(fp)
    bity    =  ptcb->OSTCBBitY;
 d00eb84:	e0bffe17 	ldw	r2,-8(fp)
 d00eb88:	10800d83 	ldbu	r2,54(r2)
 d00eb8c:	e0bffb45 	stb	r2,-19(fp)
    bitx    =  ptcb->OSTCBBitX;
 d00eb90:	e0bffe17 	ldw	r2,-8(fp)
 d00eb94:	10800d43 	ldbu	r2,53(r2)
 d00eb98:	e0bffb05 	stb	r2,-20(fp)
    pevents =  pevents_multi;
 d00eb9c:	e0bfff17 	ldw	r2,-4(fp)
 d00eba0:	e0bffd15 	stw	r2,-12(fp)
    pevent  = *pevents;
 d00eba4:	e0bffd17 	ldw	r2,-12(fp)
 d00eba8:	10800017 	ldw	r2,0(r2)
 d00ebac:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 d00ebb0:	00002606 	br	d00ec4c <OS_EventTaskRemoveMulti+0xe8>
        pevent->OSEventTbl[y]  &= ~bitx;
 d00ebb4:	e13ffb83 	ldbu	r4,-18(fp)
 d00ebb8:	e0fffb83 	ldbu	r3,-18(fp)
 d00ebbc:	e0bffc17 	ldw	r2,-16(fp)
 d00ebc0:	1885883a 	add	r2,r3,r2
 d00ebc4:	10800204 	addi	r2,r2,8
 d00ebc8:	108000c3 	ldbu	r2,3(r2)
 d00ebcc:	1007883a 	mov	r3,r2
 d00ebd0:	e0bffb03 	ldbu	r2,-20(fp)
 d00ebd4:	0084303a 	nor	r2,zero,r2
 d00ebd8:	1884703a 	and	r2,r3,r2
 d00ebdc:	1007883a 	mov	r3,r2
 d00ebe0:	e0bffc17 	ldw	r2,-16(fp)
 d00ebe4:	2085883a 	add	r2,r4,r2
 d00ebe8:	10800204 	addi	r2,r2,8
 d00ebec:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y] == 0) {
 d00ebf0:	e0fffb83 	ldbu	r3,-18(fp)
 d00ebf4:	e0bffc17 	ldw	r2,-16(fp)
 d00ebf8:	1885883a 	add	r2,r3,r2
 d00ebfc:	10800204 	addi	r2,r2,8
 d00ec00:	108000c3 	ldbu	r2,3(r2)
 d00ec04:	10803fcc 	andi	r2,r2,255
 d00ec08:	1004c03a 	cmpne	r2,r2,zero
 d00ec0c:	1000091e 	bne	r2,zero,d00ec34 <OS_EventTaskRemoveMulti+0xd0>
            pevent->OSEventGrp &= ~bity;
 d00ec10:	e0bffc17 	ldw	r2,-16(fp)
 d00ec14:	10800283 	ldbu	r2,10(r2)
 d00ec18:	1007883a 	mov	r3,r2
 d00ec1c:	e0bffb43 	ldbu	r2,-19(fp)
 d00ec20:	0084303a 	nor	r2,zero,r2
 d00ec24:	1884703a 	and	r2,r3,r2
 d00ec28:	1007883a 	mov	r3,r2
 d00ec2c:	e0bffc17 	ldw	r2,-16(fp)
 d00ec30:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 d00ec34:	e0bffd17 	ldw	r2,-12(fp)
 d00ec38:	10800104 	addi	r2,r2,4
 d00ec3c:	e0bffd15 	stw	r2,-12(fp)
        pevent = *pevents;
 d00ec40:	e0bffd17 	ldw	r2,-12(fp)
 d00ec44:	10800017 	ldw	r2,0(r2)
 d00ec48:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 d00ec4c:	e0bffc17 	ldw	r2,-16(fp)
 d00ec50:	1004c03a 	cmpne	r2,r2,zero
 d00ec54:	103fd71e 	bne	r2,zero,d00ebb4 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 d00ec58:	e037883a 	mov	sp,fp
 d00ec5c:	df000017 	ldw	fp,0(sp)
 d00ec60:	dec00104 	addi	sp,sp,4
 d00ec64:	f800283a 	ret

0d00ec68 <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 d00ec68:	defffc04 	addi	sp,sp,-16
 d00ec6c:	df000315 	stw	fp,12(sp)
 d00ec70:	df000304 	addi	fp,sp,12
 d00ec74:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 d00ec78:	e0bfff17 	ldw	r2,-4(fp)
 d00ec7c:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 d00ec80:	e0bfff17 	ldw	r2,-4(fp)
 d00ec84:	108002c4 	addi	r2,r2,11
 d00ec88:	e0bffe15 	stw	r2,-8(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d00ec8c:	e03ffd05 	stb	zero,-12(fp)
 d00ec90:	00000806 	br	d00ecb4 <OS_EventWaitListInit+0x4c>
        *ptbl++ = 0;
 d00ec94:	e0bffe17 	ldw	r2,-8(fp)
 d00ec98:	10000005 	stb	zero,0(r2)
 d00ec9c:	e0bffe17 	ldw	r2,-8(fp)
 d00eca0:	10800044 	addi	r2,r2,1
 d00eca4:	e0bffe15 	stw	r2,-8(fp)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d00eca8:	e0bffd03 	ldbu	r2,-12(fp)
 d00ecac:	10800044 	addi	r2,r2,1
 d00ecb0:	e0bffd05 	stb	r2,-12(fp)
 d00ecb4:	e0bffd03 	ldbu	r2,-12(fp)
 d00ecb8:	108000f0 	cmpltui	r2,r2,3
 d00ecbc:	103ff51e 	bne	r2,zero,d00ec94 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 d00ecc0:	e037883a 	mov	sp,fp
 d00ecc4:	df000017 	ldw	fp,0(sp)
 d00ecc8:	dec00104 	addi	sp,sp,4
 d00eccc:	f800283a 	ret

0d00ecd0 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 d00ecd0:	defffb04 	addi	sp,sp,-20
 d00ecd4:	dfc00415 	stw	ra,16(sp)
 d00ecd8:	df000315 	stw	fp,12(sp)
 d00ecdc:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 d00ece0:	010341b4 	movhi	r4,3334
 d00ece4:	212d1f04 	addi	r4,r4,-19332
 d00ece8:	0142d004 	movi	r5,2880
 d00ecec:	d00f0340 	call	d00f034 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 d00ecf0:	008341b4 	movhi	r2,3334
 d00ecf4:	10ad1f04 	addi	r2,r2,-19332
 d00ecf8:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 d00ecfc:	008341b4 	movhi	r2,3334
 d00ed00:	10ad2b04 	addi	r2,r2,-19284
 d00ed04:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 d00ed08:	e03fff0d 	sth	zero,-4(fp)
 d00ed0c:	00001306 	br	d00ed5c <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d00ed10:	e0bffe17 	ldw	r2,-8(fp)
 d00ed14:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 d00ed18:	e0fffe17 	ldw	r3,-8(fp)
 d00ed1c:	e0bffd17 	ldw	r2,-12(fp)
 d00ed20:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 d00ed24:	e0fffe17 	ldw	r3,-8(fp)
 d00ed28:	00800fc4 	movi	r2,63
 d00ed2c:	18800385 	stb	r2,14(r3)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 d00ed30:	e0bffe17 	ldw	r2,-8(fp)
 d00ed34:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 d00ed38:	e0bffe17 	ldw	r2,-8(fp)
 d00ed3c:	10800c04 	addi	r2,r2,48
 d00ed40:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 d00ed44:	e0bffd17 	ldw	r2,-12(fp)
 d00ed48:	10800c04 	addi	r2,r2,48
 d00ed4c:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 d00ed50:	e0bfff0b 	ldhu	r2,-4(fp)
 d00ed54:	10800044 	addi	r2,r2,1
 d00ed58:	e0bfff0d 	sth	r2,-4(fp)
 d00ed5c:	e0bfff0b 	ldhu	r2,-4(fp)
 d00ed60:	10800ef0 	cmpltui	r2,r2,59
 d00ed64:	103fea1e 	bne	r2,zero,d00ed10 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 d00ed68:	e0bffe17 	ldw	r2,-8(fp)
 d00ed6c:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 d00ed70:	e0bffe17 	ldw	r2,-8(fp)
 d00ed74:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 d00ed78:	e0fffe17 	ldw	r3,-8(fp)
 d00ed7c:	00800fc4 	movi	r2,63
 d00ed80:	18800385 	stb	r2,14(r3)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 d00ed84:	e0bffe17 	ldw	r2,-8(fp)
 d00ed88:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 d00ed8c:	008341b4 	movhi	r2,3334
 d00ed90:	10ad1f04 	addi	r2,r2,-19332
 d00ed94:	d0a07815 	stw	r2,-32288(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 d00ed98:	e037883a 	mov	sp,fp
 d00ed9c:	dfc00117 	ldw	ra,4(sp)
 d00eda0:	df000017 	ldw	fp,0(sp)
 d00eda4:	dec00204 	addi	sp,sp,8
 d00eda8:	f800283a 	ret

0d00edac <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 d00edac:	deffff04 	addi	sp,sp,-4
 d00edb0:	df000015 	stw	fp,0(sp)
 d00edb4:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 d00edb8:	d0207b15 	stw	zero,-32276(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 d00edbc:	d0207905 	stb	zero,-32284(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 d00edc0:	d0206b05 	stb	zero,-32340(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 d00edc4:	d0207345 	stb	zero,-32307(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 d00edc8:	d0206b45 	stb	zero,-32339(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 d00edcc:	d0207015 	stw	zero,-32320(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 d00edd0:	d0206c15 	stw	zero,-32336(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 d00edd4:	d0207e15 	stw	zero,-32264(gp)
    OSIdleCtrMax  = 0L;
 d00edd8:	d0207115 	stw	zero,-32316(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 d00eddc:	d0207d05 	stb	zero,-32268(gp)
#endif
}
 d00ede0:	e037883a 	mov	sp,fp
 d00ede4:	df000017 	ldw	fp,0(sp)
 d00ede8:	dec00104 	addi	sp,sp,4
 d00edec:	f800283a 	ret

0d00edf0 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 d00edf0:	defffd04 	addi	sp,sp,-12
 d00edf4:	df000215 	stw	fp,8(sp)
 d00edf8:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 d00edfc:	d0207705 	stb	zero,-32292(gp)
    prdytbl       = &OSRdyTbl[0];
 d00ee00:	d0a07744 	addi	r2,gp,-32291
 d00ee04:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 d00ee08:	e03fff05 	stb	zero,-4(fp)
 d00ee0c:	00000806 	br	d00ee30 <OS_InitRdyList+0x40>
        *prdytbl++ = 0;
 d00ee10:	e0bffe17 	ldw	r2,-8(fp)
 d00ee14:	10000005 	stb	zero,0(r2)
 d00ee18:	e0bffe17 	ldw	r2,-8(fp)
 d00ee1c:	10800044 	addi	r2,r2,1
 d00ee20:	e0bffe15 	stw	r2,-8(fp)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 d00ee24:	e0bfff03 	ldbu	r2,-4(fp)
 d00ee28:	10800044 	addi	r2,r2,1
 d00ee2c:	e0bfff05 	stb	r2,-4(fp)
 d00ee30:	e0bfff03 	ldbu	r2,-4(fp)
 d00ee34:	108000f0 	cmpltui	r2,r2,3
 d00ee38:	103ff51e 	bne	r2,zero,d00ee10 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 d00ee3c:	d0206d45 	stb	zero,-32331(gp)
    OSPrioHighRdy = 0;
 d00ee40:	d0206d05 	stb	zero,-32332(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 d00ee44:	d0207515 	stw	zero,-32300(gp)
    OSTCBCur      = (OS_TCB *)0;
 d00ee48:	d0207a15 	stw	zero,-32280(gp)
}
 d00ee4c:	e037883a 	mov	sp,fp
 d00ee50:	df000017 	ldw	fp,0(sp)
 d00ee54:	dec00104 	addi	sp,sp,4
 d00ee58:	f800283a 	ret

0d00ee5c <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 d00ee5c:	defff804 	addi	sp,sp,-32
 d00ee60:	dfc00715 	stw	ra,28(sp)
 d00ee64:	df000615 	stw	fp,24(sp)
 d00ee68:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 d00ee6c:	018341b4 	movhi	r6,3334
 d00ee70:	31ad1e04 	addi	r6,r6,-19336
 d00ee74:	00bfffd4 	movui	r2,65535
 d00ee78:	d8800015 	stw	r2,0(sp)
 d00ee7c:	008341b4 	movhi	r2,3334
 d00ee80:	10ab1f04 	addi	r2,r2,-21380
 d00ee84:	d8800115 	stw	r2,4(sp)
 d00ee88:	00808004 	movi	r2,512
 d00ee8c:	d8800215 	stw	r2,8(sp)
 d00ee90:	d8000315 	stw	zero,12(sp)
 d00ee94:	008000c4 	movi	r2,3
 d00ee98:	d8800415 	stw	r2,16(sp)
 d00ee9c:	01034074 	movhi	r4,3329
 d00eea0:	213cc404 	addi	r4,r4,-3312
 d00eea4:	000b883a 	mov	r5,zero
 d00eea8:	01c00504 	movi	r7,20
 d00eeac:	d0140f00 	call	d0140f0 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 d00eeb0:	01434174 	movhi	r5,3333
 d00eeb4:	2971f204 	addi	r5,r5,-14392
 d00eeb8:	01000504 	movi	r4,20
 d00eebc:	e1bfff04 	addi	r6,fp,-4
 d00eec0:	d014a240 	call	d014a24 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 d00eec4:	e037883a 	mov	sp,fp
 d00eec8:	dfc00117 	ldw	ra,4(sp)
 d00eecc:	df000017 	ldw	fp,0(sp)
 d00eed0:	dec00204 	addi	sp,sp,8
 d00eed4:	f800283a 	ret

0d00eed8 <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 d00eed8:	defff804 	addi	sp,sp,-32
 d00eedc:	dfc00715 	stw	ra,28(sp)
 d00eee0:	df000615 	stw	fp,24(sp)
 d00eee4:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 d00eee8:	018341b4 	movhi	r6,3334
 d00eeec:	31aaa604 	addi	r6,r6,-21864
 d00eef0:	00bfff94 	movui	r2,65534
 d00eef4:	d8800015 	stw	r2,0(sp)
 d00eef8:	008341b4 	movhi	r2,3334
 d00eefc:	10a8a704 	addi	r2,r2,-23908
 d00ef00:	d8800115 	stw	r2,4(sp)
 d00ef04:	00808004 	movi	r2,512
 d00ef08:	d8800215 	stw	r2,8(sp)
 d00ef0c:	d8000315 	stw	zero,12(sp)
 d00ef10:	008000c4 	movi	r2,3
 d00ef14:	d8800415 	stw	r2,16(sp)
 d00ef18:	01034074 	movhi	r4,3329
 d00ef1c:	213cdb04 	addi	r4,r4,-3220
 d00ef20:	000b883a 	mov	r5,zero
 d00ef24:	01c004c4 	movi	r7,19
 d00ef28:	d0140f00 	call	d0140f0 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 d00ef2c:	01434174 	movhi	r5,3333
 d00ef30:	2971f604 	addi	r5,r5,-14376
 d00ef34:	010004c4 	movi	r4,19
 d00ef38:	e1bfff04 	addi	r6,fp,-4
 d00ef3c:	d014a240 	call	d014a24 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 d00ef40:	e037883a 	mov	sp,fp
 d00ef44:	dfc00117 	ldw	ra,4(sp)
 d00ef48:	df000017 	ldw	fp,0(sp)
 d00ef4c:	dec00204 	addi	sp,sp,8
 d00ef50:	f800283a 	ret

0d00ef54 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 d00ef54:	defffb04 	addi	sp,sp,-20
 d00ef58:	dfc00415 	stw	ra,16(sp)
 d00ef5c:	df000315 	stw	fp,12(sp)
 d00ef60:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 d00ef64:	010341b4 	movhi	r4,3334
 d00ef68:	212fef04 	addi	r4,r4,-16452
 d00ef6c:	01414404 	movi	r5,1296
 d00ef70:	d00f0340 	call	d00f034 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 d00ef74:	010341b4 	movhi	r4,3334
 d00ef78:	21313304 	addi	r4,r4,-15156
 d00ef7c:	01401504 	movi	r5,84
 d00ef80:	d00f0340 	call	d00f034 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 d00ef84:	008341b4 	movhi	r2,3334
 d00ef88:	10afef04 	addi	r2,r2,-16452
 d00ef8c:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 d00ef90:	008341b4 	movhi	r2,3334
 d00ef94:	10b00a04 	addi	r2,r2,-16344
 d00ef98:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 d00ef9c:	e03fff05 	stb	zero,-4(fp)
 d00efa0:	00001106 	br	d00efe8 <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 d00efa4:	e0fffe17 	ldw	r3,-8(fp)
 d00efa8:	e0bffd17 	ldw	r2,-12(fp)
 d00efac:	18800515 	stw	r2,20(r3)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 d00efb0:	e0fffe17 	ldw	r3,-8(fp)
 d00efb4:	00800fc4 	movi	r2,63
 d00efb8:	18801305 	stb	r2,76(r3)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 d00efbc:	e0bffe17 	ldw	r2,-8(fp)
 d00efc0:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 d00efc4:	e0bffe17 	ldw	r2,-8(fp)
 d00efc8:	10801b04 	addi	r2,r2,108
 d00efcc:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 d00efd0:	e0bffd17 	ldw	r2,-12(fp)
 d00efd4:	10801b04 	addi	r2,r2,108
 d00efd8:	e0bffd15 	stw	r2,-12(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 d00efdc:	e0bfff03 	ldbu	r2,-4(fp)
 d00efe0:	10800044 	addi	r2,r2,1
 d00efe4:	e0bfff05 	stb	r2,-4(fp)
 d00efe8:	e0bfff03 	ldbu	r2,-4(fp)
 d00efec:	108002f0 	cmpltui	r2,r2,11
 d00eff0:	103fec1e 	bne	r2,zero,d00efa4 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 d00eff4:	e0bffe17 	ldw	r2,-8(fp)
 d00eff8:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 d00effc:	e0fffe17 	ldw	r3,-8(fp)
 d00f000:	00800fc4 	movi	r2,63
 d00f004:	18801305 	stb	r2,76(r3)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 d00f008:	e0bffe17 	ldw	r2,-8(fp)
 d00f00c:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 d00f010:	d0206e15 	stw	zero,-32328(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 d00f014:	008341b4 	movhi	r2,3334
 d00f018:	10afef04 	addi	r2,r2,-16452
 d00f01c:	d0a07215 	stw	r2,-32312(gp)
}
 d00f020:	e037883a 	mov	sp,fp
 d00f024:	dfc00117 	ldw	ra,4(sp)
 d00f028:	df000017 	ldw	fp,0(sp)
 d00f02c:	dec00204 	addi	sp,sp,8
 d00f030:	f800283a 	ret

0d00f034 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 d00f034:	defffd04 	addi	sp,sp,-12
 d00f038:	df000215 	stw	fp,8(sp)
 d00f03c:	df000204 	addi	fp,sp,8
 d00f040:	e13ffe15 	stw	r4,-8(fp)
 d00f044:	e17fff0d 	sth	r5,-4(fp)
    while (size > 0) {
 d00f048:	00000806 	br	d00f06c <OS_MemClr+0x38>
        *pdest++ = (INT8U)0;
 d00f04c:	e0bffe17 	ldw	r2,-8(fp)
 d00f050:	10000005 	stb	zero,0(r2)
 d00f054:	e0bffe17 	ldw	r2,-8(fp)
 d00f058:	10800044 	addi	r2,r2,1
 d00f05c:	e0bffe15 	stw	r2,-8(fp)
        size--;
 d00f060:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f064:	10bfffc4 	addi	r2,r2,-1
 d00f068:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 d00f06c:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f070:	1004c03a 	cmpne	r2,r2,zero
 d00f074:	103ff51e 	bne	r2,zero,d00f04c <OS_MemClr+0x18>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 d00f078:	e037883a 	mov	sp,fp
 d00f07c:	df000017 	ldw	fp,0(sp)
 d00f080:	dec00104 	addi	sp,sp,4
 d00f084:	f800283a 	ret

0d00f088 <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 d00f088:	defffc04 	addi	sp,sp,-16
 d00f08c:	df000315 	stw	fp,12(sp)
 d00f090:	df000304 	addi	fp,sp,12
 d00f094:	e13ffd15 	stw	r4,-12(fp)
 d00f098:	e17ffe15 	stw	r5,-8(fp)
 d00f09c:	e1bfff0d 	sth	r6,-4(fp)
    while (size > 0) {
 d00f0a0:	00000d06 	br	d00f0d8 <OS_MemCopy+0x50>
        *pdest++ = *psrc++;
 d00f0a4:	e0bffe17 	ldw	r2,-8(fp)
 d00f0a8:	10c00003 	ldbu	r3,0(r2)
 d00f0ac:	e0bffd17 	ldw	r2,-12(fp)
 d00f0b0:	10c00005 	stb	r3,0(r2)
 d00f0b4:	e0bffd17 	ldw	r2,-12(fp)
 d00f0b8:	10800044 	addi	r2,r2,1
 d00f0bc:	e0bffd15 	stw	r2,-12(fp)
 d00f0c0:	e0bffe17 	ldw	r2,-8(fp)
 d00f0c4:	10800044 	addi	r2,r2,1
 d00f0c8:	e0bffe15 	stw	r2,-8(fp)
        size--;
 d00f0cc:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f0d0:	10bfffc4 	addi	r2,r2,-1
 d00f0d4:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 d00f0d8:	e0bfff0b 	ldhu	r2,-4(fp)
 d00f0dc:	1004c03a 	cmpne	r2,r2,zero
 d00f0e0:	103ff01e 	bne	r2,zero,d00f0a4 <OS_MemCopy+0x1c>
        *pdest++ = *psrc++;
        size--;
    }
}
 d00f0e4:	e037883a 	mov	sp,fp
 d00f0e8:	df000017 	ldw	fp,0(sp)
 d00f0ec:	dec00104 	addi	sp,sp,4
 d00f0f0:	f800283a 	ret

0d00f0f4 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 d00f0f4:	defffb04 	addi	sp,sp,-20
 d00f0f8:	dfc00415 	stw	ra,16(sp)
 d00f0fc:	df000315 	stw	fp,12(sp)
 d00f100:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d00f104:	e03fff15 	stw	zero,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f108:	0005303a 	rdctl	r2,status
 d00f10c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f110:	e0fffe17 	ldw	r3,-8(fp)
 d00f114:	00bfff84 	movi	r2,-2
 d00f118:	1884703a 	and	r2,r3,r2
 d00f11c:	1001703a 	wrctl	status,r2
  
  return context;
 d00f120:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 d00f124:	e0bfff15 	stw	r2,-4(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 d00f128:	d0a07903 	ldbu	r2,-32284(gp)
 d00f12c:	10803fcc 	andi	r2,r2,255
 d00f130:	1004c03a 	cmpne	r2,r2,zero
 d00f134:	10001b1e 	bne	r2,zero,d00f1a4 <OS_Sched+0xb0>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 d00f138:	d0a06b03 	ldbu	r2,-32340(gp)
 d00f13c:	10803fcc 	andi	r2,r2,255
 d00f140:	1004c03a 	cmpne	r2,r2,zero
 d00f144:	1000171e 	bne	r2,zero,d00f1a4 <OS_Sched+0xb0>
            OS_SchedNew();
 d00f148:	d00f1c80 	call	d00f1c8 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 d00f14c:	d0a06d03 	ldbu	r2,-32332(gp)
 d00f150:	d0e06d43 	ldbu	r3,-32331(gp)
 d00f154:	11003fcc 	andi	r4,r2,255
 d00f158:	18803fcc 	andi	r2,r3,255
 d00f15c:	20801126 	beq	r4,r2,d00f1a4 <OS_Sched+0xb0>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 d00f160:	d0a06d03 	ldbu	r2,-32332(gp)
 d00f164:	10803fcc 	andi	r2,r2,255
 d00f168:	00c341b4 	movhi	r3,3334
 d00f16c:	18f13304 	addi	r3,r3,-15156
 d00f170:	1085883a 	add	r2,r2,r2
 d00f174:	1085883a 	add	r2,r2,r2
 d00f178:	10c5883a 	add	r2,r2,r3
 d00f17c:	10800017 	ldw	r2,0(r2)
 d00f180:	d0a07515 	stw	r2,-32300(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 d00f184:	d0e07517 	ldw	r3,-32300(gp)
 d00f188:	18800e17 	ldw	r2,56(r3)
 d00f18c:	10800044 	addi	r2,r2,1
 d00f190:	18800e15 	stw	r2,56(r3)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 d00f194:	d0a07017 	ldw	r2,-32320(gp)
 d00f198:	10800044 	addi	r2,r2,1
 d00f19c:	d0a07015 	stw	r2,-32320(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 d00f1a0:	d039b880 	call	d039b88 <OSCtxSw>
 d00f1a4:	e0bfff17 	ldw	r2,-4(fp)
 d00f1a8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00f1ac:	e0bffd17 	ldw	r2,-12(fp)
 d00f1b0:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 d00f1b4:	e037883a 	mov	sp,fp
 d00f1b8:	dfc00117 	ldw	ra,4(sp)
 d00f1bc:	df000017 	ldw	fp,0(sp)
 d00f1c0:	dec00204 	addi	sp,sp,8
 d00f1c4:	f800283a 	ret

0d00f1c8 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 d00f1c8:	defffe04 	addi	sp,sp,-8
 d00f1cc:	df000115 	stw	fp,4(sp)
 d00f1d0:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 d00f1d4:	d0a07703 	ldbu	r2,-32292(gp)
 d00f1d8:	10c03fcc 	andi	r3,r2,255
 d00f1dc:	00834174 	movhi	r2,3333
 d00f1e0:	10b1b204 	addi	r2,r2,-14648
 d00f1e4:	10c5883a 	add	r2,r2,r3
 d00f1e8:	10800003 	ldbu	r2,0(r2)
 d00f1ec:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 d00f1f0:	e0bfff03 	ldbu	r2,-4(fp)
 d00f1f4:	100490fa 	slli	r2,r2,3
 d00f1f8:	1009883a 	mov	r4,r2
 d00f1fc:	e0ffff03 	ldbu	r3,-4(fp)
 d00f200:	d0a07744 	addi	r2,gp,-32291
 d00f204:	1885883a 	add	r2,r3,r2
 d00f208:	10800003 	ldbu	r2,0(r2)
 d00f20c:	10c03fcc 	andi	r3,r2,255
 d00f210:	00834174 	movhi	r2,3333
 d00f214:	10b1b204 	addi	r2,r2,-14648
 d00f218:	10c5883a 	add	r2,r2,r3
 d00f21c:	10800003 	ldbu	r2,0(r2)
 d00f220:	2085883a 	add	r2,r4,r2
 d00f224:	d0a06d05 	stb	r2,-32332(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 d00f228:	e037883a 	mov	sp,fp
 d00f22c:	df000017 	ldw	fp,0(sp)
 d00f230:	dec00104 	addi	sp,sp,4
 d00f234:	f800283a 	ret

0d00f238 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 d00f238:	defffc04 	addi	sp,sp,-16
 d00f23c:	df000315 	stw	fp,12(sp)
 d00f240:	df000304 	addi	fp,sp,12
 d00f244:	e13ffe15 	stw	r4,-8(fp)
 d00f248:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 d00f24c:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 d00f250:	00000d06 	br	d00f288 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
 d00f254:	e0bfff17 	ldw	r2,-4(fp)
 d00f258:	10c00003 	ldbu	r3,0(r2)
 d00f25c:	e0bffe17 	ldw	r2,-8(fp)
 d00f260:	10c00005 	stb	r3,0(r2)
 d00f264:	e0bffe17 	ldw	r2,-8(fp)
 d00f268:	10800044 	addi	r2,r2,1
 d00f26c:	e0bffe15 	stw	r2,-8(fp)
 d00f270:	e0bfff17 	ldw	r2,-4(fp)
 d00f274:	10800044 	addi	r2,r2,1
 d00f278:	e0bfff15 	stw	r2,-4(fp)
        len++;
 d00f27c:	e0bffd03 	ldbu	r2,-12(fp)
 d00f280:	10800044 	addi	r2,r2,1
 d00f284:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 d00f288:	e0bfff17 	ldw	r2,-4(fp)
 d00f28c:	10800003 	ldbu	r2,0(r2)
 d00f290:	10803fcc 	andi	r2,r2,255
 d00f294:	1004c03a 	cmpne	r2,r2,zero
 d00f298:	103fee1e 	bne	r2,zero,d00f254 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 d00f29c:	e0bffe17 	ldw	r2,-8(fp)
 d00f2a0:	10000005 	stb	zero,0(r2)
    return (len);
 d00f2a4:	e0bffd03 	ldbu	r2,-12(fp)
}
 d00f2a8:	e037883a 	mov	sp,fp
 d00f2ac:	df000017 	ldw	fp,0(sp)
 d00f2b0:	dec00104 	addi	sp,sp,4
 d00f2b4:	f800283a 	ret

0d00f2b8 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 d00f2b8:	defffd04 	addi	sp,sp,-12
 d00f2bc:	df000215 	stw	fp,8(sp)
 d00f2c0:	df000204 	addi	fp,sp,8
 d00f2c4:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 d00f2c8:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 d00f2cc:	00000606 	br	d00f2e8 <OS_StrLen+0x30>
        psrc++;
 d00f2d0:	e0bfff17 	ldw	r2,-4(fp)
 d00f2d4:	10800044 	addi	r2,r2,1
 d00f2d8:	e0bfff15 	stw	r2,-4(fp)
        len++;
 d00f2dc:	e0bffe03 	ldbu	r2,-8(fp)
 d00f2e0:	10800044 	addi	r2,r2,1
 d00f2e4:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 d00f2e8:	e0bfff17 	ldw	r2,-4(fp)
 d00f2ec:	10800003 	ldbu	r2,0(r2)
 d00f2f0:	10803fcc 	andi	r2,r2,255
 d00f2f4:	1004c03a 	cmpne	r2,r2,zero
 d00f2f8:	103ff51e 	bne	r2,zero,d00f2d0 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 d00f2fc:	e0bffe03 	ldbu	r2,-8(fp)
}
 d00f300:	e037883a 	mov	sp,fp
 d00f304:	df000017 	ldw	fp,0(sp)
 d00f308:	dec00104 	addi	sp,sp,4
 d00f30c:	f800283a 	ret

0d00f310 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 d00f310:	defffa04 	addi	sp,sp,-24
 d00f314:	dfc00515 	stw	ra,20(sp)
 d00f318:	df000415 	stw	fp,16(sp)
 d00f31c:	df000404 	addi	fp,sp,16
 d00f320:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00f324:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f328:	0005303a 	rdctl	r2,status
 d00f32c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f330:	e0fffd17 	ldw	r3,-12(fp)
 d00f334:	00bfff84 	movi	r2,-2
 d00f338:	1884703a 	and	r2,r3,r2
 d00f33c:	1001703a 	wrctl	status,r2
  
  return context;
 d00f340:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 d00f344:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtr++;
 d00f348:	d0a06c17 	ldw	r2,-32336(gp)
 d00f34c:	10800044 	addi	r2,r2,1
 d00f350:	d0a06c15 	stw	r2,-32336(gp)
 d00f354:	e0bffe17 	ldw	r2,-8(fp)
 d00f358:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00f35c:	e0bffc17 	ldw	r2,-16(fp)
 d00f360:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 d00f364:	d03a0400 	call	d03a040 <OSTaskIdleHook>
    }
 d00f368:	003fef06 	br	d00f328 <OS_TaskIdle+0x18>

0d00f36c <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 d00f36c:	defffa04 	addi	sp,sp,-24
 d00f370:	dfc00515 	stw	ra,20(sp)
 d00f374:	df000415 	stw	fp,16(sp)
 d00f378:	df000404 	addi	fp,sp,16
 d00f37c:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d00f380:	e03ffe15 	stw	zero,-8(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 d00f384:	00000206 	br	d00f390 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 d00f388:	01000504 	movi	r4,20
 d00f38c:	d0153e80 	call	d0153e8 <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 d00f390:	d0a07d03 	ldbu	r2,-32268(gp)
 d00f394:	10803fcc 	andi	r2,r2,255
 d00f398:	1005003a 	cmpeq	r2,r2,zero
 d00f39c:	103ffa1e 	bne	r2,zero,d00f388 <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 d00f3a0:	d0e07117 	ldw	r3,-32316(gp)
 d00f3a4:	00801904 	movi	r2,100
 d00f3a8:	1885203a 	divu	r2,r3,r2
 d00f3ac:	d0a07115 	stw	r2,-32316(gp)
    if (OSIdleCtrMax == 0L) {
 d00f3b0:	d0a07117 	ldw	r2,-32316(gp)
 d00f3b4:	1004c03a 	cmpne	r2,r2,zero
 d00f3b8:	1000031e 	bne	r2,zero,d00f3c8 <OS_TaskStat+0x5c>
        OSCPUUsage = 0;
 d00f3bc:	d0207305 	stb	zero,-32308(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 d00f3c0:	01003fc4 	movi	r4,255
 d00f3c4:	d014ffc0 	call	d014ffc <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f3c8:	0005303a 	rdctl	r2,status
 d00f3cc:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f3d0:	e0fffd17 	ldw	r3,-12(fp)
 d00f3d4:	00bfff84 	movi	r2,-2
 d00f3d8:	1884703a 	and	r2,r3,r2
 d00f3dc:	1001703a 	wrctl	status,r2
  
  return context;
 d00f3e0:	e0bffd17 	ldw	r2,-12(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 d00f3e4:	e0bffe15 	stw	r2,-8(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 d00f3e8:	d0a06c17 	ldw	r2,-32336(gp)
 d00f3ec:	d0a07e15 	stw	r2,-32264(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 d00f3f0:	d0206c15 	stw	zero,-32336(gp)
 d00f3f4:	e0bffe17 	ldw	r2,-8(fp)
 d00f3f8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00f3fc:	e0bffc17 	ldw	r2,-16(fp)
 d00f400:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 d00f404:	d0e07e17 	ldw	r3,-32264(gp)
 d00f408:	d0a07117 	ldw	r2,-32316(gp)
 d00f40c:	1885203a 	divu	r2,r3,r2
 d00f410:	1007883a 	mov	r3,r2
 d00f414:	00801904 	movi	r2,100
 d00f418:	10c5c83a 	sub	r2,r2,r3
 d00f41c:	d0a07305 	stb	r2,-32308(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 d00f420:	d039fc40 	call	d039fc4 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 d00f424:	d00f4340 	call	d00f434 <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 d00f428:	01000284 	movi	r4,10
 d00f42c:	d0153e80 	call	d0153e8 <OSTimeDly>
    }
 d00f430:	003fe506 	br	d00f3c8 <OS_TaskStat+0x5c>

0d00f434 <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 d00f434:	defffa04 	addi	sp,sp,-24
 d00f438:	dfc00515 	stw	ra,20(sp)
 d00f43c:	df000415 	stw	fp,16(sp)
 d00f440:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 d00f444:	e03ffc05 	stb	zero,-16(fp)
 d00f448:	00002406 	br	d00f4dc <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 d00f44c:	e13ffc03 	ldbu	r4,-16(fp)
 d00f450:	e17ffe04 	addi	r5,fp,-8
 d00f454:	d014e000 	call	d014e00 <OSTaskStkChk>
 d00f458:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 d00f45c:	e0bffc43 	ldbu	r2,-15(fp)
 d00f460:	1004c03a 	cmpne	r2,r2,zero
 d00f464:	10001a1e 	bne	r2,zero,d00f4d0 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 d00f468:	e0bffc03 	ldbu	r2,-16(fp)
 d00f46c:	00c341b4 	movhi	r3,3334
 d00f470:	18f13304 	addi	r3,r3,-15156
 d00f474:	1085883a 	add	r2,r2,r2
 d00f478:	1085883a 	add	r2,r2,r2
 d00f47c:	10c5883a 	add	r2,r2,r3
 d00f480:	10800017 	ldw	r2,0(r2)
 d00f484:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 d00f488:	e0bffd17 	ldw	r2,-12(fp)
 d00f48c:	1005003a 	cmpeq	r2,r2,zero
 d00f490:	10000f1e 	bne	r2,zero,d00f4d0 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 d00f494:	e0bffd17 	ldw	r2,-12(fp)
 d00f498:	10800060 	cmpeqi	r2,r2,1
 d00f49c:	10000c1e 	bne	r2,zero,d00f4d0 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 d00f4a0:	e0bffd17 	ldw	r2,-12(fp)
 d00f4a4:	10c00217 	ldw	r3,8(r2)
 d00f4a8:	e0bffd17 	ldw	r2,-12(fp)
 d00f4ac:	10800317 	ldw	r2,12(r2)
 d00f4b0:	1085883a 	add	r2,r2,r2
 d00f4b4:	1085883a 	add	r2,r2,r2
 d00f4b8:	1887883a 	add	r3,r3,r2
 d00f4bc:	e0bffd17 	ldw	r2,-12(fp)
 d00f4c0:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 d00f4c4:	e0ffff17 	ldw	r3,-4(fp)
 d00f4c8:	e0bffd17 	ldw	r2,-12(fp)
 d00f4cc:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 d00f4d0:	e0bffc03 	ldbu	r2,-16(fp)
 d00f4d4:	10800044 	addi	r2,r2,1
 d00f4d8:	e0bffc05 	stb	r2,-16(fp)
 d00f4dc:	e0bffc03 	ldbu	r2,-16(fp)
 d00f4e0:	10800570 	cmpltui	r2,r2,21
 d00f4e4:	103fd91e 	bne	r2,zero,d00f44c <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 d00f4e8:	e037883a 	mov	sp,fp
 d00f4ec:	dfc00117 	ldw	ra,4(sp)
 d00f4f0:	df000017 	ldw	fp,0(sp)
 d00f4f4:	dec00204 	addi	sp,sp,8
 d00f4f8:	f800283a 	ret

0d00f4fc <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 d00f4fc:	defff104 	addi	sp,sp,-60
 d00f500:	dfc00e15 	stw	ra,56(sp)
 d00f504:	df000d15 	stw	fp,52(sp)
 d00f508:	df000d04 	addi	fp,sp,52
 d00f50c:	e17ffb15 	stw	r5,-20(fp)
 d00f510:	e1bffc15 	stw	r6,-16(fp)
 d00f514:	e0800417 	ldw	r2,16(fp)
 d00f518:	e13ffa05 	stb	r4,-24(fp)
 d00f51c:	e1fffd0d 	sth	r7,-12(fp)
 d00f520:	e0bffe0d 	sth	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d00f524:	e03ff815 	stw	zero,-32(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f528:	0005303a 	rdctl	r2,status
 d00f52c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f530:	e0fff717 	ldw	r3,-36(fp)
 d00f534:	00bfff84 	movi	r2,-2
 d00f538:	1884703a 	and	r2,r3,r2
 d00f53c:	1001703a 	wrctl	status,r2
  
  return context;
 d00f540:	e0bff717 	ldw	r2,-36(fp)
#endif



    OS_ENTER_CRITICAL();
 d00f544:	e0bff815 	stw	r2,-32(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 d00f548:	d0a07217 	ldw	r2,-32312(gp)
 d00f54c:	e0bff915 	stw	r2,-28(fp)
    if (ptcb != (OS_TCB *)0) {
 d00f550:	e0bff917 	ldw	r2,-28(fp)
 d00f554:	1005003a 	cmpeq	r2,r2,zero
 d00f558:	1000941e 	bne	r2,zero,d00f7ac <OS_TCBInit+0x2b0>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 d00f55c:	e0bff917 	ldw	r2,-28(fp)
 d00f560:	10800517 	ldw	r2,20(r2)
 d00f564:	d0a07215 	stw	r2,-32312(gp)
 d00f568:	e0bff817 	ldw	r2,-32(fp)
 d00f56c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00f570:	e0bff617 	ldw	r2,-40(fp)
 d00f574:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 d00f578:	e0fff917 	ldw	r3,-28(fp)
 d00f57c:	e0bffb17 	ldw	r2,-20(fp)
 d00f580:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 d00f584:	e0fff917 	ldw	r3,-28(fp)
 d00f588:	e0bffa03 	ldbu	r2,-24(fp)
 d00f58c:	18800c85 	stb	r2,50(r3)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 d00f590:	e0bff917 	ldw	r2,-28(fp)
 d00f594:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 d00f598:	e0bff917 	ldw	r2,-28(fp)
 d00f59c:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 d00f5a0:	e0bff917 	ldw	r2,-28(fp)
 d00f5a4:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 d00f5a8:	e0fff917 	ldw	r3,-28(fp)
 d00f5ac:	e0800317 	ldw	r2,12(fp)
 d00f5b0:	18800115 	stw	r2,4(r3)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 d00f5b4:	e0fff917 	ldw	r3,-28(fp)
 d00f5b8:	e0800217 	ldw	r2,8(fp)
 d00f5bc:	18800315 	stw	r2,12(r3)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 d00f5c0:	e0fff917 	ldw	r3,-28(fp)
 d00f5c4:	e0bffc17 	ldw	r2,-16(fp)
 d00f5c8:	18800215 	stw	r2,8(r3)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 d00f5cc:	e0fff917 	ldw	r3,-28(fp)
 d00f5d0:	e0bffe0b 	ldhu	r2,-8(fp)
 d00f5d4:	1880040d 	sth	r2,16(r3)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 d00f5d8:	e0fff917 	ldw	r3,-28(fp)
 d00f5dc:	e0bffd0b 	ldhu	r2,-12(fp)
 d00f5e0:	1880048d 	sth	r2,18(r3)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 d00f5e4:	e0bff917 	ldw	r2,-28(fp)
 d00f5e8:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 d00f5ec:	e0bffa03 	ldbu	r2,-24(fp)
 d00f5f0:	1004d0fa 	srli	r2,r2,3
 d00f5f4:	1007883a 	mov	r3,r2
 d00f5f8:	e0bff917 	ldw	r2,-28(fp)
 d00f5fc:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 d00f600:	e0bffa03 	ldbu	r2,-24(fp)
 d00f604:	108001cc 	andi	r2,r2,7
 d00f608:	1007883a 	mov	r3,r2
 d00f60c:	e0bff917 	ldw	r2,-28(fp)
 d00f610:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 d00f614:	e0bff917 	ldw	r2,-28(fp)
 d00f618:	10800d03 	ldbu	r2,52(r2)
 d00f61c:	10c03fcc 	andi	r3,r2,255
 d00f620:	00800044 	movi	r2,1
 d00f624:	10c4983a 	sll	r2,r2,r3
 d00f628:	1007883a 	mov	r3,r2
 d00f62c:	e0bff917 	ldw	r2,-28(fp)
 d00f630:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 d00f634:	e0bff917 	ldw	r2,-28(fp)
 d00f638:	10800cc3 	ldbu	r2,51(r2)
 d00f63c:	10c03fcc 	andi	r3,r2,255
 d00f640:	00800044 	movi	r2,1
 d00f644:	10c4983a 	sll	r2,r2,r3
 d00f648:	1007883a 	mov	r3,r2
 d00f64c:	e0bff917 	ldw	r2,-28(fp)
 d00f650:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 d00f654:	e0bff917 	ldw	r2,-28(fp)
 d00f658:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 d00f65c:	e0bff917 	ldw	r2,-28(fp)
 d00f660:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 d00f664:	e0bff917 	ldw	r2,-28(fp)
 d00f668:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 d00f66c:	e0bff917 	ldw	r2,-28(fp)
 d00f670:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 d00f674:	e0bff917 	ldw	r2,-28(fp)
 d00f678:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 d00f67c:	e0bff917 	ldw	r2,-28(fp)
 d00f680:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 d00f684:	e0bff917 	ldw	r2,-28(fp)
 d00f688:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 d00f68c:	e0bff917 	ldw	r2,-28(fp)
 d00f690:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 d00f694:	e0bff917 	ldw	r2,-28(fp)
 d00f698:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 d00f69c:	e0fff917 	ldw	r3,-28(fp)
 d00f6a0:	00800fc4 	movi	r2,63
 d00f6a4:	18801305 	stb	r2,76(r3)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 d00f6a8:	e0bff917 	ldw	r2,-28(fp)
 d00f6ac:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 d00f6b0:	e13ff917 	ldw	r4,-28(fp)
 d00f6b4:	d03a05c0 	call	d03a05c <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 d00f6b8:	e13ff917 	ldw	r4,-28(fp)
 d00f6bc:	d039f680 	call	d039f68 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00f6c0:	0005303a 	rdctl	r2,status
 d00f6c4:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00f6c8:	e0fff517 	ldw	r3,-44(fp)
 d00f6cc:	00bfff84 	movi	r2,-2
 d00f6d0:	1884703a 	and	r2,r3,r2
 d00f6d4:	1001703a 	wrctl	status,r2
  
  return context;
 d00f6d8:	e0bff517 	ldw	r2,-44(fp)

        OS_ENTER_CRITICAL();
 d00f6dc:	e0bff815 	stw	r2,-32(fp)
        OSTCBPrioTbl[prio] = ptcb;
 d00f6e0:	e0bffa03 	ldbu	r2,-24(fp)
 d00f6e4:	00c341b4 	movhi	r3,3334
 d00f6e8:	18f13304 	addi	r3,r3,-15156
 d00f6ec:	1085883a 	add	r2,r2,r2
 d00f6f0:	1085883a 	add	r2,r2,r2
 d00f6f4:	10c7883a 	add	r3,r2,r3
 d00f6f8:	e0bff917 	ldw	r2,-28(fp)
 d00f6fc:	18800015 	stw	r2,0(r3)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 d00f700:	d0e06e17 	ldw	r3,-32328(gp)
 d00f704:	e0bff917 	ldw	r2,-28(fp)
 d00f708:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 d00f70c:	e0bff917 	ldw	r2,-28(fp)
 d00f710:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 d00f714:	d0a06e17 	ldw	r2,-32328(gp)
 d00f718:	1005003a 	cmpeq	r2,r2,zero
 d00f71c:	1000031e 	bne	r2,zero,d00f72c <OS_TCBInit+0x230>
            OSTCBList->OSTCBPrev = ptcb;
 d00f720:	d0e06e17 	ldw	r3,-32328(gp)
 d00f724:	e0bff917 	ldw	r2,-28(fp)
 d00f728:	18800615 	stw	r2,24(r3)
        }
        OSTCBList               = ptcb;
 d00f72c:	e0bff917 	ldw	r2,-28(fp)
 d00f730:	d0a06e15 	stw	r2,-32328(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 d00f734:	e0bff917 	ldw	r2,-28(fp)
 d00f738:	10c00d83 	ldbu	r3,54(r2)
 d00f73c:	d0a07703 	ldbu	r2,-32292(gp)
 d00f740:	1884b03a 	or	r2,r3,r2
 d00f744:	d0a07705 	stb	r2,-32292(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d00f748:	e0bff917 	ldw	r2,-28(fp)
 d00f74c:	10800d03 	ldbu	r2,52(r2)
 d00f750:	11003fcc 	andi	r4,r2,255
 d00f754:	e0bff917 	ldw	r2,-28(fp)
 d00f758:	10800d03 	ldbu	r2,52(r2)
 d00f75c:	10c03fcc 	andi	r3,r2,255
 d00f760:	d0a07744 	addi	r2,gp,-32291
 d00f764:	1885883a 	add	r2,r3,r2
 d00f768:	10c00003 	ldbu	r3,0(r2)
 d00f76c:	e0bff917 	ldw	r2,-28(fp)
 d00f770:	10800d43 	ldbu	r2,53(r2)
 d00f774:	1884b03a 	or	r2,r3,r2
 d00f778:	1007883a 	mov	r3,r2
 d00f77c:	d0a07744 	addi	r2,gp,-32291
 d00f780:	2085883a 	add	r2,r4,r2
 d00f784:	10c00005 	stb	r3,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 d00f788:	d0a07343 	ldbu	r2,-32307(gp)
 d00f78c:	10800044 	addi	r2,r2,1
 d00f790:	d0a07345 	stb	r2,-32307(gp)
 d00f794:	e0bff817 	ldw	r2,-32(fp)
 d00f798:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00f79c:	e0bff417 	ldw	r2,-48(fp)
 d00f7a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 d00f7a4:	e03fff15 	stw	zero,-4(fp)
 d00f7a8:	00000606 	br	d00f7c4 <OS_TCBInit+0x2c8>
 d00f7ac:	e0bff817 	ldw	r2,-32(fp)
 d00f7b0:	e0bff315 	stw	r2,-52(fp)
 d00f7b4:	e0bff317 	ldw	r2,-52(fp)
 d00f7b8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 d00f7bc:	00801084 	movi	r2,66
 d00f7c0:	e0bfff15 	stw	r2,-4(fp)
 d00f7c4:	e0bfff17 	ldw	r2,-4(fp)
}
 d00f7c8:	e037883a 	mov	sp,fp
 d00f7cc:	dfc00117 	ldw	ra,4(sp)
 d00f7d0:	df000017 	ldw	fp,0(sp)
 d00f7d4:	dec00204 	addi	sp,sp,8
 d00f7d8:	f800283a 	ret

0d00f7dc <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 d00f7dc:	defffe04 	addi	sp,sp,-8
 d00f7e0:	df000115 	stw	fp,4(sp)
 d00f7e4:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 d00f7e8:	d0a00c04 	addi	r2,gp,-32720
 d00f7ec:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 d00f7f0:	d0a00d04 	addi	r2,gp,-32716
 d00f7f4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 d00f7f8:	d0a00e84 	addi	r2,gp,-32710
 d00f7fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 d00f800:	d0a00f04 	addi	r2,gp,-32708
 d00f804:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 d00f808:	d0a00e04 	addi	r2,gp,-32712
 d00f80c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 d00f810:	d0a00f84 	addi	r2,gp,-32706
 d00f814:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 d00f818:	d0a01004 	addi	r2,gp,-32704
 d00f81c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 d00f820:	d0a01084 	addi	r2,gp,-32702
 d00f824:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 d00f828:	d0a01104 	addi	r2,gp,-32700
 d00f82c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 d00f830:	d0a01184 	addi	r2,gp,-32698
 d00f834:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 d00f838:	d0a01204 	addi	r2,gp,-32696
 d00f83c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 d00f840:	d0a01284 	addi	r2,gp,-32694
 d00f844:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 d00f848:	d0a01304 	addi	r2,gp,-32692
 d00f84c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 d00f850:	d0a01384 	addi	r2,gp,-32690
 d00f854:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 d00f858:	d0a01404 	addi	r2,gp,-32688
 d00f85c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 d00f860:	d0a01484 	addi	r2,gp,-32686
 d00f864:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 d00f868:	d0a01504 	addi	r2,gp,-32684
 d00f86c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 d00f870:	d0a01584 	addi	r2,gp,-32682
 d00f874:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 d00f878:	d0a01604 	addi	r2,gp,-32680
 d00f87c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 d00f880:	d0a01684 	addi	r2,gp,-32678
 d00f884:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 d00f888:	d0a01704 	addi	r2,gp,-32676
 d00f88c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 d00f890:	d0a01784 	addi	r2,gp,-32674
 d00f894:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 d00f898:	d0a01804 	addi	r2,gp,-32672
 d00f89c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 d00f8a0:	d0a01884 	addi	r2,gp,-32670
 d00f8a4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 d00f8a8:	d0a01904 	addi	r2,gp,-32668
 d00f8ac:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 d00f8b0:	d0a01984 	addi	r2,gp,-32666
 d00f8b4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 d00f8b8:	d0a01a04 	addi	r2,gp,-32664
 d00f8bc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 d00f8c0:	d0a01a84 	addi	r2,gp,-32662
 d00f8c4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 d00f8c8:	d0a01b04 	addi	r2,gp,-32660
 d00f8cc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 d00f8d0:	d0a01b84 	addi	r2,gp,-32658
 d00f8d4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 d00f8d8:	d0a01c04 	addi	r2,gp,-32656
 d00f8dc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 d00f8e0:	d0a01c84 	addi	r2,gp,-32654
 d00f8e4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 d00f8e8:	d0a01d04 	addi	r2,gp,-32652
 d00f8ec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 d00f8f0:	d0a01d84 	addi	r2,gp,-32650
 d00f8f4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 d00f8f8:	d0a01e04 	addi	r2,gp,-32648
 d00f8fc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 d00f900:	d0a01e84 	addi	r2,gp,-32646
 d00f904:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 d00f908:	d0a01f04 	addi	r2,gp,-32644
 d00f90c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 d00f910:	d0a01f84 	addi	r2,gp,-32642
 d00f914:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 d00f918:	d0a02004 	addi	r2,gp,-32640
 d00f91c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 d00f920:	d0a02084 	addi	r2,gp,-32638
 d00f924:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 d00f928:	d0a02104 	addi	r2,gp,-32636
 d00f92c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 d00f930:	d0a02184 	addi	r2,gp,-32634
 d00f934:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 d00f938:	d0a02204 	addi	r2,gp,-32632
 d00f93c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 d00f940:	d0a02284 	addi	r2,gp,-32630
 d00f944:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 d00f948:	d0a02304 	addi	r2,gp,-32628
 d00f94c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 d00f950:	d0a02804 	addi	r2,gp,-32608
 d00f954:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 d00f958:	e037883a 	mov	sp,fp
 d00f95c:	df000017 	ldw	fp,0(sp)
 d00f960:	dec00104 	addi	sp,sp,4
 d00f964:	f800283a 	ret

0d00f968 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 d00f968:	defff104 	addi	sp,sp,-60
 d00f96c:	df000e15 	stw	fp,56(sp)
 d00f970:	df000e04 	addi	fp,sp,56
 d00f974:	e13ffa15 	stw	r4,-24(fp)
 d00f978:	e1fffd15 	stw	r7,-12(fp)
 d00f97c:	e17ffb0d 	sth	r5,-20(fp)
 d00f980:	e1bffc05 	stb	r6,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 d00f984:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d00f988:	e0bffd17 	ldw	r2,-12(fp)
 d00f98c:	1004c03a 	cmpne	r2,r2,zero
 d00f990:	1000021e 	bne	r2,zero,d00f99c <OSFlagAccept+0x34>
        return ((OS_FLAGS)0);
 d00f994:	e03fff15 	stw	zero,-4(fp)
 d00f998:	0000bb06 	br	d00fc88 <OSFlagAccept+0x320>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 d00f99c:	e0bffa17 	ldw	r2,-24(fp)
 d00f9a0:	1004c03a 	cmpne	r2,r2,zero
 d00f9a4:	1000051e 	bne	r2,zero,d00f9bc <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d00f9a8:	e0fffd17 	ldw	r3,-12(fp)
 d00f9ac:	00801b84 	movi	r2,110
 d00f9b0:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d00f9b4:	e03fff15 	stw	zero,-4(fp)
 d00f9b8:	0000b306 	br	d00fc88 <OSFlagAccept+0x320>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 d00f9bc:	e0bffa17 	ldw	r2,-24(fp)
 d00f9c0:	10800003 	ldbu	r2,0(r2)
 d00f9c4:	10803fcc 	andi	r2,r2,255
 d00f9c8:	10800160 	cmpeqi	r2,r2,5
 d00f9cc:	1000051e 	bne	r2,zero,d00f9e4 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 d00f9d0:	e0fffd17 	ldw	r3,-12(fp)
 d00f9d4:	00800044 	movi	r2,1
 d00f9d8:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d00f9dc:	e03fff15 	stw	zero,-4(fp)
 d00f9e0:	0000a906 	br	d00fc88 <OSFlagAccept+0x320>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 d00f9e4:	e0fffc03 	ldbu	r3,-16(fp)
 d00f9e8:	00bfe004 	movi	r2,-128
 d00f9ec:	1884703a 	and	r2,r3,r2
 d00f9f0:	e0bff945 	stb	r2,-27(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 d00f9f4:	e0bff943 	ldbu	r2,-27(fp)
 d00f9f8:	1005003a 	cmpeq	r2,r2,zero
 d00f9fc:	1000061e 	bne	r2,zero,d00fa18 <OSFlagAccept+0xb0>
        wait_type &= ~OS_FLAG_CONSUME;
 d00fa00:	e0bffc03 	ldbu	r2,-16(fp)
 d00fa04:	10801fcc 	andi	r2,r2,127
 d00fa08:	e0bffc05 	stb	r2,-16(fp)
        consume    = OS_TRUE;
 d00fa0c:	00800044 	movi	r2,1
 d00fa10:	e0bff905 	stb	r2,-28(fp)
 d00fa14:	00000106 	br	d00fa1c <OSFlagAccept+0xb4>
    } else {
        consume    = OS_FALSE;
 d00fa18:	e03ff905 	stb	zero,-28(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 d00fa1c:	e0bffd17 	ldw	r2,-12(fp)
 d00fa20:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00fa24:	0005303a 	rdctl	r2,status
 d00fa28:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00fa2c:	e0fff717 	ldw	r3,-36(fp)
 d00fa30:	00bfff84 	movi	r2,-2
 d00fa34:	1884703a 	and	r2,r3,r2
 d00fa38:	1001703a 	wrctl	status,r2
  
  return context;
 d00fa3c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 d00fa40:	e0bff815 	stw	r2,-32(fp)
    switch (wait_type) {
 d00fa44:	e0bffc03 	ldbu	r2,-16(fp)
 d00fa48:	e0bffe15 	stw	r2,-8(fp)
 d00fa4c:	e0fffe17 	ldw	r3,-8(fp)
 d00fa50:	18800060 	cmpeqi	r2,r3,1
 d00fa54:	1000651e 	bne	r2,zero,d00fbec <OSFlagAccept+0x284>
 d00fa58:	e0fffe17 	ldw	r3,-8(fp)
 d00fa5c:	18800088 	cmpgei	r2,r3,2
 d00fa60:	1000041e 	bne	r2,zero,d00fa74 <OSFlagAccept+0x10c>
 d00fa64:	e0fffe17 	ldw	r3,-8(fp)
 d00fa68:	1805003a 	cmpeq	r2,r3,zero
 d00fa6c:	1000421e 	bne	r2,zero,d00fb78 <OSFlagAccept+0x210>
 d00fa70:	00007b06 	br	d00fc60 <OSFlagAccept+0x2f8>
 d00fa74:	e0fffe17 	ldw	r3,-8(fp)
 d00fa78:	188000a0 	cmpeqi	r2,r3,2
 d00fa7c:	1000041e 	bne	r2,zero,d00fa90 <OSFlagAccept+0x128>
 d00fa80:	e0fffe17 	ldw	r3,-8(fp)
 d00fa84:	188000e0 	cmpeqi	r2,r3,3
 d00fa88:	10001e1e 	bne	r2,zero,d00fb04 <OSFlagAccept+0x19c>
 d00fa8c:	00007406 	br	d00fc60 <OSFlagAccept+0x2f8>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 d00fa90:	e0bffa17 	ldw	r2,-24(fp)
 d00fa94:	10c0020b 	ldhu	r3,8(r2)
 d00fa98:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fa9c:	1884703a 	and	r2,r3,r2
 d00faa0:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 d00faa4:	e0fff98b 	ldhu	r3,-26(fp)
 d00faa8:	e0bffb0b 	ldhu	r2,-20(fp)
 d00faac:	18800d1e 	bne	r3,r2,d00fae4 <OSFlagAccept+0x17c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d00fab0:	e0bff903 	ldbu	r2,-28(fp)
 d00fab4:	10800058 	cmpnei	r2,r2,1
 d00fab8:	10000d1e 	bne	r2,zero,d00faf0 <OSFlagAccept+0x188>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 d00fabc:	e0bffa17 	ldw	r2,-24(fp)
 d00fac0:	1080020b 	ldhu	r2,8(r2)
 d00fac4:	1007883a 	mov	r3,r2
 d00fac8:	e0bff98b 	ldhu	r2,-26(fp)
 d00facc:	0084303a 	nor	r2,zero,r2
 d00fad0:	1884703a 	and	r2,r3,r2
 d00fad4:	1007883a 	mov	r3,r2
 d00fad8:	e0bffa17 	ldw	r2,-24(fp)
 d00fadc:	10c0020d 	sth	r3,8(r2)
 d00fae0:	00000306 	br	d00faf0 <OSFlagAccept+0x188>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 d00fae4:	e0fffd17 	ldw	r3,-12(fp)
 d00fae8:	00801c04 	movi	r2,112
 d00faec:	18800005 	stb	r2,0(r3)
 d00faf0:	e0bff817 	ldw	r2,-32(fp)
 d00faf4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00faf8:	e0bff617 	ldw	r2,-40(fp)
 d00fafc:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 d00fb00:	00005f06 	br	d00fc80 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 d00fb04:	e0bffa17 	ldw	r2,-24(fp)
 d00fb08:	10c0020b 	ldhu	r3,8(r2)
 d00fb0c:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fb10:	1884703a 	and	r2,r3,r2
 d00fb14:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 d00fb18:	e0bff98b 	ldhu	r2,-26(fp)
 d00fb1c:	1005003a 	cmpeq	r2,r2,zero
 d00fb20:	10000d1e 	bne	r2,zero,d00fb58 <OSFlagAccept+0x1f0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d00fb24:	e0bff903 	ldbu	r2,-28(fp)
 d00fb28:	10800058 	cmpnei	r2,r2,1
 d00fb2c:	10000d1e 	bne	r2,zero,d00fb64 <OSFlagAccept+0x1fc>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 d00fb30:	e0bffa17 	ldw	r2,-24(fp)
 d00fb34:	1080020b 	ldhu	r2,8(r2)
 d00fb38:	1007883a 	mov	r3,r2
 d00fb3c:	e0bff98b 	ldhu	r2,-26(fp)
 d00fb40:	0084303a 	nor	r2,zero,r2
 d00fb44:	1884703a 	and	r2,r3,r2
 d00fb48:	1007883a 	mov	r3,r2
 d00fb4c:	e0bffa17 	ldw	r2,-24(fp)
 d00fb50:	10c0020d 	sth	r3,8(r2)
 d00fb54:	00000306 	br	d00fb64 <OSFlagAccept+0x1fc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 d00fb58:	e0fffd17 	ldw	r3,-12(fp)
 d00fb5c:	00801c04 	movi	r2,112
 d00fb60:	18800005 	stb	r2,0(r3)
 d00fb64:	e0bff817 	ldw	r2,-32(fp)
 d00fb68:	e0bff515 	stw	r2,-44(fp)
 d00fb6c:	e0bff517 	ldw	r2,-44(fp)
 d00fb70:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 d00fb74:	00004206 	br	d00fc80 <OSFlagAccept+0x318>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 d00fb78:	e0bffa17 	ldw	r2,-24(fp)
 d00fb7c:	1080020b 	ldhu	r2,8(r2)
 d00fb80:	0084303a 	nor	r2,zero,r2
 d00fb84:	1007883a 	mov	r3,r2
 d00fb88:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fb8c:	1884703a 	and	r2,r3,r2
 d00fb90:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 d00fb94:	e0fff98b 	ldhu	r3,-26(fp)
 d00fb98:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fb9c:	18800b1e 	bne	r3,r2,d00fbcc <OSFlagAccept+0x264>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d00fba0:	e0bff903 	ldbu	r2,-28(fp)
 d00fba4:	10800058 	cmpnei	r2,r2,1
 d00fba8:	10000b1e 	bne	r2,zero,d00fbd8 <OSFlagAccept+0x270>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 d00fbac:	e0bffa17 	ldw	r2,-24(fp)
 d00fbb0:	10c0020b 	ldhu	r3,8(r2)
 d00fbb4:	e0bff98b 	ldhu	r2,-26(fp)
 d00fbb8:	1884b03a 	or	r2,r3,r2
 d00fbbc:	1007883a 	mov	r3,r2
 d00fbc0:	e0bffa17 	ldw	r2,-24(fp)
 d00fbc4:	10c0020d 	sth	r3,8(r2)
 d00fbc8:	00000306 	br	d00fbd8 <OSFlagAccept+0x270>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 d00fbcc:	e0fffd17 	ldw	r3,-12(fp)
 d00fbd0:	00801c04 	movi	r2,112
 d00fbd4:	18800005 	stb	r2,0(r3)
 d00fbd8:	e0bff817 	ldw	r2,-32(fp)
 d00fbdc:	e0bff415 	stw	r2,-48(fp)
 d00fbe0:	e0bff417 	ldw	r2,-48(fp)
 d00fbe4:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 d00fbe8:	00002506 	br	d00fc80 <OSFlagAccept+0x318>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 d00fbec:	e0bffa17 	ldw	r2,-24(fp)
 d00fbf0:	1080020b 	ldhu	r2,8(r2)
 d00fbf4:	0084303a 	nor	r2,zero,r2
 d00fbf8:	1007883a 	mov	r3,r2
 d00fbfc:	e0bffb0b 	ldhu	r2,-20(fp)
 d00fc00:	1884703a 	and	r2,r3,r2
 d00fc04:	e0bff98d 	sth	r2,-26(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 d00fc08:	e0bff98b 	ldhu	r2,-26(fp)
 d00fc0c:	1005003a 	cmpeq	r2,r2,zero
 d00fc10:	10000b1e 	bne	r2,zero,d00fc40 <OSFlagAccept+0x2d8>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d00fc14:	e0bff903 	ldbu	r2,-28(fp)
 d00fc18:	10800058 	cmpnei	r2,r2,1
 d00fc1c:	10000b1e 	bne	r2,zero,d00fc4c <OSFlagAccept+0x2e4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 d00fc20:	e0bffa17 	ldw	r2,-24(fp)
 d00fc24:	10c0020b 	ldhu	r3,8(r2)
 d00fc28:	e0bff98b 	ldhu	r2,-26(fp)
 d00fc2c:	1884b03a 	or	r2,r3,r2
 d00fc30:	1007883a 	mov	r3,r2
 d00fc34:	e0bffa17 	ldw	r2,-24(fp)
 d00fc38:	10c0020d 	sth	r3,8(r2)
 d00fc3c:	00000306 	br	d00fc4c <OSFlagAccept+0x2e4>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 d00fc40:	e0fffd17 	ldw	r3,-12(fp)
 d00fc44:	00801c04 	movi	r2,112
 d00fc48:	18800005 	stb	r2,0(r3)
 d00fc4c:	e0bff817 	ldw	r2,-32(fp)
 d00fc50:	e0bff315 	stw	r2,-52(fp)
 d00fc54:	e0bff317 	ldw	r2,-52(fp)
 d00fc58:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 d00fc5c:	00000806 	br	d00fc80 <OSFlagAccept+0x318>
 d00fc60:	e0bff817 	ldw	r2,-32(fp)
 d00fc64:	e0bff215 	stw	r2,-56(fp)
 d00fc68:	e0bff217 	ldw	r2,-56(fp)
 d00fc6c:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 d00fc70:	e03ff98d 	sth	zero,-26(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 d00fc74:	e0fffd17 	ldw	r3,-12(fp)
 d00fc78:	00801bc4 	movi	r2,111
 d00fc7c:	18800005 	stb	r2,0(r3)
             break;
    }
    return (flags_rdy);
 d00fc80:	e0bff98b 	ldhu	r2,-26(fp)
 d00fc84:	e0bfff15 	stw	r2,-4(fp)
 d00fc88:	e0bfff17 	ldw	r2,-4(fp)
}
 d00fc8c:	e037883a 	mov	sp,fp
 d00fc90:	df000017 	ldw	fp,0(sp)
 d00fc94:	dec00104 	addi	sp,sp,4
 d00fc98:	f800283a 	ret

0d00fc9c <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 d00fc9c:	defff704 	addi	sp,sp,-36
 d00fca0:	df000815 	stw	fp,32(sp)
 d00fca4:	df000804 	addi	fp,sp,32
 d00fca8:	e17ffe15 	stw	r5,-8(fp)
 d00fcac:	e13ffd0d 	sth	r4,-12(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 d00fcb0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 d00fcb4:	e0bffe17 	ldw	r2,-8(fp)
 d00fcb8:	1004c03a 	cmpne	r2,r2,zero
 d00fcbc:	1000021e 	bne	r2,zero,d00fcc8 <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 d00fcc0:	e03fff15 	stw	zero,-4(fp)
 d00fcc4:	00003f06 	br	d00fdc4 <OSFlagCreate+0x128>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 d00fcc8:	00834174 	movhi	r2,3333
 d00fccc:	108a9a04 	addi	r2,r2,10856
 d00fcd0:	10800003 	ldbu	r2,0(r2)
 d00fcd4:	10803fcc 	andi	r2,r2,255
 d00fcd8:	1005003a 	cmpeq	r2,r2,zero
 d00fcdc:	1000051e 	bne	r2,zero,d00fcf4 <OSFlagCreate+0x58>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 d00fce0:	e0fffe17 	ldw	r3,-8(fp)
 d00fce4:	00800404 	movi	r2,16
 d00fce8:	18800005 	stb	r2,0(r3)
        return ((OS_FLAG_GRP *)0);
 d00fcec:	e03fff15 	stw	zero,-4(fp)
 d00fcf0:	00003406 	br	d00fdc4 <OSFlagCreate+0x128>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00fcf4:	0005303a 	rdctl	r2,status
 d00fcf8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00fcfc:	e0fffa17 	ldw	r3,-24(fp)
 d00fd00:	00bfff84 	movi	r2,-2
 d00fd04:	1884703a 	and	r2,r3,r2
 d00fd08:	1001703a 	wrctl	status,r2
  
  return context;
 d00fd0c:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d00fd10:	e0bffb15 	stw	r2,-20(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 d00fd14:	00834174 	movhi	r2,3333
 d00fd18:	108a9d04 	addi	r2,r2,10868
 d00fd1c:	10800017 	ldw	r2,0(r2)
 d00fd20:	e0bffc15 	stw	r2,-16(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 d00fd24:	e0bffc17 	ldw	r2,-16(fp)
 d00fd28:	1005003a 	cmpeq	r2,r2,zero
 d00fd2c:	10001c1e 	bne	r2,zero,d00fda0 <OSFlagCreate+0x104>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 d00fd30:	00834174 	movhi	r2,3333
 d00fd34:	108a9d04 	addi	r2,r2,10868
 d00fd38:	10800017 	ldw	r2,0(r2)
 d00fd3c:	10800117 	ldw	r2,4(r2)
 d00fd40:	1007883a 	mov	r3,r2
 d00fd44:	00834174 	movhi	r2,3333
 d00fd48:	108a9d04 	addi	r2,r2,10868
 d00fd4c:	10c00015 	stw	r3,0(r2)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 d00fd50:	e0fffc17 	ldw	r3,-16(fp)
 d00fd54:	00800144 	movi	r2,5
 d00fd58:	18800005 	stb	r2,0(r3)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 d00fd5c:	e0fffc17 	ldw	r3,-16(fp)
 d00fd60:	e0bffd0b 	ldhu	r2,-12(fp)
 d00fd64:	1880020d 	sth	r2,8(r3)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 d00fd68:	e0bffc17 	ldw	r2,-16(fp)
 d00fd6c:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 d00fd70:	e0fffc17 	ldw	r3,-16(fp)
 d00fd74:	00800fc4 	movi	r2,63
 d00fd78:	18800285 	stb	r2,10(r3)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 d00fd7c:	e0bffc17 	ldw	r2,-16(fp)
 d00fd80:	100002c5 	stb	zero,11(r2)
 d00fd84:	e0bffb17 	ldw	r2,-20(fp)
 d00fd88:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00fd8c:	e0bff917 	ldw	r2,-28(fp)
 d00fd90:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 d00fd94:	e0bffe17 	ldw	r2,-8(fp)
 d00fd98:	10000005 	stb	zero,0(r2)
 d00fd9c:	00000706 	br	d00fdbc <OSFlagCreate+0x120>
 d00fda0:	e0bffb17 	ldw	r2,-20(fp)
 d00fda4:	e0bff815 	stw	r2,-32(fp)
 d00fda8:	e0bff817 	ldw	r2,-32(fp)
 d00fdac:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 d00fdb0:	e0fffe17 	ldw	r3,-8(fp)
 d00fdb4:	00801c84 	movi	r2,114
 d00fdb8:	18800005 	stb	r2,0(r3)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 d00fdbc:	e0bffc17 	ldw	r2,-16(fp)
 d00fdc0:	e0bfff15 	stw	r2,-4(fp)
 d00fdc4:	e0bfff17 	ldw	r2,-4(fp)
}
 d00fdc8:	e037883a 	mov	sp,fp
 d00fdcc:	df000017 	ldw	fp,0(sp)
 d00fdd0:	dec00104 	addi	sp,sp,4
 d00fdd4:	f800283a 	ret

0d00fdd8 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 d00fdd8:	defff004 	addi	sp,sp,-64
 d00fddc:	dfc00f15 	stw	ra,60(sp)
 d00fde0:	df000e15 	stw	fp,56(sp)
 d00fde4:	df000e04 	addi	fp,sp,56
 d00fde8:	e13ffb15 	stw	r4,-20(fp)
 d00fdec:	e1bffd15 	stw	r6,-12(fp)
 d00fdf0:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 d00fdf4:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d00fdf8:	e0bffd17 	ldw	r2,-12(fp)
 d00fdfc:	1004c03a 	cmpne	r2,r2,zero
 d00fe00:	1000031e 	bne	r2,zero,d00fe10 <OSFlagDel+0x38>
        return (pgrp);
 d00fe04:	e0bffb17 	ldw	r2,-20(fp)
 d00fe08:	e0bfff15 	stw	r2,-4(fp)
 d00fe0c:	00009606 	br	d010068 <OSFlagDel+0x290>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 d00fe10:	e0bffb17 	ldw	r2,-20(fp)
 d00fe14:	1004c03a 	cmpne	r2,r2,zero
 d00fe18:	1000061e 	bne	r2,zero,d00fe34 <OSFlagDel+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d00fe1c:	e0fffd17 	ldw	r3,-12(fp)
 d00fe20:	00801b84 	movi	r2,110
 d00fe24:	18800005 	stb	r2,0(r3)
        return (pgrp);
 d00fe28:	e0fffb17 	ldw	r3,-20(fp)
 d00fe2c:	e0ffff15 	stw	r3,-4(fp)
 d00fe30:	00008d06 	br	d010068 <OSFlagDel+0x290>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d00fe34:	00834174 	movhi	r2,3333
 d00fe38:	108a9a04 	addi	r2,r2,10856
 d00fe3c:	10800003 	ldbu	r2,0(r2)
 d00fe40:	10803fcc 	andi	r2,r2,255
 d00fe44:	1005003a 	cmpeq	r2,r2,zero
 d00fe48:	1000061e 	bne	r2,zero,d00fe64 <OSFlagDel+0x8c>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 d00fe4c:	e0fffd17 	ldw	r3,-12(fp)
 d00fe50:	008003c4 	movi	r2,15
 d00fe54:	18800005 	stb	r2,0(r3)
        return (pgrp);
 d00fe58:	e0bffb17 	ldw	r2,-20(fp)
 d00fe5c:	e0bfff15 	stw	r2,-4(fp)
 d00fe60:	00008106 	br	d010068 <OSFlagDel+0x290>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 d00fe64:	e0bffb17 	ldw	r2,-20(fp)
 d00fe68:	10800003 	ldbu	r2,0(r2)
 d00fe6c:	10803fcc 	andi	r2,r2,255
 d00fe70:	10800160 	cmpeqi	r2,r2,5
 d00fe74:	1000061e 	bne	r2,zero,d00fe90 <OSFlagDel+0xb8>
        *perr = OS_ERR_EVENT_TYPE;
 d00fe78:	e0fffd17 	ldw	r3,-12(fp)
 d00fe7c:	00800044 	movi	r2,1
 d00fe80:	18800005 	stb	r2,0(r3)
        return (pgrp);
 d00fe84:	e0fffb17 	ldw	r3,-20(fp)
 d00fe88:	e0ffff15 	stw	r3,-4(fp)
 d00fe8c:	00007606 	br	d010068 <OSFlagDel+0x290>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d00fe90:	0005303a 	rdctl	r2,status
 d00fe94:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d00fe98:	e0fff617 	ldw	r3,-40(fp)
 d00fe9c:	00bfff84 	movi	r2,-2
 d00fea0:	1884703a 	and	r2,r3,r2
 d00fea4:	1001703a 	wrctl	status,r2
  
  return context;
 d00fea8:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 d00feac:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 d00feb0:	e0bffb17 	ldw	r2,-20(fp)
 d00feb4:	10800117 	ldw	r2,4(r2)
 d00feb8:	1005003a 	cmpeq	r2,r2,zero
 d00febc:	1000031e 	bne	r2,zero,d00fecc <OSFlagDel+0xf4>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 d00fec0:	00800044 	movi	r2,1
 d00fec4:	e0bffa05 	stb	r2,-24(fp)
 d00fec8:	00000106 	br	d00fed0 <OSFlagDel+0xf8>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 d00fecc:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 d00fed0:	e0bffc03 	ldbu	r2,-16(fp)
 d00fed4:	e0bffe15 	stw	r2,-8(fp)
 d00fed8:	e0fffe17 	ldw	r3,-8(fp)
 d00fedc:	1805003a 	cmpeq	r2,r3,zero
 d00fee0:	1000041e 	bne	r2,zero,d00fef4 <OSFlagDel+0x11c>
 d00fee4:	e0fffe17 	ldw	r3,-8(fp)
 d00fee8:	18800060 	cmpeqi	r2,r3,1
 d00feec:	1000281e 	bne	r2,zero,d00ff90 <OSFlagDel+0x1b8>
 d00fef0:	00005206 	br	d01003c <OSFlagDel+0x264>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 d00fef4:	e0bffa03 	ldbu	r2,-24(fp)
 d00fef8:	1004c03a 	cmpne	r2,r2,zero
 d00fefc:	10001a1e 	bne	r2,zero,d00ff68 <OSFlagDel+0x190>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 d00ff00:	e0fffb17 	ldw	r3,-20(fp)
 d00ff04:	00800fc4 	movi	r2,63
 d00ff08:	18800285 	stb	r2,10(r3)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 d00ff0c:	e0bffb17 	ldw	r2,-20(fp)
 d00ff10:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 d00ff14:	e0bffb17 	ldw	r2,-20(fp)
 d00ff18:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 d00ff1c:	00834174 	movhi	r2,3333
 d00ff20:	108a9d04 	addi	r2,r2,10868
 d00ff24:	10c00017 	ldw	r3,0(r2)
 d00ff28:	e0bffb17 	ldw	r2,-20(fp)
 d00ff2c:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 d00ff30:	e0bffb17 	ldw	r2,-20(fp)
 d00ff34:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 d00ff38:	00c34174 	movhi	r3,3333
 d00ff3c:	18ca9d04 	addi	r3,r3,10868
 d00ff40:	e0bffb17 	ldw	r2,-20(fp)
 d00ff44:	18800015 	stw	r2,0(r3)
 d00ff48:	e0bff717 	ldw	r2,-36(fp)
 d00ff4c:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d00ff50:	e0bff517 	ldw	r2,-44(fp)
 d00ff54:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 d00ff58:	e0bffd17 	ldw	r2,-12(fp)
 d00ff5c:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 d00ff60:	e03ff815 	stw	zero,-32(fp)
 d00ff64:	00003e06 	br	d010060 <OSFlagDel+0x288>
 d00ff68:	e0bff717 	ldw	r2,-36(fp)
 d00ff6c:	e0bff415 	stw	r2,-48(fp)
 d00ff70:	e0bff417 	ldw	r2,-48(fp)
 d00ff74:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 d00ff78:	e0fffd17 	ldw	r3,-12(fp)
 d00ff7c:	00801244 	movi	r2,73
 d00ff80:	18800005 	stb	r2,0(r3)
                 pgrp_return          = pgrp;
 d00ff84:	e0bffb17 	ldw	r2,-20(fp)
 d00ff88:	e0bff815 	stw	r2,-32(fp)
             }
             break;
 d00ff8c:	00003406 	br	d010060 <OSFlagDel+0x288>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 d00ff90:	e0bffb17 	ldw	r2,-20(fp)
 d00ff94:	10800117 	ldw	r2,4(r2)
 d00ff98:	e0bff915 	stw	r2,-28(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 d00ff9c:	00000606 	br	d00ffb8 <OSFlagDel+0x1e0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 d00ffa0:	e13ff917 	ldw	r4,-28(fp)
 d00ffa4:	000b883a 	mov	r5,zero
 d00ffa8:	d0110e80 	call	d0110e8 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 d00ffac:	e0bff917 	ldw	r2,-28(fp)
 d00ffb0:	10800017 	ldw	r2,0(r2)
 d00ffb4:	e0bff915 	stw	r2,-28(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 d00ffb8:	e0bff917 	ldw	r2,-28(fp)
 d00ffbc:	1004c03a 	cmpne	r2,r2,zero
 d00ffc0:	103ff71e 	bne	r2,zero,d00ffa0 <OSFlagDel+0x1c8>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 d00ffc4:	e0fffb17 	ldw	r3,-20(fp)
 d00ffc8:	00800fc4 	movi	r2,63
 d00ffcc:	18800285 	stb	r2,10(r3)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 d00ffd0:	e0bffb17 	ldw	r2,-20(fp)
 d00ffd4:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 d00ffd8:	e0bffb17 	ldw	r2,-20(fp)
 d00ffdc:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 d00ffe0:	00834174 	movhi	r2,3333
 d00ffe4:	108a9d04 	addi	r2,r2,10868
 d00ffe8:	10c00017 	ldw	r3,0(r2)
 d00ffec:	e0bffb17 	ldw	r2,-20(fp)
 d00fff0:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 d00fff4:	e0bffb17 	ldw	r2,-20(fp)
 d00fff8:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 d00fffc:	00c34174 	movhi	r3,3333
 d010000:	18ca9d04 	addi	r3,r3,10868
 d010004:	e0bffb17 	ldw	r2,-20(fp)
 d010008:	18800015 	stw	r2,0(r3)
 d01000c:	e0bff717 	ldw	r2,-36(fp)
 d010010:	e0bff315 	stw	r2,-52(fp)
 d010014:	e0bff317 	ldw	r2,-52(fp)
 d010018:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 d01001c:	e0bffa03 	ldbu	r2,-24(fp)
 d010020:	10800058 	cmpnei	r2,r2,1
 d010024:	1000011e 	bne	r2,zero,d01002c <OSFlagDel+0x254>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 d010028:	d00f0f40 	call	d00f0f4 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 d01002c:	e0bffd17 	ldw	r2,-12(fp)
 d010030:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 d010034:	e03ff815 	stw	zero,-32(fp)
             break;
 d010038:	00000906 	br	d010060 <OSFlagDel+0x288>
 d01003c:	e0bff717 	ldw	r2,-36(fp)
 d010040:	e0bff215 	stw	r2,-56(fp)
 d010044:	e0bff217 	ldw	r2,-56(fp)
 d010048:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 d01004c:	e0fffd17 	ldw	r3,-12(fp)
 d010050:	008001c4 	movi	r2,7
 d010054:	18800005 	stb	r2,0(r3)
             pgrp_return          = pgrp;
 d010058:	e0bffb17 	ldw	r2,-20(fp)
 d01005c:	e0bff815 	stw	r2,-32(fp)
             break;
    }
    return (pgrp_return);
 d010060:	e0bff817 	ldw	r2,-32(fp)
 d010064:	e0bfff15 	stw	r2,-4(fp)
 d010068:	e0bfff17 	ldw	r2,-4(fp)
}
 d01006c:	e037883a 	mov	sp,fp
 d010070:	dfc00117 	ldw	ra,4(sp)
 d010074:	df000017 	ldw	fp,0(sp)
 d010078:	dec00204 	addi	sp,sp,8
 d01007c:	f800283a 	ret

0d010080 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 d010080:	defff504 	addi	sp,sp,-44
 d010084:	dfc00a15 	stw	ra,40(sp)
 d010088:	df000915 	stw	fp,36(sp)
 d01008c:	df000904 	addi	fp,sp,36
 d010090:	e13ffc15 	stw	r4,-16(fp)
 d010094:	e17ffd15 	stw	r5,-12(fp)
 d010098:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d01009c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d0100a0:	e0bffe17 	ldw	r2,-8(fp)
 d0100a4:	1004c03a 	cmpne	r2,r2,zero
 d0100a8:	1000021e 	bne	r2,zero,d0100b4 <OSFlagNameGet+0x34>
        return (0);
 d0100ac:	e03fff15 	stw	zero,-4(fp)
 d0100b0:	00003e06 	br	d0101ac <OSFlagNameGet+0x12c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 d0100b4:	e0bffc17 	ldw	r2,-16(fp)
 d0100b8:	1004c03a 	cmpne	r2,r2,zero
 d0100bc:	1000051e 	bne	r2,zero,d0100d4 <OSFlagNameGet+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d0100c0:	e0fffe17 	ldw	r3,-8(fp)
 d0100c4:	00801b84 	movi	r2,110
 d0100c8:	18800005 	stb	r2,0(r3)
        return (0);
 d0100cc:	e03fff15 	stw	zero,-4(fp)
 d0100d0:	00003606 	br	d0101ac <OSFlagNameGet+0x12c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d0100d4:	e0bffd17 	ldw	r2,-12(fp)
 d0100d8:	1004c03a 	cmpne	r2,r2,zero
 d0100dc:	1000051e 	bne	r2,zero,d0100f4 <OSFlagNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 d0100e0:	e0fffe17 	ldw	r3,-8(fp)
 d0100e4:	00800304 	movi	r2,12
 d0100e8:	18800005 	stb	r2,0(r3)
        return (0);
 d0100ec:	e03fff15 	stw	zero,-4(fp)
 d0100f0:	00002e06 	br	d0101ac <OSFlagNameGet+0x12c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d0100f4:	00834174 	movhi	r2,3333
 d0100f8:	108a9a04 	addi	r2,r2,10856
 d0100fc:	10800003 	ldbu	r2,0(r2)
 d010100:	10803fcc 	andi	r2,r2,255
 d010104:	1005003a 	cmpeq	r2,r2,zero
 d010108:	1000051e 	bne	r2,zero,d010120 <OSFlagNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 d01010c:	e0fffe17 	ldw	r3,-8(fp)
 d010110:	00800444 	movi	r2,17
 d010114:	18800005 	stb	r2,0(r3)
        return (0);
 d010118:	e03fff15 	stw	zero,-4(fp)
 d01011c:	00002306 	br	d0101ac <OSFlagNameGet+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010120:	0005303a 	rdctl	r2,status
 d010124:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010128:	e0fff917 	ldw	r3,-28(fp)
 d01012c:	00bfff84 	movi	r2,-2
 d010130:	1884703a 	and	r2,r3,r2
 d010134:	1001703a 	wrctl	status,r2
  
  return context;
 d010138:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d01013c:	e0bffa15 	stw	r2,-24(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 d010140:	e0bffc17 	ldw	r2,-16(fp)
 d010144:	10800003 	ldbu	r2,0(r2)
 d010148:	10803fcc 	andi	r2,r2,255
 d01014c:	10800160 	cmpeqi	r2,r2,5
 d010150:	1000091e 	bne	r2,zero,d010178 <OSFlagNameGet+0xf8>
 d010154:	e0bffa17 	ldw	r2,-24(fp)
 d010158:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01015c:	e0bff817 	ldw	r2,-32(fp)
 d010160:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 d010164:	e0fffe17 	ldw	r3,-8(fp)
 d010168:	00800044 	movi	r2,1
 d01016c:	18800005 	stb	r2,0(r3)
        return (0);
 d010170:	e03fff15 	stw	zero,-4(fp)
 d010174:	00000d06 	br	d0101ac <OSFlagNameGet+0x12c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 d010178:	e0bffc17 	ldw	r2,-16(fp)
 d01017c:	11400284 	addi	r5,r2,10
 d010180:	e13ffd17 	ldw	r4,-12(fp)
 d010184:	d00f2380 	call	d00f238 <OS_StrCopy>
 d010188:	e0bffb05 	stb	r2,-20(fp)
 d01018c:	e0bffa17 	ldw	r2,-24(fp)
 d010190:	e0bff715 	stw	r2,-36(fp)
 d010194:	e0bff717 	ldw	r2,-36(fp)
 d010198:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d01019c:	e0bffe17 	ldw	r2,-8(fp)
 d0101a0:	10000005 	stb	zero,0(r2)
    return (len);
 d0101a4:	e0bffb03 	ldbu	r2,-20(fp)
 d0101a8:	e0bfff15 	stw	r2,-4(fp)
 d0101ac:	e0bfff17 	ldw	r2,-4(fp)
}
 d0101b0:	e037883a 	mov	sp,fp
 d0101b4:	dfc00117 	ldw	ra,4(sp)
 d0101b8:	df000017 	ldw	fp,0(sp)
 d0101bc:	dec00204 	addi	sp,sp,8
 d0101c0:	f800283a 	ret

0d0101c4 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 d0101c4:	defff504 	addi	sp,sp,-44
 d0101c8:	dfc00a15 	stw	ra,40(sp)
 d0101cc:	df000915 	stw	fp,36(sp)
 d0101d0:	df000904 	addi	fp,sp,36
 d0101d4:	e13ffd15 	stw	r4,-12(fp)
 d0101d8:	e17ffe15 	stw	r5,-8(fp)
 d0101dc:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0101e0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d0101e4:	e0bfff17 	ldw	r2,-4(fp)
 d0101e8:	1005003a 	cmpeq	r2,r2,zero
 d0101ec:	1000451e 	bne	r2,zero,d010304 <OSFlagNameSet+0x140>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 d0101f0:	e0bffd17 	ldw	r2,-12(fp)
 d0101f4:	1004c03a 	cmpne	r2,r2,zero
 d0101f8:	1000041e 	bne	r2,zero,d01020c <OSFlagNameSet+0x48>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d0101fc:	e0ffff17 	ldw	r3,-4(fp)
 d010200:	00801b84 	movi	r2,110
 d010204:	18800005 	stb	r2,0(r3)
        return;
 d010208:	00003e06 	br	d010304 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d01020c:	e0bffe17 	ldw	r2,-8(fp)
 d010210:	1004c03a 	cmpne	r2,r2,zero
 d010214:	1000041e 	bne	r2,zero,d010228 <OSFlagNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 d010218:	e0ffff17 	ldw	r3,-4(fp)
 d01021c:	00800304 	movi	r2,12
 d010220:	18800005 	stb	r2,0(r3)
        return;
 d010224:	00003706 	br	d010304 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d010228:	00834174 	movhi	r2,3333
 d01022c:	108a9a04 	addi	r2,r2,10856
 d010230:	10800003 	ldbu	r2,0(r2)
 d010234:	10803fcc 	andi	r2,r2,255
 d010238:	1005003a 	cmpeq	r2,r2,zero
 d01023c:	1000041e 	bne	r2,zero,d010250 <OSFlagNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 d010240:	e0ffff17 	ldw	r3,-4(fp)
 d010244:	00800484 	movi	r2,18
 d010248:	18800005 	stb	r2,0(r3)
        return;
 d01024c:	00002d06 	br	d010304 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010250:	0005303a 	rdctl	r2,status
 d010254:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010258:	e0fffa17 	ldw	r3,-24(fp)
 d01025c:	00bfff84 	movi	r2,-2
 d010260:	1884703a 	and	r2,r3,r2
 d010264:	1001703a 	wrctl	status,r2
  
  return context;
 d010268:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d01026c:	e0bffb15 	stw	r2,-20(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 d010270:	e0bffd17 	ldw	r2,-12(fp)
 d010274:	10800003 	ldbu	r2,0(r2)
 d010278:	10803fcc 	andi	r2,r2,255
 d01027c:	10800160 	cmpeqi	r2,r2,5
 d010280:	1000081e 	bne	r2,zero,d0102a4 <OSFlagNameSet+0xe0>
 d010284:	e0bffb17 	ldw	r2,-20(fp)
 d010288:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01028c:	e0bff917 	ldw	r2,-28(fp)
 d010290:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 d010294:	e0ffff17 	ldw	r3,-4(fp)
 d010298:	00800044 	movi	r2,1
 d01029c:	18800005 	stb	r2,0(r3)
        return;
 d0102a0:	00001806 	br	d010304 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 d0102a4:	e13ffe17 	ldw	r4,-8(fp)
 d0102a8:	d00f2b80 	call	d00f2b8 <OS_StrLen>
 d0102ac:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 d0102b0:	e0bffc03 	ldbu	r2,-16(fp)
 d0102b4:	10800830 	cmpltui	r2,r2,32
 d0102b8:	1000081e 	bne	r2,zero,d0102dc <OSFlagNameSet+0x118>
 d0102bc:	e0bffb17 	ldw	r2,-20(fp)
 d0102c0:	e0bff815 	stw	r2,-32(fp)
 d0102c4:	e0bff817 	ldw	r2,-32(fp)
 d0102c8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 d0102cc:	e0ffff17 	ldw	r3,-4(fp)
 d0102d0:	00801cc4 	movi	r2,115
 d0102d4:	18800005 	stb	r2,0(r3)
        return;
 d0102d8:	00000a06 	br	d010304 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 d0102dc:	e0bffd17 	ldw	r2,-12(fp)
 d0102e0:	11000284 	addi	r4,r2,10
 d0102e4:	e17ffe17 	ldw	r5,-8(fp)
 d0102e8:	d00f2380 	call	d00f238 <OS_StrCopy>
 d0102ec:	e0bffb17 	ldw	r2,-20(fp)
 d0102f0:	e0bff715 	stw	r2,-36(fp)
 d0102f4:	e0bff717 	ldw	r2,-36(fp)
 d0102f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d0102fc:	e0bfff17 	ldw	r2,-4(fp)
 d010300:	10000005 	stb	zero,0(r2)
    return;
}
 d010304:	e037883a 	mov	sp,fp
 d010308:	dfc00117 	ldw	ra,4(sp)
 d01030c:	df000017 	ldw	fp,0(sp)
 d010310:	dec00204 	addi	sp,sp,8
 d010314:	f800283a 	ret

0d010318 <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 d010318:	deffe004 	addi	sp,sp,-128
 d01031c:	dfc01f15 	stw	ra,124(sp)
 d010320:	df001e15 	stw	fp,120(sp)
 d010324:	df001e04 	addi	fp,sp,120
 d010328:	e13ff915 	stw	r4,-28(fp)
 d01032c:	e17ffa0d 	sth	r5,-24(fp)
 d010330:	e1bffb05 	stb	r6,-20(fp)
 d010334:	e1fffc0d 	sth	r7,-16(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 d010338:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d01033c:	e0800217 	ldw	r2,8(fp)
 d010340:	1004c03a 	cmpne	r2,r2,zero
 d010344:	1000021e 	bne	r2,zero,d010350 <OSFlagPend+0x38>
        return ((OS_FLAGS)0);
 d010348:	e03fff15 	stw	zero,-4(fp)
 d01034c:	00017d06 	br	d010944 <OSFlagPend+0x62c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 d010350:	e0bff917 	ldw	r2,-28(fp)
 d010354:	1004c03a 	cmpne	r2,r2,zero
 d010358:	1000051e 	bne	r2,zero,d010370 <OSFlagPend+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d01035c:	e0c00217 	ldw	r3,8(fp)
 d010360:	00801b84 	movi	r2,110
 d010364:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010368:	e03fff15 	stw	zero,-4(fp)
 d01036c:	00017506 	br	d010944 <OSFlagPend+0x62c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d010370:	00834174 	movhi	r2,3333
 d010374:	108a9a04 	addi	r2,r2,10856
 d010378:	10800003 	ldbu	r2,0(r2)
 d01037c:	10803fcc 	andi	r2,r2,255
 d010380:	1005003a 	cmpeq	r2,r2,zero
 d010384:	1000051e 	bne	r2,zero,d01039c <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 d010388:	e0c00217 	ldw	r3,8(fp)
 d01038c:	00800084 	movi	r2,2
 d010390:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010394:	e03fff15 	stw	zero,-4(fp)
 d010398:	00016a06 	br	d010944 <OSFlagPend+0x62c>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 d01039c:	00834174 	movhi	r2,3333
 d0103a0:	108a8c04 	addi	r2,r2,10800
 d0103a4:	10800003 	ldbu	r2,0(r2)
 d0103a8:	10803fcc 	andi	r2,r2,255
 d0103ac:	1005003a 	cmpeq	r2,r2,zero
 d0103b0:	1000051e 	bne	r2,zero,d0103c8 <OSFlagPend+0xb0>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 d0103b4:	e0c00217 	ldw	r3,8(fp)
 d0103b8:	00800344 	movi	r2,13
 d0103bc:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d0103c0:	e03fff15 	stw	zero,-4(fp)
 d0103c4:	00015f06 	br	d010944 <OSFlagPend+0x62c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 d0103c8:	e0bff917 	ldw	r2,-28(fp)
 d0103cc:	10800003 	ldbu	r2,0(r2)
 d0103d0:	10803fcc 	andi	r2,r2,255
 d0103d4:	10800160 	cmpeqi	r2,r2,5
 d0103d8:	1000051e 	bne	r2,zero,d0103f0 <OSFlagPend+0xd8>
        *perr = OS_ERR_EVENT_TYPE;
 d0103dc:	e0c00217 	ldw	r3,8(fp)
 d0103e0:	00800044 	movi	r2,1
 d0103e4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d0103e8:	e03fff15 	stw	zero,-4(fp)
 d0103ec:	00015506 	br	d010944 <OSFlagPend+0x62c>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 d0103f0:	e0fffb03 	ldbu	r3,-20(fp)
 d0103f4:	00bfe004 	movi	r2,-128
 d0103f8:	1884703a 	and	r2,r3,r2
 d0103fc:	e0bff285 	stb	r2,-54(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 d010400:	e0bff283 	ldbu	r2,-54(fp)
 d010404:	1005003a 	cmpeq	r2,r2,zero
 d010408:	1000071e 	bne	r2,zero,d010428 <OSFlagPend+0x110>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 d01040c:	00c01fc4 	movi	r3,127
 d010410:	e0bffb03 	ldbu	r2,-20(fp)
 d010414:	10c4703a 	and	r2,r2,r3
 d010418:	e0bffb05 	stb	r2,-20(fp)
        consume    = OS_TRUE;
 d01041c:	00800044 	movi	r2,1
 d010420:	e0bff205 	stb	r2,-56(fp)
 d010424:	00000106 	br	d01042c <OSFlagPend+0x114>
    } else {
        consume    = OS_FALSE;
 d010428:	e03ff205 	stb	zero,-56(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01042c:	0005303a 	rdctl	r2,status
 d010430:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010434:	e0fff017 	ldw	r3,-64(fp)
 d010438:	00bfff84 	movi	r2,-2
 d01043c:	1884703a 	and	r2,r3,r2
 d010440:	1001703a 	wrctl	status,r2
  
  return context;
 d010444:	e0bff017 	ldw	r2,-64(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 d010448:	e0bff115 	stw	r2,-60(fp)
    switch (wait_type) {
 d01044c:	e0bffb03 	ldbu	r2,-20(fp)
 d010450:	e0bffe15 	stw	r2,-8(fp)
 d010454:	e0fffe17 	ldw	r3,-8(fp)
 d010458:	18800060 	cmpeqi	r2,r3,1
 d01045c:	1000981e 	bne	r2,zero,d0106c0 <OSFlagPend+0x3a8>
 d010460:	e0fffe17 	ldw	r3,-8(fp)
 d010464:	18800088 	cmpgei	r2,r3,2
 d010468:	1000041e 	bne	r2,zero,d01047c <OSFlagPend+0x164>
 d01046c:	e0fffe17 	ldw	r3,-8(fp)
 d010470:	1805003a 	cmpeq	r2,r3,zero
 d010474:	1000641e 	bne	r2,zero,d010608 <OSFlagPend+0x2f0>
 d010478:	0000bf06 	br	d010778 <OSFlagPend+0x460>
 d01047c:	e0fffe17 	ldw	r3,-8(fp)
 d010480:	188000a0 	cmpeqi	r2,r3,2
 d010484:	1000041e 	bne	r2,zero,d010498 <OSFlagPend+0x180>
 d010488:	e0fffe17 	ldw	r3,-8(fp)
 d01048c:	188000e0 	cmpeqi	r2,r3,3
 d010490:	10002f1e 	bne	r2,zero,d010550 <OSFlagPend+0x238>
 d010494:	0000b806 	br	d010778 <OSFlagPend+0x460>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 d010498:	e0bff917 	ldw	r2,-28(fp)
 d01049c:	10c0020b 	ldhu	r3,8(r2)
 d0104a0:	e0bffa0b 	ldhu	r2,-24(fp)
 d0104a4:	1884703a 	and	r2,r3,r2
 d0104a8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 d0104ac:	e0fff30b 	ldhu	r3,-52(fp)
 d0104b0:	e0bffa0b 	ldhu	r2,-24(fp)
 d0104b4:	18801a1e 	bne	r3,r2,d010520 <OSFlagPend+0x208>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d0104b8:	e0bff203 	ldbu	r2,-56(fp)
 d0104bc:	10800058 	cmpnei	r2,r2,1
 d0104c0:	1000091e 	bne	r2,zero,d0104e8 <OSFlagPend+0x1d0>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 d0104c4:	e0bff917 	ldw	r2,-28(fp)
 d0104c8:	1080020b 	ldhu	r2,8(r2)
 d0104cc:	1007883a 	mov	r3,r2
 d0104d0:	e0bff30b 	ldhu	r2,-52(fp)
 d0104d4:	0084303a 	nor	r2,zero,r2
 d0104d8:	1884703a 	and	r2,r3,r2
 d0104dc:	1007883a 	mov	r3,r2
 d0104e0:	e0bff917 	ldw	r2,-28(fp)
 d0104e4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 d0104e8:	00834174 	movhi	r2,3333
 d0104ec:	108a9b04 	addi	r2,r2,10860
 d0104f0:	10c00017 	ldw	r3,0(r2)
 d0104f4:	e0bff30b 	ldhu	r2,-52(fp)
 d0104f8:	18800b0d 	sth	r2,44(r3)
 d0104fc:	e0bff117 	ldw	r2,-60(fp)
 d010500:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d010504:	e0bfef17 	ldw	r2,-68(fp)
 d010508:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 d01050c:	e0800217 	ldw	r2,8(fp)
 d010510:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 d010514:	e0bff30b 	ldhu	r2,-52(fp)
 d010518:	e0bfff15 	stw	r2,-4(fp)
 d01051c:	00010906 	br	d010944 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 d010520:	e1bffa0b 	ldhu	r6,-24(fp)
 d010524:	e1fffb03 	ldbu	r7,-20(fp)
 d010528:	e0bffc0b 	ldhu	r2,-16(fp)
 d01052c:	e17ff404 	addi	r5,fp,-48
 d010530:	d8800015 	stw	r2,0(sp)
 d010534:	e13ff917 	ldw	r4,-28(fp)
 d010538:	d010e400 	call	d010e40 <OS_FlagBlock>
 d01053c:	e0bff117 	ldw	r2,-60(fp)
 d010540:	e0bfee15 	stw	r2,-72(fp)
 d010544:	e0bfee17 	ldw	r2,-72(fp)
 d010548:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 d01054c:	00009506 	br	d0107a4 <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 d010550:	e0bff917 	ldw	r2,-28(fp)
 d010554:	10c0020b 	ldhu	r3,8(r2)
 d010558:	e0bffa0b 	ldhu	r2,-24(fp)
 d01055c:	1884703a 	and	r2,r3,r2
 d010560:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 d010564:	e0bff30b 	ldhu	r2,-52(fp)
 d010568:	1005003a 	cmpeq	r2,r2,zero
 d01056c:	10001a1e 	bne	r2,zero,d0105d8 <OSFlagPend+0x2c0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d010570:	e0bff203 	ldbu	r2,-56(fp)
 d010574:	10800058 	cmpnei	r2,r2,1
 d010578:	1000091e 	bne	r2,zero,d0105a0 <OSFlagPend+0x288>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 d01057c:	e0bff917 	ldw	r2,-28(fp)
 d010580:	1080020b 	ldhu	r2,8(r2)
 d010584:	1007883a 	mov	r3,r2
 d010588:	e0bff30b 	ldhu	r2,-52(fp)
 d01058c:	0084303a 	nor	r2,zero,r2
 d010590:	1884703a 	and	r2,r3,r2
 d010594:	1007883a 	mov	r3,r2
 d010598:	e0bff917 	ldw	r2,-28(fp)
 d01059c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 d0105a0:	00834174 	movhi	r2,3333
 d0105a4:	108a9b04 	addi	r2,r2,10860
 d0105a8:	10c00017 	ldw	r3,0(r2)
 d0105ac:	e0bff30b 	ldhu	r2,-52(fp)
 d0105b0:	18800b0d 	sth	r2,44(r3)
 d0105b4:	e0bff117 	ldw	r2,-60(fp)
 d0105b8:	e0bfed15 	stw	r2,-76(fp)
 d0105bc:	e0bfed17 	ldw	r2,-76(fp)
 d0105c0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 d0105c4:	e0800217 	ldw	r2,8(fp)
 d0105c8:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 d0105cc:	e0fff30b 	ldhu	r3,-52(fp)
 d0105d0:	e0ffff15 	stw	r3,-4(fp)
 d0105d4:	0000db06 	br	d010944 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 d0105d8:	e1bffa0b 	ldhu	r6,-24(fp)
 d0105dc:	e1fffb03 	ldbu	r7,-20(fp)
 d0105e0:	e0bffc0b 	ldhu	r2,-16(fp)
 d0105e4:	e17ff404 	addi	r5,fp,-48
 d0105e8:	d8800015 	stw	r2,0(sp)
 d0105ec:	e13ff917 	ldw	r4,-28(fp)
 d0105f0:	d010e400 	call	d010e40 <OS_FlagBlock>
 d0105f4:	e0bff117 	ldw	r2,-60(fp)
 d0105f8:	e0bfec15 	stw	r2,-80(fp)
 d0105fc:	e0bfec17 	ldw	r2,-80(fp)
 d010600:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 d010604:	00006706 	br	d0107a4 <OSFlagPend+0x48c>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 d010608:	e0bff917 	ldw	r2,-28(fp)
 d01060c:	1080020b 	ldhu	r2,8(r2)
 d010610:	0084303a 	nor	r2,zero,r2
 d010614:	1007883a 	mov	r3,r2
 d010618:	e0bffa0b 	ldhu	r2,-24(fp)
 d01061c:	1884703a 	and	r2,r3,r2
 d010620:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 d010624:	e0fff30b 	ldhu	r3,-52(fp)
 d010628:	e0bffa0b 	ldhu	r2,-24(fp)
 d01062c:	1880181e 	bne	r3,r2,d010690 <OSFlagPend+0x378>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d010630:	e0bff203 	ldbu	r2,-56(fp)
 d010634:	10800058 	cmpnei	r2,r2,1
 d010638:	1000071e 	bne	r2,zero,d010658 <OSFlagPend+0x340>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 d01063c:	e0bff917 	ldw	r2,-28(fp)
 d010640:	10c0020b 	ldhu	r3,8(r2)
 d010644:	e0bff30b 	ldhu	r2,-52(fp)
 d010648:	1884b03a 	or	r2,r3,r2
 d01064c:	1007883a 	mov	r3,r2
 d010650:	e0bff917 	ldw	r2,-28(fp)
 d010654:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 d010658:	00834174 	movhi	r2,3333
 d01065c:	108a9b04 	addi	r2,r2,10860
 d010660:	10c00017 	ldw	r3,0(r2)
 d010664:	e0bff30b 	ldhu	r2,-52(fp)
 d010668:	18800b0d 	sth	r2,44(r3)
 d01066c:	e0bff117 	ldw	r2,-60(fp)
 d010670:	e0bfeb15 	stw	r2,-84(fp)
 d010674:	e0bfeb17 	ldw	r2,-84(fp)
 d010678:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 d01067c:	e0800217 	ldw	r2,8(fp)
 d010680:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 d010684:	e0bff30b 	ldhu	r2,-52(fp)
 d010688:	e0bfff15 	stw	r2,-4(fp)
 d01068c:	0000ad06 	br	d010944 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 d010690:	e1bffa0b 	ldhu	r6,-24(fp)
 d010694:	e1fffb03 	ldbu	r7,-20(fp)
 d010698:	e0bffc0b 	ldhu	r2,-16(fp)
 d01069c:	e17ff404 	addi	r5,fp,-48
 d0106a0:	d8800015 	stw	r2,0(sp)
 d0106a4:	e13ff917 	ldw	r4,-28(fp)
 d0106a8:	d010e400 	call	d010e40 <OS_FlagBlock>
 d0106ac:	e0bff117 	ldw	r2,-60(fp)
 d0106b0:	e0bfea15 	stw	r2,-88(fp)
 d0106b4:	e0bfea17 	ldw	r2,-88(fp)
 d0106b8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 d0106bc:	00003906 	br	d0107a4 <OSFlagPend+0x48c>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 d0106c0:	e0bff917 	ldw	r2,-28(fp)
 d0106c4:	1080020b 	ldhu	r2,8(r2)
 d0106c8:	0084303a 	nor	r2,zero,r2
 d0106cc:	1007883a 	mov	r3,r2
 d0106d0:	e0bffa0b 	ldhu	r2,-24(fp)
 d0106d4:	1884703a 	and	r2,r3,r2
 d0106d8:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 d0106dc:	e0bff30b 	ldhu	r2,-52(fp)
 d0106e0:	1005003a 	cmpeq	r2,r2,zero
 d0106e4:	1000181e 	bne	r2,zero,d010748 <OSFlagPend+0x430>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 d0106e8:	e0bff203 	ldbu	r2,-56(fp)
 d0106ec:	10800058 	cmpnei	r2,r2,1
 d0106f0:	1000071e 	bne	r2,zero,d010710 <OSFlagPend+0x3f8>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 d0106f4:	e0bff917 	ldw	r2,-28(fp)
 d0106f8:	10c0020b 	ldhu	r3,8(r2)
 d0106fc:	e0bff30b 	ldhu	r2,-52(fp)
 d010700:	1884b03a 	or	r2,r3,r2
 d010704:	1007883a 	mov	r3,r2
 d010708:	e0bff917 	ldw	r2,-28(fp)
 d01070c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 d010710:	00834174 	movhi	r2,3333
 d010714:	108a9b04 	addi	r2,r2,10860
 d010718:	10c00017 	ldw	r3,0(r2)
 d01071c:	e0bff30b 	ldhu	r2,-52(fp)
 d010720:	18800b0d 	sth	r2,44(r3)
 d010724:	e0bff117 	ldw	r2,-60(fp)
 d010728:	e0bfe915 	stw	r2,-92(fp)
 d01072c:	e0bfe917 	ldw	r2,-92(fp)
 d010730:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 d010734:	e0800217 	ldw	r2,8(fp)
 d010738:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 d01073c:	e0fff30b 	ldhu	r3,-52(fp)
 d010740:	e0ffff15 	stw	r3,-4(fp)
 d010744:	00007f06 	br	d010944 <OSFlagPend+0x62c>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 d010748:	e1bffa0b 	ldhu	r6,-24(fp)
 d01074c:	e1fffb03 	ldbu	r7,-20(fp)
 d010750:	e0bffc0b 	ldhu	r2,-16(fp)
 d010754:	e17ff404 	addi	r5,fp,-48
 d010758:	d8800015 	stw	r2,0(sp)
 d01075c:	e13ff917 	ldw	r4,-28(fp)
 d010760:	d010e400 	call	d010e40 <OS_FlagBlock>
 d010764:	e0bff117 	ldw	r2,-60(fp)
 d010768:	e0bfe815 	stw	r2,-96(fp)
 d01076c:	e0bfe817 	ldw	r2,-96(fp)
 d010770:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 d010774:	00000b06 	br	d0107a4 <OSFlagPend+0x48c>
 d010778:	e0bff117 	ldw	r2,-60(fp)
 d01077c:	e0bfe715 	stw	r2,-100(fp)
 d010780:	e0bfe717 	ldw	r2,-100(fp)
 d010784:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 d010788:	e03ff30d 	sth	zero,-52(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 d01078c:	e0c00217 	ldw	r3,8(fp)
 d010790:	00801bc4 	movi	r2,111
 d010794:	18800005 	stb	r2,0(r3)
             return (flags_rdy);
 d010798:	e0bff30b 	ldhu	r2,-52(fp)
 d01079c:	e0bfff15 	stw	r2,-4(fp)
 d0107a0:	00006806 	br	d010944 <OSFlagPend+0x62c>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 d0107a4:	d00f0f40 	call	d00f0f4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0107a8:	0005303a 	rdctl	r2,status
 d0107ac:	e0bfe615 	stw	r2,-104(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0107b0:	e0ffe617 	ldw	r3,-104(fp)
 d0107b4:	00bfff84 	movi	r2,-2
 d0107b8:	1884703a 	and	r2,r3,r2
 d0107bc:	1001703a 	wrctl	status,r2
  
  return context;
 d0107c0:	e0bfe617 	ldw	r2,-104(fp)
    OS_ENTER_CRITICAL();
 d0107c4:	e0bff115 	stw	r2,-60(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 d0107c8:	00834174 	movhi	r2,3333
 d0107cc:	108a9b04 	addi	r2,r2,10860
 d0107d0:	10800017 	ldw	r2,0(r2)
 d0107d4:	10800c43 	ldbu	r2,49(r2)
 d0107d8:	10803fcc 	andi	r2,r2,255
 d0107dc:	1005003a 	cmpeq	r2,r2,zero
 d0107e0:	1000221e 	bne	r2,zero,d01086c <OSFlagPend+0x554>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 d0107e4:	00834174 	movhi	r2,3333
 d0107e8:	108a9b04 	addi	r2,r2,10860
 d0107ec:	10800017 	ldw	r2,0(r2)
 d0107f0:	10800c43 	ldbu	r2,49(r2)
 d0107f4:	e0bff245 	stb	r2,-55(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 d0107f8:	00834174 	movhi	r2,3333
 d0107fc:	108a9b04 	addi	r2,r2,10860
 d010800:	10800017 	ldw	r2,0(r2)
 d010804:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 d010808:	e13ff404 	addi	r4,fp,-48
 d01080c:	d0111f80 	call	d0111f8 <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 d010810:	00834174 	movhi	r2,3333
 d010814:	108a9b04 	addi	r2,r2,10860
 d010818:	10800017 	ldw	r2,0(r2)
 d01081c:	10000c05 	stb	zero,48(r2)
 d010820:	e0bff117 	ldw	r2,-60(fp)
 d010824:	e0bfe515 	stw	r2,-108(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d010828:	e0bfe517 	ldw	r2,-108(fp)
 d01082c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 d010830:	e03ff30d 	sth	zero,-52(fp)
        switch (pend_stat) {
 d010834:	e0bff243 	ldbu	r2,-55(fp)
 d010838:	108000a0 	cmpeqi	r2,r2,2
 d01083c:	1000011e 	bne	r2,zero,d010844 <OSFlagPend+0x52c>
 d010840:	00000406 	br	d010854 <OSFlagPend+0x53c>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 d010844:	e0c00217 	ldw	r3,8(fp)
 d010848:	00800384 	movi	r2,14
 d01084c:	18800005 	stb	r2,0(r3)
                 break;
 d010850:	00000306 	br	d010860 <OSFlagPend+0x548>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 d010854:	e0c00217 	ldw	r3,8(fp)
 d010858:	00800284 	movi	r2,10
 d01085c:	18800005 	stb	r2,0(r3)
                 break;
        }
        return (flags_rdy);
 d010860:	e0fff30b 	ldhu	r3,-52(fp)
 d010864:	e0ffff15 	stw	r3,-4(fp)
 d010868:	00003606 	br	d010944 <OSFlagPend+0x62c>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 d01086c:	00834174 	movhi	r2,3333
 d010870:	108a9b04 	addi	r2,r2,10860
 d010874:	10800017 	ldw	r2,0(r2)
 d010878:	10800b0b 	ldhu	r2,44(r2)
 d01087c:	e0bff30d 	sth	r2,-52(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 d010880:	e0bff203 	ldbu	r2,-56(fp)
 d010884:	10800058 	cmpnei	r2,r2,1
 d010888:	1000261e 	bne	r2,zero,d010924 <OSFlagPend+0x60c>
        switch (wait_type) {
 d01088c:	e0bffb03 	ldbu	r2,-20(fp)
 d010890:	e0bffd15 	stw	r2,-12(fp)
 d010894:	e0fffd17 	ldw	r3,-12(fp)
 d010898:	1804803a 	cmplt	r2,r3,zero
 d01089c:	1000181e 	bne	r2,zero,d010900 <OSFlagPend+0x5e8>
 d0108a0:	e0fffd17 	ldw	r3,-12(fp)
 d0108a4:	18800090 	cmplti	r2,r3,2
 d0108a8:	10000d1e 	bne	r2,zero,d0108e0 <OSFlagPend+0x5c8>
 d0108ac:	e0fffd17 	ldw	r3,-12(fp)
 d0108b0:	18800108 	cmpgei	r2,r3,4
 d0108b4:	1000121e 	bne	r2,zero,d010900 <OSFlagPend+0x5e8>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 d0108b8:	e0bff917 	ldw	r2,-28(fp)
 d0108bc:	1080020b 	ldhu	r2,8(r2)
 d0108c0:	1007883a 	mov	r3,r2
 d0108c4:	e0bff30b 	ldhu	r2,-52(fp)
 d0108c8:	0084303a 	nor	r2,zero,r2
 d0108cc:	1884703a 	and	r2,r3,r2
 d0108d0:	1007883a 	mov	r3,r2
 d0108d4:	e0bff917 	ldw	r2,-28(fp)
 d0108d8:	10c0020d 	sth	r3,8(r2)
                 break;
 d0108dc:	00001106 	br	d010924 <OSFlagPend+0x60c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 d0108e0:	e0bff917 	ldw	r2,-28(fp)
 d0108e4:	10c0020b 	ldhu	r3,8(r2)
 d0108e8:	e0bff30b 	ldhu	r2,-52(fp)
 d0108ec:	1884b03a 	or	r2,r3,r2
 d0108f0:	1007883a 	mov	r3,r2
 d0108f4:	e0bff917 	ldw	r2,-28(fp)
 d0108f8:	10c0020d 	sth	r3,8(r2)
                 break;
 d0108fc:	00000906 	br	d010924 <OSFlagPend+0x60c>
 d010900:	e0bff117 	ldw	r2,-60(fp)
 d010904:	e0bfe415 	stw	r2,-112(fp)
 d010908:	e0bfe417 	ldw	r2,-112(fp)
 d01090c:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 d010910:	e0c00217 	ldw	r3,8(fp)
 d010914:	00801bc4 	movi	r2,111
 d010918:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 d01091c:	e03fff15 	stw	zero,-4(fp)
 d010920:	00000806 	br	d010944 <OSFlagPend+0x62c>
 d010924:	e0bff117 	ldw	r2,-60(fp)
 d010928:	e0bfe315 	stw	r2,-116(fp)
 d01092c:	e0bfe317 	ldw	r2,-116(fp)
 d010930:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 d010934:	e0800217 	ldw	r2,8(fp)
 d010938:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 d01093c:	e0bff30b 	ldhu	r2,-52(fp)
 d010940:	e0bfff15 	stw	r2,-4(fp)
 d010944:	e0bfff17 	ldw	r2,-4(fp)
}
 d010948:	e037883a 	mov	sp,fp
 d01094c:	dfc00117 	ldw	ra,4(sp)
 d010950:	df000017 	ldw	fp,0(sp)
 d010954:	dec00204 	addi	sp,sp,8
 d010958:	f800283a 	ret

0d01095c <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 d01095c:	defffb04 	addi	sp,sp,-20
 d010960:	df000415 	stw	fp,16(sp)
 d010964:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 d010968:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01096c:	0005303a 	rdctl	r2,status
 d010970:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010974:	e0fffd17 	ldw	r3,-12(fp)
 d010978:	00bfff84 	movi	r2,-2
 d01097c:	1884703a 	and	r2,r3,r2
 d010980:	1001703a 	wrctl	status,r2
  
  return context;
 d010984:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 d010988:	e0bffe15 	stw	r2,-8(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 d01098c:	00834174 	movhi	r2,3333
 d010990:	108a9b04 	addi	r2,r2,10860
 d010994:	10800017 	ldw	r2,0(r2)
 d010998:	10800b0b 	ldhu	r2,44(r2)
 d01099c:	e0bfff0d 	sth	r2,-4(fp)
 d0109a0:	e0bffe17 	ldw	r2,-8(fp)
 d0109a4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0109a8:	e0bffc17 	ldw	r2,-16(fp)
 d0109ac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 d0109b0:	e0bfff0b 	ldhu	r2,-4(fp)
}
 d0109b4:	e037883a 	mov	sp,fp
 d0109b8:	df000017 	ldw	fp,0(sp)
 d0109bc:	dec00104 	addi	sp,sp,4
 d0109c0:	f800283a 	ret

0d0109c4 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 d0109c4:	deffed04 	addi	sp,sp,-76
 d0109c8:	dfc01215 	stw	ra,72(sp)
 d0109cc:	df001115 	stw	fp,68(sp)
 d0109d0:	df001104 	addi	fp,sp,68
 d0109d4:	e13ff915 	stw	r4,-28(fp)
 d0109d8:	e1fffc15 	stw	r7,-16(fp)
 d0109dc:	e17ffa0d 	sth	r5,-24(fp)
 d0109e0:	e1bffb05 	stb	r6,-20(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 d0109e4:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 d0109e8:	e0bffc17 	ldw	r2,-16(fp)
 d0109ec:	1004c03a 	cmpne	r2,r2,zero
 d0109f0:	1000021e 	bne	r2,zero,d0109fc <OSFlagPost+0x38>
        return ((OS_FLAGS)0);
 d0109f4:	e03fff15 	stw	zero,-4(fp)
 d0109f8:	0000d606 	br	d010d54 <OSFlagPost+0x390>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 d0109fc:	e0bff917 	ldw	r2,-28(fp)
 d010a00:	1004c03a 	cmpne	r2,r2,zero
 d010a04:	1000051e 	bne	r2,zero,d010a1c <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d010a08:	e0fffc17 	ldw	r3,-16(fp)
 d010a0c:	00801b84 	movi	r2,110
 d010a10:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010a14:	e03fff15 	stw	zero,-4(fp)
 d010a18:	0000ce06 	br	d010d54 <OSFlagPost+0x390>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 d010a1c:	e0bff917 	ldw	r2,-28(fp)
 d010a20:	10800003 	ldbu	r2,0(r2)
 d010a24:	10803fcc 	andi	r2,r2,255
 d010a28:	10800160 	cmpeqi	r2,r2,5
 d010a2c:	1000051e 	bne	r2,zero,d010a44 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 d010a30:	e0fffc17 	ldw	r3,-16(fp)
 d010a34:	00800044 	movi	r2,1
 d010a38:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010a3c:	e03fff15 	stw	zero,-4(fp)
 d010a40:	0000c406 	br	d010d54 <OSFlagPost+0x390>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010a44:	0005303a 	rdctl	r2,status
 d010a48:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010a4c:	e0fff417 	ldw	r3,-48(fp)
 d010a50:	00bfff84 	movi	r2,-2
 d010a54:	1884703a 	and	r2,r3,r2
 d010a58:	1001703a 	wrctl	status,r2
  
  return context;
 d010a5c:	e0bff417 	ldw	r2,-48(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 d010a60:	e0bff515 	stw	r2,-44(fp)
    switch (opt) {
 d010a64:	e0bffb03 	ldbu	r2,-20(fp)
 d010a68:	e0bffe15 	stw	r2,-8(fp)
 d010a6c:	e0fffe17 	ldw	r3,-8(fp)
 d010a70:	1805003a 	cmpeq	r2,r3,zero
 d010a74:	1000041e 	bne	r2,zero,d010a88 <OSFlagPost+0xc4>
 d010a78:	e0fffe17 	ldw	r3,-8(fp)
 d010a7c:	18800060 	cmpeqi	r2,r3,1
 d010a80:	10000b1e 	bne	r2,zero,d010ab0 <OSFlagPost+0xec>
 d010a84:	00001206 	br	d010ad0 <OSFlagPost+0x10c>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 d010a88:	e0bff917 	ldw	r2,-28(fp)
 d010a8c:	1080020b 	ldhu	r2,8(r2)
 d010a90:	1007883a 	mov	r3,r2
 d010a94:	e0bffa0b 	ldhu	r2,-24(fp)
 d010a98:	0084303a 	nor	r2,zero,r2
 d010a9c:	1884703a 	and	r2,r3,r2
 d010aa0:	1007883a 	mov	r3,r2
 d010aa4:	e0bff917 	ldw	r2,-28(fp)
 d010aa8:	10c0020d 	sth	r3,8(r2)
             break;
 d010aac:	00001106 	br	d010af4 <OSFlagPost+0x130>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 d010ab0:	e0bff917 	ldw	r2,-28(fp)
 d010ab4:	10c0020b 	ldhu	r3,8(r2)
 d010ab8:	e0bffa0b 	ldhu	r2,-24(fp)
 d010abc:	1884b03a 	or	r2,r3,r2
 d010ac0:	1007883a 	mov	r3,r2
 d010ac4:	e0bff917 	ldw	r2,-28(fp)
 d010ac8:	10c0020d 	sth	r3,8(r2)
             break;
 d010acc:	00000906 	br	d010af4 <OSFlagPost+0x130>
 d010ad0:	e0bff517 	ldw	r2,-44(fp)
 d010ad4:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d010ad8:	e0bff317 	ldw	r2,-52(fp)
 d010adc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 d010ae0:	e0fffc17 	ldw	r3,-16(fp)
 d010ae4:	00801c44 	movi	r2,113
 d010ae8:	18800005 	stb	r2,0(r3)
             return ((OS_FLAGS)0);
 d010aec:	e03fff15 	stw	zero,-4(fp)
 d010af0:	00009806 	br	d010d54 <OSFlagPost+0x390>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 d010af4:	e03ff785 	stb	zero,-34(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 d010af8:	e0bff917 	ldw	r2,-28(fp)
 d010afc:	10800117 	ldw	r2,4(r2)
 d010b00:	e0bff815 	stw	r2,-32(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 d010b04:	00007506 	br	d010cdc <OSFlagPost+0x318>
        switch (pnode->OSFlagNodeWaitType) {
 d010b08:	e0bff817 	ldw	r2,-32(fp)
 d010b0c:	10800483 	ldbu	r2,18(r2)
 d010b10:	10803fcc 	andi	r2,r2,255
 d010b14:	e0bffd15 	stw	r2,-12(fp)
 d010b18:	e0fffd17 	ldw	r3,-12(fp)
 d010b1c:	18800060 	cmpeqi	r2,r3,1
 d010b20:	10004d1e 	bne	r2,zero,d010c58 <OSFlagPost+0x294>
 d010b24:	e0fffd17 	ldw	r3,-12(fp)
 d010b28:	18800088 	cmpgei	r2,r3,2
 d010b2c:	1000041e 	bne	r2,zero,d010b40 <OSFlagPost+0x17c>
 d010b30:	e0fffd17 	ldw	r3,-12(fp)
 d010b34:	1805003a 	cmpeq	r2,r3,zero
 d010b38:	1000301e 	bne	r2,zero,d010bfc <OSFlagPost+0x238>
 d010b3c:	00005b06 	br	d010cac <OSFlagPost+0x2e8>
 d010b40:	e0fffd17 	ldw	r3,-12(fp)
 d010b44:	188000a0 	cmpeqi	r2,r3,2
 d010b48:	1000041e 	bne	r2,zero,d010b5c <OSFlagPost+0x198>
 d010b4c:	e0fffd17 	ldw	r3,-12(fp)
 d010b50:	188000e0 	cmpeqi	r2,r3,3
 d010b54:	1000161e 	bne	r2,zero,d010bb0 <OSFlagPost+0x1ec>
 d010b58:	00005406 	br	d010cac <OSFlagPost+0x2e8>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 d010b5c:	e0bff917 	ldw	r2,-28(fp)
 d010b60:	10c0020b 	ldhu	r3,8(r2)
 d010b64:	e0bff817 	ldw	r2,-32(fp)
 d010b68:	1080040b 	ldhu	r2,16(r2)
 d010b6c:	1884703a 	and	r2,r3,r2
 d010b70:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 d010b74:	e0bff817 	ldw	r2,-32(fp)
 d010b78:	1080040b 	ldhu	r2,16(r2)
 d010b7c:	10ffffcc 	andi	r3,r2,65535
 d010b80:	e0bff68b 	ldhu	r2,-38(fp)
 d010b84:	1880521e 	bne	r3,r2,d010cd0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 d010b88:	e17ff68b 	ldhu	r5,-38(fp)
 d010b8c:	e13ff817 	ldw	r4,-32(fp)
 d010b90:	d0110e80 	call	d0110e8 <OS_FlagTaskRdy>
 d010b94:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 d010b98:	e0bff603 	ldbu	r2,-40(fp)
 d010b9c:	10800058 	cmpnei	r2,r2,1
 d010ba0:	10004b1e 	bne	r2,zero,d010cd0 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 d010ba4:	00800044 	movi	r2,1
 d010ba8:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 d010bac:	00004806 	br	d010cd0 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 d010bb0:	e0bff917 	ldw	r2,-28(fp)
 d010bb4:	10c0020b 	ldhu	r3,8(r2)
 d010bb8:	e0bff817 	ldw	r2,-32(fp)
 d010bbc:	1080040b 	ldhu	r2,16(r2)
 d010bc0:	1884703a 	and	r2,r3,r2
 d010bc4:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 d010bc8:	e0bff68b 	ldhu	r2,-38(fp)
 d010bcc:	1005003a 	cmpeq	r2,r2,zero
 d010bd0:	10003f1e 	bne	r2,zero,d010cd0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 d010bd4:	e17ff68b 	ldhu	r5,-38(fp)
 d010bd8:	e13ff817 	ldw	r4,-32(fp)
 d010bdc:	d0110e80 	call	d0110e8 <OS_FlagTaskRdy>
 d010be0:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 d010be4:	e0bff603 	ldbu	r2,-40(fp)
 d010be8:	10800058 	cmpnei	r2,r2,1
 d010bec:	1000381e 	bne	r2,zero,d010cd0 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 d010bf0:	00800044 	movi	r2,1
 d010bf4:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 d010bf8:	00003506 	br	d010cd0 <OSFlagPost+0x30c>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 d010bfc:	e0bff917 	ldw	r2,-28(fp)
 d010c00:	1080020b 	ldhu	r2,8(r2)
 d010c04:	0084303a 	nor	r2,zero,r2
 d010c08:	1007883a 	mov	r3,r2
 d010c0c:	e0bff817 	ldw	r2,-32(fp)
 d010c10:	1080040b 	ldhu	r2,16(r2)
 d010c14:	1884703a 	and	r2,r3,r2
 d010c18:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 d010c1c:	e0bff817 	ldw	r2,-32(fp)
 d010c20:	1080040b 	ldhu	r2,16(r2)
 d010c24:	10ffffcc 	andi	r3,r2,65535
 d010c28:	e0bff68b 	ldhu	r2,-38(fp)
 d010c2c:	1880281e 	bne	r3,r2,d010cd0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 d010c30:	e17ff68b 	ldhu	r5,-38(fp)
 d010c34:	e13ff817 	ldw	r4,-32(fp)
 d010c38:	d0110e80 	call	d0110e8 <OS_FlagTaskRdy>
 d010c3c:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 d010c40:	e0bff603 	ldbu	r2,-40(fp)
 d010c44:	10800058 	cmpnei	r2,r2,1
 d010c48:	1000211e 	bne	r2,zero,d010cd0 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 d010c4c:	00800044 	movi	r2,1
 d010c50:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 d010c54:	00001e06 	br	d010cd0 <OSFlagPost+0x30c>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 d010c58:	e0bff917 	ldw	r2,-28(fp)
 d010c5c:	1080020b 	ldhu	r2,8(r2)
 d010c60:	0084303a 	nor	r2,zero,r2
 d010c64:	1007883a 	mov	r3,r2
 d010c68:	e0bff817 	ldw	r2,-32(fp)
 d010c6c:	1080040b 	ldhu	r2,16(r2)
 d010c70:	1884703a 	and	r2,r3,r2
 d010c74:	e0bff68d 	sth	r2,-38(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 d010c78:	e0bff68b 	ldhu	r2,-38(fp)
 d010c7c:	1005003a 	cmpeq	r2,r2,zero
 d010c80:	1000131e 	bne	r2,zero,d010cd0 <OSFlagPost+0x30c>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 d010c84:	e17ff68b 	ldhu	r5,-38(fp)
 d010c88:	e13ff817 	ldw	r4,-32(fp)
 d010c8c:	d0110e80 	call	d0110e8 <OS_FlagTaskRdy>
 d010c90:	e0bff605 	stb	r2,-40(fp)
                     if (rdy == OS_TRUE) {
 d010c94:	e0bff603 	ldbu	r2,-40(fp)
 d010c98:	10800058 	cmpnei	r2,r2,1
 d010c9c:	10000c1e 	bne	r2,zero,d010cd0 <OSFlagPost+0x30c>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 d010ca0:	00800044 	movi	r2,1
 d010ca4:	e0bff785 	stb	r2,-34(fp)
                     }
                 }
                 break;
 d010ca8:	00000906 	br	d010cd0 <OSFlagPost+0x30c>
 d010cac:	e0bff517 	ldw	r2,-44(fp)
 d010cb0:	e0bff215 	stw	r2,-56(fp)
 d010cb4:	e0bff217 	ldw	r2,-56(fp)
 d010cb8:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 d010cbc:	e0fffc17 	ldw	r3,-16(fp)
 d010cc0:	00801bc4 	movi	r2,111
 d010cc4:	18800005 	stb	r2,0(r3)
                 return ((OS_FLAGS)0);
 d010cc8:	e03fff15 	stw	zero,-4(fp)
 d010ccc:	00002106 	br	d010d54 <OSFlagPost+0x390>
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 d010cd0:	e0bff817 	ldw	r2,-32(fp)
 d010cd4:	10800017 	ldw	r2,0(r2)
 d010cd8:	e0bff815 	stw	r2,-32(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 d010cdc:	e0bff817 	ldw	r2,-32(fp)
 d010ce0:	1004c03a 	cmpne	r2,r2,zero
 d010ce4:	103f881e 	bne	r2,zero,d010b08 <OSFlagPost+0x144>
 d010ce8:	e0bff517 	ldw	r2,-44(fp)
 d010cec:	e0bff115 	stw	r2,-60(fp)
 d010cf0:	e0bff117 	ldw	r2,-60(fp)
 d010cf4:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 d010cf8:	e0bff783 	ldbu	r2,-34(fp)
 d010cfc:	10800058 	cmpnei	r2,r2,1
 d010d00:	1000011e 	bne	r2,zero,d010d08 <OSFlagPost+0x344>
        OS_Sched();
 d010d04:	d00f0f40 	call	d00f0f4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010d08:	0005303a 	rdctl	r2,status
 d010d0c:	e0bff015 	stw	r2,-64(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010d10:	e0fff017 	ldw	r3,-64(fp)
 d010d14:	00bfff84 	movi	r2,-2
 d010d18:	1884703a 	and	r2,r3,r2
 d010d1c:	1001703a 	wrctl	status,r2
  
  return context;
 d010d20:	e0bff017 	ldw	r2,-64(fp)
    }
    OS_ENTER_CRITICAL();
 d010d24:	e0bff515 	stw	r2,-44(fp)
    flags_cur = pgrp->OSFlagFlags;
 d010d28:	e0bff917 	ldw	r2,-28(fp)
 d010d2c:	1080020b 	ldhu	r2,8(r2)
 d010d30:	e0bff70d 	sth	r2,-36(fp)
 d010d34:	e0bff517 	ldw	r2,-44(fp)
 d010d38:	e0bfef15 	stw	r2,-68(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d010d3c:	e0bfef17 	ldw	r2,-68(fp)
 d010d40:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 d010d44:	e0bffc17 	ldw	r2,-16(fp)
 d010d48:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 d010d4c:	e0bff70b 	ldhu	r2,-36(fp)
 d010d50:	e0bfff15 	stw	r2,-4(fp)
 d010d54:	e0bfff17 	ldw	r2,-4(fp)
}
 d010d58:	e037883a 	mov	sp,fp
 d010d5c:	dfc00117 	ldw	ra,4(sp)
 d010d60:	df000017 	ldw	fp,0(sp)
 d010d64:	dec00204 	addi	sp,sp,8
 d010d68:	f800283a 	ret

0d010d6c <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 d010d6c:	defff804 	addi	sp,sp,-32
 d010d70:	df000715 	stw	fp,28(sp)
 d010d74:	df000704 	addi	fp,sp,28
 d010d78:	e13ffd15 	stw	r4,-12(fp)
 d010d7c:	e17ffe15 	stw	r5,-8(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 d010d80:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 d010d84:	e0bffe17 	ldw	r2,-8(fp)
 d010d88:	1004c03a 	cmpne	r2,r2,zero
 d010d8c:	1000021e 	bne	r2,zero,d010d98 <OSFlagQuery+0x2c>
        return ((OS_FLAGS)0);
 d010d90:	e03fff15 	stw	zero,-4(fp)
 d010d94:	00002506 	br	d010e2c <OSFlagQuery+0xc0>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 d010d98:	e0bffd17 	ldw	r2,-12(fp)
 d010d9c:	1004c03a 	cmpne	r2,r2,zero
 d010da0:	1000051e 	bne	r2,zero,d010db8 <OSFlagQuery+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 d010da4:	e0fffe17 	ldw	r3,-8(fp)
 d010da8:	00801b84 	movi	r2,110
 d010dac:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010db0:	e03fff15 	stw	zero,-4(fp)
 d010db4:	00001d06 	br	d010e2c <OSFlagQuery+0xc0>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 d010db8:	e0bffd17 	ldw	r2,-12(fp)
 d010dbc:	10800003 	ldbu	r2,0(r2)
 d010dc0:	10803fcc 	andi	r2,r2,255
 d010dc4:	10800160 	cmpeqi	r2,r2,5
 d010dc8:	1000051e 	bne	r2,zero,d010de0 <OSFlagQuery+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 d010dcc:	e0fffe17 	ldw	r3,-8(fp)
 d010dd0:	00800044 	movi	r2,1
 d010dd4:	18800005 	stb	r2,0(r3)
        return ((OS_FLAGS)0);
 d010dd8:	e03fff15 	stw	zero,-4(fp)
 d010ddc:	00001306 	br	d010e2c <OSFlagQuery+0xc0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d010de0:	0005303a 	rdctl	r2,status
 d010de4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d010de8:	e0fffa17 	ldw	r3,-24(fp)
 d010dec:	00bfff84 	movi	r2,-2
 d010df0:	1884703a 	and	r2,r3,r2
 d010df4:	1001703a 	wrctl	status,r2
  
  return context;
 d010df8:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d010dfc:	e0bffb15 	stw	r2,-20(fp)
    flags = pgrp->OSFlagFlags;
 d010e00:	e0bffd17 	ldw	r2,-12(fp)
 d010e04:	1080020b 	ldhu	r2,8(r2)
 d010e08:	e0bffc0d 	sth	r2,-16(fp)
 d010e0c:	e0bffb17 	ldw	r2,-20(fp)
 d010e10:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d010e14:	e0bff917 	ldw	r2,-28(fp)
 d010e18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d010e1c:	e0bffe17 	ldw	r2,-8(fp)
 d010e20:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 d010e24:	e0bffc0b 	ldhu	r2,-16(fp)
 d010e28:	e0bfff15 	stw	r2,-4(fp)
 d010e2c:	e0bfff17 	ldw	r2,-4(fp)
}
 d010e30:	e037883a 	mov	sp,fp
 d010e34:	df000017 	ldw	fp,0(sp)
 d010e38:	dec00104 	addi	sp,sp,4
 d010e3c:	f800283a 	ret

0d010e40 <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 d010e40:	defff804 	addi	sp,sp,-32
 d010e44:	df000715 	stw	fp,28(sp)
 d010e48:	df000704 	addi	fp,sp,28
 d010e4c:	e13ffb15 	stw	r4,-20(fp)
 d010e50:	e17ffc15 	stw	r5,-16(fp)
 d010e54:	e0800117 	ldw	r2,4(fp)
 d010e58:	e1bffd0d 	sth	r6,-12(fp)
 d010e5c:	e1fffe05 	stb	r7,-8(fp)
 d010e60:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 d010e64:	00834174 	movhi	r2,3333
 d010e68:	108a9b04 	addi	r2,r2,10860
 d010e6c:	10c00017 	ldw	r3,0(r2)
 d010e70:	00834174 	movhi	r2,3333
 d010e74:	108a9b04 	addi	r2,r2,10860
 d010e78:	10800017 	ldw	r2,0(r2)
 d010e7c:	10800c03 	ldbu	r2,48(r2)
 d010e80:	10800814 	ori	r2,r2,32
 d010e84:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 d010e88:	00834174 	movhi	r2,3333
 d010e8c:	108a9b04 	addi	r2,r2,10860
 d010e90:	10800017 	ldw	r2,0(r2)
 d010e94:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 d010e98:	00834174 	movhi	r2,3333
 d010e9c:	108a9b04 	addi	r2,r2,10860
 d010ea0:	10c00017 	ldw	r3,0(r2)
 d010ea4:	e0bfff0b 	ldhu	r2,-4(fp)
 d010ea8:	18800b8d 	sth	r2,46(r3)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 d010eac:	00834174 	movhi	r2,3333
 d010eb0:	108a9b04 	addi	r2,r2,10860
 d010eb4:	10c00017 	ldw	r3,0(r2)
 d010eb8:	e0bffc17 	ldw	r2,-16(fp)
 d010ebc:	18800a15 	stw	r2,40(r3)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 d010ec0:	e0fffc17 	ldw	r3,-16(fp)
 d010ec4:	e0bffd0b 	ldhu	r2,-12(fp)
 d010ec8:	1880040d 	sth	r2,16(r3)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 d010ecc:	e0fffc17 	ldw	r3,-16(fp)
 d010ed0:	e0bffe03 	ldbu	r2,-8(fp)
 d010ed4:	18800485 	stb	r2,18(r3)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 d010ed8:	00834174 	movhi	r2,3333
 d010edc:	108a9b04 	addi	r2,r2,10860
 d010ee0:	10c00017 	ldw	r3,0(r2)
 d010ee4:	e0bffc17 	ldw	r2,-16(fp)
 d010ee8:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 d010eec:	e0bffb17 	ldw	r2,-20(fp)
 d010ef0:	10c00117 	ldw	r3,4(r2)
 d010ef4:	e0bffc17 	ldw	r2,-16(fp)
 d010ef8:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 d010efc:	e0bffc17 	ldw	r2,-16(fp)
 d010f00:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 d010f04:	e0fffc17 	ldw	r3,-16(fp)
 d010f08:	e0bffb17 	ldw	r2,-20(fp)
 d010f0c:	18800315 	stw	r2,12(r3)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 d010f10:	e0bffb17 	ldw	r2,-20(fp)
 d010f14:	10800117 	ldw	r2,4(r2)
 d010f18:	e0bffa15 	stw	r2,-24(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 d010f1c:	e0bffa17 	ldw	r2,-24(fp)
 d010f20:	1005003a 	cmpeq	r2,r2,zero
 d010f24:	1000031e 	bne	r2,zero,d010f34 <OS_FlagBlock+0xf4>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 d010f28:	e0fffa17 	ldw	r3,-24(fp)
 d010f2c:	e0bffc17 	ldw	r2,-16(fp)
 d010f30:	18800115 	stw	r2,4(r3)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 d010f34:	e0fffb17 	ldw	r3,-20(fp)
 d010f38:	e0bffc17 	ldw	r2,-16(fp)
 d010f3c:	18800115 	stw	r2,4(r3)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 d010f40:	00834174 	movhi	r2,3333
 d010f44:	108a9b04 	addi	r2,r2,10860
 d010f48:	10800017 	ldw	r2,0(r2)
 d010f4c:	10800d03 	ldbu	r2,52(r2)
 d010f50:	e0bff905 	stb	r2,-28(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 d010f54:	e13ff903 	ldbu	r4,-28(fp)
 d010f58:	e0fff903 	ldbu	r3,-28(fp)
 d010f5c:	00834174 	movhi	r2,3333
 d010f60:	108a9844 	addi	r2,r2,10849
 d010f64:	10c5883a 	add	r2,r2,r3
 d010f68:	10800003 	ldbu	r2,0(r2)
 d010f6c:	1007883a 	mov	r3,r2
 d010f70:	00834174 	movhi	r2,3333
 d010f74:	108a9b04 	addi	r2,r2,10860
 d010f78:	10800017 	ldw	r2,0(r2)
 d010f7c:	10800d43 	ldbu	r2,53(r2)
 d010f80:	0084303a 	nor	r2,zero,r2
 d010f84:	1884703a 	and	r2,r3,r2
 d010f88:	1007883a 	mov	r3,r2
 d010f8c:	00834174 	movhi	r2,3333
 d010f90:	108a9844 	addi	r2,r2,10849
 d010f94:	1105883a 	add	r2,r2,r4
 d010f98:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 d010f9c:	e0fff903 	ldbu	r3,-28(fp)
 d010fa0:	00834174 	movhi	r2,3333
 d010fa4:	108a9844 	addi	r2,r2,10849
 d010fa8:	10c5883a 	add	r2,r2,r3
 d010fac:	10800003 	ldbu	r2,0(r2)
 d010fb0:	10803fcc 	andi	r2,r2,255
 d010fb4:	1004c03a 	cmpne	r2,r2,zero
 d010fb8:	10000e1e 	bne	r2,zero,d010ff4 <OS_FlagBlock+0x1b4>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 d010fbc:	00834174 	movhi	r2,3333
 d010fc0:	108a9b04 	addi	r2,r2,10860
 d010fc4:	10800017 	ldw	r2,0(r2)
 d010fc8:	10800d83 	ldbu	r2,54(r2)
 d010fcc:	0084303a 	nor	r2,zero,r2
 d010fd0:	1007883a 	mov	r3,r2
 d010fd4:	00834174 	movhi	r2,3333
 d010fd8:	108a9804 	addi	r2,r2,10848
 d010fdc:	10800003 	ldbu	r2,0(r2)
 d010fe0:	1884703a 	and	r2,r3,r2
 d010fe4:	1007883a 	mov	r3,r2
 d010fe8:	00834174 	movhi	r2,3333
 d010fec:	108a9804 	addi	r2,r2,10848
 d010ff0:	10c00005 	stb	r3,0(r2)
    }
}
 d010ff4:	e037883a 	mov	sp,fp
 d010ff8:	df000017 	ldw	fp,0(sp)
 d010ffc:	dec00104 	addi	sp,sp,4
 d011000:	f800283a 	ret

0d011004 <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 d011004:	defffb04 	addi	sp,sp,-20
 d011008:	dfc00415 	stw	ra,16(sp)
 d01100c:	df000315 	stw	fp,12(sp)
 d011010:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 d011014:	010341b4 	movhi	r4,3334
 d011018:	2124bf04 	addi	r4,r4,-27908
 d01101c:	0140dc04 	movi	r5,880
 d011020:	d00f0340 	call	d00f034 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 d011024:	008341b4 	movhi	r2,3334
 d011028:	10a4bf04 	addi	r2,r2,-27908
 d01102c:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 d011030:	008341b4 	movhi	r2,3334
 d011034:	10a4ca04 	addi	r2,r2,-27864
 d011038:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 d01103c:	e03fff0d 	sth	zero,-4(fp)
 d011040:	00001306 	br	d011090 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 d011044:	e0bffe17 	ldw	r2,-8(fp)
 d011048:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 d01104c:	e0fffe17 	ldw	r3,-8(fp)
 d011050:	e0bffd17 	ldw	r2,-12(fp)
 d011054:	18800115 	stw	r2,4(r3)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 d011058:	e0fffe17 	ldw	r3,-8(fp)
 d01105c:	00800fc4 	movi	r2,63
 d011060:	18800285 	stb	r2,10(r3)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 d011064:	e0bffe17 	ldw	r2,-8(fp)
 d011068:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 d01106c:	e0bffe17 	ldw	r2,-8(fp)
 d011070:	10800b04 	addi	r2,r2,44
 d011074:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 d011078:	e0bffd17 	ldw	r2,-12(fp)
 d01107c:	10800b04 	addi	r2,r2,44
 d011080:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 d011084:	e0bfff0b 	ldhu	r2,-4(fp)
 d011088:	10800044 	addi	r2,r2,1
 d01108c:	e0bfff0d 	sth	r2,-4(fp)
 d011090:	e0bfff0b 	ldhu	r2,-4(fp)
 d011094:	108004f0 	cmpltui	r2,r2,19
 d011098:	103fea1e 	bne	r2,zero,d011044 <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 d01109c:	e0bffe17 	ldw	r2,-8(fp)
 d0110a0:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 d0110a4:	e0bffe17 	ldw	r2,-8(fp)
 d0110a8:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 d0110ac:	e0fffe17 	ldw	r3,-8(fp)
 d0110b0:	00800fc4 	movi	r2,63
 d0110b4:	18800285 	stb	r2,10(r3)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 d0110b8:	e0bffe17 	ldw	r2,-8(fp)
 d0110bc:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 d0110c0:	00c34174 	movhi	r3,3333
 d0110c4:	18ca9d04 	addi	r3,r3,10868
 d0110c8:	008341b4 	movhi	r2,3334
 d0110cc:	10a4bf04 	addi	r2,r2,-27908
 d0110d0:	18800015 	stw	r2,0(r3)
#endif
}
 d0110d4:	e037883a 	mov	sp,fp
 d0110d8:	dfc00117 	ldw	ra,4(sp)
 d0110dc:	df000017 	ldw	fp,0(sp)
 d0110e0:	dec00204 	addi	sp,sp,8
 d0110e4:	f800283a 	ret

0d0110e8 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 d0110e8:	defffa04 	addi	sp,sp,-24
 d0110ec:	dfc00515 	stw	ra,20(sp)
 d0110f0:	df000415 	stw	fp,16(sp)
 d0110f4:	df000404 	addi	fp,sp,16
 d0110f8:	e13ffe15 	stw	r4,-8(fp)
 d0110fc:	e17fff0d 	sth	r5,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 d011100:	e0bffe17 	ldw	r2,-8(fp)
 d011104:	10800217 	ldw	r2,8(r2)
 d011108:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 d01110c:	e0bffd17 	ldw	r2,-12(fp)
 d011110:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 d011114:	e0fffd17 	ldw	r3,-12(fp)
 d011118:	e0bfff0b 	ldhu	r2,-4(fp)
 d01111c:	18800b0d 	sth	r2,44(r3)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 d011120:	e0bffd17 	ldw	r2,-12(fp)
 d011124:	10c00c03 	ldbu	r3,48(r2)
 d011128:	00bff7c4 	movi	r2,-33
 d01112c:	1884703a 	and	r2,r3,r2
 d011130:	1007883a 	mov	r3,r2
 d011134:	e0bffd17 	ldw	r2,-12(fp)
 d011138:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 d01113c:	e0bffd17 	ldw	r2,-12(fp)
 d011140:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 d011144:	e0bffd17 	ldw	r2,-12(fp)
 d011148:	10800c03 	ldbu	r2,48(r2)
 d01114c:	10803fcc 	andi	r2,r2,255
 d011150:	1004c03a 	cmpne	r2,r2,zero
 d011154:	10001f1e 	bne	r2,zero,d0111d4 <OS_FlagTaskRdy+0xec>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 d011158:	e0bffd17 	ldw	r2,-12(fp)
 d01115c:	10c00d83 	ldbu	r3,54(r2)
 d011160:	00834174 	movhi	r2,3333
 d011164:	108a9804 	addi	r2,r2,10848
 d011168:	10800003 	ldbu	r2,0(r2)
 d01116c:	1884b03a 	or	r2,r3,r2
 d011170:	1007883a 	mov	r3,r2
 d011174:	00834174 	movhi	r2,3333
 d011178:	108a9804 	addi	r2,r2,10848
 d01117c:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d011180:	e0bffd17 	ldw	r2,-12(fp)
 d011184:	10800d03 	ldbu	r2,52(r2)
 d011188:	11003fcc 	andi	r4,r2,255
 d01118c:	e0bffd17 	ldw	r2,-12(fp)
 d011190:	10800d03 	ldbu	r2,52(r2)
 d011194:	10c03fcc 	andi	r3,r2,255
 d011198:	00834174 	movhi	r2,3333
 d01119c:	108a9844 	addi	r2,r2,10849
 d0111a0:	10c5883a 	add	r2,r2,r3
 d0111a4:	10c00003 	ldbu	r3,0(r2)
 d0111a8:	e0bffd17 	ldw	r2,-12(fp)
 d0111ac:	10800d43 	ldbu	r2,53(r2)
 d0111b0:	1884b03a 	or	r2,r3,r2
 d0111b4:	1007883a 	mov	r3,r2
 d0111b8:	00834174 	movhi	r2,3333
 d0111bc:	108a9844 	addi	r2,r2,10849
 d0111c0:	1105883a 	add	r2,r2,r4
 d0111c4:	10c00005 	stb	r3,0(r2)
        sched                   = OS_TRUE;
 d0111c8:	00800044 	movi	r2,1
 d0111cc:	e0bffc05 	stb	r2,-16(fp)
 d0111d0:	00000106 	br	d0111d8 <OS_FlagTaskRdy+0xf0>
    } else {
        sched                   = OS_FALSE;
 d0111d4:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 d0111d8:	e13ffe17 	ldw	r4,-8(fp)
 d0111dc:	d0111f80 	call	d0111f8 <OS_FlagUnlink>
    return (sched);
 d0111e0:	e0bffc03 	ldbu	r2,-16(fp)
}
 d0111e4:	e037883a 	mov	sp,fp
 d0111e8:	dfc00117 	ldw	ra,4(sp)
 d0111ec:	df000017 	ldw	fp,0(sp)
 d0111f0:	dec00204 	addi	sp,sp,8
 d0111f4:	f800283a 	ret

0d0111f8 <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 d0111f8:	defffa04 	addi	sp,sp,-24
 d0111fc:	df000515 	stw	fp,20(sp)
 d011200:	df000504 	addi	fp,sp,20
 d011204:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 d011208:	e0bfff17 	ldw	r2,-4(fp)
 d01120c:	10800117 	ldw	r2,4(r2)
 d011210:	e0bffc15 	stw	r2,-16(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 d011214:	e0bfff17 	ldw	r2,-4(fp)
 d011218:	10800017 	ldw	r2,0(r2)
 d01121c:	e0bffb15 	stw	r2,-20(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 d011220:	e0bffc17 	ldw	r2,-16(fp)
 d011224:	1004c03a 	cmpne	r2,r2,zero
 d011228:	10000c1e 	bne	r2,zero,d01125c <OS_FlagUnlink+0x64>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 d01122c:	e0bfff17 	ldw	r2,-4(fp)
 d011230:	10800317 	ldw	r2,12(r2)
 d011234:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 d011238:	e0fffd17 	ldw	r3,-12(fp)
 d01123c:	e0bffb17 	ldw	r2,-20(fp)
 d011240:	18800115 	stw	r2,4(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 d011244:	e0bffb17 	ldw	r2,-20(fp)
 d011248:	1005003a 	cmpeq	r2,r2,zero
 d01124c:	10000c1e 	bne	r2,zero,d011280 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 d011250:	e0bffb17 	ldw	r2,-20(fp)
 d011254:	10000115 	stw	zero,4(r2)
 d011258:	00000906 	br	d011280 <OS_FlagUnlink+0x88>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 d01125c:	e0fffc17 	ldw	r3,-16(fp)
 d011260:	e0bffb17 	ldw	r2,-20(fp)
 d011264:	18800015 	stw	r2,0(r3)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 d011268:	e0bffb17 	ldw	r2,-20(fp)
 d01126c:	1005003a 	cmpeq	r2,r2,zero
 d011270:	1000031e 	bne	r2,zero,d011280 <OS_FlagUnlink+0x88>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 d011274:	e0fffb17 	ldw	r3,-20(fp)
 d011278:	e0bffc17 	ldw	r2,-16(fp)
 d01127c:	18800115 	stw	r2,4(r3)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 d011280:	e0bfff17 	ldw	r2,-4(fp)
 d011284:	10800217 	ldw	r2,8(r2)
 d011288:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 d01128c:	e0bffe17 	ldw	r2,-8(fp)
 d011290:	10000a15 	stw	zero,40(r2)
#endif
}
 d011294:	e037883a 	mov	sp,fp
 d011298:	df000017 	ldw	fp,0(sp)
 d01129c:	dec00104 	addi	sp,sp,4
 d0112a0:	f800283a 	ret

0d0112a4 <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 d0112a4:	defff304 	addi	sp,sp,-52
 d0112a8:	df000c15 	stw	fp,48(sp)
 d0112ac:	df000c04 	addi	fp,sp,48
 d0112b0:	e13ffb15 	stw	r4,-20(fp)
 d0112b4:	e17ffc15 	stw	r5,-16(fp)
 d0112b8:	e1bffd15 	stw	r6,-12(fp)
 d0112bc:	e1fffe15 	stw	r7,-8(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0112c0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d0112c4:	e0bffe17 	ldw	r2,-8(fp)
 d0112c8:	1004c03a 	cmpne	r2,r2,zero
 d0112cc:	1000021e 	bne	r2,zero,d0112d8 <OSMemCreate+0x34>
        return ((OS_MEM *)0);
 d0112d0:	e03fff15 	stw	zero,-4(fp)
 d0112d4:	00007506 	br	d0114ac <OSMemCreate+0x208>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 d0112d8:	e0bffb17 	ldw	r2,-20(fp)
 d0112dc:	1004c03a 	cmpne	r2,r2,zero
 d0112e0:	1000051e 	bne	r2,zero,d0112f8 <OSMemCreate+0x54>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 d0112e4:	e0fffe17 	ldw	r3,-8(fp)
 d0112e8:	00801884 	movi	r2,98
 d0112ec:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d0112f0:	e03fff15 	stw	zero,-4(fp)
 d0112f4:	00006d06 	br	d0114ac <OSMemCreate+0x208>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 d0112f8:	e0bffb17 	ldw	r2,-20(fp)
 d0112fc:	108000cc 	andi	r2,r2,3
 d011300:	1005003a 	cmpeq	r2,r2,zero
 d011304:	1000051e 	bne	r2,zero,d01131c <OSMemCreate+0x78>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 d011308:	e0fffe17 	ldw	r3,-8(fp)
 d01130c:	00801884 	movi	r2,98
 d011310:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d011314:	e03fff15 	stw	zero,-4(fp)
 d011318:	00006406 	br	d0114ac <OSMemCreate+0x208>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 d01131c:	e0bffc17 	ldw	r2,-16(fp)
 d011320:	108000a8 	cmpgeui	r2,r2,2
 d011324:	1000051e 	bne	r2,zero,d01133c <OSMemCreate+0x98>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 d011328:	e0fffe17 	ldw	r3,-8(fp)
 d01132c:	008016c4 	movi	r2,91
 d011330:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d011334:	e03fff15 	stw	zero,-4(fp)
 d011338:	00005c06 	br	d0114ac <OSMemCreate+0x208>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 d01133c:	e0bffd17 	ldw	r2,-12(fp)
 d011340:	10800128 	cmpgeui	r2,r2,4
 d011344:	1000051e 	bne	r2,zero,d01135c <OSMemCreate+0xb8>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 d011348:	e0fffe17 	ldw	r3,-8(fp)
 d01134c:	00801704 	movi	r2,92
 d011350:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d011354:	e03fff15 	stw	zero,-4(fp)
 d011358:	00005406 	br	d0114ac <OSMemCreate+0x208>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01135c:	0005303a 	rdctl	r2,status
 d011360:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011364:	e0fff517 	ldw	r3,-44(fp)
 d011368:	00bfff84 	movi	r2,-2
 d01136c:	1884703a 	and	r2,r3,r2
 d011370:	1001703a 	wrctl	status,r2
  
  return context;
 d011374:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d011378:	e0bff615 	stw	r2,-40(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 d01137c:	00834174 	movhi	r2,3333
 d011380:	108a9504 	addi	r2,r2,10836
 d011384:	10800017 	ldw	r2,0(r2)
 d011388:	e0bffa15 	stw	r2,-24(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 d01138c:	00834174 	movhi	r2,3333
 d011390:	108a9504 	addi	r2,r2,10836
 d011394:	10800017 	ldw	r2,0(r2)
 d011398:	1005003a 	cmpeq	r2,r2,zero
 d01139c:	1000081e 	bne	r2,zero,d0113c0 <OSMemCreate+0x11c>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 d0113a0:	00834174 	movhi	r2,3333
 d0113a4:	108a9504 	addi	r2,r2,10836
 d0113a8:	10800017 	ldw	r2,0(r2)
 d0113ac:	10800117 	ldw	r2,4(r2)
 d0113b0:	1007883a 	mov	r3,r2
 d0113b4:	00834174 	movhi	r2,3333
 d0113b8:	108a9504 	addi	r2,r2,10836
 d0113bc:	10c00015 	stw	r3,0(r2)
 d0113c0:	e0bff617 	ldw	r2,-40(fp)
 d0113c4:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0113c8:	e0bff417 	ldw	r2,-48(fp)
 d0113cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 d0113d0:	e0bffa17 	ldw	r2,-24(fp)
 d0113d4:	1004c03a 	cmpne	r2,r2,zero
 d0113d8:	1000051e 	bne	r2,zero,d0113f0 <OSMemCreate+0x14c>
        *perr = OS_ERR_MEM_INVALID_PART;
 d0113dc:	e0fffe17 	ldw	r3,-8(fp)
 d0113e0:	00801684 	movi	r2,90
 d0113e4:	18800005 	stb	r2,0(r3)
        return ((OS_MEM *)0);
 d0113e8:	e03fff15 	stw	zero,-4(fp)
 d0113ec:	00002f06 	br	d0114ac <OSMemCreate+0x208>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 d0113f0:	e0bffb17 	ldw	r2,-20(fp)
 d0113f4:	e0bff815 	stw	r2,-32(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 d0113f8:	e0bffb17 	ldw	r2,-20(fp)
 d0113fc:	1007883a 	mov	r3,r2
 d011400:	e0bffd17 	ldw	r2,-12(fp)
 d011404:	1885883a 	add	r2,r3,r2
 d011408:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < (nblks - 1); i++) {
 d01140c:	e03ff715 	stw	zero,-36(fp)
 d011410:	00000d06 	br	d011448 <OSMemCreate+0x1a4>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 d011414:	e0fff817 	ldw	r3,-32(fp)
 d011418:	e0bff917 	ldw	r2,-28(fp)
 d01141c:	18800015 	stw	r2,0(r3)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 d011420:	e0bff917 	ldw	r2,-28(fp)
 d011424:	e0bff815 	stw	r2,-32(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 d011428:	e0bff917 	ldw	r2,-28(fp)
 d01142c:	1007883a 	mov	r3,r2
 d011430:	e0bffd17 	ldw	r2,-12(fp)
 d011434:	1885883a 	add	r2,r3,r2
 d011438:	e0bff915 	stw	r2,-28(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 d01143c:	e0bff717 	ldw	r2,-36(fp)
 d011440:	10800044 	addi	r2,r2,1
 d011444:	e0bff715 	stw	r2,-36(fp)
 d011448:	e0bffc17 	ldw	r2,-16(fp)
 d01144c:	10ffffc4 	addi	r3,r2,-1
 d011450:	e0bff717 	ldw	r2,-36(fp)
 d011454:	10ffef36 	bltu	r2,r3,d011414 <OSMemCreate+0x170>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 d011458:	e0bff817 	ldw	r2,-32(fp)
 d01145c:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 d011460:	e0fffa17 	ldw	r3,-24(fp)
 d011464:	e0bffb17 	ldw	r2,-20(fp)
 d011468:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 d01146c:	e0fffa17 	ldw	r3,-24(fp)
 d011470:	e0bffb17 	ldw	r2,-20(fp)
 d011474:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 d011478:	e0fffa17 	ldw	r3,-24(fp)
 d01147c:	e0bffc17 	ldw	r2,-16(fp)
 d011480:	18800415 	stw	r2,16(r3)
    pmem->OSMemNBlks    = nblks;
 d011484:	e0fffa17 	ldw	r3,-24(fp)
 d011488:	e0bffc17 	ldw	r2,-16(fp)
 d01148c:	18800315 	stw	r2,12(r3)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 d011490:	e0fffa17 	ldw	r3,-24(fp)
 d011494:	e0bffd17 	ldw	r2,-12(fp)
 d011498:	18800215 	stw	r2,8(r3)
    *perr               = OS_ERR_NONE;
 d01149c:	e0bffe17 	ldw	r2,-8(fp)
 d0114a0:	10000005 	stb	zero,0(r2)
    return (pmem);
 d0114a4:	e0bffa17 	ldw	r2,-24(fp)
 d0114a8:	e0bfff15 	stw	r2,-4(fp)
 d0114ac:	e0bfff17 	ldw	r2,-4(fp)
}
 d0114b0:	e037883a 	mov	sp,fp
 d0114b4:	df000017 	ldw	fp,0(sp)
 d0114b8:	dec00104 	addi	sp,sp,4
 d0114bc:	f800283a 	ret

0d0114c0 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 d0114c0:	defff704 	addi	sp,sp,-36
 d0114c4:	df000815 	stw	fp,32(sp)
 d0114c8:	df000804 	addi	fp,sp,32
 d0114cc:	e13ffd15 	stw	r4,-12(fp)
 d0114d0:	e17ffe15 	stw	r5,-8(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0114d4:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d0114d8:	e0bffe17 	ldw	r2,-8(fp)
 d0114dc:	1004c03a 	cmpne	r2,r2,zero
 d0114e0:	1000021e 	bne	r2,zero,d0114ec <OSMemGet+0x2c>
        return ((void *)0);
 d0114e4:	e03fff15 	stw	zero,-4(fp)
 d0114e8:	00003106 	br	d0115b0 <OSMemGet+0xf0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 d0114ec:	e0bffd17 	ldw	r2,-12(fp)
 d0114f0:	1004c03a 	cmpne	r2,r2,zero
 d0114f4:	1000051e 	bne	r2,zero,d01150c <OSMemGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 d0114f8:	e0fffe17 	ldw	r3,-8(fp)
 d0114fc:	00801804 	movi	r2,96
 d011500:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d011504:	e03fff15 	stw	zero,-4(fp)
 d011508:	00002906 	br	d0115b0 <OSMemGet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01150c:	0005303a 	rdctl	r2,status
 d011510:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011514:	e0fffa17 	ldw	r3,-24(fp)
 d011518:	00bfff84 	movi	r2,-2
 d01151c:	1884703a 	and	r2,r3,r2
 d011520:	1001703a 	wrctl	status,r2
  
  return context;
 d011524:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d011528:	e0bffb15 	stw	r2,-20(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 d01152c:	e0bffd17 	ldw	r2,-12(fp)
 d011530:	10800417 	ldw	r2,16(r2)
 d011534:	1005003a 	cmpeq	r2,r2,zero
 d011538:	1000151e 	bne	r2,zero,d011590 <OSMemGet+0xd0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 d01153c:	e0bffd17 	ldw	r2,-12(fp)
 d011540:	10800117 	ldw	r2,4(r2)
 d011544:	e0bffc15 	stw	r2,-16(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 d011548:	e0bffc17 	ldw	r2,-16(fp)
 d01154c:	10c00017 	ldw	r3,0(r2)
 d011550:	e0bffd17 	ldw	r2,-12(fp)
 d011554:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 d011558:	e0bffd17 	ldw	r2,-12(fp)
 d01155c:	10800417 	ldw	r2,16(r2)
 d011560:	10ffffc4 	addi	r3,r2,-1
 d011564:	e0bffd17 	ldw	r2,-12(fp)
 d011568:	10c00415 	stw	r3,16(r2)
 d01156c:	e0bffb17 	ldw	r2,-20(fp)
 d011570:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011574:	e0bff917 	ldw	r2,-28(fp)
 d011578:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 d01157c:	e0bffe17 	ldw	r2,-8(fp)
 d011580:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 d011584:	e0bffc17 	ldw	r2,-16(fp)
 d011588:	e0bfff15 	stw	r2,-4(fp)
 d01158c:	00000806 	br	d0115b0 <OSMemGet+0xf0>
 d011590:	e0bffb17 	ldw	r2,-20(fp)
 d011594:	e0bff815 	stw	r2,-32(fp)
 d011598:	e0bff817 	ldw	r2,-32(fp)
 d01159c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 d0115a0:	e0fffe17 	ldw	r3,-8(fp)
 d0115a4:	00801744 	movi	r2,93
 d0115a8:	18800005 	stb	r2,0(r3)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 d0115ac:	e03fff15 	stw	zero,-4(fp)
 d0115b0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0115b4:	e037883a 	mov	sp,fp
 d0115b8:	df000017 	ldw	fp,0(sp)
 d0115bc:	dec00104 	addi	sp,sp,4
 d0115c0:	f800283a 	ret

0d0115c4 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 d0115c4:	defff604 	addi	sp,sp,-40
 d0115c8:	dfc00915 	stw	ra,36(sp)
 d0115cc:	df000815 	stw	fp,32(sp)
 d0115d0:	df000804 	addi	fp,sp,32
 d0115d4:	e13ffc15 	stw	r4,-16(fp)
 d0115d8:	e17ffd15 	stw	r5,-12(fp)
 d0115dc:	e1bffe15 	stw	r6,-8(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0115e0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d0115e4:	e0bffe17 	ldw	r2,-8(fp)
 d0115e8:	1004c03a 	cmpne	r2,r2,zero
 d0115ec:	1000021e 	bne	r2,zero,d0115f8 <OSMemNameGet+0x34>
        return (0);
 d0115f0:	e03fff15 	stw	zero,-4(fp)
 d0115f4:	00003006 	br	d0116b8 <OSMemNameGet+0xf4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 d0115f8:	e0bffc17 	ldw	r2,-16(fp)
 d0115fc:	1004c03a 	cmpne	r2,r2,zero
 d011600:	1000051e 	bne	r2,zero,d011618 <OSMemNameGet+0x54>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 d011604:	e0fffe17 	ldw	r3,-8(fp)
 d011608:	00801804 	movi	r2,96
 d01160c:	18800005 	stb	r2,0(r3)
        return (0);
 d011610:	e03fff15 	stw	zero,-4(fp)
 d011614:	00002806 	br	d0116b8 <OSMemNameGet+0xf4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d011618:	e0bffd17 	ldw	r2,-12(fp)
 d01161c:	1004c03a 	cmpne	r2,r2,zero
 d011620:	1000051e 	bne	r2,zero,d011638 <OSMemNameGet+0x74>
        *perr = OS_ERR_PNAME_NULL;
 d011624:	e0fffe17 	ldw	r3,-8(fp)
 d011628:	00800304 	movi	r2,12
 d01162c:	18800005 	stb	r2,0(r3)
        return (0);
 d011630:	e03fff15 	stw	zero,-4(fp)
 d011634:	00002006 	br	d0116b8 <OSMemNameGet+0xf4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d011638:	00834174 	movhi	r2,3333
 d01163c:	108a9a04 	addi	r2,r2,10856
 d011640:	10800003 	ldbu	r2,0(r2)
 d011644:	10803fcc 	andi	r2,r2,255
 d011648:	1005003a 	cmpeq	r2,r2,zero
 d01164c:	1000051e 	bne	r2,zero,d011664 <OSMemNameGet+0xa0>
        *perr = OS_ERR_NAME_GET_ISR;
 d011650:	e0fffe17 	ldw	r3,-8(fp)
 d011654:	00800444 	movi	r2,17
 d011658:	18800005 	stb	r2,0(r3)
        return (0);
 d01165c:	e03fff15 	stw	zero,-4(fp)
 d011660:	00001506 	br	d0116b8 <OSMemNameGet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011664:	0005303a 	rdctl	r2,status
 d011668:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01166c:	e0fff917 	ldw	r3,-28(fp)
 d011670:	00bfff84 	movi	r2,-2
 d011674:	1884703a 	and	r2,r3,r2
 d011678:	1001703a 	wrctl	status,r2
  
  return context;
 d01167c:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d011680:	e0bffa15 	stw	r2,-24(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 d011684:	e0bffc17 	ldw	r2,-16(fp)
 d011688:	11400504 	addi	r5,r2,20
 d01168c:	e13ffd17 	ldw	r4,-12(fp)
 d011690:	d00f2380 	call	d00f238 <OS_StrCopy>
 d011694:	e0bffb05 	stb	r2,-20(fp)
 d011698:	e0bffa17 	ldw	r2,-24(fp)
 d01169c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0116a0:	e0bff817 	ldw	r2,-32(fp)
 d0116a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d0116a8:	e0bffe17 	ldw	r2,-8(fp)
 d0116ac:	10000005 	stb	zero,0(r2)
    return (len);
 d0116b0:	e0bffb03 	ldbu	r2,-20(fp)
 d0116b4:	e0bfff15 	stw	r2,-4(fp)
 d0116b8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0116bc:	e037883a 	mov	sp,fp
 d0116c0:	dfc00117 	ldw	ra,4(sp)
 d0116c4:	df000017 	ldw	fp,0(sp)
 d0116c8:	dec00204 	addi	sp,sp,8
 d0116cc:	f800283a 	ret

0d0116d0 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 d0116d0:	defff604 	addi	sp,sp,-40
 d0116d4:	dfc00915 	stw	ra,36(sp)
 d0116d8:	df000815 	stw	fp,32(sp)
 d0116dc:	df000804 	addi	fp,sp,32
 d0116e0:	e13ffd15 	stw	r4,-12(fp)
 d0116e4:	e17ffe15 	stw	r5,-8(fp)
 d0116e8:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0116ec:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d0116f0:	e0bfff17 	ldw	r2,-4(fp)
 d0116f4:	1005003a 	cmpeq	r2,r2,zero
 d0116f8:	1000381e 	bne	r2,zero,d0117dc <OSMemNameSet+0x10c>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 d0116fc:	e0bffd17 	ldw	r2,-12(fp)
 d011700:	1004c03a 	cmpne	r2,r2,zero
 d011704:	1000041e 	bne	r2,zero,d011718 <OSMemNameSet+0x48>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 d011708:	e0ffff17 	ldw	r3,-4(fp)
 d01170c:	00801804 	movi	r2,96
 d011710:	18800005 	stb	r2,0(r3)
        return;
 d011714:	00003106 	br	d0117dc <OSMemNameSet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 d011718:	e0bffe17 	ldw	r2,-8(fp)
 d01171c:	1004c03a 	cmpne	r2,r2,zero
 d011720:	1000041e 	bne	r2,zero,d011734 <OSMemNameSet+0x64>
        *perr = OS_ERR_PNAME_NULL;
 d011724:	e0ffff17 	ldw	r3,-4(fp)
 d011728:	00800304 	movi	r2,12
 d01172c:	18800005 	stb	r2,0(r3)
        return;
 d011730:	00002a06 	br	d0117dc <OSMemNameSet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d011734:	00834174 	movhi	r2,3333
 d011738:	108a9a04 	addi	r2,r2,10856
 d01173c:	10800003 	ldbu	r2,0(r2)
 d011740:	10803fcc 	andi	r2,r2,255
 d011744:	1005003a 	cmpeq	r2,r2,zero
 d011748:	1000041e 	bne	r2,zero,d01175c <OSMemNameSet+0x8c>
        *perr = OS_ERR_NAME_SET_ISR;
 d01174c:	e0ffff17 	ldw	r3,-4(fp)
 d011750:	00800484 	movi	r2,18
 d011754:	18800005 	stb	r2,0(r3)
        return;
 d011758:	00002006 	br	d0117dc <OSMemNameSet+0x10c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01175c:	0005303a 	rdctl	r2,status
 d011760:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011764:	e0fffa17 	ldw	r3,-24(fp)
 d011768:	00bfff84 	movi	r2,-2
 d01176c:	1884703a 	and	r2,r3,r2
 d011770:	1001703a 	wrctl	status,r2
  
  return context;
 d011774:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d011778:	e0bffb15 	stw	r2,-20(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 d01177c:	e13ffe17 	ldw	r4,-8(fp)
 d011780:	d00f2b80 	call	d00f2b8 <OS_StrLen>
 d011784:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 d011788:	e0bffc03 	ldbu	r2,-16(fp)
 d01178c:	10800830 	cmpltui	r2,r2,32
 d011790:	1000081e 	bne	r2,zero,d0117b4 <OSMemNameSet+0xe4>
 d011794:	e0bffb17 	ldw	r2,-20(fp)
 d011798:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01179c:	e0bff917 	ldw	r2,-28(fp)
 d0117a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 d0117a4:	e0ffff17 	ldw	r3,-4(fp)
 d0117a8:	008018c4 	movi	r2,99
 d0117ac:	18800005 	stb	r2,0(r3)
        return;
 d0117b0:	00000a06 	br	d0117dc <OSMemNameSet+0x10c>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 d0117b4:	e0bffd17 	ldw	r2,-12(fp)
 d0117b8:	11000504 	addi	r4,r2,20
 d0117bc:	e17ffe17 	ldw	r5,-8(fp)
 d0117c0:	d00f2380 	call	d00f238 <OS_StrCopy>
 d0117c4:	e0bffb17 	ldw	r2,-20(fp)
 d0117c8:	e0bff815 	stw	r2,-32(fp)
 d0117cc:	e0bff817 	ldw	r2,-32(fp)
 d0117d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d0117d4:	e0bfff17 	ldw	r2,-4(fp)
 d0117d8:	10000005 	stb	zero,0(r2)
}
 d0117dc:	e037883a 	mov	sp,fp
 d0117e0:	dfc00117 	ldw	ra,4(sp)
 d0117e4:	df000017 	ldw	fp,0(sp)
 d0117e8:	dec00204 	addi	sp,sp,8
 d0117ec:	f800283a 	ret

0d0117f0 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 d0117f0:	defff804 	addi	sp,sp,-32
 d0117f4:	df000715 	stw	fp,28(sp)
 d0117f8:	df000704 	addi	fp,sp,28
 d0117fc:	e13ffd15 	stw	r4,-12(fp)
 d011800:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d011804:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 d011808:	e0bffd17 	ldw	r2,-12(fp)
 d01180c:	1004c03a 	cmpne	r2,r2,zero
 d011810:	1000031e 	bne	r2,zero,d011820 <OSMemPut+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 d011814:	00801804 	movi	r2,96
 d011818:	e0bfff15 	stw	r2,-4(fp)
 d01181c:	00002b06 	br	d0118cc <OSMemPut+0xdc>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 d011820:	e0bffe17 	ldw	r2,-8(fp)
 d011824:	1004c03a 	cmpne	r2,r2,zero
 d011828:	1000031e 	bne	r2,zero,d011838 <OSMemPut+0x48>
        return (OS_ERR_MEM_INVALID_PBLK);
 d01182c:	008017c4 	movi	r2,95
 d011830:	e0bfff15 	stw	r2,-4(fp)
 d011834:	00002506 	br	d0118cc <OSMemPut+0xdc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011838:	0005303a 	rdctl	r2,status
 d01183c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011840:	e0fffb17 	ldw	r3,-20(fp)
 d011844:	00bfff84 	movi	r2,-2
 d011848:	1884703a 	and	r2,r3,r2
 d01184c:	1001703a 	wrctl	status,r2
  
  return context;
 d011850:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d011854:	e0bffc15 	stw	r2,-16(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 d011858:	e0bffd17 	ldw	r2,-12(fp)
 d01185c:	10c00417 	ldw	r3,16(r2)
 d011860:	e0bffd17 	ldw	r2,-12(fp)
 d011864:	10800317 	ldw	r2,12(r2)
 d011868:	18800736 	bltu	r3,r2,d011888 <OSMemPut+0x98>
 d01186c:	e0bffc17 	ldw	r2,-16(fp)
 d011870:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011874:	e0bffa17 	ldw	r2,-24(fp)
 d011878:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 d01187c:	00801784 	movi	r2,94
 d011880:	e0bfff15 	stw	r2,-4(fp)
 d011884:	00001106 	br	d0118cc <OSMemPut+0xdc>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 d011888:	e0fffe17 	ldw	r3,-8(fp)
 d01188c:	e0bffd17 	ldw	r2,-12(fp)
 d011890:	10800117 	ldw	r2,4(r2)
 d011894:	18800015 	stw	r2,0(r3)
    pmem->OSMemFreeList = pblk;
 d011898:	e0fffd17 	ldw	r3,-12(fp)
 d01189c:	e0bffe17 	ldw	r2,-8(fp)
 d0118a0:	18800115 	stw	r2,4(r3)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 d0118a4:	e0bffd17 	ldw	r2,-12(fp)
 d0118a8:	10800417 	ldw	r2,16(r2)
 d0118ac:	10c00044 	addi	r3,r2,1
 d0118b0:	e0bffd17 	ldw	r2,-12(fp)
 d0118b4:	10c00415 	stw	r3,16(r2)
 d0118b8:	e0bffc17 	ldw	r2,-16(fp)
 d0118bc:	e0bff915 	stw	r2,-28(fp)
 d0118c0:	e0bff917 	ldw	r2,-28(fp)
 d0118c4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 d0118c8:	e03fff15 	stw	zero,-4(fp)
 d0118cc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0118d0:	e037883a 	mov	sp,fp
 d0118d4:	df000017 	ldw	fp,0(sp)
 d0118d8:	dec00104 	addi	sp,sp,4
 d0118dc:	f800283a 	ret

0d0118e0 <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 d0118e0:	defff904 	addi	sp,sp,-28
 d0118e4:	df000615 	stw	fp,24(sp)
 d0118e8:	df000604 	addi	fp,sp,24
 d0118ec:	e13ffd15 	stw	r4,-12(fp)
 d0118f0:	e17ffe15 	stw	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0118f4:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 d0118f8:	e0bffd17 	ldw	r2,-12(fp)
 d0118fc:	1004c03a 	cmpne	r2,r2,zero
 d011900:	1000031e 	bne	r2,zero,d011910 <OSMemQuery+0x30>
        return (OS_ERR_MEM_INVALID_PMEM);
 d011904:	00801804 	movi	r2,96
 d011908:	e0bfff15 	stw	r2,-4(fp)
 d01190c:	00002e06 	br	d0119c8 <OSMemQuery+0xe8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 d011910:	e0bffe17 	ldw	r2,-8(fp)
 d011914:	1004c03a 	cmpne	r2,r2,zero
 d011918:	1000031e 	bne	r2,zero,d011928 <OSMemQuery+0x48>
        return (OS_ERR_MEM_INVALID_PDATA);
 d01191c:	00801844 	movi	r2,97
 d011920:	e0bfff15 	stw	r2,-4(fp)
 d011924:	00002806 	br	d0119c8 <OSMemQuery+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011928:	0005303a 	rdctl	r2,status
 d01192c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011930:	e0fffb17 	ldw	r3,-20(fp)
 d011934:	00bfff84 	movi	r2,-2
 d011938:	1884703a 	and	r2,r3,r2
 d01193c:	1001703a 	wrctl	status,r2
  
  return context;
 d011940:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d011944:	e0bffc15 	stw	r2,-16(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 d011948:	e0bffd17 	ldw	r2,-12(fp)
 d01194c:	10c00017 	ldw	r3,0(r2)
 d011950:	e0bffe17 	ldw	r2,-8(fp)
 d011954:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 d011958:	e0bffd17 	ldw	r2,-12(fp)
 d01195c:	10c00117 	ldw	r3,4(r2)
 d011960:	e0bffe17 	ldw	r2,-8(fp)
 d011964:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 d011968:	e0bffd17 	ldw	r2,-12(fp)
 d01196c:	10c00217 	ldw	r3,8(r2)
 d011970:	e0bffe17 	ldw	r2,-8(fp)
 d011974:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 d011978:	e0bffd17 	ldw	r2,-12(fp)
 d01197c:	10c00317 	ldw	r3,12(r2)
 d011980:	e0bffe17 	ldw	r2,-8(fp)
 d011984:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 d011988:	e0bffd17 	ldw	r2,-12(fp)
 d01198c:	10c00417 	ldw	r3,16(r2)
 d011990:	e0bffe17 	ldw	r2,-8(fp)
 d011994:	10c00415 	stw	r3,16(r2)
 d011998:	e0bffc17 	ldw	r2,-16(fp)
 d01199c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0119a0:	e0bffa17 	ldw	r2,-24(fp)
 d0119a4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 d0119a8:	e0bffe17 	ldw	r2,-8(fp)
 d0119ac:	10c00317 	ldw	r3,12(r2)
 d0119b0:	e0bffe17 	ldw	r2,-8(fp)
 d0119b4:	10800417 	ldw	r2,16(r2)
 d0119b8:	1887c83a 	sub	r3,r3,r2
 d0119bc:	e0bffe17 	ldw	r2,-8(fp)
 d0119c0:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 d0119c4:	e03fff15 	stw	zero,-4(fp)
 d0119c8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0119cc:	e037883a 	mov	sp,fp
 d0119d0:	df000017 	ldw	fp,0(sp)
 d0119d4:	dec00104 	addi	sp,sp,4
 d0119d8:	f800283a 	ret

0d0119dc <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 d0119dc:	defffc04 	addi	sp,sp,-16
 d0119e0:	dfc00315 	stw	ra,12(sp)
 d0119e4:	df000215 	stw	fp,8(sp)
 d0119e8:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 d0119ec:	010341b4 	movhi	r4,3334
 d0119f0:	21259b04 	addi	r4,r4,-27028
 d0119f4:	01430c04 	movi	r5,3120
 d0119f8:	d00f0340 	call	d00f034 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 d0119fc:	008341b4 	movhi	r2,3334
 d011a00:	10a59b04 	addi	r2,r2,-27028
 d011a04:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 d011a08:	e03ffe0d 	sth	zero,-8(fp)
 d011a0c:	00001306 	br	d011a5c <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 d011a10:	e0bffe0b 	ldhu	r2,-8(fp)
 d011a14:	10800d24 	muli	r2,r2,52
 d011a18:	1007883a 	mov	r3,r2
 d011a1c:	008341b4 	movhi	r2,3334
 d011a20:	10a5a804 	addi	r2,r2,-26976
 d011a24:	1887883a 	add	r3,r3,r2
 d011a28:	e0bfff17 	ldw	r2,-4(fp)
 d011a2c:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 d011a30:	e0ffff17 	ldw	r3,-4(fp)
 d011a34:	00800fc4 	movi	r2,63
 d011a38:	18800505 	stb	r2,20(r3)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 d011a3c:	e0bfff17 	ldw	r2,-4(fp)
 d011a40:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 d011a44:	e0bfff17 	ldw	r2,-4(fp)
 d011a48:	10800d04 	addi	r2,r2,52
 d011a4c:	e0bfff15 	stw	r2,-4(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 d011a50:	e0bffe0b 	ldhu	r2,-8(fp)
 d011a54:	10800044 	addi	r2,r2,1
 d011a58:	e0bffe0d 	sth	r2,-8(fp)
 d011a5c:	e0bffe0b 	ldhu	r2,-8(fp)
 d011a60:	10800ef0 	cmpltui	r2,r2,59
 d011a64:	103fea1e 	bne	r2,zero,d011a10 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 d011a68:	e0bfff17 	ldw	r2,-4(fp)
 d011a6c:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 d011a70:	e0ffff17 	ldw	r3,-4(fp)
 d011a74:	00800fc4 	movi	r2,63
 d011a78:	18800505 	stb	r2,20(r3)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 d011a7c:	e0bfff17 	ldw	r2,-4(fp)
 d011a80:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 d011a84:	00c34174 	movhi	r3,3333
 d011a88:	18ca9504 	addi	r3,r3,10836
 d011a8c:	008341b4 	movhi	r2,3334
 d011a90:	10a59b04 	addi	r2,r2,-27028
 d011a94:	18800015 	stw	r2,0(r3)
#endif
}
 d011a98:	e037883a 	mov	sp,fp
 d011a9c:	dfc00117 	ldw	ra,4(sp)
 d011aa0:	df000017 	ldw	fp,0(sp)
 d011aa4:	dec00204 	addi	sp,sp,8
 d011aa8:	f800283a 	ret

0d011aac <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 d011aac:	defff704 	addi	sp,sp,-36
 d011ab0:	df000815 	stw	fp,32(sp)
 d011ab4:	df000804 	addi	fp,sp,32
 d011ab8:	e13ffd15 	stw	r4,-12(fp)
 d011abc:	e17ffe15 	stw	r5,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d011ac0:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d011ac4:	e0bffe17 	ldw	r2,-8(fp)
 d011ac8:	1004c03a 	cmpne	r2,r2,zero
 d011acc:	1000021e 	bne	r2,zero,d011ad8 <OSQAccept+0x2c>
        return ((void *)0);
 d011ad0:	e03fff15 	stw	zero,-4(fp)
 d011ad4:	00004506 	br	d011bec <OSQAccept+0x140>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 d011ad8:	e0bffd17 	ldw	r2,-12(fp)
 d011adc:	1004c03a 	cmpne	r2,r2,zero
 d011ae0:	1000051e 	bne	r2,zero,d011af8 <OSQAccept+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 d011ae4:	e0fffe17 	ldw	r3,-8(fp)
 d011ae8:	00800104 	movi	r2,4
 d011aec:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d011af0:	e03fff15 	stw	zero,-4(fp)
 d011af4:	00003d06 	br	d011bec <OSQAccept+0x140>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 d011af8:	e0bffd17 	ldw	r2,-12(fp)
 d011afc:	10800003 	ldbu	r2,0(r2)
 d011b00:	10803fcc 	andi	r2,r2,255
 d011b04:	108000a0 	cmpeqi	r2,r2,2
 d011b08:	1000051e 	bne	r2,zero,d011b20 <OSQAccept+0x74>
        *perr = OS_ERR_EVENT_TYPE;
 d011b0c:	e0fffe17 	ldw	r3,-8(fp)
 d011b10:	00800044 	movi	r2,1
 d011b14:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d011b18:	e03fff15 	stw	zero,-4(fp)
 d011b1c:	00003306 	br	d011bec <OSQAccept+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011b20:	0005303a 	rdctl	r2,status
 d011b24:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011b28:	e0fff917 	ldw	r3,-28(fp)
 d011b2c:	00bfff84 	movi	r2,-2
 d011b30:	1884703a 	and	r2,r3,r2
 d011b34:	1001703a 	wrctl	status,r2
  
  return context;
 d011b38:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d011b3c:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 d011b40:	e0bffd17 	ldw	r2,-12(fp)
 d011b44:	10800117 	ldw	r2,4(r2)
 d011b48:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 d011b4c:	e0bffb17 	ldw	r2,-20(fp)
 d011b50:	1080058b 	ldhu	r2,22(r2)
 d011b54:	10bfffcc 	andi	r2,r2,65535
 d011b58:	1005003a 	cmpeq	r2,r2,zero
 d011b5c:	1000191e 	bne	r2,zero,d011bc4 <OSQAccept+0x118>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 d011b60:	e0bffb17 	ldw	r2,-20(fp)
 d011b64:	10c00417 	ldw	r3,16(r2)
 d011b68:	18800017 	ldw	r2,0(r3)
 d011b6c:	e0bffc15 	stw	r2,-16(fp)
 d011b70:	18c00104 	addi	r3,r3,4
 d011b74:	e0bffb17 	ldw	r2,-20(fp)
 d011b78:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 d011b7c:	e0bffb17 	ldw	r2,-20(fp)
 d011b80:	1080058b 	ldhu	r2,22(r2)
 d011b84:	10bfffc4 	addi	r2,r2,-1
 d011b88:	1007883a 	mov	r3,r2
 d011b8c:	e0bffb17 	ldw	r2,-20(fp)
 d011b90:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 d011b94:	e0bffb17 	ldw	r2,-20(fp)
 d011b98:	10c00417 	ldw	r3,16(r2)
 d011b9c:	e0bffb17 	ldw	r2,-20(fp)
 d011ba0:	10800217 	ldw	r2,8(r2)
 d011ba4:	1880041e 	bne	r3,r2,d011bb8 <OSQAccept+0x10c>
            pq->OSQOut = pq->OSQStart;
 d011ba8:	e0bffb17 	ldw	r2,-20(fp)
 d011bac:	10c00117 	ldw	r3,4(r2)
 d011bb0:	e0bffb17 	ldw	r2,-20(fp)
 d011bb4:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 d011bb8:	e0bffe17 	ldw	r2,-8(fp)
 d011bbc:	10000005 	stb	zero,0(r2)
 d011bc0:	00000406 	br	d011bd4 <OSQAccept+0x128>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 d011bc4:	e0fffe17 	ldw	r3,-8(fp)
 d011bc8:	008007c4 	movi	r2,31
 d011bcc:	18800005 	stb	r2,0(r3)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 d011bd0:	e03ffc15 	stw	zero,-16(fp)
 d011bd4:	e0bffa17 	ldw	r2,-24(fp)
 d011bd8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011bdc:	e0bff817 	ldw	r2,-32(fp)
 d011be0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 d011be4:	e0bffc17 	ldw	r2,-16(fp)
 d011be8:	e0bfff15 	stw	r2,-4(fp)
 d011bec:	e0bfff17 	ldw	r2,-4(fp)
}
 d011bf0:	e037883a 	mov	sp,fp
 d011bf4:	df000017 	ldw	fp,0(sp)
 d011bf8:	dec00104 	addi	sp,sp,4
 d011bfc:	f800283a 	ret

0d011c00 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 d011c00:	defff304 	addi	sp,sp,-52
 d011c04:	dfc00c15 	stw	ra,48(sp)
 d011c08:	df000b15 	stw	fp,44(sp)
 d011c0c:	df000b04 	addi	fp,sp,44
 d011c10:	e13ffd15 	stw	r4,-12(fp)
 d011c14:	e17ffe0d 	sth	r5,-8(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d011c18:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 d011c1c:	00834174 	movhi	r2,3333
 d011c20:	108a9a04 	addi	r2,r2,10856
 d011c24:	10800003 	ldbu	r2,0(r2)
 d011c28:	10803fcc 	andi	r2,r2,255
 d011c2c:	1005003a 	cmpeq	r2,r2,zero
 d011c30:	1000021e 	bne	r2,zero,d011c3c <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 d011c34:	e03fff15 	stw	zero,-4(fp)
 d011c38:	00007006 	br	d011dfc <OSQCreate+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011c3c:	0005303a 	rdctl	r2,status
 d011c40:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011c44:	e0fff917 	ldw	r3,-28(fp)
 d011c48:	00bfff84 	movi	r2,-2
 d011c4c:	1884703a 	and	r2,r3,r2
 d011c50:	1001703a 	wrctl	status,r2
  
  return context;
 d011c54:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d011c58:	e0bffa15 	stw	r2,-24(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 d011c5c:	00834174 	movhi	r2,3333
 d011c60:	108a9904 	addi	r2,r2,10852
 d011c64:	10800017 	ldw	r2,0(r2)
 d011c68:	e0bffc15 	stw	r2,-16(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 d011c6c:	00834174 	movhi	r2,3333
 d011c70:	108a9904 	addi	r2,r2,10852
 d011c74:	10800017 	ldw	r2,0(r2)
 d011c78:	1005003a 	cmpeq	r2,r2,zero
 d011c7c:	1000081e 	bne	r2,zero,d011ca0 <OSQCreate+0xa0>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 d011c80:	00834174 	movhi	r2,3333
 d011c84:	108a9904 	addi	r2,r2,10852
 d011c88:	10800017 	ldw	r2,0(r2)
 d011c8c:	10800117 	ldw	r2,4(r2)
 d011c90:	1007883a 	mov	r3,r2
 d011c94:	00834174 	movhi	r2,3333
 d011c98:	108a9904 	addi	r2,r2,10852
 d011c9c:	10c00015 	stw	r3,0(r2)
 d011ca0:	e0bffa17 	ldw	r2,-24(fp)
 d011ca4:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011ca8:	e0bff817 	ldw	r2,-32(fp)
 d011cac:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 d011cb0:	e0bffc17 	ldw	r2,-16(fp)
 d011cb4:	1005003a 	cmpeq	r2,r2,zero
 d011cb8:	10004e1e 	bne	r2,zero,d011df4 <OSQCreate+0x1f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011cbc:	0005303a 	rdctl	r2,status
 d011cc0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011cc4:	e0fff717 	ldw	r3,-36(fp)
 d011cc8:	00bfff84 	movi	r2,-2
 d011ccc:	1884703a 	and	r2,r3,r2
 d011cd0:	1001703a 	wrctl	status,r2
  
  return context;
 d011cd4:	e0bff717 	ldw	r2,-36(fp)
        OS_ENTER_CRITICAL();
 d011cd8:	e0bffa15 	stw	r2,-24(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 d011cdc:	00834174 	movhi	r2,3333
 d011ce0:	108a9704 	addi	r2,r2,10844
 d011ce4:	10800017 	ldw	r2,0(r2)
 d011ce8:	e0bffb15 	stw	r2,-20(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 d011cec:	e0bffb17 	ldw	r2,-20(fp)
 d011cf0:	1005003a 	cmpeq	r2,r2,zero
 d011cf4:	1000311e 	bne	r2,zero,d011dbc <OSQCreate+0x1bc>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 d011cf8:	00834174 	movhi	r2,3333
 d011cfc:	108a9704 	addi	r2,r2,10844
 d011d00:	10800017 	ldw	r2,0(r2)
 d011d04:	10c00017 	ldw	r3,0(r2)
 d011d08:	00834174 	movhi	r2,3333
 d011d0c:	108a9704 	addi	r2,r2,10844
 d011d10:	10c00015 	stw	r3,0(r2)
 d011d14:	e0bffa17 	ldw	r2,-24(fp)
 d011d18:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011d1c:	e0bff617 	ldw	r2,-40(fp)
 d011d20:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 d011d24:	e0fffb17 	ldw	r3,-20(fp)
 d011d28:	e0bffd17 	ldw	r2,-12(fp)
 d011d2c:	18800115 	stw	r2,4(r3)
            pq->OSQEnd             = &start[size];
 d011d30:	e0bffe0b 	ldhu	r2,-8(fp)
 d011d34:	1085883a 	add	r2,r2,r2
 d011d38:	1085883a 	add	r2,r2,r2
 d011d3c:	1007883a 	mov	r3,r2
 d011d40:	e0bffd17 	ldw	r2,-12(fp)
 d011d44:	1887883a 	add	r3,r3,r2
 d011d48:	e0bffb17 	ldw	r2,-20(fp)
 d011d4c:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 d011d50:	e0fffb17 	ldw	r3,-20(fp)
 d011d54:	e0bffd17 	ldw	r2,-12(fp)
 d011d58:	18800315 	stw	r2,12(r3)
            pq->OSQOut             = start;
 d011d5c:	e0fffb17 	ldw	r3,-20(fp)
 d011d60:	e0bffd17 	ldw	r2,-12(fp)
 d011d64:	18800415 	stw	r2,16(r3)
            pq->OSQSize            = size;
 d011d68:	e0fffb17 	ldw	r3,-20(fp)
 d011d6c:	e0bffe0b 	ldhu	r2,-8(fp)
 d011d70:	1880050d 	sth	r2,20(r3)
            pq->OSQEntries         = 0;
 d011d74:	e0bffb17 	ldw	r2,-20(fp)
 d011d78:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 d011d7c:	e0fffc17 	ldw	r3,-16(fp)
 d011d80:	00800084 	movi	r2,2
 d011d84:	18800005 	stb	r2,0(r3)
            pevent->OSEventCnt     = 0;
 d011d88:	e0bffc17 	ldw	r2,-16(fp)
 d011d8c:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 d011d90:	e0fffc17 	ldw	r3,-16(fp)
 d011d94:	e0bffb17 	ldw	r2,-20(fp)
 d011d98:	18800115 	stw	r2,4(r3)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 d011d9c:	e0fffc17 	ldw	r3,-16(fp)
 d011da0:	00800fc4 	movi	r2,63
 d011da4:	18800385 	stb	r2,14(r3)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 d011da8:	e0bffc17 	ldw	r2,-16(fp)
 d011dac:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 d011db0:	e13ffc17 	ldw	r4,-16(fp)
 d011db4:	d00ec680 	call	d00ec68 <OS_EventWaitListInit>
 d011db8:	00000e06 	br	d011df4 <OSQCreate+0x1f4>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 d011dbc:	00834174 	movhi	r2,3333
 d011dc0:	108a9904 	addi	r2,r2,10852
 d011dc4:	10c00017 	ldw	r3,0(r2)
 d011dc8:	e0bffc17 	ldw	r2,-16(fp)
 d011dcc:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 d011dd0:	00c34174 	movhi	r3,3333
 d011dd4:	18ca9904 	addi	r3,r3,10852
 d011dd8:	e0bffc17 	ldw	r2,-16(fp)
 d011ddc:	18800015 	stw	r2,0(r3)
 d011de0:	e0bffa17 	ldw	r2,-24(fp)
 d011de4:	e0bff515 	stw	r2,-44(fp)
 d011de8:	e0bff517 	ldw	r2,-44(fp)
 d011dec:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 d011df0:	e03ffc15 	stw	zero,-16(fp)
        }
    }
    return (pevent);
 d011df4:	e0bffc17 	ldw	r2,-16(fp)
 d011df8:	e0bfff15 	stw	r2,-4(fp)
 d011dfc:	e0bfff17 	ldw	r2,-4(fp)
}
 d011e00:	e037883a 	mov	sp,fp
 d011e04:	dfc00117 	ldw	ra,4(sp)
 d011e08:	df000017 	ldw	fp,0(sp)
 d011e0c:	dec00204 	addi	sp,sp,8
 d011e10:	f800283a 	ret

0d011e14 <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 d011e14:	defff004 	addi	sp,sp,-64
 d011e18:	dfc00f15 	stw	ra,60(sp)
 d011e1c:	df000e15 	stw	fp,56(sp)
 d011e20:	df000e04 	addi	fp,sp,56
 d011e24:	e13ffb15 	stw	r4,-20(fp)
 d011e28:	e1bffd15 	stw	r6,-12(fp)
 d011e2c:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d011e30:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d011e34:	e0bffd17 	ldw	r2,-12(fp)
 d011e38:	1004c03a 	cmpne	r2,r2,zero
 d011e3c:	1000031e 	bne	r2,zero,d011e4c <OSQDel+0x38>
        return (pevent);
 d011e40:	e0bffb17 	ldw	r2,-20(fp)
 d011e44:	e0bfff15 	stw	r2,-4(fp)
 d011e48:	0000ac06 	br	d0120fc <OSQDel+0x2e8>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 d011e4c:	e0bffb17 	ldw	r2,-20(fp)
 d011e50:	1004c03a 	cmpne	r2,r2,zero
 d011e54:	1000061e 	bne	r2,zero,d011e70 <OSQDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 d011e58:	e0fffd17 	ldw	r3,-12(fp)
 d011e5c:	00800104 	movi	r2,4
 d011e60:	18800005 	stb	r2,0(r3)
        return (pevent);
 d011e64:	e0fffb17 	ldw	r3,-20(fp)
 d011e68:	e0ffff15 	stw	r3,-4(fp)
 d011e6c:	0000a306 	br	d0120fc <OSQDel+0x2e8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 d011e70:	e0bffb17 	ldw	r2,-20(fp)
 d011e74:	10800003 	ldbu	r2,0(r2)
 d011e78:	10803fcc 	andi	r2,r2,255
 d011e7c:	108000a0 	cmpeqi	r2,r2,2
 d011e80:	1000061e 	bne	r2,zero,d011e9c <OSQDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 d011e84:	e0fffd17 	ldw	r3,-12(fp)
 d011e88:	00800044 	movi	r2,1
 d011e8c:	18800005 	stb	r2,0(r3)
        return (pevent);
 d011e90:	e0bffb17 	ldw	r2,-20(fp)
 d011e94:	e0bfff15 	stw	r2,-4(fp)
 d011e98:	00009806 	br	d0120fc <OSQDel+0x2e8>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d011e9c:	00834174 	movhi	r2,3333
 d011ea0:	108a9a04 	addi	r2,r2,10856
 d011ea4:	10800003 	ldbu	r2,0(r2)
 d011ea8:	10803fcc 	andi	r2,r2,255
 d011eac:	1005003a 	cmpeq	r2,r2,zero
 d011eb0:	1000061e 	bne	r2,zero,d011ecc <OSQDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 d011eb4:	e0fffd17 	ldw	r3,-12(fp)
 d011eb8:	008003c4 	movi	r2,15
 d011ebc:	18800005 	stb	r2,0(r3)
        return (pevent);
 d011ec0:	e0fffb17 	ldw	r3,-20(fp)
 d011ec4:	e0ffff15 	stw	r3,-4(fp)
 d011ec8:	00008c06 	br	d0120fc <OSQDel+0x2e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d011ecc:	0005303a 	rdctl	r2,status
 d011ed0:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d011ed4:	e0fff617 	ldw	r3,-40(fp)
 d011ed8:	00bfff84 	movi	r2,-2
 d011edc:	1884703a 	and	r2,r3,r2
 d011ee0:	1001703a 	wrctl	status,r2
  
  return context;
 d011ee4:	e0bff617 	ldw	r2,-40(fp)
    }
    OS_ENTER_CRITICAL();
 d011ee8:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 d011eec:	e0bffb17 	ldw	r2,-20(fp)
 d011ef0:	10800283 	ldbu	r2,10(r2)
 d011ef4:	10803fcc 	andi	r2,r2,255
 d011ef8:	1005003a 	cmpeq	r2,r2,zero
 d011efc:	1000031e 	bne	r2,zero,d011f0c <OSQDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 d011f00:	00800044 	movi	r2,1
 d011f04:	e0bffa05 	stb	r2,-24(fp)
 d011f08:	00000106 	br	d011f10 <OSQDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 d011f0c:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 d011f10:	e0bffc03 	ldbu	r2,-16(fp)
 d011f14:	e0bffe15 	stw	r2,-8(fp)
 d011f18:	e0fffe17 	ldw	r3,-8(fp)
 d011f1c:	1805003a 	cmpeq	r2,r3,zero
 d011f20:	1000041e 	bne	r2,zero,d011f34 <OSQDel+0x120>
 d011f24:	e0fffe17 	ldw	r3,-8(fp)
 d011f28:	18800060 	cmpeqi	r2,r3,1
 d011f2c:	1000391e 	bne	r2,zero,d012014 <OSQDel+0x200>
 d011f30:	00006706 	br	d0120d0 <OSQDel+0x2bc>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 d011f34:	e0bffa03 	ldbu	r2,-24(fp)
 d011f38:	1004c03a 	cmpne	r2,r2,zero
 d011f3c:	1000261e 	bne	r2,zero,d011fd8 <OSQDel+0x1c4>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 d011f40:	e0fffb17 	ldw	r3,-20(fp)
 d011f44:	00800fc4 	movi	r2,63
 d011f48:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 d011f4c:	e0bffb17 	ldw	r2,-20(fp)
 d011f50:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 d011f54:	e0bffb17 	ldw	r2,-20(fp)
 d011f58:	10800117 	ldw	r2,4(r2)
 d011f5c:	e0bff815 	stw	r2,-32(fp)
                 pq->OSQPtr             = OSQFreeList;
 d011f60:	00834174 	movhi	r2,3333
 d011f64:	108a9704 	addi	r2,r2,10844
 d011f68:	10c00017 	ldw	r3,0(r2)
 d011f6c:	e0bff817 	ldw	r2,-32(fp)
 d011f70:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 d011f74:	00c34174 	movhi	r3,3333
 d011f78:	18ca9704 	addi	r3,r3,10844
 d011f7c:	e0bff817 	ldw	r2,-32(fp)
 d011f80:	18800015 	stw	r2,0(r3)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d011f84:	e0bffb17 	ldw	r2,-20(fp)
 d011f88:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 d011f8c:	00834174 	movhi	r2,3333
 d011f90:	108a9904 	addi	r2,r2,10852
 d011f94:	10c00017 	ldw	r3,0(r2)
 d011f98:	e0bffb17 	ldw	r2,-20(fp)
 d011f9c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 d011fa0:	e0bffb17 	ldw	r2,-20(fp)
 d011fa4:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 d011fa8:	00c34174 	movhi	r3,3333
 d011fac:	18ca9904 	addi	r3,r3,10852
 d011fb0:	e0bffb17 	ldw	r2,-20(fp)
 d011fb4:	18800015 	stw	r2,0(r3)
 d011fb8:	e0bff717 	ldw	r2,-36(fp)
 d011fbc:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d011fc0:	e0bff517 	ldw	r2,-44(fp)
 d011fc4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 d011fc8:	e0bffd17 	ldw	r2,-12(fp)
 d011fcc:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 d011fd0:	e03ff915 	stw	zero,-28(fp)
 d011fd4:	00004706 	br	d0120f4 <OSQDel+0x2e0>
 d011fd8:	e0bff717 	ldw	r2,-36(fp)
 d011fdc:	e0bff415 	stw	r2,-48(fp)
 d011fe0:	e0bff417 	ldw	r2,-48(fp)
 d011fe4:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 d011fe8:	e0fffd17 	ldw	r3,-12(fp)
 d011fec:	00801244 	movi	r2,73
 d011ff0:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 d011ff4:	e0bffb17 	ldw	r2,-20(fp)
 d011ff8:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 d011ffc:	00003d06 	br	d0120f4 <OSQDel+0x2e0>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 d012000:	e13ffb17 	ldw	r4,-20(fp)
 d012004:	000b883a 	mov	r5,zero
 d012008:	01800104 	movi	r6,4
 d01200c:	000f883a 	mov	r7,zero
 d012010:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 d012014:	e0bffb17 	ldw	r2,-20(fp)
 d012018:	10800283 	ldbu	r2,10(r2)
 d01201c:	10803fcc 	andi	r2,r2,255
 d012020:	1004c03a 	cmpne	r2,r2,zero
 d012024:	103ff61e 	bne	r2,zero,d012000 <OSQDel+0x1ec>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 d012028:	e0fffb17 	ldw	r3,-20(fp)
 d01202c:	00800fc4 	movi	r2,63
 d012030:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 d012034:	e0bffb17 	ldw	r2,-20(fp)
 d012038:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 d01203c:	e0bffb17 	ldw	r2,-20(fp)
 d012040:	10800117 	ldw	r2,4(r2)
 d012044:	e0bff815 	stw	r2,-32(fp)
             pq->OSQPtr             = OSQFreeList;
 d012048:	00834174 	movhi	r2,3333
 d01204c:	108a9704 	addi	r2,r2,10844
 d012050:	10c00017 	ldw	r3,0(r2)
 d012054:	e0bff817 	ldw	r2,-32(fp)
 d012058:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 d01205c:	00c34174 	movhi	r3,3333
 d012060:	18ca9704 	addi	r3,r3,10844
 d012064:	e0bff817 	ldw	r2,-32(fp)
 d012068:	18800015 	stw	r2,0(r3)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d01206c:	e0bffb17 	ldw	r2,-20(fp)
 d012070:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 d012074:	00834174 	movhi	r2,3333
 d012078:	108a9904 	addi	r2,r2,10852
 d01207c:	10c00017 	ldw	r3,0(r2)
 d012080:	e0bffb17 	ldw	r2,-20(fp)
 d012084:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 d012088:	e0bffb17 	ldw	r2,-20(fp)
 d01208c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 d012090:	00c34174 	movhi	r3,3333
 d012094:	18ca9904 	addi	r3,r3,10852
 d012098:	e0bffb17 	ldw	r2,-20(fp)
 d01209c:	18800015 	stw	r2,0(r3)
 d0120a0:	e0bff717 	ldw	r2,-36(fp)
 d0120a4:	e0bff315 	stw	r2,-52(fp)
 d0120a8:	e0bff317 	ldw	r2,-52(fp)
 d0120ac:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 d0120b0:	e0bffa03 	ldbu	r2,-24(fp)
 d0120b4:	10800058 	cmpnei	r2,r2,1
 d0120b8:	1000011e 	bne	r2,zero,d0120c0 <OSQDel+0x2ac>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 d0120bc:	d00f0f40 	call	d00f0f4 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 d0120c0:	e0bffd17 	ldw	r2,-12(fp)
 d0120c4:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 d0120c8:	e03ff915 	stw	zero,-28(fp)
             break;
 d0120cc:	00000906 	br	d0120f4 <OSQDel+0x2e0>
 d0120d0:	e0bff717 	ldw	r2,-36(fp)
 d0120d4:	e0bff215 	stw	r2,-56(fp)
 d0120d8:	e0bff217 	ldw	r2,-56(fp)
 d0120dc:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 d0120e0:	e0fffd17 	ldw	r3,-12(fp)
 d0120e4:	008001c4 	movi	r2,7
 d0120e8:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 d0120ec:	e0bffb17 	ldw	r2,-20(fp)
 d0120f0:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 d0120f4:	e0bff917 	ldw	r2,-28(fp)
 d0120f8:	e0bfff15 	stw	r2,-4(fp)
 d0120fc:	e0bfff17 	ldw	r2,-4(fp)
}
 d012100:	e037883a 	mov	sp,fp
 d012104:	dfc00117 	ldw	ra,4(sp)
 d012108:	df000017 	ldw	fp,0(sp)
 d01210c:	dec00204 	addi	sp,sp,8
 d012110:	f800283a 	ret

0d012114 <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 d012114:	defff904 	addi	sp,sp,-28
 d012118:	df000615 	stw	fp,24(sp)
 d01211c:	df000604 	addi	fp,sp,24
 d012120:	e13ffe15 	stw	r4,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d012124:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d012128:	e0bffe17 	ldw	r2,-8(fp)
 d01212c:	1004c03a 	cmpne	r2,r2,zero
 d012130:	1000031e 	bne	r2,zero,d012140 <OSQFlush+0x2c>
        return (OS_ERR_PEVENT_NULL);
 d012134:	00800104 	movi	r2,4
 d012138:	e0bfff15 	stw	r2,-4(fp)
 d01213c:	00002206 	br	d0121c8 <OSQFlush+0xb4>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 d012140:	e0bffe17 	ldw	r2,-8(fp)
 d012144:	10800003 	ldbu	r2,0(r2)
 d012148:	10803fcc 	andi	r2,r2,255
 d01214c:	108000a0 	cmpeqi	r2,r2,2
 d012150:	1000031e 	bne	r2,zero,d012160 <OSQFlush+0x4c>
        return (OS_ERR_EVENT_TYPE);
 d012154:	00800044 	movi	r2,1
 d012158:	e0bfff15 	stw	r2,-4(fp)
 d01215c:	00001a06 	br	d0121c8 <OSQFlush+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d012160:	0005303a 	rdctl	r2,status
 d012164:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012168:	e0fffb17 	ldw	r3,-20(fp)
 d01216c:	00bfff84 	movi	r2,-2
 d012170:	1884703a 	and	r2,r3,r2
 d012174:	1001703a 	wrctl	status,r2
  
  return context;
 d012178:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d01217c:	e0bffc15 	stw	r2,-16(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 d012180:	e0bffe17 	ldw	r2,-8(fp)
 d012184:	10800117 	ldw	r2,4(r2)
 d012188:	e0bffd15 	stw	r2,-12(fp)
    pq->OSQIn      = pq->OSQStart;
 d01218c:	e0bffd17 	ldw	r2,-12(fp)
 d012190:	10c00117 	ldw	r3,4(r2)
 d012194:	e0bffd17 	ldw	r2,-12(fp)
 d012198:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 d01219c:	e0bffd17 	ldw	r2,-12(fp)
 d0121a0:	10c00117 	ldw	r3,4(r2)
 d0121a4:	e0bffd17 	ldw	r2,-12(fp)
 d0121a8:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 d0121ac:	e0bffd17 	ldw	r2,-12(fp)
 d0121b0:	1000058d 	sth	zero,22(r2)
 d0121b4:	e0bffc17 	ldw	r2,-16(fp)
 d0121b8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0121bc:	e0bffa17 	ldw	r2,-24(fp)
 d0121c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d0121c4:	e03fff15 	stw	zero,-4(fp)
 d0121c8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0121cc:	e037883a 	mov	sp,fp
 d0121d0:	df000017 	ldw	fp,0(sp)
 d0121d4:	dec00104 	addi	sp,sp,4
 d0121d8:	f800283a 	ret

0d0121dc <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 d0121dc:	defff104 	addi	sp,sp,-60
 d0121e0:	dfc00e15 	stw	ra,56(sp)
 d0121e4:	df000d15 	stw	fp,52(sp)
 d0121e8:	df000d04 	addi	fp,sp,52
 d0121ec:	e13ffb15 	stw	r4,-20(fp)
 d0121f0:	e1bffd15 	stw	r6,-12(fp)
 d0121f4:	e17ffc0d 	sth	r5,-16(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0121f8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 d0121fc:	e0bffd17 	ldw	r2,-12(fp)
 d012200:	1004c03a 	cmpne	r2,r2,zero
 d012204:	1000021e 	bne	r2,zero,d012210 <OSQPend+0x34>
        return ((void *)0);
 d012208:	e03fff15 	stw	zero,-4(fp)
 d01220c:	0000b506 	br	d0124e4 <OSQPend+0x308>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 d012210:	e0bffb17 	ldw	r2,-20(fp)
 d012214:	1004c03a 	cmpne	r2,r2,zero
 d012218:	1000051e 	bne	r2,zero,d012230 <OSQPend+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 d01221c:	e0fffd17 	ldw	r3,-12(fp)
 d012220:	00800104 	movi	r2,4
 d012224:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d012228:	e03fff15 	stw	zero,-4(fp)
 d01222c:	0000ad06 	br	d0124e4 <OSQPend+0x308>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 d012230:	e0bffb17 	ldw	r2,-20(fp)
 d012234:	10800003 	ldbu	r2,0(r2)
 d012238:	10803fcc 	andi	r2,r2,255
 d01223c:	108000a0 	cmpeqi	r2,r2,2
 d012240:	1000051e 	bne	r2,zero,d012258 <OSQPend+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 d012244:	e0fffd17 	ldw	r3,-12(fp)
 d012248:	00800044 	movi	r2,1
 d01224c:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d012250:	e03fff15 	stw	zero,-4(fp)
 d012254:	0000a306 	br	d0124e4 <OSQPend+0x308>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 d012258:	00834174 	movhi	r2,3333
 d01225c:	108a9a04 	addi	r2,r2,10856
 d012260:	10800003 	ldbu	r2,0(r2)
 d012264:	10803fcc 	andi	r2,r2,255
 d012268:	1005003a 	cmpeq	r2,r2,zero
 d01226c:	1000051e 	bne	r2,zero,d012284 <OSQPend+0xa8>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 d012270:	e0fffd17 	ldw	r3,-12(fp)
 d012274:	00800084 	movi	r2,2
 d012278:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d01227c:	e03fff15 	stw	zero,-4(fp)
 d012280:	00009806 	br	d0124e4 <OSQPend+0x308>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 d012284:	00834174 	movhi	r2,3333
 d012288:	108a8c04 	addi	r2,r2,10800
 d01228c:	10800003 	ldbu	r2,0(r2)
 d012290:	10803fcc 	andi	r2,r2,255
 d012294:	1005003a 	cmpeq	r2,r2,zero
 d012298:	1000051e 	bne	r2,zero,d0122b0 <OSQPend+0xd4>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 d01229c:	e0fffd17 	ldw	r3,-12(fp)
 d0122a0:	00800344 	movi	r2,13
 d0122a4:	18800005 	stb	r2,0(r3)
        return ((void *)0);
 d0122a8:	e03fff15 	stw	zero,-4(fp)
 d0122ac:	00008d06 	br	d0124e4 <OSQPend+0x308>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0122b0:	0005303a 	rdctl	r2,status
 d0122b4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0122b8:	e0fff717 	ldw	r3,-36(fp)
 d0122bc:	00bfff84 	movi	r2,-2
 d0122c0:	1884703a 	and	r2,r3,r2
 d0122c4:	1001703a 	wrctl	status,r2
  
  return context;
 d0122c8:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 d0122cc:	e0bff815 	stw	r2,-32(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 d0122d0:	e0bffb17 	ldw	r2,-20(fp)
 d0122d4:	10800117 	ldw	r2,4(r2)
 d0122d8:	e0bff915 	stw	r2,-28(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 d0122dc:	e0bff917 	ldw	r2,-28(fp)
 d0122e0:	1080058b 	ldhu	r2,22(r2)
 d0122e4:	10bfffcc 	andi	r2,r2,65535
 d0122e8:	1005003a 	cmpeq	r2,r2,zero
 d0122ec:	10001f1e 	bne	r2,zero,d01236c <OSQPend+0x190>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 d0122f0:	e0bff917 	ldw	r2,-28(fp)
 d0122f4:	10c00417 	ldw	r3,16(r2)
 d0122f8:	18800017 	ldw	r2,0(r3)
 d0122fc:	e0bffa15 	stw	r2,-24(fp)
 d012300:	18c00104 	addi	r3,r3,4
 d012304:	e0bff917 	ldw	r2,-28(fp)
 d012308:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 d01230c:	e0bff917 	ldw	r2,-28(fp)
 d012310:	1080058b 	ldhu	r2,22(r2)
 d012314:	10bfffc4 	addi	r2,r2,-1
 d012318:	1007883a 	mov	r3,r2
 d01231c:	e0bff917 	ldw	r2,-28(fp)
 d012320:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 d012324:	e0bff917 	ldw	r2,-28(fp)
 d012328:	10c00417 	ldw	r3,16(r2)
 d01232c:	e0bff917 	ldw	r2,-28(fp)
 d012330:	10800217 	ldw	r2,8(r2)
 d012334:	1880041e 	bne	r3,r2,d012348 <OSQPend+0x16c>
            pq->OSQOut = pq->OSQStart;
 d012338:	e0bff917 	ldw	r2,-28(fp)
 d01233c:	10c00117 	ldw	r3,4(r2)
 d012340:	e0bff917 	ldw	r2,-28(fp)
 d012344:	10c00415 	stw	r3,16(r2)
 d012348:	e0bff817 	ldw	r2,-32(fp)
 d01234c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012350:	e0bff617 	ldw	r2,-40(fp)
 d012354:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 d012358:	e0bffd17 	ldw	r2,-12(fp)
 d01235c:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 d012360:	e0bffa17 	ldw	r2,-24(fp)
 d012364:	e0bfff15 	stw	r2,-4(fp)
 d012368:	00005e06 	br	d0124e4 <OSQPend+0x308>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 d01236c:	00834174 	movhi	r2,3333
 d012370:	108a9b04 	addi	r2,r2,10860
 d012374:	10c00017 	ldw	r3,0(r2)
 d012378:	00834174 	movhi	r2,3333
 d01237c:	108a9b04 	addi	r2,r2,10860
 d012380:	10800017 	ldw	r2,0(r2)
 d012384:	10800c03 	ldbu	r2,48(r2)
 d012388:	10800114 	ori	r2,r2,4
 d01238c:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 d012390:	00834174 	movhi	r2,3333
 d012394:	108a9b04 	addi	r2,r2,10860
 d012398:	10800017 	ldw	r2,0(r2)
 d01239c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 d0123a0:	00834174 	movhi	r2,3333
 d0123a4:	108a9b04 	addi	r2,r2,10860
 d0123a8:	10c00017 	ldw	r3,0(r2)
 d0123ac:	e0bffc0b 	ldhu	r2,-16(fp)
 d0123b0:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 d0123b4:	e13ffb17 	ldw	r4,-20(fp)
 d0123b8:	d00e8480 	call	d00e848 <OS_EventTaskWait>
 d0123bc:	e0bff817 	ldw	r2,-32(fp)
 d0123c0:	e0bff515 	stw	r2,-44(fp)
 d0123c4:	e0bff517 	ldw	r2,-44(fp)
 d0123c8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 d0123cc:	d00f0f40 	call	d00f0f4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0123d0:	0005303a 	rdctl	r2,status
 d0123d4:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0123d8:	e0fff417 	ldw	r3,-48(fp)
 d0123dc:	00bfff84 	movi	r2,-2
 d0123e0:	1884703a 	and	r2,r3,r2
 d0123e4:	1001703a 	wrctl	status,r2
  
  return context;
 d0123e8:	e0bff417 	ldw	r2,-48(fp)
    OS_ENTER_CRITICAL();
 d0123ec:	e0bff815 	stw	r2,-32(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 d0123f0:	00834174 	movhi	r2,3333
 d0123f4:	108a9b04 	addi	r2,r2,10860
 d0123f8:	10800017 	ldw	r2,0(r2)
 d0123fc:	10800c43 	ldbu	r2,49(r2)
 d012400:	10803fcc 	andi	r2,r2,255
 d012404:	e0bffe15 	stw	r2,-8(fp)
 d012408:	e0fffe17 	ldw	r3,-8(fp)
 d01240c:	1805003a 	cmpeq	r2,r3,zero
 d012410:	1000041e 	bne	r2,zero,d012424 <OSQPend+0x248>
 d012414:	e0fffe17 	ldw	r3,-8(fp)
 d012418:	188000a0 	cmpeqi	r2,r3,2
 d01241c:	1000091e 	bne	r2,zero,d012444 <OSQPend+0x268>
 d012420:	00000d06 	br	d012458 <OSQPend+0x27c>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 d012424:	00834174 	movhi	r2,3333
 d012428:	108a9b04 	addi	r2,r2,10860
 d01242c:	10800017 	ldw	r2,0(r2)
 d012430:	10800917 	ldw	r2,36(r2)
 d012434:	e0bffa15 	stw	r2,-24(fp)
            *perr =  OS_ERR_NONE;
 d012438:	e0bffd17 	ldw	r2,-12(fp)
 d01243c:	10000005 	stb	zero,0(r2)
             break;
 d012440:	00000e06 	br	d01247c <OSQPend+0x2a0>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 d012444:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 d012448:	e0fffd17 	ldw	r3,-12(fp)
 d01244c:	00800384 	movi	r2,14
 d012450:	18800005 	stb	r2,0(r3)
             break;
 d012454:	00000906 	br	d01247c <OSQPend+0x2a0>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 d012458:	00834174 	movhi	r2,3333
 d01245c:	108a9b04 	addi	r2,r2,10860
 d012460:	11000017 	ldw	r4,0(r2)
 d012464:	e17ffb17 	ldw	r5,-20(fp)
 d012468:	d00eaac0 	call	d00eaac <OS_EventTaskRemove>
             pmsg = (void *)0;
 d01246c:	e03ffa15 	stw	zero,-24(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 d012470:	e0fffd17 	ldw	r3,-12(fp)
 d012474:	00800284 	movi	r2,10
 d012478:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 d01247c:	00834174 	movhi	r2,3333
 d012480:	108a9b04 	addi	r2,r2,10860
 d012484:	10800017 	ldw	r2,0(r2)
 d012488:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 d01248c:	00834174 	movhi	r2,3333
 d012490:	108a9b04 	addi	r2,r2,10860
 d012494:	10800017 	ldw	r2,0(r2)
 d012498:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 d01249c:	00834174 	movhi	r2,3333
 d0124a0:	108a9b04 	addi	r2,r2,10860
 d0124a4:	10800017 	ldw	r2,0(r2)
 d0124a8:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 d0124ac:	00834174 	movhi	r2,3333
 d0124b0:	108a9b04 	addi	r2,r2,10860
 d0124b4:	10800017 	ldw	r2,0(r2)
 d0124b8:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 d0124bc:	00834174 	movhi	r2,3333
 d0124c0:	108a9b04 	addi	r2,r2,10860
 d0124c4:	10800017 	ldw	r2,0(r2)
 d0124c8:	10000915 	stw	zero,36(r2)
 d0124cc:	e0bff817 	ldw	r2,-32(fp)
 d0124d0:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0124d4:	e0bff317 	ldw	r2,-52(fp)
 d0124d8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 d0124dc:	e0bffa17 	ldw	r2,-24(fp)
 d0124e0:	e0bfff15 	stw	r2,-4(fp)
 d0124e4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0124e8:	e037883a 	mov	sp,fp
 d0124ec:	dfc00117 	ldw	ra,4(sp)
 d0124f0:	df000017 	ldw	fp,0(sp)
 d0124f4:	dec00204 	addi	sp,sp,8
 d0124f8:	f800283a 	ret

0d0124fc <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 d0124fc:	defff504 	addi	sp,sp,-44
 d012500:	dfc00a15 	stw	ra,40(sp)
 d012504:	df000915 	stw	fp,36(sp)
 d012508:	df000904 	addi	fp,sp,36
 d01250c:	e13ffc15 	stw	r4,-16(fp)
 d012510:	e1bffe15 	stw	r6,-8(fp)
 d012514:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d012518:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d01251c:	e0bffe17 	ldw	r2,-8(fp)
 d012520:	1004c03a 	cmpne	r2,r2,zero
 d012524:	1000021e 	bne	r2,zero,d012530 <OSQPendAbort+0x34>
        return (0);
 d012528:	e03fff15 	stw	zero,-4(fp)
 d01252c:	00004c06 	br	d012660 <OSQPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 d012530:	e0bffc17 	ldw	r2,-16(fp)
 d012534:	1004c03a 	cmpne	r2,r2,zero
 d012538:	1000051e 	bne	r2,zero,d012550 <OSQPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 d01253c:	e0fffe17 	ldw	r3,-8(fp)
 d012540:	00800104 	movi	r2,4
 d012544:	18800005 	stb	r2,0(r3)
        return (0);
 d012548:	e03fff15 	stw	zero,-4(fp)
 d01254c:	00004406 	br	d012660 <OSQPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 d012550:	e0bffc17 	ldw	r2,-16(fp)
 d012554:	10800003 	ldbu	r2,0(r2)
 d012558:	10803fcc 	andi	r2,r2,255
 d01255c:	108000a0 	cmpeqi	r2,r2,2
 d012560:	1000051e 	bne	r2,zero,d012578 <OSQPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 d012564:	e0fffe17 	ldw	r3,-8(fp)
 d012568:	00800044 	movi	r2,1
 d01256c:	18800005 	stb	r2,0(r3)
        return (0);
 d012570:	e03fff15 	stw	zero,-4(fp)
 d012574:	00003a06 	br	d012660 <OSQPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d012578:	0005303a 	rdctl	r2,status
 d01257c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012580:	e0fff917 	ldw	r3,-28(fp)
 d012584:	00bfff84 	movi	r2,-2
 d012588:	1884703a 	and	r2,r3,r2
 d01258c:	1001703a 	wrctl	status,r2
  
  return context;
 d012590:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d012594:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 d012598:	e0bffc17 	ldw	r2,-16(fp)
 d01259c:	10800283 	ldbu	r2,10(r2)
 d0125a0:	10803fcc 	andi	r2,r2,255
 d0125a4:	1005003a 	cmpeq	r2,r2,zero
 d0125a8:	1000261e 	bne	r2,zero,d012644 <OSQPendAbort+0x148>
        nbr_tasks = 0;
 d0125ac:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 d0125b0:	e0bffd03 	ldbu	r2,-12(fp)
 d0125b4:	10800060 	cmpeqi	r2,r2,1
 d0125b8:	1000091e 	bne	r2,zero,d0125e0 <OSQPendAbort+0xe4>
 d0125bc:	00000e06 	br	d0125f8 <OSQPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 d0125c0:	e13ffc17 	ldw	r4,-16(fp)
 d0125c4:	000b883a 	mov	r5,zero
 d0125c8:	01800104 	movi	r6,4
 d0125cc:	01c00084 	movi	r7,2
 d0125d0:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
                     nbr_tasks++;
 d0125d4:	e0bffb03 	ldbu	r2,-20(fp)
 d0125d8:	10800044 	addi	r2,r2,1
 d0125dc:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 d0125e0:	e0bffc17 	ldw	r2,-16(fp)
 d0125e4:	10800283 	ldbu	r2,10(r2)
 d0125e8:	10803fcc 	andi	r2,r2,255
 d0125ec:	1004c03a 	cmpne	r2,r2,zero
 d0125f0:	103ff31e 	bne	r2,zero,d0125c0 <OSQPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 d0125f4:	00000806 	br	d012618 <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 d0125f8:	e13ffc17 	ldw	r4,-16(fp)
 d0125fc:	000b883a 	mov	r5,zero
 d012600:	01800104 	movi	r6,4
 d012604:	01c00084 	movi	r7,2
 d012608:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
                 nbr_tasks++;
 d01260c:	e0bffb03 	ldbu	r2,-20(fp)
 d012610:	10800044 	addi	r2,r2,1
 d012614:	e0bffb05 	stb	r2,-20(fp)
 d012618:	e0bffa17 	ldw	r2,-24(fp)
 d01261c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012620:	e0bff817 	ldw	r2,-32(fp)
 d012624:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 d012628:	d00f0f40 	call	d00f0f4 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 d01262c:	e0fffe17 	ldw	r3,-8(fp)
 d012630:	00800384 	movi	r2,14
 d012634:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 d012638:	e0bffb03 	ldbu	r2,-20(fp)
 d01263c:	e0bfff15 	stw	r2,-4(fp)
 d012640:	00000706 	br	d012660 <OSQPendAbort+0x164>
 d012644:	e0bffa17 	ldw	r2,-24(fp)
 d012648:	e0bff715 	stw	r2,-36(fp)
 d01264c:	e0bff717 	ldw	r2,-36(fp)
 d012650:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d012654:	e0bffe17 	ldw	r2,-8(fp)
 d012658:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 d01265c:	e03fff15 	stw	zero,-4(fp)
 d012660:	e0bfff17 	ldw	r2,-4(fp)
}
 d012664:	e037883a 	mov	sp,fp
 d012668:	dfc00117 	ldw	ra,4(sp)
 d01266c:	df000017 	ldw	fp,0(sp)
 d012670:	dec00204 	addi	sp,sp,8
 d012674:	f800283a 	ret

0d012678 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 d012678:	defff504 	addi	sp,sp,-44
 d01267c:	dfc00a15 	stw	ra,40(sp)
 d012680:	df000915 	stw	fp,36(sp)
 d012684:	df000904 	addi	fp,sp,36
 d012688:	e13ffd15 	stw	r4,-12(fp)
 d01268c:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d012690:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 d012694:	e0bffd17 	ldw	r2,-12(fp)
 d012698:	1004c03a 	cmpne	r2,r2,zero
 d01269c:	1000031e 	bne	r2,zero,d0126ac <OSQPost+0x34>
        return (OS_ERR_PEVENT_NULL);
 d0126a0:	00800104 	movi	r2,4
 d0126a4:	e0bfff15 	stw	r2,-4(fp)
 d0126a8:	00004d06 	br	d0127e0 <OSQPost+0x168>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 d0126ac:	e0bffd17 	ldw	r2,-12(fp)
 d0126b0:	10800003 	ldbu	r2,0(r2)
 d0126b4:	10803fcc 	andi	r2,r2,255
 d0126b8:	108000a0 	cmpeqi	r2,r2,2
 d0126bc:	1000031e 	bne	r2,zero,d0126cc <OSQPost+0x54>
        return (OS_ERR_EVENT_TYPE);
 d0126c0:	00800044 	movi	r2,1
 d0126c4:	e0bfff15 	stw	r2,-4(fp)
 d0126c8:	00004506 	br	d0127e0 <OSQPost+0x168>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0126cc:	0005303a 	rdctl	r2,status
 d0126d0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0126d4:	e0fffa17 	ldw	r3,-24(fp)
 d0126d8:	00bfff84 	movi	r2,-2
 d0126dc:	1884703a 	and	r2,r3,r2
 d0126e0:	1001703a 	wrctl	status,r2
  
  return context;
 d0126e4:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d0126e8:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 d0126ec:	e0bffd17 	ldw	r2,-12(fp)
 d0126f0:	10800283 	ldbu	r2,10(r2)
 d0126f4:	10803fcc 	andi	r2,r2,255
 d0126f8:	1005003a 	cmpeq	r2,r2,zero
 d0126fc:	10000c1e 	bne	r2,zero,d012730 <OSQPost+0xb8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 d012700:	e13ffd17 	ldw	r4,-12(fp)
 d012704:	e17ffe17 	ldw	r5,-8(fp)
 d012708:	01800104 	movi	r6,4
 d01270c:	000f883a 	mov	r7,zero
 d012710:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
 d012714:	e0bffb17 	ldw	r2,-20(fp)
 d012718:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01271c:	e0bff917 	ldw	r2,-28(fp)
 d012720:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 d012724:	d00f0f40 	call	d00f0f4 <OS_Sched>
        return (OS_ERR_NONE);
 d012728:	e03fff15 	stw	zero,-4(fp)
 d01272c:	00002c06 	br	d0127e0 <OSQPost+0x168>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 d012730:	e0bffd17 	ldw	r2,-12(fp)
 d012734:	10800117 	ldw	r2,4(r2)
 d012738:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 d01273c:	e0bffc17 	ldw	r2,-16(fp)
 d012740:	10c0058b 	ldhu	r3,22(r2)
 d012744:	e0bffc17 	ldw	r2,-16(fp)
 d012748:	1080050b 	ldhu	r2,20(r2)
 d01274c:	18ffffcc 	andi	r3,r3,65535
 d012750:	10bfffcc 	andi	r2,r2,65535
 d012754:	18800736 	bltu	r3,r2,d012774 <OSQPost+0xfc>
 d012758:	e0bffb17 	ldw	r2,-20(fp)
 d01275c:	e0bff815 	stw	r2,-32(fp)
 d012760:	e0bff817 	ldw	r2,-32(fp)
 d012764:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 d012768:	00800784 	movi	r2,30
 d01276c:	e0bfff15 	stw	r2,-4(fp)
 d012770:	00001b06 	br	d0127e0 <OSQPost+0x168>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 d012774:	e0bffc17 	ldw	r2,-16(fp)
 d012778:	10c00317 	ldw	r3,12(r2)
 d01277c:	e0bffe17 	ldw	r2,-8(fp)
 d012780:	18800015 	stw	r2,0(r3)
 d012784:	18c00104 	addi	r3,r3,4
 d012788:	e0bffc17 	ldw	r2,-16(fp)
 d01278c:	10c00315 	stw	r3,12(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 d012790:	e0bffc17 	ldw	r2,-16(fp)
 d012794:	1080058b 	ldhu	r2,22(r2)
 d012798:	10800044 	addi	r2,r2,1
 d01279c:	1007883a 	mov	r3,r2
 d0127a0:	e0bffc17 	ldw	r2,-16(fp)
 d0127a4:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 d0127a8:	e0bffc17 	ldw	r2,-16(fp)
 d0127ac:	10c00317 	ldw	r3,12(r2)
 d0127b0:	e0bffc17 	ldw	r2,-16(fp)
 d0127b4:	10800217 	ldw	r2,8(r2)
 d0127b8:	1880041e 	bne	r3,r2,d0127cc <OSQPost+0x154>
        pq->OSQIn = pq->OSQStart;
 d0127bc:	e0bffc17 	ldw	r2,-16(fp)
 d0127c0:	10c00117 	ldw	r3,4(r2)
 d0127c4:	e0bffc17 	ldw	r2,-16(fp)
 d0127c8:	10c00315 	stw	r3,12(r2)
 d0127cc:	e0bffb17 	ldw	r2,-20(fp)
 d0127d0:	e0bff715 	stw	r2,-36(fp)
 d0127d4:	e0bff717 	ldw	r2,-36(fp)
 d0127d8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d0127dc:	e03fff15 	stw	zero,-4(fp)
 d0127e0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0127e4:	e037883a 	mov	sp,fp
 d0127e8:	dfc00117 	ldw	ra,4(sp)
 d0127ec:	df000017 	ldw	fp,0(sp)
 d0127f0:	dec00204 	addi	sp,sp,8
 d0127f4:	f800283a 	ret

0d0127f8 <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 d0127f8:	defff504 	addi	sp,sp,-44
 d0127fc:	dfc00a15 	stw	ra,40(sp)
 d012800:	df000915 	stw	fp,36(sp)
 d012804:	df000904 	addi	fp,sp,36
 d012808:	e13ffd15 	stw	r4,-12(fp)
 d01280c:	e17ffe15 	stw	r5,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d012810:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d012814:	e0bffd17 	ldw	r2,-12(fp)
 d012818:	1004c03a 	cmpne	r2,r2,zero
 d01281c:	1000031e 	bne	r2,zero,d01282c <OSQPostFront+0x34>
        return (OS_ERR_PEVENT_NULL);
 d012820:	00800104 	movi	r2,4
 d012824:	e0bfff15 	stw	r2,-4(fp)
 d012828:	00004f06 	br	d012968 <OSQPostFront+0x170>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 d01282c:	e0bffd17 	ldw	r2,-12(fp)
 d012830:	10800003 	ldbu	r2,0(r2)
 d012834:	10803fcc 	andi	r2,r2,255
 d012838:	108000a0 	cmpeqi	r2,r2,2
 d01283c:	1000031e 	bne	r2,zero,d01284c <OSQPostFront+0x54>
        return (OS_ERR_EVENT_TYPE);
 d012840:	00800044 	movi	r2,1
 d012844:	e0bfff15 	stw	r2,-4(fp)
 d012848:	00004706 	br	d012968 <OSQPostFront+0x170>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01284c:	0005303a 	rdctl	r2,status
 d012850:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012854:	e0fffa17 	ldw	r3,-24(fp)
 d012858:	00bfff84 	movi	r2,-2
 d01285c:	1884703a 	and	r2,r3,r2
 d012860:	1001703a 	wrctl	status,r2
  
  return context;
 d012864:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d012868:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 d01286c:	e0bffd17 	ldw	r2,-12(fp)
 d012870:	10800283 	ldbu	r2,10(r2)
 d012874:	10803fcc 	andi	r2,r2,255
 d012878:	1005003a 	cmpeq	r2,r2,zero
 d01287c:	10000c1e 	bne	r2,zero,d0128b0 <OSQPostFront+0xb8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 d012880:	e13ffd17 	ldw	r4,-12(fp)
 d012884:	e17ffe17 	ldw	r5,-8(fp)
 d012888:	01800104 	movi	r6,4
 d01288c:	000f883a 	mov	r7,zero
 d012890:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
 d012894:	e0bffb17 	ldw	r2,-20(fp)
 d012898:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01289c:	e0bff917 	ldw	r2,-28(fp)
 d0128a0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 d0128a4:	d00f0f40 	call	d00f0f4 <OS_Sched>
        return (OS_ERR_NONE);
 d0128a8:	e03fff15 	stw	zero,-4(fp)
 d0128ac:	00002e06 	br	d012968 <OSQPostFront+0x170>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 d0128b0:	e0bffd17 	ldw	r2,-12(fp)
 d0128b4:	10800117 	ldw	r2,4(r2)
 d0128b8:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 d0128bc:	e0bffc17 	ldw	r2,-16(fp)
 d0128c0:	10c0058b 	ldhu	r3,22(r2)
 d0128c4:	e0bffc17 	ldw	r2,-16(fp)
 d0128c8:	1080050b 	ldhu	r2,20(r2)
 d0128cc:	18ffffcc 	andi	r3,r3,65535
 d0128d0:	10bfffcc 	andi	r2,r2,65535
 d0128d4:	18800736 	bltu	r3,r2,d0128f4 <OSQPostFront+0xfc>
 d0128d8:	e0bffb17 	ldw	r2,-20(fp)
 d0128dc:	e0bff815 	stw	r2,-32(fp)
 d0128e0:	e0bff817 	ldw	r2,-32(fp)
 d0128e4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 d0128e8:	00800784 	movi	r2,30
 d0128ec:	e0bfff15 	stw	r2,-4(fp)
 d0128f0:	00001d06 	br	d012968 <OSQPostFront+0x170>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 d0128f4:	e0bffc17 	ldw	r2,-16(fp)
 d0128f8:	10c00417 	ldw	r3,16(r2)
 d0128fc:	e0bffc17 	ldw	r2,-16(fp)
 d012900:	10800117 	ldw	r2,4(r2)
 d012904:	1880041e 	bne	r3,r2,d012918 <OSQPostFront+0x120>
        pq->OSQOut = pq->OSQEnd;
 d012908:	e0bffc17 	ldw	r2,-16(fp)
 d01290c:	10c00217 	ldw	r3,8(r2)
 d012910:	e0bffc17 	ldw	r2,-16(fp)
 d012914:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 d012918:	e0bffc17 	ldw	r2,-16(fp)
 d01291c:	10800417 	ldw	r2,16(r2)
 d012920:	10ffff04 	addi	r3,r2,-4
 d012924:	e0bffc17 	ldw	r2,-16(fp)
 d012928:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 d01292c:	e0bffc17 	ldw	r2,-16(fp)
 d012930:	10c00417 	ldw	r3,16(r2)
 d012934:	e0bffe17 	ldw	r2,-8(fp)
 d012938:	18800015 	stw	r2,0(r3)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 d01293c:	e0bffc17 	ldw	r2,-16(fp)
 d012940:	1080058b 	ldhu	r2,22(r2)
 d012944:	10800044 	addi	r2,r2,1
 d012948:	1007883a 	mov	r3,r2
 d01294c:	e0bffc17 	ldw	r2,-16(fp)
 d012950:	10c0058d 	sth	r3,22(r2)
 d012954:	e0bffb17 	ldw	r2,-20(fp)
 d012958:	e0bff715 	stw	r2,-36(fp)
 d01295c:	e0bff717 	ldw	r2,-36(fp)
 d012960:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d012964:	e03fff15 	stw	zero,-4(fp)
 d012968:	e0bfff17 	ldw	r2,-4(fp)
}
 d01296c:	e037883a 	mov	sp,fp
 d012970:	dfc00117 	ldw	ra,4(sp)
 d012974:	df000017 	ldw	fp,0(sp)
 d012978:	dec00204 	addi	sp,sp,8
 d01297c:	f800283a 	ret

0d012980 <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 d012980:	defff404 	addi	sp,sp,-48
 d012984:	dfc00b15 	stw	ra,44(sp)
 d012988:	df000a15 	stw	fp,40(sp)
 d01298c:	df000a04 	addi	fp,sp,40
 d012990:	e13ffc15 	stw	r4,-16(fp)
 d012994:	e17ffd15 	stw	r5,-12(fp)
 d012998:	e1bffe05 	stb	r6,-8(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d01299c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d0129a0:	e0bffc17 	ldw	r2,-16(fp)
 d0129a4:	1004c03a 	cmpne	r2,r2,zero
 d0129a8:	1000031e 	bne	r2,zero,d0129b8 <OSQPostOpt+0x38>
        return (OS_ERR_PEVENT_NULL);
 d0129ac:	00800104 	movi	r2,4
 d0129b0:	e0bfff15 	stw	r2,-4(fp)
 d0129b4:	00007906 	br	d012b9c <OSQPostOpt+0x21c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 d0129b8:	e0bffc17 	ldw	r2,-16(fp)
 d0129bc:	10800003 	ldbu	r2,0(r2)
 d0129c0:	10803fcc 	andi	r2,r2,255
 d0129c4:	108000a0 	cmpeqi	r2,r2,2
 d0129c8:	1000031e 	bne	r2,zero,d0129d8 <OSQPostOpt+0x58>
        return (OS_ERR_EVENT_TYPE);
 d0129cc:	00800044 	movi	r2,1
 d0129d0:	e0bfff15 	stw	r2,-4(fp)
 d0129d4:	00007106 	br	d012b9c <OSQPostOpt+0x21c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0129d8:	0005303a 	rdctl	r2,status
 d0129dc:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0129e0:	e0fff917 	ldw	r3,-28(fp)
 d0129e4:	00bfff84 	movi	r2,-2
 d0129e8:	1884703a 	and	r2,r3,r2
 d0129ec:	1001703a 	wrctl	status,r2
  
  return context;
 d0129f0:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d0129f4:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 d0129f8:	e0bffc17 	ldw	r2,-16(fp)
 d0129fc:	10800283 	ldbu	r2,10(r2)
 d012a00:	10803fcc 	andi	r2,r2,255
 d012a04:	1005003a 	cmpeq	r2,r2,zero
 d012a08:	1000211e 	bne	r2,zero,d012a90 <OSQPostOpt+0x110>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 d012a0c:	e0bffe03 	ldbu	r2,-8(fp)
 d012a10:	1080004c 	andi	r2,r2,1
 d012a14:	10803fcc 	andi	r2,r2,255
 d012a18:	1005003a 	cmpeq	r2,r2,zero
 d012a1c:	10000c1e 	bne	r2,zero,d012a50 <OSQPostOpt+0xd0>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 d012a20:	00000506 	br	d012a38 <OSQPostOpt+0xb8>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 d012a24:	e13ffc17 	ldw	r4,-16(fp)
 d012a28:	e17ffd17 	ldw	r5,-12(fp)
 d012a2c:	01800104 	movi	r6,4
 d012a30:	000f883a 	mov	r7,zero
 d012a34:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 d012a38:	e0bffc17 	ldw	r2,-16(fp)
 d012a3c:	10800283 	ldbu	r2,10(r2)
 d012a40:	10803fcc 	andi	r2,r2,255
 d012a44:	1004c03a 	cmpne	r2,r2,zero
 d012a48:	103ff61e 	bne	r2,zero,d012a24 <OSQPostOpt+0xa4>
 d012a4c:	00000506 	br	d012a64 <OSQPostOpt+0xe4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 d012a50:	e13ffc17 	ldw	r4,-16(fp)
 d012a54:	e17ffd17 	ldw	r5,-12(fp)
 d012a58:	01800104 	movi	r6,4
 d012a5c:	000f883a 	mov	r7,zero
 d012a60:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
 d012a64:	e0bffa17 	ldw	r2,-24(fp)
 d012a68:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012a6c:	e0bff817 	ldw	r2,-32(fp)
 d012a70:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 d012a74:	e0bffe03 	ldbu	r2,-8(fp)
 d012a78:	1080010c 	andi	r2,r2,4
 d012a7c:	1004c03a 	cmpne	r2,r2,zero
 d012a80:	1000011e 	bne	r2,zero,d012a88 <OSQPostOpt+0x108>
            OS_Sched();                               /* Find highest priority task ready to run       */
 d012a84:	d00f0f40 	call	d00f0f4 <OS_Sched>
        }
        return (OS_ERR_NONE);
 d012a88:	e03fff15 	stw	zero,-4(fp)
 d012a8c:	00004306 	br	d012b9c <OSQPostOpt+0x21c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 d012a90:	e0bffc17 	ldw	r2,-16(fp)
 d012a94:	10800117 	ldw	r2,4(r2)
 d012a98:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 d012a9c:	e0bffb17 	ldw	r2,-20(fp)
 d012aa0:	10c0058b 	ldhu	r3,22(r2)
 d012aa4:	e0bffb17 	ldw	r2,-20(fp)
 d012aa8:	1080050b 	ldhu	r2,20(r2)
 d012aac:	18ffffcc 	andi	r3,r3,65535
 d012ab0:	10bfffcc 	andi	r2,r2,65535
 d012ab4:	18800736 	bltu	r3,r2,d012ad4 <OSQPostOpt+0x154>
 d012ab8:	e0bffa17 	ldw	r2,-24(fp)
 d012abc:	e0bff715 	stw	r2,-36(fp)
 d012ac0:	e0bff717 	ldw	r2,-36(fp)
 d012ac4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 d012ac8:	00800784 	movi	r2,30
 d012acc:	e0bfff15 	stw	r2,-4(fp)
 d012ad0:	00003206 	br	d012b9c <OSQPostOpt+0x21c>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 d012ad4:	e0bffe03 	ldbu	r2,-8(fp)
 d012ad8:	1080008c 	andi	r2,r2,2
 d012adc:	1005003a 	cmpeq	r2,r2,zero
 d012ae0:	1000131e 	bne	r2,zero,d012b30 <OSQPostOpt+0x1b0>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 d012ae4:	e0bffb17 	ldw	r2,-20(fp)
 d012ae8:	10c00417 	ldw	r3,16(r2)
 d012aec:	e0bffb17 	ldw	r2,-20(fp)
 d012af0:	10800117 	ldw	r2,4(r2)
 d012af4:	1880041e 	bne	r3,r2,d012b08 <OSQPostOpt+0x188>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 d012af8:	e0bffb17 	ldw	r2,-20(fp)
 d012afc:	10c00217 	ldw	r3,8(r2)
 d012b00:	e0bffb17 	ldw	r2,-20(fp)
 d012b04:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 d012b08:	e0bffb17 	ldw	r2,-20(fp)
 d012b0c:	10800417 	ldw	r2,16(r2)
 d012b10:	10ffff04 	addi	r3,r2,-4
 d012b14:	e0bffb17 	ldw	r2,-20(fp)
 d012b18:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 d012b1c:	e0bffb17 	ldw	r2,-20(fp)
 d012b20:	10c00417 	ldw	r3,16(r2)
 d012b24:	e0bffd17 	ldw	r2,-12(fp)
 d012b28:	18800015 	stw	r2,0(r3)
 d012b2c:	00001006 	br	d012b70 <OSQPostOpt+0x1f0>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 d012b30:	e0bffb17 	ldw	r2,-20(fp)
 d012b34:	10c00317 	ldw	r3,12(r2)
 d012b38:	e0bffd17 	ldw	r2,-12(fp)
 d012b3c:	18800015 	stw	r2,0(r3)
 d012b40:	18c00104 	addi	r3,r3,4
 d012b44:	e0bffb17 	ldw	r2,-20(fp)
 d012b48:	10c00315 	stw	r3,12(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 d012b4c:	e0bffb17 	ldw	r2,-20(fp)
 d012b50:	10c00317 	ldw	r3,12(r2)
 d012b54:	e0bffb17 	ldw	r2,-20(fp)
 d012b58:	10800217 	ldw	r2,8(r2)
 d012b5c:	1880041e 	bne	r3,r2,d012b70 <OSQPostOpt+0x1f0>
            pq->OSQIn = pq->OSQStart;
 d012b60:	e0bffb17 	ldw	r2,-20(fp)
 d012b64:	10c00117 	ldw	r3,4(r2)
 d012b68:	e0bffb17 	ldw	r2,-20(fp)
 d012b6c:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 d012b70:	e0bffb17 	ldw	r2,-20(fp)
 d012b74:	1080058b 	ldhu	r2,22(r2)
 d012b78:	10800044 	addi	r2,r2,1
 d012b7c:	1007883a 	mov	r3,r2
 d012b80:	e0bffb17 	ldw	r2,-20(fp)
 d012b84:	10c0058d 	sth	r3,22(r2)
 d012b88:	e0bffa17 	ldw	r2,-24(fp)
 d012b8c:	e0bff615 	stw	r2,-40(fp)
 d012b90:	e0bff617 	ldw	r2,-40(fp)
 d012b94:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d012b98:	e03fff15 	stw	zero,-4(fp)
 d012b9c:	e0bfff17 	ldw	r2,-4(fp)
}
 d012ba0:	e037883a 	mov	sp,fp
 d012ba4:	dfc00117 	ldw	ra,4(sp)
 d012ba8:	df000017 	ldw	fp,0(sp)
 d012bac:	dec00204 	addi	sp,sp,8
 d012bb0:	f800283a 	ret

0d012bb4 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 d012bb4:	defff504 	addi	sp,sp,-44
 d012bb8:	df000a15 	stw	fp,40(sp)
 d012bbc:	df000a04 	addi	fp,sp,40
 d012bc0:	e13ffd15 	stw	r4,-12(fp)
 d012bc4:	e17ffe15 	stw	r5,-8(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d012bc8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 d012bcc:	e0bffd17 	ldw	r2,-12(fp)
 d012bd0:	1004c03a 	cmpne	r2,r2,zero
 d012bd4:	1000031e 	bne	r2,zero,d012be4 <OSQQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 d012bd8:	00800104 	movi	r2,4
 d012bdc:	e0bfff15 	stw	r2,-4(fp)
 d012be0:	00004f06 	br	d012d20 <OSQQuery+0x16c>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 d012be4:	e0bffe17 	ldw	r2,-8(fp)
 d012be8:	1004c03a 	cmpne	r2,r2,zero
 d012bec:	1000031e 	bne	r2,zero,d012bfc <OSQQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 d012bf0:	00800244 	movi	r2,9
 d012bf4:	e0bfff15 	stw	r2,-4(fp)
 d012bf8:	00004906 	br	d012d20 <OSQQuery+0x16c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 d012bfc:	e0bffd17 	ldw	r2,-12(fp)
 d012c00:	10800003 	ldbu	r2,0(r2)
 d012c04:	10803fcc 	andi	r2,r2,255
 d012c08:	108000a0 	cmpeqi	r2,r2,2
 d012c0c:	1000031e 	bne	r2,zero,d012c1c <OSQQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 d012c10:	00800044 	movi	r2,1
 d012c14:	e0bfff15 	stw	r2,-4(fp)
 d012c18:	00004106 	br	d012d20 <OSQQuery+0x16c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d012c1c:	0005303a 	rdctl	r2,status
 d012c20:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012c24:	e0fff717 	ldw	r3,-36(fp)
 d012c28:	00bfff84 	movi	r2,-2
 d012c2c:	1884703a 	and	r2,r3,r2
 d012c30:	1001703a 	wrctl	status,r2
  
  return context;
 d012c34:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 d012c38:	e0bff815 	stw	r2,-32(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 d012c3c:	e0bffd17 	ldw	r2,-12(fp)
 d012c40:	10c00283 	ldbu	r3,10(r2)
 d012c44:	e0bffe17 	ldw	r2,-8(fp)
 d012c48:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 d012c4c:	e0bffd17 	ldw	r2,-12(fp)
 d012c50:	108002c4 	addi	r2,r2,11
 d012c54:	e0bffa15 	stw	r2,-24(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 d012c58:	e0bffe17 	ldw	r2,-8(fp)
 d012c5c:	10800204 	addi	r2,r2,8
 d012c60:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d012c64:	e03ffb05 	stb	zero,-20(fp)
 d012c68:	00000d06 	br	d012ca0 <OSQQuery+0xec>
        *pdest++ = *psrc++;
 d012c6c:	e0bffa17 	ldw	r2,-24(fp)
 d012c70:	10c00003 	ldbu	r3,0(r2)
 d012c74:	e0bff917 	ldw	r2,-28(fp)
 d012c78:	10c00005 	stb	r3,0(r2)
 d012c7c:	e0bff917 	ldw	r2,-28(fp)
 d012c80:	10800044 	addi	r2,r2,1
 d012c84:	e0bff915 	stw	r2,-28(fp)
 d012c88:	e0bffa17 	ldw	r2,-24(fp)
 d012c8c:	10800044 	addi	r2,r2,1
 d012c90:	e0bffa15 	stw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d012c94:	e0bffb03 	ldbu	r2,-20(fp)
 d012c98:	10800044 	addi	r2,r2,1
 d012c9c:	e0bffb05 	stb	r2,-20(fp)
 d012ca0:	e0bffb03 	ldbu	r2,-20(fp)
 d012ca4:	108000f0 	cmpltui	r2,r2,3
 d012ca8:	103ff01e 	bne	r2,zero,d012c6c <OSQQuery+0xb8>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 d012cac:	e0bffd17 	ldw	r2,-12(fp)
 d012cb0:	10800117 	ldw	r2,4(r2)
 d012cb4:	e0bffc15 	stw	r2,-16(fp)
    if (pq->OSQEntries > 0) {
 d012cb8:	e0bffc17 	ldw	r2,-16(fp)
 d012cbc:	1080058b 	ldhu	r2,22(r2)
 d012cc0:	10bfffcc 	andi	r2,r2,65535
 d012cc4:	1005003a 	cmpeq	r2,r2,zero
 d012cc8:	1000061e 	bne	r2,zero,d012ce4 <OSQQuery+0x130>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 d012ccc:	e0bffc17 	ldw	r2,-16(fp)
 d012cd0:	10800417 	ldw	r2,16(r2)
 d012cd4:	10c00017 	ldw	r3,0(r2)
 d012cd8:	e0bffe17 	ldw	r2,-8(fp)
 d012cdc:	10c00015 	stw	r3,0(r2)
 d012ce0:	00000206 	br	d012cec <OSQQuery+0x138>
    } else {
        p_q_data->OSMsg = (void *)0;
 d012ce4:	e0bffe17 	ldw	r2,-8(fp)
 d012ce8:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 d012cec:	e0bffc17 	ldw	r2,-16(fp)
 d012cf0:	10c0058b 	ldhu	r3,22(r2)
 d012cf4:	e0bffe17 	ldw	r2,-8(fp)
 d012cf8:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 d012cfc:	e0bffc17 	ldw	r2,-16(fp)
 d012d00:	10c0050b 	ldhu	r3,20(r2)
 d012d04:	e0bffe17 	ldw	r2,-8(fp)
 d012d08:	10c0018d 	sth	r3,6(r2)
 d012d0c:	e0bff817 	ldw	r2,-32(fp)
 d012d10:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012d14:	e0bff617 	ldw	r2,-40(fp)
 d012d18:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d012d1c:	e03fff15 	stw	zero,-4(fp)
 d012d20:	e0bfff17 	ldw	r2,-4(fp)
}
 d012d24:	e037883a 	mov	sp,fp
 d012d28:	df000017 	ldw	fp,0(sp)
 d012d2c:	dec00104 	addi	sp,sp,4
 d012d30:	f800283a 	ret

0d012d34 <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 d012d34:	defffb04 	addi	sp,sp,-20
 d012d38:	dfc00415 	stw	ra,16(sp)
 d012d3c:	df000315 	stw	fp,12(sp)
 d012d40:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 d012d44:	010341b4 	movhi	r4,3334
 d012d48:	212aa704 	addi	r4,r4,-21860
 d012d4c:	01407804 	movi	r5,480
 d012d50:	d00f0340 	call	d00f034 <OS_MemClr>
    pq1 = &OSQTbl[0];
 d012d54:	008341b4 	movhi	r2,3334
 d012d58:	10aaa704 	addi	r2,r2,-21860
 d012d5c:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 d012d60:	008341b4 	movhi	r2,3334
 d012d64:	10aaad04 	addi	r2,r2,-21836
 d012d68:	e0bffd15 	stw	r2,-12(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 d012d6c:	e03fff0d 	sth	zero,-4(fp)
 d012d70:	00000c06 	br	d012da4 <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 d012d74:	e0fffe17 	ldw	r3,-8(fp)
 d012d78:	e0bffd17 	ldw	r2,-12(fp)
 d012d7c:	18800015 	stw	r2,0(r3)
        pq1++;
 d012d80:	e0bffe17 	ldw	r2,-8(fp)
 d012d84:	10800604 	addi	r2,r2,24
 d012d88:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 d012d8c:	e0bffd17 	ldw	r2,-12(fp)
 d012d90:	10800604 	addi	r2,r2,24
 d012d94:	e0bffd15 	stw	r2,-12(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 d012d98:	e0bfff0b 	ldhu	r2,-4(fp)
 d012d9c:	10800044 	addi	r2,r2,1
 d012da0:	e0bfff0d 	sth	r2,-4(fp)
 d012da4:	e0bfff0b 	ldhu	r2,-4(fp)
 d012da8:	108004f0 	cmpltui	r2,r2,19
 d012dac:	103ff11e 	bne	r2,zero,d012d74 <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 d012db0:	e0bffe17 	ldw	r2,-8(fp)
 d012db4:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 d012db8:	00c34174 	movhi	r3,3333
 d012dbc:	18ca9704 	addi	r3,r3,10844
 d012dc0:	008341b4 	movhi	r2,3334
 d012dc4:	10aaa704 	addi	r2,r2,-21860
 d012dc8:	18800015 	stw	r2,0(r3)
#endif
}
 d012dcc:	e037883a 	mov	sp,fp
 d012dd0:	dfc00117 	ldw	ra,4(sp)
 d012dd4:	df000017 	ldw	fp,0(sp)
 d012dd8:	dec00204 	addi	sp,sp,8
 d012ddc:	f800283a 	ret

0d012de0 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 d012de0:	defff904 	addi	sp,sp,-28
 d012de4:	df000615 	stw	fp,24(sp)
 d012de8:	df000604 	addi	fp,sp,24
 d012dec:	e13ffe15 	stw	r4,-8(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d012df0:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d012df4:	e0bffe17 	ldw	r2,-8(fp)
 d012df8:	1004c03a 	cmpne	r2,r2,zero
 d012dfc:	1000021e 	bne	r2,zero,d012e08 <OSSemAccept+0x28>
        return (0);
 d012e00:	e03fff15 	stw	zero,-4(fp)
 d012e04:	00002106 	br	d012e8c <OSSemAccept+0xac>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d012e08:	e0bffe17 	ldw	r2,-8(fp)
 d012e0c:	10800003 	ldbu	r2,0(r2)
 d012e10:	10803fcc 	andi	r2,r2,255
 d012e14:	108000e0 	cmpeqi	r2,r2,3
 d012e18:	1000021e 	bne	r2,zero,d012e24 <OSSemAccept+0x44>
        return (0);
 d012e1c:	e03fff15 	stw	zero,-4(fp)
 d012e20:	00001a06 	br	d012e8c <OSSemAccept+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d012e24:	0005303a 	rdctl	r2,status
 d012e28:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012e2c:	e0fffb17 	ldw	r3,-20(fp)
 d012e30:	00bfff84 	movi	r2,-2
 d012e34:	1884703a 	and	r2,r3,r2
 d012e38:	1001703a 	wrctl	status,r2
  
  return context;
 d012e3c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 d012e40:	e0bffc15 	stw	r2,-16(fp)
    cnt = pevent->OSEventCnt;
 d012e44:	e0bffe17 	ldw	r2,-8(fp)
 d012e48:	1080020b 	ldhu	r2,8(r2)
 d012e4c:	e0bffd0d 	sth	r2,-12(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 d012e50:	e0bffd0b 	ldhu	r2,-12(fp)
 d012e54:	1005003a 	cmpeq	r2,r2,zero
 d012e58:	1000061e 	bne	r2,zero,d012e74 <OSSemAccept+0x94>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 d012e5c:	e0bffe17 	ldw	r2,-8(fp)
 d012e60:	1080020b 	ldhu	r2,8(r2)
 d012e64:	10bfffc4 	addi	r2,r2,-1
 d012e68:	1007883a 	mov	r3,r2
 d012e6c:	e0bffe17 	ldw	r2,-8(fp)
 d012e70:	10c0020d 	sth	r3,8(r2)
 d012e74:	e0bffc17 	ldw	r2,-16(fp)
 d012e78:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012e7c:	e0bffa17 	ldw	r2,-24(fp)
 d012e80:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 d012e84:	e0bffd0b 	ldhu	r2,-12(fp)
 d012e88:	e0bfff15 	stw	r2,-4(fp)
 d012e8c:	e0bfff17 	ldw	r2,-4(fp)
}
 d012e90:	e037883a 	mov	sp,fp
 d012e94:	df000017 	ldw	fp,0(sp)
 d012e98:	dec00104 	addi	sp,sp,4
 d012e9c:	f800283a 	ret

0d012ea0 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 d012ea0:	defff804 	addi	sp,sp,-32
 d012ea4:	dfc00715 	stw	ra,28(sp)
 d012ea8:	df000615 	stw	fp,24(sp)
 d012eac:	df000604 	addi	fp,sp,24
 d012eb0:	e13ffe0d 	sth	r4,-8(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d012eb4:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d012eb8:	00834174 	movhi	r2,3333
 d012ebc:	108a9a04 	addi	r2,r2,10856
 d012ec0:	10800003 	ldbu	r2,0(r2)
 d012ec4:	10803fcc 	andi	r2,r2,255
 d012ec8:	1005003a 	cmpeq	r2,r2,zero
 d012ecc:	1000021e 	bne	r2,zero,d012ed8 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 d012ed0:	e03fff15 	stw	zero,-4(fp)
 d012ed4:	00003106 	br	d012f9c <OSSemCreate+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d012ed8:	0005303a 	rdctl	r2,status
 d012edc:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d012ee0:	e0fffb17 	ldw	r3,-20(fp)
 d012ee4:	00bfff84 	movi	r2,-2
 d012ee8:	1884703a 	and	r2,r3,r2
 d012eec:	1001703a 	wrctl	status,r2
  
  return context;
 d012ef0:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 d012ef4:	e0bffc15 	stw	r2,-16(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 d012ef8:	00834174 	movhi	r2,3333
 d012efc:	108a9904 	addi	r2,r2,10852
 d012f00:	10800017 	ldw	r2,0(r2)
 d012f04:	e0bffd15 	stw	r2,-12(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 d012f08:	00834174 	movhi	r2,3333
 d012f0c:	108a9904 	addi	r2,r2,10852
 d012f10:	10800017 	ldw	r2,0(r2)
 d012f14:	1005003a 	cmpeq	r2,r2,zero
 d012f18:	1000081e 	bne	r2,zero,d012f3c <OSSemCreate+0x9c>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 d012f1c:	00834174 	movhi	r2,3333
 d012f20:	108a9904 	addi	r2,r2,10852
 d012f24:	10800017 	ldw	r2,0(r2)
 d012f28:	10800117 	ldw	r2,4(r2)
 d012f2c:	1007883a 	mov	r3,r2
 d012f30:	00834174 	movhi	r2,3333
 d012f34:	108a9904 	addi	r2,r2,10852
 d012f38:	10c00015 	stw	r3,0(r2)
 d012f3c:	e0bffc17 	ldw	r2,-16(fp)
 d012f40:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d012f44:	e0bffa17 	ldw	r2,-24(fp)
 d012f48:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 d012f4c:	e0bffd17 	ldw	r2,-12(fp)
 d012f50:	1005003a 	cmpeq	r2,r2,zero
 d012f54:	10000f1e 	bne	r2,zero,d012f94 <OSSemCreate+0xf4>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 d012f58:	e0fffd17 	ldw	r3,-12(fp)
 d012f5c:	008000c4 	movi	r2,3
 d012f60:	18800005 	stb	r2,0(r3)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 d012f64:	e0fffd17 	ldw	r3,-12(fp)
 d012f68:	e0bffe0b 	ldhu	r2,-8(fp)
 d012f6c:	1880020d 	sth	r2,8(r3)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 d012f70:	e0bffd17 	ldw	r2,-12(fp)
 d012f74:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 d012f78:	e0fffd17 	ldw	r3,-12(fp)
 d012f7c:	00800fc4 	movi	r2,63
 d012f80:	18800385 	stb	r2,14(r3)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 d012f84:	e0bffd17 	ldw	r2,-12(fp)
 d012f88:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 d012f8c:	e13ffd17 	ldw	r4,-12(fp)
 d012f90:	d00ec680 	call	d00ec68 <OS_EventWaitListInit>
    }
    return (pevent);
 d012f94:	e0bffd17 	ldw	r2,-12(fp)
 d012f98:	e0bfff15 	stw	r2,-4(fp)
 d012f9c:	e0bfff17 	ldw	r2,-4(fp)
}
 d012fa0:	e037883a 	mov	sp,fp
 d012fa4:	dfc00117 	ldw	ra,4(sp)
 d012fa8:	df000017 	ldw	fp,0(sp)
 d012fac:	dec00204 	addi	sp,sp,8
 d012fb0:	f800283a 	ret

0d012fb4 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 d012fb4:	defff104 	addi	sp,sp,-60
 d012fb8:	dfc00e15 	stw	ra,56(sp)
 d012fbc:	df000d15 	stw	fp,52(sp)
 d012fc0:	df000d04 	addi	fp,sp,52
 d012fc4:	e13ffb15 	stw	r4,-20(fp)
 d012fc8:	e1bffd15 	stw	r6,-12(fp)
 d012fcc:	e17ffc05 	stb	r5,-16(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d012fd0:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 d012fd4:	e0bffd17 	ldw	r2,-12(fp)
 d012fd8:	1004c03a 	cmpne	r2,r2,zero
 d012fdc:	1000031e 	bne	r2,zero,d012fec <OSSemDel+0x38>
        return (pevent);
 d012fe0:	e0bffb17 	ldw	r2,-20(fp)
 d012fe4:	e0bfff15 	stw	r2,-4(fp)
 d012fe8:	00009406 	br	d01323c <OSSemDel+0x288>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 d012fec:	e0bffb17 	ldw	r2,-20(fp)
 d012ff0:	1004c03a 	cmpne	r2,r2,zero
 d012ff4:	1000061e 	bne	r2,zero,d013010 <OSSemDel+0x5c>
        *perr = OS_ERR_PEVENT_NULL;
 d012ff8:	e0fffd17 	ldw	r3,-12(fp)
 d012ffc:	00800104 	movi	r2,4
 d013000:	18800005 	stb	r2,0(r3)
        return (pevent);
 d013004:	e0fffb17 	ldw	r3,-20(fp)
 d013008:	e0ffff15 	stw	r3,-4(fp)
 d01300c:	00008b06 	br	d01323c <OSSemDel+0x288>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 d013010:	e0bffb17 	ldw	r2,-20(fp)
 d013014:	10800003 	ldbu	r2,0(r2)
 d013018:	10803fcc 	andi	r2,r2,255
 d01301c:	108000e0 	cmpeqi	r2,r2,3
 d013020:	1000061e 	bne	r2,zero,d01303c <OSSemDel+0x88>
        *perr = OS_ERR_EVENT_TYPE;
 d013024:	e0fffd17 	ldw	r3,-12(fp)
 d013028:	00800044 	movi	r2,1
 d01302c:	18800005 	stb	r2,0(r3)
        return (pevent);
 d013030:	e0bffb17 	ldw	r2,-20(fp)
 d013034:	e0bfff15 	stw	r2,-4(fp)
 d013038:	00008006 	br	d01323c <OSSemDel+0x288>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 d01303c:	00834174 	movhi	r2,3333
 d013040:	108a9a04 	addi	r2,r2,10856
 d013044:	10800003 	ldbu	r2,0(r2)
 d013048:	10803fcc 	andi	r2,r2,255
 d01304c:	1005003a 	cmpeq	r2,r2,zero
 d013050:	1000061e 	bne	r2,zero,d01306c <OSSemDel+0xb8>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 d013054:	e0fffd17 	ldw	r3,-12(fp)
 d013058:	008003c4 	movi	r2,15
 d01305c:	18800005 	stb	r2,0(r3)
        return (pevent);
 d013060:	e0fffb17 	ldw	r3,-20(fp)
 d013064:	e0ffff15 	stw	r3,-4(fp)
 d013068:	00007406 	br	d01323c <OSSemDel+0x288>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01306c:	0005303a 	rdctl	r2,status
 d013070:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013074:	e0fff717 	ldw	r3,-36(fp)
 d013078:	00bfff84 	movi	r2,-2
 d01307c:	1884703a 	and	r2,r3,r2
 d013080:	1001703a 	wrctl	status,r2
  
  return context;
 d013084:	e0bff717 	ldw	r2,-36(fp)
    }
    OS_ENTER_CRITICAL();
 d013088:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 d01308c:	e0bffb17 	ldw	r2,-20(fp)
 d013090:	10800283 	ldbu	r2,10(r2)
 d013094:	10803fcc 	andi	r2,r2,255
 d013098:	1005003a 	cmpeq	r2,r2,zero
 d01309c:	1000031e 	bne	r2,zero,d0130ac <OSSemDel+0xf8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 d0130a0:	00800044 	movi	r2,1
 d0130a4:	e0bffa05 	stb	r2,-24(fp)
 d0130a8:	00000106 	br	d0130b0 <OSSemDel+0xfc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 d0130ac:	e03ffa05 	stb	zero,-24(fp)
    }
    switch (opt) {
 d0130b0:	e0bffc03 	ldbu	r2,-16(fp)
 d0130b4:	e0bffe15 	stw	r2,-8(fp)
 d0130b8:	e0fffe17 	ldw	r3,-8(fp)
 d0130bc:	1805003a 	cmpeq	r2,r3,zero
 d0130c0:	1000041e 	bne	r2,zero,d0130d4 <OSSemDel+0x120>
 d0130c4:	e0fffe17 	ldw	r3,-8(fp)
 d0130c8:	18800060 	cmpeqi	r2,r3,1
 d0130cc:	10002d1e 	bne	r2,zero,d013184 <OSSemDel+0x1d0>
 d0130d0:	00004f06 	br	d013210 <OSSemDel+0x25c>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 d0130d4:	e0bffa03 	ldbu	r2,-24(fp)
 d0130d8:	1004c03a 	cmpne	r2,r2,zero
 d0130dc:	10001a1e 	bne	r2,zero,d013148 <OSSemDel+0x194>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 d0130e0:	e0fffb17 	ldw	r3,-20(fp)
 d0130e4:	00800fc4 	movi	r2,63
 d0130e8:	18800385 	stb	r2,14(r3)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 d0130ec:	e0bffb17 	ldw	r2,-20(fp)
 d0130f0:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d0130f4:	e0bffb17 	ldw	r2,-20(fp)
 d0130f8:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 d0130fc:	00834174 	movhi	r2,3333
 d013100:	108a9904 	addi	r2,r2,10852
 d013104:	10c00017 	ldw	r3,0(r2)
 d013108:	e0bffb17 	ldw	r2,-20(fp)
 d01310c:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 d013110:	e0bffb17 	ldw	r2,-20(fp)
 d013114:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 d013118:	00c34174 	movhi	r3,3333
 d01311c:	18ca9904 	addi	r3,r3,10852
 d013120:	e0bffb17 	ldw	r2,-20(fp)
 d013124:	18800015 	stw	r2,0(r3)
 d013128:	e0bff817 	ldw	r2,-32(fp)
 d01312c:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013130:	e0bff617 	ldw	r2,-40(fp)
 d013134:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 d013138:	e0bffd17 	ldw	r2,-12(fp)
 d01313c:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 d013140:	e03ff915 	stw	zero,-28(fp)
 d013144:	00003b06 	br	d013234 <OSSemDel+0x280>
 d013148:	e0bff817 	ldw	r2,-32(fp)
 d01314c:	e0bff515 	stw	r2,-44(fp)
 d013150:	e0bff517 	ldw	r2,-44(fp)
 d013154:	1001703a 	wrctl	status,r2
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 d013158:	e0fffd17 	ldw	r3,-12(fp)
 d01315c:	00801244 	movi	r2,73
 d013160:	18800005 	stb	r2,0(r3)
                 pevent_return          = pevent;
 d013164:	e0bffb17 	ldw	r2,-20(fp)
 d013168:	e0bff915 	stw	r2,-28(fp)
             }
             break;
 d01316c:	00003106 	br	d013234 <OSSemDel+0x280>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 d013170:	e13ffb17 	ldw	r4,-20(fp)
 d013174:	000b883a 	mov	r5,zero
 d013178:	01800044 	movi	r6,1
 d01317c:	000f883a 	mov	r7,zero
 d013180:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 d013184:	e0bffb17 	ldw	r2,-20(fp)
 d013188:	10800283 	ldbu	r2,10(r2)
 d01318c:	10803fcc 	andi	r2,r2,255
 d013190:	1004c03a 	cmpne	r2,r2,zero
 d013194:	103ff61e 	bne	r2,zero,d013170 <OSSemDel+0x1bc>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 d013198:	e0fffb17 	ldw	r3,-20(fp)
 d01319c:	00800fc4 	movi	r2,63
 d0131a0:	18800385 	stb	r2,14(r3)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 d0131a4:	e0bffb17 	ldw	r2,-20(fp)
 d0131a8:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 d0131ac:	e0bffb17 	ldw	r2,-20(fp)
 d0131b0:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 d0131b4:	00834174 	movhi	r2,3333
 d0131b8:	108a9904 	addi	r2,r2,10852
 d0131bc:	10c00017 	ldw	r3,0(r2)
 d0131c0:	e0bffb17 	ldw	r2,-20(fp)
 d0131c4:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 d0131c8:	e0bffb17 	ldw	r2,-20(fp)
 d0131cc:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 d0131d0:	00c34174 	movhi	r3,3333
 d0131d4:	18ca9904 	addi	r3,r3,10852
 d0131d8:	e0bffb17 	ldw	r2,-20(fp)
 d0131dc:	18800015 	stw	r2,0(r3)
 d0131e0:	e0bff817 	ldw	r2,-32(fp)
 d0131e4:	e0bff415 	stw	r2,-48(fp)
 d0131e8:	e0bff417 	ldw	r2,-48(fp)
 d0131ec:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 d0131f0:	e0bffa03 	ldbu	r2,-24(fp)
 d0131f4:	10800058 	cmpnei	r2,r2,1
 d0131f8:	1000011e 	bne	r2,zero,d013200 <OSSemDel+0x24c>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 d0131fc:	d00f0f40 	call	d00f0f4 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 d013200:	e0bffd17 	ldw	r2,-12(fp)
 d013204:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 d013208:	e03ff915 	stw	zero,-28(fp)
             break;
 d01320c:	00000906 	br	d013234 <OSSemDel+0x280>
 d013210:	e0bff817 	ldw	r2,-32(fp)
 d013214:	e0bff315 	stw	r2,-52(fp)
 d013218:	e0bff317 	ldw	r2,-52(fp)
 d01321c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 d013220:	e0fffd17 	ldw	r3,-12(fp)
 d013224:	008001c4 	movi	r2,7
 d013228:	18800005 	stb	r2,0(r3)
             pevent_return          = pevent;
 d01322c:	e0bffb17 	ldw	r2,-20(fp)
 d013230:	e0bff915 	stw	r2,-28(fp)
             break;
    }
    return (pevent_return);
 d013234:	e0bff917 	ldw	r2,-28(fp)
 d013238:	e0bfff15 	stw	r2,-4(fp)
 d01323c:	e0bfff17 	ldw	r2,-4(fp)
}
 d013240:	e037883a 	mov	sp,fp
 d013244:	dfc00117 	ldw	ra,4(sp)
 d013248:	df000017 	ldw	fp,0(sp)
 d01324c:	dec00204 	addi	sp,sp,8
 d013250:	f800283a 	ret

0d013254 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 d013254:	defff404 	addi	sp,sp,-48
 d013258:	dfc00b15 	stw	ra,44(sp)
 d01325c:	df000a15 	stw	fp,40(sp)
 d013260:	df000a04 	addi	fp,sp,40
 d013264:	e13ffc15 	stw	r4,-16(fp)
 d013268:	e1bffe15 	stw	r6,-8(fp)
 d01326c:	e17ffd0d 	sth	r5,-12(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d013270:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d013274:	e0bffe17 	ldw	r2,-8(fp)
 d013278:	1005003a 	cmpeq	r2,r2,zero
 d01327c:	10008f1e 	bne	r2,zero,d0134bc <OSSemPend+0x268>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d013280:	e0bffc17 	ldw	r2,-16(fp)
 d013284:	1004c03a 	cmpne	r2,r2,zero
 d013288:	1000041e 	bne	r2,zero,d01329c <OSSemPend+0x48>
        *perr = OS_ERR_PEVENT_NULL;
 d01328c:	e0fffe17 	ldw	r3,-8(fp)
 d013290:	00800104 	movi	r2,4
 d013294:	18800005 	stb	r2,0(r3)
        return;
 d013298:	00008806 	br	d0134bc <OSSemPend+0x268>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d01329c:	e0bffc17 	ldw	r2,-16(fp)
 d0132a0:	10800003 	ldbu	r2,0(r2)
 d0132a4:	10803fcc 	andi	r2,r2,255
 d0132a8:	108000e0 	cmpeqi	r2,r2,3
 d0132ac:	1000041e 	bne	r2,zero,d0132c0 <OSSemPend+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 d0132b0:	e0fffe17 	ldw	r3,-8(fp)
 d0132b4:	00800044 	movi	r2,1
 d0132b8:	18800005 	stb	r2,0(r3)
        return;
 d0132bc:	00007f06 	br	d0134bc <OSSemPend+0x268>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 d0132c0:	00834174 	movhi	r2,3333
 d0132c4:	108a9a04 	addi	r2,r2,10856
 d0132c8:	10800003 	ldbu	r2,0(r2)
 d0132cc:	10803fcc 	andi	r2,r2,255
 d0132d0:	1005003a 	cmpeq	r2,r2,zero
 d0132d4:	1000041e 	bne	r2,zero,d0132e8 <OSSemPend+0x94>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 d0132d8:	e0fffe17 	ldw	r3,-8(fp)
 d0132dc:	00800084 	movi	r2,2
 d0132e0:	18800005 	stb	r2,0(r3)
        return;
 d0132e4:	00007506 	br	d0134bc <OSSemPend+0x268>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 d0132e8:	00834174 	movhi	r2,3333
 d0132ec:	108a8c04 	addi	r2,r2,10800
 d0132f0:	10800003 	ldbu	r2,0(r2)
 d0132f4:	10803fcc 	andi	r2,r2,255
 d0132f8:	1005003a 	cmpeq	r2,r2,zero
 d0132fc:	1000041e 	bne	r2,zero,d013310 <OSSemPend+0xbc>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 d013300:	e0fffe17 	ldw	r3,-8(fp)
 d013304:	00800344 	movi	r2,13
 d013308:	18800005 	stb	r2,0(r3)
        return;
 d01330c:	00006b06 	br	d0134bc <OSSemPend+0x268>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013310:	0005303a 	rdctl	r2,status
 d013314:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013318:	e0fffa17 	ldw	r3,-24(fp)
 d01331c:	00bfff84 	movi	r2,-2
 d013320:	1884703a 	and	r2,r3,r2
 d013324:	1001703a 	wrctl	status,r2
  
  return context;
 d013328:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 d01332c:	e0bffb15 	stw	r2,-20(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 d013330:	e0bffc17 	ldw	r2,-16(fp)
 d013334:	1080020b 	ldhu	r2,8(r2)
 d013338:	10bfffcc 	andi	r2,r2,65535
 d01333c:	1005003a 	cmpeq	r2,r2,zero
 d013340:	10000d1e 	bne	r2,zero,d013378 <OSSemPend+0x124>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 d013344:	e0bffc17 	ldw	r2,-16(fp)
 d013348:	1080020b 	ldhu	r2,8(r2)
 d01334c:	10bfffc4 	addi	r2,r2,-1
 d013350:	1007883a 	mov	r3,r2
 d013354:	e0bffc17 	ldw	r2,-16(fp)
 d013358:	10c0020d 	sth	r3,8(r2)
 d01335c:	e0bffb17 	ldw	r2,-20(fp)
 d013360:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013364:	e0bff917 	ldw	r2,-28(fp)
 d013368:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 d01336c:	e0bffe17 	ldw	r2,-8(fp)
 d013370:	10000005 	stb	zero,0(r2)
        return;
 d013374:	00005106 	br	d0134bc <OSSemPend+0x268>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 d013378:	00834174 	movhi	r2,3333
 d01337c:	108a9b04 	addi	r2,r2,10860
 d013380:	10c00017 	ldw	r3,0(r2)
 d013384:	00834174 	movhi	r2,3333
 d013388:	108a9b04 	addi	r2,r2,10860
 d01338c:	10800017 	ldw	r2,0(r2)
 d013390:	10800c03 	ldbu	r2,48(r2)
 d013394:	10800054 	ori	r2,r2,1
 d013398:	18800c05 	stb	r2,48(r3)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 d01339c:	00834174 	movhi	r2,3333
 d0133a0:	108a9b04 	addi	r2,r2,10860
 d0133a4:	10800017 	ldw	r2,0(r2)
 d0133a8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 d0133ac:	00834174 	movhi	r2,3333
 d0133b0:	108a9b04 	addi	r2,r2,10860
 d0133b4:	10c00017 	ldw	r3,0(r2)
 d0133b8:	e0bffd0b 	ldhu	r2,-12(fp)
 d0133bc:	18800b8d 	sth	r2,46(r3)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 d0133c0:	e13ffc17 	ldw	r4,-16(fp)
 d0133c4:	d00e8480 	call	d00e848 <OS_EventTaskWait>
 d0133c8:	e0bffb17 	ldw	r2,-20(fp)
 d0133cc:	e0bff815 	stw	r2,-32(fp)
 d0133d0:	e0bff817 	ldw	r2,-32(fp)
 d0133d4:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 d0133d8:	d00f0f40 	call	d00f0f4 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0133dc:	0005303a 	rdctl	r2,status
 d0133e0:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0133e4:	e0fff717 	ldw	r3,-36(fp)
 d0133e8:	00bfff84 	movi	r2,-2
 d0133ec:	1884703a 	and	r2,r3,r2
 d0133f0:	1001703a 	wrctl	status,r2
  
  return context;
 d0133f4:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 d0133f8:	e0bffb15 	stw	r2,-20(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 d0133fc:	00834174 	movhi	r2,3333
 d013400:	108a9b04 	addi	r2,r2,10860
 d013404:	10800017 	ldw	r2,0(r2)
 d013408:	10800c43 	ldbu	r2,49(r2)
 d01340c:	10803fcc 	andi	r2,r2,255
 d013410:	e0bfff15 	stw	r2,-4(fp)
 d013414:	e0ffff17 	ldw	r3,-4(fp)
 d013418:	1805003a 	cmpeq	r2,r3,zero
 d01341c:	1000041e 	bne	r2,zero,d013430 <OSSemPend+0x1dc>
 d013420:	e0ffff17 	ldw	r3,-4(fp)
 d013424:	188000a0 	cmpeqi	r2,r3,2
 d013428:	1000041e 	bne	r2,zero,d01343c <OSSemPend+0x1e8>
 d01342c:	00000706 	br	d01344c <OSSemPend+0x1f8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 d013430:	e0bffe17 	ldw	r2,-8(fp)
 d013434:	10000005 	stb	zero,0(r2)
             break;
 d013438:	00000c06 	br	d01346c <OSSemPend+0x218>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 d01343c:	e0fffe17 	ldw	r3,-8(fp)
 d013440:	00800384 	movi	r2,14
 d013444:	18800005 	stb	r2,0(r3)
             break;
 d013448:	00000806 	br	d01346c <OSSemPend+0x218>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 d01344c:	00834174 	movhi	r2,3333
 d013450:	108a9b04 	addi	r2,r2,10860
 d013454:	11000017 	ldw	r4,0(r2)
 d013458:	e17ffc17 	ldw	r5,-16(fp)
 d01345c:	d00eaac0 	call	d00eaac <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 d013460:	e0fffe17 	ldw	r3,-8(fp)
 d013464:	00800284 	movi	r2,10
 d013468:	18800005 	stb	r2,0(r3)
             break;
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 d01346c:	00834174 	movhi	r2,3333
 d013470:	108a9b04 	addi	r2,r2,10860
 d013474:	10800017 	ldw	r2,0(r2)
 d013478:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 d01347c:	00834174 	movhi	r2,3333
 d013480:	108a9b04 	addi	r2,r2,10860
 d013484:	10800017 	ldw	r2,0(r2)
 d013488:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 d01348c:	00834174 	movhi	r2,3333
 d013490:	108a9b04 	addi	r2,r2,10860
 d013494:	10800017 	ldw	r2,0(r2)
 d013498:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 d01349c:	00834174 	movhi	r2,3333
 d0134a0:	108a9b04 	addi	r2,r2,10860
 d0134a4:	10800017 	ldw	r2,0(r2)
 d0134a8:	10000815 	stw	zero,32(r2)
 d0134ac:	e0bffb17 	ldw	r2,-20(fp)
 d0134b0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0134b4:	e0bff617 	ldw	r2,-40(fp)
 d0134b8:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
}
 d0134bc:	e037883a 	mov	sp,fp
 d0134c0:	dfc00117 	ldw	ra,4(sp)
 d0134c4:	df000017 	ldw	fp,0(sp)
 d0134c8:	dec00204 	addi	sp,sp,8
 d0134cc:	f800283a 	ret

0d0134d0 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 d0134d0:	defff504 	addi	sp,sp,-44
 d0134d4:	dfc00a15 	stw	ra,40(sp)
 d0134d8:	df000915 	stw	fp,36(sp)
 d0134dc:	df000904 	addi	fp,sp,36
 d0134e0:	e13ffc15 	stw	r4,-16(fp)
 d0134e4:	e1bffe15 	stw	r6,-8(fp)
 d0134e8:	e17ffd05 	stb	r5,-12(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0134ec:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d0134f0:	e0bffe17 	ldw	r2,-8(fp)
 d0134f4:	1004c03a 	cmpne	r2,r2,zero
 d0134f8:	1000021e 	bne	r2,zero,d013504 <OSSemPendAbort+0x34>
        return (0);
 d0134fc:	e03fff15 	stw	zero,-4(fp)
 d013500:	00004c06 	br	d013634 <OSSemPendAbort+0x164>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d013504:	e0bffc17 	ldw	r2,-16(fp)
 d013508:	1004c03a 	cmpne	r2,r2,zero
 d01350c:	1000051e 	bne	r2,zero,d013524 <OSSemPendAbort+0x54>
        *perr = OS_ERR_PEVENT_NULL;
 d013510:	e0fffe17 	ldw	r3,-8(fp)
 d013514:	00800104 	movi	r2,4
 d013518:	18800005 	stb	r2,0(r3)
        return (0);
 d01351c:	e03fff15 	stw	zero,-4(fp)
 d013520:	00004406 	br	d013634 <OSSemPendAbort+0x164>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d013524:	e0bffc17 	ldw	r2,-16(fp)
 d013528:	10800003 	ldbu	r2,0(r2)
 d01352c:	10803fcc 	andi	r2,r2,255
 d013530:	108000e0 	cmpeqi	r2,r2,3
 d013534:	1000051e 	bne	r2,zero,d01354c <OSSemPendAbort+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 d013538:	e0fffe17 	ldw	r3,-8(fp)
 d01353c:	00800044 	movi	r2,1
 d013540:	18800005 	stb	r2,0(r3)
        return (0);
 d013544:	e03fff15 	stw	zero,-4(fp)
 d013548:	00003a06 	br	d013634 <OSSemPendAbort+0x164>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01354c:	0005303a 	rdctl	r2,status
 d013550:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013554:	e0fff917 	ldw	r3,-28(fp)
 d013558:	00bfff84 	movi	r2,-2
 d01355c:	1884703a 	and	r2,r3,r2
 d013560:	1001703a 	wrctl	status,r2
  
  return context;
 d013564:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d013568:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 d01356c:	e0bffc17 	ldw	r2,-16(fp)
 d013570:	10800283 	ldbu	r2,10(r2)
 d013574:	10803fcc 	andi	r2,r2,255
 d013578:	1005003a 	cmpeq	r2,r2,zero
 d01357c:	1000261e 	bne	r2,zero,d013618 <OSSemPendAbort+0x148>
        nbr_tasks = 0;
 d013580:	e03ffb05 	stb	zero,-20(fp)
        switch (opt) {
 d013584:	e0bffd03 	ldbu	r2,-12(fp)
 d013588:	10800060 	cmpeqi	r2,r2,1
 d01358c:	1000091e 	bne	r2,zero,d0135b4 <OSSemPendAbort+0xe4>
 d013590:	00000e06 	br	d0135cc <OSSemPendAbort+0xfc>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 d013594:	e13ffc17 	ldw	r4,-16(fp)
 d013598:	000b883a 	mov	r5,zero
 d01359c:	01800044 	movi	r6,1
 d0135a0:	01c00084 	movi	r7,2
 d0135a4:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
                     nbr_tasks++;
 d0135a8:	e0bffb03 	ldbu	r2,-20(fp)
 d0135ac:	10800044 	addi	r2,r2,1
 d0135b0:	e0bffb05 	stb	r2,-20(fp)
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 d0135b4:	e0bffc17 	ldw	r2,-16(fp)
 d0135b8:	10800283 	ldbu	r2,10(r2)
 d0135bc:	10803fcc 	andi	r2,r2,255
 d0135c0:	1004c03a 	cmpne	r2,r2,zero
 d0135c4:	103ff31e 	bne	r2,zero,d013594 <OSSemPendAbort+0xc4>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 d0135c8:	00000806 	br	d0135ec <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 d0135cc:	e13ffc17 	ldw	r4,-16(fp)
 d0135d0:	000b883a 	mov	r5,zero
 d0135d4:	01800044 	movi	r6,1
 d0135d8:	01c00084 	movi	r7,2
 d0135dc:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
                 nbr_tasks++;
 d0135e0:	e0bffb03 	ldbu	r2,-20(fp)
 d0135e4:	10800044 	addi	r2,r2,1
 d0135e8:	e0bffb05 	stb	r2,-20(fp)
 d0135ec:	e0bffa17 	ldw	r2,-24(fp)
 d0135f0:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0135f4:	e0bff817 	ldw	r2,-32(fp)
 d0135f8:	1001703a 	wrctl	status,r2
                 break;
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 d0135fc:	d00f0f40 	call	d00f0f4 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 d013600:	e0fffe17 	ldw	r3,-8(fp)
 d013604:	00800384 	movi	r2,14
 d013608:	18800005 	stb	r2,0(r3)
        return (nbr_tasks);
 d01360c:	e0bffb03 	ldbu	r2,-20(fp)
 d013610:	e0bfff15 	stw	r2,-4(fp)
 d013614:	00000706 	br	d013634 <OSSemPendAbort+0x164>
 d013618:	e0bffa17 	ldw	r2,-24(fp)
 d01361c:	e0bff715 	stw	r2,-36(fp)
 d013620:	e0bff717 	ldw	r2,-36(fp)
 d013624:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d013628:	e0bffe17 	ldw	r2,-8(fp)
 d01362c:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 d013630:	e03fff15 	stw	zero,-4(fp)
 d013634:	e0bfff17 	ldw	r2,-4(fp)
}
 d013638:	e037883a 	mov	sp,fp
 d01363c:	dfc00117 	ldw	ra,4(sp)
 d013640:	df000017 	ldw	fp,0(sp)
 d013644:	dec00204 	addi	sp,sp,8
 d013648:	f800283a 	ret

0d01364c <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 d01364c:	defff704 	addi	sp,sp,-36
 d013650:	dfc00815 	stw	ra,32(sp)
 d013654:	df000715 	stw	fp,28(sp)
 d013658:	df000704 	addi	fp,sp,28
 d01365c:	e13ffe15 	stw	r4,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d013660:	e03ffd15 	stw	zero,-12(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d013664:	e0bffe17 	ldw	r2,-8(fp)
 d013668:	1004c03a 	cmpne	r2,r2,zero
 d01366c:	1000031e 	bne	r2,zero,d01367c <OSSemPost+0x30>
        return (OS_ERR_PEVENT_NULL);
 d013670:	00800104 	movi	r2,4
 d013674:	e0bfff15 	stw	r2,-4(fp)
 d013678:	00003806 	br	d01375c <OSSemPost+0x110>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d01367c:	e0bffe17 	ldw	r2,-8(fp)
 d013680:	10800003 	ldbu	r2,0(r2)
 d013684:	10803fcc 	andi	r2,r2,255
 d013688:	108000e0 	cmpeqi	r2,r2,3
 d01368c:	1000031e 	bne	r2,zero,d01369c <OSSemPost+0x50>
        return (OS_ERR_EVENT_TYPE);
 d013690:	00800044 	movi	r2,1
 d013694:	e0bfff15 	stw	r2,-4(fp)
 d013698:	00003006 	br	d01375c <OSSemPost+0x110>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01369c:	0005303a 	rdctl	r2,status
 d0136a0:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0136a4:	e0fffc17 	ldw	r3,-16(fp)
 d0136a8:	00bfff84 	movi	r2,-2
 d0136ac:	1884703a 	and	r2,r3,r2
 d0136b0:	1001703a 	wrctl	status,r2
  
  return context;
 d0136b4:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 d0136b8:	e0bffd15 	stw	r2,-12(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 d0136bc:	e0bffe17 	ldw	r2,-8(fp)
 d0136c0:	10800283 	ldbu	r2,10(r2)
 d0136c4:	10803fcc 	andi	r2,r2,255
 d0136c8:	1005003a 	cmpeq	r2,r2,zero
 d0136cc:	10000c1e 	bne	r2,zero,d013700 <OSSemPost+0xb4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 d0136d0:	e13ffe17 	ldw	r4,-8(fp)
 d0136d4:	000b883a 	mov	r5,zero
 d0136d8:	01800044 	movi	r6,1
 d0136dc:	000f883a 	mov	r7,zero
 d0136e0:	d00e6b40 	call	d00e6b4 <OS_EventTaskRdy>
 d0136e4:	e0bffd17 	ldw	r2,-12(fp)
 d0136e8:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0136ec:	e0bffb17 	ldw	r2,-20(fp)
 d0136f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 d0136f4:	d00f0f40 	call	d00f0f4 <OS_Sched>
        return (OS_ERR_NONE);
 d0136f8:	e03fff15 	stw	zero,-4(fp)
 d0136fc:	00001706 	br	d01375c <OSSemPost+0x110>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 d013700:	e0bffe17 	ldw	r2,-8(fp)
 d013704:	1080020b 	ldhu	r2,8(r2)
 d013708:	10ffffcc 	andi	r3,r2,65535
 d01370c:	00bfffd4 	movui	r2,65535
 d013710:	18800c26 	beq	r3,r2,d013744 <OSSemPost+0xf8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 d013714:	e0bffe17 	ldw	r2,-8(fp)
 d013718:	1080020b 	ldhu	r2,8(r2)
 d01371c:	10800044 	addi	r2,r2,1
 d013720:	1007883a 	mov	r3,r2
 d013724:	e0bffe17 	ldw	r2,-8(fp)
 d013728:	10c0020d 	sth	r3,8(r2)
 d01372c:	e0bffd17 	ldw	r2,-12(fp)
 d013730:	e0bffa15 	stw	r2,-24(fp)
 d013734:	e0bffa17 	ldw	r2,-24(fp)
 d013738:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 d01373c:	e03fff15 	stw	zero,-4(fp)
 d013740:	00000606 	br	d01375c <OSSemPost+0x110>
 d013744:	e0bffd17 	ldw	r2,-12(fp)
 d013748:	e0bff915 	stw	r2,-28(fp)
 d01374c:	e0bff917 	ldw	r2,-28(fp)
 d013750:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 d013754:	00800c84 	movi	r2,50
 d013758:	e0bfff15 	stw	r2,-4(fp)
 d01375c:	e0bfff17 	ldw	r2,-4(fp)
}
 d013760:	e037883a 	mov	sp,fp
 d013764:	dfc00117 	ldw	ra,4(sp)
 d013768:	df000017 	ldw	fp,0(sp)
 d01376c:	dec00204 	addi	sp,sp,8
 d013770:	f800283a 	ret

0d013774 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 d013774:	defff604 	addi	sp,sp,-40
 d013778:	df000915 	stw	fp,36(sp)
 d01377c:	df000904 	addi	fp,sp,36
 d013780:	e13ffd15 	stw	r4,-12(fp)
 d013784:	e17ffe15 	stw	r5,-8(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 d013788:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 d01378c:	e0bffd17 	ldw	r2,-12(fp)
 d013790:	1004c03a 	cmpne	r2,r2,zero
 d013794:	1000031e 	bne	r2,zero,d0137a4 <OSSemQuery+0x30>
        return (OS_ERR_PEVENT_NULL);
 d013798:	00800104 	movi	r2,4
 d01379c:	e0bfff15 	stw	r2,-4(fp)
 d0137a0:	00003b06 	br	d013890 <OSSemQuery+0x11c>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 d0137a4:	e0bffe17 	ldw	r2,-8(fp)
 d0137a8:	1004c03a 	cmpne	r2,r2,zero
 d0137ac:	1000031e 	bne	r2,zero,d0137bc <OSSemQuery+0x48>
        return (OS_ERR_PDATA_NULL);
 d0137b0:	00800244 	movi	r2,9
 d0137b4:	e0bfff15 	stw	r2,-4(fp)
 d0137b8:	00003506 	br	d013890 <OSSemQuery+0x11c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 d0137bc:	e0bffd17 	ldw	r2,-12(fp)
 d0137c0:	10800003 	ldbu	r2,0(r2)
 d0137c4:	10803fcc 	andi	r2,r2,255
 d0137c8:	108000e0 	cmpeqi	r2,r2,3
 d0137cc:	1000031e 	bne	r2,zero,d0137dc <OSSemQuery+0x68>
        return (OS_ERR_EVENT_TYPE);
 d0137d0:	00800044 	movi	r2,1
 d0137d4:	e0bfff15 	stw	r2,-4(fp)
 d0137d8:	00002d06 	br	d013890 <OSSemQuery+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0137dc:	0005303a 	rdctl	r2,status
 d0137e0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0137e4:	e0fff817 	ldw	r3,-32(fp)
 d0137e8:	00bfff84 	movi	r2,-2
 d0137ec:	1884703a 	and	r2,r3,r2
 d0137f0:	1001703a 	wrctl	status,r2
  
  return context;
 d0137f4:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 d0137f8:	e0bff915 	stw	r2,-28(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 d0137fc:	e0bffd17 	ldw	r2,-12(fp)
 d013800:	10c00283 	ldbu	r3,10(r2)
 d013804:	e0bffe17 	ldw	r2,-8(fp)
 d013808:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 d01380c:	e0bffd17 	ldw	r2,-12(fp)
 d013810:	108002c4 	addi	r2,r2,11
 d013814:	e0bffc15 	stw	r2,-16(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 d013818:	e0bffe17 	ldw	r2,-8(fp)
 d01381c:	10800084 	addi	r2,r2,2
 d013820:	e0bffb15 	stw	r2,-20(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d013824:	e03ffa05 	stb	zero,-24(fp)
 d013828:	00000d06 	br	d013860 <OSSemQuery+0xec>
        *pdest++ = *psrc++;
 d01382c:	e0bffc17 	ldw	r2,-16(fp)
 d013830:	10c00003 	ldbu	r3,0(r2)
 d013834:	e0bffb17 	ldw	r2,-20(fp)
 d013838:	10c00005 	stb	r3,0(r2)
 d01383c:	e0bffb17 	ldw	r2,-20(fp)
 d013840:	10800044 	addi	r2,r2,1
 d013844:	e0bffb15 	stw	r2,-20(fp)
 d013848:	e0bffc17 	ldw	r2,-16(fp)
 d01384c:	10800044 	addi	r2,r2,1
 d013850:	e0bffc15 	stw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 d013854:	e0bffa03 	ldbu	r2,-24(fp)
 d013858:	10800044 	addi	r2,r2,1
 d01385c:	e0bffa05 	stb	r2,-24(fp)
 d013860:	e0bffa03 	ldbu	r2,-24(fp)
 d013864:	108000f0 	cmpltui	r2,r2,3
 d013868:	103ff01e 	bne	r2,zero,d01382c <OSSemQuery+0xb8>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 d01386c:	e0bffd17 	ldw	r2,-12(fp)
 d013870:	10c0020b 	ldhu	r3,8(r2)
 d013874:	e0bffe17 	ldw	r2,-8(fp)
 d013878:	10c0000d 	sth	r3,0(r2)
 d01387c:	e0bff917 	ldw	r2,-28(fp)
 d013880:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013884:	e0bff717 	ldw	r2,-36(fp)
 d013888:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d01388c:	e03fff15 	stw	zero,-4(fp)
 d013890:	e0bfff17 	ldw	r2,-4(fp)
}
 d013894:	e037883a 	mov	sp,fp
 d013898:	df000017 	ldw	fp,0(sp)
 d01389c:	dec00104 	addi	sp,sp,4
 d0138a0:	f800283a 	ret

0d0138a4 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 d0138a4:	defff904 	addi	sp,sp,-28
 d0138a8:	df000615 	stw	fp,24(sp)
 d0138ac:	df000604 	addi	fp,sp,24
 d0138b0:	e13ffd15 	stw	r4,-12(fp)
 d0138b4:	e1bfff15 	stw	r6,-4(fp)
 d0138b8:	e17ffe0d 	sth	r5,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0138bc:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 d0138c0:	e0bfff17 	ldw	r2,-4(fp)
 d0138c4:	1005003a 	cmpeq	r2,r2,zero
 d0138c8:	1000331e 	bne	r2,zero,d013998 <OSSemSet+0xf4>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 d0138cc:	e0bffd17 	ldw	r2,-12(fp)
 d0138d0:	1004c03a 	cmpne	r2,r2,zero
 d0138d4:	1000041e 	bne	r2,zero,d0138e8 <OSSemSet+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 d0138d8:	e0ffff17 	ldw	r3,-4(fp)
 d0138dc:	00800104 	movi	r2,4
 d0138e0:	18800005 	stb	r2,0(r3)
        return;
 d0138e4:	00002c06 	br	d013998 <OSSemSet+0xf4>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 d0138e8:	e0bffd17 	ldw	r2,-12(fp)
 d0138ec:	10800003 	ldbu	r2,0(r2)
 d0138f0:	10803fcc 	andi	r2,r2,255
 d0138f4:	108000e0 	cmpeqi	r2,r2,3
 d0138f8:	1000041e 	bne	r2,zero,d01390c <OSSemSet+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 d0138fc:	e0ffff17 	ldw	r3,-4(fp)
 d013900:	00800044 	movi	r2,1
 d013904:	18800005 	stb	r2,0(r3)
        return;
 d013908:	00002306 	br	d013998 <OSSemSet+0xf4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01390c:	0005303a 	rdctl	r2,status
 d013910:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013914:	e0fffb17 	ldw	r3,-20(fp)
 d013918:	00bfff84 	movi	r2,-2
 d01391c:	1884703a 	and	r2,r3,r2
 d013920:	1001703a 	wrctl	status,r2
  
  return context;
 d013924:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 d013928:	e0bffc15 	stw	r2,-16(fp)
    *perr = OS_ERR_NONE;
 d01392c:	e0bfff17 	ldw	r2,-4(fp)
 d013930:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 d013934:	e0bffd17 	ldw	r2,-12(fp)
 d013938:	1080020b 	ldhu	r2,8(r2)
 d01393c:	10bfffcc 	andi	r2,r2,65535
 d013940:	1005003a 	cmpeq	r2,r2,zero
 d013944:	1000041e 	bne	r2,zero,d013958 <OSSemSet+0xb4>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 d013948:	e0fffd17 	ldw	r3,-12(fp)
 d01394c:	e0bffe0b 	ldhu	r2,-8(fp)
 d013950:	1880020d 	sth	r2,8(r3)
 d013954:	00000c06 	br	d013988 <OSSemSet+0xe4>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 d013958:	e0bffd17 	ldw	r2,-12(fp)
 d01395c:	10800283 	ldbu	r2,10(r2)
 d013960:	10803fcc 	andi	r2,r2,255
 d013964:	1004c03a 	cmpne	r2,r2,zero
 d013968:	1000041e 	bne	r2,zero,d01397c <OSSemSet+0xd8>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 d01396c:	e0fffd17 	ldw	r3,-12(fp)
 d013970:	e0bffe0b 	ldhu	r2,-8(fp)
 d013974:	1880020d 	sth	r2,8(r3)
 d013978:	00000306 	br	d013988 <OSSemSet+0xe4>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 d01397c:	e0ffff17 	ldw	r3,-4(fp)
 d013980:	00801244 	movi	r2,73
 d013984:	18800005 	stb	r2,0(r3)
 d013988:	e0bffc17 	ldw	r2,-16(fp)
 d01398c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013990:	e0bffa17 	ldw	r2,-24(fp)
 d013994:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
}
 d013998:	e037883a 	mov	sp,fp
 d01399c:	df000017 	ldw	fp,0(sp)
 d0139a0:	dec00104 	addi	sp,sp,4
 d0139a4:	f800283a 	ret

0d0139a8 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 d0139a8:	defff004 	addi	sp,sp,-64
 d0139ac:	dfc00f15 	stw	ra,60(sp)
 d0139b0:	df000e15 	stw	fp,56(sp)
 d0139b4:	df000e04 	addi	fp,sp,56
 d0139b8:	e13ffd05 	stb	r4,-12(fp)
 d0139bc:	e17ffe05 	stb	r5,-8(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 d0139c0:	e03ff715 	stw	zero,-36(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 d0139c4:	e0bffd03 	ldbu	r2,-12(fp)
 d0139c8:	10800530 	cmpltui	r2,r2,20
 d0139cc:	1000061e 	bne	r2,zero,d0139e8 <OSTaskChangePrio+0x40>
        if (oldprio != OS_PRIO_SELF) {
 d0139d0:	e0bffd03 	ldbu	r2,-12(fp)
 d0139d4:	10803fe0 	cmpeqi	r2,r2,255
 d0139d8:	1000031e 	bne	r2,zero,d0139e8 <OSTaskChangePrio+0x40>
            return (OS_ERR_PRIO_INVALID);
 d0139dc:	00800a84 	movi	r2,42
 d0139e0:	e0bfff15 	stw	r2,-4(fp)
 d0139e4:	00014706 	br	d013f04 <OSTaskChangePrio+0x55c>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 d0139e8:	e0bffe03 	ldbu	r2,-8(fp)
 d0139ec:	10800530 	cmpltui	r2,r2,20
 d0139f0:	1000031e 	bne	r2,zero,d013a00 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 d0139f4:	00800a84 	movi	r2,42
 d0139f8:	e0bfff15 	stw	r2,-4(fp)
 d0139fc:	00014106 	br	d013f04 <OSTaskChangePrio+0x55c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013a00:	0005303a 	rdctl	r2,status
 d013a04:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013a08:	e0fff617 	ldw	r3,-40(fp)
 d013a0c:	00bfff84 	movi	r2,-2
 d013a10:	1884703a 	and	r2,r3,r2
 d013a14:	1001703a 	wrctl	status,r2
  
  return context;
 d013a18:	e0bff617 	ldw	r2,-40(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d013a1c:	e0bff715 	stw	r2,-36(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 d013a20:	e0bffe03 	ldbu	r2,-8(fp)
 d013a24:	00c341b4 	movhi	r3,3334
 d013a28:	18f13304 	addi	r3,r3,-15156
 d013a2c:	1085883a 	add	r2,r2,r2
 d013a30:	1085883a 	add	r2,r2,r2
 d013a34:	10c5883a 	add	r2,r2,r3
 d013a38:	10800017 	ldw	r2,0(r2)
 d013a3c:	1005003a 	cmpeq	r2,r2,zero
 d013a40:	1000071e 	bne	r2,zero,d013a60 <OSTaskChangePrio+0xb8>
 d013a44:	e0bff717 	ldw	r2,-36(fp)
 d013a48:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013a4c:	e0bff517 	ldw	r2,-44(fp)
 d013a50:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 d013a54:	00800a04 	movi	r2,40
 d013a58:	e0bfff15 	stw	r2,-4(fp)
 d013a5c:	00012906 	br	d013f04 <OSTaskChangePrio+0x55c>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 d013a60:	e0bffd03 	ldbu	r2,-12(fp)
 d013a64:	10803fd8 	cmpnei	r2,r2,255
 d013a68:	1000051e 	bne	r2,zero,d013a80 <OSTaskChangePrio+0xd8>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 d013a6c:	00834174 	movhi	r2,3333
 d013a70:	108a9b04 	addi	r2,r2,10860
 d013a74:	10800017 	ldw	r2,0(r2)
 d013a78:	10800c83 	ldbu	r2,50(r2)
 d013a7c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 d013a80:	e0bffd03 	ldbu	r2,-12(fp)
 d013a84:	00c341b4 	movhi	r3,3334
 d013a88:	18f13304 	addi	r3,r3,-15156
 d013a8c:	1085883a 	add	r2,r2,r2
 d013a90:	1085883a 	add	r2,r2,r2
 d013a94:	10c5883a 	add	r2,r2,r3
 d013a98:	10800017 	ldw	r2,0(r2)
 d013a9c:	e0bffa15 	stw	r2,-24(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 d013aa0:	e0bffa17 	ldw	r2,-24(fp)
 d013aa4:	1004c03a 	cmpne	r2,r2,zero
 d013aa8:	1000071e 	bne	r2,zero,d013ac8 <OSTaskChangePrio+0x120>
 d013aac:	e0bff717 	ldw	r2,-36(fp)
 d013ab0:	e0bff415 	stw	r2,-48(fp)
 d013ab4:	e0bff417 	ldw	r2,-48(fp)
 d013ab8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 d013abc:	00800a44 	movi	r2,41
 d013ac0:	e0bfff15 	stw	r2,-4(fp)
 d013ac4:	00010f06 	br	d013f04 <OSTaskChangePrio+0x55c>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 d013ac8:	e0bffa17 	ldw	r2,-24(fp)
 d013acc:	10800058 	cmpnei	r2,r2,1
 d013ad0:	1000071e 	bne	r2,zero,d013af0 <OSTaskChangePrio+0x148>
 d013ad4:	e0bff717 	ldw	r2,-36(fp)
 d013ad8:	e0bff315 	stw	r2,-52(fp)
 d013adc:	e0bff317 	ldw	r2,-52(fp)
 d013ae0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 d013ae4:	008010c4 	movi	r2,67
 d013ae8:	e0bfff15 	stw	r2,-4(fp)
 d013aec:	00010506 	br	d013f04 <OSTaskChangePrio+0x55c>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 d013af0:	e0bffe03 	ldbu	r2,-8(fp)
 d013af4:	1004d0fa 	srli	r2,r2,3
 d013af8:	e0bff985 	stb	r2,-26(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 d013afc:	e0bffe03 	ldbu	r2,-8(fp)
 d013b00:	108001cc 	andi	r2,r2,7
 d013b04:	e0bff945 	stb	r2,-27(fp)
    bity_new              = (INT8U)(1 << y_new);
 d013b08:	e0fff983 	ldbu	r3,-26(fp)
 d013b0c:	00800044 	movi	r2,1
 d013b10:	10c4983a 	sll	r2,r2,r3
 d013b14:	e0bff8c5 	stb	r2,-29(fp)
    bitx_new              = (INT8U)(1 << x_new);
 d013b18:	e0fff943 	ldbu	r3,-27(fp)
 d013b1c:	00800044 	movi	r2,1
 d013b20:	10c4983a 	sll	r2,r2,r3
 d013b24:	e0bff885 	stb	r2,-30(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 d013b28:	e0bffd03 	ldbu	r2,-12(fp)
 d013b2c:	00c341b4 	movhi	r3,3334
 d013b30:	18f13304 	addi	r3,r3,-15156
 d013b34:	1085883a 	add	r2,r2,r2
 d013b38:	1085883a 	add	r2,r2,r2
 d013b3c:	10c5883a 	add	r2,r2,r3
 d013b40:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 d013b44:	e0bffe03 	ldbu	r2,-8(fp)
 d013b48:	00c341b4 	movhi	r3,3334
 d013b4c:	18f13304 	addi	r3,r3,-15156
 d013b50:	1085883a 	add	r2,r2,r2
 d013b54:	1085883a 	add	r2,r2,r2
 d013b58:	10c7883a 	add	r3,r2,r3
 d013b5c:	e0bffa17 	ldw	r2,-24(fp)
 d013b60:	18800015 	stw	r2,0(r3)
    y_old                 =  ptcb->OSTCBY;
 d013b64:	e0bffa17 	ldw	r2,-24(fp)
 d013b68:	10800d03 	ldbu	r2,52(r2)
 d013b6c:	e0bff905 	stb	r2,-28(fp)
    bity_old              =  ptcb->OSTCBBitY;
 d013b70:	e0bffa17 	ldw	r2,-24(fp)
 d013b74:	10800d83 	ldbu	r2,54(r2)
 d013b78:	e0bff845 	stb	r2,-31(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 d013b7c:	e0bffa17 	ldw	r2,-24(fp)
 d013b80:	10800d43 	ldbu	r2,53(r2)
 d013b84:	e0bff805 	stb	r2,-32(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 d013b88:	e0fff903 	ldbu	r3,-28(fp)
 d013b8c:	00834174 	movhi	r2,3333
 d013b90:	108a9844 	addi	r2,r2,10849
 d013b94:	10c5883a 	add	r2,r2,r3
 d013b98:	10c00003 	ldbu	r3,0(r2)
 d013b9c:	e0bff803 	ldbu	r2,-32(fp)
 d013ba0:	1884703a 	and	r2,r3,r2
 d013ba4:	10803fcc 	andi	r2,r2,255
 d013ba8:	1005003a 	cmpeq	r2,r2,zero
 d013bac:	1000381e 	bne	r2,zero,d013c90 <OSTaskChangePrio+0x2e8>
         OSRdyTbl[y_old] &= ~bitx_old;
 d013bb0:	e13ff903 	ldbu	r4,-28(fp)
 d013bb4:	e0fff903 	ldbu	r3,-28(fp)
 d013bb8:	00834174 	movhi	r2,3333
 d013bbc:	108a9844 	addi	r2,r2,10849
 d013bc0:	10c5883a 	add	r2,r2,r3
 d013bc4:	10800003 	ldbu	r2,0(r2)
 d013bc8:	1007883a 	mov	r3,r2
 d013bcc:	e0bff803 	ldbu	r2,-32(fp)
 d013bd0:	0084303a 	nor	r2,zero,r2
 d013bd4:	1884703a 	and	r2,r3,r2
 d013bd8:	1007883a 	mov	r3,r2
 d013bdc:	00834174 	movhi	r2,3333
 d013be0:	108a9844 	addi	r2,r2,10849
 d013be4:	1105883a 	add	r2,r2,r4
 d013be8:	10c00005 	stb	r3,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 d013bec:	e0fff903 	ldbu	r3,-28(fp)
 d013bf0:	00834174 	movhi	r2,3333
 d013bf4:	108a9844 	addi	r2,r2,10849
 d013bf8:	10c5883a 	add	r2,r2,r3
 d013bfc:	10800003 	ldbu	r2,0(r2)
 d013c00:	10803fcc 	andi	r2,r2,255
 d013c04:	1004c03a 	cmpne	r2,r2,zero
 d013c08:	10000b1e 	bne	r2,zero,d013c38 <OSTaskChangePrio+0x290>
             OSRdyGrp &= ~bity_old;
 d013c0c:	e0bff843 	ldbu	r2,-31(fp)
 d013c10:	0084303a 	nor	r2,zero,r2
 d013c14:	1007883a 	mov	r3,r2
 d013c18:	00834174 	movhi	r2,3333
 d013c1c:	108a9804 	addi	r2,r2,10848
 d013c20:	10800003 	ldbu	r2,0(r2)
 d013c24:	1884703a 	and	r2,r3,r2
 d013c28:	1007883a 	mov	r3,r2
 d013c2c:	00834174 	movhi	r2,3333
 d013c30:	108a9804 	addi	r2,r2,10848
 d013c34:	10c00005 	stb	r3,0(r2)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 d013c38:	00834174 	movhi	r2,3333
 d013c3c:	108a9804 	addi	r2,r2,10848
 d013c40:	10c00003 	ldbu	r3,0(r2)
 d013c44:	e0bff8c3 	ldbu	r2,-29(fp)
 d013c48:	1884b03a 	or	r2,r3,r2
 d013c4c:	1007883a 	mov	r3,r2
 d013c50:	00834174 	movhi	r2,3333
 d013c54:	108a9804 	addi	r2,r2,10848
 d013c58:	10c00005 	stb	r3,0(r2)
         OSRdyTbl[y_new] |= bitx_new;
 d013c5c:	e13ff983 	ldbu	r4,-26(fp)
 d013c60:	e0fff983 	ldbu	r3,-26(fp)
 d013c64:	00834174 	movhi	r2,3333
 d013c68:	108a9844 	addi	r2,r2,10849
 d013c6c:	10c5883a 	add	r2,r2,r3
 d013c70:	10c00003 	ldbu	r3,0(r2)
 d013c74:	e0bff883 	ldbu	r2,-30(fp)
 d013c78:	1884b03a 	or	r2,r3,r2
 d013c7c:	1007883a 	mov	r3,r2
 d013c80:	00834174 	movhi	r2,3333
 d013c84:	108a9844 	addi	r2,r2,10849
 d013c88:	1105883a 	add	r2,r2,r4
 d013c8c:	10c00005 	stb	r3,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 d013c90:	e0bffa17 	ldw	r2,-24(fp)
 d013c94:	10800717 	ldw	r2,28(r2)
 d013c98:	e0bffc15 	stw	r2,-16(fp)
    if (pevent != (OS_EVENT *)0) {
 d013c9c:	e0bffc17 	ldw	r2,-16(fp)
 d013ca0:	1005003a 	cmpeq	r2,r2,zero
 d013ca4:	1000341e 	bne	r2,zero,d013d78 <OSTaskChangePrio+0x3d0>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 d013ca8:	e13ff903 	ldbu	r4,-28(fp)
 d013cac:	e0fff903 	ldbu	r3,-28(fp)
 d013cb0:	e0bffc17 	ldw	r2,-16(fp)
 d013cb4:	1885883a 	add	r2,r3,r2
 d013cb8:	10800204 	addi	r2,r2,8
 d013cbc:	108000c3 	ldbu	r2,3(r2)
 d013cc0:	1007883a 	mov	r3,r2
 d013cc4:	e0bff803 	ldbu	r2,-32(fp)
 d013cc8:	0084303a 	nor	r2,zero,r2
 d013ccc:	1884703a 	and	r2,r3,r2
 d013cd0:	1007883a 	mov	r3,r2
 d013cd4:	e0bffc17 	ldw	r2,-16(fp)
 d013cd8:	2085883a 	add	r2,r4,r2
 d013cdc:	10800204 	addi	r2,r2,8
 d013ce0:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 d013ce4:	e0fff903 	ldbu	r3,-28(fp)
 d013ce8:	e0bffc17 	ldw	r2,-16(fp)
 d013cec:	1885883a 	add	r2,r3,r2
 d013cf0:	10800204 	addi	r2,r2,8
 d013cf4:	108000c3 	ldbu	r2,3(r2)
 d013cf8:	10803fcc 	andi	r2,r2,255
 d013cfc:	1004c03a 	cmpne	r2,r2,zero
 d013d00:	1000091e 	bne	r2,zero,d013d28 <OSTaskChangePrio+0x380>
            pevent->OSEventGrp    &= ~bity_old;
 d013d04:	e0bffc17 	ldw	r2,-16(fp)
 d013d08:	10800283 	ldbu	r2,10(r2)
 d013d0c:	1007883a 	mov	r3,r2
 d013d10:	e0bff843 	ldbu	r2,-31(fp)
 d013d14:	0084303a 	nor	r2,zero,r2
 d013d18:	1884703a 	and	r2,r3,r2
 d013d1c:	1007883a 	mov	r3,r2
 d013d20:	e0bffc17 	ldw	r2,-16(fp)
 d013d24:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 d013d28:	e0bffc17 	ldw	r2,-16(fp)
 d013d2c:	10c00283 	ldbu	r3,10(r2)
 d013d30:	e0bff8c3 	ldbu	r2,-29(fp)
 d013d34:	1884b03a 	or	r2,r3,r2
 d013d38:	1007883a 	mov	r3,r2
 d013d3c:	e0bffc17 	ldw	r2,-16(fp)
 d013d40:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 d013d44:	e13ff983 	ldbu	r4,-26(fp)
 d013d48:	e0fff983 	ldbu	r3,-26(fp)
 d013d4c:	e0bffc17 	ldw	r2,-16(fp)
 d013d50:	1885883a 	add	r2,r3,r2
 d013d54:	10800204 	addi	r2,r2,8
 d013d58:	10c000c3 	ldbu	r3,3(r2)
 d013d5c:	e0bff883 	ldbu	r2,-30(fp)
 d013d60:	1884b03a 	or	r2,r3,r2
 d013d64:	1007883a 	mov	r3,r2
 d013d68:	e0bffc17 	ldw	r2,-16(fp)
 d013d6c:	2085883a 	add	r2,r4,r2
 d013d70:	10800204 	addi	r2,r2,8
 d013d74:	10c000c5 	stb	r3,3(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 d013d78:	e0bffa17 	ldw	r2,-24(fp)
 d013d7c:	10800817 	ldw	r2,32(r2)
 d013d80:	1005003a 	cmpeq	r2,r2,zero
 d013d84:	1000441e 	bne	r2,zero,d013e98 <OSTaskChangePrio+0x4f0>
        pevents =  ptcb->OSTCBEventMultiPtr;
 d013d88:	e0bffa17 	ldw	r2,-24(fp)
 d013d8c:	10800817 	ldw	r2,32(r2)
 d013d90:	e0bffb15 	stw	r2,-20(fp)
        pevent  = *pevents;
 d013d94:	e0bffb17 	ldw	r2,-20(fp)
 d013d98:	10800017 	ldw	r2,0(r2)
 d013d9c:	e0bffc15 	stw	r2,-16(fp)
        while (pevent != (OS_EVENT *)0) {
 d013da0:	00003a06 	br	d013e8c <OSTaskChangePrio+0x4e4>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 d013da4:	e13ff903 	ldbu	r4,-28(fp)
 d013da8:	e0fff903 	ldbu	r3,-28(fp)
 d013dac:	e0bffc17 	ldw	r2,-16(fp)
 d013db0:	1885883a 	add	r2,r3,r2
 d013db4:	10800204 	addi	r2,r2,8
 d013db8:	108000c3 	ldbu	r2,3(r2)
 d013dbc:	1007883a 	mov	r3,r2
 d013dc0:	e0bff803 	ldbu	r2,-32(fp)
 d013dc4:	0084303a 	nor	r2,zero,r2
 d013dc8:	1884703a 	and	r2,r3,r2
 d013dcc:	1007883a 	mov	r3,r2
 d013dd0:	e0bffc17 	ldw	r2,-16(fp)
 d013dd4:	2085883a 	add	r2,r4,r2
 d013dd8:	10800204 	addi	r2,r2,8
 d013ddc:	10c000c5 	stb	r3,3(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 d013de0:	e0fff903 	ldbu	r3,-28(fp)
 d013de4:	e0bffc17 	ldw	r2,-16(fp)
 d013de8:	1885883a 	add	r2,r3,r2
 d013dec:	10800204 	addi	r2,r2,8
 d013df0:	108000c3 	ldbu	r2,3(r2)
 d013df4:	10803fcc 	andi	r2,r2,255
 d013df8:	1004c03a 	cmpne	r2,r2,zero
 d013dfc:	1000091e 	bne	r2,zero,d013e24 <OSTaskChangePrio+0x47c>
                pevent->OSEventGrp    &= ~bity_old;
 d013e00:	e0bffc17 	ldw	r2,-16(fp)
 d013e04:	10800283 	ldbu	r2,10(r2)
 d013e08:	1007883a 	mov	r3,r2
 d013e0c:	e0bff843 	ldbu	r2,-31(fp)
 d013e10:	0084303a 	nor	r2,zero,r2
 d013e14:	1884703a 	and	r2,r3,r2
 d013e18:	1007883a 	mov	r3,r2
 d013e1c:	e0bffc17 	ldw	r2,-16(fp)
 d013e20:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 d013e24:	e0bffc17 	ldw	r2,-16(fp)
 d013e28:	10c00283 	ldbu	r3,10(r2)
 d013e2c:	e0bff8c3 	ldbu	r2,-29(fp)
 d013e30:	1884b03a 	or	r2,r3,r2
 d013e34:	1007883a 	mov	r3,r2
 d013e38:	e0bffc17 	ldw	r2,-16(fp)
 d013e3c:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 d013e40:	e13ff983 	ldbu	r4,-26(fp)
 d013e44:	e0fff983 	ldbu	r3,-26(fp)
 d013e48:	e0bffc17 	ldw	r2,-16(fp)
 d013e4c:	1885883a 	add	r2,r3,r2
 d013e50:	10800204 	addi	r2,r2,8
 d013e54:	10c000c3 	ldbu	r3,3(r2)
 d013e58:	e0bff883 	ldbu	r2,-30(fp)
 d013e5c:	1884b03a 	or	r2,r3,r2
 d013e60:	1007883a 	mov	r3,r2
 d013e64:	e0bffc17 	ldw	r2,-16(fp)
 d013e68:	2085883a 	add	r2,r4,r2
 d013e6c:	10800204 	addi	r2,r2,8
 d013e70:	10c000c5 	stb	r3,3(r2)
            pevents++;
 d013e74:	e0bffb17 	ldw	r2,-20(fp)
 d013e78:	10800104 	addi	r2,r2,4
 d013e7c:	e0bffb15 	stw	r2,-20(fp)
            pevent                     = *pevents;
 d013e80:	e0bffb17 	ldw	r2,-20(fp)
 d013e84:	10800017 	ldw	r2,0(r2)
 d013e88:	e0bffc15 	stw	r2,-16(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 d013e8c:	e0bffc17 	ldw	r2,-16(fp)
 d013e90:	1004c03a 	cmpne	r2,r2,zero
 d013e94:	103fc31e 	bne	r2,zero,d013da4 <OSTaskChangePrio+0x3fc>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 d013e98:	e0fffa17 	ldw	r3,-24(fp)
 d013e9c:	e0bffe03 	ldbu	r2,-8(fp)
 d013ea0:	18800c85 	stb	r2,50(r3)
    ptcb->OSTCBY    = y_new;
 d013ea4:	e0fffa17 	ldw	r3,-24(fp)
 d013ea8:	e0bff983 	ldbu	r2,-26(fp)
 d013eac:	18800d05 	stb	r2,52(r3)
    ptcb->OSTCBX    = x_new;
 d013eb0:	e0fffa17 	ldw	r3,-24(fp)
 d013eb4:	e0bff943 	ldbu	r2,-27(fp)
 d013eb8:	18800cc5 	stb	r2,51(r3)
    ptcb->OSTCBBitY = bity_new;
 d013ebc:	e0fffa17 	ldw	r3,-24(fp)
 d013ec0:	e0bff8c3 	ldbu	r2,-29(fp)
 d013ec4:	18800d85 	stb	r2,54(r3)
    ptcb->OSTCBBitX = bitx_new;
 d013ec8:	e0fffa17 	ldw	r3,-24(fp)
 d013ecc:	e0bff883 	ldbu	r2,-30(fp)
 d013ed0:	18800d45 	stb	r2,53(r3)
 d013ed4:	e0bff717 	ldw	r2,-36(fp)
 d013ed8:	e0bff215 	stw	r2,-56(fp)
 d013edc:	e0bff217 	ldw	r2,-56(fp)
 d013ee0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 d013ee4:	00834174 	movhi	r2,3333
 d013ee8:	108a8c44 	addi	r2,r2,10801
 d013eec:	10800003 	ldbu	r2,0(r2)
 d013ef0:	10803fcc 	andi	r2,r2,255
 d013ef4:	10800058 	cmpnei	r2,r2,1
 d013ef8:	1000011e 	bne	r2,zero,d013f00 <OSTaskChangePrio+0x558>
        OS_Sched();                                         /* Find new highest priority task          */
 d013efc:	d00f0f40 	call	d00f0f4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 d013f00:	e03fff15 	stw	zero,-4(fp)
 d013f04:	e0bfff17 	ldw	r2,-4(fp)
}
 d013f08:	e037883a 	mov	sp,fp
 d013f0c:	dfc00117 	ldw	ra,4(sp)
 d013f10:	df000017 	ldw	fp,0(sp)
 d013f14:	dec00204 	addi	sp,sp,8
 d013f18:	f800283a 	ret

0d013f1c <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 d013f1c:	deffed04 	addi	sp,sp,-76
 d013f20:	dfc01215 	stw	ra,72(sp)
 d013f24:	df001115 	stw	fp,68(sp)
 d013f28:	df001104 	addi	fp,sp,68
 d013f2c:	e13ffb15 	stw	r4,-20(fp)
 d013f30:	e17ffc15 	stw	r5,-16(fp)
 d013f34:	e1bffd15 	stw	r6,-12(fp)
 d013f38:	e1fffe05 	stb	r7,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 d013f3c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 d013f40:	e0bffe03 	ldbu	r2,-8(fp)
 d013f44:	10800570 	cmpltui	r2,r2,21
 d013f48:	1000031e 	bne	r2,zero,d013f58 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 d013f4c:	00800a84 	movi	r2,42
 d013f50:	e0bfff15 	stw	r2,-4(fp)
 d013f54:	00006006 	br	d0140d8 <OSTaskCreate+0x1bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d013f58:	0005303a 	rdctl	r2,status
 d013f5c:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d013f60:	e0fff717 	ldw	r3,-36(fp)
 d013f64:	00bfff84 	movi	r2,-2
 d013f68:	1884703a 	and	r2,r3,r2
 d013f6c:	1001703a 	wrctl	status,r2
  
  return context;
 d013f70:	e0bff717 	ldw	r2,-36(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d013f74:	e0bff815 	stw	r2,-32(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 d013f78:	00834174 	movhi	r2,3333
 d013f7c:	108a9a04 	addi	r2,r2,10856
 d013f80:	10800003 	ldbu	r2,0(r2)
 d013f84:	10803fcc 	andi	r2,r2,255
 d013f88:	1005003a 	cmpeq	r2,r2,zero
 d013f8c:	1000071e 	bne	r2,zero,d013fac <OSTaskCreate+0x90>
 d013f90:	e0bff817 	ldw	r2,-32(fp)
 d013f94:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d013f98:	e0bff617 	ldw	r2,-40(fp)
 d013f9c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 d013fa0:	00800f04 	movi	r2,60
 d013fa4:	e0bfff15 	stw	r2,-4(fp)
 d013fa8:	00004b06 	br	d0140d8 <OSTaskCreate+0x1bc>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 d013fac:	e0bffe03 	ldbu	r2,-8(fp)
 d013fb0:	00c341b4 	movhi	r3,3334
 d013fb4:	18f13304 	addi	r3,r3,-15156
 d013fb8:	1085883a 	add	r2,r2,r2
 d013fbc:	1085883a 	add	r2,r2,r2
 d013fc0:	10c5883a 	add	r2,r2,r3
 d013fc4:	10800017 	ldw	r2,0(r2)
 d013fc8:	1004c03a 	cmpne	r2,r2,zero
 d013fcc:	10003c1e 	bne	r2,zero,d0140c0 <OSTaskCreate+0x1a4>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 d013fd0:	e0bffe03 	ldbu	r2,-8(fp)
 d013fd4:	00c341b4 	movhi	r3,3334
 d013fd8:	18f13304 	addi	r3,r3,-15156
 d013fdc:	1085883a 	add	r2,r2,r2
 d013fe0:	1085883a 	add	r2,r2,r2
 d013fe4:	10c7883a 	add	r3,r2,r3
 d013fe8:	00800044 	movi	r2,1
 d013fec:	18800015 	stw	r2,0(r3)
 d013ff0:	e0bff817 	ldw	r2,-32(fp)
 d013ff4:	e0bff515 	stw	r2,-44(fp)
 d013ff8:	e0bff517 	ldw	r2,-44(fp)
 d013ffc:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 d014000:	e13ffb17 	ldw	r4,-20(fp)
 d014004:	e17ffc17 	ldw	r5,-16(fp)
 d014008:	e1bffd17 	ldw	r6,-12(fp)
 d01400c:	000f883a 	mov	r7,zero
 d014010:	d039c580 	call	d039c58 <OSTaskStkInit>
 d014014:	e0bffa15 	stw	r2,-24(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 d014018:	e13ffe03 	ldbu	r4,-8(fp)
 d01401c:	d8000015 	stw	zero,0(sp)
 d014020:	d8000115 	stw	zero,4(sp)
 d014024:	d8000215 	stw	zero,8(sp)
 d014028:	e17ffa17 	ldw	r5,-24(fp)
 d01402c:	000d883a 	mov	r6,zero
 d014030:	000f883a 	mov	r7,zero
 d014034:	d00f4fc0 	call	d00f4fc <OS_TCBInit>
 d014038:	e0bff905 	stb	r2,-28(fp)
        if (err == OS_ERR_NONE) {
 d01403c:	e0bff903 	ldbu	r2,-28(fp)
 d014040:	1004c03a 	cmpne	r2,r2,zero
 d014044:	1000081e 	bne	r2,zero,d014068 <OSTaskCreate+0x14c>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 d014048:	00834174 	movhi	r2,3333
 d01404c:	108a8c44 	addi	r2,r2,10801
 d014050:	10800003 	ldbu	r2,0(r2)
 d014054:	10803fcc 	andi	r2,r2,255
 d014058:	10800058 	cmpnei	r2,r2,1
 d01405c:	1000151e 	bne	r2,zero,d0140b4 <OSTaskCreate+0x198>
                OS_Sched();
 d014060:	d00f0f40 	call	d00f0f4 <OS_Sched>
 d014064:	00001306 	br	d0140b4 <OSTaskCreate+0x198>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014068:	0005303a 	rdctl	r2,status
 d01406c:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014070:	e0fff417 	ldw	r3,-48(fp)
 d014074:	00bfff84 	movi	r2,-2
 d014078:	1884703a 	and	r2,r3,r2
 d01407c:	1001703a 	wrctl	status,r2
  
  return context;
 d014080:	e0bff417 	ldw	r2,-48(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 d014084:	e0bff815 	stw	r2,-32(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 d014088:	e0bffe03 	ldbu	r2,-8(fp)
 d01408c:	00c341b4 	movhi	r3,3334
 d014090:	18f13304 	addi	r3,r3,-15156
 d014094:	1085883a 	add	r2,r2,r2
 d014098:	1085883a 	add	r2,r2,r2
 d01409c:	10c5883a 	add	r2,r2,r3
 d0140a0:	10000015 	stw	zero,0(r2)
 d0140a4:	e0bff817 	ldw	r2,-32(fp)
 d0140a8:	e0bff315 	stw	r2,-52(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0140ac:	e0bff317 	ldw	r2,-52(fp)
 d0140b0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 d0140b4:	e0bff903 	ldbu	r2,-28(fp)
 d0140b8:	e0bfff15 	stw	r2,-4(fp)
 d0140bc:	00000606 	br	d0140d8 <OSTaskCreate+0x1bc>
 d0140c0:	e0bff817 	ldw	r2,-32(fp)
 d0140c4:	e0bff215 	stw	r2,-56(fp)
 d0140c8:	e0bff217 	ldw	r2,-56(fp)
 d0140cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 d0140d0:	00800a04 	movi	r2,40
 d0140d4:	e0bfff15 	stw	r2,-4(fp)
 d0140d8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0140dc:	e037883a 	mov	sp,fp
 d0140e0:	dfc00117 	ldw	ra,4(sp)
 d0140e4:	df000017 	ldw	fp,0(sp)
 d0140e8:	dec00204 	addi	sp,sp,8
 d0140ec:	f800283a 	ret

0d0140f0 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 d0140f0:	deffeb04 	addi	sp,sp,-84
 d0140f4:	dfc01415 	stw	ra,80(sp)
 d0140f8:	df001315 	stw	fp,76(sp)
 d0140fc:	df001304 	addi	fp,sp,76
 d014100:	e13ff915 	stw	r4,-28(fp)
 d014104:	e17ffa15 	stw	r5,-24(fp)
 d014108:	e1bffb15 	stw	r6,-20(fp)
 d01410c:	e0800217 	ldw	r2,8(fp)
 d014110:	e0c00617 	ldw	r3,24(fp)
 d014114:	e1fffc05 	stb	r7,-16(fp)
 d014118:	e0bffd0d 	sth	r2,-12(fp)
 d01411c:	e0fffe0d 	sth	r3,-8(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 d014120:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 d014124:	e0bffc03 	ldbu	r2,-16(fp)
 d014128:	10800570 	cmpltui	r2,r2,21
 d01412c:	1000031e 	bne	r2,zero,d01413c <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 d014130:	00800a84 	movi	r2,42
 d014134:	e0bfff15 	stw	r2,-4(fp)
 d014138:	00006706 	br	d0142d8 <OSTaskCreateExt+0x1e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01413c:	0005303a 	rdctl	r2,status
 d014140:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014144:	e0fff517 	ldw	r3,-44(fp)
 d014148:	00bfff84 	movi	r2,-2
 d01414c:	1884703a 	and	r2,r3,r2
 d014150:	1001703a 	wrctl	status,r2
  
  return context;
 d014154:	e0bff517 	ldw	r2,-44(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d014158:	e0bff615 	stw	r2,-40(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 d01415c:	00834174 	movhi	r2,3333
 d014160:	108a9a04 	addi	r2,r2,10856
 d014164:	10800003 	ldbu	r2,0(r2)
 d014168:	10803fcc 	andi	r2,r2,255
 d01416c:	1005003a 	cmpeq	r2,r2,zero
 d014170:	1000071e 	bne	r2,zero,d014190 <OSTaskCreateExt+0xa0>
 d014174:	e0bff617 	ldw	r2,-40(fp)
 d014178:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01417c:	e0bff417 	ldw	r2,-48(fp)
 d014180:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 d014184:	00800f04 	movi	r2,60
 d014188:	e0bfff15 	stw	r2,-4(fp)
 d01418c:	00005206 	br	d0142d8 <OSTaskCreateExt+0x1e8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 d014190:	e0bffc03 	ldbu	r2,-16(fp)
 d014194:	00c341b4 	movhi	r3,3334
 d014198:	18f13304 	addi	r3,r3,-15156
 d01419c:	1085883a 	add	r2,r2,r2
 d0141a0:	1085883a 	add	r2,r2,r2
 d0141a4:	10c5883a 	add	r2,r2,r3
 d0141a8:	10800017 	ldw	r2,0(r2)
 d0141ac:	1004c03a 	cmpne	r2,r2,zero
 d0141b0:	1000431e 	bne	r2,zero,d0142c0 <OSTaskCreateExt+0x1d0>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 d0141b4:	e0bffc03 	ldbu	r2,-16(fp)
 d0141b8:	00c341b4 	movhi	r3,3334
 d0141bc:	18f13304 	addi	r3,r3,-15156
 d0141c0:	1085883a 	add	r2,r2,r2
 d0141c4:	1085883a 	add	r2,r2,r2
 d0141c8:	10c7883a 	add	r3,r2,r3
 d0141cc:	00800044 	movi	r2,1
 d0141d0:	18800015 	stw	r2,0(r3)
 d0141d4:	e0bff617 	ldw	r2,-40(fp)
 d0141d8:	e0bff315 	stw	r2,-52(fp)
 d0141dc:	e0bff317 	ldw	r2,-52(fp)
 d0141e0:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 d0141e4:	e1bffe0b 	ldhu	r6,-8(fp)
 d0141e8:	e1000317 	ldw	r4,12(fp)
 d0141ec:	e1400417 	ldw	r5,16(fp)
 d0141f0:	d01536c0 	call	d01536c <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 d0141f4:	e1fffe0b 	ldhu	r7,-8(fp)
 d0141f8:	e13ff917 	ldw	r4,-28(fp)
 d0141fc:	e17ffa17 	ldw	r5,-24(fp)
 d014200:	e1bffb17 	ldw	r6,-20(fp)
 d014204:	d039c580 	call	d039c58 <OSTaskStkInit>
 d014208:	e0bff815 	stw	r2,-32(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 d01420c:	e13ffc03 	ldbu	r4,-16(fp)
 d014210:	e1fffd0b 	ldhu	r7,-12(fp)
 d014214:	e0fffe0b 	ldhu	r3,-8(fp)
 d014218:	e0800417 	ldw	r2,16(fp)
 d01421c:	d8800015 	stw	r2,0(sp)
 d014220:	e0800517 	ldw	r2,20(fp)
 d014224:	d8800115 	stw	r2,4(sp)
 d014228:	d8c00215 	stw	r3,8(sp)
 d01422c:	e17ff817 	ldw	r5,-32(fp)
 d014230:	e1800317 	ldw	r6,12(fp)
 d014234:	d00f4fc0 	call	d00f4fc <OS_TCBInit>
 d014238:	e0bff705 	stb	r2,-36(fp)
        if (err == OS_ERR_NONE) {
 d01423c:	e0bff703 	ldbu	r2,-36(fp)
 d014240:	1004c03a 	cmpne	r2,r2,zero
 d014244:	1000081e 	bne	r2,zero,d014268 <OSTaskCreateExt+0x178>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 d014248:	00834174 	movhi	r2,3333
 d01424c:	108a8c44 	addi	r2,r2,10801
 d014250:	10800003 	ldbu	r2,0(r2)
 d014254:	10803fcc 	andi	r2,r2,255
 d014258:	10800058 	cmpnei	r2,r2,1
 d01425c:	1000151e 	bne	r2,zero,d0142b4 <OSTaskCreateExt+0x1c4>
                OS_Sched();
 d014260:	d00f0f40 	call	d00f0f4 <OS_Sched>
 d014264:	00001306 	br	d0142b4 <OSTaskCreateExt+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014268:	0005303a 	rdctl	r2,status
 d01426c:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014270:	e0fff217 	ldw	r3,-56(fp)
 d014274:	00bfff84 	movi	r2,-2
 d014278:	1884703a 	and	r2,r3,r2
 d01427c:	1001703a 	wrctl	status,r2
  
  return context;
 d014280:	e0bff217 	ldw	r2,-56(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 d014284:	e0bff615 	stw	r2,-40(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 d014288:	e0bffc03 	ldbu	r2,-16(fp)
 d01428c:	00c341b4 	movhi	r3,3334
 d014290:	18f13304 	addi	r3,r3,-15156
 d014294:	1085883a 	add	r2,r2,r2
 d014298:	1085883a 	add	r2,r2,r2
 d01429c:	10c5883a 	add	r2,r2,r3
 d0142a0:	10000015 	stw	zero,0(r2)
 d0142a4:	e0bff617 	ldw	r2,-40(fp)
 d0142a8:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0142ac:	e0bff117 	ldw	r2,-60(fp)
 d0142b0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 d0142b4:	e0bff703 	ldbu	r2,-36(fp)
 d0142b8:	e0bfff15 	stw	r2,-4(fp)
 d0142bc:	00000606 	br	d0142d8 <OSTaskCreateExt+0x1e8>
 d0142c0:	e0bff617 	ldw	r2,-40(fp)
 d0142c4:	e0bff015 	stw	r2,-64(fp)
 d0142c8:	e0bff017 	ldw	r2,-64(fp)
 d0142cc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 d0142d0:	00800a04 	movi	r2,40
 d0142d4:	e0bfff15 	stw	r2,-4(fp)
 d0142d8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0142dc:	e037883a 	mov	sp,fp
 d0142e0:	dfc00117 	ldw	ra,4(sp)
 d0142e4:	df000017 	ldw	fp,0(sp)
 d0142e8:	dec00204 	addi	sp,sp,8
 d0142ec:	f800283a 	ret

0d0142f0 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 d0142f0:	defff304 	addi	sp,sp,-52
 d0142f4:	dfc00c15 	stw	ra,48(sp)
 d0142f8:	df000b15 	stw	fp,44(sp)
 d0142fc:	df000b04 	addi	fp,sp,44
 d014300:	e13ffe05 	stb	r4,-8(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 d014304:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 d014308:	00834174 	movhi	r2,3333
 d01430c:	108a9a04 	addi	r2,r2,10856
 d014310:	10800003 	ldbu	r2,0(r2)
 d014314:	10803fcc 	andi	r2,r2,255
 d014318:	1005003a 	cmpeq	r2,r2,zero
 d01431c:	1000031e 	bne	r2,zero,d01432c <OSTaskDel+0x3c>
        return (OS_ERR_TASK_DEL_ISR);
 d014320:	00801004 	movi	r2,64
 d014324:	e0bfff15 	stw	r2,-4(fp)
 d014328:	0000ee06 	br	d0146e4 <OSTaskDel+0x3f4>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 d01432c:	e0bffe03 	ldbu	r2,-8(fp)
 d014330:	10800518 	cmpnei	r2,r2,20
 d014334:	1000031e 	bne	r2,zero,d014344 <OSTaskDel+0x54>
        return (OS_ERR_TASK_DEL_IDLE);
 d014338:	00800f84 	movi	r2,62
 d01433c:	e0bfff15 	stw	r2,-4(fp)
 d014340:	0000e806 	br	d0146e4 <OSTaskDel+0x3f4>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 d014344:	e0bffe03 	ldbu	r2,-8(fp)
 d014348:	10800530 	cmpltui	r2,r2,20
 d01434c:	1000061e 	bne	r2,zero,d014368 <OSTaskDel+0x78>
        if (prio != OS_PRIO_SELF) {
 d014350:	e0bffe03 	ldbu	r2,-8(fp)
 d014354:	10803fe0 	cmpeqi	r2,r2,255
 d014358:	1000031e 	bne	r2,zero,d014368 <OSTaskDel+0x78>
            return (OS_ERR_PRIO_INVALID);
 d01435c:	00800a84 	movi	r2,42
 d014360:	e0bfff15 	stw	r2,-4(fp)
 d014364:	0000df06 	br	d0146e4 <OSTaskDel+0x3f4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014368:	0005303a 	rdctl	r2,status
 d01436c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014370:	e0fffa17 	ldw	r3,-24(fp)
 d014374:	00bfff84 	movi	r2,-2
 d014378:	1884703a 	and	r2,r3,r2
 d01437c:	1001703a 	wrctl	status,r2
  
  return context;
 d014380:	e0bffa17 	ldw	r2,-24(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 d014384:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 d014388:	e0bffe03 	ldbu	r2,-8(fp)
 d01438c:	10803fd8 	cmpnei	r2,r2,255
 d014390:	1000051e 	bne	r2,zero,d0143a8 <OSTaskDel+0xb8>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 d014394:	00834174 	movhi	r2,3333
 d014398:	108a9b04 	addi	r2,r2,10860
 d01439c:	10800017 	ldw	r2,0(r2)
 d0143a0:	10800c83 	ldbu	r2,50(r2)
 d0143a4:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d0143a8:	e0bffe03 	ldbu	r2,-8(fp)
 d0143ac:	00c341b4 	movhi	r3,3334
 d0143b0:	18f13304 	addi	r3,r3,-15156
 d0143b4:	1085883a 	add	r2,r2,r2
 d0143b8:	1085883a 	add	r2,r2,r2
 d0143bc:	10c5883a 	add	r2,r2,r3
 d0143c0:	10800017 	ldw	r2,0(r2)
 d0143c4:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 d0143c8:	e0bffc17 	ldw	r2,-16(fp)
 d0143cc:	1004c03a 	cmpne	r2,r2,zero
 d0143d0:	1000071e 	bne	r2,zero,d0143f0 <OSTaskDel+0x100>
 d0143d4:	e0bffb17 	ldw	r2,-20(fp)
 d0143d8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0143dc:	e0bff917 	ldw	r2,-28(fp)
 d0143e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d0143e4:	008010c4 	movi	r2,67
 d0143e8:	e0bfff15 	stw	r2,-4(fp)
 d0143ec:	0000bd06 	br	d0146e4 <OSTaskDel+0x3f4>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 d0143f0:	e0bffc17 	ldw	r2,-16(fp)
 d0143f4:	10800058 	cmpnei	r2,r2,1
 d0143f8:	1000071e 	bne	r2,zero,d014418 <OSTaskDel+0x128>
 d0143fc:	e0bffb17 	ldw	r2,-20(fp)
 d014400:	e0bff815 	stw	r2,-32(fp)
 d014404:	e0bff817 	ldw	r2,-32(fp)
 d014408:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 d01440c:	00800f44 	movi	r2,61
 d014410:	e0bfff15 	stw	r2,-4(fp)
 d014414:	0000b306 	br	d0146e4 <OSTaskDel+0x3f4>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 d014418:	e0bffc17 	ldw	r2,-16(fp)
 d01441c:	10800d03 	ldbu	r2,52(r2)
 d014420:	11003fcc 	andi	r4,r2,255
 d014424:	e0bffc17 	ldw	r2,-16(fp)
 d014428:	10800d03 	ldbu	r2,52(r2)
 d01442c:	10c03fcc 	andi	r3,r2,255
 d014430:	00834174 	movhi	r2,3333
 d014434:	108a9844 	addi	r2,r2,10849
 d014438:	10c5883a 	add	r2,r2,r3
 d01443c:	10800003 	ldbu	r2,0(r2)
 d014440:	1007883a 	mov	r3,r2
 d014444:	e0bffc17 	ldw	r2,-16(fp)
 d014448:	10800d43 	ldbu	r2,53(r2)
 d01444c:	0084303a 	nor	r2,zero,r2
 d014450:	1884703a 	and	r2,r3,r2
 d014454:	1007883a 	mov	r3,r2
 d014458:	00834174 	movhi	r2,3333
 d01445c:	108a9844 	addi	r2,r2,10849
 d014460:	1105883a 	add	r2,r2,r4
 d014464:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 d014468:	e0bffc17 	ldw	r2,-16(fp)
 d01446c:	10800d03 	ldbu	r2,52(r2)
 d014470:	10c03fcc 	andi	r3,r2,255
 d014474:	00834174 	movhi	r2,3333
 d014478:	108a9844 	addi	r2,r2,10849
 d01447c:	10c5883a 	add	r2,r2,r3
 d014480:	10800003 	ldbu	r2,0(r2)
 d014484:	10803fcc 	andi	r2,r2,255
 d014488:	1004c03a 	cmpne	r2,r2,zero
 d01448c:	10000c1e 	bne	r2,zero,d0144c0 <OSTaskDel+0x1d0>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 d014490:	e0bffc17 	ldw	r2,-16(fp)
 d014494:	10800d83 	ldbu	r2,54(r2)
 d014498:	0084303a 	nor	r2,zero,r2
 d01449c:	1007883a 	mov	r3,r2
 d0144a0:	00834174 	movhi	r2,3333
 d0144a4:	108a9804 	addi	r2,r2,10848
 d0144a8:	10800003 	ldbu	r2,0(r2)
 d0144ac:	1884703a 	and	r2,r3,r2
 d0144b0:	1007883a 	mov	r3,r2
 d0144b4:	00834174 	movhi	r2,3333
 d0144b8:	108a9804 	addi	r2,r2,10848
 d0144bc:	10c00005 	stb	r3,0(r2)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 d0144c0:	e0bffc17 	ldw	r2,-16(fp)
 d0144c4:	10800717 	ldw	r2,28(r2)
 d0144c8:	1005003a 	cmpeq	r2,r2,zero
 d0144cc:	1000041e 	bne	r2,zero,d0144e0 <OSTaskDel+0x1f0>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 d0144d0:	e0bffc17 	ldw	r2,-16(fp)
 d0144d4:	11400717 	ldw	r5,28(r2)
 d0144d8:	e13ffc17 	ldw	r4,-16(fp)
 d0144dc:	d00eaac0 	call	d00eaac <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 d0144e0:	e0bffc17 	ldw	r2,-16(fp)
 d0144e4:	10800817 	ldw	r2,32(r2)
 d0144e8:	1005003a 	cmpeq	r2,r2,zero
 d0144ec:	1000041e 	bne	r2,zero,d014500 <OSTaskDel+0x210>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 d0144f0:	e0bffc17 	ldw	r2,-16(fp)
 d0144f4:	11400817 	ldw	r5,32(r2)
 d0144f8:	e13ffc17 	ldw	r4,-16(fp)
 d0144fc:	d00eb640 	call	d00eb64 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 d014500:	e0bffc17 	ldw	r2,-16(fp)
 d014504:	10800a17 	ldw	r2,40(r2)
 d014508:	e0bffd15 	stw	r2,-12(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 d01450c:	e0bffd17 	ldw	r2,-12(fp)
 d014510:	1005003a 	cmpeq	r2,r2,zero
 d014514:	1000021e 	bne	r2,zero,d014520 <OSTaskDel+0x230>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 d014518:	e13ffd17 	ldw	r4,-12(fp)
 d01451c:	d0111f80 	call	d0111f8 <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 d014520:	e0bffc17 	ldw	r2,-16(fp)
 d014524:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 d014528:	e0bffc17 	ldw	r2,-16(fp)
 d01452c:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 d014530:	e0bffc17 	ldw	r2,-16(fp)
 d014534:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 d014538:	00834174 	movhi	r2,3333
 d01453c:	108a8c04 	addi	r2,r2,10800
 d014540:	10800003 	ldbu	r2,0(r2)
 d014544:	10803fcc 	andi	r2,r2,255
 d014548:	10803fe0 	cmpeqi	r2,r2,255
 d01454c:	1000081e 	bne	r2,zero,d014570 <OSTaskDel+0x280>
        OSLockNesting++;
 d014550:	00834174 	movhi	r2,3333
 d014554:	108a8c04 	addi	r2,r2,10800
 d014558:	10800003 	ldbu	r2,0(r2)
 d01455c:	10800044 	addi	r2,r2,1
 d014560:	1007883a 	mov	r3,r2
 d014564:	00834174 	movhi	r2,3333
 d014568:	108a8c04 	addi	r2,r2,10800
 d01456c:	10c00005 	stb	r3,0(r2)
 d014570:	e0bffb17 	ldw	r2,-20(fp)
 d014574:	e0bff715 	stw	r2,-36(fp)
 d014578:	e0bff717 	ldw	r2,-36(fp)
 d01457c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 d014580:	d00e6980 	call	d00e698 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014584:	0005303a 	rdctl	r2,status
 d014588:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01458c:	e0fff617 	ldw	r3,-40(fp)
 d014590:	00bfff84 	movi	r2,-2
 d014594:	1884703a 	and	r2,r3,r2
 d014598:	1001703a 	wrctl	status,r2
  
  return context;
 d01459c:	e0bff617 	ldw	r2,-40(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 d0145a0:	e0bffb15 	stw	r2,-20(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 d0145a4:	00834174 	movhi	r2,3333
 d0145a8:	108a8c04 	addi	r2,r2,10800
 d0145ac:	10800003 	ldbu	r2,0(r2)
 d0145b0:	10803fcc 	andi	r2,r2,255
 d0145b4:	1005003a 	cmpeq	r2,r2,zero
 d0145b8:	1000081e 	bne	r2,zero,d0145dc <OSTaskDel+0x2ec>
        OSLockNesting--;
 d0145bc:	00834174 	movhi	r2,3333
 d0145c0:	108a8c04 	addi	r2,r2,10800
 d0145c4:	10800003 	ldbu	r2,0(r2)
 d0145c8:	10bfffc4 	addi	r2,r2,-1
 d0145cc:	1007883a 	mov	r3,r2
 d0145d0:	00834174 	movhi	r2,3333
 d0145d4:	108a8c04 	addi	r2,r2,10800
 d0145d8:	10c00005 	stb	r3,0(r2)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 d0145dc:	e13ffc17 	ldw	r4,-16(fp)
 d0145e0:	d039f880 	call	d039f88 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 d0145e4:	00834174 	movhi	r2,3333
 d0145e8:	108a9444 	addi	r2,r2,10833
 d0145ec:	10800003 	ldbu	r2,0(r2)
 d0145f0:	10bfffc4 	addi	r2,r2,-1
 d0145f4:	1007883a 	mov	r3,r2
 d0145f8:	00834174 	movhi	r2,3333
 d0145fc:	108a9444 	addi	r2,r2,10833
 d014600:	10c00005 	stb	r3,0(r2)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 d014604:	e0bffe03 	ldbu	r2,-8(fp)
 d014608:	00c341b4 	movhi	r3,3334
 d01460c:	18f13304 	addi	r3,r3,-15156
 d014610:	1085883a 	add	r2,r2,r2
 d014614:	1085883a 	add	r2,r2,r2
 d014618:	10c5883a 	add	r2,r2,r3
 d01461c:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 d014620:	e0bffc17 	ldw	r2,-16(fp)
 d014624:	10800617 	ldw	r2,24(r2)
 d014628:	1004c03a 	cmpne	r2,r2,zero
 d01462c:	1000091e 	bne	r2,zero,d014654 <OSTaskDel+0x364>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 d014630:	e0bffc17 	ldw	r2,-16(fp)
 d014634:	10800517 	ldw	r2,20(r2)
 d014638:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 d01463c:	e0bffc17 	ldw	r2,-16(fp)
 d014640:	10c00517 	ldw	r3,20(r2)
 d014644:	00834174 	movhi	r2,3333
 d014648:	108a8f04 	addi	r2,r2,10812
 d01464c:	10c00015 	stw	r3,0(r2)
 d014650:	00000a06 	br	d01467c <OSTaskDel+0x38c>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 d014654:	e0bffc17 	ldw	r2,-16(fp)
 d014658:	10c00617 	ldw	r3,24(r2)
 d01465c:	e0bffc17 	ldw	r2,-16(fp)
 d014660:	10800517 	ldw	r2,20(r2)
 d014664:	18800515 	stw	r2,20(r3)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 d014668:	e0bffc17 	ldw	r2,-16(fp)
 d01466c:	10c00517 	ldw	r3,20(r2)
 d014670:	e0bffc17 	ldw	r2,-16(fp)
 d014674:	10800617 	ldw	r2,24(r2)
 d014678:	18800615 	stw	r2,24(r3)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 d01467c:	00834174 	movhi	r2,3333
 d014680:	108a9304 	addi	r2,r2,10828
 d014684:	10c00017 	ldw	r3,0(r2)
 d014688:	e0bffc17 	ldw	r2,-16(fp)
 d01468c:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 d014690:	00c34174 	movhi	r3,3333
 d014694:	18ca9304 	addi	r3,r3,10828
 d014698:	e0bffc17 	ldw	r2,-16(fp)
 d01469c:	18800015 	stw	r2,0(r3)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 d0146a0:	e0fffc17 	ldw	r3,-16(fp)
 d0146a4:	00800fc4 	movi	r2,63
 d0146a8:	18801305 	stb	r2,76(r3)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 d0146ac:	e0bffc17 	ldw	r2,-16(fp)
 d0146b0:	10001345 	stb	zero,77(r2)
 d0146b4:	e0bffb17 	ldw	r2,-20(fp)
 d0146b8:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0146bc:	e0bff517 	ldw	r2,-44(fp)
 d0146c0:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 d0146c4:	00834174 	movhi	r2,3333
 d0146c8:	108a8c44 	addi	r2,r2,10801
 d0146cc:	10800003 	ldbu	r2,0(r2)
 d0146d0:	10803fcc 	andi	r2,r2,255
 d0146d4:	10800058 	cmpnei	r2,r2,1
 d0146d8:	1000011e 	bne	r2,zero,d0146e0 <OSTaskDel+0x3f0>
        OS_Sched();                                     /* Find new highest priority task              */
 d0146dc:	d00f0f40 	call	d00f0f4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 d0146e0:	e03fff15 	stw	zero,-4(fp)
 d0146e4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0146e8:	e037883a 	mov	sp,fp
 d0146ec:	dfc00117 	ldw	ra,4(sp)
 d0146f0:	df000017 	ldw	fp,0(sp)
 d0146f4:	dec00204 	addi	sp,sp,8
 d0146f8:	f800283a 	ret

0d0146fc <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 d0146fc:	defff404 	addi	sp,sp,-48
 d014700:	df000b15 	stw	fp,44(sp)
 d014704:	df000b04 	addi	fp,sp,44
 d014708:	e13ffe05 	stb	r4,-8(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d01470c:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 d014710:	e0bffe03 	ldbu	r2,-8(fp)
 d014714:	10800518 	cmpnei	r2,r2,20
 d014718:	1000031e 	bne	r2,zero,d014728 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 d01471c:	00800f84 	movi	r2,62
 d014720:	e0bfff15 	stw	r2,-4(fp)
 d014724:	00004c06 	br	d014858 <OSTaskDelReq+0x15c>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 d014728:	e0bffe03 	ldbu	r2,-8(fp)
 d01472c:	10800530 	cmpltui	r2,r2,20
 d014730:	1000061e 	bne	r2,zero,d01474c <OSTaskDelReq+0x50>
        if (prio != OS_PRIO_SELF) {
 d014734:	e0bffe03 	ldbu	r2,-8(fp)
 d014738:	10803fe0 	cmpeqi	r2,r2,255
 d01473c:	1000031e 	bne	r2,zero,d01474c <OSTaskDelReq+0x50>
            return (OS_ERR_PRIO_INVALID);
 d014740:	00800a84 	movi	r2,42
 d014744:	e0bfff15 	stw	r2,-4(fp)
 d014748:	00004306 	br	d014858 <OSTaskDelReq+0x15c>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 d01474c:	e0bffe03 	ldbu	r2,-8(fp)
 d014750:	10803fd8 	cmpnei	r2,r2,255
 d014754:	1000141e 	bne	r2,zero,d0147a8 <OSTaskDelReq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014758:	0005303a 	rdctl	r2,status
 d01475c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014760:	e0fffa17 	ldw	r3,-24(fp)
 d014764:	00bfff84 	movi	r2,-2
 d014768:	1884703a 	and	r2,r3,r2
 d01476c:	1001703a 	wrctl	status,r2
  
  return context;
 d014770:	e0bffa17 	ldw	r2,-24(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 d014774:	e0bffb15 	stw	r2,-20(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 d014778:	00834174 	movhi	r2,3333
 d01477c:	108a9b04 	addi	r2,r2,10860
 d014780:	10800017 	ldw	r2,0(r2)
 d014784:	10800dc3 	ldbu	r2,55(r2)
 d014788:	e0bffd05 	stb	r2,-12(fp)
 d01478c:	e0bffb17 	ldw	r2,-20(fp)
 d014790:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014794:	e0bff917 	ldw	r2,-28(fp)
 d014798:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 d01479c:	e0bffd03 	ldbu	r2,-12(fp)
 d0147a0:	e0bfff15 	stw	r2,-4(fp)
 d0147a4:	00002c06 	br	d014858 <OSTaskDelReq+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0147a8:	0005303a 	rdctl	r2,status
 d0147ac:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0147b0:	e0fff817 	ldw	r3,-32(fp)
 d0147b4:	00bfff84 	movi	r2,-2
 d0147b8:	1884703a 	and	r2,r3,r2
 d0147bc:	1001703a 	wrctl	status,r2
  
  return context;
 d0147c0:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 d0147c4:	e0bffb15 	stw	r2,-20(fp)
    ptcb = OSTCBPrioTbl[prio];
 d0147c8:	e0bffe03 	ldbu	r2,-8(fp)
 d0147cc:	00c341b4 	movhi	r3,3334
 d0147d0:	18f13304 	addi	r3,r3,-15156
 d0147d4:	1085883a 	add	r2,r2,r2
 d0147d8:	1085883a 	add	r2,r2,r2
 d0147dc:	10c5883a 	add	r2,r2,r3
 d0147e0:	10800017 	ldw	r2,0(r2)
 d0147e4:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 d0147e8:	e0bffc17 	ldw	r2,-16(fp)
 d0147ec:	1004c03a 	cmpne	r2,r2,zero
 d0147f0:	1000071e 	bne	r2,zero,d014810 <OSTaskDelReq+0x114>
 d0147f4:	e0bffb17 	ldw	r2,-20(fp)
 d0147f8:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0147fc:	e0bff717 	ldw	r2,-36(fp)
 d014800:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 d014804:	008010c4 	movi	r2,67
 d014808:	e0bfff15 	stw	r2,-4(fp)
 d01480c:	00001206 	br	d014858 <OSTaskDelReq+0x15c>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 d014810:	e0bffc17 	ldw	r2,-16(fp)
 d014814:	10800058 	cmpnei	r2,r2,1
 d014818:	1000071e 	bne	r2,zero,d014838 <OSTaskDelReq+0x13c>
 d01481c:	e0bffb17 	ldw	r2,-20(fp)
 d014820:	e0bff615 	stw	r2,-40(fp)
 d014824:	e0bff617 	ldw	r2,-40(fp)
 d014828:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 d01482c:	00800f44 	movi	r2,61
 d014830:	e0bfff15 	stw	r2,-4(fp)
 d014834:	00000806 	br	d014858 <OSTaskDelReq+0x15c>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 d014838:	e0fffc17 	ldw	r3,-16(fp)
 d01483c:	00800fc4 	movi	r2,63
 d014840:	18800dc5 	stb	r2,55(r3)
 d014844:	e0bffb17 	ldw	r2,-20(fp)
 d014848:	e0bff515 	stw	r2,-44(fp)
 d01484c:	e0bff517 	ldw	r2,-44(fp)
 d014850:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d014854:	e03fff15 	stw	zero,-4(fp)
 d014858:	e0bfff17 	ldw	r2,-4(fp)
}
 d01485c:	e037883a 	mov	sp,fp
 d014860:	df000017 	ldw	fp,0(sp)
 d014864:	dec00104 	addi	sp,sp,4
 d014868:	f800283a 	ret

0d01486c <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 d01486c:	defff304 	addi	sp,sp,-52
 d014870:	dfc00c15 	stw	ra,48(sp)
 d014874:	df000b15 	stw	fp,44(sp)
 d014878:	df000b04 	addi	fp,sp,44
 d01487c:	e17ffd15 	stw	r5,-12(fp)
 d014880:	e1bffe15 	stw	r6,-8(fp)
 d014884:	e13ffc05 	stb	r4,-16(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 d014888:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 d01488c:	e0bffe17 	ldw	r2,-8(fp)
 d014890:	1004c03a 	cmpne	r2,r2,zero
 d014894:	1000021e 	bne	r2,zero,d0148a0 <OSTaskNameGet+0x34>
        return (0);
 d014898:	e03fff15 	stw	zero,-4(fp)
 d01489c:	00005b06 	br	d014a0c <OSTaskNameGet+0x1a0>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 d0148a0:	e0bffc03 	ldbu	r2,-16(fp)
 d0148a4:	10800570 	cmpltui	r2,r2,21
 d0148a8:	1000081e 	bne	r2,zero,d0148cc <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 d0148ac:	e0bffc03 	ldbu	r2,-16(fp)
 d0148b0:	10803fe0 	cmpeqi	r2,r2,255
 d0148b4:	1000051e 	bne	r2,zero,d0148cc <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 d0148b8:	e0fffe17 	ldw	r3,-8(fp)
 d0148bc:	00800a84 	movi	r2,42
 d0148c0:	18800005 	stb	r2,0(r3)
            return (0);
 d0148c4:	e03fff15 	stw	zero,-4(fp)
 d0148c8:	00005006 	br	d014a0c <OSTaskNameGet+0x1a0>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 d0148cc:	e0bffd17 	ldw	r2,-12(fp)
 d0148d0:	1004c03a 	cmpne	r2,r2,zero
 d0148d4:	1000051e 	bne	r2,zero,d0148ec <OSTaskNameGet+0x80>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 d0148d8:	e0fffe17 	ldw	r3,-8(fp)
 d0148dc:	00800304 	movi	r2,12
 d0148e0:	18800005 	stb	r2,0(r3)
        return (0);
 d0148e4:	e03fff15 	stw	zero,-4(fp)
 d0148e8:	00004806 	br	d014a0c <OSTaskNameGet+0x1a0>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 d0148ec:	00834174 	movhi	r2,3333
 d0148f0:	108a9a04 	addi	r2,r2,10856
 d0148f4:	10800003 	ldbu	r2,0(r2)
 d0148f8:	10803fcc 	andi	r2,r2,255
 d0148fc:	1005003a 	cmpeq	r2,r2,zero
 d014900:	1000051e 	bne	r2,zero,d014918 <OSTaskNameGet+0xac>
        *perr = OS_ERR_NAME_GET_ISR;
 d014904:	e0fffe17 	ldw	r3,-8(fp)
 d014908:	00800444 	movi	r2,17
 d01490c:	18800005 	stb	r2,0(r3)
        return (0);
 d014910:	e03fff15 	stw	zero,-4(fp)
 d014914:	00003d06 	br	d014a0c <OSTaskNameGet+0x1a0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014918:	0005303a 	rdctl	r2,status
 d01491c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014920:	e0fff817 	ldw	r3,-32(fp)
 d014924:	00bfff84 	movi	r2,-2
 d014928:	1884703a 	and	r2,r3,r2
 d01492c:	1001703a 	wrctl	status,r2
  
  return context;
 d014930:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 d014934:	e0bff915 	stw	r2,-28(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 d014938:	e0bffc03 	ldbu	r2,-16(fp)
 d01493c:	10803fd8 	cmpnei	r2,r2,255
 d014940:	1000051e 	bne	r2,zero,d014958 <OSTaskNameGet+0xec>
        prio = OSTCBCur->OSTCBPrio;
 d014944:	00834174 	movhi	r2,3333
 d014948:	108a9b04 	addi	r2,r2,10860
 d01494c:	10800017 	ldw	r2,0(r2)
 d014950:	10800c83 	ldbu	r2,50(r2)
 d014954:	e0bffc05 	stb	r2,-16(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d014958:	e0bffc03 	ldbu	r2,-16(fp)
 d01495c:	00c341b4 	movhi	r3,3334
 d014960:	18f13304 	addi	r3,r3,-15156
 d014964:	1085883a 	add	r2,r2,r2
 d014968:	1085883a 	add	r2,r2,r2
 d01496c:	10c5883a 	add	r2,r2,r3
 d014970:	10800017 	ldw	r2,0(r2)
 d014974:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 d014978:	e0bffb17 	ldw	r2,-20(fp)
 d01497c:	1004c03a 	cmpne	r2,r2,zero
 d014980:	1000091e 	bne	r2,zero,d0149a8 <OSTaskNameGet+0x13c>
 d014984:	e0bff917 	ldw	r2,-28(fp)
 d014988:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01498c:	e0bff717 	ldw	r2,-36(fp)
 d014990:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 d014994:	e0fffe17 	ldw	r3,-8(fp)
 d014998:	008010c4 	movi	r2,67
 d01499c:	18800005 	stb	r2,0(r3)
        return (0);
 d0149a0:	e03fff15 	stw	zero,-4(fp)
 d0149a4:	00001906 	br	d014a0c <OSTaskNameGet+0x1a0>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 d0149a8:	e0bffb17 	ldw	r2,-20(fp)
 d0149ac:	10800058 	cmpnei	r2,r2,1
 d0149b0:	1000091e 	bne	r2,zero,d0149d8 <OSTaskNameGet+0x16c>
 d0149b4:	e0bff917 	ldw	r2,-28(fp)
 d0149b8:	e0bff615 	stw	r2,-40(fp)
 d0149bc:	e0bff617 	ldw	r2,-40(fp)
 d0149c0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 d0149c4:	e0fffe17 	ldw	r3,-8(fp)
 d0149c8:	008010c4 	movi	r2,67
 d0149cc:	18800005 	stb	r2,0(r3)
        return (0);
 d0149d0:	e03fff15 	stw	zero,-4(fp)
 d0149d4:	00000d06 	br	d014a0c <OSTaskNameGet+0x1a0>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 d0149d8:	e0bffb17 	ldw	r2,-20(fp)
 d0149dc:	11401304 	addi	r5,r2,76
 d0149e0:	e13ffd17 	ldw	r4,-12(fp)
 d0149e4:	d00f2380 	call	d00f238 <OS_StrCopy>
 d0149e8:	e0bffa05 	stb	r2,-24(fp)
 d0149ec:	e0bff917 	ldw	r2,-28(fp)
 d0149f0:	e0bff515 	stw	r2,-44(fp)
 d0149f4:	e0bff517 	ldw	r2,-44(fp)
 d0149f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d0149fc:	e0bffe17 	ldw	r2,-8(fp)
 d014a00:	10000005 	stb	zero,0(r2)
    return (len);
 d014a04:	e0bffa03 	ldbu	r2,-24(fp)
 d014a08:	e0bfff15 	stw	r2,-4(fp)
 d014a0c:	e0bfff17 	ldw	r2,-4(fp)
}
 d014a10:	e037883a 	mov	sp,fp
 d014a14:	dfc00117 	ldw	ra,4(sp)
 d014a18:	df000017 	ldw	fp,0(sp)
 d014a1c:	dec00204 	addi	sp,sp,8
 d014a20:	f800283a 	ret

0d014a24 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 d014a24:	defff304 	addi	sp,sp,-52
 d014a28:	dfc00c15 	stw	ra,48(sp)
 d014a2c:	df000b15 	stw	fp,44(sp)
 d014a30:	df000b04 	addi	fp,sp,44
 d014a34:	e17ffe15 	stw	r5,-8(fp)
 d014a38:	e1bfff15 	stw	r6,-4(fp)
 d014a3c:	e13ffd05 	stb	r4,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 d014a40:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 d014a44:	e0bfff17 	ldw	r2,-4(fp)
 d014a48:	1005003a 	cmpeq	r2,r2,zero
 d014a4c:	1000611e 	bne	r2,zero,d014bd4 <OSTaskNameSet+0x1b0>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 d014a50:	e0bffd03 	ldbu	r2,-12(fp)
 d014a54:	10800570 	cmpltui	r2,r2,21
 d014a58:	1000071e 	bne	r2,zero,d014a78 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 d014a5c:	e0bffd03 	ldbu	r2,-12(fp)
 d014a60:	10803fe0 	cmpeqi	r2,r2,255
 d014a64:	1000041e 	bne	r2,zero,d014a78 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 d014a68:	e0ffff17 	ldw	r3,-4(fp)
 d014a6c:	00800a84 	movi	r2,42
 d014a70:	18800005 	stb	r2,0(r3)
            return;
 d014a74:	00005706 	br	d014bd4 <OSTaskNameSet+0x1b0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 d014a78:	e0bffe17 	ldw	r2,-8(fp)
 d014a7c:	1004c03a 	cmpne	r2,r2,zero
 d014a80:	1000041e 	bne	r2,zero,d014a94 <OSTaskNameSet+0x70>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 d014a84:	e0ffff17 	ldw	r3,-4(fp)
 d014a88:	00800304 	movi	r2,12
 d014a8c:	18800005 	stb	r2,0(r3)
        return;
 d014a90:	00005006 	br	d014bd4 <OSTaskNameSet+0x1b0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 d014a94:	00834174 	movhi	r2,3333
 d014a98:	108a9a04 	addi	r2,r2,10856
 d014a9c:	10800003 	ldbu	r2,0(r2)
 d014aa0:	10803fcc 	andi	r2,r2,255
 d014aa4:	1005003a 	cmpeq	r2,r2,zero
 d014aa8:	1000041e 	bne	r2,zero,d014abc <OSTaskNameSet+0x98>
        *perr = OS_ERR_NAME_SET_ISR;
 d014aac:	e0ffff17 	ldw	r3,-4(fp)
 d014ab0:	00800484 	movi	r2,18
 d014ab4:	18800005 	stb	r2,0(r3)
        return;
 d014ab8:	00004606 	br	d014bd4 <OSTaskNameSet+0x1b0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014abc:	0005303a 	rdctl	r2,status
 d014ac0:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014ac4:	e0fff917 	ldw	r3,-28(fp)
 d014ac8:	00bfff84 	movi	r2,-2
 d014acc:	1884703a 	and	r2,r3,r2
 d014ad0:	1001703a 	wrctl	status,r2
  
  return context;
 d014ad4:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 d014ad8:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 d014adc:	e0bffd03 	ldbu	r2,-12(fp)
 d014ae0:	10803fd8 	cmpnei	r2,r2,255
 d014ae4:	1000051e 	bne	r2,zero,d014afc <OSTaskNameSet+0xd8>
        prio = OSTCBCur->OSTCBPrio;
 d014ae8:	00834174 	movhi	r2,3333
 d014aec:	108a9b04 	addi	r2,r2,10860
 d014af0:	10800017 	ldw	r2,0(r2)
 d014af4:	10800c83 	ldbu	r2,50(r2)
 d014af8:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d014afc:	e0bffd03 	ldbu	r2,-12(fp)
 d014b00:	00c341b4 	movhi	r3,3334
 d014b04:	18f13304 	addi	r3,r3,-15156
 d014b08:	1085883a 	add	r2,r2,r2
 d014b0c:	1085883a 	add	r2,r2,r2
 d014b10:	10c5883a 	add	r2,r2,r3
 d014b14:	10800017 	ldw	r2,0(r2)
 d014b18:	e0bffb15 	stw	r2,-20(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 d014b1c:	e0bffb17 	ldw	r2,-20(fp)
 d014b20:	1004c03a 	cmpne	r2,r2,zero
 d014b24:	1000081e 	bne	r2,zero,d014b48 <OSTaskNameSet+0x124>
 d014b28:	e0bffa17 	ldw	r2,-24(fp)
 d014b2c:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014b30:	e0bff817 	ldw	r2,-32(fp)
 d014b34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 d014b38:	e0ffff17 	ldw	r3,-4(fp)
 d014b3c:	008010c4 	movi	r2,67
 d014b40:	18800005 	stb	r2,0(r3)
        return;
 d014b44:	00002306 	br	d014bd4 <OSTaskNameSet+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 d014b48:	e0bffb17 	ldw	r2,-20(fp)
 d014b4c:	10800058 	cmpnei	r2,r2,1
 d014b50:	1000081e 	bne	r2,zero,d014b74 <OSTaskNameSet+0x150>
 d014b54:	e0bffa17 	ldw	r2,-24(fp)
 d014b58:	e0bff715 	stw	r2,-36(fp)
 d014b5c:	e0bff717 	ldw	r2,-36(fp)
 d014b60:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 d014b64:	e0ffff17 	ldw	r3,-4(fp)
 d014b68:	008010c4 	movi	r2,67
 d014b6c:	18800005 	stb	r2,0(r3)
        return;
 d014b70:	00001806 	br	d014bd4 <OSTaskNameSet+0x1b0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 d014b74:	e13ffe17 	ldw	r4,-8(fp)
 d014b78:	d00f2b80 	call	d00f2b8 <OS_StrLen>
 d014b7c:	e0bffc05 	stb	r2,-16(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 d014b80:	e0bffc03 	ldbu	r2,-16(fp)
 d014b84:	10800830 	cmpltui	r2,r2,32
 d014b88:	1000081e 	bne	r2,zero,d014bac <OSTaskNameSet+0x188>
 d014b8c:	e0bffa17 	ldw	r2,-24(fp)
 d014b90:	e0bff615 	stw	r2,-40(fp)
 d014b94:	e0bff617 	ldw	r2,-40(fp)
 d014b98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 d014b9c:	e0ffff17 	ldw	r3,-4(fp)
 d014ba0:	00801044 	movi	r2,65
 d014ba4:	18800005 	stb	r2,0(r3)
        return;
 d014ba8:	00000a06 	br	d014bd4 <OSTaskNameSet+0x1b0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 d014bac:	e0bffb17 	ldw	r2,-20(fp)
 d014bb0:	11001304 	addi	r4,r2,76
 d014bb4:	e17ffe17 	ldw	r5,-8(fp)
 d014bb8:	d00f2380 	call	d00f238 <OS_StrCopy>
 d014bbc:	e0bffa17 	ldw	r2,-24(fp)
 d014bc0:	e0bff515 	stw	r2,-44(fp)
 d014bc4:	e0bff517 	ldw	r2,-44(fp)
 d014bc8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 d014bcc:	e0bfff17 	ldw	r2,-4(fp)
 d014bd0:	10000005 	stb	zero,0(r2)
}
 d014bd4:	e037883a 	mov	sp,fp
 d014bd8:	dfc00117 	ldw	ra,4(sp)
 d014bdc:	df000017 	ldw	fp,0(sp)
 d014be0:	dec00204 	addi	sp,sp,8
 d014be4:	f800283a 	ret

0d014be8 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 d014be8:	defff304 	addi	sp,sp,-52
 d014bec:	dfc00c15 	stw	ra,48(sp)
 d014bf0:	df000b15 	stw	fp,44(sp)
 d014bf4:	df000b04 	addi	fp,sp,44
 d014bf8:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 d014bfc:	e03ffc15 	stw	zero,-16(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 d014c00:	e0bffe03 	ldbu	r2,-8(fp)
 d014c04:	10800530 	cmpltui	r2,r2,20
 d014c08:	1000031e 	bne	r2,zero,d014c18 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 d014c0c:	00800a84 	movi	r2,42
 d014c10:	e0bfff15 	stw	r2,-4(fp)
 d014c14:	00007406 	br	d014de8 <OSTaskResume+0x200>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014c18:	0005303a 	rdctl	r2,status
 d014c1c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014c20:	e0fffb17 	ldw	r3,-20(fp)
 d014c24:	00bfff84 	movi	r2,-2
 d014c28:	1884703a 	and	r2,r3,r2
 d014c2c:	1001703a 	wrctl	status,r2
  
  return context;
 d014c30:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d014c34:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];
 d014c38:	e0bffe03 	ldbu	r2,-8(fp)
 d014c3c:	00c341b4 	movhi	r3,3334
 d014c40:	18f13304 	addi	r3,r3,-15156
 d014c44:	1085883a 	add	r2,r2,r2
 d014c48:	1085883a 	add	r2,r2,r2
 d014c4c:	10c5883a 	add	r2,r2,r3
 d014c50:	10800017 	ldw	r2,0(r2)
 d014c54:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 d014c58:	e0bffd17 	ldw	r2,-12(fp)
 d014c5c:	1004c03a 	cmpne	r2,r2,zero
 d014c60:	1000071e 	bne	r2,zero,d014c80 <OSTaskResume+0x98>
 d014c64:	e0bffc17 	ldw	r2,-16(fp)
 d014c68:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014c6c:	e0bffa17 	ldw	r2,-24(fp)
 d014c70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 d014c74:	00801184 	movi	r2,70
 d014c78:	e0bfff15 	stw	r2,-4(fp)
 d014c7c:	00005a06 	br	d014de8 <OSTaskResume+0x200>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 d014c80:	e0bffd17 	ldw	r2,-12(fp)
 d014c84:	10800058 	cmpnei	r2,r2,1
 d014c88:	1000071e 	bne	r2,zero,d014ca8 <OSTaskResume+0xc0>
 d014c8c:	e0bffc17 	ldw	r2,-16(fp)
 d014c90:	e0bff915 	stw	r2,-28(fp)
 d014c94:	e0bff917 	ldw	r2,-28(fp)
 d014c98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d014c9c:	008010c4 	movi	r2,67
 d014ca0:	e0bfff15 	stw	r2,-4(fp)
 d014ca4:	00005006 	br	d014de8 <OSTaskResume+0x200>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 d014ca8:	e0bffd17 	ldw	r2,-12(fp)
 d014cac:	10800c03 	ldbu	r2,48(r2)
 d014cb0:	10803fcc 	andi	r2,r2,255
 d014cb4:	1080020c 	andi	r2,r2,8
 d014cb8:	1005003a 	cmpeq	r2,r2,zero
 d014cbc:	1000441e 	bne	r2,zero,d014dd0 <OSTaskResume+0x1e8>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 d014cc0:	e0bffd17 	ldw	r2,-12(fp)
 d014cc4:	10c00c03 	ldbu	r3,48(r2)
 d014cc8:	00bffdc4 	movi	r2,-9
 d014ccc:	1884703a 	and	r2,r3,r2
 d014cd0:	1007883a 	mov	r3,r2
 d014cd4:	e0bffd17 	ldw	r2,-12(fp)
 d014cd8:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 d014cdc:	e0bffd17 	ldw	r2,-12(fp)
 d014ce0:	10800c03 	ldbu	r2,48(r2)
 d014ce4:	10803fcc 	andi	r2,r2,255
 d014ce8:	1004c03a 	cmpne	r2,r2,zero
 d014cec:	1000321e 	bne	r2,zero,d014db8 <OSTaskResume+0x1d0>
            if (ptcb->OSTCBDly == 0) {
 d014cf0:	e0bffd17 	ldw	r2,-12(fp)
 d014cf4:	10800b8b 	ldhu	r2,46(r2)
 d014cf8:	10bfffcc 	andi	r2,r2,65535
 d014cfc:	1004c03a 	cmpne	r2,r2,zero
 d014d00:	1000281e 	bne	r2,zero,d014da4 <OSTaskResume+0x1bc>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 d014d04:	e0bffd17 	ldw	r2,-12(fp)
 d014d08:	10c00d83 	ldbu	r3,54(r2)
 d014d0c:	00834174 	movhi	r2,3333
 d014d10:	108a9804 	addi	r2,r2,10848
 d014d14:	10800003 	ldbu	r2,0(r2)
 d014d18:	1884b03a 	or	r2,r3,r2
 d014d1c:	1007883a 	mov	r3,r2
 d014d20:	00834174 	movhi	r2,3333
 d014d24:	108a9804 	addi	r2,r2,10848
 d014d28:	10c00005 	stb	r3,0(r2)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d014d2c:	e0bffd17 	ldw	r2,-12(fp)
 d014d30:	10800d03 	ldbu	r2,52(r2)
 d014d34:	11003fcc 	andi	r4,r2,255
 d014d38:	e0bffd17 	ldw	r2,-12(fp)
 d014d3c:	10800d03 	ldbu	r2,52(r2)
 d014d40:	10c03fcc 	andi	r3,r2,255
 d014d44:	00834174 	movhi	r2,3333
 d014d48:	108a9844 	addi	r2,r2,10849
 d014d4c:	10c5883a 	add	r2,r2,r3
 d014d50:	10c00003 	ldbu	r3,0(r2)
 d014d54:	e0bffd17 	ldw	r2,-12(fp)
 d014d58:	10800d43 	ldbu	r2,53(r2)
 d014d5c:	1884b03a 	or	r2,r3,r2
 d014d60:	1007883a 	mov	r3,r2
 d014d64:	00834174 	movhi	r2,3333
 d014d68:	108a9844 	addi	r2,r2,10849
 d014d6c:	1105883a 	add	r2,r2,r4
 d014d70:	10c00005 	stb	r3,0(r2)
 d014d74:	e0bffc17 	ldw	r2,-16(fp)
 d014d78:	e0bff815 	stw	r2,-32(fp)
 d014d7c:	e0bff817 	ldw	r2,-32(fp)
 d014d80:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 d014d84:	00834174 	movhi	r2,3333
 d014d88:	108a8c44 	addi	r2,r2,10801
 d014d8c:	10800003 	ldbu	r2,0(r2)
 d014d90:	10803fcc 	andi	r2,r2,255
 d014d94:	10800058 	cmpnei	r2,r2,1
 d014d98:	10000b1e 	bne	r2,zero,d014dc8 <OSTaskResume+0x1e0>
                    OS_Sched();                               /* Find new highest priority task        */
 d014d9c:	d00f0f40 	call	d00f0f4 <OS_Sched>
 d014da0:	00000906 	br	d014dc8 <OSTaskResume+0x1e0>
 d014da4:	e0bffc17 	ldw	r2,-16(fp)
 d014da8:	e0bff715 	stw	r2,-36(fp)
 d014dac:	e0bff717 	ldw	r2,-36(fp)
 d014db0:	1001703a 	wrctl	status,r2
 d014db4:	00000406 	br	d014dc8 <OSTaskResume+0x1e0>
 d014db8:	e0bffc17 	ldw	r2,-16(fp)
 d014dbc:	e0bff615 	stw	r2,-40(fp)
 d014dc0:	e0bff617 	ldw	r2,-40(fp)
 d014dc4:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 d014dc8:	e03fff15 	stw	zero,-4(fp)
 d014dcc:	00000606 	br	d014de8 <OSTaskResume+0x200>
 d014dd0:	e0bffc17 	ldw	r2,-16(fp)
 d014dd4:	e0bff515 	stw	r2,-44(fp)
 d014dd8:	e0bff517 	ldw	r2,-44(fp)
 d014ddc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 d014de0:	00801104 	movi	r2,68
 d014de4:	e0bfff15 	stw	r2,-4(fp)
 d014de8:	e0bfff17 	ldw	r2,-4(fp)
}
 d014dec:	e037883a 	mov	sp,fp
 d014df0:	dfc00117 	ldw	ra,4(sp)
 d014df4:	df000017 	ldw	fp,0(sp)
 d014df8:	dec00204 	addi	sp,sp,8
 d014dfc:	f800283a 	ret

0d014e00 <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 d014e00:	defff204 	addi	sp,sp,-56
 d014e04:	df000d15 	stw	fp,52(sp)
 d014e08:	df000d04 	addi	fp,sp,52
 d014e0c:	e17ffe15 	stw	r5,-8(fp)
 d014e10:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 d014e14:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 d014e18:	e0bffd03 	ldbu	r2,-12(fp)
 d014e1c:	10800570 	cmpltui	r2,r2,21
 d014e20:	1000061e 	bne	r2,zero,d014e3c <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 d014e24:	e0bffd03 	ldbu	r2,-12(fp)
 d014e28:	10803fe0 	cmpeqi	r2,r2,255
 d014e2c:	1000031e 	bne	r2,zero,d014e3c <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 d014e30:	00800a84 	movi	r2,42
 d014e34:	e0bfff15 	stw	r2,-4(fp)
 d014e38:	00006b06 	br	d014fe8 <OSTaskStkChk+0x1e8>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 d014e3c:	e0bffe17 	ldw	r2,-8(fp)
 d014e40:	1004c03a 	cmpne	r2,r2,zero
 d014e44:	1000031e 	bne	r2,zero,d014e54 <OSTaskStkChk+0x54>
        return (OS_ERR_PDATA_NULL);
 d014e48:	00800244 	movi	r2,9
 d014e4c:	e0bfff15 	stw	r2,-4(fp)
 d014e50:	00006506 	br	d014fe8 <OSTaskStkChk+0x1e8>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 d014e54:	e0bffe17 	ldw	r2,-8(fp)
 d014e58:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 d014e5c:	e0bffe17 	ldw	r2,-8(fp)
 d014e60:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d014e64:	0005303a 	rdctl	r2,status
 d014e68:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d014e6c:	e0fff717 	ldw	r3,-36(fp)
 d014e70:	00bfff84 	movi	r2,-2
 d014e74:	1884703a 	and	r2,r3,r2
 d014e78:	1001703a 	wrctl	status,r2
  
  return context;
 d014e7c:	e0bff717 	ldw	r2,-36(fp)
    OS_ENTER_CRITICAL();
 d014e80:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 d014e84:	e0bffd03 	ldbu	r2,-12(fp)
 d014e88:	10803fd8 	cmpnei	r2,r2,255
 d014e8c:	1000051e 	bne	r2,zero,d014ea4 <OSTaskStkChk+0xa4>
        prio = OSTCBCur->OSTCBPrio;
 d014e90:	00834174 	movhi	r2,3333
 d014e94:	108a9b04 	addi	r2,r2,10860
 d014e98:	10800017 	ldw	r2,0(r2)
 d014e9c:	10800c83 	ldbu	r2,50(r2)
 d014ea0:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d014ea4:	e0bffd03 	ldbu	r2,-12(fp)
 d014ea8:	00c341b4 	movhi	r3,3334
 d014eac:	18f13304 	addi	r3,r3,-15156
 d014eb0:	1085883a 	add	r2,r2,r2
 d014eb4:	1085883a 	add	r2,r2,r2
 d014eb8:	10c5883a 	add	r2,r2,r3
 d014ebc:	10800017 	ldw	r2,0(r2)
 d014ec0:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 d014ec4:	e0bffc17 	ldw	r2,-16(fp)
 d014ec8:	1004c03a 	cmpne	r2,r2,zero
 d014ecc:	1000071e 	bne	r2,zero,d014eec <OSTaskStkChk+0xec>
 d014ed0:	e0bff817 	ldw	r2,-32(fp)
 d014ed4:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d014ed8:	e0bff617 	ldw	r2,-40(fp)
 d014edc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d014ee0:	008010c4 	movi	r2,67
 d014ee4:	e0bfff15 	stw	r2,-4(fp)
 d014ee8:	00003f06 	br	d014fe8 <OSTaskStkChk+0x1e8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 d014eec:	e0bffc17 	ldw	r2,-16(fp)
 d014ef0:	10800058 	cmpnei	r2,r2,1
 d014ef4:	1000071e 	bne	r2,zero,d014f14 <OSTaskStkChk+0x114>
 d014ef8:	e0bff817 	ldw	r2,-32(fp)
 d014efc:	e0bff515 	stw	r2,-44(fp)
 d014f00:	e0bff517 	ldw	r2,-44(fp)
 d014f04:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d014f08:	008010c4 	movi	r2,67
 d014f0c:	e0bfff15 	stw	r2,-4(fp)
 d014f10:	00003506 	br	d014fe8 <OSTaskStkChk+0x1e8>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 d014f14:	e0bffc17 	ldw	r2,-16(fp)
 d014f18:	1080040b 	ldhu	r2,16(r2)
 d014f1c:	10bfffcc 	andi	r2,r2,65535
 d014f20:	1080004c 	andi	r2,r2,1
 d014f24:	1004c03a 	cmpne	r2,r2,zero
 d014f28:	1000071e 	bne	r2,zero,d014f48 <OSTaskStkChk+0x148>
 d014f2c:	e0bff817 	ldw	r2,-32(fp)
 d014f30:	e0bff415 	stw	r2,-48(fp)
 d014f34:	e0bff417 	ldw	r2,-48(fp)
 d014f38:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 d014f3c:	00801144 	movi	r2,69
 d014f40:	e0bfff15 	stw	r2,-4(fp)
 d014f44:	00002806 	br	d014fe8 <OSTaskStkChk+0x1e8>
    }
    nfree = 0;
 d014f48:	e03ffa15 	stw	zero,-24(fp)
    size  = ptcb->OSTCBStkSize;
 d014f4c:	e0bffc17 	ldw	r2,-16(fp)
 d014f50:	10800317 	ldw	r2,12(r2)
 d014f54:	e0bff915 	stw	r2,-28(fp)
    pchk  = ptcb->OSTCBStkBottom;
 d014f58:	e0bffc17 	ldw	r2,-16(fp)
 d014f5c:	10800217 	ldw	r2,8(r2)
 d014f60:	e0bffb15 	stw	r2,-20(fp)
 d014f64:	e0bff817 	ldw	r2,-32(fp)
 d014f68:	e0bff315 	stw	r2,-52(fp)
 d014f6c:	e0bff317 	ldw	r2,-52(fp)
 d014f70:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 d014f74:	00000306 	br	d014f84 <OSTaskStkChk+0x184>
        nfree++;
 d014f78:	e0bffa17 	ldw	r2,-24(fp)
 d014f7c:	10800044 	addi	r2,r2,1
 d014f80:	e0bffa15 	stw	r2,-24(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 d014f84:	e0bffb17 	ldw	r2,-20(fp)
 d014f88:	10800017 	ldw	r2,0(r2)
 d014f8c:	1005003a 	cmpeq	r2,r2,zero
 d014f90:	1007883a 	mov	r3,r2
 d014f94:	e0bffb17 	ldw	r2,-20(fp)
 d014f98:	10800104 	addi	r2,r2,4
 d014f9c:	e0bffb15 	stw	r2,-20(fp)
 d014fa0:	18803fcc 	andi	r2,r3,255
 d014fa4:	1004c03a 	cmpne	r2,r2,zero
 d014fa8:	103ff31e 	bne	r2,zero,d014f78 <OSTaskStkChk+0x178>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 d014fac:	e0bffa17 	ldw	r2,-24(fp)
 d014fb0:	1085883a 	add	r2,r2,r2
 d014fb4:	1085883a 	add	r2,r2,r2
 d014fb8:	1007883a 	mov	r3,r2
 d014fbc:	e0bffe17 	ldw	r2,-8(fp)
 d014fc0:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 d014fc4:	e0fff917 	ldw	r3,-28(fp)
 d014fc8:	e0bffa17 	ldw	r2,-24(fp)
 d014fcc:	1885c83a 	sub	r2,r3,r2
 d014fd0:	1085883a 	add	r2,r2,r2
 d014fd4:	1085883a 	add	r2,r2,r2
 d014fd8:	1007883a 	mov	r3,r2
 d014fdc:	e0bffe17 	ldw	r2,-8(fp)
 d014fe0:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 d014fe4:	e03fff15 	stw	zero,-4(fp)
 d014fe8:	e0bfff17 	ldw	r2,-4(fp)
}
 d014fec:	e037883a 	mov	sp,fp
 d014ff0:	df000017 	ldw	fp,0(sp)
 d014ff4:	dec00104 	addi	sp,sp,4
 d014ff8:	f800283a 	ret

0d014ffc <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 d014ffc:	defff404 	addi	sp,sp,-48
 d015000:	dfc00b15 	stw	ra,44(sp)
 d015004:	df000a15 	stw	fp,40(sp)
 d015008:	df000a04 	addi	fp,sp,40
 d01500c:	e13ffe05 	stb	r4,-8(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d015010:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 d015014:	e0bffe03 	ldbu	r2,-8(fp)
 d015018:	10800518 	cmpnei	r2,r2,20
 d01501c:	1000031e 	bne	r2,zero,d01502c <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 d015020:	008011c4 	movi	r2,71
 d015024:	e0bfff15 	stw	r2,-4(fp)
 d015028:	00007906 	br	d015210 <OSTaskSuspend+0x214>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 d01502c:	e0bffe03 	ldbu	r2,-8(fp)
 d015030:	10800530 	cmpltui	r2,r2,20
 d015034:	1000061e 	bne	r2,zero,d015050 <OSTaskSuspend+0x54>
        if (prio != OS_PRIO_SELF) {
 d015038:	e0bffe03 	ldbu	r2,-8(fp)
 d01503c:	10803fe0 	cmpeqi	r2,r2,255
 d015040:	1000031e 	bne	r2,zero,d015050 <OSTaskSuspend+0x54>
            return (OS_ERR_PRIO_INVALID);
 d015044:	00800a84 	movi	r2,42
 d015048:	e0bfff15 	stw	r2,-4(fp)
 d01504c:	00007006 	br	d015210 <OSTaskSuspend+0x214>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d015050:	0005303a 	rdctl	r2,status
 d015054:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d015058:	e0fff917 	ldw	r3,-28(fp)
 d01505c:	00bfff84 	movi	r2,-2
 d015060:	1884703a 	and	r2,r3,r2
 d015064:	1001703a 	wrctl	status,r2
  
  return context;
 d015068:	e0bff917 	ldw	r2,-28(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 d01506c:	e0bffa15 	stw	r2,-24(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 d015070:	e0bffe03 	ldbu	r2,-8(fp)
 d015074:	10803fd8 	cmpnei	r2,r2,255
 d015078:	1000081e 	bne	r2,zero,d01509c <OSTaskSuspend+0xa0>
        prio = OSTCBCur->OSTCBPrio;
 d01507c:	00834174 	movhi	r2,3333
 d015080:	108a9b04 	addi	r2,r2,10860
 d015084:	10800017 	ldw	r2,0(r2)
 d015088:	10800c83 	ldbu	r2,50(r2)
 d01508c:	e0bffe05 	stb	r2,-8(fp)
        self = OS_TRUE;
 d015090:	00800044 	movi	r2,1
 d015094:	e0bffd05 	stb	r2,-12(fp)
 d015098:	00000b06 	br	d0150c8 <OSTaskSuspend+0xcc>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 d01509c:	00834174 	movhi	r2,3333
 d0150a0:	108a9b04 	addi	r2,r2,10860
 d0150a4:	10800017 	ldw	r2,0(r2)
 d0150a8:	10800c83 	ldbu	r2,50(r2)
 d0150ac:	10c03fcc 	andi	r3,r2,255
 d0150b0:	e0bffe03 	ldbu	r2,-8(fp)
 d0150b4:	1880031e 	bne	r3,r2,d0150c4 <OSTaskSuspend+0xc8>
        self = OS_TRUE;
 d0150b8:	00800044 	movi	r2,1
 d0150bc:	e0bffd05 	stb	r2,-12(fp)
 d0150c0:	00000106 	br	d0150c8 <OSTaskSuspend+0xcc>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 d0150c4:	e03ffd05 	stb	zero,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d0150c8:	e0bffe03 	ldbu	r2,-8(fp)
 d0150cc:	00c341b4 	movhi	r3,3334
 d0150d0:	18f13304 	addi	r3,r3,-15156
 d0150d4:	1085883a 	add	r2,r2,r2
 d0150d8:	1085883a 	add	r2,r2,r2
 d0150dc:	10c5883a 	add	r2,r2,r3
 d0150e0:	10800017 	ldw	r2,0(r2)
 d0150e4:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 d0150e8:	e0bffc17 	ldw	r2,-16(fp)
 d0150ec:	1004c03a 	cmpne	r2,r2,zero
 d0150f0:	1000071e 	bne	r2,zero,d015110 <OSTaskSuspend+0x114>
 d0150f4:	e0bffa17 	ldw	r2,-24(fp)
 d0150f8:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0150fc:	e0bff817 	ldw	r2,-32(fp)
 d015100:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 d015104:	00801204 	movi	r2,72
 d015108:	e0bfff15 	stw	r2,-4(fp)
 d01510c:	00004006 	br	d015210 <OSTaskSuspend+0x214>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 d015110:	e0bffc17 	ldw	r2,-16(fp)
 d015114:	10800058 	cmpnei	r2,r2,1
 d015118:	1000071e 	bne	r2,zero,d015138 <OSTaskSuspend+0x13c>
 d01511c:	e0bffa17 	ldw	r2,-24(fp)
 d015120:	e0bff715 	stw	r2,-36(fp)
 d015124:	e0bff717 	ldw	r2,-36(fp)
 d015128:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d01512c:	008010c4 	movi	r2,67
 d015130:	e0bfff15 	stw	r2,-4(fp)
 d015134:	00003606 	br	d015210 <OSTaskSuspend+0x214>
    }
    y            = ptcb->OSTCBY;
 d015138:	e0bffc17 	ldw	r2,-16(fp)
 d01513c:	10800d03 	ldbu	r2,52(r2)
 d015140:	e0bffb05 	stb	r2,-20(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 d015144:	e13ffb03 	ldbu	r4,-20(fp)
 d015148:	e0fffb03 	ldbu	r3,-20(fp)
 d01514c:	00834174 	movhi	r2,3333
 d015150:	108a9844 	addi	r2,r2,10849
 d015154:	10c5883a 	add	r2,r2,r3
 d015158:	10800003 	ldbu	r2,0(r2)
 d01515c:	1007883a 	mov	r3,r2
 d015160:	e0bffc17 	ldw	r2,-16(fp)
 d015164:	10800d43 	ldbu	r2,53(r2)
 d015168:	0084303a 	nor	r2,zero,r2
 d01516c:	1884703a 	and	r2,r3,r2
 d015170:	1007883a 	mov	r3,r2
 d015174:	00834174 	movhi	r2,3333
 d015178:	108a9844 	addi	r2,r2,10849
 d01517c:	1105883a 	add	r2,r2,r4
 d015180:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 d015184:	e0fffb03 	ldbu	r3,-20(fp)
 d015188:	00834174 	movhi	r2,3333
 d01518c:	108a9844 	addi	r2,r2,10849
 d015190:	10c5883a 	add	r2,r2,r3
 d015194:	10800003 	ldbu	r2,0(r2)
 d015198:	10803fcc 	andi	r2,r2,255
 d01519c:	1004c03a 	cmpne	r2,r2,zero
 d0151a0:	10000c1e 	bne	r2,zero,d0151d4 <OSTaskSuspend+0x1d8>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 d0151a4:	e0bffc17 	ldw	r2,-16(fp)
 d0151a8:	10800d83 	ldbu	r2,54(r2)
 d0151ac:	0084303a 	nor	r2,zero,r2
 d0151b0:	1007883a 	mov	r3,r2
 d0151b4:	00834174 	movhi	r2,3333
 d0151b8:	108a9804 	addi	r2,r2,10848
 d0151bc:	10800003 	ldbu	r2,0(r2)
 d0151c0:	1884703a 	and	r2,r3,r2
 d0151c4:	1007883a 	mov	r3,r2
 d0151c8:	00834174 	movhi	r2,3333
 d0151cc:	108a9804 	addi	r2,r2,10848
 d0151d0:	10c00005 	stb	r3,0(r2)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 d0151d4:	e0bffc17 	ldw	r2,-16(fp)
 d0151d8:	10800c03 	ldbu	r2,48(r2)
 d0151dc:	10800214 	ori	r2,r2,8
 d0151e0:	1007883a 	mov	r3,r2
 d0151e4:	e0bffc17 	ldw	r2,-16(fp)
 d0151e8:	10c00c05 	stb	r3,48(r2)
 d0151ec:	e0bffa17 	ldw	r2,-24(fp)
 d0151f0:	e0bff615 	stw	r2,-40(fp)
 d0151f4:	e0bff617 	ldw	r2,-40(fp)
 d0151f8:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 d0151fc:	e0bffd03 	ldbu	r2,-12(fp)
 d015200:	10800058 	cmpnei	r2,r2,1
 d015204:	1000011e 	bne	r2,zero,d01520c <OSTaskSuspend+0x210>
        OS_Sched();                                             /* Find new highest priority task      */
 d015208:	d00f0f40 	call	d00f0f4 <OS_Sched>
    }
    return (OS_ERR_NONE);
 d01520c:	e03fff15 	stw	zero,-4(fp)
 d015210:	e0bfff17 	ldw	r2,-4(fp)
}
 d015214:	e037883a 	mov	sp,fp
 d015218:	dfc00117 	ldw	ra,4(sp)
 d01521c:	df000017 	ldw	fp,0(sp)
 d015220:	dec00204 	addi	sp,sp,8
 d015224:	f800283a 	ret

0d015228 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 d015228:	defff504 	addi	sp,sp,-44
 d01522c:	dfc00a15 	stw	ra,40(sp)
 d015230:	df000915 	stw	fp,36(sp)
 d015234:	df000904 	addi	fp,sp,36
 d015238:	e17ffe15 	stw	r5,-8(fp)
 d01523c:	e13ffd05 	stb	r4,-12(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d015240:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 d015244:	e0bffd03 	ldbu	r2,-12(fp)
 d015248:	10800570 	cmpltui	r2,r2,21
 d01524c:	1000061e 	bne	r2,zero,d015268 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 d015250:	e0bffd03 	ldbu	r2,-12(fp)
 d015254:	10803fe0 	cmpeqi	r2,r2,255
 d015258:	1000031e 	bne	r2,zero,d015268 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 d01525c:	00800a84 	movi	r2,42
 d015260:	e0bfff15 	stw	r2,-4(fp)
 d015264:	00003b06 	br	d015354 <OSTaskQuery+0x12c>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 d015268:	e0bffe17 	ldw	r2,-8(fp)
 d01526c:	1004c03a 	cmpne	r2,r2,zero
 d015270:	1000031e 	bne	r2,zero,d015280 <OSTaskQuery+0x58>
        return (OS_ERR_PDATA_NULL);
 d015274:	00800244 	movi	r2,9
 d015278:	e0bfff15 	stw	r2,-4(fp)
 d01527c:	00003506 	br	d015354 <OSTaskQuery+0x12c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d015280:	0005303a 	rdctl	r2,status
 d015284:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d015288:	e0fffa17 	ldw	r3,-24(fp)
 d01528c:	00bfff84 	movi	r2,-2
 d015290:	1884703a 	and	r2,r3,r2
 d015294:	1001703a 	wrctl	status,r2
  
  return context;
 d015298:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 d01529c:	e0bffb15 	stw	r2,-20(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 d0152a0:	e0bffd03 	ldbu	r2,-12(fp)
 d0152a4:	10803fd8 	cmpnei	r2,r2,255
 d0152a8:	1000051e 	bne	r2,zero,d0152c0 <OSTaskQuery+0x98>
        prio = OSTCBCur->OSTCBPrio;
 d0152ac:	00834174 	movhi	r2,3333
 d0152b0:	108a9b04 	addi	r2,r2,10860
 d0152b4:	10800017 	ldw	r2,0(r2)
 d0152b8:	10800c83 	ldbu	r2,50(r2)
 d0152bc:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 d0152c0:	e0bffd03 	ldbu	r2,-12(fp)
 d0152c4:	00c341b4 	movhi	r3,3334
 d0152c8:	18f13304 	addi	r3,r3,-15156
 d0152cc:	1085883a 	add	r2,r2,r2
 d0152d0:	1085883a 	add	r2,r2,r2
 d0152d4:	10c5883a 	add	r2,r2,r3
 d0152d8:	10800017 	ldw	r2,0(r2)
 d0152dc:	e0bffc15 	stw	r2,-16(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 d0152e0:	e0bffc17 	ldw	r2,-16(fp)
 d0152e4:	1004c03a 	cmpne	r2,r2,zero
 d0152e8:	1000071e 	bne	r2,zero,d015308 <OSTaskQuery+0xe0>
 d0152ec:	e0bffb17 	ldw	r2,-20(fp)
 d0152f0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0152f4:	e0bff917 	ldw	r2,-28(fp)
 d0152f8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 d0152fc:	00800a44 	movi	r2,41
 d015300:	e0bfff15 	stw	r2,-4(fp)
 d015304:	00001306 	br	d015354 <OSTaskQuery+0x12c>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 d015308:	e0bffc17 	ldw	r2,-16(fp)
 d01530c:	10800058 	cmpnei	r2,r2,1
 d015310:	1000071e 	bne	r2,zero,d015330 <OSTaskQuery+0x108>
 d015314:	e0bffb17 	ldw	r2,-20(fp)
 d015318:	e0bff815 	stw	r2,-32(fp)
 d01531c:	e0bff817 	ldw	r2,-32(fp)
 d015320:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 d015324:	008010c4 	movi	r2,67
 d015328:	e0bfff15 	stw	r2,-4(fp)
 d01532c:	00000906 	br	d015354 <OSTaskQuery+0x12c>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 d015330:	e13ffe17 	ldw	r4,-8(fp)
 d015334:	e17ffc17 	ldw	r5,-16(fp)
 d015338:	01801b04 	movi	r6,108
 d01533c:	d00f0880 	call	d00f088 <OS_MemCopy>
 d015340:	e0bffb17 	ldw	r2,-20(fp)
 d015344:	e0bff715 	stw	r2,-36(fp)
 d015348:	e0bff717 	ldw	r2,-36(fp)
 d01534c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 d015350:	e03fff15 	stw	zero,-4(fp)
 d015354:	e0bfff17 	ldw	r2,-4(fp)
}
 d015358:	e037883a 	mov	sp,fp
 d01535c:	dfc00117 	ldw	ra,4(sp)
 d015360:	df000017 	ldw	fp,0(sp)
 d015364:	dec00204 	addi	sp,sp,8
 d015368:	f800283a 	ret

0d01536c <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 d01536c:	defffc04 	addi	sp,sp,-16
 d015370:	df000315 	stw	fp,12(sp)
 d015374:	df000304 	addi	fp,sp,12
 d015378:	e13ffd15 	stw	r4,-12(fp)
 d01537c:	e17ffe15 	stw	r5,-8(fp)
 d015380:	e1bfff0d 	sth	r6,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 d015384:	e0bfff0b 	ldhu	r2,-4(fp)
 d015388:	1080004c 	andi	r2,r2,1
 d01538c:	10803fcc 	andi	r2,r2,255
 d015390:	1005003a 	cmpeq	r2,r2,zero
 d015394:	1000101e 	bne	r2,zero,d0153d8 <OS_TaskStkClr+0x6c>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 d015398:	e0bfff0b 	ldhu	r2,-4(fp)
 d01539c:	1080008c 	andi	r2,r2,2
 d0153a0:	1005003a 	cmpeq	r2,r2,zero
 d0153a4:	10000c1e 	bne	r2,zero,d0153d8 <OS_TaskStkClr+0x6c>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 d0153a8:	00000806 	br	d0153cc <OS_TaskStkClr+0x60>
                size--;
 d0153ac:	e0bffe17 	ldw	r2,-8(fp)
 d0153b0:	10bfffc4 	addi	r2,r2,-1
 d0153b4:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 d0153b8:	e0bffd17 	ldw	r2,-12(fp)
 d0153bc:	10000015 	stw	zero,0(r2)
 d0153c0:	e0bffd17 	ldw	r2,-12(fp)
 d0153c4:	10800104 	addi	r2,r2,4
 d0153c8:	e0bffd15 	stw	r2,-12(fp)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 d0153cc:	e0bffe17 	ldw	r2,-8(fp)
 d0153d0:	1004c03a 	cmpne	r2,r2,zero
 d0153d4:	103ff51e 	bne	r2,zero,d0153ac <OS_TaskStkClr+0x40>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 d0153d8:	e037883a 	mov	sp,fp
 d0153dc:	df000017 	ldw	fp,0(sp)
 d0153e0:	dec00104 	addi	sp,sp,4
 d0153e4:	f800283a 	ret

0d0153e8 <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 d0153e8:	defff904 	addi	sp,sp,-28
 d0153ec:	dfc00615 	stw	ra,24(sp)
 d0153f0:	df000515 	stw	fp,20(sp)
 d0153f4:	df000504 	addi	fp,sp,20
 d0153f8:	e13fff0d 	sth	r4,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0153fc:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d015400:	00834174 	movhi	r2,3333
 d015404:	108a9a04 	addi	r2,r2,10856
 d015408:	10800003 	ldbu	r2,0(r2)
 d01540c:	10803fcc 	andi	r2,r2,255
 d015410:	1004c03a 	cmpne	r2,r2,zero
 d015414:	1000421e 	bne	r2,zero,d015520 <OSTimeDly+0x138>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 d015418:	e0bfff0b 	ldhu	r2,-4(fp)
 d01541c:	1005003a 	cmpeq	r2,r2,zero
 d015420:	10003f1e 	bne	r2,zero,d015520 <OSTimeDly+0x138>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d015424:	0005303a 	rdctl	r2,status
 d015428:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01542c:	e0fffc17 	ldw	r3,-16(fp)
 d015430:	00bfff84 	movi	r2,-2
 d015434:	1884703a 	and	r2,r3,r2
 d015438:	1001703a 	wrctl	status,r2
  
  return context;
 d01543c:	e0bffc17 	ldw	r2,-16(fp)
        OS_ENTER_CRITICAL();
 d015440:	e0bffd15 	stw	r2,-12(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 d015444:	00834174 	movhi	r2,3333
 d015448:	108a9b04 	addi	r2,r2,10860
 d01544c:	10800017 	ldw	r2,0(r2)
 d015450:	10800d03 	ldbu	r2,52(r2)
 d015454:	e0bffe05 	stb	r2,-8(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 d015458:	e13ffe03 	ldbu	r4,-8(fp)
 d01545c:	e0fffe03 	ldbu	r3,-8(fp)
 d015460:	00834174 	movhi	r2,3333
 d015464:	108a9844 	addi	r2,r2,10849
 d015468:	10c5883a 	add	r2,r2,r3
 d01546c:	10800003 	ldbu	r2,0(r2)
 d015470:	1007883a 	mov	r3,r2
 d015474:	00834174 	movhi	r2,3333
 d015478:	108a9b04 	addi	r2,r2,10860
 d01547c:	10800017 	ldw	r2,0(r2)
 d015480:	10800d43 	ldbu	r2,53(r2)
 d015484:	0084303a 	nor	r2,zero,r2
 d015488:	1884703a 	and	r2,r3,r2
 d01548c:	1007883a 	mov	r3,r2
 d015490:	00834174 	movhi	r2,3333
 d015494:	108a9844 	addi	r2,r2,10849
 d015498:	1105883a 	add	r2,r2,r4
 d01549c:	10c00005 	stb	r3,0(r2)
        if (OSRdyTbl[y] == 0) {
 d0154a0:	e0fffe03 	ldbu	r3,-8(fp)
 d0154a4:	00834174 	movhi	r2,3333
 d0154a8:	108a9844 	addi	r2,r2,10849
 d0154ac:	10c5883a 	add	r2,r2,r3
 d0154b0:	10800003 	ldbu	r2,0(r2)
 d0154b4:	10803fcc 	andi	r2,r2,255
 d0154b8:	1004c03a 	cmpne	r2,r2,zero
 d0154bc:	10000e1e 	bne	r2,zero,d0154f8 <OSTimeDly+0x110>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 d0154c0:	00834174 	movhi	r2,3333
 d0154c4:	108a9b04 	addi	r2,r2,10860
 d0154c8:	10800017 	ldw	r2,0(r2)
 d0154cc:	10800d83 	ldbu	r2,54(r2)
 d0154d0:	0084303a 	nor	r2,zero,r2
 d0154d4:	1007883a 	mov	r3,r2
 d0154d8:	00834174 	movhi	r2,3333
 d0154dc:	108a9804 	addi	r2,r2,10848
 d0154e0:	10800003 	ldbu	r2,0(r2)
 d0154e4:	1884703a 	and	r2,r3,r2
 d0154e8:	1007883a 	mov	r3,r2
 d0154ec:	00834174 	movhi	r2,3333
 d0154f0:	108a9804 	addi	r2,r2,10848
 d0154f4:	10c00005 	stb	r3,0(r2)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 d0154f8:	00834174 	movhi	r2,3333
 d0154fc:	108a9b04 	addi	r2,r2,10860
 d015500:	10c00017 	ldw	r3,0(r2)
 d015504:	e0bfff0b 	ldhu	r2,-4(fp)
 d015508:	18800b8d 	sth	r2,46(r3)
 d01550c:	e0bffd17 	ldw	r2,-12(fp)
 d015510:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d015514:	e0bffb17 	ldw	r2,-20(fp)
 d015518:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 d01551c:	d00f0f40 	call	d00f0f4 <OS_Sched>
    }
}
 d015520:	e037883a 	mov	sp,fp
 d015524:	dfc00117 	ldw	ra,4(sp)
 d015528:	df000017 	ldw	fp,0(sp)
 d01552c:	dec00204 	addi	sp,sp,8
 d015530:	f800283a 	ret

0d015534 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 d015534:	defff704 	addi	sp,sp,-36
 d015538:	dfc00815 	stw	ra,32(sp)
 d01553c:	df000715 	stw	fp,28(sp)
 d015540:	df000704 	addi	fp,sp,28
 d015544:	e13ffb05 	stb	r4,-20(fp)
 d015548:	e17ffc05 	stb	r5,-16(fp)
 d01554c:	e1bffd05 	stb	r6,-12(fp)
 d015550:	e1fffe0d 	sth	r7,-8(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 d015554:	00834174 	movhi	r2,3333
 d015558:	108a9a04 	addi	r2,r2,10856
 d01555c:	10800003 	ldbu	r2,0(r2)
 d015560:	10803fcc 	andi	r2,r2,255
 d015564:	1005003a 	cmpeq	r2,r2,zero
 d015568:	1000031e 	bne	r2,zero,d015578 <OSTimeDlyHMSM+0x44>
        return (OS_ERR_TIME_DLY_ISR);
 d01556c:	00801544 	movi	r2,85
 d015570:	e0bfff15 	stw	r2,-4(fp)
 d015574:	00004506 	br	d01568c <OSTimeDlyHMSM+0x158>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 d015578:	e0bffb03 	ldbu	r2,-20(fp)
 d01557c:	1004c03a 	cmpne	r2,r2,zero
 d015580:	10000c1e 	bne	r2,zero,d0155b4 <OSTimeDlyHMSM+0x80>
        if (minutes == 0) {
 d015584:	e0bffc03 	ldbu	r2,-16(fp)
 d015588:	1004c03a 	cmpne	r2,r2,zero
 d01558c:	1000091e 	bne	r2,zero,d0155b4 <OSTimeDlyHMSM+0x80>
            if (seconds == 0) {
 d015590:	e0bffd03 	ldbu	r2,-12(fp)
 d015594:	1004c03a 	cmpne	r2,r2,zero
 d015598:	1000061e 	bne	r2,zero,d0155b4 <OSTimeDlyHMSM+0x80>
                if (ms == 0) {
 d01559c:	e0bffe0b 	ldhu	r2,-8(fp)
 d0155a0:	1004c03a 	cmpne	r2,r2,zero
 d0155a4:	1000031e 	bne	r2,zero,d0155b4 <OSTimeDlyHMSM+0x80>
                    return (OS_ERR_TIME_ZERO_DLY);
 d0155a8:	00801504 	movi	r2,84
 d0155ac:	e0bfff15 	stw	r2,-4(fp)
 d0155b0:	00003606 	br	d01568c <OSTimeDlyHMSM+0x158>
                }
            }
        }
    }
    if (minutes > 59) {
 d0155b4:	e0bffc03 	ldbu	r2,-16(fp)
 d0155b8:	10800f30 	cmpltui	r2,r2,60
 d0155bc:	1000031e 	bne	r2,zero,d0155cc <OSTimeDlyHMSM+0x98>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 d0155c0:	00801444 	movi	r2,81
 d0155c4:	e0bfff15 	stw	r2,-4(fp)
 d0155c8:	00003006 	br	d01568c <OSTimeDlyHMSM+0x158>
    }
    if (seconds > 59) {
 d0155cc:	e0bffd03 	ldbu	r2,-12(fp)
 d0155d0:	10800f30 	cmpltui	r2,r2,60
 d0155d4:	1000031e 	bne	r2,zero,d0155e4 <OSTimeDlyHMSM+0xb0>
        return (OS_ERR_TIME_INVALID_SECONDS);
 d0155d8:	00801484 	movi	r2,82
 d0155dc:	e0bfff15 	stw	r2,-4(fp)
 d0155e0:	00002a06 	br	d01568c <OSTimeDlyHMSM+0x158>
    }
    if (ms > 999) {
 d0155e4:	e0bffe0b 	ldhu	r2,-8(fp)
 d0155e8:	1080fa30 	cmpltui	r2,r2,1000
 d0155ec:	1000031e 	bne	r2,zero,d0155fc <OSTimeDlyHMSM+0xc8>
        return (OS_ERR_TIME_INVALID_MS);
 d0155f0:	008014c4 	movi	r2,83
 d0155f4:	e0bfff15 	stw	r2,-4(fp)
 d0155f8:	00002406 	br	d01568c <OSTimeDlyHMSM+0x158>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 d0155fc:	e0bffb03 	ldbu	r2,-20(fp)
 d015600:	10c38424 	muli	r3,r2,3600
 d015604:	e0bffc03 	ldbu	r2,-16(fp)
 d015608:	10800f24 	muli	r2,r2,60
 d01560c:	1887883a 	add	r3,r3,r2
 d015610:	e0bffd03 	ldbu	r2,-12(fp)
 d015614:	1885883a 	add	r2,r3,r2
 d015618:	11001924 	muli	r4,r2,100
 d01561c:	e0bffe0b 	ldhu	r2,-8(fp)
 d015620:	10801924 	muli	r2,r2,100
 d015624:	10c07d04 	addi	r3,r2,500
 d015628:	0080fa04 	movi	r2,1000
 d01562c:	1885203a 	divu	r2,r3,r2
 d015630:	2085883a 	add	r2,r4,r2
 d015634:	e0bffa15 	stw	r2,-24(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 d015638:	e0bffa17 	ldw	r2,-24(fp)
 d01563c:	1004d43a 	srli	r2,r2,16
 d015640:	e0bff90d 	sth	r2,-28(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 d015644:	e0bffa17 	ldw	r2,-24(fp)
 d015648:	10bfffcc 	andi	r2,r2,65535
 d01564c:	e0bffa15 	stw	r2,-24(fp)
    OSTimeDly((INT16U)ticks);
 d015650:	e0bffa17 	ldw	r2,-24(fp)
 d015654:	113fffcc 	andi	r4,r2,65535
 d015658:	d0153e80 	call	d0153e8 <OSTimeDly>
    while (loops > 0) {
 d01565c:	00000706 	br	d01567c <OSTimeDlyHMSM+0x148>
        OSTimeDly((INT16U)32768u);
 d015660:	01200014 	movui	r4,32768
 d015664:	d0153e80 	call	d0153e8 <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 d015668:	01200014 	movui	r4,32768
 d01566c:	d0153e80 	call	d0153e8 <OSTimeDly>
        loops--;
 d015670:	e0bff90b 	ldhu	r2,-28(fp)
 d015674:	10bfffc4 	addi	r2,r2,-1
 d015678:	e0bff90d 	sth	r2,-28(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 d01567c:	e0bff90b 	ldhu	r2,-28(fp)
 d015680:	1004c03a 	cmpne	r2,r2,zero
 d015684:	103ff61e 	bne	r2,zero,d015660 <OSTimeDlyHMSM+0x12c>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 d015688:	e03fff15 	stw	zero,-4(fp)
 d01568c:	e0bfff17 	ldw	r2,-4(fp)
}
 d015690:	e037883a 	mov	sp,fp
 d015694:	dfc00117 	ldw	ra,4(sp)
 d015698:	df000017 	ldw	fp,0(sp)
 d01569c:	dec00204 	addi	sp,sp,8
 d0156a0:	f800283a 	ret

0d0156a4 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 d0156a4:	defff404 	addi	sp,sp,-48
 d0156a8:	dfc00b15 	stw	ra,44(sp)
 d0156ac:	df000a15 	stw	fp,40(sp)
 d0156b0:	df000a04 	addi	fp,sp,40
 d0156b4:	e13ffe05 	stb	r4,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 d0156b8:	e03ffc15 	stw	zero,-16(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 d0156bc:	e0bffe03 	ldbu	r2,-8(fp)
 d0156c0:	10800530 	cmpltui	r2,r2,20
 d0156c4:	1000031e 	bne	r2,zero,d0156d4 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 d0156c8:	00800a84 	movi	r2,42
 d0156cc:	e0bfff15 	stw	r2,-4(fp)
 d0156d0:	00007206 	br	d01589c <OSTimeDlyResume+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0156d4:	0005303a 	rdctl	r2,status
 d0156d8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0156dc:	e0fffb17 	ldw	r3,-20(fp)
 d0156e0:	00bfff84 	movi	r2,-2
 d0156e4:	1884703a 	and	r2,r3,r2
 d0156e8:	1001703a 	wrctl	status,r2
  
  return context;
 d0156ec:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 d0156f0:	e0bffc15 	stw	r2,-16(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 d0156f4:	e0bffe03 	ldbu	r2,-8(fp)
 d0156f8:	00c341b4 	movhi	r3,3334
 d0156fc:	18f13304 	addi	r3,r3,-15156
 d015700:	1085883a 	add	r2,r2,r2
 d015704:	1085883a 	add	r2,r2,r2
 d015708:	10c5883a 	add	r2,r2,r3
 d01570c:	10800017 	ldw	r2,0(r2)
 d015710:	e0bffd15 	stw	r2,-12(fp)
    if (ptcb == (OS_TCB *)0) {
 d015714:	e0bffd17 	ldw	r2,-12(fp)
 d015718:	1004c03a 	cmpne	r2,r2,zero
 d01571c:	1000071e 	bne	r2,zero,d01573c <OSTimeDlyResume+0x98>
 d015720:	e0bffc17 	ldw	r2,-16(fp)
 d015724:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d015728:	e0bffa17 	ldw	r2,-24(fp)
 d01572c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 d015730:	008010c4 	movi	r2,67
 d015734:	e0bfff15 	stw	r2,-4(fp)
 d015738:	00005806 	br	d01589c <OSTimeDlyResume+0x1f8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 d01573c:	e0bffd17 	ldw	r2,-12(fp)
 d015740:	10800058 	cmpnei	r2,r2,1
 d015744:	1000071e 	bne	r2,zero,d015764 <OSTimeDlyResume+0xc0>
 d015748:	e0bffc17 	ldw	r2,-16(fp)
 d01574c:	e0bff915 	stw	r2,-28(fp)
 d015750:	e0bff917 	ldw	r2,-28(fp)
 d015754:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 d015758:	008010c4 	movi	r2,67
 d01575c:	e0bfff15 	stw	r2,-4(fp)
 d015760:	00004e06 	br	d01589c <OSTimeDlyResume+0x1f8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 d015764:	e0bffd17 	ldw	r2,-12(fp)
 d015768:	10800b8b 	ldhu	r2,46(r2)
 d01576c:	10bfffcc 	andi	r2,r2,65535
 d015770:	1004c03a 	cmpne	r2,r2,zero
 d015774:	1000071e 	bne	r2,zero,d015794 <OSTimeDlyResume+0xf0>
 d015778:	e0bffc17 	ldw	r2,-16(fp)
 d01577c:	e0bff815 	stw	r2,-32(fp)
 d015780:	e0bff817 	ldw	r2,-32(fp)
 d015784:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 d015788:	00801404 	movi	r2,80
 d01578c:	e0bfff15 	stw	r2,-4(fp)
 d015790:	00004206 	br	d01589c <OSTimeDlyResume+0x1f8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 d015794:	e0bffd17 	ldw	r2,-12(fp)
 d015798:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 d01579c:	e0bffd17 	ldw	r2,-12(fp)
 d0157a0:	10800c03 	ldbu	r2,48(r2)
 d0157a4:	10803fcc 	andi	r2,r2,255
 d0157a8:	10800dcc 	andi	r2,r2,55
 d0157ac:	1005003a 	cmpeq	r2,r2,zero
 d0157b0:	10000b1e 	bne	r2,zero,d0157e0 <OSTimeDlyResume+0x13c>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 d0157b4:	e0bffd17 	ldw	r2,-12(fp)
 d0157b8:	10c00c03 	ldbu	r3,48(r2)
 d0157bc:	00bff204 	movi	r2,-56
 d0157c0:	1884703a 	and	r2,r3,r2
 d0157c4:	1007883a 	mov	r3,r2
 d0157c8:	e0bffd17 	ldw	r2,-12(fp)
 d0157cc:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 d0157d0:	e0fffd17 	ldw	r3,-12(fp)
 d0157d4:	00800044 	movi	r2,1
 d0157d8:	18800c45 	stb	r2,49(r3)
 d0157dc:	00000206 	br	d0157e8 <OSTimeDlyResume+0x144>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 d0157e0:	e0bffd17 	ldw	r2,-12(fp)
 d0157e4:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 d0157e8:	e0bffd17 	ldw	r2,-12(fp)
 d0157ec:	10800c03 	ldbu	r2,48(r2)
 d0157f0:	10803fcc 	andi	r2,r2,255
 d0157f4:	1080020c 	andi	r2,r2,8
 d0157f8:	1004c03a 	cmpne	r2,r2,zero
 d0157fc:	1000221e 	bne	r2,zero,d015888 <OSTimeDlyResume+0x1e4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 d015800:	e0bffd17 	ldw	r2,-12(fp)
 d015804:	10c00d83 	ldbu	r3,54(r2)
 d015808:	00834174 	movhi	r2,3333
 d01580c:	108a9804 	addi	r2,r2,10848
 d015810:	10800003 	ldbu	r2,0(r2)
 d015814:	1884b03a 	or	r2,r3,r2
 d015818:	1007883a 	mov	r3,r2
 d01581c:	00834174 	movhi	r2,3333
 d015820:	108a9804 	addi	r2,r2,10848
 d015824:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 d015828:	e0bffd17 	ldw	r2,-12(fp)
 d01582c:	10800d03 	ldbu	r2,52(r2)
 d015830:	11003fcc 	andi	r4,r2,255
 d015834:	e0bffd17 	ldw	r2,-12(fp)
 d015838:	10800d03 	ldbu	r2,52(r2)
 d01583c:	10c03fcc 	andi	r3,r2,255
 d015840:	00834174 	movhi	r2,3333
 d015844:	108a9844 	addi	r2,r2,10849
 d015848:	10c5883a 	add	r2,r2,r3
 d01584c:	10c00003 	ldbu	r3,0(r2)
 d015850:	e0bffd17 	ldw	r2,-12(fp)
 d015854:	10800d43 	ldbu	r2,53(r2)
 d015858:	1884b03a 	or	r2,r3,r2
 d01585c:	1007883a 	mov	r3,r2
 d015860:	00834174 	movhi	r2,3333
 d015864:	108a9844 	addi	r2,r2,10849
 d015868:	1105883a 	add	r2,r2,r4
 d01586c:	10c00005 	stb	r3,0(r2)
 d015870:	e0bffc17 	ldw	r2,-16(fp)
 d015874:	e0bff715 	stw	r2,-36(fp)
 d015878:	e0bff717 	ldw	r2,-36(fp)
 d01587c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 d015880:	d00f0f40 	call	d00f0f4 <OS_Sched>
 d015884:	00000406 	br	d015898 <OSTimeDlyResume+0x1f4>
 d015888:	e0bffc17 	ldw	r2,-16(fp)
 d01588c:	e0bff615 	stw	r2,-40(fp)
 d015890:	e0bff617 	ldw	r2,-40(fp)
 d015894:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 d015898:	e03fff15 	stw	zero,-4(fp)
 d01589c:	e0bfff17 	ldw	r2,-4(fp)
}
 d0158a0:	e037883a 	mov	sp,fp
 d0158a4:	dfc00117 	ldw	ra,4(sp)
 d0158a8:	df000017 	ldw	fp,0(sp)
 d0158ac:	dec00204 	addi	sp,sp,8
 d0158b0:	f800283a 	ret

0d0158b4 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 d0158b4:	defffb04 	addi	sp,sp,-20
 d0158b8:	df000415 	stw	fp,16(sp)
 d0158bc:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d0158c0:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0158c4:	0005303a 	rdctl	r2,status
 d0158c8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0158cc:	e0fffd17 	ldw	r3,-12(fp)
 d0158d0:	00bfff84 	movi	r2,-2
 d0158d4:	1884703a 	and	r2,r3,r2
 d0158d8:	1001703a 	wrctl	status,r2
  
  return context;
 d0158dc:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 d0158e0:	e0bffe15 	stw	r2,-8(fp)
    ticks = OSTime;
 d0158e4:	00834174 	movhi	r2,3333
 d0158e8:	108a9c04 	addi	r2,r2,10864
 d0158ec:	10800017 	ldw	r2,0(r2)
 d0158f0:	e0bfff15 	stw	r2,-4(fp)
 d0158f4:	e0bffe17 	ldw	r2,-8(fp)
 d0158f8:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0158fc:	e0bffc17 	ldw	r2,-16(fp)
 d015900:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 d015904:	e0bfff17 	ldw	r2,-4(fp)
}
 d015908:	e037883a 	mov	sp,fp
 d01590c:	df000017 	ldw	fp,0(sp)
 d015910:	dec00104 	addi	sp,sp,4
 d015914:	f800283a 	ret

0d015918 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 d015918:	defffb04 	addi	sp,sp,-20
 d01591c:	df000415 	stw	fp,16(sp)
 d015920:	df000404 	addi	fp,sp,16
 d015924:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 d015928:	e03ffe15 	stw	zero,-8(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01592c:	0005303a 	rdctl	r2,status
 d015930:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d015934:	e0fffd17 	ldw	r3,-12(fp)
 d015938:	00bfff84 	movi	r2,-2
 d01593c:	1884703a 	and	r2,r3,r2
 d015940:	1001703a 	wrctl	status,r2
  
  return context;
 d015944:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 d015948:	e0bffe15 	stw	r2,-8(fp)
    OSTime = ticks;
 d01594c:	00c34174 	movhi	r3,3333
 d015950:	18ca9c04 	addi	r3,r3,10864
 d015954:	e0bfff17 	ldw	r2,-4(fp)
 d015958:	18800015 	stw	r2,0(r3)
 d01595c:	e0bffe17 	ldw	r2,-8(fp)
 d015960:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d015964:	e0bffc17 	ldw	r2,-16(fp)
 d015968:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 d01596c:	e037883a 	mov	sp,fp
 d015970:	df000017 	ldw	fp,0(sp)
 d015974:	dec00104 	addi	sp,sp,4
 d015978:	f800283a 	ret

0d01597c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 d01597c:	defffd04 	addi	sp,sp,-12
 d015980:	dfc00215 	stw	ra,8(sp)
 d015984:	df000115 	stw	fp,4(sp)
 d015988:	df000104 	addi	fp,sp,4
 d01598c:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_IRQ_INIT ( CPU, cpu);
 d015990:	d039b680 	call	d039b68 <altera_nios2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 d015994:	00800044 	movi	r2,1
 d015998:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 d01599c:	e037883a 	mov	sp,fp
 d0159a0:	dfc00117 	ldw	ra,4(sp)
 d0159a4:	df000017 	ldw	fp,0(sp)
 d0159a8:	dec00204 	addi	sp,sp,8
 d0159ac:	f800283a 	ret

0d0159b0 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 d0159b0:	defffa04 	addi	sp,sp,-24
 d0159b4:	dfc00515 	stw	ra,20(sp)
 d0159b8:	df000415 	stw	fp,16(sp)
 d0159bc:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 d0159c0:	01080034 	movhi	r4,8192
 d0159c4:	210d3804 	addi	r4,r4,13536
 d0159c8:	000b883a 	mov	r5,zero
 d0159cc:	01800344 	movi	r6,13
 d0159d0:	01c01904 	movi	r7,100
 d0159d4:	d01a4b80 	call	d01a4b8 <alt_avalon_timer_sc_init>
    ALTERA_AVALON_CFI_FLASH_INIT ( EXT_FLASH, ext_flash);
 d0159d8:	01034174 	movhi	r4,3333
 d0159dc:	21047d04 	addi	r4,r4,4596
 d0159e0:	d015c5c0 	call	d015c5c <alt_flash_cfi_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 d0159e4:	01034174 	movhi	r4,3333
 d0159e8:	2104bd04 	addi	r4,r4,4852
 d0159ec:	000b883a 	mov	r5,zero
 d0159f0:	01800044 	movi	r6,1
 d0159f4:	d017ac40 	call	d017ac4 <altera_avalon_jtag_uart_init>
 d0159f8:	01034174 	movhi	r4,3333
 d0159fc:	2104b304 	addi	r4,r4,4812
 d015a00:	d015c240 	call	d015c24 <alt_dev_reg>
    ALTERA_AVALON_LCD_16207_INIT ( TRISTATE_LCD, tristate_lcd);
 d015a04:	01034174 	movhi	r4,3333
 d015a08:	2108d804 	addi	r4,r4,9056
 d015a0c:	d0194a80 	call	d0194a8 <altera_avalon_lcd_16207_init>
 d015a10:	01034174 	movhi	r4,3333
 d015a14:	2108ce04 	addi	r4,r4,9016
 d015a18:	d015c240 	call	d015c24 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 d015a1c:	01034174 	movhi	r4,3333
 d015a20:	21091704 	addi	r4,r4,9308
 d015a24:	000b883a 	mov	r5,zero
 d015a28:	01800084 	movi	r6,2
 d015a2c:	d01a39c0 	call	d01a39c <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 d015a30:	01034174 	movhi	r4,3333
 d015a34:	21092304 	addi	r4,r4,9356
 d015a38:	000b883a 	mov	r5,zero
 d015a3c:	018000c4 	movi	r6,3
 d015a40:	d01a39c0 	call	d01a39c <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_INIT ( SYSID, sysid);
    TRIPLE_SPEED_ETHERNET_INIT ( TSE_MAC, tse_mac);
 d015a44:	e03fff15 	stw	zero,-4(fp)
 d015a48:	00800044 	movi	r2,1
 d015a4c:	e0bffe15 	stw	r2,-8(fp)
 d015a50:	e0bffe17 	ldw	r2,-8(fp)
 d015a54:	10800048 	cmpgei	r2,r2,1
 d015a58:	1000021e 	bne	r2,zero,d015a64 <alt_sys_init+0xb4>
 d015a5c:	00800044 	movi	r2,1
 d015a60:	e0bffe15 	stw	r2,-8(fp)
 d015a64:	e03fff15 	stw	zero,-4(fp)
 d015a68:	00006606 	br	d015c04 <alt_sys_init+0x254>
 d015a6c:	e0bfff17 	ldw	r2,-4(fp)
 d015a70:	00c341b4 	movhi	r3,3334
 d015a74:	18f14804 	addi	r3,r3,-15072
 d015a78:	10800724 	muli	r2,r2,28
 d015a7c:	10c5883a 	add	r2,r2,r3
 d015a80:	10000015 	stw	zero,0(r2)
 d015a84:	e0bfff17 	ldw	r2,-4(fp)
 d015a88:	00c341b4 	movhi	r3,3334
 d015a8c:	18f14804 	addi	r3,r3,-15072
 d015a90:	10800724 	muli	r2,r2,28
 d015a94:	10c5883a 	add	r2,r2,r3
 d015a98:	10800104 	addi	r2,r2,4
 d015a9c:	10000015 	stw	zero,0(r2)
 d015aa0:	e0bfff17 	ldw	r2,-4(fp)
 d015aa4:	d1202917 	ldw	r4,-32604(gp)
 d015aa8:	00c341b4 	movhi	r3,3334
 d015aac:	18f14804 	addi	r3,r3,-15072
 d015ab0:	10800724 	muli	r2,r2,28
 d015ab4:	10c5883a 	add	r2,r2,r3
 d015ab8:	10800204 	addi	r2,r2,8
 d015abc:	11000015 	stw	r4,0(r2)
 d015ac0:	e0bfff17 	ldw	r2,-4(fp)
 d015ac4:	00c341b4 	movhi	r3,3334
 d015ac8:	18f14804 	addi	r3,r3,-15072
 d015acc:	10800724 	muli	r2,r2,28
 d015ad0:	10c5883a 	add	r2,r2,r3
 d015ad4:	10c00304 	addi	r3,r2,12
 d015ad8:	008340b4 	movhi	r2,3330
 d015adc:	10be2604 	addi	r2,r2,-1896
 d015ae0:	18800015 	stw	r2,0(r3)
 d015ae4:	e0bfff17 	ldw	r2,-4(fp)
 d015ae8:	10c00724 	muli	r3,r2,28
 d015aec:	008341b4 	movhi	r2,3334
 d015af0:	10b14804 	addi	r2,r2,-15072
 d015af4:	1887883a 	add	r3,r3,r2
 d015af8:	00834174 	movhi	r2,3333
 d015afc:	108a4f04 	addi	r2,r2,10556
 d015b00:	e0bffc15 	stw	r2,-16(fp)
 d015b04:	e0fffd15 	stw	r3,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 d015b08:	e0fffd17 	ldw	r3,-12(fp)
 d015b0c:	e0bffc17 	ldw	r2,-16(fp)
 d015b10:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 d015b14:	e0bffc17 	ldw	r2,-16(fp)
 d015b18:	10c00017 	ldw	r3,0(r2)
 d015b1c:	e0bffd17 	ldw	r2,-12(fp)
 d015b20:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 d015b24:	e0bffc17 	ldw	r2,-16(fp)
 d015b28:	10c00017 	ldw	r3,0(r2)
 d015b2c:	e0bffd17 	ldw	r2,-12(fp)
 d015b30:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 d015b34:	e0fffc17 	ldw	r3,-16(fp)
 d015b38:	e0bffd17 	ldw	r2,-12(fp)
 d015b3c:	18800015 	stw	r2,0(r3)
 d015b40:	00834174 	movhi	r2,3333
 d015b44:	108aa104 	addi	r2,r2,10884
 d015b48:	10800003 	ldbu	r2,0(r2)
 d015b4c:	11403fcc 	andi	r5,r2,255
 d015b50:	e0bfff17 	ldw	r2,-4(fp)
 d015b54:	10c00724 	muli	r3,r2,28
 d015b58:	008341b4 	movhi	r2,3334
 d015b5c:	10b14804 	addi	r2,r2,-15072
 d015b60:	1889883a 	add	r4,r3,r2
 d015b64:	00c341b4 	movhi	r3,3334
 d015b68:	18f18804 	addi	r3,r3,-14816
 d015b6c:	28800324 	muli	r2,r5,12
 d015b70:	10c5883a 	add	r2,r2,r3
 d015b74:	11000015 	stw	r4,0(r2)
 d015b78:	00834174 	movhi	r2,3333
 d015b7c:	108aa104 	addi	r2,r2,10884
 d015b80:	10800003 	ldbu	r2,0(r2)
 d015b84:	10803fcc 	andi	r2,r2,255
 d015b88:	00c341b4 	movhi	r3,3334
 d015b8c:	18f18804 	addi	r3,r3,-14816
 d015b90:	10800324 	muli	r2,r2,12
 d015b94:	10c5883a 	add	r2,r2,r3
 d015b98:	10c00104 	addi	r3,r2,4
 d015b9c:	00880034 	movhi	r2,8192
 d015ba0:	108c0004 	addi	r2,r2,12288
 d015ba4:	18800015 	stw	r2,0(r3)
 d015ba8:	00834174 	movhi	r2,3333
 d015bac:	108aa104 	addi	r2,r2,10884
 d015bb0:	10800003 	ldbu	r2,0(r2)
 d015bb4:	11003fcc 	andi	r4,r2,255
 d015bb8:	e0bfff17 	ldw	r2,-4(fp)
 d015bbc:	100b883a 	mov	r5,r2
 d015bc0:	00c341b4 	movhi	r3,3334
 d015bc4:	18f18804 	addi	r3,r3,-14816
 d015bc8:	20800324 	muli	r2,r4,12
 d015bcc:	10c5883a 	add	r2,r2,r3
 d015bd0:	10800204 	addi	r2,r2,8
 d015bd4:	11400005 	stb	r5,0(r2)
 d015bd8:	00834174 	movhi	r2,3333
 d015bdc:	108aa104 	addi	r2,r2,10884
 d015be0:	10800003 	ldbu	r2,0(r2)
 d015be4:	10800044 	addi	r2,r2,1
 d015be8:	1007883a 	mov	r3,r2
 d015bec:	00834174 	movhi	r2,3333
 d015bf0:	108aa104 	addi	r2,r2,10884
 d015bf4:	10c00005 	stb	r3,0(r2)
 d015bf8:	e0bfff17 	ldw	r2,-4(fp)
 d015bfc:	10800044 	addi	r2,r2,1
 d015c00:	e0bfff15 	stw	r2,-4(fp)
 d015c04:	e0ffff17 	ldw	r3,-4(fp)
 d015c08:	e0bffe17 	ldw	r2,-8(fp)
 d015c0c:	18bf9716 	blt	r3,r2,d015a6c <alt_sys_init+0xbc>
}
 d015c10:	e037883a 	mov	sp,fp
 d015c14:	dfc00117 	ldw	ra,4(sp)
 d015c18:	df000017 	ldw	fp,0(sp)
 d015c1c:	dec00204 	addi	sp,sp,8
 d015c20:	f800283a 	ret

0d015c24 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 d015c24:	defffd04 	addi	sp,sp,-12
 d015c28:	dfc00215 	stw	ra,8(sp)
 d015c2c:	df000115 	stw	fp,4(sp)
 d015c30:	df000104 	addi	fp,sp,4
 d015c34:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 d015c38:	e13fff17 	ldw	r4,-4(fp)
 d015c3c:	01434174 	movhi	r5,3333
 d015c40:	294a6504 	addi	r5,r5,10644
 d015c44:	d038b300 	call	d038b30 <alt_dev_llist_insert>
}
 d015c48:	e037883a 	mov	sp,fp
 d015c4c:	dfc00117 	ldw	ra,4(sp)
 d015c50:	df000017 	ldw	fp,0(sp)
 d015c54:	dec00204 	addi	sp,sp,8
 d015c58:	f800283a 	ret

0d015c5c <alt_flash_cfi_init>:
 * Read the CFI table and fill out the alt_flash_cfi_dev structure with all the 
 * information we need to program the flash.
 * 
 */
int alt_flash_cfi_init( alt_flash_cfi_dev* flash  )
{
 d015c5c:	defffc04 	addi	sp,sp,-16
 d015c60:	dfc00315 	stw	ra,12(sp)
 d015c64:	df000215 	stw	fp,8(sp)
 d015c68:	df000204 	addi	fp,sp,8
 d015c6c:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 d015c70:	e03ffe15 	stw	zero,-8(fp)
 
  ret_code = alt_read_cfi_width( flash );
 d015c74:	e13fff17 	ldw	r4,-4(fp)
 d015c78:	d0170f40 	call	d0170f4 <alt_read_cfi_width>
 d015c7c:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 d015c80:	e0bffe17 	ldw	r2,-8(fp)
 d015c84:	1004c03a 	cmpne	r2,r2,zero
 d015c88:	1000031e 	bne	r2,zero,d015c98 <alt_flash_cfi_init+0x3c>
    ret_code = alt_set_flash_width_func( flash );
 d015c8c:	e13fff17 	ldw	r4,-4(fp)
 d015c90:	d01686c0 	call	d01686c <alt_set_flash_width_func>
 d015c94:	e0bffe15 	stw	r2,-8(fp)
  
  if (!ret_code)
 d015c98:	e0bffe17 	ldw	r2,-8(fp)
 d015c9c:	1004c03a 	cmpne	r2,r2,zero
 d015ca0:	1000031e 	bne	r2,zero,d015cb0 <alt_flash_cfi_init+0x54>
    ret_code = alt_read_cfi_table( flash );
 d015ca4:	e13fff17 	ldw	r4,-4(fp)
 d015ca8:	d016b740 	call	d016b74 <alt_read_cfi_table>
 d015cac:	e0bffe15 	stw	r2,-8(fp)

  if (!ret_code) 
 d015cb0:	e0bffe17 	ldw	r2,-8(fp)
 d015cb4:	1004c03a 	cmpne	r2,r2,zero
 d015cb8:	1000031e 	bne	r2,zero,d015cc8 <alt_flash_cfi_init+0x6c>
    ret_code = alt_set_flash_algorithm_func( flash);
 d015cbc:	e13fff17 	ldw	r4,-4(fp)
 d015cc0:	d016a4c0 	call	d016a4c <alt_set_flash_algorithm_func>
 d015cc4:	e0bffe15 	stw	r2,-8(fp)

  /*
  *  Register this device as a valid flash device type
  */ 
  if (!ret_code)
 d015cc8:	e0bffe17 	ldw	r2,-8(fp)
 d015ccc:	1004c03a 	cmpne	r2,r2,zero
 d015cd0:	1000031e 	bne	r2,zero,d015ce0 <alt_flash_cfi_init+0x84>
    ret_code = alt_flash_device_register(&(flash->dev));
 d015cd4:	e13fff17 	ldw	r4,-4(fp)
 d015cd8:	d015cf80 	call	d015cf8 <alt_flash_device_register>
 d015cdc:	e0bffe15 	stw	r2,-8(fp)
 
  return ret_code;
 d015ce0:	e0bffe17 	ldw	r2,-8(fp)
}
 d015ce4:	e037883a 	mov	sp,fp
 d015ce8:	dfc00117 	ldw	ra,4(sp)
 d015cec:	df000017 	ldw	fp,0(sp)
 d015cf0:	dec00204 	addi	sp,sp,8
 d015cf4:	f800283a 	ret

0d015cf8 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 d015cf8:	defffd04 	addi	sp,sp,-12
 d015cfc:	dfc00215 	stw	ra,8(sp)
 d015d00:	df000115 	stw	fp,4(sp)
 d015d04:	df000104 	addi	fp,sp,4
 d015d08:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 d015d0c:	e13fff17 	ldw	r4,-4(fp)
 d015d10:	01434174 	movhi	r5,3333
 d015d14:	294a2804 	addi	r5,r5,10400
 d015d18:	d038b300 	call	d038b30 <alt_dev_llist_insert>
}
 d015d1c:	e037883a 	mov	sp,fp
 d015d20:	dfc00117 	ldw	ra,4(sp)
 d015d24:	df000017 	ldw	fp,0(sp)
 d015d28:	dec00204 	addi	sp,sp,8
 d015d2c:	f800283a 	ret

0d015d30 <alt_flash_cfi_write>:
 * large buffer to tie up in our programming library, when not all users will 
 * want that functionality.
 */
 int alt_flash_cfi_write( alt_flash_dev* flash_info, int offset, 
                          const void* src_addr, int length )
 {
 d015d30:	deffef04 	addi	sp,sp,-68
 d015d34:	dfc01015 	stw	ra,64(sp)
 d015d38:	df000f15 	stw	fp,60(sp)
 d015d3c:	df000f04 	addi	fp,sp,60
 d015d40:	e13ffa15 	stw	r4,-24(fp)
 d015d44:	e17ffb15 	stw	r5,-20(fp)
 d015d48:	e1bffc15 	stw	r6,-16(fp)
 d015d4c:	e1fffd15 	stw	r7,-12(fp)
  int         ret_code = 0;
 d015d50:	e03ff915 	stw	zero,-28(fp)
  int         i,j;
  int         data_to_write;
  int         full_length = length;
 d015d54:	e0bffd17 	ldw	r2,-12(fp)
 d015d58:	e0bff515 	stw	r2,-44(fp)
  int         current_offset;
  int         start_offset = offset;
 d015d5c:	e0bffb17 	ldw	r2,-20(fp)
 d015d60:	e0bff315 	stw	r2,-52(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d015d64:	e0bffa17 	ldw	r2,-24(fp)
 d015d68:	e0bff215 	stw	r2,-56(fp)

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 d015d6c:	e03ff815 	stw	zero,-32(fp)
 d015d70:	00008e06 	br	d015fac <alt_flash_cfi_write+0x27c>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash->dev.region_info[i].offset) &&
 d015d74:	e0bff817 	ldw	r2,-32(fp)
 d015d78:	e0fff217 	ldw	r3,-56(fp)
 d015d7c:	1004913a 	slli	r2,r2,4
 d015d80:	10c5883a 	add	r2,r2,r3
 d015d84:	10800d04 	addi	r2,r2,52
 d015d88:	10c00017 	ldw	r3,0(r2)
 d015d8c:	e0bffb17 	ldw	r2,-20(fp)
 d015d90:	10c08316 	blt	r2,r3,d015fa0 <alt_flash_cfi_write+0x270>
 d015d94:	e0bff817 	ldw	r2,-32(fp)
 d015d98:	e0fff217 	ldw	r3,-56(fp)
 d015d9c:	1004913a 	slli	r2,r2,4
 d015da0:	10c5883a 	add	r2,r2,r3
 d015da4:	10800d04 	addi	r2,r2,52
 d015da8:	11000017 	ldw	r4,0(r2)
 d015dac:	e0bff817 	ldw	r2,-32(fp)
 d015db0:	e0fff217 	ldw	r3,-56(fp)
 d015db4:	1004913a 	slli	r2,r2,4
 d015db8:	10c5883a 	add	r2,r2,r3
 d015dbc:	10800e04 	addi	r2,r2,56
 d015dc0:	10800017 	ldw	r2,0(r2)
 d015dc4:	2087883a 	add	r3,r4,r2
 d015dc8:	e0bffb17 	ldw	r2,-20(fp)
 d015dcc:	10c0740e 	bge	r2,r3,d015fa0 <alt_flash_cfi_write+0x270>
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;
 d015dd0:	e0bff817 	ldw	r2,-32(fp)
 d015dd4:	e0fff217 	ldw	r3,-56(fp)
 d015dd8:	1004913a 	slli	r2,r2,4
 d015ddc:	10c5883a 	add	r2,r2,r3
 d015de0:	10800d04 	addi	r2,r2,52
 d015de4:	10800017 	ldw	r2,0(r2)
 d015de8:	e0bff415 	stw	r2,-48(fp)

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 d015dec:	e03ff715 	stw	zero,-36(fp)
 d015df0:	00006306 	br	d015f80 <alt_flash_cfi_write+0x250>
      {
        if ((offset >= current_offset ) && 
 d015df4:	e0fffb17 	ldw	r3,-20(fp)
 d015df8:	e0bff417 	ldw	r2,-48(fp)
 d015dfc:	18805416 	blt	r3,r2,d015f50 <alt_flash_cfi_write+0x220>
 d015e00:	e0bff817 	ldw	r2,-32(fp)
 d015e04:	e0fff217 	ldw	r3,-56(fp)
 d015e08:	1004913a 	slli	r2,r2,4
 d015e0c:	10c5883a 	add	r2,r2,r3
 d015e10:	10801004 	addi	r2,r2,64
 d015e14:	10c00017 	ldw	r3,0(r2)
 d015e18:	e0bff417 	ldw	r2,-48(fp)
 d015e1c:	1887883a 	add	r3,r3,r2
 d015e20:	e0bffb17 	ldw	r2,-20(fp)
 d015e24:	10c04a0e 	bge	r2,r3,d015f50 <alt_flash_cfi_write+0x220>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash->dev.region_info[i].block_size 
 d015e28:	e0bff817 	ldw	r2,-32(fp)
 d015e2c:	e0fff217 	ldw	r3,-56(fp)
 d015e30:	1004913a 	slli	r2,r2,4
 d015e34:	10c5883a 	add	r2,r2,r3
 d015e38:	10801004 	addi	r2,r2,64
 d015e3c:	10c00017 	ldw	r3,0(r2)
 d015e40:	e0bff417 	ldw	r2,-48(fp)
 d015e44:	1887883a 	add	r3,r3,r2
 d015e48:	e0bffb17 	ldw	r2,-20(fp)
 d015e4c:	1885c83a 	sub	r2,r3,r2
 d015e50:	e0bff615 	stw	r2,-40(fp)
                            - offset); 
          data_to_write = MIN(data_to_write, length);
 d015e54:	e0bff617 	ldw	r2,-40(fp)
 d015e58:	e0bfff15 	stw	r2,-4(fp)
 d015e5c:	e0fffd17 	ldw	r3,-12(fp)
 d015e60:	e0fffe15 	stw	r3,-8(fp)
 d015e64:	e0bfff17 	ldw	r2,-4(fp)
 d015e68:	e0fffe17 	ldw	r3,-8(fp)
 d015e6c:	10c0020e 	bge	r2,r3,d015e78 <alt_flash_cfi_write+0x148>
 d015e70:	e0bfff17 	ldw	r2,-4(fp)
 d015e74:	e0bffe15 	stw	r2,-8(fp)
 d015e78:	e0fffe17 	ldw	r3,-8(fp)
 d015e7c:	e0fff615 	stw	r3,-40(fp)
          if(memcmp(src_addr, 
 d015e80:	e0bff217 	ldw	r2,-56(fp)
 d015e84:	10800a17 	ldw	r2,40(r2)
 d015e88:	1007883a 	mov	r3,r2
 d015e8c:	e0bffb17 	ldw	r2,-20(fp)
 d015e90:	188b883a 	add	r5,r3,r2
 d015e94:	e1bff617 	ldw	r6,-40(fp)
 d015e98:	e13ffc17 	ldw	r4,-16(fp)
 d015e9c:	d049ed40 	call	d049ed4 <memcmp>
 d015ea0:	1005003a 	cmpeq	r2,r2,zero
 d015ea4:	1000131e 	bne	r2,zero,d015ef4 <alt_flash_cfi_write+0x1c4>
                    (alt_u8*)flash->dev.base_addr+offset,
                    data_to_write))
          {
            ret_code = (*flash->dev.erase_block)( &flash->dev, current_offset);
 d015ea8:	e0bff217 	ldw	r2,-56(fp)
 d015eac:	10800817 	ldw	r2,32(r2)
 d015eb0:	e13ff217 	ldw	r4,-56(fp)
 d015eb4:	e17ff417 	ldw	r5,-48(fp)
 d015eb8:	103ee83a 	callr	r2
 d015ebc:	e0bff915 	stw	r2,-28(fp)

            if (!ret_code)
 d015ec0:	e0bff917 	ldw	r2,-28(fp)
 d015ec4:	1004c03a 	cmpne	r2,r2,zero
 d015ec8:	10000a1e 	bne	r2,zero,d015ef4 <alt_flash_cfi_write+0x1c4>
            {
              ret_code = (*flash->dev.write_block)( 
 d015ecc:	e0bff217 	ldw	r2,-56(fp)
 d015ed0:	10c00917 	ldw	r3,36(r2)
 d015ed4:	e13ff217 	ldw	r4,-56(fp)
 d015ed8:	e0bff617 	ldw	r2,-40(fp)
 d015edc:	d8800015 	stw	r2,0(sp)
 d015ee0:	e17ff417 	ldw	r5,-48(fp)
 d015ee4:	e1bffb17 	ldw	r6,-20(fp)
 d015ee8:	e1fffc17 	ldw	r7,-16(fp)
 d015eec:	183ee83a 	callr	r3
 d015ef0:	e0bff915 	stw	r2,-28(fp)
                                                  data_to_write);
            }
          }    
    
          /* Was this the last block? */    
          if ((length == data_to_write) || ret_code)
 d015ef4:	e0fffd17 	ldw	r3,-12(fp)
 d015ef8:	e0bff617 	ldw	r2,-40(fp)
 d015efc:	18802f26 	beq	r3,r2,d015fbc <alt_flash_cfi_write+0x28c>
 d015f00:	e0bff917 	ldw	r2,-28(fp)
 d015f04:	1004c03a 	cmpne	r2,r2,zero
 d015f08:	10002c1e 	bne	r2,zero,d015fbc <alt_flash_cfi_write+0x28c>
          {
            goto finished;
          }
          
          length -= data_to_write;
 d015f0c:	e0fffd17 	ldw	r3,-12(fp)
 d015f10:	e0bff617 	ldw	r2,-40(fp)
 d015f14:	1885c83a 	sub	r2,r3,r2
 d015f18:	e0bffd15 	stw	r2,-12(fp)
          offset = current_offset + flash->dev.region_info[i].block_size;
 d015f1c:	e0bff817 	ldw	r2,-32(fp)
 d015f20:	e0fff217 	ldw	r3,-56(fp)
 d015f24:	1004913a 	slli	r2,r2,4
 d015f28:	10c5883a 	add	r2,r2,r3
 d015f2c:	10801004 	addi	r2,r2,64
 d015f30:	10c00017 	ldw	r3,0(r2)
 d015f34:	e0bff417 	ldw	r2,-48(fp)
 d015f38:	1885883a 	add	r2,r3,r2
 d015f3c:	e0bffb15 	stw	r2,-20(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 d015f40:	e0fffc17 	ldw	r3,-16(fp)
 d015f44:	e0bff617 	ldw	r2,-40(fp)
 d015f48:	1885883a 	add	r2,r3,r2
 d015f4c:	e0bffc15 	stw	r2,-16(fp)
        }
        current_offset += flash->dev.region_info[i].block_size;
 d015f50:	e0bff817 	ldw	r2,-32(fp)
 d015f54:	e0fff217 	ldw	r3,-56(fp)
 d015f58:	1004913a 	slli	r2,r2,4
 d015f5c:	10c5883a 	add	r2,r2,r3
 d015f60:	10801004 	addi	r2,r2,64
 d015f64:	10c00017 	ldw	r3,0(r2)
 d015f68:	e0bff417 	ldw	r2,-48(fp)
 d015f6c:	10c5883a 	add	r2,r2,r3
 d015f70:	e0bff415 	stw	r2,-48(fp)
      (offset < (flash->dev.region_info[i].offset + 
      flash->dev.region_info[i].region_size)))
    {
      current_offset = flash->dev.region_info[i].offset;

      for(j=0;j<flash->dev.region_info[i].number_of_blocks;j++)
 d015f74:	e0bff717 	ldw	r2,-36(fp)
 d015f78:	10800044 	addi	r2,r2,1
 d015f7c:	e0bff715 	stw	r2,-36(fp)
 d015f80:	e0bff817 	ldw	r2,-32(fp)
 d015f84:	e0fff217 	ldw	r3,-56(fp)
 d015f88:	1004913a 	slli	r2,r2,4
 d015f8c:	10c5883a 	add	r2,r2,r3
 d015f90:	10800f04 	addi	r2,r2,60
 d015f94:	10c00017 	ldw	r3,0(r2)
 d015f98:	e0bff717 	ldw	r2,-36(fp)
 d015f9c:	10ff9516 	blt	r2,r3,d015df4 <alt_flash_cfi_write+0xc4>
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;

  /*
   * First and foremost which sectors are affected?
   */   
  for(i=0;i<flash->dev.number_of_regions;i++)
 d015fa0:	e0bff817 	ldw	r2,-32(fp)
 d015fa4:	10800044 	addi	r2,r2,1
 d015fa8:	e0bff815 	stw	r2,-32(fp)
 d015fac:	e0bff217 	ldw	r2,-56(fp)
 d015fb0:	10c00c17 	ldw	r3,48(r2)
 d015fb4:	e0bff817 	ldw	r2,-32(fp)
 d015fb8:	10ff6e16 	blt	r2,r3,d015d74 <alt_flash_cfi_write+0x44>
      }     
    } 
  }
finished:    

  alt_dcache_flush((alt_u8*)flash->dev.base_addr+start_offset, full_length);
 d015fbc:	e0bff217 	ldw	r2,-56(fp)
 d015fc0:	10800a17 	ldw	r2,40(r2)
 d015fc4:	1007883a 	mov	r3,r2
 d015fc8:	e0bff317 	ldw	r2,-52(fp)
 d015fcc:	1889883a 	add	r4,r3,r2
 d015fd0:	e17ff517 	ldw	r5,-44(fp)
 d015fd4:	d038a8c0 	call	d038a8c <alt_dcache_flush>
  return ret_code;
 d015fd8:	e0bff917 	ldw	r2,-28(fp)
}
 d015fdc:	e037883a 	mov	sp,fp
 d015fe0:	dfc00117 	ldw	ra,4(sp)
 d015fe4:	df000017 	ldw	fp,0(sp)
 d015fe8:	dec00204 	addi	sp,sp,8
 d015fec:	f800283a 	ret

0d015ff0 <alt_flash_cfi_get_info>:
 * 
 *  Pass the table of erase blocks to the user
 */
int alt_flash_cfi_get_info( alt_flash_fd* fd, flash_region** info, 
                            int* number_of_regions)
{
 d015ff0:	defffa04 	addi	sp,sp,-24
 d015ff4:	df000515 	stw	fp,20(sp)
 d015ff8:	df000504 	addi	fp,sp,20
 d015ffc:	e13ffd15 	stw	r4,-12(fp)
 d016000:	e17ffe15 	stw	r5,-8(fp)
 d016004:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 d016008:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_dev* flash = (alt_flash_dev*)fd;
 d01600c:	e0bffd17 	ldw	r2,-12(fp)
 d016010:	e0bffb15 	stw	r2,-20(fp)

  *number_of_regions = flash->number_of_regions;
 d016014:	e0bffb17 	ldw	r2,-20(fp)
 d016018:	10c00c17 	ldw	r3,48(r2)
 d01601c:	e0bfff17 	ldw	r2,-4(fp)
 d016020:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 d016024:	e0bffb17 	ldw	r2,-20(fp)
 d016028:	10800c17 	ldw	r2,48(r2)
 d01602c:	1004c03a 	cmpne	r2,r2,zero
 d016030:	1000031e 	bne	r2,zero,d016040 <alt_flash_cfi_get_info+0x50>
  {
    ret_code = -EIO;
 d016034:	00bffec4 	movi	r2,-5
 d016038:	e0bffc15 	stw	r2,-16(fp)
 d01603c:	00000b06 	br	d01606c <alt_flash_cfi_get_info+0x7c>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 d016040:	e0bffb17 	ldw	r2,-20(fp)
 d016044:	10800c17 	ldw	r2,48(r2)
 d016048:	10800250 	cmplti	r2,r2,9
 d01604c:	1000031e 	bne	r2,zero,d01605c <alt_flash_cfi_get_info+0x6c>
  {
    ret_code = -ENOMEM;
 d016050:	00bffd04 	movi	r2,-12
 d016054:	e0bffc15 	stw	r2,-16(fp)
 d016058:	00000406 	br	d01606c <alt_flash_cfi_get_info+0x7c>
  }
  else
  {
    *info = &flash->region_info[0];
 d01605c:	e0bffb17 	ldw	r2,-20(fp)
 d016060:	10c00d04 	addi	r3,r2,52
 d016064:	e0bffe17 	ldw	r2,-8(fp)
 d016068:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 d01606c:	e0bffc17 	ldw	r2,-16(fp)
}
 d016070:	e037883a 	mov	sp,fp
 d016074:	df000017 	ldw	fp,0(sp)
 d016078:	dec00104 	addi	sp,sp,4
 d01607c:	f800283a 	ret

0d016080 <alt_flash_cfi_read>:
 *  Read from an area in flash, you could use memcopy yourself
 *  for these flash types, but we're trying to be generic and future proof
 */
int alt_flash_cfi_read( alt_flash_dev* flash_info, int offset, 
                        void* dest_addr, int length )
{
 d016080:	defff904 	addi	sp,sp,-28
 d016084:	dfc00615 	stw	ra,24(sp)
 d016088:	df000515 	stw	fp,20(sp)
 d01608c:	df000504 	addi	fp,sp,20
 d016090:	e13ffc15 	stw	r4,-16(fp)
 d016094:	e17ffd15 	stw	r5,-12(fp)
 d016098:	e1bffe15 	stw	r6,-8(fp)
 d01609c:	e1ffff15 	stw	r7,-4(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d0160a0:	e0bffc17 	ldw	r2,-16(fp)
 d0160a4:	e0bffb15 	stw	r2,-20(fp)
  memcpy(dest_addr, (alt_u8*)flash->dev.base_addr+offset, length);
 d0160a8:	e0bffb17 	ldw	r2,-20(fp)
 d0160ac:	10800a17 	ldw	r2,40(r2)
 d0160b0:	1007883a 	mov	r3,r2
 d0160b4:	e0bffd17 	ldw	r2,-12(fp)
 d0160b8:	1887883a 	add	r3,r3,r2
 d0160bc:	e1bfff17 	ldw	r6,-4(fp)
 d0160c0:	e0bffe17 	ldw	r2,-8(fp)
 d0160c4:	1009883a 	mov	r4,r2
 d0160c8:	180b883a 	mov	r5,r3
 d0160cc:	d0027000 	call	d002700 <memcpy>
  return 0;
 d0160d0:	0005883a 	mov	r2,zero
}
 d0160d4:	e037883a 	mov	sp,fp
 d0160d8:	dfc00117 	ldw	ra,4(sp)
 d0160dc:	df000017 	ldw	fp,0(sp)
 d0160e0:	dec00204 	addi	sp,sp,8
 d0160e4:	f800283a 	ret

0d0160e8 <alt_write_value_to_flash>:
* It writes the largest word size that the flash can support
* so if it's an 8 bit flash it writes bytes
* 16 bit half word etc.
*/
void alt_write_value_to_flash(alt_flash_cfi_dev* flash, int offset, const alt_u8* src_addr)
{
 d0160e8:	defffa04 	addi	sp,sp,-24
 d0160ec:	df000515 	stw	fp,20(sp)
 d0160f0:	df000504 	addi	fp,sp,20
 d0160f4:	e13ffd15 	stw	r4,-12(fp)
 d0160f8:	e17ffe15 	stw	r5,-8(fp)
 d0160fc:	e1bfff15 	stw	r6,-4(fp)
  alt_u16 half_word_value;
  alt_u32 word_value;

  if (flash->mode_width == 1)
 d016100:	e0bffd17 	ldw	r2,-12(fp)
 d016104:	10802e17 	ldw	r2,184(r2)
 d016108:	10800058 	cmpnei	r2,r2,1
 d01610c:	10000b1e 	bne	r2,zero,d01613c <alt_write_value_to_flash+0x54>
  {
    IOWR_8DIRECT(flash->dev.base_addr, offset, *src_addr);
 d016110:	e0bffd17 	ldw	r2,-12(fp)
 d016114:	10800a17 	ldw	r2,40(r2)
 d016118:	1007883a 	mov	r3,r2
 d01611c:	e0bffe17 	ldw	r2,-8(fp)
 d016120:	1889883a 	add	r4,r3,r2
 d016124:	e0bfff17 	ldw	r2,-4(fp)
 d016128:	10800003 	ldbu	r2,0(r2)
 d01612c:	10c03fcc 	andi	r3,r2,255
 d016130:	2005883a 	mov	r2,r4
 d016134:	10c00025 	stbio	r3,0(r2)
 d016138:	00004006 	br	d01623c <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 2)
 d01613c:	e0bffd17 	ldw	r2,-12(fp)
 d016140:	10802e17 	ldw	r2,184(r2)
 d016144:	10800098 	cmpnei	r2,r2,2
 d016148:	1000151e 	bne	r2,zero,d0161a0 <alt_write_value_to_flash+0xb8>
  {
    half_word_value = (alt_u16)(*src_addr);
 d01614c:	e0bfff17 	ldw	r2,-4(fp)
 d016150:	10800003 	ldbu	r2,0(r2)
 d016154:	10803fcc 	andi	r2,r2,255
 d016158:	e0bffc0d 	sth	r2,-16(fp)
    half_word_value |= (alt_u16)(*(src_addr + 1)) << 8;
 d01615c:	e0bfff17 	ldw	r2,-4(fp)
 d016160:	10800044 	addi	r2,r2,1
 d016164:	10800003 	ldbu	r2,0(r2)
 d016168:	10803fcc 	andi	r2,r2,255
 d01616c:	1004923a 	slli	r2,r2,8
 d016170:	1007883a 	mov	r3,r2
 d016174:	e0bffc0b 	ldhu	r2,-16(fp)
 d016178:	1884b03a 	or	r2,r3,r2
 d01617c:	e0bffc0d 	sth	r2,-16(fp)
    IOWR_16DIRECT(flash->dev.base_addr, offset, half_word_value);
 d016180:	e0bffd17 	ldw	r2,-12(fp)
 d016184:	10800a17 	ldw	r2,40(r2)
 d016188:	1007883a 	mov	r3,r2
 d01618c:	e0bffe17 	ldw	r2,-8(fp)
 d016190:	1885883a 	add	r2,r3,r2
 d016194:	e0fffc0b 	ldhu	r3,-16(fp)
 d016198:	10c0002d 	sthio	r3,0(r2)
 d01619c:	00002706 	br	d01623c <alt_write_value_to_flash+0x154>
  }
  else if (flash->mode_width == 4)
 d0161a0:	e0bffd17 	ldw	r2,-12(fp)
 d0161a4:	10802e17 	ldw	r2,184(r2)
 d0161a8:	10800118 	cmpnei	r2,r2,4
 d0161ac:	1000231e 	bne	r2,zero,d01623c <alt_write_value_to_flash+0x154>
  {
    word_value = (alt_u32)(*src_addr);
 d0161b0:	e0bfff17 	ldw	r2,-4(fp)
 d0161b4:	10800003 	ldbu	r2,0(r2)
 d0161b8:	10803fcc 	andi	r2,r2,255
 d0161bc:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 1)) << 8);
 d0161c0:	e0bfff17 	ldw	r2,-4(fp)
 d0161c4:	10800044 	addi	r2,r2,1
 d0161c8:	10800003 	ldbu	r2,0(r2)
 d0161cc:	10803fcc 	andi	r2,r2,255
 d0161d0:	1006923a 	slli	r3,r2,8
 d0161d4:	e0bffb17 	ldw	r2,-20(fp)
 d0161d8:	10c4b03a 	or	r2,r2,r3
 d0161dc:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 2)) << 16);
 d0161e0:	e0bfff17 	ldw	r2,-4(fp)
 d0161e4:	10800084 	addi	r2,r2,2
 d0161e8:	10800003 	ldbu	r2,0(r2)
 d0161ec:	10803fcc 	andi	r2,r2,255
 d0161f0:	1006943a 	slli	r3,r2,16
 d0161f4:	e0bffb17 	ldw	r2,-20(fp)
 d0161f8:	10c4b03a 	or	r2,r2,r3
 d0161fc:	e0bffb15 	stw	r2,-20(fp)
    word_value |= ((alt_u32)(*(src_addr + 3)) << 24);
 d016200:	e0bfff17 	ldw	r2,-4(fp)
 d016204:	108000c4 	addi	r2,r2,3
 d016208:	10800003 	ldbu	r2,0(r2)
 d01620c:	10803fcc 	andi	r2,r2,255
 d016210:	1006963a 	slli	r3,r2,24
 d016214:	e0bffb17 	ldw	r2,-20(fp)
 d016218:	10c4b03a 	or	r2,r2,r3
 d01621c:	e0bffb15 	stw	r2,-20(fp)
    IOWR_32DIRECT(flash->dev.base_addr, offset, word_value);
 d016220:	e0bffd17 	ldw	r2,-12(fp)
 d016224:	10800a17 	ldw	r2,40(r2)
 d016228:	1007883a 	mov	r3,r2
 d01622c:	e0bffe17 	ldw	r2,-8(fp)
 d016230:	1885883a 	add	r2,r3,r2
 d016234:	e0fffb17 	ldw	r3,-20(fp)
 d016238:	10c00035 	stwio	r3,0(r2)
  }

  return;
}
 d01623c:	e037883a 	mov	sp,fp
 d016240:	df000017 	ldw	fp,0(sp)
 d016244:	dec00104 	addi	sp,sp,4
 d016248:	f800283a 	ret

0d01624c <alt_flash_program_block>:
*/
int alt_flash_program_block(  alt_flash_cfi_dev* flash, const int offset, 
                        const alt_u8* src_addr, 
                        const int length,
                        alt_program_word_fn program_word_func)
{
 d01624c:	defff304 	addi	sp,sp,-52
 d016250:	dfc00c15 	stw	ra,48(sp)
 d016254:	df000b15 	stw	fp,44(sp)
 d016258:	df000b04 	addi	fp,sp,44
 d01625c:	e13ffc15 	stw	r4,-16(fp)
 d016260:	e17ffd15 	stw	r5,-12(fp)
 d016264:	e1bffe15 	stw	r6,-8(fp)
 d016268:	e1ffff15 	stw	r7,-4(fp)
  int     ret_code = 0;
 d01626c:	e03ffa15 	stw	zero,-24(fp)

  /*
   * First take care of any writes which are on none native boundaries
   * as far as the flash is concerned.
   */
  bytes_to_preserve = ((int)((alt_u8*)flash->dev.base_addr + offset) % 
 d016270:	e0bffc17 	ldw	r2,-16(fp)
 d016274:	10800a17 	ldw	r2,40(r2)
 d016278:	1007883a 	mov	r3,r2
 d01627c:	e0bffd17 	ldw	r2,-12(fp)
 d016280:	1885883a 	add	r2,r3,r2
 d016284:	1009883a 	mov	r4,r2
 d016288:	e0bffc17 	ldw	r2,-16(fp)
 d01628c:	10c02e17 	ldw	r3,184(r2)
 d016290:	20c5283a 	div	r2,r4,r3
 d016294:	10c5383a 	mul	r2,r2,r3
 d016298:	2085c83a 	sub	r2,r4,r2
 d01629c:	e0bff915 	stw	r2,-28(fp)
                      flash->mode_width);
  if ( bytes_to_preserve != 0)
 d0162a0:	e0bff917 	ldw	r2,-28(fp)
 d0162a4:	1005003a 	cmpeq	r2,r2,zero
 d0162a8:	10003a1e 	bne	r2,zero,d016394 <alt_flash_program_block+0x148>
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
 d0162ac:	e0bffc17 	ldw	r2,-16(fp)
 d0162b0:	10c02e17 	ldw	r3,184(r2)
 d0162b4:	e0bff917 	ldw	r2,-28(fp)
 d0162b8:	1885c83a 	sub	r2,r3,r2
 d0162bc:	e0bff815 	stw	r2,-32(fp)
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 d0162c0:	e03ff615 	stw	zero,-40(fp)
 d0162c4:	00001206 	br	d016310 <alt_flash_program_block+0xc4>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
 d0162c8:	e17ff617 	ldw	r5,-40(fp)
 d0162cc:	e0bffc17 	ldw	r2,-16(fp)
 d0162d0:	10800a17 	ldw	r2,40(r2)
 d0162d4:	1009883a 	mov	r4,r2
 d0162d8:	e0fffd17 	ldw	r3,-12(fp)
 d0162dc:	e0bff917 	ldw	r2,-28(fp)
 d0162e0:	1887c83a 	sub	r3,r3,r2
 d0162e4:	e0bff617 	ldw	r2,-40(fp)
 d0162e8:	1885883a 	add	r2,r3,r2
 d0162ec:	2085883a 	add	r2,r4,r2
 d0162f0:	10800023 	ldbuio	r2,0(r2)
 d0162f4:	1007883a 	mov	r3,r2
 d0162f8:	e0bffb04 	addi	r2,fp,-20
 d0162fc:	1145883a 	add	r2,r2,r5
 d016300:	10c00005 	stb	r3,0(r2)
  {
    unaligned_bytes = flash->mode_width - bytes_to_preserve;
    /*
     * Read the bytes we wish to preserve out of flash
     */
    for (i=0;i<bytes_to_preserve;i++)
 d016304:	e0bff617 	ldw	r2,-40(fp)
 d016308:	10800044 	addi	r2,r2,1
 d01630c:	e0bff615 	stw	r2,-40(fp)
 d016310:	e0fff617 	ldw	r3,-40(fp)
 d016314:	e0bff917 	ldw	r2,-28(fp)
 d016318:	18bfeb16 	blt	r3,r2,d0162c8 <alt_flash_program_block+0x7c>
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 d01631c:	e03ff615 	stw	zero,-40(fp)
 d016320:	00000e06 	br	d01635c <alt_flash_program_block+0x110>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
 d016324:	e0fff917 	ldw	r3,-28(fp)
 d016328:	e0bff617 	ldw	r2,-40(fp)
 d01632c:	1889883a 	add	r4,r3,r2
 d016330:	e0bff617 	ldw	r2,-40(fp)
 d016334:	1007883a 	mov	r3,r2
 d016338:	e0bffe17 	ldw	r2,-8(fp)
 d01633c:	1885883a 	add	r2,r3,r2
 d016340:	10c00003 	ldbu	r3,0(r2)
 d016344:	e0bffb04 	addi	r2,fp,-20
 d016348:	1105883a 	add	r2,r2,r4
 d01634c:	10c00005 	stb	r3,0(r2)
    {
      unaligned[i] = IORD_8DIRECT(flash->dev.base_addr, 
                                offset-bytes_to_preserve+i);
    }

    for (i=0;i<unaligned_bytes;i++)
 d016350:	e0bff617 	ldw	r2,-40(fp)
 d016354:	10800044 	addi	r2,r2,1
 d016358:	e0bff615 	stw	r2,-40(fp)
 d01635c:	e0fff617 	ldw	r3,-40(fp)
 d016360:	e0bff817 	ldw	r2,-32(fp)
 d016364:	18bfef16 	blt	r3,r2,d016324 <alt_flash_program_block+0xd8>
    {
      unaligned[bytes_to_preserve + i] = *(alt_u8*)(src_addr + i);
    }
    
    ret_code = (*program_word_func)(flash, offset-bytes_to_preserve, unaligned);
 d016368:	e0fffd17 	ldw	r3,-12(fp)
 d01636c:	e0bff917 	ldw	r2,-28(fp)
 d016370:	188bc83a 	sub	r5,r3,r2
 d016374:	e1bffb04 	addi	r6,fp,-20
 d016378:	e0800217 	ldw	r2,8(fp)
 d01637c:	e13ffc17 	ldw	r4,-16(fp)
 d016380:	103ee83a 	callr	r2
 d016384:	e0bffa15 	stw	r2,-24(fp)
    i = unaligned_bytes;
 d016388:	e0bff817 	ldw	r2,-32(fp)
 d01638c:	e0bff615 	stw	r2,-40(fp)
 d016390:	00000106 	br	d016398 <alt_flash_program_block+0x14c>
  }
  else
  {
    i = 0;
 d016394:	e03ff615 	stw	zero,-40(fp)
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
 d016398:	e0fffd17 	ldw	r3,-12(fp)
 d01639c:	e0bfff17 	ldw	r2,-4(fp)
 d0163a0:	1889883a 	add	r4,r3,r2
 d0163a4:	e0bffc17 	ldw	r2,-16(fp)
 d0163a8:	10c02e17 	ldw	r3,184(r2)
 d0163ac:	20c5283a 	div	r2,r4,r3
 d0163b0:	10c5383a 	mul	r2,r2,r3
 d0163b4:	2085c83a 	sub	r2,r4,r2
 d0163b8:	e0bff715 	stw	r2,-36(fp)
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 d0163bc:	00001006 	br	d016400 <alt_flash_program_block+0x1b4>
  {
    ret_code = (*program_word_func)(flash, offset+i, src_addr+i);
 d0163c0:	e0fffd17 	ldw	r3,-12(fp)
 d0163c4:	e0bff617 	ldw	r2,-40(fp)
 d0163c8:	188b883a 	add	r5,r3,r2
 d0163cc:	e0bff617 	ldw	r2,-40(fp)
 d0163d0:	1007883a 	mov	r3,r2
 d0163d4:	e0bffe17 	ldw	r2,-8(fp)
 d0163d8:	188d883a 	add	r6,r3,r2
 d0163dc:	e0800217 	ldw	r2,8(fp)
 d0163e0:	e13ffc17 	ldw	r4,-16(fp)
 d0163e4:	103ee83a 	callr	r2
 d0163e8:	e0bffa15 	stw	r2,-24(fp)
    i += flash->mode_width;     
 d0163ec:	e0bffc17 	ldw	r2,-16(fp)
 d0163f0:	10c02e17 	ldw	r3,184(r2)
 d0163f4:	e0bff617 	ldw	r2,-40(fp)
 d0163f8:	10c5883a 	add	r2,r2,r3
 d0163fc:	e0bff615 	stw	r2,-40(fp)
  {
    i = 0;
  }

  unaligned_end_bytes = (offset+length) % flash->mode_width;
  while ((ret_code == 0) && (i < (length-unaligned_end_bytes)))
 d016400:	e0bffa17 	ldw	r2,-24(fp)
 d016404:	1004c03a 	cmpne	r2,r2,zero
 d016408:	1000051e 	bne	r2,zero,d016420 <alt_flash_program_block+0x1d4>
 d01640c:	e0ffff17 	ldw	r3,-4(fp)
 d016410:	e0bff717 	ldw	r2,-36(fp)
 d016414:	1887c83a 	sub	r3,r3,r2
 d016418:	e0bff617 	ldw	r2,-40(fp)
 d01641c:	10ffe816 	blt	r2,r3,d0163c0 <alt_flash_program_block+0x174>

  /*
   * Now take care of any writes at the end of the buffer which are on none 
   * native boundaries as far as the flash is concerned.
   */
  if (unaligned_end_bytes && !ret_code)
 d016420:	e0bff717 	ldw	r2,-36(fp)
 d016424:	1005003a 	cmpeq	r2,r2,zero
 d016428:	10003c1e 	bne	r2,zero,d01651c <alt_flash_program_block+0x2d0>
 d01642c:	e0bffa17 	ldw	r2,-24(fp)
 d016430:	1004c03a 	cmpne	r2,r2,zero
 d016434:	1000391e 	bne	r2,zero,d01651c <alt_flash_program_block+0x2d0>
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
 d016438:	e0bffc17 	ldw	r2,-16(fp)
 d01643c:	10c02e17 	ldw	r3,184(r2)
 d016440:	e0bff717 	ldw	r2,-36(fp)
 d016444:	1885c83a 	sub	r2,r3,r2
 d016448:	e0bff915 	stw	r2,-28(fp)
    
    for (j=0;j<unaligned_end_bytes;j++)
 d01644c:	e03ff515 	stw	zero,-44(fp)
 d016450:	00000e06 	br	d01648c <alt_flash_program_block+0x240>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
 d016454:	e13ff517 	ldw	r4,-44(fp)
 d016458:	e0bff617 	ldw	r2,-40(fp)
 d01645c:	1007883a 	mov	r3,r2
 d016460:	e0bffe17 	ldw	r2,-8(fp)
 d016464:	1887883a 	add	r3,r3,r2
 d016468:	e0bff517 	ldw	r2,-44(fp)
 d01646c:	1885883a 	add	r2,r3,r2
 d016470:	10c00003 	ldbu	r3,0(r2)
 d016474:	e0bffb04 	addi	r2,fp,-20
 d016478:	1105883a 	add	r2,r2,r4
 d01647c:	10c00005 	stb	r3,0(r2)
   */
  if (unaligned_end_bytes && !ret_code)
  {
    bytes_to_preserve = flash->mode_width - unaligned_end_bytes;
    
    for (j=0;j<unaligned_end_bytes;j++)
 d016480:	e0bff517 	ldw	r2,-44(fp)
 d016484:	10800044 	addi	r2,r2,1
 d016488:	e0bff515 	stw	r2,-44(fp)
 d01648c:	e0fff517 	ldw	r3,-44(fp)
 d016490:	e0bff717 	ldw	r2,-36(fp)
 d016494:	18bfef16 	blt	r3,r2,d016454 <alt_flash_program_block+0x208>
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 d016498:	e03ff515 	stw	zero,-44(fp)
 d01649c:	00001406 	br	d0164f0 <alt_flash_program_block+0x2a4>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
 d0164a0:	e0fff717 	ldw	r3,-36(fp)
 d0164a4:	e0bff517 	ldw	r2,-44(fp)
 d0164a8:	188b883a 	add	r5,r3,r2
 d0164ac:	e0bffc17 	ldw	r2,-16(fp)
 d0164b0:	10800a17 	ldw	r2,40(r2)
 d0164b4:	1009883a 	mov	r4,r2
 d0164b8:	e0fffd17 	ldw	r3,-12(fp)
 d0164bc:	e0bfff17 	ldw	r2,-4(fp)
 d0164c0:	1887883a 	add	r3,r3,r2
 d0164c4:	e0bff517 	ldw	r2,-44(fp)
 d0164c8:	1885883a 	add	r2,r3,r2
 d0164cc:	2085883a 	add	r2,r4,r2
 d0164d0:	10800023 	ldbuio	r2,0(r2)
 d0164d4:	1007883a 	mov	r3,r2
 d0164d8:	e0bffb04 	addi	r2,fp,-20
 d0164dc:	1145883a 	add	r2,r2,r5
 d0164e0:	10c00005 	stb	r3,0(r2)
    for (j=0;j<unaligned_end_bytes;j++)
    {
      unaligned[j] = *(alt_u8*)(src_addr+i+j);
    }
    
    for (j=0;j<bytes_to_preserve;j++)
 d0164e4:	e0bff517 	ldw	r2,-44(fp)
 d0164e8:	10800044 	addi	r2,r2,1
 d0164ec:	e0bff515 	stw	r2,-44(fp)
 d0164f0:	e0fff517 	ldw	r3,-44(fp)
 d0164f4:	e0bff917 	ldw	r2,-28(fp)
 d0164f8:	18bfe916 	blt	r3,r2,d0164a0 <alt_flash_program_block+0x254>
    {
      unaligned[unaligned_end_bytes+j] = IORD_8DIRECT(flash->dev.base_addr, 
                                                      offset+length+j);
    }

    ret_code = (*program_word_func)(flash, offset+i, unaligned);      
 d0164fc:	e0fffd17 	ldw	r3,-12(fp)
 d016500:	e0bff617 	ldw	r2,-40(fp)
 d016504:	188b883a 	add	r5,r3,r2
 d016508:	e1bffb04 	addi	r6,fp,-20
 d01650c:	e0800217 	ldw	r2,8(fp)
 d016510:	e13ffc17 	ldw	r4,-16(fp)
 d016514:	103ee83a 	callr	r2
 d016518:	e0bffa15 	stw	r2,-24(fp)
  }

  return ret_code;
 d01651c:	e0bffa17 	ldw	r2,-24(fp)
}
 d016520:	e037883a 	mov	sp,fp
 d016524:	dfc00117 	ldw	ra,4(sp)
 d016528:	df000017 	ldw	fp,0(sp)
 d01652c:	dec00204 	addi	sp,sp,8
 d016530:	f800283a 	ret

0d016534 <alt_read_query_entry_8bit>:

/*
 *  Read an 8 bit value from the CFI query table in flash
 */
alt_u8 alt_read_query_entry_8bit( alt_flash_cfi_dev* flash, int address)
{
 d016534:	defffd04 	addi	sp,sp,-12
 d016538:	df000215 	stw	fp,8(sp)
 d01653c:	df000204 	addi	fp,sp,8
 d016540:	e13ffe15 	stw	r4,-8(fp)
 d016544:	e17fff15 	stw	r5,-4(fp)
  return IORD_8DIRECT((alt_u8*)flash->dev.base_addr, address);
 d016548:	e0bffe17 	ldw	r2,-8(fp)
 d01654c:	10800a17 	ldw	r2,40(r2)
 d016550:	1007883a 	mov	r3,r2
 d016554:	e0bfff17 	ldw	r2,-4(fp)
 d016558:	1885883a 	add	r2,r3,r2
 d01655c:	10800023 	ldbuio	r2,0(r2)
 d016560:	10803fcc 	andi	r2,r2,255
}
 d016564:	e037883a 	mov	sp,fp
 d016568:	df000017 	ldw	fp,0(sp)
 d01656c:	dec00104 	addi	sp,sp,4
 d016570:	f800283a 	ret

0d016574 <alt_read_query_entry_16bit>:

alt_u8 alt_read_query_entry_16bit( alt_flash_cfi_dev* flash, int address)
{
 d016574:	defffd04 	addi	sp,sp,-12
 d016578:	df000215 	stw	fp,8(sp)
 d01657c:	df000204 	addi	fp,sp,8
 d016580:	e13ffe15 	stw	r4,-8(fp)
 d016584:	e17fff15 	stw	r5,-4(fp)
  return (IORD_16DIRECT((alt_u8*)flash->dev.base_addr, address*2) & 0xff);
 d016588:	e0bffe17 	ldw	r2,-8(fp)
 d01658c:	10800a17 	ldw	r2,40(r2)
 d016590:	1007883a 	mov	r3,r2
 d016594:	e0bfff17 	ldw	r2,-4(fp)
 d016598:	1085883a 	add	r2,r2,r2
 d01659c:	1885883a 	add	r2,r3,r2
 d0165a0:	1080002b 	ldhuio	r2,0(r2)
 d0165a4:	10803fcc 	andi	r2,r2,255
}
 d0165a8:	e037883a 	mov	sp,fp
 d0165ac:	df000017 	ldw	fp,0(sp)
 d0165b0:	dec00104 	addi	sp,sp,4
 d0165b4:	f800283a 	ret

0d0165b8 <alt_read_query_entry_32bit>:

alt_u8 alt_read_query_entry_32bit( alt_flash_cfi_dev* flash, int address)
{
 d0165b8:	defffd04 	addi	sp,sp,-12
 d0165bc:	df000215 	stw	fp,8(sp)
 d0165c0:	df000204 	addi	fp,sp,8
 d0165c4:	e13ffe15 	stw	r4,-8(fp)
 d0165c8:	e17fff15 	stw	r5,-4(fp)
  return (IORD_32DIRECT((alt_u8*)flash->dev.base_addr, address*4) & 0xff);
 d0165cc:	e0bffe17 	ldw	r2,-8(fp)
 d0165d0:	10800a17 	ldw	r2,40(r2)
 d0165d4:	1007883a 	mov	r3,r2
 d0165d8:	e0bfff17 	ldw	r2,-4(fp)
 d0165dc:	1085883a 	add	r2,r2,r2
 d0165e0:	1085883a 	add	r2,r2,r2
 d0165e4:	1885883a 	add	r2,r3,r2
 d0165e8:	10800037 	ldwio	r2,0(r2)
 d0165ec:	10803fcc 	andi	r2,r2,255
}
 d0165f0:	e037883a 	mov	sp,fp
 d0165f4:	df000017 	ldw	fp,0(sp)
 d0165f8:	dec00104 	addi	sp,sp,4
 d0165fc:	f800283a 	ret

0d016600 <alt_write_flash_command_8bit_device_8bit_mode>:

/*
 * Write an 8 bit command to a flash
 */
void alt_write_flash_command_8bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d016600:	defffc04 	addi	sp,sp,-16
 d016604:	df000315 	stw	fp,12(sp)
 d016608:	df000304 	addi	fp,sp,12
 d01660c:	e13ffd15 	stw	r4,-12(fp)
 d016610:	e17ffe15 	stw	r5,-8(fp)
 d016614:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset, value);
 d016618:	e0fffd17 	ldw	r3,-12(fp)
 d01661c:	e0bffe17 	ldw	r2,-8(fp)
 d016620:	1885883a 	add	r2,r3,r2
 d016624:	e0ffff03 	ldbu	r3,-4(fp)
 d016628:	10c00025 	stbio	r3,0(r2)
  return;
}
 d01662c:	e037883a 	mov	sp,fp
 d016630:	df000017 	ldw	fp,0(sp)
 d016634:	dec00104 	addi	sp,sp,4
 d016638:	f800283a 	ret

0d01663c <alt_write_flash_command_16bit_device_8bit_mode>:

void alt_write_flash_command_16bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d01663c:	defffc04 	addi	sp,sp,-16
 d016640:	df000315 	stw	fp,12(sp)
 d016644:	df000304 	addi	fp,sp,12
 d016648:	e13ffd15 	stw	r4,-12(fp)
 d01664c:	e17ffe15 	stw	r5,-8(fp)
 d016650:	e1bfff05 	stb	r6,-4(fp)
  if (offset % 2)
 d016654:	e0bffe17 	ldw	r2,-8(fp)
 d016658:	1080004c 	andi	r2,r2,1
 d01665c:	10803fcc 	andi	r2,r2,255
 d016660:	1005003a 	cmpeq	r2,r2,zero
 d016664:	1000081e 	bne	r2,zero,d016688 <alt_write_flash_command_16bit_device_8bit_mode+0x4c>
  {
    IOWR_8DIRECT(base_addr, offset*2, value);
 d016668:	e0bffe17 	ldw	r2,-8(fp)
 d01666c:	1085883a 	add	r2,r2,r2
 d016670:	1007883a 	mov	r3,r2
 d016674:	e0bffd17 	ldw	r2,-12(fp)
 d016678:	1885883a 	add	r2,r3,r2
 d01667c:	e0ffff03 	ldbu	r3,-4(fp)
 d016680:	10c00025 	stbio	r3,0(r2)
 d016684:	00000806 	br	d0166a8 <alt_write_flash_command_16bit_device_8bit_mode+0x6c>
  }
  else
  {
    IOWR_8DIRECT(base_addr, (offset*2)+1, value);
 d016688:	e0bffe17 	ldw	r2,-8(fp)
 d01668c:	1085883a 	add	r2,r2,r2
 d016690:	1007883a 	mov	r3,r2
 d016694:	e0bffd17 	ldw	r2,-12(fp)
 d016698:	1885883a 	add	r2,r3,r2
 d01669c:	10800044 	addi	r2,r2,1
 d0166a0:	e0ffff03 	ldbu	r3,-4(fp)
 d0166a4:	10c00025 	stbio	r3,0(r2)
  }
  return;
}
 d0166a8:	e037883a 	mov	sp,fp
 d0166ac:	df000017 	ldw	fp,0(sp)
 d0166b0:	dec00104 	addi	sp,sp,4
 d0166b4:	f800283a 	ret

0d0166b8 <alt_write_flash_command_32bit_device_8bit_mode>:

void alt_write_flash_command_32bit_device_8bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d0166b8:	defffc04 	addi	sp,sp,-16
 d0166bc:	df000315 	stw	fp,12(sp)
 d0166c0:	df000304 	addi	fp,sp,12
 d0166c4:	e13ffd15 	stw	r4,-12(fp)
 d0166c8:	e17ffe15 	stw	r5,-8(fp)
 d0166cc:	e1bfff05 	stb	r6,-4(fp)
  IOWR_8DIRECT(base_addr, offset*4, value);
 d0166d0:	e0bffe17 	ldw	r2,-8(fp)
 d0166d4:	1085883a 	add	r2,r2,r2
 d0166d8:	1085883a 	add	r2,r2,r2
 d0166dc:	1007883a 	mov	r3,r2
 d0166e0:	e0bffd17 	ldw	r2,-12(fp)
 d0166e4:	1885883a 	add	r2,r3,r2
 d0166e8:	e0ffff03 	ldbu	r3,-4(fp)
 d0166ec:	10c00025 	stbio	r3,0(r2)
  return;
}
 d0166f0:	e037883a 	mov	sp,fp
 d0166f4:	df000017 	ldw	fp,0(sp)
 d0166f8:	dec00104 	addi	sp,sp,4
 d0166fc:	f800283a 	ret

0d016700 <alt_write_flash_command_16bit_device_16bit_mode>:

void alt_write_flash_command_16bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d016700:	defffc04 	addi	sp,sp,-16
 d016704:	df000315 	stw	fp,12(sp)
 d016708:	df000304 	addi	fp,sp,12
 d01670c:	e13ffd15 	stw	r4,-12(fp)
 d016710:	e17ffe15 	stw	r5,-8(fp)
 d016714:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*2, ((alt_u16)value)& 0x00ff);
 d016718:	e0bffe17 	ldw	r2,-8(fp)
 d01671c:	1085883a 	add	r2,r2,r2
 d016720:	1007883a 	mov	r3,r2
 d016724:	e0bffd17 	ldw	r2,-12(fp)
 d016728:	1885883a 	add	r2,r3,r2
 d01672c:	e0ffff03 	ldbu	r3,-4(fp)
 d016730:	10c0002d 	sthio	r3,0(r2)
  return;
}
 d016734:	e037883a 	mov	sp,fp
 d016738:	df000017 	ldw	fp,0(sp)
 d01673c:	dec00104 	addi	sp,sp,4
 d016740:	f800283a 	ret

0d016744 <alt_write_flash_command_32bit_device_16bit_mode>:

void alt_write_flash_command_32bit_device_16bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d016744:	defffc04 	addi	sp,sp,-16
 d016748:	df000315 	stw	fp,12(sp)
 d01674c:	df000304 	addi	fp,sp,12
 d016750:	e13ffd15 	stw	r4,-12(fp)
 d016754:	e17ffe15 	stw	r5,-8(fp)
 d016758:	e1bfff05 	stb	r6,-4(fp)
  IOWR_16DIRECT(base_addr, offset*4, ((alt_u16)value)& 0x00ff);
 d01675c:	e0bffe17 	ldw	r2,-8(fp)
 d016760:	1085883a 	add	r2,r2,r2
 d016764:	1085883a 	add	r2,r2,r2
 d016768:	1007883a 	mov	r3,r2
 d01676c:	e0bffd17 	ldw	r2,-12(fp)
 d016770:	1885883a 	add	r2,r3,r2
 d016774:	e0ffff03 	ldbu	r3,-4(fp)
 d016778:	10c0002d 	sthio	r3,0(r2)
  return;
}
 d01677c:	e037883a 	mov	sp,fp
 d016780:	df000017 	ldw	fp,0(sp)
 d016784:	dec00104 	addi	sp,sp,4
 d016788:	f800283a 	ret

0d01678c <alt_write_flash_command_32bit_device_32bit_mode>:

void alt_write_flash_command_32bit_device_32bit_mode( void* base_addr, int offset, alt_u8 value)
{
 d01678c:	defffc04 	addi	sp,sp,-16
 d016790:	df000315 	stw	fp,12(sp)
 d016794:	df000304 	addi	fp,sp,12
 d016798:	e13ffd15 	stw	r4,-12(fp)
 d01679c:	e17ffe15 	stw	r5,-8(fp)
 d0167a0:	e1bfff05 	stb	r6,-4(fp)
  IOWR_32DIRECT(base_addr, offset*4, ((alt_u32)value)& 0x000000ff);
 d0167a4:	e0bffe17 	ldw	r2,-8(fp)
 d0167a8:	1085883a 	add	r2,r2,r2
 d0167ac:	1085883a 	add	r2,r2,r2
 d0167b0:	1007883a 	mov	r3,r2
 d0167b4:	e0bffd17 	ldw	r2,-12(fp)
 d0167b8:	1885883a 	add	r2,r3,r2
 d0167bc:	e0ffff03 	ldbu	r3,-4(fp)
 d0167c0:	10c00035 	stwio	r3,0(r2)
  return;
}
 d0167c4:	e037883a 	mov	sp,fp
 d0167c8:	df000017 	ldw	fp,0(sp)
 d0167cc:	dec00104 	addi	sp,sp,4
 d0167d0:	f800283a 	ret

0d0167d4 <alt_write_native_8bit>:

/*
 * Write the value passed to the flash
 */
void alt_write_native_8bit( void* address, alt_u32 value)
{
 d0167d4:	defffd04 	addi	sp,sp,-12
 d0167d8:	df000215 	stw	fp,8(sp)
 d0167dc:	df000204 	addi	fp,sp,8
 d0167e0:	e13ffe15 	stw	r4,-8(fp)
 d0167e4:	e17fff15 	stw	r5,-4(fp)
  IOWR_8DIRECT(address, 0, (alt_u8)(value&0xff));
 d0167e8:	e0bfff17 	ldw	r2,-4(fp)
 d0167ec:	10c03fcc 	andi	r3,r2,255
 d0167f0:	e0bffe17 	ldw	r2,-8(fp)
 d0167f4:	10c00025 	stbio	r3,0(r2)
  return;
}
 d0167f8:	e037883a 	mov	sp,fp
 d0167fc:	df000017 	ldw	fp,0(sp)
 d016800:	dec00104 	addi	sp,sp,4
 d016804:	f800283a 	ret

0d016808 <alt_write_native_16bit>:

void alt_write_native_16bit( void* address, alt_u32 value)
{
 d016808:	defffd04 	addi	sp,sp,-12
 d01680c:	df000215 	stw	fp,8(sp)
 d016810:	df000204 	addi	fp,sp,8
 d016814:	e13ffe15 	stw	r4,-8(fp)
 d016818:	e17fff15 	stw	r5,-4(fp)
  IOWR_16DIRECT(address, 0, ((alt_u16)value)& 0xffff);
 d01681c:	e0bfff17 	ldw	r2,-4(fp)
 d016820:	10ffffcc 	andi	r3,r2,65535
 d016824:	e0bffe17 	ldw	r2,-8(fp)
 d016828:	10c0002d 	sthio	r3,0(r2)
  return;
}
 d01682c:	e037883a 	mov	sp,fp
 d016830:	df000017 	ldw	fp,0(sp)
 d016834:	dec00104 	addi	sp,sp,4
 d016838:	f800283a 	ret

0d01683c <alt_write_native_32bit>:

void alt_write_native_32bit( void* address, alt_u32 value)
{
 d01683c:	defffd04 	addi	sp,sp,-12
 d016840:	df000215 	stw	fp,8(sp)
 d016844:	df000204 	addi	fp,sp,8
 d016848:	e13ffe15 	stw	r4,-8(fp)
 d01684c:	e17fff15 	stw	r5,-4(fp)
  IOWR_32DIRECT(address, 0, value);
 d016850:	e0ffff17 	ldw	r3,-4(fp)
 d016854:	e0bffe17 	ldw	r2,-8(fp)
 d016858:	10c00035 	stwio	r3,0(r2)
  return;
}
 d01685c:	e037883a 	mov	sp,fp
 d016860:	df000017 	ldw	fp,0(sp)
 d016864:	dec00104 	addi	sp,sp,4
 d016868:	f800283a 	ret

0d01686c <alt_set_flash_width_func>:
 * 
 * Setup the function pointers for writing a byte to the flash for the width
 * of the device
 */
int alt_set_flash_width_func( alt_flash_cfi_dev* flash)
{ 
 d01686c:	defffb04 	addi	sp,sp,-20
 d016870:	df000415 	stw	fp,16(sp)
 d016874:	df000404 	addi	fp,sp,16
 d016878:	e13ffd15 	stw	r4,-12(fp)
  int ret_code = 0;
 d01687c:	e03ffc15 	stw	zero,-16(fp)
  
  switch(flash->mode_width)
 d016880:	e0bffd17 	ldw	r2,-12(fp)
 d016884:	10802e17 	ldw	r2,184(r2)
 d016888:	e0bfff15 	stw	r2,-4(fp)
 d01688c:	e0ffff17 	ldw	r3,-4(fp)
 d016890:	188000a0 	cmpeqi	r2,r3,2
 d016894:	1000261e 	bne	r2,zero,d016930 <alt_set_flash_width_func+0xc4>
 d016898:	e0ffff17 	ldw	r3,-4(fp)
 d01689c:	18800120 	cmpeqi	r2,r3,4
 d0168a0:	1000391e 	bne	r2,zero,d016988 <alt_set_flash_width_func+0x11c>
 d0168a4:	e0ffff17 	ldw	r3,-4(fp)
 d0168a8:	18800060 	cmpeqi	r2,r3,1
 d0168ac:	1000011e 	bne	r2,zero,d0168b4 <alt_set_flash_width_func+0x48>
 d0168b0:	00003e06 	br	d0169ac <alt_set_flash_width_func+0x140>
  {
    case 1:
    {
      flash->write_native = alt_write_native_8bit;
 d0168b4:	e0fffd17 	ldw	r3,-12(fp)
 d0168b8:	00834074 	movhi	r2,3329
 d0168bc:	1099f504 	addi	r2,r2,26580
 d0168c0:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 1)
 d0168c4:	e0bffd17 	ldw	r2,-12(fp)
 d0168c8:	10802f17 	ldw	r2,188(r2)
 d0168cc:	10800058 	cmpnei	r2,r2,1
 d0168d0:	1000051e 	bne	r2,zero,d0168e8 <alt_set_flash_width_func+0x7c>
      {
        flash->write_command = alt_write_flash_command_8bit_device_8bit_mode;
 d0168d4:	e0fffd17 	ldw	r3,-12(fp)
 d0168d8:	00834074 	movhi	r2,3329
 d0168dc:	10998004 	addi	r2,r2,26112
 d0168e0:	18803315 	stw	r2,204(r3)
 d0168e4:	00003306 	br	d0169b4 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 2)
 d0168e8:	e0bffd17 	ldw	r2,-12(fp)
 d0168ec:	10802f17 	ldw	r2,188(r2)
 d0168f0:	10800098 	cmpnei	r2,r2,2
 d0168f4:	1000051e 	bne	r2,zero,d01690c <alt_set_flash_width_func+0xa0>
      {
        flash->write_command = alt_write_flash_command_16bit_device_8bit_mode;
 d0168f8:	e0fffd17 	ldw	r3,-12(fp)
 d0168fc:	00834074 	movhi	r2,3329
 d016900:	10998f04 	addi	r2,r2,26172
 d016904:	18803315 	stw	r2,204(r3)
 d016908:	00002a06 	br	d0169b4 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 d01690c:	e0bffd17 	ldw	r2,-12(fp)
 d016910:	10802f17 	ldw	r2,188(r2)
 d016914:	10800118 	cmpnei	r2,r2,4
 d016918:	1000261e 	bne	r2,zero,d0169b4 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_8bit_mode;
 d01691c:	e0fffd17 	ldw	r3,-12(fp)
 d016920:	00834074 	movhi	r2,3329
 d016924:	1099ae04 	addi	r2,r2,26296
 d016928:	18803315 	stw	r2,204(r3)
      }
      break;
 d01692c:	00002106 	br	d0169b4 <alt_set_flash_width_func+0x148>
    }
    case 2:
    {
      flash->write_native = alt_write_native_16bit;
 d016930:	e0fffd17 	ldw	r3,-12(fp)
 d016934:	00834074 	movhi	r2,3329
 d016938:	109a0204 	addi	r2,r2,26632
 d01693c:	18803515 	stw	r2,212(r3)

      if (flash->device_width == 2)
 d016940:	e0bffd17 	ldw	r2,-12(fp)
 d016944:	10802f17 	ldw	r2,188(r2)
 d016948:	10800098 	cmpnei	r2,r2,2
 d01694c:	1000051e 	bne	r2,zero,d016964 <alt_set_flash_width_func+0xf8>
      {
        flash->write_command = alt_write_flash_command_16bit_device_16bit_mode;
 d016950:	e0fffd17 	ldw	r3,-12(fp)
 d016954:	00834074 	movhi	r2,3329
 d016958:	1099c004 	addi	r2,r2,26368
 d01695c:	18803315 	stw	r2,204(r3)
 d016960:	00001406 	br	d0169b4 <alt_set_flash_width_func+0x148>
      }
      else if (flash->device_width == 4)
 d016964:	e0bffd17 	ldw	r2,-12(fp)
 d016968:	10802f17 	ldw	r2,188(r2)
 d01696c:	10800118 	cmpnei	r2,r2,4
 d016970:	1000101e 	bne	r2,zero,d0169b4 <alt_set_flash_width_func+0x148>
      {
        flash->write_command = alt_write_flash_command_32bit_device_16bit_mode;
 d016974:	e0fffd17 	ldw	r3,-12(fp)
 d016978:	00834074 	movhi	r2,3329
 d01697c:	1099d104 	addi	r2,r2,26436
 d016980:	18803315 	stw	r2,204(r3)
      }

      break;
 d016984:	00000b06 	br	d0169b4 <alt_set_flash_width_func+0x148>
    }
    case 4:
    {
      flash->write_native = alt_write_native_32bit;
 d016988:	e0fffd17 	ldw	r3,-12(fp)
 d01698c:	00834074 	movhi	r2,3329
 d016990:	109a0f04 	addi	r2,r2,26684
 d016994:	18803515 	stw	r2,212(r3)
      flash->write_command = alt_write_flash_command_32bit_device_32bit_mode;
 d016998:	e0fffd17 	ldw	r3,-12(fp)
 d01699c:	00834074 	movhi	r2,3329
 d0169a0:	1099e304 	addi	r2,r2,26508
 d0169a4:	18803315 	stw	r2,204(r3)
      break;
 d0169a8:	00000206 	br	d0169b4 <alt_set_flash_width_func+0x148>
    }
    default:
    {
      ret_code = -EACCES;
 d0169ac:	00bffcc4 	movi	r2,-13
 d0169b0:	e0bffc15 	stw	r2,-16(fp)
    }
  }

  if (!ret_code)
 d0169b4:	e0bffc17 	ldw	r2,-16(fp)
 d0169b8:	1004c03a 	cmpne	r2,r2,zero
 d0169bc:	10001e1e 	bne	r2,zero,d016a38 <alt_set_flash_width_func+0x1cc>
  {
    switch(flash->device_width)
 d0169c0:	e0bffd17 	ldw	r2,-12(fp)
 d0169c4:	10802f17 	ldw	r2,188(r2)
 d0169c8:	e0bffe15 	stw	r2,-8(fp)
 d0169cc:	e0fffe17 	ldw	r3,-8(fp)
 d0169d0:	188000a0 	cmpeqi	r2,r3,2
 d0169d4:	10000c1e 	bne	r2,zero,d016a08 <alt_set_flash_width_func+0x19c>
 d0169d8:	e0fffe17 	ldw	r3,-8(fp)
 d0169dc:	18800120 	cmpeqi	r2,r3,4
 d0169e0:	10000e1e 	bne	r2,zero,d016a1c <alt_set_flash_width_func+0x1b0>
 d0169e4:	e0fffe17 	ldw	r3,-8(fp)
 d0169e8:	18800060 	cmpeqi	r2,r3,1
 d0169ec:	1000011e 	bne	r2,zero,d0169f4 <alt_set_flash_width_func+0x188>
 d0169f0:	00000f06 	br	d016a30 <alt_set_flash_width_func+0x1c4>
    {
      case 1:
      {
        flash->read_query = alt_read_query_entry_8bit;
 d0169f4:	e0fffd17 	ldw	r3,-12(fp)
 d0169f8:	00834074 	movhi	r2,3329
 d0169fc:	10994d04 	addi	r2,r2,25908
 d016a00:	18803415 	stw	r2,208(r3)
        break;
 d016a04:	00000c06 	br	d016a38 <alt_set_flash_width_func+0x1cc>
      }
      case 2:
      {
        flash->read_query = alt_read_query_entry_16bit;
 d016a08:	e0fffd17 	ldw	r3,-12(fp)
 d016a0c:	00834074 	movhi	r2,3329
 d016a10:	10995d04 	addi	r2,r2,25972
 d016a14:	18803415 	stw	r2,208(r3)
        break;
 d016a18:	00000706 	br	d016a38 <alt_set_flash_width_func+0x1cc>
      }
      case 4:
      {
        flash->read_query = alt_read_query_entry_32bit;
 d016a1c:	e0fffd17 	ldw	r3,-12(fp)
 d016a20:	00834074 	movhi	r2,3329
 d016a24:	10996e04 	addi	r2,r2,26040
 d016a28:	18803415 	stw	r2,208(r3)
        break;
 d016a2c:	00000206 	br	d016a38 <alt_set_flash_width_func+0x1cc>
      }
      default:
      {
        ret_code = -EACCES;
 d016a30:	00bffcc4 	movi	r2,-13
 d016a34:	e0bffc15 	stw	r2,-16(fp)
      }
    }
  }

  return ret_code;
 d016a38:	e0bffc17 	ldw	r2,-16(fp)
}
 d016a3c:	e037883a 	mov	sp,fp
 d016a40:	df000017 	ldw	fp,0(sp)
 d016a44:	dec00104 	addi	sp,sp,4
 d016a48:	f800283a 	ret

0d016a4c <alt_set_flash_algorithm_func>:
 * 
 * Setup the function pointers to the functions for this algorithm
 * 
 */
int alt_set_flash_algorithm_func( alt_flash_cfi_dev* flash)
{
 d016a4c:	defffc04 	addi	sp,sp,-16
 d016a50:	df000315 	stw	fp,12(sp)
 d016a54:	df000304 	addi	fp,sp,12
 d016a58:	e13ffe15 	stw	r4,-8(fp)
  int ret_code = 0;
 d016a5c:	e03ffd15 	stw	zero,-12(fp)
 
  switch(flash->algorithm)
 d016a60:	e0bffe17 	ldw	r2,-8(fp)
 d016a64:	10802d17 	ldw	r2,180(r2)
 d016a68:	e0bfff15 	stw	r2,-4(fp)
 d016a6c:	e0ffff17 	ldw	r3,-4(fp)
 d016a70:	188000a0 	cmpeqi	r2,r3,2
 d016a74:	1000071e 	bne	r2,zero,d016a94 <alt_set_flash_algorithm_func+0x48>
 d016a78:	e0ffff17 	ldw	r3,-4(fp)
 d016a7c:	188000e0 	cmpeqi	r2,r3,3
 d016a80:	10000d1e 	bne	r2,zero,d016ab8 <alt_set_flash_algorithm_func+0x6c>
 d016a84:	e0ffff17 	ldw	r3,-4(fp)
 d016a88:	18800060 	cmpeqi	r2,r3,1
 d016a8c:	10000a1e 	bne	r2,zero,d016ab8 <alt_set_flash_algorithm_func+0x6c>
 d016a90:	00001206 	br	d016adc <alt_set_flash_algorithm_func+0x90>
  {
    case CFI_ALG_AMD:
    {
      flash->dev.erase_block = alt_erase_block_amd;
 d016a94:	e0fffe17 	ldw	r3,-8(fp)
 d016a98:	00834134 	movhi	r2,3332
 d016a9c:	10a83904 	addi	r2,r2,-24348
 d016aa0:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_amd;
 d016aa4:	e0fffe17 	ldw	r3,-8(fp)
 d016aa8:	00834134 	movhi	r2,3332
 d016aac:	10a81f04 	addi	r2,r2,-24452
 d016ab0:	18800915 	stw	r2,36(r3)
      break;
 d016ab4:	00000b06 	br	d016ae4 <alt_set_flash_algorithm_func+0x98>
    }
    case CFI_ALG_INTEL:
    case CFI_ALG_INTEL_STRATA:
    {
      flash->dev.erase_block = alt_erase_block_intel;
 d016ab8:	e0fffe17 	ldw	r3,-8(fp)
 d016abc:	00834134 	movhi	r2,3332
 d016ac0:	10a95804 	addi	r2,r2,-23200
 d016ac4:	18800815 	stw	r2,32(r3)
      flash->dev.write_block = alt_program_intel;
 d016ac8:	e0fffe17 	ldw	r3,-8(fp)
 d016acc:	00834134 	movhi	r2,3332
 d016ad0:	10a93704 	addi	r2,r2,-23332
 d016ad4:	18800915 	stw	r2,36(r3)
      break;
 d016ad8:	00000206 	br	d016ae4 <alt_set_flash_algorithm_func+0x98>
    }
    default:
    {
      ret_code = -EIO;
 d016adc:	00bffec4 	movi	r2,-5
 d016ae0:	e0bffd15 	stw	r2,-12(fp)
    }
  } 
  return ret_code;  
 d016ae4:	e0bffd17 	ldw	r2,-12(fp)
}
 d016ae8:	e037883a 	mov	sp,fp
 d016aec:	df000017 	ldw	fp,0(sp)
 d016af0:	dec00104 	addi	sp,sp,4
 d016af4:	f800283a 	ret

0d016af8 <alt_read_16bit_query_entry>:
 * read_16bit_query_entry
 * 
 * Read a 16 bit entry from the CFI Query table
 */
static alt_u16 alt_read_16bit_query_entry(alt_flash_cfi_dev* flash, int address)
{
 d016af8:	defffb04 	addi	sp,sp,-20
 d016afc:	dfc00415 	stw	ra,16(sp)
 d016b00:	df000315 	stw	fp,12(sp)
 d016b04:	df000304 	addi	fp,sp,12
 d016b08:	e13ffe15 	stw	r4,-8(fp)
 d016b0c:	e17fff15 	stw	r5,-4(fp)
  alt_u16 ret_code;

  ret_code = (*flash->read_query)( flash, address);
 d016b10:	e0bffe17 	ldw	r2,-8(fp)
 d016b14:	10803417 	ldw	r2,208(r2)
 d016b18:	e13ffe17 	ldw	r4,-8(fp)
 d016b1c:	e17fff17 	ldw	r5,-4(fp)
 d016b20:	103ee83a 	callr	r2
 d016b24:	10803fcc 	andi	r2,r2,255
 d016b28:	e0bffd0d 	sth	r2,-12(fp)
  ret_code |= (((int)(*flash->read_query)(flash, address+1)) << 8);                   
 d016b2c:	e0bffe17 	ldw	r2,-8(fp)
 d016b30:	10c03417 	ldw	r3,208(r2)
 d016b34:	e0bfff17 	ldw	r2,-4(fp)
 d016b38:	11400044 	addi	r5,r2,1
 d016b3c:	e13ffe17 	ldw	r4,-8(fp)
 d016b40:	183ee83a 	callr	r3
 d016b44:	10803fcc 	andi	r2,r2,255
 d016b48:	1004923a 	slli	r2,r2,8
 d016b4c:	1007883a 	mov	r3,r2
 d016b50:	e0bffd0b 	ldhu	r2,-12(fp)
 d016b54:	1884b03a 	or	r2,r3,r2
 d016b58:	e0bffd0d 	sth	r2,-12(fp)

  return ret_code;
 d016b5c:	e0bffd0b 	ldhu	r2,-12(fp)
}
 d016b60:	e037883a 	mov	sp,fp
 d016b64:	dfc00117 	ldw	ra,4(sp)
 d016b68:	df000017 	ldw	fp,0(sp)
 d016b6c:	dec00204 	addi	sp,sp,8
 d016b70:	f800283a 	ret

0d016b74 <alt_read_cfi_table>:
 * read_cfi_table
 * 
 * Read the CFI Table
 */
int alt_read_cfi_table(alt_flash_cfi_dev* flash)
{
 d016b74:	defff204 	addi	sp,sp,-56
 d016b78:	dfc00d15 	stw	ra,52(sp)
 d016b7c:	df000c15 	stw	fp,48(sp)
 d016b80:	dc000b15 	stw	r16,44(sp)
 d016b84:	df000b04 	addi	fp,sp,44
 d016b88:	e13fff15 	stw	r4,-4(fp)
  int   i,j;
  int   device_size;
  int   ret_code = 0;
 d016b8c:	e03ffb15 	stw	zero,-20(fp)
  int   size = 0;
 d016b90:	e03ffa15 	stw	zero,-24(fp)
  int   swap;
  int   typical_timeout;
  int   max_timeout;
  int   offset = 0;
 d016b94:	e03ff615 	stw	zero,-40(fp)
   
  /*
  * Check that the Primary Vendor Specific table
  * starts with the letters PRI                                                         
  */
  ret_code = alt_check_primary_table(flash);
 d016b98:	e13fff17 	ldw	r4,-4(fp)
 d016b9c:	d0178a00 	call	d0178a0 <alt_check_primary_table>
 d016ba0:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 d016ba4:	e0bffb17 	ldw	r2,-20(fp)
 d016ba8:	1004c03a 	cmpne	r2,r2,zero
 d016bac:	10014a1e 	bne	r2,zero,d0170d8 <alt_read_cfi_table+0x564>
  {
    flash->algorithm = (*flash->read_query)(flash, 0x13);
 d016bb0:	e0bfff17 	ldw	r2,-4(fp)
 d016bb4:	10803417 	ldw	r2,208(r2)
 d016bb8:	e13fff17 	ldw	r4,-4(fp)
 d016bbc:	014004c4 	movi	r5,19
 d016bc0:	103ee83a 	callr	r2
 d016bc4:	10c03fcc 	andi	r3,r2,255
 d016bc8:	e0bfff17 	ldw	r2,-4(fp)
 d016bcc:	10c02d15 	stw	r3,180(r2)
  
    /* 
     * Let's read the write timeout values from the flash 
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
 d016bd0:	e0bfff17 	ldw	r2,-4(fp)
 d016bd4:	10803417 	ldw	r2,208(r2)
 d016bd8:	e13fff17 	ldw	r4,-4(fp)
 d016bdc:	014007c4 	movi	r5,31
 d016be0:	103ee83a 	callr	r2
 d016be4:	10803fcc 	andi	r2,r2,255
 d016be8:	e0bff815 	stw	r2,-32(fp)
    max_timeout = (*flash->read_query)( flash, 0x23);
 d016bec:	e0bfff17 	ldw	r2,-4(fp)
 d016bf0:	10803417 	ldw	r2,208(r2)
 d016bf4:	e13fff17 	ldw	r4,-4(fp)
 d016bf8:	014008c4 	movi	r5,35
 d016bfc:	103ee83a 	callr	r2
 d016c00:	10803fcc 	andi	r2,r2,255
 d016c04:	e0bff715 	stw	r2,-36(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 d016c08:	e0bff817 	ldw	r2,-32(fp)
 d016c0c:	1005003a 	cmpeq	r2,r2,zero
 d016c10:	1000031e 	bne	r2,zero,d016c20 <alt_read_cfi_table+0xac>
 d016c14:	e0bff717 	ldw	r2,-36(fp)
 d016c18:	1004c03a 	cmpne	r2,r2,zero
 d016c1c:	1000041e 	bne	r2,zero,d016c30 <alt_read_cfi_table+0xbc>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
 d016c20:	e0ffff17 	ldw	r3,-4(fp)
 d016c24:	0080fa04 	movi	r2,1000
 d016c28:	18803015 	stw	r2,192(r3)
     * 
     */
    typical_timeout = (*flash->read_query)( flash, 0x1f);
    max_timeout = (*flash->read_query)( flash, 0x23);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 d016c2c:	00000706 	br	d016c4c <alt_read_cfi_table+0xd8>
    {
      flash->write_timeout = 1000; /* 1ms should be more than enough */
    }
    else
    {
      flash->write_timeout = (1 << typical_timeout) * (1 << max_timeout);
 d016c30:	00c00044 	movi	r3,1
 d016c34:	e0bff817 	ldw	r2,-32(fp)
 d016c38:	1886983a 	sll	r3,r3,r2
 d016c3c:	e0bff717 	ldw	r2,-36(fp)
 d016c40:	1886983a 	sll	r3,r3,r2
 d016c44:	e0bfff17 	ldw	r2,-4(fp)
 d016c48:	10c03015 	stw	r3,192(r2)
    }
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
 d016c4c:	e0bfff17 	ldw	r2,-4(fp)
 d016c50:	10803417 	ldw	r2,208(r2)
 d016c54:	e13fff17 	ldw	r4,-4(fp)
 d016c58:	01400844 	movi	r5,33
 d016c5c:	103ee83a 	callr	r2
 d016c60:	10803fcc 	andi	r2,r2,255
 d016c64:	e0bff815 	stw	r2,-32(fp)
    max_timeout = (*flash->read_query)( flash, 0x25);
 d016c68:	e0bfff17 	ldw	r2,-4(fp)
 d016c6c:	10803417 	ldw	r2,208(r2)
 d016c70:	e13fff17 	ldw	r4,-4(fp)
 d016c74:	01400944 	movi	r5,37
 d016c78:	103ee83a 	callr	r2
 d016c7c:	10803fcc 	andi	r2,r2,255
 d016c80:	e0bff715 	stw	r2,-36(fp)
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 d016c84:	e0bff817 	ldw	r2,-32(fp)
 d016c88:	1005003a 	cmpeq	r2,r2,zero
 d016c8c:	1000031e 	bne	r2,zero,d016c9c <alt_read_cfi_table+0x128>
 d016c90:	e0bff717 	ldw	r2,-36(fp)
 d016c94:	1004c03a 	cmpne	r2,r2,zero
 d016c98:	1000051e 	bne	r2,zero,d016cb0 <alt_read_cfi_table+0x13c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
 d016c9c:	e0ffff17 	ldw	r3,-4(fp)
 d016ca0:	00804c74 	movhi	r2,305
 d016ca4:	108b4004 	addi	r2,r2,11520
 d016ca8:	18803115 	stw	r2,196(r3)
   
    /* Let's read the block erase timeout values from the flash */
    typical_timeout = (*flash->read_query)( flash, 0x21);
    max_timeout = (*flash->read_query)( flash, 0x25);
    
    if ((typical_timeout == 0 ) || (max_timeout == 0))
 d016cac:	00000806 	br	d016cd0 <alt_read_cfi_table+0x15c>
    {
      flash->erase_timeout = 20000000; /* 20s should be more than enough */
    }
    else
    {
      flash->erase_timeout = (1 << typical_timeout) * (1 << max_timeout) * 1000;
 d016cb0:	00c00044 	movi	r3,1
 d016cb4:	e0bff817 	ldw	r2,-32(fp)
 d016cb8:	1886983a 	sll	r3,r3,r2
 d016cbc:	e0bff717 	ldw	r2,-36(fp)
 d016cc0:	1884983a 	sll	r2,r3,r2
 d016cc4:	10c0fa24 	muli	r3,r2,1000
 d016cc8:	e0bfff17 	ldw	r2,-4(fp)
 d016ccc:	10c03115 	stw	r3,196(r2)
    }
   
    device_size = 0x1 << (*flash->read_query)( flash, 0x27);
 d016cd0:	e0bfff17 	ldw	r2,-4(fp)
 d016cd4:	10803417 	ldw	r2,208(r2)
 d016cd8:	e13fff17 	ldw	r4,-4(fp)
 d016cdc:	014009c4 	movi	r5,39
 d016ce0:	103ee83a 	callr	r2
 d016ce4:	10c03fcc 	andi	r3,r2,255
 d016ce8:	00800044 	movi	r2,1
 d016cec:	10c4983a 	sll	r2,r2,r3
 d016cf0:	e0bffc15 	stw	r2,-16(fp)
  
    flash->dev.number_of_regions = (*flash->read_query)(flash, 0x2c);
 d016cf4:	e0bfff17 	ldw	r2,-4(fp)
 d016cf8:	10803417 	ldw	r2,208(r2)
 d016cfc:	e13fff17 	ldw	r4,-4(fp)
 d016d00:	01400b04 	movi	r5,44
 d016d04:	103ee83a 	callr	r2
 d016d08:	10c03fcc 	andi	r3,r2,255
 d016d0c:	e0bfff17 	ldw	r2,-4(fp)
 d016d10:	10c00c15 	stw	r3,48(r2)
    
    if (flash->dev.number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 d016d14:	e0bfff17 	ldw	r2,-4(fp)
 d016d18:	10800c17 	ldw	r2,48(r2)
 d016d1c:	10800250 	cmplti	r2,r2,9
 d016d20:	1000031e 	bne	r2,zero,d016d30 <alt_read_cfi_table+0x1bc>
    {
      ret_code = -ENOMEM;
 d016d24:	00bffd04 	movi	r2,-12
 d016d28:	e0bffb15 	stw	r2,-20(fp)
 d016d2c:	00005e06 	br	d016ea8 <alt_read_cfi_table+0x334>
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 d016d30:	e03ffe15 	stw	zero,-8(fp)
 d016d34:	00005306 	br	d016e84 <alt_read_cfi_table+0x310>
      {
        flash->dev.region_info[i].number_of_blocks =  alt_read_16bit_query_entry( 
 d016d38:	e43ffe17 	ldw	r16,-8(fp)
 d016d3c:	e0bffe17 	ldw	r2,-8(fp)
 d016d40:	1085883a 	add	r2,r2,r2
 d016d44:	1085883a 	add	r2,r2,r2
 d016d48:	11400b44 	addi	r5,r2,45
 d016d4c:	e13fff17 	ldw	r4,-4(fp)
 d016d50:	d016af80 	call	d016af8 <alt_read_16bit_query_entry>
 d016d54:	113fffcc 	andi	r4,r2,65535
 d016d58:	e0ffff17 	ldw	r3,-4(fp)
 d016d5c:	8004913a 	slli	r2,r16,4
 d016d60:	10c5883a 	add	r2,r2,r3
 d016d64:	10800f04 	addi	r2,r2,60
 d016d68:	11000015 	stw	r4,0(r2)
                                                            flash,
                                                            (0x2D+i*4));
        flash->dev.region_info[i].number_of_blocks += 1; 
 d016d6c:	e17ffe17 	ldw	r5,-8(fp)
 d016d70:	e0bffe17 	ldw	r2,-8(fp)
 d016d74:	e0ffff17 	ldw	r3,-4(fp)
 d016d78:	1004913a 	slli	r2,r2,4
 d016d7c:	10c5883a 	add	r2,r2,r3
 d016d80:	10800f04 	addi	r2,r2,60
 d016d84:	10800017 	ldw	r2,0(r2)
 d016d88:	11000044 	addi	r4,r2,1
 d016d8c:	e0ffff17 	ldw	r3,-4(fp)
 d016d90:	2804913a 	slli	r2,r5,4
 d016d94:	10c5883a 	add	r2,r2,r3
 d016d98:	10800f04 	addi	r2,r2,60
 d016d9c:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].block_size =  alt_read_16bit_query_entry( flash, 
 d016da0:	e43ffe17 	ldw	r16,-8(fp)
 d016da4:	e0bffe17 	ldw	r2,-8(fp)
 d016da8:	1085883a 	add	r2,r2,r2
 d016dac:	1085883a 	add	r2,r2,r2
 d016db0:	11400bc4 	addi	r5,r2,47
 d016db4:	e13fff17 	ldw	r4,-4(fp)
 d016db8:	d016af80 	call	d016af8 <alt_read_16bit_query_entry>
 d016dbc:	113fffcc 	andi	r4,r2,65535
 d016dc0:	e0ffff17 	ldw	r3,-4(fp)
 d016dc4:	8004913a 	slli	r2,r16,4
 d016dc8:	10c5883a 	add	r2,r2,r3
 d016dcc:	10801004 	addi	r2,r2,64
 d016dd0:	11000015 	stw	r4,0(r2)
                                                              (0x2F+i*4));
        flash->dev.region_info[i].block_size *= 256;
 d016dd4:	e17ffe17 	ldw	r5,-8(fp)
 d016dd8:	e0bffe17 	ldw	r2,-8(fp)
 d016ddc:	e0ffff17 	ldw	r3,-4(fp)
 d016de0:	1004913a 	slli	r2,r2,4
 d016de4:	10c5883a 	add	r2,r2,r3
 d016de8:	10801004 	addi	r2,r2,64
 d016dec:	10800017 	ldw	r2,0(r2)
 d016df0:	1008923a 	slli	r4,r2,8
 d016df4:	e0ffff17 	ldw	r3,-4(fp)
 d016df8:	2804913a 	slli	r2,r5,4
 d016dfc:	10c5883a 	add	r2,r2,r3
 d016e00:	10801004 	addi	r2,r2,64
 d016e04:	11000015 	stw	r4,0(r2)
        flash->dev.region_info[i].region_size = 
 d016e08:	e17ffe17 	ldw	r5,-8(fp)
 d016e0c:	e0bffe17 	ldw	r2,-8(fp)
 d016e10:	e0ffff17 	ldw	r3,-4(fp)
 d016e14:	1004913a 	slli	r2,r2,4
 d016e18:	10c5883a 	add	r2,r2,r3
 d016e1c:	10800f04 	addi	r2,r2,60
 d016e20:	11000017 	ldw	r4,0(r2)
 d016e24:	e0bffe17 	ldw	r2,-8(fp)
 d016e28:	e0ffff17 	ldw	r3,-4(fp)
 d016e2c:	1004913a 	slli	r2,r2,4
 d016e30:	10c5883a 	add	r2,r2,r3
 d016e34:	10801004 	addi	r2,r2,64
 d016e38:	10800017 	ldw	r2,0(r2)
 d016e3c:	2089383a 	mul	r4,r4,r2
 d016e40:	e0ffff17 	ldw	r3,-4(fp)
 d016e44:	2804913a 	slli	r2,r5,4
 d016e48:	10c5883a 	add	r2,r2,r3
 d016e4c:	10800e04 	addi	r2,r2,56
 d016e50:	11000015 	stw	r4,0(r2)
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
 d016e54:	e0bffe17 	ldw	r2,-8(fp)
 d016e58:	e0ffff17 	ldw	r3,-4(fp)
 d016e5c:	1004913a 	slli	r2,r2,4
 d016e60:	10c5883a 	add	r2,r2,r3
 d016e64:	10800e04 	addi	r2,r2,56
 d016e68:	10c00017 	ldw	r3,0(r2)
 d016e6c:	e0bffa17 	ldw	r2,-24(fp)
 d016e70:	10c5883a 	add	r2,r2,r3
 d016e74:	e0bffa15 	stw	r2,-24(fp)
    {
      ret_code = -ENOMEM;
    }
    else
    {
      for(i=0;i<flash->dev.number_of_regions;i++)
 d016e78:	e0bffe17 	ldw	r2,-8(fp)
 d016e7c:	10800044 	addi	r2,r2,1
 d016e80:	e0bffe15 	stw	r2,-8(fp)
 d016e84:	e0bfff17 	ldw	r2,-4(fp)
 d016e88:	10c00c17 	ldw	r3,48(r2)
 d016e8c:	e0bffe17 	ldw	r2,-8(fp)
 d016e90:	10ffa916 	blt	r2,r3,d016d38 <alt_read_cfi_table+0x1c4>
                                    flash->dev.region_info[i].number_of_blocks 
                                    * flash->dev.region_info[i].block_size;
        size += flash->dev.region_info[i].region_size;
      }
       
      if (size != device_size)
 d016e94:	e0fffa17 	ldw	r3,-24(fp)
 d016e98:	e0bffc17 	ldw	r2,-16(fp)
 d016e9c:	18800226 	beq	r3,r2,d016ea8 <alt_read_cfi_table+0x334>
      {
        ret_code = -ENODEV;
 d016ea0:	00bffb44 	movi	r2,-19
 d016ea4:	e0bffb15 	stw	r2,-20(fp)
      }
    }
    
    boot_mode = (*flash->read_query)( flash, flash->primary_address + 0xf);
 d016ea8:	e0bfff17 	ldw	r2,-4(fp)
 d016eac:	10c03417 	ldw	r3,208(r2)
 d016eb0:	e0bfff17 	ldw	r2,-4(fp)
 d016eb4:	10803217 	ldw	r2,200(r2)
 d016eb8:	114003c4 	addi	r5,r2,15
 d016ebc:	e13fff17 	ldw	r4,-4(fp)
 d016ec0:	183ee83a 	callr	r3
 d016ec4:	e0bff505 	stb	r2,-44(fp)
     * Intel Flash parts describe the sections in the order they appear
     * for AMD they just put all the small ones first then the bigger ones
     * So if it's a top boot part we have to reverse the order of the sectors
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
 d016ec8:	e0bfff17 	ldw	r2,-4(fp)
 d016ecc:	10802d17 	ldw	r2,180(r2)
 d016ed0:	10800098 	cmpnei	r2,r2,2
 d016ed4:	1000601e 	bne	r2,zero,d017058 <alt_read_cfi_table+0x4e4>
 d016ed8:	e0bff503 	ldbu	r2,-44(fp)
 d016edc:	108000d8 	cmpnei	r2,r2,3
 d016ee0:	10005d1e 	bne	r2,zero,d017058 <alt_read_cfi_table+0x4e4>
    {
      for(i=flash->dev.number_of_regions-1, j=0;
 d016ee4:	e0bfff17 	ldw	r2,-4(fp)
 d016ee8:	10800c17 	ldw	r2,48(r2)
 d016eec:	10bfffc4 	addi	r2,r2,-1
 d016ef0:	e0bffe15 	stw	r2,-8(fp)
 d016ef4:	e03ffd15 	stw	zero,-12(fp)
          j<=i;i--,j++)
 d016ef8:	00005406 	br	d01704c <alt_read_cfi_table+0x4d8>
      {
        swap = flash->dev.region_info[i].region_size;
 d016efc:	e0bffe17 	ldw	r2,-8(fp)
 d016f00:	e0ffff17 	ldw	r3,-4(fp)
 d016f04:	1004913a 	slli	r2,r2,4
 d016f08:	10c5883a 	add	r2,r2,r3
 d016f0c:	10800e04 	addi	r2,r2,56
 d016f10:	10800017 	ldw	r2,0(r2)
 d016f14:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].region_size =  
 d016f18:	e17ffe17 	ldw	r5,-8(fp)
 d016f1c:	e0bffd17 	ldw	r2,-12(fp)
 d016f20:	e0ffff17 	ldw	r3,-4(fp)
 d016f24:	1004913a 	slli	r2,r2,4
 d016f28:	10c5883a 	add	r2,r2,r3
 d016f2c:	10800e04 	addi	r2,r2,56
 d016f30:	11000017 	ldw	r4,0(r2)
 d016f34:	e0ffff17 	ldw	r3,-4(fp)
 d016f38:	2804913a 	slli	r2,r5,4
 d016f3c:	10c5883a 	add	r2,r2,r3
 d016f40:	10800e04 	addi	r2,r2,56
 d016f44:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].region_size;
        flash->dev.region_info[j].region_size = swap;
 d016f48:	e0bffd17 	ldw	r2,-12(fp)
 d016f4c:	e0ffff17 	ldw	r3,-4(fp)
 d016f50:	1004913a 	slli	r2,r2,4
 d016f54:	10c5883a 	add	r2,r2,r3
 d016f58:	10c00e04 	addi	r3,r2,56
 d016f5c:	e0bff917 	ldw	r2,-28(fp)
 d016f60:	18800015 	stw	r2,0(r3)

        swap = flash->dev.region_info[i].block_size;
 d016f64:	e0bffe17 	ldw	r2,-8(fp)
 d016f68:	e0ffff17 	ldw	r3,-4(fp)
 d016f6c:	1004913a 	slli	r2,r2,4
 d016f70:	10c5883a 	add	r2,r2,r3
 d016f74:	10801004 	addi	r2,r2,64
 d016f78:	10800017 	ldw	r2,0(r2)
 d016f7c:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].block_size =  
 d016f80:	e17ffe17 	ldw	r5,-8(fp)
 d016f84:	e0bffd17 	ldw	r2,-12(fp)
 d016f88:	e0ffff17 	ldw	r3,-4(fp)
 d016f8c:	1004913a 	slli	r2,r2,4
 d016f90:	10c5883a 	add	r2,r2,r3
 d016f94:	10801004 	addi	r2,r2,64
 d016f98:	11000017 	ldw	r4,0(r2)
 d016f9c:	e0ffff17 	ldw	r3,-4(fp)
 d016fa0:	2804913a 	slli	r2,r5,4
 d016fa4:	10c5883a 	add	r2,r2,r3
 d016fa8:	10801004 	addi	r2,r2,64
 d016fac:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].block_size;
        flash->dev.region_info[j].block_size = swap;
 d016fb0:	e0bffd17 	ldw	r2,-12(fp)
 d016fb4:	e0ffff17 	ldw	r3,-4(fp)
 d016fb8:	1004913a 	slli	r2,r2,4
 d016fbc:	10c5883a 	add	r2,r2,r3
 d016fc0:	10c01004 	addi	r3,r2,64
 d016fc4:	e0bff917 	ldw	r2,-28(fp)
 d016fc8:	18800015 	stw	r2,0(r3)
 
        swap = flash->dev.region_info[i].number_of_blocks;
 d016fcc:	e0bffe17 	ldw	r2,-8(fp)
 d016fd0:	e0ffff17 	ldw	r3,-4(fp)
 d016fd4:	1004913a 	slli	r2,r2,4
 d016fd8:	10c5883a 	add	r2,r2,r3
 d016fdc:	10800f04 	addi	r2,r2,60
 d016fe0:	10800017 	ldw	r2,0(r2)
 d016fe4:	e0bff915 	stw	r2,-28(fp)
        flash->dev.region_info[i].number_of_blocks =  
 d016fe8:	e17ffe17 	ldw	r5,-8(fp)
 d016fec:	e0bffd17 	ldw	r2,-12(fp)
 d016ff0:	e0ffff17 	ldw	r3,-4(fp)
 d016ff4:	1004913a 	slli	r2,r2,4
 d016ff8:	10c5883a 	add	r2,r2,r3
 d016ffc:	10800f04 	addi	r2,r2,60
 d017000:	11000017 	ldw	r4,0(r2)
 d017004:	e0ffff17 	ldw	r3,-4(fp)
 d017008:	2804913a 	slli	r2,r5,4
 d01700c:	10c5883a 	add	r2,r2,r3
 d017010:	10800f04 	addi	r2,r2,60
 d017014:	11000015 	stw	r4,0(r2)
                                flash->dev.region_info[j].number_of_blocks;
        flash->dev.region_info[j].number_of_blocks = swap;
 d017018:	e0bffd17 	ldw	r2,-12(fp)
 d01701c:	e0ffff17 	ldw	r3,-4(fp)
 d017020:	1004913a 	slli	r2,r2,4
 d017024:	10c5883a 	add	r2,r2,r3
 d017028:	10c00f04 	addi	r3,r2,60
 d01702c:	e0bff917 	ldw	r2,-28(fp)
 d017030:	18800015 	stw	r2,0(r3)
     * so they're in the correct order
     */
    if ((flash->algorithm == CFI_ALG_AMD) && (boot_mode == TOP_BOOT_DEVICE))
    {
      for(i=flash->dev.number_of_regions-1, j=0;
          j<=i;i--,j++)
 d017034:	e0bffe17 	ldw	r2,-8(fp)
 d017038:	10bfffc4 	addi	r2,r2,-1
 d01703c:	e0bffe15 	stw	r2,-8(fp)
 d017040:	e0bffd17 	ldw	r2,-12(fp)
 d017044:	10800044 	addi	r2,r2,1
 d017048:	e0bffd15 	stw	r2,-12(fp)
 d01704c:	e0fffd17 	ldw	r3,-12(fp)
 d017050:	e0bffe17 	ldw	r2,-8(fp)
 d017054:	10ffa90e 	bge	r2,r3,d016efc <alt_read_cfi_table+0x388>
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 d017058:	e03ffe15 	stw	zero,-8(fp)
 d01705c:	00001306 	br	d0170ac <alt_read_cfi_table+0x538>
    {
      flash->dev.region_info[i].offset = offset;
 d017060:	e0bffe17 	ldw	r2,-8(fp)
 d017064:	e0ffff17 	ldw	r3,-4(fp)
 d017068:	1004913a 	slli	r2,r2,4
 d01706c:	10c5883a 	add	r2,r2,r3
 d017070:	10c00d04 	addi	r3,r2,52
 d017074:	e0bff617 	ldw	r2,-40(fp)
 d017078:	18800015 	stw	r2,0(r3)
      offset += flash->dev.region_info[i].region_size;
 d01707c:	e0bffe17 	ldw	r2,-8(fp)
 d017080:	e0ffff17 	ldw	r3,-4(fp)
 d017084:	1004913a 	slli	r2,r2,4
 d017088:	10c5883a 	add	r2,r2,r3
 d01708c:	10800e04 	addi	r2,r2,56
 d017090:	10c00017 	ldw	r3,0(r2)
 d017094:	e0bff617 	ldw	r2,-40(fp)
 d017098:	10c5883a 	add	r2,r2,r3
 d01709c:	e0bff615 	stw	r2,-40(fp)
        flash->dev.region_info[j].number_of_blocks = swap;

      } 
    }
    
    for(i=0;i<flash->dev.number_of_regions;i++)
 d0170a0:	e0bffe17 	ldw	r2,-8(fp)
 d0170a4:	10800044 	addi	r2,r2,1
 d0170a8:	e0bffe15 	stw	r2,-8(fp)
 d0170ac:	e0bfff17 	ldw	r2,-4(fp)
 d0170b0:	10c00c17 	ldw	r3,48(r2)
 d0170b4:	e0bffe17 	ldw	r2,-8(fp)
 d0170b8:	10ffe916 	blt	r2,r3,d017060 <alt_read_cfi_table+0x4ec>
    {
      flash->dev.region_info[i].offset = offset;
      offset += flash->dev.region_info[i].region_size;
    }
    
    (*flash->write_command)(flash->dev.base_addr, 
 d0170bc:	e0bfff17 	ldw	r2,-4(fp)
 d0170c0:	10c03317 	ldw	r3,204(r2)
 d0170c4:	e0bfff17 	ldw	r2,-4(fp)
 d0170c8:	11000a17 	ldw	r4,40(r2)
 d0170cc:	01401544 	movi	r5,85
 d0170d0:	01803fc4 	movi	r6,255
 d0170d4:	183ee83a 	callr	r3
                            0x55, 
                            READ_ARRAY_MODE);
  }  

  return ret_code;
 d0170d8:	e0bffb17 	ldw	r2,-20(fp)
}
 d0170dc:	e037883a 	mov	sp,fp
 d0170e0:	dfc00217 	ldw	ra,8(sp)
 d0170e4:	df000117 	ldw	fp,4(sp)
 d0170e8:	dc000017 	ldw	r16,0(sp)
 d0170ec:	dec00304 	addi	sp,sp,12
 d0170f0:	f800283a 	ret

0d0170f4 <alt_read_cfi_width>:
 * 
 * Work out the width of the device we're talking to and sanity check that we  
 * can read the CFI and the Primary Vendor specific Table
 */
int alt_read_cfi_width(alt_flash_cfi_dev* flash)
{
 d0170f4:	defff704 	addi	sp,sp,-36
 d0170f8:	dfc00815 	stw	ra,32(sp)
 d0170fc:	df000715 	stw	fp,28(sp)
 d017100:	df000704 	addi	fp,sp,28
 d017104:	e13fff15 	stw	r4,-4(fp)
  int i;
  alt_u8 byte_id[12];
  alt_u16 iface;
  int ret_code = 0;
 d017108:	e03ff915 	stw	zero,-28(fp)

  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d01710c:	e0bfff17 	ldw	r2,-4(fp)
 d017110:	11000a17 	ldw	r4,40(r2)
 d017114:	01401544 	movi	r5,85
 d017118:	01802604 	movi	r6,152
 d01711c:	d0166000 	call	d016600 <alt_write_flash_command_8bit_device_8bit_mode>

  for(i=0;i<3;i++)
 d017120:	e03ffb15 	stw	zero,-20(fp)
 d017124:	00000f06 	br	d017164 <alt_read_cfi_width+0x70>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
 d017128:	e13ffb17 	ldw	r4,-20(fp)
 d01712c:	e0bfff17 	ldw	r2,-4(fp)
 d017130:	10800a17 	ldw	r2,40(r2)
 d017134:	1007883a 	mov	r3,r2
 d017138:	e0bffb17 	ldw	r2,-20(fp)
 d01713c:	1885883a 	add	r2,r3,r2
 d017140:	10800404 	addi	r2,r2,16
 d017144:	10800023 	ldbuio	r2,0(r2)
 d017148:	1007883a 	mov	r3,r2
 d01714c:	e0bffc04 	addi	r2,fp,-16
 d017150:	1105883a 	add	r2,r2,r4
 d017154:	10c00005 	stb	r3,0(r2)
  /*
  * Check for 8 bit wide flash
  */
  alt_write_flash_command_8bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);

  for(i=0;i<3;i++)
 d017158:	e0bffb17 	ldw	r2,-20(fp)
 d01715c:	10800044 	addi	r2,r2,1
 d017160:	e0bffb15 	stw	r2,-20(fp)
 d017164:	e0bffb17 	ldw	r2,-20(fp)
 d017168:	108000d0 	cmplti	r2,r2,3
 d01716c:	103fee1e 	bne	r2,zero,d017128 <alt_read_cfi_width+0x34>
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 d017170:	e0bffc03 	ldbu	r2,-16(fp)
 d017174:	10803fcc 	andi	r2,r2,255
 d017178:	10801458 	cmpnei	r2,r2,81
 d01717c:	10001d1e 	bne	r2,zero,d0171f4 <alt_read_cfi_width+0x100>
 d017180:	e0bffc43 	ldbu	r2,-15(fp)
 d017184:	10803fcc 	andi	r2,r2,255
 d017188:	10801498 	cmpnei	r2,r2,82
 d01718c:	1000191e 	bne	r2,zero,d0171f4 <alt_read_cfi_width+0x100>
 d017190:	e0bffc83 	ldbu	r2,-14(fp)
 d017194:	10803fcc 	andi	r2,r2,255
 d017198:	10801658 	cmpnei	r2,r2,89
 d01719c:	1000151e 	bne	r2,zero,d0171f4 <alt_read_cfi_width+0x100>
      (byte_id[1] == 'R') &&
      (byte_id[2] == 'Y'))
  {
    flash->mode_width = 1;
 d0171a0:	e0ffff17 	ldw	r3,-4(fp)
 d0171a4:	00800044 	movi	r2,1
 d0171a8:	18802e15 	stw	r2,184(r3)
    flash->device_width = 1; 
 d0171ac:	e0ffff17 	ldw	r3,-4(fp)
 d0171b0:	00800044 	movi	r2,1
 d0171b4:	18802f15 	stw	r2,188(r3)
    iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR);
 d0171b8:	e0bfff17 	ldw	r2,-4(fp)
 d0171bc:	10800a17 	ldw	r2,40(r2)
 d0171c0:	10800a04 	addi	r2,r2,40
 d0171c4:	1080002b 	ldhuio	r2,0(r2)
 d0171c8:	e0bffa0d 	sth	r2,-24(fp)
    iface += 1;
 d0171cc:	e0bffa0b 	ldhu	r2,-24(fp)
 d0171d0:	10800044 	addi	r2,r2,1
 d0171d4:	e0bffa0d 	sth	r2,-24(fp)
    if (!(iface & 0x1))
 d0171d8:	e0bffa0b 	ldhu	r2,-24(fp)
 d0171dc:	1080004c 	andi	r2,r2,1
 d0171e0:	1004c03a 	cmpne	r2,r2,zero
 d0171e4:	1001a81e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
    {
      ret_code = -ENODEV;
 d0171e8:	00bffb44 	movi	r2,-19
 d0171ec:	e0bff915 	stw	r2,-28(fp)
  for(i=0;i<3;i++)
  {
    byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, QUERY_ADDR+i);
  }

  if ((byte_id[0] == 'Q') &&
 d0171f0:	0001a506 	br	d017888 <alt_read_cfi_width+0x794>
  else
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d0171f4:	e0bfff17 	ldw	r2,-4(fp)
 d0171f8:	11000a17 	ldw	r4,40(r2)
 d0171fc:	01401544 	movi	r5,85
 d017200:	01802604 	movi	r6,152
 d017204:	d01663c0 	call	d01663c <alt_write_flash_command_16bit_device_8bit_mode>
    for(i=0;i<6;i++)
 d017208:	e03ffb15 	stw	zero,-20(fp)
 d01720c:	00000f06 	br	d01724c <alt_read_cfi_width+0x158>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 d017210:	e13ffb17 	ldw	r4,-20(fp)
 d017214:	e0bfff17 	ldw	r2,-4(fp)
 d017218:	10800a17 	ldw	r2,40(r2)
 d01721c:	1007883a 	mov	r3,r2
 d017220:	e0bffb17 	ldw	r2,-20(fp)
 d017224:	1885883a 	add	r2,r3,r2
 d017228:	10800804 	addi	r2,r2,32
 d01722c:	10800023 	ldbuio	r2,0(r2)
 d017230:	1007883a 	mov	r3,r2
 d017234:	e0bffc04 	addi	r2,fp,-16
 d017238:	1105883a 	add	r2,r2,r4
 d01723c:	10c00005 	stb	r3,0(r2)
  {
    /*
    * Check for 8/16 bit in byte wide mode
    */
    alt_write_flash_command_16bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
    for(i=0;i<6;i++)
 d017240:	e0bffb17 	ldw	r2,-20(fp)
 d017244:	10800044 	addi	r2,r2,1
 d017248:	e0bffb15 	stw	r2,-20(fp)
 d01724c:	e0bffb17 	ldw	r2,-20(fp)
 d017250:	10800190 	cmplti	r2,r2,6
 d017254:	103fee1e 	bne	r2,zero,d017210 <alt_read_cfi_width+0x11c>
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 d017258:	e0bffc03 	ldbu	r2,-16(fp)
 d01725c:	10803fcc 	andi	r2,r2,255
 d017260:	10801458 	cmpnei	r2,r2,81
 d017264:	1000291e 	bne	r2,zero,d01730c <alt_read_cfi_width+0x218>
 d017268:	e0bffc43 	ldbu	r2,-15(fp)
 d01726c:	10803fcc 	andi	r2,r2,255
 d017270:	10801458 	cmpnei	r2,r2,81
 d017274:	1000251e 	bne	r2,zero,d01730c <alt_read_cfi_width+0x218>
 d017278:	e0bffc83 	ldbu	r2,-14(fp)
 d01727c:	10803fcc 	andi	r2,r2,255
 d017280:	10801498 	cmpnei	r2,r2,82
 d017284:	1000211e 	bne	r2,zero,d01730c <alt_read_cfi_width+0x218>
 d017288:	e0bffcc3 	ldbu	r2,-13(fp)
 d01728c:	10803fcc 	andi	r2,r2,255
 d017290:	10801498 	cmpnei	r2,r2,82
 d017294:	10001d1e 	bne	r2,zero,d01730c <alt_read_cfi_width+0x218>
 d017298:	e0bffd03 	ldbu	r2,-12(fp)
 d01729c:	10803fcc 	andi	r2,r2,255
 d0172a0:	10801658 	cmpnei	r2,r2,89
 d0172a4:	1000191e 	bne	r2,zero,d01730c <alt_read_cfi_width+0x218>
 d0172a8:	e0bffd43 	ldbu	r2,-11(fp)
 d0172ac:	10803fcc 	andi	r2,r2,255
 d0172b0:	10801658 	cmpnei	r2,r2,89
 d0172b4:	1000151e 	bne	r2,zero,d01730c <alt_read_cfi_width+0x218>
        (byte_id[2] == 'R') &&
        (byte_id[3] == 'R') && 
        (byte_id[4] == 'Y') && 
        (byte_id[5] == 'Y'))
    {
      flash->mode_width = 1;
 d0172b8:	e0ffff17 	ldw	r3,-4(fp)
 d0172bc:	00800044 	movi	r2,1
 d0172c0:	18802e15 	stw	r2,184(r3)
      flash->device_width = 2; 
 d0172c4:	e0ffff17 	ldw	r3,-4(fp)
 d0172c8:	00800084 	movi	r2,2
 d0172cc:	18802f15 	stw	r2,188(r3)
      iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 d0172d0:	e0bfff17 	ldw	r2,-4(fp)
 d0172d4:	10800a17 	ldw	r2,40(r2)
 d0172d8:	10801404 	addi	r2,r2,80
 d0172dc:	1080002b 	ldhuio	r2,0(r2)
 d0172e0:	e0bffa0d 	sth	r2,-24(fp)
      iface += 1;
 d0172e4:	e0bffa0b 	ldhu	r2,-24(fp)
 d0172e8:	10800044 	addi	r2,r2,1
 d0172ec:	e0bffa0d 	sth	r2,-24(fp)
      if (!(iface & 0x1))
 d0172f0:	e0bffa0b 	ldhu	r2,-24(fp)
 d0172f4:	1080004c 	andi	r2,r2,1
 d0172f8:	1004c03a 	cmpne	r2,r2,zero
 d0172fc:	1001621e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
      {
        ret_code = -ENODEV;
 d017300:	00bffb44 	movi	r2,-19
 d017304:	e0bff915 	stw	r2,-28(fp)
    for(i=0;i<6;i++)
    {
      byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
    }

    if ((byte_id[0] == 'Q') && 
 d017308:	00015f06 	br	d017888 <alt_read_cfi_width+0x794>
    else
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d01730c:	e0bfff17 	ldw	r2,-4(fp)
 d017310:	11000a17 	ldw	r4,40(r2)
 d017314:	01401544 	movi	r5,85
 d017318:	01802604 	movi	r6,152
 d01731c:	d0167000 	call	d016700 <alt_write_flash_command_16bit_device_16bit_mode>
      for(i=0;i<6;i++)
 d017320:	e03ffb15 	stw	zero,-20(fp)
 d017324:	00000f06 	br	d017364 <alt_read_cfi_width+0x270>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
 d017328:	e13ffb17 	ldw	r4,-20(fp)
 d01732c:	e0bfff17 	ldw	r2,-4(fp)
 d017330:	10800a17 	ldw	r2,40(r2)
 d017334:	1007883a 	mov	r3,r2
 d017338:	e0bffb17 	ldw	r2,-20(fp)
 d01733c:	1885883a 	add	r2,r3,r2
 d017340:	10800804 	addi	r2,r2,32
 d017344:	10800023 	ldbuio	r2,0(r2)
 d017348:	1007883a 	mov	r3,r2
 d01734c:	e0bffc04 	addi	r2,fp,-16
 d017350:	1105883a 	add	r2,r2,r4
 d017354:	10c00005 	stb	r3,0(r2)
    {
      /*
      * Check for 16 bit flash in word mode
      */
      alt_write_flash_command_16bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
      for(i=0;i<6;i++)
 d017358:	e0bffb17 	ldw	r2,-20(fp)
 d01735c:	10800044 	addi	r2,r2,1
 d017360:	e0bffb15 	stw	r2,-20(fp)
 d017364:	e0bffb17 	ldw	r2,-20(fp)
 d017368:	10800190 	cmplti	r2,r2,6
 d01736c:	103fee1e 	bne	r2,zero,d017328 <alt_read_cfi_width+0x234>
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 d017370:	e0bffc03 	ldbu	r2,-16(fp)
 d017374:	10803fcc 	andi	r2,r2,255
 d017378:	10801458 	cmpnei	r2,r2,81
 d01737c:	1000291e 	bne	r2,zero,d017424 <alt_read_cfi_width+0x330>
 d017380:	e0bffc43 	ldbu	r2,-15(fp)
 d017384:	10803fcc 	andi	r2,r2,255
 d017388:	1004c03a 	cmpne	r2,r2,zero
 d01738c:	1000251e 	bne	r2,zero,d017424 <alt_read_cfi_width+0x330>
 d017390:	e0bffc83 	ldbu	r2,-14(fp)
 d017394:	10803fcc 	andi	r2,r2,255
 d017398:	10801498 	cmpnei	r2,r2,82
 d01739c:	1000211e 	bne	r2,zero,d017424 <alt_read_cfi_width+0x330>
 d0173a0:	e0bffcc3 	ldbu	r2,-13(fp)
 d0173a4:	10803fcc 	andi	r2,r2,255
 d0173a8:	1004c03a 	cmpne	r2,r2,zero
 d0173ac:	10001d1e 	bne	r2,zero,d017424 <alt_read_cfi_width+0x330>
 d0173b0:	e0bffd03 	ldbu	r2,-12(fp)
 d0173b4:	10803fcc 	andi	r2,r2,255
 d0173b8:	10801658 	cmpnei	r2,r2,89
 d0173bc:	1000191e 	bne	r2,zero,d017424 <alt_read_cfi_width+0x330>
 d0173c0:	e0bffd43 	ldbu	r2,-11(fp)
 d0173c4:	10803fcc 	andi	r2,r2,255
 d0173c8:	1004c03a 	cmpne	r2,r2,zero
 d0173cc:	1000151e 	bne	r2,zero,d017424 <alt_read_cfi_width+0x330>
          (byte_id[2] == 'R') && 
          (byte_id[3] == '\0') && 
          (byte_id[4] == 'Y') && 
          (byte_id[5] == '\0'))
      {
        flash->mode_width = 2;
 d0173d0:	e0ffff17 	ldw	r3,-4(fp)
 d0173d4:	00800084 	movi	r2,2
 d0173d8:	18802e15 	stw	r2,184(r3)
        flash->device_width = 2; 
 d0173dc:	e0ffff17 	ldw	r3,-4(fp)
 d0173e0:	00800084 	movi	r2,2
 d0173e4:	18802f15 	stw	r2,188(r3)
        iface = IORD_16DIRECT(flash->dev.base_addr, INTERFACE_ADDR*2);
 d0173e8:	e0bfff17 	ldw	r2,-4(fp)
 d0173ec:	10800a17 	ldw	r2,40(r2)
 d0173f0:	10801404 	addi	r2,r2,80
 d0173f4:	1080002b 	ldhuio	r2,0(r2)
 d0173f8:	e0bffa0d 	sth	r2,-24(fp)
        iface += 1;
 d0173fc:	e0bffa0b 	ldhu	r2,-24(fp)
 d017400:	10800044 	addi	r2,r2,1
 d017404:	e0bffa0d 	sth	r2,-24(fp)
        if (!(iface & 0x2))
 d017408:	e0bffa0b 	ldhu	r2,-24(fp)
 d01740c:	1080008c 	andi	r2,r2,2
 d017410:	1004c03a 	cmpne	r2,r2,zero
 d017414:	10011c1e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
        {
          ret_code = -ENODEV;
 d017418:	00bffb44 	movi	r2,-19
 d01741c:	e0bff915 	stw	r2,-28(fp)
      for(i=0;i<6;i++)
      {
        byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*2)+i);
      }

      if ((byte_id[0] == 'Q') && 
 d017420:	00011906 	br	d017888 <alt_read_cfi_width+0x794>
      else
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d017424:	e0bfff17 	ldw	r2,-4(fp)
 d017428:	11000a17 	ldw	r4,40(r2)
 d01742c:	01401544 	movi	r5,85
 d017430:	01802604 	movi	r6,152
 d017434:	d01678c0 	call	d01678c <alt_write_flash_command_32bit_device_32bit_mode>
        for(i=0;i<12;i++)
 d017438:	e03ffb15 	stw	zero,-20(fp)
 d01743c:	00000f06 	br	d01747c <alt_read_cfi_width+0x388>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 d017440:	e13ffb17 	ldw	r4,-20(fp)
 d017444:	e0bfff17 	ldw	r2,-4(fp)
 d017448:	10800a17 	ldw	r2,40(r2)
 d01744c:	1007883a 	mov	r3,r2
 d017450:	e0bffb17 	ldw	r2,-20(fp)
 d017454:	1885883a 	add	r2,r3,r2
 d017458:	10801004 	addi	r2,r2,64
 d01745c:	10800023 	ldbuio	r2,0(r2)
 d017460:	1007883a 	mov	r3,r2
 d017464:	e0bffc04 	addi	r2,fp,-16
 d017468:	1105883a 	add	r2,r2,r4
 d01746c:	10c00005 	stb	r3,0(r2)
      {
        /*
        * Check for 32bit wide flash in 32 bit mode
        */
        alt_write_flash_command_32bit_device_32bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
        for(i=0;i<12;i++)
 d017470:	e0bffb17 	ldw	r2,-20(fp)
 d017474:	10800044 	addi	r2,r2,1
 d017478:	e0bffb15 	stw	r2,-20(fp)
 d01747c:	e0bffb17 	ldw	r2,-20(fp)
 d017480:	10800310 	cmplti	r2,r2,12
 d017484:	103fee1e 	bne	r2,zero,d017440 <alt_read_cfi_width+0x34c>
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 d017488:	e0bffc03 	ldbu	r2,-16(fp)
 d01748c:	10803fcc 	andi	r2,r2,255
 d017490:	10801458 	cmpnei	r2,r2,81
 d017494:	1000411e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d017498:	e0bffc43 	ldbu	r2,-15(fp)
 d01749c:	10803fcc 	andi	r2,r2,255
 d0174a0:	1004c03a 	cmpne	r2,r2,zero
 d0174a4:	10003d1e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d0174a8:	e0bffc83 	ldbu	r2,-14(fp)
 d0174ac:	10803fcc 	andi	r2,r2,255
 d0174b0:	1004c03a 	cmpne	r2,r2,zero
 d0174b4:	1000391e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d0174b8:	e0bffcc3 	ldbu	r2,-13(fp)
 d0174bc:	10803fcc 	andi	r2,r2,255
 d0174c0:	1004c03a 	cmpne	r2,r2,zero
 d0174c4:	1000351e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d0174c8:	e0bffd03 	ldbu	r2,-12(fp)
 d0174cc:	10803fcc 	andi	r2,r2,255
 d0174d0:	10801498 	cmpnei	r2,r2,82
 d0174d4:	1000311e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d0174d8:	e0bffd43 	ldbu	r2,-11(fp)
 d0174dc:	10803fcc 	andi	r2,r2,255
 d0174e0:	1004c03a 	cmpne	r2,r2,zero
 d0174e4:	10002d1e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d0174e8:	e0bffd83 	ldbu	r2,-10(fp)
 d0174ec:	10803fcc 	andi	r2,r2,255
 d0174f0:	1004c03a 	cmpne	r2,r2,zero
 d0174f4:	1000291e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d0174f8:	e0bffdc3 	ldbu	r2,-9(fp)
 d0174fc:	10803fcc 	andi	r2,r2,255
 d017500:	1004c03a 	cmpne	r2,r2,zero
 d017504:	1000251e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d017508:	e0bffe03 	ldbu	r2,-8(fp)
 d01750c:	10803fcc 	andi	r2,r2,255
 d017510:	10801658 	cmpnei	r2,r2,89
 d017514:	1000211e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d017518:	e0bffe43 	ldbu	r2,-7(fp)
 d01751c:	10803fcc 	andi	r2,r2,255
 d017520:	1004c03a 	cmpne	r2,r2,zero
 d017524:	10001d1e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d017528:	e0bffe83 	ldbu	r2,-6(fp)
 d01752c:	10803fcc 	andi	r2,r2,255
 d017530:	1004c03a 	cmpne	r2,r2,zero
 d017534:	1000191e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
 d017538:	e0bffec3 	ldbu	r2,-5(fp)
 d01753c:	10803fcc 	andi	r2,r2,255
 d017540:	1004c03a 	cmpne	r2,r2,zero
 d017544:	1000151e 	bne	r2,zero,d01759c <alt_read_cfi_width+0x4a8>
          (byte_id[8] == 'Y') && 
          (byte_id[9] == '\0') && 
          (byte_id[10] == '\0') && 
          (byte_id[11] == '\0'))
        {
          flash->mode_width = 4;
 d017548:	e0ffff17 	ldw	r3,-4(fp)
 d01754c:	00800104 	movi	r2,4
 d017550:	18802e15 	stw	r2,184(r3)
          flash->device_width = 4; 
 d017554:	e0ffff17 	ldw	r3,-4(fp)
 d017558:	00800104 	movi	r2,4
 d01755c:	18802f15 	stw	r2,188(r3)
          iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 d017560:	e0bfff17 	ldw	r2,-4(fp)
 d017564:	10800a17 	ldw	r2,40(r2)
 d017568:	10802804 	addi	r2,r2,160
 d01756c:	10800037 	ldwio	r2,0(r2)
 d017570:	e0bffa0d 	sth	r2,-24(fp)
          iface += 1;
 d017574:	e0bffa0b 	ldhu	r2,-24(fp)
 d017578:	10800044 	addi	r2,r2,1
 d01757c:	e0bffa0d 	sth	r2,-24(fp)
          if (!(iface & 0x4))
 d017580:	e0bffa0b 	ldhu	r2,-24(fp)
 d017584:	1080010c 	andi	r2,r2,4
 d017588:	1004c03a 	cmpne	r2,r2,zero
 d01758c:	1000be1e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
          {
            ret_code = -ENODEV;
 d017590:	00bffb44 	movi	r2,-19
 d017594:	e0bff915 	stw	r2,-28(fp)
        for(i=0;i<12;i++)
        {
          byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
        }

        if ((byte_id[0] == 'Q') &&
 d017598:	0000bb06 	br	d017888 <alt_read_cfi_width+0x794>
        else
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d01759c:	e0bfff17 	ldw	r2,-4(fp)
 d0175a0:	11000a17 	ldw	r4,40(r2)
 d0175a4:	01401544 	movi	r5,85
 d0175a8:	01802604 	movi	r6,152
 d0175ac:	d0167440 	call	d016744 <alt_write_flash_command_32bit_device_16bit_mode>
          for(i=0;i<12;i++)
 d0175b0:	e03ffb15 	stw	zero,-20(fp)
 d0175b4:	00000f06 	br	d0175f4 <alt_read_cfi_width+0x500>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 d0175b8:	e13ffb17 	ldw	r4,-20(fp)
 d0175bc:	e0bfff17 	ldw	r2,-4(fp)
 d0175c0:	10800a17 	ldw	r2,40(r2)
 d0175c4:	1007883a 	mov	r3,r2
 d0175c8:	e0bffb17 	ldw	r2,-20(fp)
 d0175cc:	1885883a 	add	r2,r3,r2
 d0175d0:	10801004 	addi	r2,r2,64
 d0175d4:	10800023 	ldbuio	r2,0(r2)
 d0175d8:	1007883a 	mov	r3,r2
 d0175dc:	e0bffc04 	addi	r2,fp,-16
 d0175e0:	1105883a 	add	r2,r2,r4
 d0175e4:	10c00005 	stb	r3,0(r2)
        {
          /*
          * Check for 32 bit wide in 16 bit mode
          */
          alt_write_flash_command_32bit_device_16bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
          for(i=0;i<12;i++)
 d0175e8:	e0bffb17 	ldw	r2,-20(fp)
 d0175ec:	10800044 	addi	r2,r2,1
 d0175f0:	e0bffb15 	stw	r2,-20(fp)
 d0175f4:	e0bffb17 	ldw	r2,-20(fp)
 d0175f8:	10800310 	cmplti	r2,r2,12
 d0175fc:	103fee1e 	bne	r2,zero,d0175b8 <alt_read_cfi_width+0x4c4>
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 d017600:	e0bffc03 	ldbu	r2,-16(fp)
 d017604:	10803fcc 	andi	r2,r2,255
 d017608:	10801458 	cmpnei	r2,r2,81
 d01760c:	1000411e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d017610:	e0bffc43 	ldbu	r2,-15(fp)
 d017614:	10803fcc 	andi	r2,r2,255
 d017618:	1004c03a 	cmpne	r2,r2,zero
 d01761c:	10003d1e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d017620:	e0bffc83 	ldbu	r2,-14(fp)
 d017624:	10803fcc 	andi	r2,r2,255
 d017628:	10801458 	cmpnei	r2,r2,81
 d01762c:	1000391e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d017630:	e0bffcc3 	ldbu	r2,-13(fp)
 d017634:	10803fcc 	andi	r2,r2,255
 d017638:	1004c03a 	cmpne	r2,r2,zero
 d01763c:	1000351e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d017640:	e0bffd03 	ldbu	r2,-12(fp)
 d017644:	10803fcc 	andi	r2,r2,255
 d017648:	10801498 	cmpnei	r2,r2,82
 d01764c:	1000311e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d017650:	e0bffd43 	ldbu	r2,-11(fp)
 d017654:	10803fcc 	andi	r2,r2,255
 d017658:	1004c03a 	cmpne	r2,r2,zero
 d01765c:	10002d1e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d017660:	e0bffd83 	ldbu	r2,-10(fp)
 d017664:	10803fcc 	andi	r2,r2,255
 d017668:	10801498 	cmpnei	r2,r2,82
 d01766c:	1000291e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d017670:	e0bffdc3 	ldbu	r2,-9(fp)
 d017674:	10803fcc 	andi	r2,r2,255
 d017678:	1004c03a 	cmpne	r2,r2,zero
 d01767c:	1000251e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d017680:	e0bffe03 	ldbu	r2,-8(fp)
 d017684:	10803fcc 	andi	r2,r2,255
 d017688:	10801658 	cmpnei	r2,r2,89
 d01768c:	1000211e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d017690:	e0bffe43 	ldbu	r2,-7(fp)
 d017694:	10803fcc 	andi	r2,r2,255
 d017698:	1004c03a 	cmpne	r2,r2,zero
 d01769c:	10001d1e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d0176a0:	e0bffe83 	ldbu	r2,-6(fp)
 d0176a4:	10803fcc 	andi	r2,r2,255
 d0176a8:	10801658 	cmpnei	r2,r2,89
 d0176ac:	1000191e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
 d0176b0:	e0bffec3 	ldbu	r2,-5(fp)
 d0176b4:	10803fcc 	andi	r2,r2,255
 d0176b8:	1004c03a 	cmpne	r2,r2,zero
 d0176bc:	1000151e 	bne	r2,zero,d017714 <alt_read_cfi_width+0x620>
              (byte_id[8] == 'Y') &&
              (byte_id[9] == '\0') &&
              (byte_id[10] == 'Y') &&
              (byte_id[11] == '\0'))
          {
            flash->mode_width = 2;
 d0176c0:	e0ffff17 	ldw	r3,-4(fp)
 d0176c4:	00800084 	movi	r2,2
 d0176c8:	18802e15 	stw	r2,184(r3)
            flash->device_width = 4; 
 d0176cc:	e0ffff17 	ldw	r3,-4(fp)
 d0176d0:	00800104 	movi	r2,4
 d0176d4:	18802f15 	stw	r2,188(r3)
            iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 d0176d8:	e0bfff17 	ldw	r2,-4(fp)
 d0176dc:	10800a17 	ldw	r2,40(r2)
 d0176e0:	10802804 	addi	r2,r2,160
 d0176e4:	10800037 	ldwio	r2,0(r2)
 d0176e8:	e0bffa0d 	sth	r2,-24(fp)
            iface += 1;
 d0176ec:	e0bffa0b 	ldhu	r2,-24(fp)
 d0176f0:	10800044 	addi	r2,r2,1
 d0176f4:	e0bffa0d 	sth	r2,-24(fp)
            if (!(iface & 0x4))
 d0176f8:	e0bffa0b 	ldhu	r2,-24(fp)
 d0176fc:	1080010c 	andi	r2,r2,4
 d017700:	1004c03a 	cmpne	r2,r2,zero
 d017704:	1000601e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
            {
              ret_code = -ENODEV;
 d017708:	00bffb44 	movi	r2,-19
 d01770c:	e0bff915 	stw	r2,-28(fp)
          for(i=0;i<12;i++)
          {
            byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
          }

          if ((byte_id[0] == 'Q') &&
 d017710:	00005d06 	br	d017888 <alt_read_cfi_width+0x794>
          else
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
 d017714:	e0bfff17 	ldw	r2,-4(fp)
 d017718:	11000a17 	ldw	r4,40(r2)
 d01771c:	01401544 	movi	r5,85
 d017720:	01802604 	movi	r6,152
 d017724:	d0166b80 	call	d0166b8 <alt_write_flash_command_32bit_device_8bit_mode>
            for(i=0;i<12;i++)
 d017728:	e03ffb15 	stw	zero,-20(fp)
 d01772c:	00000f06 	br	d01776c <alt_read_cfi_width+0x678>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
 d017730:	e13ffb17 	ldw	r4,-20(fp)
 d017734:	e0bfff17 	ldw	r2,-4(fp)
 d017738:	10800a17 	ldw	r2,40(r2)
 d01773c:	1007883a 	mov	r3,r2
 d017740:	e0bffb17 	ldw	r2,-20(fp)
 d017744:	1885883a 	add	r2,r3,r2
 d017748:	10801004 	addi	r2,r2,64
 d01774c:	10800023 	ldbuio	r2,0(r2)
 d017750:	1007883a 	mov	r3,r2
 d017754:	e0bffc04 	addi	r2,fp,-16
 d017758:	1105883a 	add	r2,r2,r4
 d01775c:	10c00005 	stb	r3,0(r2)
          {
            /*
            * 32 Bit wide flash in byte mode
            */
            alt_write_flash_command_32bit_device_8bit_mode(flash->dev.base_addr, 0x55, QUERY_MODE);
            for(i=0;i<12;i++)
 d017760:	e0bffb17 	ldw	r2,-20(fp)
 d017764:	10800044 	addi	r2,r2,1
 d017768:	e0bffb15 	stw	r2,-20(fp)
 d01776c:	e0bffb17 	ldw	r2,-20(fp)
 d017770:	10800310 	cmplti	r2,r2,12
 d017774:	103fee1e 	bne	r2,zero,d017730 <alt_read_cfi_width+0x63c>
            {
              byte_id[i] = IORD_8DIRECT(flash->dev.base_addr, (QUERY_ADDR*4)+i);
            }

            if ((byte_id[0] == 'Q') &&
 d017778:	e0bffc03 	ldbu	r2,-16(fp)
 d01777c:	10803fcc 	andi	r2,r2,255
 d017780:	10801458 	cmpnei	r2,r2,81
 d017784:	1000401e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d017788:	e0bffc43 	ldbu	r2,-15(fp)
 d01778c:	10803fcc 	andi	r2,r2,255
 d017790:	10801458 	cmpnei	r2,r2,81
 d017794:	10003c1e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d017798:	e0bffc83 	ldbu	r2,-14(fp)
 d01779c:	10803fcc 	andi	r2,r2,255
 d0177a0:	10801458 	cmpnei	r2,r2,81
 d0177a4:	1000381e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d0177a8:	e0bffcc3 	ldbu	r2,-13(fp)
 d0177ac:	10803fcc 	andi	r2,r2,255
 d0177b0:	10801458 	cmpnei	r2,r2,81
 d0177b4:	1000341e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d0177b8:	e0bffd03 	ldbu	r2,-12(fp)
 d0177bc:	10803fcc 	andi	r2,r2,255
 d0177c0:	10801498 	cmpnei	r2,r2,82
 d0177c4:	1000301e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d0177c8:	e0bffd43 	ldbu	r2,-11(fp)
 d0177cc:	10803fcc 	andi	r2,r2,255
 d0177d0:	10801498 	cmpnei	r2,r2,82
 d0177d4:	10002c1e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d0177d8:	e0bffd83 	ldbu	r2,-10(fp)
 d0177dc:	10803fcc 	andi	r2,r2,255
 d0177e0:	10801498 	cmpnei	r2,r2,82
 d0177e4:	1000281e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d0177e8:	e0bffdc3 	ldbu	r2,-9(fp)
 d0177ec:	10803fcc 	andi	r2,r2,255
 d0177f0:	10801498 	cmpnei	r2,r2,82
 d0177f4:	1000241e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d0177f8:	e0bffe03 	ldbu	r2,-8(fp)
 d0177fc:	10803fcc 	andi	r2,r2,255
 d017800:	10801658 	cmpnei	r2,r2,89
 d017804:	1000201e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d017808:	e0bffe43 	ldbu	r2,-7(fp)
 d01780c:	10803fcc 	andi	r2,r2,255
 d017810:	10801658 	cmpnei	r2,r2,89
 d017814:	10001c1e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d017818:	e0bffe83 	ldbu	r2,-6(fp)
 d01781c:	10803fcc 	andi	r2,r2,255
 d017820:	10801658 	cmpnei	r2,r2,89
 d017824:	1000181e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
 d017828:	e0bffec3 	ldbu	r2,-5(fp)
 d01782c:	10803fcc 	andi	r2,r2,255
 d017830:	10801658 	cmpnei	r2,r2,89
 d017834:	1000141e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
                (byte_id[8] == 'Y') && 
                (byte_id[9] == 'Y') && 
                (byte_id[10] == 'Y') && 
                (byte_id[11] == 'Y'))
            {
              flash->mode_width = 1;
 d017838:	e0ffff17 	ldw	r3,-4(fp)
 d01783c:	00800044 	movi	r2,1
 d017840:	18802e15 	stw	r2,184(r3)
              flash->device_width = 4; 
 d017844:	e0ffff17 	ldw	r3,-4(fp)
 d017848:	00800104 	movi	r2,4
 d01784c:	18802f15 	stw	r2,188(r3)
              iface = IORD_32DIRECT(flash->dev.base_addr, INTERFACE_ADDR*4);
 d017850:	e0bfff17 	ldw	r2,-4(fp)
 d017854:	10800a17 	ldw	r2,40(r2)
 d017858:	10802804 	addi	r2,r2,160
 d01785c:	10800037 	ldwio	r2,0(r2)
 d017860:	e0bffa0d 	sth	r2,-24(fp)
              iface += 1;
 d017864:	e0bffa0b 	ldhu	r2,-24(fp)
 d017868:	10800044 	addi	r2,r2,1
 d01786c:	e0bffa0d 	sth	r2,-24(fp)
              if (!(iface & 0x4))
 d017870:	e0bffa0b 	ldhu	r2,-24(fp)
 d017874:	1080010c 	andi	r2,r2,4
 d017878:	1004c03a 	cmpne	r2,r2,zero
 d01787c:	1000021e 	bne	r2,zero,d017888 <alt_read_cfi_width+0x794>
              {
                ret_code = -ENODEV;
 d017880:	00bffb44 	movi	r2,-19
 d017884:	e0bff915 	stw	r2,-28(fp)
        }
      }
    }
  }
  
  return ret_code;
 d017888:	e0bff917 	ldw	r2,-28(fp)
}
 d01788c:	e037883a 	mov	sp,fp
 d017890:	dfc00117 	ldw	ra,4(sp)
 d017894:	df000017 	ldw	fp,0(sp)
 d017898:	dec00204 	addi	sp,sp,8
 d01789c:	f800283a 	ret

0d0178a0 <alt_check_primary_table>:
 * 
 * Check that the primary Vendor table starts with the 
 * correct pattern
 */
int alt_check_primary_table(alt_flash_cfi_dev* flash)
{
 d0178a0:	defff904 	addi	sp,sp,-28
 d0178a4:	dfc00615 	stw	ra,24(sp)
 d0178a8:	df000515 	stw	fp,20(sp)
 d0178ac:	dc000415 	stw	r16,16(sp)
 d0178b0:	df000404 	addi	fp,sp,16
 d0178b4:	e13fff15 	stw	r4,-4(fp)
  int i;
  int ret_code = 0;
 d0178b8:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
 d0178bc:	e13fff17 	ldw	r4,-4(fp)
 d0178c0:	01400544 	movi	r5,21
 d0178c4:	d016af80 	call	d016af8 <alt_read_16bit_query_entry>
 d0178c8:	10ffffcc 	andi	r3,r2,65535
 d0178cc:	e0bfff17 	ldw	r2,-4(fp)
 d0178d0:	10c03215 	stw	r3,200(r2)
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 d0178d4:	e03ffd15 	stw	zero,-12(fp)
 d0178d8:	00001006 	br	d01791c <alt_check_primary_table+0x7c>
  {
    primary_query_string[i] = 
 d0178dc:	e43ffd17 	ldw	r16,-12(fp)
 d0178e0:	e0bfff17 	ldw	r2,-4(fp)
 d0178e4:	11803417 	ldw	r6,208(r2)
 d0178e8:	e0bfff17 	ldw	r2,-4(fp)
 d0178ec:	10c03217 	ldw	r3,200(r2)
 d0178f0:	e0bffd17 	ldw	r2,-12(fp)
 d0178f4:	188b883a 	add	r5,r3,r2
 d0178f8:	e13fff17 	ldw	r4,-4(fp)
 d0178fc:	303ee83a 	callr	r6
 d017900:	1007883a 	mov	r3,r2
 d017904:	e0bffe04 	addi	r2,fp,-8
 d017908:	1405883a 	add	r2,r2,r16
 d01790c:	10c00005 	stb	r3,0(r2)
  alt_u8 primary_query_string[3];
  
  flash->primary_address = alt_read_16bit_query_entry( flash, 
                            PRIMARY_ADDR);
  
  for(i=0;i<3;i++)
 d017910:	e0bffd17 	ldw	r2,-12(fp)
 d017914:	10800044 	addi	r2,r2,1
 d017918:	e0bffd15 	stw	r2,-12(fp)
 d01791c:	e0bffd17 	ldw	r2,-12(fp)
 d017920:	108000d0 	cmplti	r2,r2,3
 d017924:	103fed1e 	bne	r2,zero,d0178dc <alt_check_primary_table+0x3c>
  {
    primary_query_string[i] = 
          (*flash->read_query)( flash,(flash->primary_address + i));
  }
    
  if ((primary_query_string[0] != 'P') ||
 d017928:	e0bffe03 	ldbu	r2,-8(fp)
 d01792c:	10803fcc 	andi	r2,r2,255
 d017930:	10801418 	cmpnei	r2,r2,80
 d017934:	1000081e 	bne	r2,zero,d017958 <alt_check_primary_table+0xb8>
 d017938:	e0bffe43 	ldbu	r2,-7(fp)
 d01793c:	10803fcc 	andi	r2,r2,255
 d017940:	10801498 	cmpnei	r2,r2,82
 d017944:	1000041e 	bne	r2,zero,d017958 <alt_check_primary_table+0xb8>
 d017948:	e0bffe83 	ldbu	r2,-6(fp)
 d01794c:	10803fcc 	andi	r2,r2,255
 d017950:	10801260 	cmpeqi	r2,r2,73
 d017954:	1000021e 	bne	r2,zero,d017960 <alt_check_primary_table+0xc0>
      (primary_query_string[1] != 'R') ||
      (primary_query_string[2] != 'I'))
  {
    ret_code = -ENODEV;
 d017958:	00bffb44 	movi	r2,-19
 d01795c:	e0bffc15 	stw	r2,-16(fp)
  }
  
  return ret_code;
 d017960:	e0bffc17 	ldw	r2,-16(fp)
}
 d017964:	e037883a 	mov	sp,fp
 d017968:	dfc00217 	ldw	ra,8(sp)
 d01796c:	df000117 	ldw	fp,4(sp)
 d017970:	dc000017 	ldw	r16,0(sp)
 d017974:	dec00304 	addi	sp,sp,12
 d017978:	f800283a 	ret

0d01797c <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 d01797c:	defffa04 	addi	sp,sp,-24
 d017980:	dfc00515 	stw	ra,20(sp)
 d017984:	df000415 	stw	fp,16(sp)
 d017988:	df000404 	addi	fp,sp,16
 d01798c:	e13ffd15 	stw	r4,-12(fp)
 d017990:	e17ffe15 	stw	r5,-8(fp)
 d017994:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 d017998:	e0bffd17 	ldw	r2,-12(fp)
 d01799c:	10800017 	ldw	r2,0(r2)
 d0179a0:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 d0179a4:	e0bffc17 	ldw	r2,-16(fp)
 d0179a8:	11000a04 	addi	r4,r2,40
 d0179ac:	e0bffd17 	ldw	r2,-12(fp)
 d0179b0:	11c00217 	ldw	r7,8(r2)
 d0179b4:	e17ffe17 	ldw	r5,-8(fp)
 d0179b8:	e1bfff17 	ldw	r6,-4(fp)
 d0179bc:	d01813c0 	call	d01813c <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 d0179c0:	e037883a 	mov	sp,fp
 d0179c4:	dfc00117 	ldw	ra,4(sp)
 d0179c8:	df000017 	ldw	fp,0(sp)
 d0179cc:	dec00204 	addi	sp,sp,8
 d0179d0:	f800283a 	ret

0d0179d4 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 d0179d4:	defffa04 	addi	sp,sp,-24
 d0179d8:	dfc00515 	stw	ra,20(sp)
 d0179dc:	df000415 	stw	fp,16(sp)
 d0179e0:	df000404 	addi	fp,sp,16
 d0179e4:	e13ffd15 	stw	r4,-12(fp)
 d0179e8:	e17ffe15 	stw	r5,-8(fp)
 d0179ec:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 d0179f0:	e0bffd17 	ldw	r2,-12(fp)
 d0179f4:	10800017 	ldw	r2,0(r2)
 d0179f8:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 d0179fc:	e0bffc17 	ldw	r2,-16(fp)
 d017a00:	11000a04 	addi	r4,r2,40
 d017a04:	e0bffd17 	ldw	r2,-12(fp)
 d017a08:	11c00217 	ldw	r7,8(r2)
 d017a0c:	e17ffe17 	ldw	r5,-8(fp)
 d017a10:	e1bfff17 	ldw	r6,-4(fp)
 d017a14:	d0183fc0 	call	d0183fc <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 d017a18:	e037883a 	mov	sp,fp
 d017a1c:	dfc00117 	ldw	ra,4(sp)
 d017a20:	df000017 	ldw	fp,0(sp)
 d017a24:	dec00204 	addi	sp,sp,8
 d017a28:	f800283a 	ret

0d017a2c <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 d017a2c:	defffc04 	addi	sp,sp,-16
 d017a30:	dfc00315 	stw	ra,12(sp)
 d017a34:	df000215 	stw	fp,8(sp)
 d017a38:	df000204 	addi	fp,sp,8
 d017a3c:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 d017a40:	e0bfff17 	ldw	r2,-4(fp)
 d017a44:	10800017 	ldw	r2,0(r2)
 d017a48:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 d017a4c:	e0bffe17 	ldw	r2,-8(fp)
 d017a50:	11000a04 	addi	r4,r2,40
 d017a54:	e0bfff17 	ldw	r2,-4(fp)
 d017a58:	11400217 	ldw	r5,8(r2)
 d017a5c:	d017fd40 	call	d017fd4 <altera_avalon_jtag_uart_close>
}
 d017a60:	e037883a 	mov	sp,fp
 d017a64:	dfc00117 	ldw	ra,4(sp)
 d017a68:	df000017 	ldw	fp,0(sp)
 d017a6c:	dec00204 	addi	sp,sp,8
 d017a70:	f800283a 	ret

0d017a74 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 d017a74:	defffa04 	addi	sp,sp,-24
 d017a78:	dfc00515 	stw	ra,20(sp)
 d017a7c:	df000415 	stw	fp,16(sp)
 d017a80:	df000404 	addi	fp,sp,16
 d017a84:	e13ffd15 	stw	r4,-12(fp)
 d017a88:	e17ffe15 	stw	r5,-8(fp)
 d017a8c:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 d017a90:	e0bffd17 	ldw	r2,-12(fp)
 d017a94:	10800017 	ldw	r2,0(r2)
 d017a98:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 d017a9c:	e0bffc17 	ldw	r2,-16(fp)
 d017aa0:	11000a04 	addi	r4,r2,40
 d017aa4:	e17ffe17 	ldw	r5,-8(fp)
 d017aa8:	e1bfff17 	ldw	r6,-4(fp)
 d017aac:	d0180480 	call	d018048 <altera_avalon_jtag_uart_ioctl>
}
 d017ab0:	e037883a 	mov	sp,fp
 d017ab4:	dfc00117 	ldw	ra,4(sp)
 d017ab8:	df000017 	ldw	fp,0(sp)
 d017abc:	dec00204 	addi	sp,sp,8
 d017ac0:	f800283a 	ret

0d017ac4 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 d017ac4:	defff404 	addi	sp,sp,-48
 d017ac8:	dfc00b15 	stw	ra,44(sp)
 d017acc:	df000a15 	stw	fp,40(sp)
 d017ad0:	df000a04 	addi	fp,sp,40
 d017ad4:	e13ffd15 	stw	r4,-12(fp)
 d017ad8:	e17ffe15 	stw	r5,-8(fp)
 d017adc:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 d017ae0:	e0bffd17 	ldw	r2,-12(fp)
 d017ae4:	10800c04 	addi	r2,r2,48
 d017ae8:	e0bffb15 	stw	r2,-20(fp)
 d017aec:	e03ffc0d 	sth	zero,-16(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 d017af0:	e13ffc0b 	ldhu	r4,-16(fp)
 d017af4:	e17ffc84 	addi	r5,fp,-14
 d017af8:	d00fc9c0 	call	d00fc9c <OSFlagCreate>
 d017afc:	1007883a 	mov	r3,r2
 d017b00:	e0bffb17 	ldw	r2,-20(fp)
 d017b04:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 d017b08:	e0bffd17 	ldw	r2,-12(fp)
 d017b0c:	10800a04 	addi	r2,r2,40
 d017b10:	e0bff915 	stw	r2,-28(fp)
 d017b14:	00800044 	movi	r2,1
 d017b18:	e0bffa0d 	sth	r2,-24(fp)
 d017b1c:	e13ffa0b 	ldhu	r4,-24(fp)
 d017b20:	d012ea00 	call	d012ea0 <OSSemCreate>
 d017b24:	1007883a 	mov	r3,r2
 d017b28:	e0bff917 	ldw	r2,-28(fp)
 d017b2c:	10c00015 	stw	r3,0(r2)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 d017b30:	e0bffd17 	ldw	r2,-12(fp)
 d017b34:	10800b04 	addi	r2,r2,44
 d017b38:	e0bff715 	stw	r2,-36(fp)
 d017b3c:	00800044 	movi	r2,1
 d017b40:	e0bff80d 	sth	r2,-32(fp)
 d017b44:	e13ff80b 	ldhu	r4,-32(fp)
 d017b48:	d012ea00 	call	d012ea0 <OSSemCreate>
 d017b4c:	1007883a 	mov	r3,r2
 d017b50:	e0bff717 	ldw	r2,-36(fp)
 d017b54:	10c00015 	stw	r3,0(r2)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 d017b58:	e0fffd17 	ldw	r3,-12(fp)
 d017b5c:	00800044 	movi	r2,1
 d017b60:	18800815 	stw	r2,32(r3)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 d017b64:	e0bffd17 	ldw	r2,-12(fp)
 d017b68:	10800017 	ldw	r2,0(r2)
 d017b6c:	11000104 	addi	r4,r2,4
 d017b70:	e0bffd17 	ldw	r2,-12(fp)
 d017b74:	10800817 	ldw	r2,32(r2)
 d017b78:	1007883a 	mov	r3,r2
 d017b7c:	2005883a 	mov	r2,r4
 d017b80:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 d017b84:	e13ffe17 	ldw	r4,-8(fp)
 d017b88:	e17fff17 	ldw	r5,-4(fp)
 d017b8c:	d8000015 	stw	zero,0(sp)
 d017b90:	01834074 	movhi	r6,3329
 d017b94:	319eff04 	addi	r6,r6,31740
 d017b98:	e1fffd17 	ldw	r7,-12(fp)
 d017b9c:	d038da00 	call	d038da0 <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 d017ba0:	e0bffd17 	ldw	r2,-12(fp)
 d017ba4:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 d017ba8:	e0bffd17 	ldw	r2,-12(fp)
 d017bac:	11000204 	addi	r4,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 d017bb0:	00834174 	movhi	r2,3333
 d017bb4:	108ad904 	addi	r2,r2,11108
 d017bb8:	10800017 	ldw	r2,0(r2)
 d017bbc:	100b883a 	mov	r5,r2
 d017bc0:	01834074 	movhi	r6,3329
 d017bc4:	319fb004 	addi	r6,r6,32448
 d017bc8:	e1fffd17 	ldw	r7,-12(fp)
 d017bcc:	d0387dc0 	call	d0387dc <alt_alarm_start>
 d017bd0:	1004403a 	cmpge	r2,r2,zero
 d017bd4:	1000041e 	bne	r2,zero,d017be8 <altera_avalon_jtag_uart_init+0x124>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 d017bd8:	e0fffd17 	ldw	r3,-12(fp)
 d017bdc:	00a00034 	movhi	r2,32768
 d017be0:	10bfffc4 	addi	r2,r2,-1
 d017be4:	18800115 	stw	r2,4(r3)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 d017be8:	e037883a 	mov	sp,fp
 d017bec:	dfc00117 	ldw	ra,4(sp)
 d017bf0:	df000017 	ldw	fp,0(sp)
 d017bf4:	dec00204 	addi	sp,sp,8
 d017bf8:	f800283a 	ret

0d017bfc <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 d017bfc:	defff204 	addi	sp,sp,-56
 d017c00:	dfc00d15 	stw	ra,52(sp)
 d017c04:	df000c15 	stw	fp,48(sp)
 d017c08:	df000c04 	addi	fp,sp,48
 d017c0c:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 d017c10:	e0bfff17 	ldw	r2,-4(fp)
 d017c14:	e0bffd15 	stw	r2,-12(fp)
  unsigned int base = sp->base;
 d017c18:	e0bffd17 	ldw	r2,-12(fp)
 d017c1c:	10800017 	ldw	r2,0(r2)
 d017c20:	e0bffc15 	stw	r2,-16(fp)
 d017c24:	00000006 	br	d017c28 <altera_avalon_jtag_uart_irq+0x2c>
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 d017c28:	e0bffc17 	ldw	r2,-16(fp)
 d017c2c:	10800104 	addi	r2,r2,4
 d017c30:	10800037 	ldwio	r2,0(r2)
 d017c34:	e0bffb15 	stw	r2,-20(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 d017c38:	e0bffb17 	ldw	r2,-20(fp)
 d017c3c:	1080c00c 	andi	r2,r2,768
 d017c40:	1005003a 	cmpeq	r2,r2,zero
 d017c44:	1000991e 	bne	r2,zero,d017eac <altera_avalon_jtag_uart_irq+0x2b0>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 d017c48:	e0bffb17 	ldw	r2,-20(fp)
 d017c4c:	1080400c 	andi	r2,r2,256
 d017c50:	1005003a 	cmpeq	r2,r2,zero
 d017c54:	1000481e 	bne	r2,zero,d017d78 <altera_avalon_jtag_uart_irq+0x17c>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 d017c58:	00800074 	movhi	r2,1
 d017c5c:	e0bffa15 	stw	r2,-24(fp)
 d017c60:	00000006 	br	d017c64 <altera_avalon_jtag_uart_irq+0x68>
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d017c64:	e0bffd17 	ldw	r2,-12(fp)
 d017c68:	10800d17 	ldw	r2,52(r2)
 d017c6c:	10800044 	addi	r2,r2,1
 d017c70:	1081ffcc 	andi	r2,r2,2047
 d017c74:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 d017c78:	e0bffd17 	ldw	r2,-12(fp)
 d017c7c:	10c00e17 	ldw	r3,56(r2)
 d017c80:	e0bff917 	ldw	r2,-28(fp)
 d017c84:	18802826 	beq	r3,r2,d017d28 <altera_avalon_jtag_uart_irq+0x12c>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 d017c88:	e0bffc17 	ldw	r2,-16(fp)
 d017c8c:	10800037 	ldwio	r2,0(r2)
 d017c90:	e0bffa15 	stw	r2,-24(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 d017c94:	e0bffa17 	ldw	r2,-24(fp)
 d017c98:	10a0000c 	andi	r2,r2,32768
 d017c9c:	1005003a 	cmpeq	r2,r2,zero
 d017ca0:	1000211e 	bne	r2,zero,d017d28 <altera_avalon_jtag_uart_irq+0x12c>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 d017ca4:	e0bffd17 	ldw	r2,-12(fp)
 d017ca8:	10c00d17 	ldw	r3,52(r2)
 d017cac:	e0bffa17 	ldw	r2,-24(fp)
 d017cb0:	1009883a 	mov	r4,r2
 d017cb4:	e0bffd17 	ldw	r2,-12(fp)
 d017cb8:	1885883a 	add	r2,r3,r2
 d017cbc:	10801104 	addi	r2,r2,68
 d017cc0:	11000005 	stb	r4,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d017cc4:	e0bffd17 	ldw	r2,-12(fp)
 d017cc8:	10800d17 	ldw	r2,52(r2)
 d017ccc:	10800044 	addi	r2,r2,1
 d017cd0:	10c1ffcc 	andi	r3,r2,2047
 d017cd4:	e0bffd17 	ldw	r2,-12(fp)
 d017cd8:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 d017cdc:	e0bffd17 	ldw	r2,-12(fp)
 d017ce0:	10800c17 	ldw	r2,48(r2)
 d017ce4:	e0bff615 	stw	r2,-40(fp)
 d017ce8:	00800044 	movi	r2,1
 d017cec:	e0bff70d 	sth	r2,-36(fp)
 d017cf0:	00800044 	movi	r2,1
 d017cf4:	e0bff785 	stb	r2,-34(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 d017cf8:	00834174 	movhi	r2,3333
 d017cfc:	108a8c44 	addi	r2,r2,10801
 d017d00:	10800003 	ldbu	r2,0(r2)
 d017d04:	10803fcc 	andi	r2,r2,255
 d017d08:	1005003a 	cmpeq	r2,r2,zero
 d017d0c:	103fd51e 	bne	r2,zero,d017c64 <altera_avalon_jtag_uart_irq+0x68>
  {
    OSFlagPost (group, flags, opt, &err);
 d017d10:	e17ff70b 	ldhu	r5,-36(fp)
 d017d14:	e1bff783 	ldbu	r6,-34(fp)
 d017d18:	e1fffe04 	addi	r7,fp,-8
 d017d1c:	e13ff617 	ldw	r4,-40(fp)
 d017d20:	d0109c40 	call	d0109c4 <OSFlagPost>
    return err;
 d017d24:	003fcf06 	br	d017c64 <altera_avalon_jtag_uart_irq+0x68>
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 d017d28:	e0bffa17 	ldw	r2,-24(fp)
 d017d2c:	10bfffec 	andhi	r2,r2,65535
 d017d30:	1005003a 	cmpeq	r2,r2,zero
 d017d34:	1000101e 	bne	r2,zero,d017d78 <altera_avalon_jtag_uart_irq+0x17c>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 d017d38:	e0bffd17 	ldw	r2,-12(fp)
 d017d3c:	10c00817 	ldw	r3,32(r2)
 d017d40:	00bfff84 	movi	r2,-2
 d017d44:	1886703a 	and	r3,r3,r2
 d017d48:	e0bffd17 	ldw	r2,-12(fp)
 d017d4c:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 d017d50:	e0bffc17 	ldw	r2,-16(fp)
 d017d54:	11000104 	addi	r4,r2,4
 d017d58:	e0bffd17 	ldw	r2,-12(fp)
 d017d5c:	10800817 	ldw	r2,32(r2)
 d017d60:	1007883a 	mov	r3,r2
 d017d64:	2005883a 	mov	r2,r4
 d017d68:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 d017d6c:	e0bffc17 	ldw	r2,-16(fp)
 d017d70:	10800104 	addi	r2,r2,4
 d017d74:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 d017d78:	e0bffb17 	ldw	r2,-20(fp)
 d017d7c:	1080800c 	andi	r2,r2,512
 d017d80:	1005003a 	cmpeq	r2,r2,zero
 d017d84:	103fa81e 	bne	r2,zero,d017c28 <altera_avalon_jtag_uart_irq+0x2c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 d017d88:	e0bffb17 	ldw	r2,-20(fp)
 d017d8c:	10bfffec 	andhi	r2,r2,65535
 d017d90:	1004d43a 	srli	r2,r2,16
 d017d94:	e0bff815 	stw	r2,-32(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 d017d98:	00002706 	br	d017e38 <altera_avalon_jtag_uart_irq+0x23c>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 d017d9c:	e13ffc17 	ldw	r4,-16(fp)
 d017da0:	e0bffd17 	ldw	r2,-12(fp)
 d017da4:	10c01017 	ldw	r3,64(r2)
 d017da8:	e0bffd17 	ldw	r2,-12(fp)
 d017dac:	1885883a 	add	r2,r3,r2
 d017db0:	10821104 	addi	r2,r2,2116
 d017db4:	10800003 	ldbu	r2,0(r2)
 d017db8:	10c03fcc 	andi	r3,r2,255
 d017dbc:	18c0201c 	xori	r3,r3,128
 d017dc0:	18ffe004 	addi	r3,r3,-128
 d017dc4:	2005883a 	mov	r2,r4
 d017dc8:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d017dcc:	e0bffd17 	ldw	r2,-12(fp)
 d017dd0:	10801017 	ldw	r2,64(r2)
 d017dd4:	10800044 	addi	r2,r2,1
 d017dd8:	10c1ffcc 	andi	r3,r2,2047
 d017ddc:	e0bffd17 	ldw	r2,-12(fp)
 d017de0:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 d017de4:	e0bffd17 	ldw	r2,-12(fp)
 d017de8:	10800c17 	ldw	r2,48(r2)
 d017dec:	e0bff415 	stw	r2,-48(fp)
 d017df0:	00800084 	movi	r2,2
 d017df4:	e0bff50d 	sth	r2,-44(fp)
 d017df8:	00800044 	movi	r2,1
 d017dfc:	e0bff585 	stb	r2,-42(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 d017e00:	00834174 	movhi	r2,3333
 d017e04:	108a8c44 	addi	r2,r2,10801
 d017e08:	10800003 	ldbu	r2,0(r2)
 d017e0c:	10803fcc 	andi	r2,r2,255
 d017e10:	1005003a 	cmpeq	r2,r2,zero
 d017e14:	1000051e 	bne	r2,zero,d017e2c <altera_avalon_jtag_uart_irq+0x230>
  {
    OSFlagPost (group, flags, opt, &err);
 d017e18:	e17ff50b 	ldhu	r5,-44(fp)
 d017e1c:	e1bff583 	ldbu	r6,-42(fp)
 d017e20:	e1fffe44 	addi	r7,fp,-7
 d017e24:	e13ff417 	ldw	r4,-48(fp)
 d017e28:	d0109c40 	call	d0109c4 <OSFlagPost>

        space--;
 d017e2c:	e0bff817 	ldw	r2,-32(fp)
 d017e30:	10bfffc4 	addi	r2,r2,-1
 d017e34:	e0bff815 	stw	r2,-32(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 d017e38:	e0bff817 	ldw	r2,-32(fp)
 d017e3c:	1005003a 	cmpeq	r2,r2,zero
 d017e40:	1000051e 	bne	r2,zero,d017e58 <altera_avalon_jtag_uart_irq+0x25c>
 d017e44:	e0bffd17 	ldw	r2,-12(fp)
 d017e48:	10c01017 	ldw	r3,64(r2)
 d017e4c:	e0bffd17 	ldw	r2,-12(fp)
 d017e50:	10800f17 	ldw	r2,60(r2)
 d017e54:	18bfd11e 	bne	r3,r2,d017d9c <altera_avalon_jtag_uart_irq+0x1a0>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 d017e58:	e0bff817 	ldw	r2,-32(fp)
 d017e5c:	1005003a 	cmpeq	r2,r2,zero
 d017e60:	103f711e 	bne	r2,zero,d017c28 <altera_avalon_jtag_uart_irq+0x2c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 d017e64:	e0bffd17 	ldw	r2,-12(fp)
 d017e68:	10c00817 	ldw	r3,32(r2)
 d017e6c:	00bfff44 	movi	r2,-3
 d017e70:	1886703a 	and	r3,r3,r2
 d017e74:	e0bffd17 	ldw	r2,-12(fp)
 d017e78:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 d017e7c:	e0bffd17 	ldw	r2,-12(fp)
 d017e80:	10800017 	ldw	r2,0(r2)
 d017e84:	11000104 	addi	r4,r2,4
 d017e88:	e0bffd17 	ldw	r2,-12(fp)
 d017e8c:	10800817 	ldw	r2,32(r2)
 d017e90:	1007883a 	mov	r3,r2
 d017e94:	2005883a 	mov	r2,r4
 d017e98:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 d017e9c:	e0bffc17 	ldw	r2,-16(fp)
 d017ea0:	10800104 	addi	r2,r2,4
 d017ea4:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 d017ea8:	003f5f06 	br	d017c28 <altera_avalon_jtag_uart_irq+0x2c>
}
 d017eac:	e037883a 	mov	sp,fp
 d017eb0:	dfc00117 	ldw	ra,4(sp)
 d017eb4:	df000017 	ldw	fp,0(sp)
 d017eb8:	dec00204 	addi	sp,sp,8
 d017ebc:	f800283a 	ret

0d017ec0 <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 d017ec0:	defff804 	addi	sp,sp,-32
 d017ec4:	dfc00715 	stw	ra,28(sp)
 d017ec8:	df000615 	stw	fp,24(sp)
 d017ecc:	df000604 	addi	fp,sp,24
 d017ed0:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 d017ed4:	e0bfff17 	ldw	r2,-4(fp)
 d017ed8:	e0bffd15 	stw	r2,-12(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 d017edc:	e0bffd17 	ldw	r2,-12(fp)
 d017ee0:	10800017 	ldw	r2,0(r2)
 d017ee4:	10800104 	addi	r2,r2,4
 d017ee8:	10800037 	ldwio	r2,0(r2)
 d017eec:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 d017ef0:	e0bffc17 	ldw	r2,-16(fp)
 d017ef4:	1081000c 	andi	r2,r2,1024
 d017ef8:	1005003a 	cmpeq	r2,r2,zero
 d017efc:	10000c1e 	bne	r2,zero,d017f30 <altera_avalon_jtag_uart_timeout+0x70>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 d017f00:	e0bffd17 	ldw	r2,-12(fp)
 d017f04:	10800017 	ldw	r2,0(r2)
 d017f08:	11000104 	addi	r4,r2,4
 d017f0c:	e0bffd17 	ldw	r2,-12(fp)
 d017f10:	10800817 	ldw	r2,32(r2)
 d017f14:	10810014 	ori	r2,r2,1024
 d017f18:	1007883a 	mov	r3,r2
 d017f1c:	2005883a 	mov	r2,r4
 d017f20:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 d017f24:	e0bffd17 	ldw	r2,-12(fp)
 d017f28:	10000915 	stw	zero,36(r2)
 d017f2c:	00002106 	br	d017fb4 <altera_avalon_jtag_uart_timeout+0xf4>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 d017f30:	e0bffd17 	ldw	r2,-12(fp)
 d017f34:	10c00917 	ldw	r3,36(r2)
 d017f38:	00a00034 	movhi	r2,32768
 d017f3c:	10bfff04 	addi	r2,r2,-4
 d017f40:	10c01c36 	bltu	r2,r3,d017fb4 <altera_avalon_jtag_uart_timeout+0xf4>
    sp->host_inactive++;
 d017f44:	e0bffd17 	ldw	r2,-12(fp)
 d017f48:	10800917 	ldw	r2,36(r2)
 d017f4c:	10c00044 	addi	r3,r2,1
 d017f50:	e0bffd17 	ldw	r2,-12(fp)
 d017f54:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 d017f58:	e0bffd17 	ldw	r2,-12(fp)
 d017f5c:	10c00917 	ldw	r3,36(r2)
 d017f60:	e0bffd17 	ldw	r2,-12(fp)
 d017f64:	10800117 	ldw	r2,4(r2)
 d017f68:	18801236 	bltu	r3,r2,d017fb4 <altera_avalon_jtag_uart_timeout+0xf4>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 d017f6c:	e0bffd17 	ldw	r2,-12(fp)
 d017f70:	10800c17 	ldw	r2,48(r2)
 d017f74:	e0bffa15 	stw	r2,-24(fp)
 d017f78:	00800104 	movi	r2,4
 d017f7c:	e0bffb0d 	sth	r2,-20(fp)
 d017f80:	00800044 	movi	r2,1
 d017f84:	e0bffb85 	stb	r2,-18(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 d017f88:	00834174 	movhi	r2,3333
 d017f8c:	108a8c44 	addi	r2,r2,10801
 d017f90:	10800003 	ldbu	r2,0(r2)
 d017f94:	10803fcc 	andi	r2,r2,255
 d017f98:	1005003a 	cmpeq	r2,r2,zero
 d017f9c:	1000051e 	bne	r2,zero,d017fb4 <altera_avalon_jtag_uart_timeout+0xf4>
  {
    OSFlagPost (group, flags, opt, &err);
 d017fa0:	e17ffb0b 	ldhu	r5,-20(fp)
 d017fa4:	e1bffb83 	ldbu	r6,-18(fp)
 d017fa8:	e1fffe04 	addi	r7,fp,-8
 d017fac:	e13ffa17 	ldw	r4,-24(fp)
 d017fb0:	d0109c40 	call	d0109c4 <OSFlagPost>
 d017fb4:	00834174 	movhi	r2,3333
 d017fb8:	108ad904 	addi	r2,r2,11108
 d017fbc:	10800017 	ldw	r2,0(r2)
    }
  }

  return alt_ticks_per_second();
}
 d017fc0:	e037883a 	mov	sp,fp
 d017fc4:	dfc00117 	ldw	ra,4(sp)
 d017fc8:	df000017 	ldw	fp,0(sp)
 d017fcc:	dec00204 	addi	sp,sp,8
 d017fd0:	f800283a 	ret

0d017fd4 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 d017fd4:	defffc04 	addi	sp,sp,-16
 d017fd8:	df000315 	stw	fp,12(sp)
 d017fdc:	df000304 	addi	fp,sp,12
 d017fe0:	e13ffd15 	stw	r4,-12(fp)
 d017fe4:	e17ffe15 	stw	r5,-8(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 d017fe8:	00000706 	br	d018008 <altera_avalon_jtag_uart_close+0x34>
    if (flags & O_NONBLOCK) {
 d017fec:	e0bffe17 	ldw	r2,-8(fp)
 d017ff0:	1090000c 	andi	r2,r2,16384
 d017ff4:	1005003a 	cmpeq	r2,r2,zero
 d017ff8:	1000031e 	bne	r2,zero,d018008 <altera_avalon_jtag_uart_close+0x34>
      return -EWOULDBLOCK; 
 d017ffc:	00bffd44 	movi	r2,-11
 d018000:	e0bfff15 	stw	r2,-4(fp)
 d018004:	00000b06 	br	d018034 <altera_avalon_jtag_uart_close+0x60>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 d018008:	e0bffd17 	ldw	r2,-12(fp)
 d01800c:	10c01017 	ldw	r3,64(r2)
 d018010:	e0bffd17 	ldw	r2,-12(fp)
 d018014:	10800f17 	ldw	r2,60(r2)
 d018018:	18800526 	beq	r3,r2,d018030 <altera_avalon_jtag_uart_close+0x5c>
 d01801c:	e0bffd17 	ldw	r2,-12(fp)
 d018020:	10c00917 	ldw	r3,36(r2)
 d018024:	e0bffd17 	ldw	r2,-12(fp)
 d018028:	10800117 	ldw	r2,4(r2)
 d01802c:	18bfef36 	bltu	r3,r2,d017fec <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 d018030:	e03fff15 	stw	zero,-4(fp)
 d018034:	e0bfff17 	ldw	r2,-4(fp)
}
 d018038:	e037883a 	mov	sp,fp
 d01803c:	df000017 	ldw	fp,0(sp)
 d018040:	dec00104 	addi	sp,sp,4
 d018044:	f800283a 	ret

0d018048 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 d018048:	defff804 	addi	sp,sp,-32
 d01804c:	df000715 	stw	fp,28(sp)
 d018050:	df000704 	addi	fp,sp,28
 d018054:	e13ffb15 	stw	r4,-20(fp)
 d018058:	e17ffc15 	stw	r5,-16(fp)
 d01805c:	e1bffd15 	stw	r6,-12(fp)
  int rc = -ENOTTY;
 d018060:	00bff9c4 	movi	r2,-25
 d018064:	e0bffa15 	stw	r2,-24(fp)

  switch (req)
 d018068:	e0bffc17 	ldw	r2,-16(fp)
 d01806c:	e0bfff15 	stw	r2,-4(fp)
 d018070:	e0ffff17 	ldw	r3,-4(fp)
 d018074:	189a8060 	cmpeqi	r2,r3,27137
 d018078:	1000041e 	bne	r2,zero,d01808c <altera_avalon_jtag_uart_ioctl+0x44>
 d01807c:	e0ffff17 	ldw	r3,-4(fp)
 d018080:	189a80a0 	cmpeqi	r2,r3,27138
 d018084:	10001b1e 	bne	r2,zero,d0180f4 <altera_avalon_jtag_uart_ioctl+0xac>
 d018088:	00002706 	br	d018128 <altera_avalon_jtag_uart_ioctl+0xe0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 d01808c:	e0bffb17 	ldw	r2,-20(fp)
 d018090:	10c00117 	ldw	r3,4(r2)
 d018094:	00a00034 	movhi	r2,32768
 d018098:	10bfffc4 	addi	r2,r2,-1
 d01809c:	18802226 	beq	r3,r2,d018128 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
 d0180a0:	e0bffd17 	ldw	r2,-12(fp)
 d0180a4:	10800017 	ldw	r2,0(r2)
 d0180a8:	e0bff915 	stw	r2,-28(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 d0180ac:	e0bff917 	ldw	r2,-28(fp)
 d0180b0:	10800090 	cmplti	r2,r2,2
 d0180b4:	1000071e 	bne	r2,zero,d0180d4 <altera_avalon_jtag_uart_ioctl+0x8c>
 d0180b8:	e0fff917 	ldw	r3,-28(fp)
 d0180bc:	00a00034 	movhi	r2,32768
 d0180c0:	10bfffc4 	addi	r2,r2,-1
 d0180c4:	18800326 	beq	r3,r2,d0180d4 <altera_avalon_jtag_uart_ioctl+0x8c>
 d0180c8:	e0bff917 	ldw	r2,-28(fp)
 d0180cc:	e0bffe15 	stw	r2,-8(fp)
 d0180d0:	00000306 	br	d0180e0 <altera_avalon_jtag_uart_ioctl+0x98>
 d0180d4:	00e00034 	movhi	r3,32768
 d0180d8:	18ffff84 	addi	r3,r3,-2
 d0180dc:	e0fffe15 	stw	r3,-8(fp)
 d0180e0:	e0bffb17 	ldw	r2,-20(fp)
 d0180e4:	e0fffe17 	ldw	r3,-8(fp)
 d0180e8:	10c00115 	stw	r3,4(r2)
      rc = 0;
 d0180ec:	e03ffa15 	stw	zero,-24(fp)
    }
    break;
 d0180f0:	00000d06 	br	d018128 <altera_avalon_jtag_uart_ioctl+0xe0>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 d0180f4:	e0bffb17 	ldw	r2,-20(fp)
 d0180f8:	10c00117 	ldw	r3,4(r2)
 d0180fc:	00a00034 	movhi	r2,32768
 d018100:	10bfffc4 	addi	r2,r2,-1
 d018104:	18800826 	beq	r3,r2,d018128 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 d018108:	e13ffd17 	ldw	r4,-12(fp)
 d01810c:	e0bffb17 	ldw	r2,-20(fp)
 d018110:	10c00917 	ldw	r3,36(r2)
 d018114:	e0bffb17 	ldw	r2,-20(fp)
 d018118:	10800117 	ldw	r2,4(r2)
 d01811c:	1885803a 	cmpltu	r2,r3,r2
 d018120:	20800015 	stw	r2,0(r4)
      rc = 0;
 d018124:	e03ffa15 	stw	zero,-24(fp)

  default:
    break;
  }

  return rc;
 d018128:	e0bffa17 	ldw	r2,-24(fp)
}
 d01812c:	e037883a 	mov	sp,fp
 d018130:	df000017 	ldw	fp,0(sp)
 d018134:	dec00104 	addi	sp,sp,4
 d018138:	f800283a 	ret

0d01813c <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 d01813c:	deffeb04 	addi	sp,sp,-84
 d018140:	dfc01415 	stw	ra,80(sp)
 d018144:	df001315 	stw	fp,76(sp)
 d018148:	df001304 	addi	fp,sp,76
 d01814c:	e13ffb15 	stw	r4,-20(fp)
 d018150:	e17ffc15 	stw	r5,-16(fp)
 d018154:	e1bffd15 	stw	r6,-12(fp)
 d018158:	e1fffe15 	stw	r7,-8(fp)
  char * ptr = buffer;
 d01815c:	e0bffc17 	ldw	r2,-16(fp)
 d018160:	e0bff915 	stw	r2,-28(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 d018164:	e0bffb17 	ldw	r2,-20(fp)
 d018168:	10800a17 	ldw	r2,40(r2)
 d01816c:	e0bff315 	stw	r2,-52(fp)
 d018170:	e03ff40d 	sth	zero,-48(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 d018174:	e17ff40b 	ldhu	r5,-48(fp)
 d018178:	e1bffa44 	addi	r6,fp,-23
 d01817c:	e13ff317 	ldw	r4,-52(fp)
 d018180:	d0132540 	call	d013254 <OSSemPend>

  while (space > 0)
 d018184:	00006406 	br	d018318 <altera_avalon_jtag_uart_read+0x1dc>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 d018188:	e0bffb17 	ldw	r2,-20(fp)
 d01818c:	10800d17 	ldw	r2,52(r2)
 d018190:	e0bff615 	stw	r2,-40(fp)
      out = sp->rx_out;
 d018194:	e0bffb17 	ldw	r2,-20(fp)
 d018198:	10800e17 	ldw	r2,56(r2)
 d01819c:	e0bff515 	stw	r2,-44(fp)

      if (in >= out)
 d0181a0:	e0fff617 	ldw	r3,-40(fp)
 d0181a4:	e0bff517 	ldw	r2,-44(fp)
 d0181a8:	18800536 	bltu	r3,r2,d0181c0 <altera_avalon_jtag_uart_read+0x84>
        n = in - out;
 d0181ac:	e0bff617 	ldw	r2,-40(fp)
 d0181b0:	e0fff517 	ldw	r3,-44(fp)
 d0181b4:	10c5c83a 	sub	r2,r2,r3
 d0181b8:	e0bff715 	stw	r2,-36(fp)
 d0181bc:	00000406 	br	d0181d0 <altera_avalon_jtag_uart_read+0x94>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 d0181c0:	00820004 	movi	r2,2048
 d0181c4:	e0fff517 	ldw	r3,-44(fp)
 d0181c8:	10c5c83a 	sub	r2,r2,r3
 d0181cc:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 d0181d0:	e0bff717 	ldw	r2,-36(fp)
 d0181d4:	1005003a 	cmpeq	r2,r2,zero
 d0181d8:	10001f1e 	bne	r2,zero,d018258 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 d0181dc:	e0fffd17 	ldw	r3,-12(fp)
 d0181e0:	e0bff717 	ldw	r2,-36(fp)
 d0181e4:	1880022e 	bgeu	r3,r2,d0181f0 <altera_avalon_jtag_uart_read+0xb4>
        n = space;
 d0181e8:	e0bffd17 	ldw	r2,-12(fp)
 d0181ec:	e0bff715 	stw	r2,-36(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 d0181f0:	e0bffb17 	ldw	r2,-20(fp)
 d0181f4:	10c01104 	addi	r3,r2,68
 d0181f8:	e0bff517 	ldw	r2,-44(fp)
 d0181fc:	1887883a 	add	r3,r3,r2
 d018200:	e0bff917 	ldw	r2,-28(fp)
 d018204:	1009883a 	mov	r4,r2
 d018208:	180b883a 	mov	r5,r3
 d01820c:	e1bff717 	ldw	r6,-36(fp)
 d018210:	d0027000 	call	d002700 <memcpy>
      ptr   += n;
 d018214:	e0fff717 	ldw	r3,-36(fp)
 d018218:	e0bff917 	ldw	r2,-28(fp)
 d01821c:	10c5883a 	add	r2,r2,r3
 d018220:	e0bff915 	stw	r2,-28(fp)
      space -= n;
 d018224:	e0fffd17 	ldw	r3,-12(fp)
 d018228:	e0bff717 	ldw	r2,-36(fp)
 d01822c:	1885c83a 	sub	r2,r3,r2
 d018230:	e0bffd15 	stw	r2,-12(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d018234:	e0fff517 	ldw	r3,-44(fp)
 d018238:	e0bff717 	ldw	r2,-36(fp)
 d01823c:	1885883a 	add	r2,r3,r2
 d018240:	10c1ffcc 	andi	r3,r2,2047
 d018244:	e0bffb17 	ldw	r2,-20(fp)
 d018248:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 d01824c:	e0bffd17 	ldw	r2,-12(fp)
 d018250:	10800048 	cmpgei	r2,r2,1
 d018254:	103fcc1e 	bne	r2,zero,d018188 <altera_avalon_jtag_uart_read+0x4c>

    /* If we read any data then return it */
    if (ptr != buffer)
 d018258:	e0fff917 	ldw	r3,-28(fp)
 d01825c:	e0bffc17 	ldw	r2,-16(fp)
 d018260:	1880301e 	bne	r3,r2,d018324 <altera_avalon_jtag_uart_read+0x1e8>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 d018264:	e0bffe17 	ldw	r2,-8(fp)
 d018268:	1090000c 	andi	r2,r2,16384
 d01826c:	1004c03a 	cmpne	r2,r2,zero
 d018270:	10002c1e 	bne	r2,zero,d018324 <altera_avalon_jtag_uart_read+0x1e8>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 d018274:	00834174 	movhi	r2,3333
 d018278:	108a8c44 	addi	r2,r2,10801
 d01827c:	10800003 	ldbu	r2,0(r2)
 d018280:	10803fcc 	andi	r2,r2,255
 d018284:	10800058 	cmpnei	r2,r2,1
 d018288:	1000161e 	bne	r2,zero,d0182e4 <altera_avalon_jtag_uart_read+0x1a8>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 d01828c:	e0bffb17 	ldw	r2,-20(fp)
 d018290:	10800c17 	ldw	r2,48(r2)
 d018294:	e0bff015 	stw	r2,-64(fp)
 d018298:	00800144 	movi	r2,5
 d01829c:	e0bff10d 	sth	r2,-60(fp)
 d0182a0:	00bfe0c4 	movi	r2,-125
 d0182a4:	e0bff185 	stb	r2,-58(fp)
 d0182a8:	e03ff20d 	sth	zero,-56(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 d0182ac:	00834174 	movhi	r2,3333
 d0182b0:	108a8c44 	addi	r2,r2,10801
 d0182b4:	10800003 	ldbu	r2,0(r2)
 d0182b8:	10803fcc 	andi	r2,r2,255
 d0182bc:	1005003a 	cmpeq	r2,r2,zero
 d0182c0:	1000111e 	bne	r2,zero,d018308 <altera_avalon_jtag_uart_read+0x1cc>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 d0182c4:	e17ff10b 	ldhu	r5,-60(fp)
 d0182c8:	e1bff183 	ldbu	r6,-58(fp)
 d0182cc:	e1fff20b 	ldhu	r7,-56(fp)
 d0182d0:	e0bffa04 	addi	r2,fp,-24
 d0182d4:	d8800015 	stw	r2,0(sp)
 d0182d8:	e13ff017 	ldw	r4,-64(fp)
 d0182dc:	d0103180 	call	d010318 <OSFlagPend>
    return err;
 d0182e0:	00000906 	br	d018308 <altera_avalon_jtag_uart_read+0x1cc>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 d0182e4:	e0bffb17 	ldw	r2,-20(fp)
 d0182e8:	10c00d17 	ldw	r3,52(r2)
 d0182ec:	e0bff617 	ldw	r2,-40(fp)
 d0182f0:	1880051e 	bne	r3,r2,d018308 <altera_avalon_jtag_uart_read+0x1cc>
 d0182f4:	e0bffb17 	ldw	r2,-20(fp)
 d0182f8:	10c00917 	ldw	r3,36(r2)
 d0182fc:	e0bffb17 	ldw	r2,-20(fp)
 d018300:	10800117 	ldw	r2,4(r2)
 d018304:	18bff736 	bltu	r3,r2,d0182e4 <altera_avalon_jtag_uart_read+0x1a8>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 d018308:	e0bffb17 	ldw	r2,-20(fp)
 d01830c:	10c00d17 	ldw	r3,52(r2)
 d018310:	e0bff617 	ldw	r2,-40(fp)
 d018314:	18800326 	beq	r3,r2,d018324 <altera_avalon_jtag_uart_read+0x1e8>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 d018318:	e0bffd17 	ldw	r2,-12(fp)
 d01831c:	10800048 	cmpgei	r2,r2,1
 d018320:	103f991e 	bne	r2,zero,d018188 <altera_avalon_jtag_uart_read+0x4c>
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 d018324:	e0bffb17 	ldw	r2,-20(fp)
 d018328:	11000a17 	ldw	r4,40(r2)
 d01832c:	d01364c0 	call	d01364c <OSSemPost>

  if (ptr != buffer)
 d018330:	e0fff917 	ldw	r3,-28(fp)
 d018334:	e0bffc17 	ldw	r2,-16(fp)
 d018338:	18801926 	beq	r3,r2,d0183a0 <altera_avalon_jtag_uart_read+0x264>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01833c:	0005303a 	rdctl	r2,status
 d018340:	e0bfef15 	stw	r2,-68(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d018344:	e0ffef17 	ldw	r3,-68(fp)
 d018348:	00bfff84 	movi	r2,-2
 d01834c:	1884703a 	and	r2,r3,r2
 d018350:	1001703a 	wrctl	status,r2
  
  return context;
 d018354:	e0bfef17 	ldw	r2,-68(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 d018358:	e0bff815 	stw	r2,-32(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 d01835c:	e0bffb17 	ldw	r2,-20(fp)
 d018360:	10800817 	ldw	r2,32(r2)
 d018364:	10c00054 	ori	r3,r2,1
 d018368:	e0bffb17 	ldw	r2,-20(fp)
 d01836c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 d018370:	e0bffb17 	ldw	r2,-20(fp)
 d018374:	10800017 	ldw	r2,0(r2)
 d018378:	11000104 	addi	r4,r2,4
 d01837c:	e0bffb17 	ldw	r2,-20(fp)
 d018380:	10800817 	ldw	r2,32(r2)
 d018384:	1007883a 	mov	r3,r2
 d018388:	2005883a 	mov	r2,r4
 d01838c:	10c00035 	stwio	r3,0(r2)
 d018390:	e0bff817 	ldw	r2,-32(fp)
 d018394:	e0bfee15 	stw	r2,-72(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d018398:	e0bfee17 	ldw	r2,-72(fp)
 d01839c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 d0183a0:	e0fff917 	ldw	r3,-28(fp)
 d0183a4:	e0bffc17 	ldw	r2,-16(fp)
 d0183a8:	18800526 	beq	r3,r2,d0183c0 <altera_avalon_jtag_uart_read+0x284>
    return ptr - buffer;
 d0183ac:	e0fff917 	ldw	r3,-28(fp)
 d0183b0:	e0bffc17 	ldw	r2,-16(fp)
 d0183b4:	1887c83a 	sub	r3,r3,r2
 d0183b8:	e0ffff15 	stw	r3,-4(fp)
 d0183bc:	00000906 	br	d0183e4 <altera_avalon_jtag_uart_read+0x2a8>
  else if (flags & O_NONBLOCK)
 d0183c0:	e0bffe17 	ldw	r2,-8(fp)
 d0183c4:	1090000c 	andi	r2,r2,16384
 d0183c8:	1005003a 	cmpeq	r2,r2,zero
 d0183cc:	1000031e 	bne	r2,zero,d0183dc <altera_avalon_jtag_uart_read+0x2a0>
    return -EWOULDBLOCK;
 d0183d0:	00bffd44 	movi	r2,-11
 d0183d4:	e0bfff15 	stw	r2,-4(fp)
 d0183d8:	00000206 	br	d0183e4 <altera_avalon_jtag_uart_read+0x2a8>
  else
    return -EIO;
 d0183dc:	00bffec4 	movi	r2,-5
 d0183e0:	e0bfff15 	stw	r2,-4(fp)
 d0183e4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0183e8:	e037883a 	mov	sp,fp
 d0183ec:	dfc00117 	ldw	ra,4(sp)
 d0183f0:	df000017 	ldw	fp,0(sp)
 d0183f4:	dec00204 	addi	sp,sp,8
 d0183f8:	f800283a 	ret

0d0183fc <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 d0183fc:	deffeb04 	addi	sp,sp,-84
 d018400:	dfc01415 	stw	ra,80(sp)
 d018404:	df001315 	stw	fp,76(sp)
 d018408:	df001304 	addi	fp,sp,76
 d01840c:	e13ffb15 	stw	r4,-20(fp)
 d018410:	e17ffc15 	stw	r5,-16(fp)
 d018414:	e1bffd15 	stw	r6,-12(fp)
 d018418:	e1fffe15 	stw	r7,-8(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 d01841c:	e03ff815 	stw	zero,-32(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 d018420:	e0bffc17 	ldw	r2,-16(fp)
 d018424:	e0bff515 	stw	r2,-44(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 d018428:	e0bffb17 	ldw	r2,-20(fp)
 d01842c:	10800b17 	ldw	r2,44(r2)
 d018430:	e0bff315 	stw	r2,-52(fp)
 d018434:	e03ff40d 	sth	zero,-48(fp)
 d018438:	e17ff40b 	ldhu	r5,-48(fp)
 d01843c:	e1bffa04 	addi	r6,fp,-24
 d018440:	e13ff317 	ldw	r4,-52(fp)
 d018444:	d0132540 	call	d013254 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 d018448:	00003a06 	br	d018534 <altera_avalon_jtag_uart_write+0x138>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 d01844c:	e0bffb17 	ldw	r2,-20(fp)
 d018450:	10800f17 	ldw	r2,60(r2)
 d018454:	e0bff915 	stw	r2,-28(fp)
      out = sp->tx_out;
 d018458:	e0bffb17 	ldw	r2,-20(fp)
 d01845c:	10801017 	ldw	r2,64(r2)
 d018460:	e0bff815 	stw	r2,-32(fp)

      if (in < out)
 d018464:	e0fff917 	ldw	r3,-28(fp)
 d018468:	e0bff817 	ldw	r2,-32(fp)
 d01846c:	1880062e 	bgeu	r3,r2,d018488 <altera_avalon_jtag_uart_write+0x8c>
        n = out - 1 - in;
 d018470:	e0fff817 	ldw	r3,-32(fp)
 d018474:	e0bff917 	ldw	r2,-28(fp)
 d018478:	1885c83a 	sub	r2,r3,r2
 d01847c:	10bfffc4 	addi	r2,r2,-1
 d018480:	e0bff715 	stw	r2,-36(fp)
 d018484:	00000c06 	br	d0184b8 <altera_avalon_jtag_uart_write+0xbc>
      else if (out > 0)
 d018488:	e0bff817 	ldw	r2,-32(fp)
 d01848c:	1005003a 	cmpeq	r2,r2,zero
 d018490:	1000051e 	bne	r2,zero,d0184a8 <altera_avalon_jtag_uart_write+0xac>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 d018494:	00820004 	movi	r2,2048
 d018498:	e0fff917 	ldw	r3,-28(fp)
 d01849c:	10c5c83a 	sub	r2,r2,r3
 d0184a0:	e0bff715 	stw	r2,-36(fp)
 d0184a4:	00000406 	br	d0184b8 <altera_avalon_jtag_uart_write+0xbc>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 d0184a8:	0081ffc4 	movi	r2,2047
 d0184ac:	e0fff917 	ldw	r3,-28(fp)
 d0184b0:	10c5c83a 	sub	r2,r2,r3
 d0184b4:	e0bff715 	stw	r2,-36(fp)

      if (n == 0)
 d0184b8:	e0bff717 	ldw	r2,-36(fp)
 d0184bc:	1005003a 	cmpeq	r2,r2,zero
 d0184c0:	10001f1e 	bne	r2,zero,d018540 <altera_avalon_jtag_uart_write+0x144>
        break;

      if (n > count)
 d0184c4:	e0fffd17 	ldw	r3,-12(fp)
 d0184c8:	e0bff717 	ldw	r2,-36(fp)
 d0184cc:	1880022e 	bgeu	r3,r2,d0184d8 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 d0184d0:	e0bffd17 	ldw	r2,-12(fp)
 d0184d4:	e0bff715 	stw	r2,-36(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 d0184d8:	e0bffb17 	ldw	r2,-20(fp)
 d0184dc:	10c21104 	addi	r3,r2,2116
 d0184e0:	e0bff917 	ldw	r2,-28(fp)
 d0184e4:	1885883a 	add	r2,r3,r2
 d0184e8:	e0fffc17 	ldw	r3,-16(fp)
 d0184ec:	1009883a 	mov	r4,r2
 d0184f0:	180b883a 	mov	r5,r3
 d0184f4:	e1bff717 	ldw	r6,-36(fp)
 d0184f8:	d0027000 	call	d002700 <memcpy>
      ptr   += n;
 d0184fc:	e0fff717 	ldw	r3,-36(fp)
 d018500:	e0bffc17 	ldw	r2,-16(fp)
 d018504:	10c5883a 	add	r2,r2,r3
 d018508:	e0bffc15 	stw	r2,-16(fp)
      count -= n;
 d01850c:	e0fffd17 	ldw	r3,-12(fp)
 d018510:	e0bff717 	ldw	r2,-36(fp)
 d018514:	1885c83a 	sub	r2,r3,r2
 d018518:	e0bffd15 	stw	r2,-12(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 d01851c:	e0fff917 	ldw	r3,-28(fp)
 d018520:	e0bff717 	ldw	r2,-36(fp)
 d018524:	1885883a 	add	r2,r3,r2
 d018528:	10c1ffcc 	andi	r3,r2,2047
 d01852c:	e0bffb17 	ldw	r2,-20(fp)
 d018530:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 d018534:	e0bffd17 	ldw	r2,-12(fp)
 d018538:	10800048 	cmpgei	r2,r2,1
 d01853c:	103fc31e 	bne	r2,zero,d01844c <altera_avalon_jtag_uart_write+0x50>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d018540:	0005303a 	rdctl	r2,status
 d018544:	e0bff215 	stw	r2,-56(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d018548:	e0fff217 	ldw	r3,-56(fp)
 d01854c:	00bfff84 	movi	r2,-2
 d018550:	1884703a 	and	r2,r3,r2
 d018554:	1001703a 	wrctl	status,r2
  
  return context;
 d018558:	e0bff217 	ldw	r2,-56(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 d01855c:	e0bff615 	stw	r2,-40(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 d018560:	e0bffb17 	ldw	r2,-20(fp)
 d018564:	10800817 	ldw	r2,32(r2)
 d018568:	10c00094 	ori	r3,r2,2
 d01856c:	e0bffb17 	ldw	r2,-20(fp)
 d018570:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 d018574:	e0bffb17 	ldw	r2,-20(fp)
 d018578:	10800017 	ldw	r2,0(r2)
 d01857c:	11000104 	addi	r4,r2,4
 d018580:	e0bffb17 	ldw	r2,-20(fp)
 d018584:	10800817 	ldw	r2,32(r2)
 d018588:	1007883a 	mov	r3,r2
 d01858c:	2005883a 	mov	r2,r4
 d018590:	10c00035 	stwio	r3,0(r2)
 d018594:	e0bff617 	ldw	r2,-40(fp)
 d018598:	e0bff115 	stw	r2,-60(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01859c:	e0bff117 	ldw	r2,-60(fp)
 d0185a0:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 d0185a4:	e0bffd17 	ldw	r2,-12(fp)
 d0185a8:	10800050 	cmplti	r2,r2,1
 d0185ac:	10002d1e 	bne	r2,zero,d018664 <altera_avalon_jtag_uart_write+0x268>
    {
      if (flags & O_NONBLOCK)
 d0185b0:	e0bffe17 	ldw	r2,-8(fp)
 d0185b4:	1090000c 	andi	r2,r2,16384
 d0185b8:	1004c03a 	cmpne	r2,r2,zero
 d0185bc:	10002c1e 	bne	r2,zero,d018670 <altera_avalon_jtag_uart_write+0x274>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 d0185c0:	00834174 	movhi	r2,3333
 d0185c4:	108a8c44 	addi	r2,r2,10801
 d0185c8:	10800003 	ldbu	r2,0(r2)
 d0185cc:	10803fcc 	andi	r2,r2,255
 d0185d0:	10800058 	cmpnei	r2,r2,1
 d0185d4:	1000161e 	bne	r2,zero,d018630 <altera_avalon_jtag_uart_write+0x234>
         * When running in a multi-threaded mode, we pend on the write event
         * flag set or the timeout flag in the isr. This avoids wasting CPU
         * cycles waiting in this thread, when we could be doing something
         * more profitable elsewhere.
         */
        ALT_FLAG_PEND (sp->events,
 d0185d8:	e0bffb17 	ldw	r2,-20(fp)
 d0185dc:	10800c17 	ldw	r2,48(r2)
 d0185e0:	e0bfee15 	stw	r2,-72(fp)
 d0185e4:	00800184 	movi	r2,6
 d0185e8:	e0bfef0d 	sth	r2,-68(fp)
 d0185ec:	00bfe0c4 	movi	r2,-125
 d0185f0:	e0bfef85 	stb	r2,-66(fp)
 d0185f4:	e03ff00d 	sth	zero,-64(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 d0185f8:	00834174 	movhi	r2,3333
 d0185fc:	108a8c44 	addi	r2,r2,10801
 d018600:	10800003 	ldbu	r2,0(r2)
 d018604:	10803fcc 	andi	r2,r2,255
 d018608:	1005003a 	cmpeq	r2,r2,zero
 d01860c:	1000111e 	bne	r2,zero,d018654 <altera_avalon_jtag_uart_write+0x258>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 d018610:	e17fef0b 	ldhu	r5,-68(fp)
 d018614:	e1bfef83 	ldbu	r6,-66(fp)
 d018618:	e1fff00b 	ldhu	r7,-64(fp)
 d01861c:	e0bffa44 	addi	r2,fp,-23
 d018620:	d8800015 	stw	r2,0(sp)
 d018624:	e13fee17 	ldw	r4,-72(fp)
 d018628:	d0103180 	call	d010318 <OSFlagPend>
    return err;
 d01862c:	00000906 	br	d018654 <altera_avalon_jtag_uart_write+0x258>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 d018630:	e0bffb17 	ldw	r2,-20(fp)
 d018634:	10c01017 	ldw	r3,64(r2)
 d018638:	e0bff817 	ldw	r2,-32(fp)
 d01863c:	1880051e 	bne	r3,r2,d018654 <altera_avalon_jtag_uart_write+0x258>
 d018640:	e0bffb17 	ldw	r2,-20(fp)
 d018644:	10c00917 	ldw	r3,36(r2)
 d018648:	e0bffb17 	ldw	r2,-20(fp)
 d01864c:	10800117 	ldw	r2,4(r2)
 d018650:	18bff736 	bltu	r3,r2,d018630 <altera_avalon_jtag_uart_write+0x234>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 d018654:	e0bffb17 	ldw	r2,-20(fp)
 d018658:	10c01017 	ldw	r3,64(r2)
 d01865c:	e0bff817 	ldw	r2,-32(fp)
 d018660:	18800326 	beq	r3,r2,d018670 <altera_avalon_jtag_uart_write+0x274>
        break;
    }
  }
  while (count > 0);
 d018664:	e0bffd17 	ldw	r2,-12(fp)
 d018668:	10800048 	cmpgei	r2,r2,1
 d01866c:	103fb11e 	bne	r2,zero,d018534 <altera_avalon_jtag_uart_write+0x138>

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 d018670:	e0bffb17 	ldw	r2,-20(fp)
 d018674:	11000b17 	ldw	r4,44(r2)
 d018678:	d01364c0 	call	d01364c <OSSemPost>

  if (ptr != start)
 d01867c:	e0fffc17 	ldw	r3,-16(fp)
 d018680:	e0bff517 	ldw	r2,-44(fp)
 d018684:	18800526 	beq	r3,r2,d01869c <altera_avalon_jtag_uart_write+0x2a0>
    return ptr - start;
 d018688:	e0fffc17 	ldw	r3,-16(fp)
 d01868c:	e0bff517 	ldw	r2,-44(fp)
 d018690:	1887c83a 	sub	r3,r3,r2
 d018694:	e0ffff15 	stw	r3,-4(fp)
 d018698:	00000906 	br	d0186c0 <altera_avalon_jtag_uart_write+0x2c4>
  else if (flags & O_NONBLOCK)
 d01869c:	e0bffe17 	ldw	r2,-8(fp)
 d0186a0:	1090000c 	andi	r2,r2,16384
 d0186a4:	1005003a 	cmpeq	r2,r2,zero
 d0186a8:	1000031e 	bne	r2,zero,d0186b8 <altera_avalon_jtag_uart_write+0x2bc>
    return -EWOULDBLOCK;
 d0186ac:	00bffd44 	movi	r2,-11
 d0186b0:	e0bfff15 	stw	r2,-4(fp)
 d0186b4:	00000206 	br	d0186c0 <altera_avalon_jtag_uart_write+0x2c4>
  else
    return -EIO; /* Host not connected */
 d0186b8:	00bffec4 	movi	r2,-5
 d0186bc:	e0bfff15 	stw	r2,-4(fp)
 d0186c0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0186c4:	e037883a 	mov	sp,fp
 d0186c8:	dfc00117 	ldw	ra,4(sp)
 d0186cc:	df000017 	ldw	fp,0(sp)
 d0186d0:	dec00204 	addi	sp,sp,8
 d0186d4:	f800283a 	ret

0d0186d8 <lcd_write_command>:

/* --------------------------------------------------------------------- */

static void lcd_write_command(altera_avalon_lcd_16207_state* sp, 
  unsigned char command)
{
 d0186d8:	defffa04 	addi	sp,sp,-24
 d0186dc:	dfc00515 	stw	ra,20(sp)
 d0186e0:	df000415 	stw	fp,16(sp)
 d0186e4:	df000404 	addi	fp,sp,16
 d0186e8:	e13ffe15 	stw	r4,-8(fp)
 d0186ec:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 d0186f0:	e0bffe17 	ldw	r2,-8(fp)
 d0186f4:	10800017 	ldw	r2,0(r2)
 d0186f8:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 d0186fc:	008003f4 	movhi	r2,15
 d018700:	10909004 	addi	r2,r2,16960
 d018704:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 d018708:	e0bffe17 	ldw	r2,-8(fp)
 d01870c:	10800803 	ldbu	r2,32(r2)
 d018710:	10803fcc 	andi	r2,r2,255
 d018714:	1080201c 	xori	r2,r2,128
 d018718:	10bfe004 	addi	r2,r2,-128
 d01871c:	1004c03a 	cmpne	r2,r2,zero
 d018720:	1000161e 	bne	r2,zero,d01877c <lcd_write_command+0xa4>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 d018724:	00000a06 	br	d018750 <lcd_write_command+0x78>
    if (--i == 0)
 d018728:	e0bffc17 	ldw	r2,-16(fp)
 d01872c:	10bfffc4 	addi	r2,r2,-1
 d018730:	e0bffc15 	stw	r2,-16(fp)
 d018734:	e0bffc17 	ldw	r2,-16(fp)
 d018738:	1004c03a 	cmpne	r2,r2,zero
 d01873c:	1000041e 	bne	r2,zero,d018750 <lcd_write_command+0x78>
    {
      sp->broken = 1;
 d018740:	e0fffe17 	ldw	r3,-8(fp)
 d018744:	00800044 	movi	r2,1
 d018748:	18800805 	stb	r2,32(r3)
      return;
 d01874c:	00000b06 	br	d01877c <lcd_write_command+0xa4>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 d018750:	e0bffd17 	ldw	r2,-12(fp)
 d018754:	10800104 	addi	r2,r2,4
 d018758:	10800037 	ldwio	r2,0(r2)
 d01875c:	1080200c 	andi	r2,r2,128
 d018760:	1004c03a 	cmpne	r2,r2,zero
 d018764:	103ff01e 	bne	r2,zero,d018728 <lcd_write_command+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 d018768:	01001904 	movi	r4,100
 d01876c:	d0398d00 	call	d0398d0 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, command);
 d018770:	e0bffd17 	ldw	r2,-12(fp)
 d018774:	e0ffff03 	ldbu	r3,-4(fp)
 d018778:	10c00035 	stwio	r3,0(r2)
}
 d01877c:	e037883a 	mov	sp,fp
 d018780:	dfc00117 	ldw	ra,4(sp)
 d018784:	df000017 	ldw	fp,0(sp)
 d018788:	dec00204 	addi	sp,sp,8
 d01878c:	f800283a 	ret

0d018790 <lcd_write_data>:

/* --------------------------------------------------------------------- */

static void lcd_write_data(altera_avalon_lcd_16207_state* sp, 
  unsigned char data)
{
 d018790:	defffa04 	addi	sp,sp,-24
 d018794:	dfc00515 	stw	ra,20(sp)
 d018798:	df000415 	stw	fp,16(sp)
 d01879c:	df000404 	addi	fp,sp,16
 d0187a0:	e13ffe15 	stw	r4,-8(fp)
 d0187a4:	e17fff05 	stb	r5,-4(fp)
  unsigned int base = sp->base;
 d0187a8:	e0bffe17 	ldw	r2,-8(fp)
 d0187ac:	10800017 	ldw	r2,0(r2)
 d0187b0:	e0bffd15 	stw	r2,-12(fp)
  /* We impose a timeout on the driver in case the LCD panel isn't connected.
   * The first time we call this function the timeout is approx 25ms 
   * (assuming 5 cycles per loop and a 200MHz clock).  Obviously systems
   * with slower clocks, or debug builds, or slower memory will take longer.
   */
  int i = 1000000;
 d0187b4:	008003f4 	movhi	r2,15
 d0187b8:	10909004 	addi	r2,r2,16960
 d0187bc:	e0bffc15 	stw	r2,-16(fp)

  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
 d0187c0:	e0bffe17 	ldw	r2,-8(fp)
 d0187c4:	10800803 	ldbu	r2,32(r2)
 d0187c8:	10803fcc 	andi	r2,r2,255
 d0187cc:	1080201c 	xori	r2,r2,128
 d0187d0:	10bfe004 	addi	r2,r2,-128
 d0187d4:	1004c03a 	cmpne	r2,r2,zero
 d0187d8:	10001d1e 	bne	r2,zero,d018850 <lcd_write_data+0xc0>
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 d0187dc:	00000a06 	br	d018808 <lcd_write_data+0x78>
    if (--i == 0)
 d0187e0:	e0bffc17 	ldw	r2,-16(fp)
 d0187e4:	10bfffc4 	addi	r2,r2,-1
 d0187e8:	e0bffc15 	stw	r2,-16(fp)
 d0187ec:	e0bffc17 	ldw	r2,-16(fp)
 d0187f0:	1004c03a 	cmpne	r2,r2,zero
 d0187f4:	1000041e 	bne	r2,zero,d018808 <lcd_write_data+0x78>
    {
      sp->broken = 1;
 d0187f8:	e0fffe17 	ldw	r3,-8(fp)
 d0187fc:	00800044 	movi	r2,1
 d018800:	18800805 	stb	r2,32(r3)
      return;
 d018804:	00001206 	br	d018850 <lcd_write_data+0xc0>
  /* Don't bother if the LCD panel didn't work before */
  if (sp->broken)
    return;

  /* Wait until LCD isn't busy. */
  while (IORD_ALTERA_AVALON_LCD_16207_STATUS(base) & ALTERA_AVALON_LCD_16207_STATUS_BUSY_MSK)
 d018808:	e0bffd17 	ldw	r2,-12(fp)
 d01880c:	10800104 	addi	r2,r2,4
 d018810:	10800037 	ldwio	r2,0(r2)
 d018814:	1080200c 	andi	r2,r2,128
 d018818:	1004c03a 	cmpne	r2,r2,zero
 d01881c:	103ff01e 	bne	r2,zero,d0187e0 <lcd_write_data+0x50>
    }

  /* Despite what it says in the datasheet, the LCD isn't ready to accept
   * a write immediately after it returns BUSY=0.  Wait for 100us more.
   */
  usleep(100);
 d018820:	01001904 	movi	r4,100
 d018824:	d0398d00 	call	d0398d0 <usleep>

  IOWR_ALTERA_AVALON_LCD_16207_DATA(base, data);
 d018828:	e0bffd17 	ldw	r2,-12(fp)
 d01882c:	10800204 	addi	r2,r2,8
 d018830:	e0ffff03 	ldbu	r3,-4(fp)
 d018834:	10c00035 	stwio	r3,0(r2)

  sp->address++;
 d018838:	e0bffe17 	ldw	r2,-8(fp)
 d01883c:	108008c3 	ldbu	r2,35(r2)
 d018840:	10800044 	addi	r2,r2,1
 d018844:	1007883a 	mov	r3,r2
 d018848:	e0bffe17 	ldw	r2,-8(fp)
 d01884c:	10c008c5 	stb	r3,35(r2)
}
 d018850:	e037883a 	mov	sp,fp
 d018854:	dfc00117 	ldw	ra,4(sp)
 d018858:	df000017 	ldw	fp,0(sp)
 d01885c:	dec00204 	addi	sp,sp,8
 d018860:	f800283a 	ret

0d018864 <lcd_clear_screen>:

/* --------------------------------------------------------------------- */

static void lcd_clear_screen(altera_avalon_lcd_16207_state* sp)
{
 d018864:	defffc04 	addi	sp,sp,-16
 d018868:	dfc00315 	stw	ra,12(sp)
 d01886c:	df000215 	stw	fp,8(sp)
 d018870:	df000204 	addi	fp,sp,8
 d018874:	e13fff15 	stw	r4,-4(fp)
  int y;

  lcd_write_command(sp, LCD_CMD_CLEAR);
 d018878:	e13fff17 	ldw	r4,-4(fp)
 d01887c:	01400044 	movi	r5,1
 d018880:	d0186d80 	call	d0186d8 <lcd_write_command>

  sp->x = 0;
 d018884:	e0bfff17 	ldw	r2,-4(fp)
 d018888:	10000845 	stb	zero,33(r2)
  sp->y = 0;
 d01888c:	e0bfff17 	ldw	r2,-4(fp)
 d018890:	10000885 	stb	zero,34(r2)
  sp->address = 0;
 d018894:	e0bfff17 	ldw	r2,-4(fp)
 d018898:	100008c5 	stb	zero,35(r2)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01889c:	e03ffe15 	stw	zero,-8(fp)
 d0188a0:	00001906 	br	d018908 <lcd_clear_screen+0xa4>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
 d0188a4:	e0bffe17 	ldw	r2,-8(fp)
 d0188a8:	108018e4 	muli	r2,r2,99
 d0188ac:	10c01004 	addi	r3,r2,64
 d0188b0:	e0bfff17 	ldw	r2,-4(fp)
 d0188b4:	1889883a 	add	r4,r3,r2
 d0188b8:	01400804 	movi	r5,32
 d0188bc:	01801444 	movi	r6,81
 d0188c0:	d0028800 	call	d002880 <memset>
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
 d0188c4:	e0bffe17 	ldw	r2,-8(fp)
 d0188c8:	108018e4 	muli	r2,r2,99
 d0188cc:	10c00c04 	addi	r3,r2,48
 d0188d0:	e0bfff17 	ldw	r2,-4(fp)
 d0188d4:	1889883a 	add	r4,r3,r2
 d0188d8:	01400804 	movi	r5,32
 d0188dc:	01800404 	movi	r6,16
 d0188e0:	d0028800 	call	d002880 <memset>
    sp->line[y].width = 0;
 d0188e4:	e0bffe17 	ldw	r2,-8(fp)
 d0188e8:	e0ffff17 	ldw	r3,-4(fp)
 d0188ec:	108018e4 	muli	r2,r2,99
 d0188f0:	10c5883a 	add	r2,r2,r3
 d0188f4:	10802404 	addi	r2,r2,144
 d0188f8:	10000045 	stb	zero,1(r2)

  sp->x = 0;
  sp->y = 0;
  sp->address = 0;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d0188fc:	e0bffe17 	ldw	r2,-8(fp)
 d018900:	10800044 	addi	r2,r2,1
 d018904:	e0bffe15 	stw	r2,-8(fp)
 d018908:	e0bffe17 	ldw	r2,-8(fp)
 d01890c:	10800090 	cmplti	r2,r2,2
 d018910:	103fe41e 	bne	r2,zero,d0188a4 <lcd_clear_screen+0x40>
  {
    memset(sp->line[y].data, ' ', sizeof(sp->line[0].data));
    memset(sp->line[y].visible, ' ', sizeof(sp->line[0].visible));
    sp->line[y].width = 0;
  }
}
 d018914:	e037883a 	mov	sp,fp
 d018918:	dfc00117 	ldw	ra,4(sp)
 d01891c:	df000017 	ldw	fp,0(sp)
 d018920:	dec00204 	addi	sp,sp,8
 d018924:	f800283a 	ret

0d018928 <lcd_repaint_screen>:

/* --------------------------------------------------------------------- */

static void lcd_repaint_screen(altera_avalon_lcd_16207_state* sp)
{
 d018928:	defff704 	addi	sp,sp,-36
 d01892c:	dfc00815 	stw	ra,32(sp)
 d018930:	df000715 	stw	fp,28(sp)
 d018934:	df000704 	addi	fp,sp,28
 d018938:	e13fff15 	stw	r4,-4(fp)
  /* scrollpos controls how much the lines have scrolled round.  The speed
   * each line scrolls at is controlled by its speed variable - while
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;
 d01893c:	e0bfff17 	ldw	r2,-4(fp)
 d018940:	10800943 	ldbu	r2,37(r2)
 d018944:	10803fcc 	andi	r2,r2,255
 d018948:	1080201c 	xori	r2,r2,128
 d01894c:	10bfe004 	addi	r2,r2,-128
 d018950:	e0bffc15 	stw	r2,-16(fp)

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d018954:	e03ffe15 	stw	zero,-8(fp)
 d018958:	00006606 	br	d018af4 <lcd_repaint_screen+0x1cc>
  {
    int width  = sp->line[y].width;
 d01895c:	e0bffe17 	ldw	r2,-8(fp)
 d018960:	e0ffff17 	ldw	r3,-4(fp)
 d018964:	108018e4 	muli	r2,r2,99
 d018968:	10c5883a 	add	r2,r2,r3
 d01896c:	10802404 	addi	r2,r2,144
 d018970:	10800043 	ldbu	r2,1(r2)
 d018974:	10803fcc 	andi	r2,r2,255
 d018978:	1080201c 	xori	r2,r2,128
 d01897c:	10bfe004 	addi	r2,r2,-128
 d018980:	e0bffb15 	stw	r2,-20(fp)
    int offset = (scrollpos * sp->line[y].speed) >> 8;
 d018984:	e0bffe17 	ldw	r2,-8(fp)
 d018988:	e0ffff17 	ldw	r3,-4(fp)
 d01898c:	108018e4 	muli	r2,r2,99
 d018990:	10c5883a 	add	r2,r2,r3
 d018994:	10802404 	addi	r2,r2,144
 d018998:	10800083 	ldbu	r2,2(r2)
 d01899c:	10c03fcc 	andi	r3,r2,255
 d0189a0:	e0bffc17 	ldw	r2,-16(fp)
 d0189a4:	1885383a 	mul	r2,r3,r2
 d0189a8:	1005d23a 	srai	r2,r2,8
 d0189ac:	e0bffa15 	stw	r2,-24(fp)
    if (offset >= width)
 d0189b0:	e0fffa17 	ldw	r3,-24(fp)
 d0189b4:	e0bffb17 	ldw	r2,-20(fp)
 d0189b8:	18800116 	blt	r3,r2,d0189c0 <lcd_repaint_screen+0x98>
      offset = 0;
 d0189bc:	e03ffa15 	stw	zero,-24(fp)

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 d0189c0:	e03ffd15 	stw	zero,-12(fp)
 d0189c4:	00004506 	br	d018adc <lcd_repaint_screen+0x1b4>
    {
      char c = sp->line[y].data[(x + offset) % width];
 d0189c8:	e17ffe17 	ldw	r5,-8(fp)
 d0189cc:	e0fffd17 	ldw	r3,-12(fp)
 d0189d0:	e0bffa17 	ldw	r2,-24(fp)
 d0189d4:	1889883a 	add	r4,r3,r2
 d0189d8:	e0bffb17 	ldw	r2,-20(fp)
 d0189dc:	2087283a 	div	r3,r4,r2
 d0189e0:	e0bffb17 	ldw	r2,-20(fp)
 d0189e4:	1885383a 	mul	r2,r3,r2
 d0189e8:	2089c83a 	sub	r4,r4,r2
 d0189ec:	e0ffff17 	ldw	r3,-4(fp)
 d0189f0:	288018e4 	muli	r2,r5,99
 d0189f4:	10c5883a 	add	r2,r2,r3
 d0189f8:	1105883a 	add	r2,r2,r4
 d0189fc:	10801004 	addi	r2,r2,64
 d018a00:	10800003 	ldbu	r2,0(r2)
 d018a04:	e0bff945 	stb	r2,-27(fp)

      /* Writing data takes 40us, so don't do it unless required */
      if (sp->line[y].visible[x] != c)
 d018a08:	e0bffe17 	ldw	r2,-8(fp)
 d018a0c:	e13ffd17 	ldw	r4,-12(fp)
 d018a10:	e0ffff17 	ldw	r3,-4(fp)
 d018a14:	108018e4 	muli	r2,r2,99
 d018a18:	10c5883a 	add	r2,r2,r3
 d018a1c:	1105883a 	add	r2,r2,r4
 d018a20:	10800c04 	addi	r2,r2,48
 d018a24:	10800003 	ldbu	r2,0(r2)
 d018a28:	10c03fcc 	andi	r3,r2,255
 d018a2c:	18c0201c 	xori	r3,r3,128
 d018a30:	18ffe004 	addi	r3,r3,-128
 d018a34:	e0bff947 	ldb	r2,-27(fp)
 d018a38:	18802526 	beq	r3,r2,d018ad0 <lcd_repaint_screen+0x1a8>
      {
        unsigned char address = x + colstart[y];
 d018a3c:	e0fffe17 	ldw	r3,-8(fp)
 d018a40:	d0a02a04 	addi	r2,gp,-32600
 d018a44:	1885883a 	add	r2,r3,r2
 d018a48:	10800003 	ldbu	r2,0(r2)
 d018a4c:	1007883a 	mov	r3,r2
 d018a50:	e0bffd17 	ldw	r2,-12(fp)
 d018a54:	1885883a 	add	r2,r3,r2
 d018a58:	e0bff905 	stb	r2,-28(fp)

        if (address != sp->address)
 d018a5c:	e0fff903 	ldbu	r3,-28(fp)
 d018a60:	e0bfff17 	ldw	r2,-4(fp)
 d018a64:	108008c3 	ldbu	r2,35(r2)
 d018a68:	10803fcc 	andi	r2,r2,255
 d018a6c:	1080201c 	xori	r2,r2,128
 d018a70:	10bfe004 	addi	r2,r2,-128
 d018a74:	18800926 	beq	r3,r2,d018a9c <lcd_repaint_screen+0x174>
        {
          lcd_write_command(sp, LCD_CMD_WRITE_DATA | address);
 d018a78:	e0fff903 	ldbu	r3,-28(fp)
 d018a7c:	00bfe004 	movi	r2,-128
 d018a80:	1884b03a 	or	r2,r3,r2
 d018a84:	11403fcc 	andi	r5,r2,255
 d018a88:	e13fff17 	ldw	r4,-4(fp)
 d018a8c:	d0186d80 	call	d0186d8 <lcd_write_command>
          sp->address = address;
 d018a90:	e0fff903 	ldbu	r3,-28(fp)
 d018a94:	e0bfff17 	ldw	r2,-4(fp)
 d018a98:	10c008c5 	stb	r3,35(r2)
        }

        lcd_write_data(sp, c);
 d018a9c:	e0bff943 	ldbu	r2,-27(fp)
 d018aa0:	11403fcc 	andi	r5,r2,255
 d018aa4:	e13fff17 	ldw	r4,-4(fp)
 d018aa8:	d0187900 	call	d018790 <lcd_write_data>
        sp->line[y].visible[x] = c;
 d018aac:	e0bffe17 	ldw	r2,-8(fp)
 d018ab0:	e13ffd17 	ldw	r4,-12(fp)
 d018ab4:	e0ffff17 	ldw	r3,-4(fp)
 d018ab8:	108018e4 	muli	r2,r2,99
 d018abc:	10c5883a 	add	r2,r2,r3
 d018ac0:	1105883a 	add	r2,r2,r4
 d018ac4:	10c00c04 	addi	r3,r2,48
 d018ac8:	e0bff943 	ldbu	r2,-27(fp)
 d018acc:	18800005 	stb	r2,0(r3)
    int width  = sp->line[y].width;
    int offset = (scrollpos * sp->line[y].speed) >> 8;
    if (offset >= width)
      offset = 0;

    for (x = 0 ; x < ALT_LCD_WIDTH ; x++)
 d018ad0:	e0bffd17 	ldw	r2,-12(fp)
 d018ad4:	10800044 	addi	r2,r2,1
 d018ad8:	e0bffd15 	stw	r2,-12(fp)
 d018adc:	e0bffd17 	ldw	r2,-12(fp)
 d018ae0:	10800410 	cmplti	r2,r2,16
 d018ae4:	103fb81e 	bne	r2,zero,d0189c8 <lcd_repaint_screen+0xa0>
   * scrolline lines will wrap at the position set by width
   */

  int scrollpos = sp->scrollpos;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d018ae8:	e0bffe17 	ldw	r2,-8(fp)
 d018aec:	10800044 	addi	r2,r2,1
 d018af0:	e0bffe15 	stw	r2,-8(fp)
 d018af4:	e0bffe17 	ldw	r2,-8(fp)
 d018af8:	10800090 	cmplti	r2,r2,2
 d018afc:	103f971e 	bne	r2,zero,d01895c <lcd_repaint_screen+0x34>
        lcd_write_data(sp, c);
        sp->line[y].visible[x] = c;
      }
    }
  }
}
 d018b00:	e037883a 	mov	sp,fp
 d018b04:	dfc00117 	ldw	ra,4(sp)
 d018b08:	df000017 	ldw	fp,0(sp)
 d018b0c:	dec00204 	addi	sp,sp,8
 d018b10:	f800283a 	ret

0d018b14 <lcd_scroll_up>:

/* --------------------------------------------------------------------- */

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
 d018b14:	defffc04 	addi	sp,sp,-16
 d018b18:	dfc00315 	stw	ra,12(sp)
 d018b1c:	df000215 	stw	fp,8(sp)
 d018b20:	df000204 	addi	fp,sp,8
 d018b24:	e13fff15 	stw	r4,-4(fp)
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d018b28:	e03ffe15 	stw	zero,-8(fp)
 d018b2c:	00001d06 	br	d018ba4 <lcd_scroll_up+0x90>
  {
    if (y < ALT_LCD_HEIGHT-1)
 d018b30:	e0bffe17 	ldw	r2,-8(fp)
 d018b34:	10800048 	cmpgei	r2,r2,1
 d018b38:	10000f1e 	bne	r2,zero,d018b78 <lcd_scroll_up+0x64>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
 d018b3c:	e0bffe17 	ldw	r2,-8(fp)
 d018b40:	108018e4 	muli	r2,r2,99
 d018b44:	10c01004 	addi	r3,r2,64
 d018b48:	e0bfff17 	ldw	r2,-4(fp)
 d018b4c:	1889883a 	add	r4,r3,r2
 d018b50:	e0bffe17 	ldw	r2,-8(fp)
 d018b54:	10800044 	addi	r2,r2,1
 d018b58:	108018e4 	muli	r2,r2,99
 d018b5c:	10c01004 	addi	r3,r2,64
 d018b60:	e0bfff17 	ldw	r2,-4(fp)
 d018b64:	1885883a 	add	r2,r3,r2
 d018b68:	100b883a 	mov	r5,r2
 d018b6c:	01801404 	movi	r6,80
 d018b70:	d0027000 	call	d002700 <memcpy>
 d018b74:	00000806 	br	d018b98 <lcd_scroll_up+0x84>
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
 d018b78:	e0bffe17 	ldw	r2,-8(fp)
 d018b7c:	108018e4 	muli	r2,r2,99
 d018b80:	10c01004 	addi	r3,r2,64
 d018b84:	e0bfff17 	ldw	r2,-4(fp)
 d018b88:	1889883a 	add	r4,r3,r2
 d018b8c:	01400804 	movi	r5,32
 d018b90:	01801404 	movi	r6,80
 d018b94:	d0028800 	call	d002880 <memset>

static void lcd_scroll_up(altera_avalon_lcd_16207_state* sp)
{
  int y;

  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d018b98:	e0bffe17 	ldw	r2,-8(fp)
 d018b9c:	10800044 	addi	r2,r2,1
 d018ba0:	e0bffe15 	stw	r2,-8(fp)
 d018ba4:	e0bffe17 	ldw	r2,-8(fp)
 d018ba8:	10800090 	cmplti	r2,r2,2
 d018bac:	103fe01e 	bne	r2,zero,d018b30 <lcd_scroll_up+0x1c>
      memcpy(sp->line[y].data, sp->line[y+1].data, ALT_LCD_VIRTUAL_WIDTH);
    else
      memset(sp->line[y].data, ' ', ALT_LCD_VIRTUAL_WIDTH);
  }

  sp->y--;
 d018bb0:	e0bfff17 	ldw	r2,-4(fp)
 d018bb4:	10800883 	ldbu	r2,34(r2)
 d018bb8:	10bfffc4 	addi	r2,r2,-1
 d018bbc:	1007883a 	mov	r3,r2
 d018bc0:	e0bfff17 	ldw	r2,-4(fp)
 d018bc4:	10c00885 	stb	r3,34(r2)
}
 d018bc8:	e037883a 	mov	sp,fp
 d018bcc:	dfc00117 	ldw	ra,4(sp)
 d018bd0:	df000017 	ldw	fp,0(sp)
 d018bd4:	dec00204 	addi	sp,sp,8
 d018bd8:	f800283a 	ret

0d018bdc <lcd_handle_escape>:

/* --------------------------------------------------------------------- */

static void lcd_handle_escape(altera_avalon_lcd_16207_state* sp, char c)
{
 d018bdc:	defff804 	addi	sp,sp,-32
 d018be0:	dfc00715 	stw	ra,28(sp)
 d018be4:	df000615 	stw	fp,24(sp)
 d018be8:	df000604 	addi	fp,sp,24
 d018bec:	e13ffd15 	stw	r4,-12(fp)
 d018bf0:	e17ffe05 	stb	r5,-8(fp)
  int parm1 = 0, parm2 = 0;
 d018bf4:	e03ffc15 	stw	zero,-16(fp)
 d018bf8:	e03ffb15 	stw	zero,-20(fp)

  if (sp->escape[0] == '[')
 d018bfc:	e0bffd17 	ldw	r2,-12(fp)
 d018c00:	10800a03 	ldbu	r2,40(r2)
 d018c04:	10803fcc 	andi	r2,r2,255
 d018c08:	1080201c 	xori	r2,r2,128
 d018c0c:	10bfe004 	addi	r2,r2,-128
 d018c10:	108016d8 	cmpnei	r2,r2,91
 d018c14:	1000491e 	bne	r2,zero,d018d3c <lcd_handle_escape+0x160>
  {
    char * ptr = sp->escape+1;
 d018c18:	e0bffd17 	ldw	r2,-12(fp)
 d018c1c:	10800a04 	addi	r2,r2,40
 d018c20:	10800044 	addi	r2,r2,1
 d018c24:	e0bffa15 	stw	r2,-24(fp)
    while (isdigit(*ptr))
 d018c28:	00000d06 	br	d018c60 <lcd_handle_escape+0x84>
      parm1 = (parm1 * 10) + (*ptr++ - '0');
 d018c2c:	e0bffc17 	ldw	r2,-16(fp)
 d018c30:	10c002a4 	muli	r3,r2,10
 d018c34:	e0bffa17 	ldw	r2,-24(fp)
 d018c38:	10800003 	ldbu	r2,0(r2)
 d018c3c:	10803fcc 	andi	r2,r2,255
 d018c40:	1080201c 	xori	r2,r2,128
 d018c44:	10bfe004 	addi	r2,r2,-128
 d018c48:	1885883a 	add	r2,r3,r2
 d018c4c:	10bff404 	addi	r2,r2,-48
 d018c50:	e0bffc15 	stw	r2,-16(fp)
 d018c54:	e0bffa17 	ldw	r2,-24(fp)
 d018c58:	10800044 	addi	r2,r2,1
 d018c5c:	e0bffa15 	stw	r2,-24(fp)
  int parm1 = 0, parm2 = 0;

  if (sp->escape[0] == '[')
  {
    char * ptr = sp->escape+1;
    while (isdigit(*ptr))
 d018c60:	e0bffa17 	ldw	r2,-24(fp)
 d018c64:	10800003 	ldbu	r2,0(r2)
 d018c68:	10803fcc 	andi	r2,r2,255
 d018c6c:	1080201c 	xori	r2,r2,128
 d018c70:	10bfe004 	addi	r2,r2,-128
 d018c74:	1007883a 	mov	r3,r2
 d018c78:	00834174 	movhi	r2,3333
 d018c7c:	108a2104 	addi	r2,r2,10372
 d018c80:	10800017 	ldw	r2,0(r2)
 d018c84:	1885883a 	add	r2,r3,r2
 d018c88:	10800003 	ldbu	r2,0(r2)
 d018c8c:	10803fcc 	andi	r2,r2,255
 d018c90:	1080010c 	andi	r2,r2,4
 d018c94:	1004c03a 	cmpne	r2,r2,zero
 d018c98:	103fe41e 	bne	r2,zero,d018c2c <lcd_handle_escape+0x50>
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
 d018c9c:	e0bffa17 	ldw	r2,-24(fp)
 d018ca0:	10800003 	ldbu	r2,0(r2)
 d018ca4:	10803fcc 	andi	r2,r2,255
 d018ca8:	1080201c 	xori	r2,r2,128
 d018cac:	10bfe004 	addi	r2,r2,-128
 d018cb0:	10800ed8 	cmpnei	r2,r2,59
 d018cb4:	1000231e 	bne	r2,zero,d018d44 <lcd_handle_escape+0x168>
    {
      ptr++;
 d018cb8:	e0bffa17 	ldw	r2,-24(fp)
 d018cbc:	10800044 	addi	r2,r2,1
 d018cc0:	e0bffa15 	stw	r2,-24(fp)
      while (isdigit(*ptr))
 d018cc4:	00000d06 	br	d018cfc <lcd_handle_escape+0x120>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
 d018cc8:	e0bffb17 	ldw	r2,-20(fp)
 d018ccc:	10c002a4 	muli	r3,r2,10
 d018cd0:	e0bffa17 	ldw	r2,-24(fp)
 d018cd4:	10800003 	ldbu	r2,0(r2)
 d018cd8:	10803fcc 	andi	r2,r2,255
 d018cdc:	1080201c 	xori	r2,r2,128
 d018ce0:	10bfe004 	addi	r2,r2,-128
 d018ce4:	1885883a 	add	r2,r3,r2
 d018ce8:	10bff404 	addi	r2,r2,-48
 d018cec:	e0bffb15 	stw	r2,-20(fp)
 d018cf0:	e0bffa17 	ldw	r2,-24(fp)
 d018cf4:	10800044 	addi	r2,r2,1
 d018cf8:	e0bffa15 	stw	r2,-24(fp)
      parm1 = (parm1 * 10) + (*ptr++ - '0');

    if (*ptr == ';')
    {
      ptr++;
      while (isdigit(*ptr))
 d018cfc:	e0bffa17 	ldw	r2,-24(fp)
 d018d00:	10800003 	ldbu	r2,0(r2)
 d018d04:	10803fcc 	andi	r2,r2,255
 d018d08:	1080201c 	xori	r2,r2,128
 d018d0c:	10bfe004 	addi	r2,r2,-128
 d018d10:	1007883a 	mov	r3,r2
 d018d14:	00834174 	movhi	r2,3333
 d018d18:	108a2104 	addi	r2,r2,10372
 d018d1c:	10800017 	ldw	r2,0(r2)
 d018d20:	1885883a 	add	r2,r3,r2
 d018d24:	10800003 	ldbu	r2,0(r2)
 d018d28:	10803fcc 	andi	r2,r2,255
 d018d2c:	1080010c 	andi	r2,r2,4
 d018d30:	1004c03a 	cmpne	r2,r2,zero
 d018d34:	103fe41e 	bne	r2,zero,d018cc8 <lcd_handle_escape+0xec>
 d018d38:	00000206 	br	d018d44 <lcd_handle_escape+0x168>
        parm2 = (parm2 * 10) + (*ptr++ - '0');
    }
  }
  else
    parm1 = -1;
 d018d3c:	00bfffc4 	movi	r2,-1
 d018d40:	e0bffc15 	stw	r2,-16(fp)

  switch (c)
 d018d44:	e0bffe07 	ldb	r2,-8(fp)
 d018d48:	e0bfff15 	stw	r2,-4(fp)
 d018d4c:	e0ffff17 	ldw	r3,-4(fp)
 d018d50:	188012a0 	cmpeqi	r2,r3,74
 d018d54:	10002f1e 	bne	r2,zero,d018e14 <lcd_handle_escape+0x238>
 d018d58:	e0ffff17 	ldw	r3,-4(fp)
 d018d5c:	188012c8 	cmpgei	r2,r3,75
 d018d60:	1000041e 	bne	r2,zero,d018d74 <lcd_handle_escape+0x198>
 d018d64:	e0ffff17 	ldw	r3,-4(fp)
 d018d68:	18801220 	cmpeqi	r2,r3,72
 d018d6c:	1000081e 	bne	r2,zero,d018d90 <lcd_handle_escape+0x1b4>
 d018d70:	00004906 	br	d018e98 <lcd_handle_escape+0x2bc>
 d018d74:	e0ffff17 	ldw	r3,-4(fp)
 d018d78:	188012e0 	cmpeqi	r2,r3,75
 d018d7c:	10002b1e 	bne	r2,zero,d018e2c <lcd_handle_escape+0x250>
 d018d80:	e0ffff17 	ldw	r3,-4(fp)
 d018d84:	188019a0 	cmpeqi	r2,r3,102
 d018d88:	1000011e 	bne	r2,zero,d018d90 <lcd_handle_escape+0x1b4>
 d018d8c:	00004206 	br	d018e98 <lcd_handle_escape+0x2bc>
  {
  case 'H': /* ESC '[' <y> ';' <x> 'H'  : Move cursor to location */
  case 'f': /* Same as above */
    if (parm2 > 0)
 d018d90:	e0bffb17 	ldw	r2,-20(fp)
 d018d94:	10800050 	cmplti	r2,r2,1
 d018d98:	1000051e 	bne	r2,zero,d018db0 <lcd_handle_escape+0x1d4>
      sp->x = parm2 - 1;
 d018d9c:	e0bffb17 	ldw	r2,-20(fp)
 d018da0:	10bfffc4 	addi	r2,r2,-1
 d018da4:	1007883a 	mov	r3,r2
 d018da8:	e0bffd17 	ldw	r2,-12(fp)
 d018dac:	10c00845 	stb	r3,33(r2)
    if (parm1 > 0)
 d018db0:	e0bffc17 	ldw	r2,-16(fp)
 d018db4:	10800050 	cmplti	r2,r2,1
 d018db8:	1000371e 	bne	r2,zero,d018e98 <lcd_handle_escape+0x2bc>
    {
      sp->y = parm1 - 1;
 d018dbc:	e0bffc17 	ldw	r2,-16(fp)
 d018dc0:	10bfffc4 	addi	r2,r2,-1
 d018dc4:	1007883a 	mov	r3,r2
 d018dc8:	e0bffd17 	ldw	r2,-12(fp)
 d018dcc:	10c00885 	stb	r3,34(r2)
      if (sp->y > ALT_LCD_HEIGHT * 2)
 d018dd0:	e0bffd17 	ldw	r2,-12(fp)
 d018dd4:	10800883 	ldbu	r2,34(r2)
 d018dd8:	10803fcc 	andi	r2,r2,255
 d018ddc:	10800170 	cmpltui	r2,r2,5
 d018de0:	1000061e 	bne	r2,zero,d018dfc <lcd_handle_escape+0x220>
        sp->y = ALT_LCD_HEIGHT * 2;
 d018de4:	e0fffd17 	ldw	r3,-12(fp)
 d018de8:	00800104 	movi	r2,4
 d018dec:	18800885 	stb	r2,34(r3)
      while (sp->y > ALT_LCD_HEIGHT)
 d018df0:	00000206 	br	d018dfc <lcd_handle_escape+0x220>
        lcd_scroll_up(sp);
 d018df4:	e13ffd17 	ldw	r4,-12(fp)
 d018df8:	d018b140 	call	d018b14 <lcd_scroll_up>
    if (parm1 > 0)
    {
      sp->y = parm1 - 1;
      if (sp->y > ALT_LCD_HEIGHT * 2)
        sp->y = ALT_LCD_HEIGHT * 2;
      while (sp->y > ALT_LCD_HEIGHT)
 d018dfc:	e0bffd17 	ldw	r2,-12(fp)
 d018e00:	10800883 	ldbu	r2,34(r2)
 d018e04:	10803fcc 	andi	r2,r2,255
 d018e08:	108000e8 	cmpgeui	r2,r2,3
 d018e0c:	103ff91e 	bne	r2,zero,d018df4 <lcd_handle_escape+0x218>
        lcd_scroll_up(sp);
    }
    break;
 d018e10:	00002106 	br	d018e98 <lcd_handle_escape+0x2bc>
    /*   ESC J      is clear to beginning of line    [unimplemented]
     *   ESC [ 0 J  is clear to bottom of screen     [unimplemented]
     *   ESC [ 1 J  is clear to beginning of screen  [unimplemented]
     *   ESC [ 2 J  is clear screen
     */
    if (parm1 == 2)
 d018e14:	e0bffc17 	ldw	r2,-16(fp)
 d018e18:	10800098 	cmpnei	r2,r2,2
 d018e1c:	10001e1e 	bne	r2,zero,d018e98 <lcd_handle_escape+0x2bc>
      lcd_clear_screen(sp);
 d018e20:	e13ffd17 	ldw	r4,-12(fp)
 d018e24:	d0188640 	call	d018864 <lcd_clear_screen>
    break;
 d018e28:	00001b06 	br	d018e98 <lcd_handle_escape+0x2bc>
    /*   ESC K      is clear to end of line
     *   ESC [ 0 K  is clear to end of line
     *   ESC [ 1 K  is clear to beginning of line    [unimplemented]
     *   ESC [ 2 K  is clear line                    [unimplemented]
     */
    if (parm1 < 1)
 d018e2c:	e0bffc17 	ldw	r2,-16(fp)
 d018e30:	10800048 	cmpgei	r2,r2,1
 d018e34:	1000181e 	bne	r2,zero,d018e98 <lcd_handle_escape+0x2bc>
    {
      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 d018e38:	e0bffd17 	ldw	r2,-12(fp)
 d018e3c:	10800843 	ldbu	r2,33(r2)
 d018e40:	10803fcc 	andi	r2,r2,255
 d018e44:	10801428 	cmpgeui	r2,r2,80
 d018e48:	1000131e 	bne	r2,zero,d018e98 <lcd_handle_escape+0x2bc>
        memset(sp->line[sp->y].data + sp->x, ' ', ALT_LCD_VIRTUAL_WIDTH - sp->x);
 d018e4c:	e0bffd17 	ldw	r2,-12(fp)
 d018e50:	10800883 	ldbu	r2,34(r2)
 d018e54:	10803fcc 	andi	r2,r2,255
 d018e58:	108018e4 	muli	r2,r2,99
 d018e5c:	10c01004 	addi	r3,r2,64
 d018e60:	e0bffd17 	ldw	r2,-12(fp)
 d018e64:	1887883a 	add	r3,r3,r2
 d018e68:	e0bffd17 	ldw	r2,-12(fp)
 d018e6c:	10800843 	ldbu	r2,33(r2)
 d018e70:	10803fcc 	andi	r2,r2,255
 d018e74:	1889883a 	add	r4,r3,r2
 d018e78:	e0bffd17 	ldw	r2,-12(fp)
 d018e7c:	10800843 	ldbu	r2,33(r2)
 d018e80:	10c03fcc 	andi	r3,r2,255
 d018e84:	00801404 	movi	r2,80
 d018e88:	10c5c83a 	sub	r2,r2,r3
 d018e8c:	100d883a 	mov	r6,r2
 d018e90:	01400804 	movi	r5,32
 d018e94:	d0028800 	call	d002880 <memset>
    }
    break;
  }
}
 d018e98:	e037883a 	mov	sp,fp
 d018e9c:	dfc00117 	ldw	ra,4(sp)
 d018ea0:	df000017 	ldw	fp,0(sp)
 d018ea4:	dec00204 	addi	sp,sp,8
 d018ea8:	f800283a 	ret

0d018eac <altera_avalon_lcd_16207_write>:

/* --------------------------------------------------------------------- */

int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp, 
  const char* ptr, int len, int flags)
{
 d018eac:	defff004 	addi	sp,sp,-64
 d018eb0:	dfc00f15 	stw	ra,60(sp)
 d018eb4:	df000e15 	stw	fp,56(sp)
 d018eb8:	df000e04 	addi	fp,sp,56
 d018ebc:	e13ffc15 	stw	r4,-16(fp)
 d018ec0:	e17ffd15 	stw	r5,-12(fp)
 d018ec4:	e1bffe15 	stw	r6,-8(fp)
 d018ec8:	e1ffff15 	stw	r7,-4(fp)
  const char* end = ptr + len;
 d018ecc:	e0bffe17 	ldw	r2,-8(fp)
 d018ed0:	1007883a 	mov	r3,r2
 d018ed4:	e0bffd17 	ldw	r2,-12(fp)
 d018ed8:	10c5883a 	add	r2,r2,r3
 d018edc:	e0bffa15 	stw	r2,-24(fp)

  /* When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */

  ALT_SEM_PEND (sp->write_lock, 0);
 d018ee0:	e0bffc17 	ldw	r2,-16(fp)
 d018ee4:	10803e17 	ldw	r2,248(r2)
 d018ee8:	e0bff215 	stw	r2,-56(fp)
 d018eec:	e03ff30d 	sth	zero,-52(fp)
 d018ef0:	e17ff30b 	ldhu	r5,-52(fp)
 d018ef4:	e1bffb04 	addi	r6,fp,-20
 d018ef8:	e13ff217 	ldw	r4,-56(fp)
 d018efc:	d0132540 	call	d013254 <OSSemPend>

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;
 d018f00:	e0fffc17 	ldw	r3,-16(fp)
 d018f04:	00800044 	movi	r2,1
 d018f08:	188009c5 	stb	r2,39(r3)

  for ( ; ptr < end ; ptr++)
 d018f0c:	0000a206 	br	d019198 <altera_avalon_lcd_16207_write+0x2ec>
  {
    char c = *ptr;
 d018f10:	e0bffd17 	ldw	r2,-12(fp)
 d018f14:	10800003 	ldbu	r2,0(r2)
 d018f18:	e0bff705 	stb	r2,-36(fp)

    if (sp->esccount >= 0)
 d018f1c:	e0bffc17 	ldw	r2,-16(fp)
 d018f20:	10800903 	ldbu	r2,36(r2)
 d018f24:	10803fcc 	andi	r2,r2,255
 d018f28:	1080201c 	xori	r2,r2,128
 d018f2c:	10bfe004 	addi	r2,r2,-128
 d018f30:	1004803a 	cmplt	r2,r2,zero
 d018f34:	10003b1e 	bne	r2,zero,d019024 <altera_avalon_lcd_16207_write+0x178>
    {
      unsigned int esccount = sp->esccount;
 d018f38:	e0bffc17 	ldw	r2,-16(fp)
 d018f3c:	10800903 	ldbu	r2,36(r2)
 d018f40:	10803fcc 	andi	r2,r2,255
 d018f44:	1080201c 	xori	r2,r2,128
 d018f48:	10bfe004 	addi	r2,r2,-128
 d018f4c:	e0bff615 	stw	r2,-40(fp)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 d018f50:	e0bff617 	ldw	r2,-40(fp)
 d018f54:	1004c03a 	cmpne	r2,r2,zero
 d018f58:	1000031e 	bne	r2,zero,d018f68 <altera_avalon_lcd_16207_write+0xbc>
 d018f5c:	e0bff707 	ldb	r2,-36(fp)
 d018f60:	108016d8 	cmpnei	r2,r2,91
 d018f64:	1000111e 	bne	r2,zero,d018fac <altera_avalon_lcd_16207_write+0x100>
 d018f68:	e0bff617 	ldw	r2,-40(fp)
 d018f6c:	1005003a 	cmpeq	r2,r2,zero
 d018f70:	10001a1e 	bne	r2,zero,d018fdc <altera_avalon_lcd_16207_write+0x130>
 d018f74:	e0bff707 	ldb	r2,-36(fp)
 d018f78:	1007883a 	mov	r3,r2
 d018f7c:	00834174 	movhi	r2,3333
 d018f80:	108a2104 	addi	r2,r2,10372
 d018f84:	10800017 	ldw	r2,0(r2)
 d018f88:	1885883a 	add	r2,r3,r2
 d018f8c:	10800003 	ldbu	r2,0(r2)
 d018f90:	10803fcc 	andi	r2,r2,255
 d018f94:	1080010c 	andi	r2,r2,4
 d018f98:	1004c03a 	cmpne	r2,r2,zero
 d018f9c:	10000f1e 	bne	r2,zero,d018fdc <altera_avalon_lcd_16207_write+0x130>
 d018fa0:	e0bff707 	ldb	r2,-36(fp)
 d018fa4:	10800ee0 	cmpeqi	r2,r2,59
 d018fa8:	10000c1e 	bne	r2,zero,d018fdc <altera_avalon_lcd_16207_write+0x130>
          (esccount > 0 && !isdigit(c) && c != ';'))
      {
        sp->escape[esccount] = 0;
 d018fac:	e0fff617 	ldw	r3,-40(fp)
 d018fb0:	e0bffc17 	ldw	r2,-16(fp)
 d018fb4:	1885883a 	add	r2,r3,r2
 d018fb8:	10800a04 	addi	r2,r2,40
 d018fbc:	10000005 	stb	zero,0(r2)

        lcd_handle_escape(sp, c);
 d018fc0:	e17ff707 	ldb	r5,-36(fp)
 d018fc4:	e13ffc17 	ldw	r4,-16(fp)
 d018fc8:	d018bdc0 	call	d018bdc <lcd_handle_escape>

        sp->esccount = -1;
 d018fcc:	e0fffc17 	ldw	r3,-16(fp)
 d018fd0:	00bfffc4 	movi	r2,-1
 d018fd4:	18800905 	stb	r2,36(r3)

      /* Single character escape sequences can end with any character
       * Multi character escape sequences start with '[' and contain
       * digits and semicolons before terminating
       */
      if ((esccount == 0 && c != '[') ||
 d018fd8:	00006c06 	br	d01918c <altera_avalon_lcd_16207_write+0x2e0>

        lcd_handle_escape(sp, c);

        sp->esccount = -1;
      }
      else if (sp->esccount < sizeof(sp->escape)-1)
 d018fdc:	e0bffc17 	ldw	r2,-16(fp)
 d018fe0:	10800903 	ldbu	r2,36(r2)
 d018fe4:	10803fcc 	andi	r2,r2,255
 d018fe8:	108001e8 	cmpgeui	r2,r2,7
 d018fec:	1000671e 	bne	r2,zero,d01918c <altera_avalon_lcd_16207_write+0x2e0>
      {
        sp->escape[esccount] = c;
 d018ff0:	e0fff617 	ldw	r3,-40(fp)
 d018ff4:	e0bffc17 	ldw	r2,-16(fp)
 d018ff8:	1885883a 	add	r2,r3,r2
 d018ffc:	10c00a04 	addi	r3,r2,40
 d019000:	e0bff703 	ldbu	r2,-36(fp)
 d019004:	18800005 	stb	r2,0(r3)
        sp->esccount++;
 d019008:	e0bffc17 	ldw	r2,-16(fp)
 d01900c:	10800903 	ldbu	r2,36(r2)
 d019010:	10800044 	addi	r2,r2,1
 d019014:	1007883a 	mov	r3,r2
 d019018:	e0bffc17 	ldw	r2,-16(fp)
 d01901c:	10c00905 	stb	r3,36(r2)
 d019020:	00005a06 	br	d01918c <altera_avalon_lcd_16207_write+0x2e0>
      }
    }
    else if (c == 27) /* ESC */
 d019024:	e0bff707 	ldb	r2,-36(fp)
 d019028:	108006d8 	cmpnei	r2,r2,27
 d01902c:	1000031e 	bne	r2,zero,d01903c <altera_avalon_lcd_16207_write+0x190>
    {
      sp->esccount = 0;
 d019030:	e0bffc17 	ldw	r2,-16(fp)
 d019034:	10000905 	stb	zero,36(r2)
 d019038:	00005406 	br	d01918c <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (c == '\r')
 d01903c:	e0bff707 	ldb	r2,-36(fp)
 d019040:	10800358 	cmpnei	r2,r2,13
 d019044:	1000031e 	bne	r2,zero,d019054 <altera_avalon_lcd_16207_write+0x1a8>
    {
      sp->x = 0;
 d019048:	e0bffc17 	ldw	r2,-16(fp)
 d01904c:	10000845 	stb	zero,33(r2)
 d019050:	00004e06 	br	d01918c <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (c == '\n')
 d019054:	e0bff707 	ldb	r2,-36(fp)
 d019058:	10800298 	cmpnei	r2,r2,10
 d01905c:	1000101e 	bne	r2,zero,d0190a0 <altera_avalon_lcd_16207_write+0x1f4>
    {
      sp->x = 0;
 d019060:	e0bffc17 	ldw	r2,-16(fp)
 d019064:	10000845 	stb	zero,33(r2)
      sp->y++;
 d019068:	e0bffc17 	ldw	r2,-16(fp)
 d01906c:	10800883 	ldbu	r2,34(r2)
 d019070:	10800044 	addi	r2,r2,1
 d019074:	1007883a 	mov	r3,r2
 d019078:	e0bffc17 	ldw	r2,-16(fp)
 d01907c:	10c00885 	stb	r3,34(r2)

      /* Let the cursor sit at X=0, Y=HEIGHT without scrolling so the user
       * can print two lines of data without losing one.
       */
      if (sp->y > ALT_LCD_HEIGHT)
 d019080:	e0bffc17 	ldw	r2,-16(fp)
 d019084:	10800883 	ldbu	r2,34(r2)
 d019088:	10803fcc 	andi	r2,r2,255
 d01908c:	108000f0 	cmpltui	r2,r2,3
 d019090:	10003e1e 	bne	r2,zero,d01918c <altera_avalon_lcd_16207_write+0x2e0>
        lcd_scroll_up(sp);
 d019094:	e13ffc17 	ldw	r4,-16(fp)
 d019098:	d018b140 	call	d018b14 <lcd_scroll_up>
 d01909c:	00003b06 	br	d01918c <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (c == '\b')
 d0190a0:	e0bff707 	ldb	r2,-36(fp)
 d0190a4:	10800218 	cmpnei	r2,r2,8
 d0190a8:	10000c1e 	bne	r2,zero,d0190dc <altera_avalon_lcd_16207_write+0x230>
    {
      if (sp->x > 0)
 d0190ac:	e0bffc17 	ldw	r2,-16(fp)
 d0190b0:	10800843 	ldbu	r2,33(r2)
 d0190b4:	10803fcc 	andi	r2,r2,255
 d0190b8:	1005003a 	cmpeq	r2,r2,zero
 d0190bc:	1000331e 	bne	r2,zero,d01918c <altera_avalon_lcd_16207_write+0x2e0>
        sp->x--;
 d0190c0:	e0bffc17 	ldw	r2,-16(fp)
 d0190c4:	10800843 	ldbu	r2,33(r2)
 d0190c8:	10bfffc4 	addi	r2,r2,-1
 d0190cc:	1007883a 	mov	r3,r2
 d0190d0:	e0bffc17 	ldw	r2,-16(fp)
 d0190d4:	10c00845 	stb	r3,33(r2)
 d0190d8:	00002c06 	br	d01918c <altera_avalon_lcd_16207_write+0x2e0>
    }
    else if (isprint(c))
 d0190dc:	e0bff707 	ldb	r2,-36(fp)
 d0190e0:	1007883a 	mov	r3,r2
 d0190e4:	00834174 	movhi	r2,3333
 d0190e8:	108a2104 	addi	r2,r2,10372
 d0190ec:	10800017 	ldw	r2,0(r2)
 d0190f0:	1885883a 	add	r2,r3,r2
 d0190f4:	10800003 	ldbu	r2,0(r2)
 d0190f8:	10803fcc 	andi	r2,r2,255
 d0190fc:	1080201c 	xori	r2,r2,128
 d019100:	10bfe004 	addi	r2,r2,-128
 d019104:	108025cc 	andi	r2,r2,151
 d019108:	1005003a 	cmpeq	r2,r2,zero
 d01910c:	10001f1e 	bne	r2,zero,d01918c <altera_avalon_lcd_16207_write+0x2e0>
    {
      /* If we didn't scroll on the last linefeed then we might need to do
       * it now. */
      if (sp->y >= ALT_LCD_HEIGHT)
 d019110:	e0bffc17 	ldw	r2,-16(fp)
 d019114:	10800883 	ldbu	r2,34(r2)
 d019118:	10803fcc 	andi	r2,r2,255
 d01911c:	108000b0 	cmpltui	r2,r2,2
 d019120:	1000021e 	bne	r2,zero,d01912c <altera_avalon_lcd_16207_write+0x280>
        lcd_scroll_up(sp);
 d019124:	e13ffc17 	ldw	r4,-16(fp)
 d019128:	d018b140 	call	d018b14 <lcd_scroll_up>

      if (sp->x < ALT_LCD_VIRTUAL_WIDTH)
 d01912c:	e0bffc17 	ldw	r2,-16(fp)
 d019130:	10800843 	ldbu	r2,33(r2)
 d019134:	10803fcc 	andi	r2,r2,255
 d019138:	10801428 	cmpgeui	r2,r2,80
 d01913c:	10000d1e 	bne	r2,zero,d019174 <altera_avalon_lcd_16207_write+0x2c8>
        sp->line[sp->y].data[sp->x] = c;
 d019140:	e0bffc17 	ldw	r2,-16(fp)
 d019144:	10800883 	ldbu	r2,34(r2)
 d019148:	11003fcc 	andi	r4,r2,255
 d01914c:	e0bffc17 	ldw	r2,-16(fp)
 d019150:	10800843 	ldbu	r2,33(r2)
 d019154:	11403fcc 	andi	r5,r2,255
 d019158:	e0fffc17 	ldw	r3,-16(fp)
 d01915c:	208018e4 	muli	r2,r4,99
 d019160:	10c5883a 	add	r2,r2,r3
 d019164:	1145883a 	add	r2,r2,r5
 d019168:	10c01004 	addi	r3,r2,64
 d01916c:	e0bff703 	ldbu	r2,-36(fp)
 d019170:	18800005 	stb	r2,0(r3)

      sp->x++;
 d019174:	e0bffc17 	ldw	r2,-16(fp)
 d019178:	10800843 	ldbu	r2,33(r2)
 d01917c:	10800044 	addi	r2,r2,1
 d019180:	1007883a 	mov	r3,r2
 d019184:	e0bffc17 	ldw	r2,-16(fp)
 d019188:	10c00845 	stb	r3,33(r2)

  /* Tell the routine which is called off the timer interrupt that the
   * foreground routines are active so it must not repaint the display. */
  sp->active = 1;

  for ( ; ptr < end ; ptr++)
 d01918c:	e0bffd17 	ldw	r2,-12(fp)
 d019190:	10800044 	addi	r2,r2,1
 d019194:	e0bffd15 	stw	r2,-12(fp)
 d019198:	e0fffd17 	ldw	r3,-12(fp)
 d01919c:	e0bffa17 	ldw	r2,-24(fp)
 d0191a0:	18bf5b36 	bltu	r3,r2,d018f10 <altera_avalon_lcd_16207_write+0x64>
      sp->x++;
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
 d0191a4:	00800404 	movi	r2,16
 d0191a8:	e0bff815 	stw	r2,-32(fp)
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d0191ac:	e03ff915 	stw	zero,-28(fp)
 d0191b0:	00003606 	br	d01928c <altera_avalon_lcd_16207_write+0x3e0>
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 d0191b4:	00801404 	movi	r2,80
 d0191b8:	e0bff515 	stw	r2,-44(fp)
 d0191bc:	00001106 	br	d019204 <altera_avalon_lcd_16207_write+0x358>
      if (sp->line[y].data[width-1] != ' ')
 d0191c0:	e13ff917 	ldw	r4,-28(fp)
 d0191c4:	e0bff517 	ldw	r2,-44(fp)
 d0191c8:	117fffc4 	addi	r5,r2,-1
 d0191cc:	e0fffc17 	ldw	r3,-16(fp)
 d0191d0:	208018e4 	muli	r2,r4,99
 d0191d4:	10c5883a 	add	r2,r2,r3
 d0191d8:	1145883a 	add	r2,r2,r5
 d0191dc:	10801004 	addi	r2,r2,64
 d0191e0:	10800003 	ldbu	r2,0(r2)
 d0191e4:	10803fcc 	andi	r2,r2,255
 d0191e8:	1080201c 	xori	r2,r2,128
 d0191ec:	10bfe004 	addi	r2,r2,-128
 d0191f0:	10800818 	cmpnei	r2,r2,32
 d0191f4:	1000061e 	bne	r2,zero,d019210 <altera_avalon_lcd_16207_write+0x364>
  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
  {
    int width;
    for (width = ALT_LCD_VIRTUAL_WIDTH ; width > 0 ; width--)
 d0191f8:	e0bff517 	ldw	r2,-44(fp)
 d0191fc:	10bfffc4 	addi	r2,r2,-1
 d019200:	e0bff515 	stw	r2,-44(fp)
 d019204:	e0bff517 	ldw	r2,-44(fp)
 d019208:	10800048 	cmpgei	r2,r2,1
 d01920c:	103fec1e 	bne	r2,zero,d0191c0 <altera_avalon_lcd_16207_write+0x314>

    /* The minimum width is the size of the LCD panel.  If the real width
     * is long enough to require scrolling then add an extra space so the
     * end of the message doesn't run into the beginning of it.
     */
    if (width <= ALT_LCD_WIDTH)
 d019210:	e0bff517 	ldw	r2,-44(fp)
 d019214:	10800448 	cmpgei	r2,r2,17
 d019218:	1000031e 	bne	r2,zero,d019228 <altera_avalon_lcd_16207_write+0x37c>
      width = ALT_LCD_WIDTH;
 d01921c:	00800404 	movi	r2,16
 d019220:	e0bff515 	stw	r2,-44(fp)
 d019224:	00000306 	br	d019234 <altera_avalon_lcd_16207_write+0x388>
    else
      width++;
 d019228:	e0bff517 	ldw	r2,-44(fp)
 d01922c:	10800044 	addi	r2,r2,1
 d019230:	e0bff515 	stw	r2,-44(fp)

    sp->line[y].width = width;
 d019234:	e13ff917 	ldw	r4,-28(fp)
 d019238:	e0bff517 	ldw	r2,-44(fp)
 d01923c:	100b883a 	mov	r5,r2
 d019240:	e0fffc17 	ldw	r3,-16(fp)
 d019244:	208018e4 	muli	r2,r4,99
 d019248:	10c5883a 	add	r2,r2,r3
 d01924c:	10802404 	addi	r2,r2,144
 d019250:	11400045 	stb	r5,1(r2)
    if (widthmax < width)
 d019254:	e0fff817 	ldw	r3,-32(fp)
 d019258:	e0bff517 	ldw	r2,-44(fp)
 d01925c:	1880020e 	bge	r3,r2,d019268 <altera_avalon_lcd_16207_write+0x3bc>
      widthmax = width;
 d019260:	e0bff517 	ldw	r2,-44(fp)
 d019264:	e0bff815 	stw	r2,-32(fp)
    sp->line[y].speed = 0; /* By default lines don't scroll */
 d019268:	e0bff917 	ldw	r2,-28(fp)
 d01926c:	e0fffc17 	ldw	r3,-16(fp)
 d019270:	108018e4 	muli	r2,r2,99
 d019274:	10c5883a 	add	r2,r2,r3
 d019278:	10802404 	addi	r2,r2,144
 d01927c:	10000085 	stb	zero,2(r2)
    }
  }

  /* Recalculate the scrolling parameters */
  widthmax = ALT_LCD_WIDTH;
  for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d019280:	e0bff917 	ldw	r2,-28(fp)
 d019284:	10800044 	addi	r2,r2,1
 d019288:	e0bff915 	stw	r2,-28(fp)
 d01928c:	e0bff917 	ldw	r2,-28(fp)
 d019290:	10800090 	cmplti	r2,r2,2
 d019294:	103fc71e 	bne	r2,zero,d0191b4 <altera_avalon_lcd_16207_write+0x308>
    if (widthmax < width)
      widthmax = width;
    sp->line[y].speed = 0; /* By default lines don't scroll */
  }

  if (widthmax <= ALT_LCD_WIDTH)
 d019298:	e0bff817 	ldw	r2,-32(fp)
 d01929c:	10800448 	cmpgei	r2,r2,17
 d0192a0:	1000031e 	bne	r2,zero,d0192b0 <altera_avalon_lcd_16207_write+0x404>
    sp->scrollmax = 0;
 d0192a4:	e0bffc17 	ldw	r2,-16(fp)
 d0192a8:	10000985 	stb	zero,38(r2)
 d0192ac:	00002d06 	br	d019364 <altera_avalon_lcd_16207_write+0x4b8>
  else
  {
    widthmax *= 2;
 d0192b0:	e0bff817 	ldw	r2,-32(fp)
 d0192b4:	1085883a 	add	r2,r2,r2
 d0192b8:	e0bff815 	stw	r2,-32(fp)
    sp->scrollmax = widthmax;
 d0192bc:	e0bff817 	ldw	r2,-32(fp)
 d0192c0:	1007883a 	mov	r3,r2
 d0192c4:	e0bffc17 	ldw	r2,-16(fp)
 d0192c8:	10c00985 	stb	r3,38(r2)

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d0192cc:	e03ff915 	stw	zero,-28(fp)
 d0192d0:	00002106 	br	d019358 <altera_avalon_lcd_16207_write+0x4ac>
      if (sp->line[y].width > ALT_LCD_WIDTH)
 d0192d4:	e0bff917 	ldw	r2,-28(fp)
 d0192d8:	e0fffc17 	ldw	r3,-16(fp)
 d0192dc:	108018e4 	muli	r2,r2,99
 d0192e0:	10c5883a 	add	r2,r2,r3
 d0192e4:	10802404 	addi	r2,r2,144
 d0192e8:	10800043 	ldbu	r2,1(r2)
 d0192ec:	10803fcc 	andi	r2,r2,255
 d0192f0:	1080201c 	xori	r2,r2,128
 d0192f4:	10bfe004 	addi	r2,r2,-128
 d0192f8:	10800450 	cmplti	r2,r2,17
 d0192fc:	1000131e 	bne	r2,zero,d01934c <altera_avalon_lcd_16207_write+0x4a0>
         */
#if 1
        /* This option makes all the lines scroll round at different speeds
         * which are chosen so that all the scrolls finish at the same time.
         */
        sp->line[y].speed = 256 * sp->line[y].width / widthmax;
 d019300:	e17ff917 	ldw	r5,-28(fp)
 d019304:	e0bff917 	ldw	r2,-28(fp)
 d019308:	e0fffc17 	ldw	r3,-16(fp)
 d01930c:	108018e4 	muli	r2,r2,99
 d019310:	10c5883a 	add	r2,r2,r3
 d019314:	10802404 	addi	r2,r2,144
 d019318:	10800043 	ldbu	r2,1(r2)
 d01931c:	10803fcc 	andi	r2,r2,255
 d019320:	1080201c 	xori	r2,r2,128
 d019324:	10bfe004 	addi	r2,r2,-128
 d019328:	1006923a 	slli	r3,r2,8
 d01932c:	e0bff817 	ldw	r2,-32(fp)
 d019330:	1885283a 	div	r2,r3,r2
 d019334:	1009883a 	mov	r4,r2
 d019338:	e0fffc17 	ldw	r3,-16(fp)
 d01933c:	288018e4 	muli	r2,r5,99
 d019340:	10c5883a 	add	r2,r2,r3
 d019344:	10802404 	addi	r2,r2,144
 d019348:	11000085 	stb	r4,2(r2)
  {
    widthmax *= 2;
    sp->scrollmax = widthmax;

    /* Now calculate how fast each of the other lines should go */
    for (y = 0 ; y < ALT_LCD_HEIGHT ; y++)
 d01934c:	e0bff917 	ldw	r2,-28(fp)
 d019350:	10800044 	addi	r2,r2,1
 d019354:	e0bff915 	stw	r2,-28(fp)
 d019358:	e0bff917 	ldw	r2,-28(fp)
 d01935c:	10800090 	cmplti	r2,r2,2
 d019360:	103fdc1e 	bne	r2,zero,d0192d4 <altera_avalon_lcd_16207_write+0x428>
   * (because active was set when the timer interrupt occurred).  If there
   * has been a missed repaint then paint again.  And again.  etc.
   */
  for ( ; ; )
  {
    int old_scrollpos = sp->scrollpos;
 d019364:	e0bffc17 	ldw	r2,-16(fp)
 d019368:	10800943 	ldbu	r2,37(r2)
 d01936c:	10803fcc 	andi	r2,r2,255
 d019370:	1080201c 	xori	r2,r2,128
 d019374:	10bfe004 	addi	r2,r2,-128
 d019378:	e0bff415 	stw	r2,-48(fp)

    lcd_repaint_screen(sp);
 d01937c:	e13ffc17 	ldw	r4,-16(fp)
 d019380:	d0189280 	call	d018928 <lcd_repaint_screen>

    /* Let the timer routines repaint the display again */
    sp->active = 0;
 d019384:	e0bffc17 	ldw	r2,-16(fp)
 d019388:	100009c5 	stb	zero,39(r2)

    /* Have the timer routines tried to scroll while we were painting?
     * If not then we can exit */
    if (sp->scrollpos == old_scrollpos)
 d01938c:	e0bffc17 	ldw	r2,-16(fp)
 d019390:	10800943 	ldbu	r2,37(r2)
 d019394:	10c03fcc 	andi	r3,r2,255
 d019398:	18c0201c 	xori	r3,r3,128
 d01939c:	18ffe004 	addi	r3,r3,-128
 d0193a0:	e0bff417 	ldw	r2,-48(fp)
 d0193a4:	18800426 	beq	r3,r2,d0193b8 <altera_avalon_lcd_16207_write+0x50c>
      break;

    /* We need to repaint again since the display scrolled while we were
     * painting last time */
    sp->active = 1;
 d0193a8:	e0fffc17 	ldw	r3,-16(fp)
 d0193ac:	00800044 	movi	r2,1
 d0193b0:	188009c5 	stb	r2,39(r3)
  }
 d0193b4:	003feb06 	br	d019364 <altera_avalon_lcd_16207_write+0x4b8>

  /* Now that access to the display is complete, release the write
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->write_lock);
 d0193b8:	e0bffc17 	ldw	r2,-16(fp)
 d0193bc:	11003e17 	ldw	r4,248(r2)
 d0193c0:	d01364c0 	call	d01364c <OSSemPost>

  return len;
 d0193c4:	e0bffe17 	ldw	r2,-8(fp)
}
 d0193c8:	e037883a 	mov	sp,fp
 d0193cc:	dfc00117 	ldw	ra,4(sp)
 d0193d0:	df000017 	ldw	fp,0(sp)
 d0193d4:	dec00204 	addi	sp,sp,8
 d0193d8:	f800283a 	ret

0d0193dc <alt_lcd_16207_timeout>:
/*
 * Timeout routine is called every second
 */

static alt_u32 alt_lcd_16207_timeout(void* context) 
{
 d0193dc:	defffc04 	addi	sp,sp,-16
 d0193e0:	dfc00315 	stw	ra,12(sp)
 d0193e4:	df000215 	stw	fp,8(sp)
 d0193e8:	df000204 	addi	fp,sp,8
 d0193ec:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_lcd_16207_state* sp = (altera_avalon_lcd_16207_state*)context;
 d0193f0:	e0bfff17 	ldw	r2,-4(fp)
 d0193f4:	e0bffe15 	stw	r2,-8(fp)

  /* Update the scrolling position */
  if (sp->scrollpos + 1 >= sp->scrollmax)
 d0193f8:	e0bffe17 	ldw	r2,-8(fp)
 d0193fc:	10800943 	ldbu	r2,37(r2)
 d019400:	10803fcc 	andi	r2,r2,255
 d019404:	1080201c 	xori	r2,r2,128
 d019408:	10bfe004 	addi	r2,r2,-128
 d01940c:	10c00044 	addi	r3,r2,1
 d019410:	e0bffe17 	ldw	r2,-8(fp)
 d019414:	10800983 	ldbu	r2,38(r2)
 d019418:	10803fcc 	andi	r2,r2,255
 d01941c:	1080201c 	xori	r2,r2,128
 d019420:	10bfe004 	addi	r2,r2,-128
 d019424:	18800316 	blt	r3,r2,d019434 <alt_lcd_16207_timeout+0x58>
    sp->scrollpos = 0;
 d019428:	e0bffe17 	ldw	r2,-8(fp)
 d01942c:	10000945 	stb	zero,37(r2)
 d019430:	00000606 	br	d01944c <alt_lcd_16207_timeout+0x70>
  else
    sp->scrollpos = sp->scrollpos + 1;
 d019434:	e0bffe17 	ldw	r2,-8(fp)
 d019438:	10800943 	ldbu	r2,37(r2)
 d01943c:	10800044 	addi	r2,r2,1
 d019440:	1007883a 	mov	r3,r2
 d019444:	e0bffe17 	ldw	r2,-8(fp)
 d019448:	10c00945 	stb	r3,37(r2)

  /* Repaint the panel unless the foreground will do it again soon */
  if (sp->scrollmax > 0 && !sp->active)
 d01944c:	e0bffe17 	ldw	r2,-8(fp)
 d019450:	10800983 	ldbu	r2,38(r2)
 d019454:	10803fcc 	andi	r2,r2,255
 d019458:	1080201c 	xori	r2,r2,128
 d01945c:	10bfe004 	addi	r2,r2,-128
 d019460:	10800050 	cmplti	r2,r2,1
 d019464:	1000091e 	bne	r2,zero,d01948c <alt_lcd_16207_timeout+0xb0>
 d019468:	e0bffe17 	ldw	r2,-8(fp)
 d01946c:	108009c3 	ldbu	r2,39(r2)
 d019470:	10803fcc 	andi	r2,r2,255
 d019474:	1080201c 	xori	r2,r2,128
 d019478:	10bfe004 	addi	r2,r2,-128
 d01947c:	1004c03a 	cmpne	r2,r2,zero
 d019480:	1000021e 	bne	r2,zero,d01948c <alt_lcd_16207_timeout+0xb0>
    lcd_repaint_screen(sp);
 d019484:	e13ffe17 	ldw	r4,-8(fp)
 d019488:	d0189280 	call	d018928 <lcd_repaint_screen>

  return sp->period;
 d01948c:	e0bffe17 	ldw	r2,-8(fp)
 d019490:	10800717 	ldw	r2,28(r2)
}
 d019494:	e037883a 	mov	sp,fp
 d019498:	dfc00117 	ldw	ra,4(sp)
 d01949c:	df000017 	ldw	fp,0(sp)
 d0194a0:	dec00204 	addi	sp,sp,8
 d0194a4:	f800283a 	ret

0d0194a8 <altera_avalon_lcd_16207_init>:

/*
 * Called at boot time to initialise the LCD driver
 */
void altera_avalon_lcd_16207_init(altera_avalon_lcd_16207_state* sp)
{
 d0194a8:	defffa04 	addi	sp,sp,-24
 d0194ac:	dfc00515 	stw	ra,20(sp)
 d0194b0:	df000415 	stw	fp,16(sp)
 d0194b4:	df000404 	addi	fp,sp,16
 d0194b8:	e13fff15 	stw	r4,-4(fp)
  unsigned int base = sp->base;
 d0194bc:	e0bfff17 	ldw	r2,-4(fp)
 d0194c0:	10800017 	ldw	r2,0(r2)
 d0194c4:	e0bffe15 	stw	r2,-8(fp)

  /* Mark the device as functional */
  sp->broken = 0;
 d0194c8:	e0bfff17 	ldw	r2,-4(fp)
 d0194cc:	10000805 	stb	zero,32(r2)

  ALT_SEM_CREATE (&sp->write_lock, 1);
 d0194d0:	e0bfff17 	ldw	r2,-4(fp)
 d0194d4:	10803e04 	addi	r2,r2,248
 d0194d8:	e0bffc15 	stw	r2,-16(fp)
 d0194dc:	00800044 	movi	r2,1
 d0194e0:	e0bffd0d 	sth	r2,-12(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 d0194e4:	e13ffd0b 	ldhu	r4,-12(fp)
 d0194e8:	d012ea00 	call	d012ea0 <OSSemCreate>
 d0194ec:	1007883a 	mov	r3,r2
 d0194f0:	e0bffc17 	ldw	r2,-16(fp)
 d0194f4:	10c00015 	stw	r3,0(r2)
   * the BUSY bit in the status register doesn't work until the display
   * has been reset three times.
   */

  /* Wait for 15 ms then reset */
  usleep(15000);
 d0194f8:	010ea604 	movi	r4,15000
 d0194fc:	d0398d00 	call	d0398d0 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 d019500:	e0bffe17 	ldw	r2,-8(fp)
 d019504:	1007883a 	mov	r3,r2
 d019508:	00800c04 	movi	r2,48
 d01950c:	18800035 	stwio	r2,0(r3)

  /* Wait for another 4.1ms and reset again */
  usleep(4100);  
 d019510:	01040104 	movi	r4,4100
 d019514:	d0398d00 	call	d0398d0 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 d019518:	e0bffe17 	ldw	r2,-8(fp)
 d01951c:	1007883a 	mov	r3,r2
 d019520:	00800c04 	movi	r2,48
 d019524:	18800035 	stwio	r2,0(r3)

  /* Wait a further 1 ms and reset a third time */
  usleep(1000);
 d019528:	0100fa04 	movi	r4,1000
 d01952c:	d0398d00 	call	d0398d0 <usleep>
  IOWR_ALTERA_AVALON_LCD_16207_COMMAND(base, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT);
 d019530:	e0bffe17 	ldw	r2,-8(fp)
 d019534:	1007883a 	mov	r3,r2
 d019538:	00800c04 	movi	r2,48
 d01953c:	18800035 	stwio	r2,0(r3)

  /* Setup interface parameters: 8 bit bus, 2 rows, 5x7 font */
  lcd_write_command(sp, LCD_CMD_FUNCTION_SET | LCD_CMD_8BIT | LCD_CMD_TWO_LINE);
 d019540:	e13fff17 	ldw	r4,-4(fp)
 d019544:	01400e04 	movi	r5,56
 d019548:	d0186d80 	call	d0186d8 <lcd_write_command>
  
  /* Turn display off */
  lcd_write_command(sp, LCD_CMD_ONOFF);
 d01954c:	e13fff17 	ldw	r4,-4(fp)
 d019550:	01400204 	movi	r5,8
 d019554:	d0186d80 	call	d0186d8 <lcd_write_command>

  /* Clear display */
  lcd_clear_screen(sp);
 d019558:	e13fff17 	ldw	r4,-4(fp)
 d01955c:	d0188640 	call	d018864 <lcd_clear_screen>
  
  /* Set mode: increment after writing, don't shift display */
  lcd_write_command(sp, LCD_CMD_MODES | LCD_CMD_MODE_INC);
 d019560:	e13fff17 	ldw	r4,-4(fp)
 d019564:	01400184 	movi	r5,6
 d019568:	d0186d80 	call	d0186d8 <lcd_write_command>

  /* Turn display on */
  lcd_write_command(sp, LCD_CMD_ONOFF | LCD_CMD_ENABLE_DISP);
 d01956c:	e13fff17 	ldw	r4,-4(fp)
 d019570:	01400304 	movi	r5,12
 d019574:	d0186d80 	call	d0186d8 <lcd_write_command>

  sp->esccount = -1;
 d019578:	e0ffff17 	ldw	r3,-4(fp)
 d01957c:	00bfffc4 	movi	r2,-1
 d019580:	18800905 	stb	r2,36(r3)
  memset(sp->escape, 0, sizeof(sp->escape));
 d019584:	e0bfff17 	ldw	r2,-4(fp)
 d019588:	11000a04 	addi	r4,r2,40
 d01958c:	000b883a 	mov	r5,zero
 d019590:	01800204 	movi	r6,8
 d019594:	d0028800 	call	d002880 <memset>

  sp->scrollpos = 0;
 d019598:	e0bfff17 	ldw	r2,-4(fp)
 d01959c:	10000945 	stb	zero,37(r2)
  sp->scrollmax = 0;
 d0195a0:	e0bfff17 	ldw	r2,-4(fp)
 d0195a4:	10000985 	stb	zero,38(r2)
  sp->active = 0;
 d0195a8:	e0bfff17 	ldw	r2,-4(fp)
 d0195ac:	100009c5 	stb	zero,39(r2)
 d0195b0:	00834174 	movhi	r2,3333
 d0195b4:	108ad904 	addi	r2,r2,11108
 d0195b8:	10800017 	ldw	r2,0(r2)
 d0195bc:	1007883a 	mov	r3,r2

  sp->period = alt_ticks_per_second() / 10; /* Call every 100ms */
 d0195c0:	00800284 	movi	r2,10
 d0195c4:	1885203a 	divu	r2,r3,r2
 d0195c8:	1007883a 	mov	r3,r2
 d0195cc:	e0bfff17 	ldw	r2,-4(fp)
 d0195d0:	10c00715 	stw	r3,28(r2)

  alt_alarm_start(&sp->alarm, sp->period, &alt_lcd_16207_timeout, sp);
 d0195d4:	e0bfff17 	ldw	r2,-4(fp)
 d0195d8:	11000104 	addi	r4,r2,4
 d0195dc:	e0bfff17 	ldw	r2,-4(fp)
 d0195e0:	10800717 	ldw	r2,28(r2)
 d0195e4:	100b883a 	mov	r5,r2
 d0195e8:	018340b4 	movhi	r6,3330
 d0195ec:	31a4f704 	addi	r6,r6,-27684
 d0195f0:	e1ffff17 	ldw	r7,-4(fp)
 d0195f4:	d0387dc0 	call	d0387dc <alt_alarm_start>
}
 d0195f8:	e037883a 	mov	sp,fp
 d0195fc:	dfc00117 	ldw	ra,4(sp)
 d019600:	df000017 	ldw	fp,0(sp)
 d019604:	dec00204 	addi	sp,sp,8
 d019608:	f800283a 	ret

0d01960c <altera_avalon_lcd_16207_write_fd>:
extern int altera_avalon_lcd_16207_write(altera_avalon_lcd_16207_state* sp,
  const char* ptr, int count, int flags);

int 
altera_avalon_lcd_16207_write_fd(alt_fd* fd, const char* buffer, int space)
{
 d01960c:	defffa04 	addi	sp,sp,-24
 d019610:	dfc00515 	stw	ra,20(sp)
 d019614:	df000415 	stw	fp,16(sp)
 d019618:	df000404 	addi	fp,sp,16
 d01961c:	e13ffd15 	stw	r4,-12(fp)
 d019620:	e17ffe15 	stw	r5,-8(fp)
 d019624:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_lcd_16207_dev* dev = (altera_avalon_lcd_16207_dev*) fd->dev; 
 d019628:	e0bffd17 	ldw	r2,-12(fp)
 d01962c:	10800017 	ldw	r2,0(r2)
 d019630:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_lcd_16207_write(&dev->state, buffer, space,
 d019634:	e0bffc17 	ldw	r2,-16(fp)
 d019638:	11000a04 	addi	r4,r2,40
 d01963c:	e0bffd17 	ldw	r2,-12(fp)
 d019640:	11c00217 	ldw	r7,8(r2)
 d019644:	e17ffe17 	ldw	r5,-8(fp)
 d019648:	e1bfff17 	ldw	r6,-4(fp)
 d01964c:	d018eac0 	call	d018eac <altera_avalon_lcd_16207_write>
      fd->fd_flags);
}
 d019650:	e037883a 	mov	sp,fp
 d019654:	dfc00117 	ldw	ra,4(sp)
 d019658:	df000017 	ldw	fp,0(sp)
 d01965c:	dec00204 	addi	sp,sp,8
 d019660:	f800283a 	ret

0d019664 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 d019664:	defffb04 	addi	sp,sp,-20
 d019668:	df000415 	stw	fp,16(sp)
 d01966c:	df000404 	addi	fp,sp,16
 d019670:	e13ffd15 	stw	r4,-12(fp)
 d019674:	e17ffe15 	stw	r5,-8(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 d019678:	e0bffd17 	ldw	r2,-12(fp)
 d01967c:	10800317 	ldw	r2,12(r2)
 d019680:	10800037 	ldwio	r2,0(r2)
 d019684:	1080040c 	andi	r2,r2,16
 d019688:	1005003a 	cmpeq	r2,r2,zero
 d01968c:	1000031e 	bne	r2,zero,d01969c <alt_avalon_sgdma_do_async_transfer+0x38>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 d019690:	00bffc04 	movi	r2,-16
 d019694:	e0bfff15 	stw	r2,-4(fp)
 d019698:	00003c06 	br	d01978c <alt_avalon_sgdma_do_async_transfer+0x128>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d01969c:	e0bffd17 	ldw	r2,-12(fp)
 d0196a0:	10800317 	ldw	r2,12(r2)
 d0196a4:	11000404 	addi	r4,r2,16
 d0196a8:	e0bffd17 	ldw	r2,-12(fp)
 d0196ac:	10800317 	ldw	r2,12(r2)
 d0196b0:	10800404 	addi	r2,r2,16
 d0196b4:	10c00037 	ldwio	r3,0(r2)
 d0196b8:	00bff7c4 	movi	r2,-33
 d0196bc:	1886703a 	and	r3,r3,r2
 d0196c0:	2005883a 	mov	r2,r4
 d0196c4:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 d0196c8:	e0bffd17 	ldw	r2,-12(fp)
 d0196cc:	10800317 	ldw	r2,12(r2)
 d0196d0:	1007883a 	mov	r3,r2
 d0196d4:	00803fc4 	movi	r2,255
 d0196d8:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 d0196dc:	e0bffd17 	ldw	r2,-12(fp)
 d0196e0:	10800317 	ldw	r2,12(r2)
 d0196e4:	10800804 	addi	r2,r2,32
 d0196e8:	e0fffe17 	ldw	r3,-8(fp)
 d0196ec:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 d0196f0:	e0bffd17 	ldw	r2,-12(fp)
 d0196f4:	10800917 	ldw	r2,36(r2)
 d0196f8:	1005003a 	cmpeq	r2,r2,zero
 d0196fc:	1000111e 	bne	r2,zero,d019744 <alt_avalon_sgdma_do_async_transfer+0xe0>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019700:	e0bffd17 	ldw	r2,-12(fp)
 d019704:	10800317 	ldw	r2,12(r2)
 d019708:	10800404 	addi	r2,r2,16
 d01970c:	10800037 	ldwio	r2,0(r2)
 d019710:	e0bffc15 	stw	r2,-16(fp)

    control |= (dev->chain_control                          |
 d019714:	e0bffd17 	ldw	r2,-12(fp)
 d019718:	10c00b17 	ldw	r3,44(r2)
 d01971c:	e0bffc17 	ldw	r2,-16(fp)
 d019720:	1884b03a 	or	r2,r3,r2
 d019724:	10801814 	ori	r2,r2,96
 d019728:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d01972c:	e0bffd17 	ldw	r2,-12(fp)
 d019730:	10800317 	ldw	r2,12(r2)
 d019734:	10800404 	addi	r2,r2,16
 d019738:	e0fffc17 	ldw	r3,-16(fp)
 d01973c:	10c00035 	stwio	r3,0(r2)
 d019740:	00001106 	br	d019788 <alt_avalon_sgdma_do_async_transfer+0x124>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019744:	e0bffd17 	ldw	r2,-12(fp)
 d019748:	10800317 	ldw	r2,12(r2)
 d01974c:	10800404 	addi	r2,r2,16
 d019750:	10800037 	ldwio	r2,0(r2)
 d019754:	e0bffc15 	stw	r2,-16(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 d019758:	e0bffc17 	ldw	r2,-16(fp)
 d01975c:	10801814 	ori	r2,r2,96
 d019760:	e0bffc15 	stw	r2,-16(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 d019764:	e0fffc17 	ldw	r3,-16(fp)
 d019768:	00bffbc4 	movi	r2,-17
 d01976c:	1884703a 	and	r2,r3,r2
 d019770:	e0bffc15 	stw	r2,-16(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019774:	e0bffd17 	ldw	r2,-12(fp)
 d019778:	10800317 	ldw	r2,12(r2)
 d01977c:	10800404 	addi	r2,r2,16
 d019780:	e0fffc17 	ldw	r3,-16(fp)
 d019784:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 d019788:	e03fff15 	stw	zero,-4(fp)
 d01978c:	e0bfff17 	ldw	r2,-4(fp)
}
 d019790:	e037883a 	mov	sp,fp
 d019794:	df000017 	ldw	fp,0(sp)
 d019798:	dec00104 	addi	sp,sp,4
 d01979c:	f800283a 	ret

0d0197a0 <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 d0197a0:	defffc04 	addi	sp,sp,-16
 d0197a4:	df000315 	stw	fp,12(sp)
 d0197a8:	df000304 	addi	fp,sp,12
 d0197ac:	e13ffe15 	stw	r4,-8(fp)
 d0197b0:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 d0197b4:	e0bffe17 	ldw	r2,-8(fp)
 d0197b8:	10800317 	ldw	r2,12(r2)
 d0197bc:	10800037 	ldwio	r2,0(r2)
 d0197c0:	1080040c 	andi	r2,r2,16
 d0197c4:	1004c03a 	cmpne	r2,r2,zero
 d0197c8:	103ffa1e 	bne	r2,zero,d0197b4 <alt_avalon_sgdma_do_sync_transfer+0x14>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d0197cc:	e0bffe17 	ldw	r2,-8(fp)
 d0197d0:	10800317 	ldw	r2,12(r2)
 d0197d4:	11000404 	addi	r4,r2,16
 d0197d8:	e0bffe17 	ldw	r2,-8(fp)
 d0197dc:	10800317 	ldw	r2,12(r2)
 d0197e0:	10800404 	addi	r2,r2,16
 d0197e4:	10c00037 	ldwio	r3,0(r2)
 d0197e8:	00bff7c4 	movi	r2,-33
 d0197ec:	1886703a 	and	r3,r3,r2
 d0197f0:	2005883a 	mov	r2,r4
 d0197f4:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 d0197f8:	e0bffe17 	ldw	r2,-8(fp)
 d0197fc:	10800317 	ldw	r2,12(r2)
 d019800:	1007883a 	mov	r3,r2
 d019804:	00803fc4 	movi	r2,255
 d019808:	18800035 	stwio	r2,0(r3)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 d01980c:	e0bffe17 	ldw	r2,-8(fp)
 d019810:	10800317 	ldw	r2,12(r2)
 d019814:	10800804 	addi	r2,r2,32
 d019818:	e0ffff17 	ldw	r3,-4(fp)
 d01981c:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d019820:	e0bffe17 	ldw	r2,-8(fp)
 d019824:	10800317 	ldw	r2,12(r2)
 d019828:	11000404 	addi	r4,r2,16
 d01982c:	e0bffe17 	ldw	r2,-8(fp)
 d019830:	10800317 	ldw	r2,12(r2)
 d019834:	10800404 	addi	r2,r2,16
 d019838:	10800037 	ldwio	r2,0(r2)
 d01983c:	10c01814 	ori	r3,r2,96
 d019840:	2005883a 	mov	r2,r4
 d019844:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 d019848:	e0bffe17 	ldw	r2,-8(fp)
 d01984c:	10800317 	ldw	r2,12(r2)
 d019850:	10800037 	ldwio	r2,0(r2)
 d019854:	1080040c 	andi	r2,r2,16
 d019858:	1004c03a 	cmpne	r2,r2,zero
 d01985c:	103ffa1e 	bne	r2,zero,d019848 <alt_avalon_sgdma_do_sync_transfer+0xa8>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 d019860:	e0bffe17 	ldw	r2,-8(fp)
 d019864:	10800317 	ldw	r2,12(r2)
 d019868:	11000404 	addi	r4,r2,16
 d01986c:	e0bffe17 	ldw	r2,-8(fp)
 d019870:	10800317 	ldw	r2,12(r2)
 d019874:	10800404 	addi	r2,r2,16
 d019878:	10c00037 	ldwio	r3,0(r2)
 d01987c:	00bff7c4 	movi	r2,-33
 d019880:	1886703a 	and	r3,r3,r2
 d019884:	2005883a 	mov	r2,r4
 d019888:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 d01988c:	e0bffe17 	ldw	r2,-8(fp)
 d019890:	10800317 	ldw	r2,12(r2)
 d019894:	10800037 	ldwio	r2,0(r2)
 d019898:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 d01989c:	e0bffe17 	ldw	r2,-8(fp)
 d0198a0:	10800317 	ldw	r2,12(r2)
 d0198a4:	1007883a 	mov	r3,r2
 d0198a8:	00803fc4 	movi	r2,255
 d0198ac:	18800035 	stwio	r2,0(r3)

  return status;
 d0198b0:	e0bffd03 	ldbu	r2,-12(fp)
}
 d0198b4:	e037883a 	mov	sp,fp
 d0198b8:	df000017 	ldw	fp,0(sp)
 d0198bc:	dec00104 	addi	sp,sp,4
 d0198c0:	f800283a 	ret

0d0198c4 <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 d0198c4:	defff404 	addi	sp,sp,-48
 d0198c8:	dfc00b15 	stw	ra,44(sp)
 d0198cc:	df000a15 	stw	fp,40(sp)
 d0198d0:	df000a04 	addi	fp,sp,40
 d0198d4:	e13ffb15 	stw	r4,-20(fp)
 d0198d8:	e17ffc15 	stw	r5,-16(fp)
 d0198dc:	e1bffd15 	stw	r6,-12(fp)
 d0198e0:	e1fffe15 	stw	r7,-8(fp)
 d0198e4:	e0800217 	ldw	r2,8(fp)
 d0198e8:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 d0198ec:	e0bfff0b 	ldhu	r2,-4(fp)
 d0198f0:	d8800015 	stw	r2,0(sp)
 d0198f4:	e0800317 	ldw	r2,12(fp)
 d0198f8:	d8800115 	stw	r2,4(sp)
 d0198fc:	e0800417 	ldw	r2,16(fp)
 d019900:	d8800215 	stw	r2,8(sp)
 d019904:	d8000315 	stw	zero,12(sp)
 d019908:	d8000415 	stw	zero,16(sp)
 d01990c:	e13ffb17 	ldw	r4,-20(fp)
 d019910:	e17ffc17 	ldw	r5,-16(fp)
 d019914:	e1bffd17 	ldw	r6,-12(fp)
 d019918:	e1fffe17 	ldw	r7,-8(fp)
 d01991c:	d0199340 	call	d019934 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 d019920:	e037883a 	mov	sp,fp
 d019924:	dfc00117 	ldw	ra,4(sp)
 d019928:	df000017 	ldw	fp,0(sp)
 d01992c:	dec00204 	addi	sp,sp,8
 d019930:	f800283a 	ret

0d019934 <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 d019934:	defff204 	addi	sp,sp,-56
 d019938:	dfc00d15 	stw	ra,52(sp)
 d01993c:	df000c15 	stw	fp,48(sp)
 d019940:	df000c04 	addi	fp,sp,48
 d019944:	e13ffb15 	stw	r4,-20(fp)
 d019948:	e17ffc15 	stw	r5,-16(fp)
 d01994c:	e1bffd15 	stw	r6,-12(fp)
 d019950:	e1fffe15 	stw	r7,-8(fp)
 d019954:	e0800217 	ldw	r2,8(fp)
 d019958:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 d01995c:	e0bfff0b 	ldhu	r2,-4(fp)
 d019960:	d8800015 	stw	r2,0(sp)
 d019964:	d8000115 	stw	zero,4(sp)
 d019968:	e0800317 	ldw	r2,12(fp)
 d01996c:	d8800215 	stw	r2,8(sp)
 d019970:	e0800417 	ldw	r2,16(fp)
 d019974:	d8800315 	stw	r2,12(sp)
 d019978:	e0800517 	ldw	r2,20(fp)
 d01997c:	d8800415 	stw	r2,16(sp)
 d019980:	e0800617 	ldw	r2,24(fp)
 d019984:	d8800515 	stw	r2,20(sp)
 d019988:	d8000615 	stw	zero,24(sp)
 d01998c:	e13ffb17 	ldw	r4,-20(fp)
 d019990:	e17ffc17 	ldw	r5,-16(fp)
 d019994:	e1bffd17 	ldw	r6,-12(fp)
 d019998:	e1fffe17 	ldw	r7,-8(fp)
 d01999c:	d019ef40 	call	d019ef4 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 d0199a0:	e037883a 	mov	sp,fp
 d0199a4:	dfc00117 	ldw	ra,4(sp)
 d0199a8:	df000017 	ldw	fp,0(sp)
 d0199ac:	dec00204 	addi	sp,sp,8
 d0199b0:	f800283a 	ret

0d0199b4 <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 d0199b4:	defff804 	addi	sp,sp,-32
 d0199b8:	dfc00715 	stw	ra,28(sp)
 d0199bc:	df000615 	stw	fp,24(sp)
 d0199c0:	df000604 	addi	fp,sp,24
 d0199c4:	e13ffc15 	stw	r4,-16(fp)
 d0199c8:	e17ffd15 	stw	r5,-12(fp)
 d0199cc:	e1bffe15 	stw	r6,-8(fp)
 d0199d0:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 d0199d4:	e1ffff0b 	ldhu	r7,-4(fp)
 d0199d8:	e0800217 	ldw	r2,8(fp)
 d0199dc:	d8800015 	stw	r2,0(sp)
 d0199e0:	d8000115 	stw	zero,4(sp)
 d0199e4:	e13ffc17 	ldw	r4,-16(fp)
 d0199e8:	e17ffd17 	ldw	r5,-12(fp)
 d0199ec:	e1bffe17 	ldw	r6,-8(fp)
 d0199f0:	d019a080 	call	d019a08 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 d0199f4:	e037883a 	mov	sp,fp
 d0199f8:	dfc00117 	ldw	ra,4(sp)
 d0199fc:	df000017 	ldw	fp,0(sp)
 d019a00:	dec00204 	addi	sp,sp,8
 d019a04:	f800283a 	ret

0d019a08 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 d019a08:	defff304 	addi	sp,sp,-52
 d019a0c:	dfc00c15 	stw	ra,48(sp)
 d019a10:	df000b15 	stw	fp,44(sp)
 d019a14:	df000b04 	addi	fp,sp,44
 d019a18:	e13ffc15 	stw	r4,-16(fp)
 d019a1c:	e17ffd15 	stw	r5,-12(fp)
 d019a20:	e1bffe15 	stw	r6,-8(fp)
 d019a24:	e1ffff0d 	sth	r7,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 d019a28:	e0bfff0b 	ldhu	r2,-4(fp)
 d019a2c:	d8800015 	stw	r2,0(sp)
 d019a30:	d8000115 	stw	zero,4(sp)
 d019a34:	d8000215 	stw	zero,8(sp)
 d019a38:	e0800217 	ldw	r2,8(fp)
 d019a3c:	d8800315 	stw	r2,12(sp)
 d019a40:	d8000415 	stw	zero,16(sp)
 d019a44:	e0800317 	ldw	r2,12(fp)
 d019a48:	d8800515 	stw	r2,20(sp)
 d019a4c:	d8000615 	stw	zero,24(sp)
 d019a50:	e13ffc17 	ldw	r4,-16(fp)
 d019a54:	e17ffd17 	ldw	r5,-12(fp)
 d019a58:	000d883a 	mov	r6,zero
 d019a5c:	e1fffe17 	ldw	r7,-8(fp)
 d019a60:	d019ef40 	call	d019ef4 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 d019a64:	e037883a 	mov	sp,fp
 d019a68:	dfc00117 	ldw	ra,4(sp)
 d019a6c:	df000017 	ldw	fp,0(sp)
 d019a70:	dec00204 	addi	sp,sp,8
 d019a74:	f800283a 	ret

0d019a78 <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 d019a78:	defff404 	addi	sp,sp,-48
 d019a7c:	dfc00b15 	stw	ra,44(sp)
 d019a80:	df000a15 	stw	fp,40(sp)
 d019a84:	df000a04 	addi	fp,sp,40
 d019a88:	e13ffb15 	stw	r4,-20(fp)
 d019a8c:	e17ffc15 	stw	r5,-16(fp)
 d019a90:	e1bffd15 	stw	r6,-12(fp)
 d019a94:	e0800517 	ldw	r2,20(fp)
 d019a98:	e1fffe0d 	sth	r7,-8(fp)
 d019a9c:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 d019aa0:	e1fffe0b 	ldhu	r7,-8(fp)
 d019aa4:	e0ffff03 	ldbu	r3,-4(fp)
 d019aa8:	e0800217 	ldw	r2,8(fp)
 d019aac:	d8800015 	stw	r2,0(sp)
 d019ab0:	e0800317 	ldw	r2,12(fp)
 d019ab4:	d8800115 	stw	r2,4(sp)
 d019ab8:	e0800417 	ldw	r2,16(fp)
 d019abc:	d8800215 	stw	r2,8(sp)
 d019ac0:	d8000315 	stw	zero,12(sp)
 d019ac4:	d8c00415 	stw	r3,16(sp)
 d019ac8:	e13ffb17 	ldw	r4,-20(fp)
 d019acc:	e17ffc17 	ldw	r5,-16(fp)
 d019ad0:	e1bffd17 	ldw	r6,-12(fp)
 d019ad4:	d019aec0 	call	d019aec <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 d019ad8:	e037883a 	mov	sp,fp
 d019adc:	dfc00117 	ldw	ra,4(sp)
 d019ae0:	df000017 	ldw	fp,0(sp)
 d019ae4:	dec00204 	addi	sp,sp,8
 d019ae8:	f800283a 	ret

0d019aec <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 d019aec:	defff204 	addi	sp,sp,-56
 d019af0:	dfc00d15 	stw	ra,52(sp)
 d019af4:	df000c15 	stw	fp,48(sp)
 d019af8:	df000c04 	addi	fp,sp,48
 d019afc:	e13ffb15 	stw	r4,-20(fp)
 d019b00:	e17ffc15 	stw	r5,-16(fp)
 d019b04:	e1bffd15 	stw	r6,-12(fp)
 d019b08:	e0800617 	ldw	r2,24(fp)
 d019b0c:	e1fffe0d 	sth	r7,-8(fp)
 d019b10:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 d019b14:	e0bffe0b 	ldhu	r2,-8(fp)
 d019b18:	e0ffff03 	ldbu	r3,-4(fp)
 d019b1c:	d8800015 	stw	r2,0(sp)
 d019b20:	e0800417 	ldw	r2,16(fp)
 d019b24:	d8800115 	stw	r2,4(sp)
 d019b28:	e0800217 	ldw	r2,8(fp)
 d019b2c:	d8800215 	stw	r2,8(sp)
 d019b30:	e0800317 	ldw	r2,12(fp)
 d019b34:	d8800315 	stw	r2,12(sp)
 d019b38:	e0800517 	ldw	r2,20(fp)
 d019b3c:	d8800415 	stw	r2,16(sp)
 d019b40:	d8000515 	stw	zero,20(sp)
 d019b44:	d8c00615 	stw	r3,24(sp)
 d019b48:	e13ffb17 	ldw	r4,-20(fp)
 d019b4c:	e17ffc17 	ldw	r5,-16(fp)
 d019b50:	e1bffd17 	ldw	r6,-12(fp)
 d019b54:	000f883a 	mov	r7,zero
 d019b58:	d019ef40 	call	d019ef4 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 d019b5c:	e037883a 	mov	sp,fp
 d019b60:	dfc00117 	ldw	ra,4(sp)
 d019b64:	df000017 	ldw	fp,0(sp)
 d019b68:	dec00204 	addi	sp,sp,8
 d019b6c:	f800283a 	ret

0d019b70 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 d019b70:	defffb04 	addi	sp,sp,-20
 d019b74:	df000415 	stw	fp,16(sp)
 d019b78:	df000404 	addi	fp,sp,16
 d019b7c:	e13ffc15 	stw	r4,-16(fp)
 d019b80:	e17ffd15 	stw	r5,-12(fp)
 d019b84:	e1bffe15 	stw	r6,-8(fp)
 d019b88:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 d019b8c:	e0fffc17 	ldw	r3,-16(fp)
 d019b90:	e0bffd17 	ldw	r2,-12(fp)
 d019b94:	18800915 	stw	r2,36(r3)
  dev->callback_context = context;
 d019b98:	e0fffc17 	ldw	r3,-16(fp)
 d019b9c:	e0bfff17 	ldw	r2,-4(fp)
 d019ba0:	18800a15 	stw	r2,40(r3)
  dev->chain_control    = chain_control;
 d019ba4:	e0fffc17 	ldw	r3,-16(fp)
 d019ba8:	e0bffe17 	ldw	r2,-8(fp)
 d019bac:	18800b15 	stw	r2,44(r3)
}
 d019bb0:	e037883a 	mov	sp,fp
 d019bb4:	df000017 	ldw	fp,0(sp)
 d019bb8:	dec00104 	addi	sp,sp,4
 d019bbc:	f800283a 	ret

0d019bc0 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 d019bc0:	defffd04 	addi	sp,sp,-12
 d019bc4:	df000215 	stw	fp,8(sp)
 d019bc8:	df000204 	addi	fp,sp,8
 d019bcc:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019bd0:	e0bfff17 	ldw	r2,-4(fp)
 d019bd4:	10800317 	ldw	r2,12(r2)
 d019bd8:	10800404 	addi	r2,r2,16
 d019bdc:	10800037 	ldwio	r2,0(r2)
 d019be0:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 d019be4:	e0bffe17 	ldw	r2,-8(fp)
 d019be8:	10800814 	ori	r2,r2,32
 d019bec:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019bf0:	e0bfff17 	ldw	r2,-4(fp)
 d019bf4:	10800317 	ldw	r2,12(r2)
 d019bf8:	10800404 	addi	r2,r2,16
 d019bfc:	e0fffe17 	ldw	r3,-8(fp)
 d019c00:	10c00035 	stwio	r3,0(r2)
}
 d019c04:	e037883a 	mov	sp,fp
 d019c08:	df000017 	ldw	fp,0(sp)
 d019c0c:	dec00104 	addi	sp,sp,4
 d019c10:	f800283a 	ret

0d019c14 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 d019c14:	defffd04 	addi	sp,sp,-12
 d019c18:	df000215 	stw	fp,8(sp)
 d019c1c:	df000204 	addi	fp,sp,8
 d019c20:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019c24:	e0bfff17 	ldw	r2,-4(fp)
 d019c28:	10800317 	ldw	r2,12(r2)
 d019c2c:	10800404 	addi	r2,r2,16
 d019c30:	10800037 	ldwio	r2,0(r2)
 d019c34:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 d019c38:	e0fffe17 	ldw	r3,-8(fp)
 d019c3c:	00bff7c4 	movi	r2,-33
 d019c40:	1884703a 	and	r2,r3,r2
 d019c44:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019c48:	e0bfff17 	ldw	r2,-4(fp)
 d019c4c:	10800317 	ldw	r2,12(r2)
 d019c50:	10800404 	addi	r2,r2,16
 d019c54:	e0fffe17 	ldw	r3,-8(fp)
 d019c58:	10c00035 	stwio	r3,0(r2)
}
 d019c5c:	e037883a 	mov	sp,fp
 d019c60:	df000017 	ldw	fp,0(sp)
 d019c64:	dec00104 	addi	sp,sp,4
 d019c68:	f800283a 	ret

0d019c6c <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 d019c6c:	defffd04 	addi	sp,sp,-12
 d019c70:	df000215 	stw	fp,8(sp)
 d019c74:	df000204 	addi	fp,sp,8
 d019c78:	e13ffe15 	stw	r4,-8(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 d019c7c:	e0bffe17 	ldw	r2,-8(fp)
 d019c80:	10800784 	addi	r2,r2,30
 d019c84:	10800023 	ldbuio	r2,0(r2)
 d019c88:	10801fcc 	andi	r2,r2,127
 d019c8c:	1005003a 	cmpeq	r2,r2,zero
 d019c90:	1000031e 	bne	r2,zero,d019ca0 <alt_avalon_sgdma_check_descriptor_status+0x34>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 d019c94:	00bffec4 	movi	r2,-5
 d019c98:	e0bfff15 	stw	r2,-4(fp)
 d019c9c:	00000a06 	br	d019cc8 <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 d019ca0:	e0bffe17 	ldw	r2,-8(fp)
 d019ca4:	108007c4 	addi	r2,r2,31
 d019ca8:	10800023 	ldbuio	r2,0(r2)
 d019cac:	1080200c 	andi	r2,r2,128
 d019cb0:	1005003a 	cmpeq	r2,r2,zero
 d019cb4:	1000031e 	bne	r2,zero,d019cc4 <alt_avalon_sgdma_check_descriptor_status+0x58>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 d019cb8:	00bfe244 	movi	r2,-119
 d019cbc:	e0bfff15 	stw	r2,-4(fp)
 d019cc0:	00000106 	br	d019cc8 <alt_avalon_sgdma_check_descriptor_status+0x5c>
  }

    return 0;
 d019cc4:	e03fff15 	stw	zero,-4(fp)
 d019cc8:	e0bfff17 	ldw	r2,-4(fp)
}
 d019ccc:	e037883a 	mov	sp,fp
 d019cd0:	df000017 	ldw	fp,0(sp)
 d019cd4:	dec00104 	addi	sp,sp,4
 d019cd8:	f800283a 	ret

0d019cdc <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 d019cdc:	defffc04 	addi	sp,sp,-16
 d019ce0:	dfc00315 	stw	ra,12(sp)
 d019ce4:	df000215 	stw	fp,8(sp)
 d019ce8:	df000204 	addi	fp,sp,8
 d019cec:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 d019cf0:	e13fff17 	ldw	r4,-4(fp)
 d019cf4:	d1602b04 	addi	r5,gp,-32596
 d019cf8:	d038d0c0 	call	d038d0c <alt_find_dev>
 d019cfc:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 d019d00:	e0bffe17 	ldw	r2,-8(fp)
 d019d04:	1004c03a 	cmpne	r2,r2,zero
 d019d08:	1000041e 	bne	r2,zero,d019d1c <alt_avalon_sgdma_open+0x40>
    ALT_ERRNO = ENODEV;
 d019d0c:	d019d340 	call	d019d34 <alt_get_errno>
 d019d10:	1007883a 	mov	r3,r2
 d019d14:	008004c4 	movi	r2,19
 d019d18:	18800015 	stw	r2,0(r3)
  }

  return dev;
 d019d1c:	e0bffe17 	ldw	r2,-8(fp)
}
 d019d20:	e037883a 	mov	sp,fp
 d019d24:	dfc00117 	ldw	ra,4(sp)
 d019d28:	df000017 	ldw	fp,0(sp)
 d019d2c:	dec00204 	addi	sp,sp,8
 d019d30:	f800283a 	ret

0d019d34 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d019d34:	defffd04 	addi	sp,sp,-12
 d019d38:	dfc00215 	stw	ra,8(sp)
 d019d3c:	df000115 	stw	fp,4(sp)
 d019d40:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d019d44:	00834174 	movhi	r2,3333
 d019d48:	108a6804 	addi	r2,r2,10656
 d019d4c:	10800017 	ldw	r2,0(r2)
 d019d50:	1005003a 	cmpeq	r2,r2,zero
 d019d54:	1000061e 	bne	r2,zero,d019d70 <alt_get_errno+0x3c>
 d019d58:	00834174 	movhi	r2,3333
 d019d5c:	108a6804 	addi	r2,r2,10656
 d019d60:	10800017 	ldw	r2,0(r2)
 d019d64:	103ee83a 	callr	r2
 d019d68:	e0bfff15 	stw	r2,-4(fp)
 d019d6c:	00000306 	br	d019d7c <alt_get_errno+0x48>
 d019d70:	00834174 	movhi	r2,3333
 d019d74:	108a8404 	addi	r2,r2,10768
 d019d78:	e0bfff15 	stw	r2,-4(fp)
 d019d7c:	e0bfff17 	ldw	r2,-4(fp)
}
 d019d80:	e037883a 	mov	sp,fp
 d019d84:	dfc00117 	ldw	ra,4(sp)
 d019d88:	df000017 	ldw	fp,0(sp)
 d019d8c:	dec00204 	addi	sp,sp,8
 d019d90:	f800283a 	ret

0d019d94 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 d019d94:	defff104 	addi	sp,sp,-60
 d019d98:	dfc00e15 	stw	ra,56(sp)
 d019d9c:	df000d15 	stw	fp,52(sp)
 d019da0:	df000d04 	addi	fp,sp,52
 d019da4:	e13ffa15 	stw	r4,-24(fp)
 d019da8:	e17ffb15 	stw	r5,-20(fp)
 d019dac:	e1bffc15 	stw	r6,-16(fp)
 d019db0:	e1fffd15 	stw	r7,-12(fp)
 d019db4:	e0800217 	ldw	r2,8(fp)
 d019db8:	e0c00617 	ldw	r3,24(fp)
 d019dbc:	e0bffe0d 	sth	r2,-8(fp)
 d019dc0:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 d019dc4:	e0bffe0b 	ldhu	r2,-8(fp)
 d019dc8:	e0ffff03 	ldbu	r3,-4(fp)
 d019dcc:	d8800015 	stw	r2,0(sp)
 d019dd0:	e0800317 	ldw	r2,12(fp)
 d019dd4:	d8800115 	stw	r2,4(sp)
 d019dd8:	e0800417 	ldw	r2,16(fp)
 d019ddc:	d8800215 	stw	r2,8(sp)
 d019de0:	e0800517 	ldw	r2,20(fp)
 d019de4:	d8800315 	stw	r2,12(sp)
 d019de8:	d8000415 	stw	zero,16(sp)
 d019dec:	d8000515 	stw	zero,20(sp)
 d019df0:	d8c00615 	stw	r3,24(sp)
 d019df4:	e13ffa17 	ldw	r4,-24(fp)
 d019df8:	e17ffb17 	ldw	r5,-20(fp)
 d019dfc:	e1bffc17 	ldw	r6,-16(fp)
 d019e00:	e1fffd17 	ldw	r7,-12(fp)
 d019e04:	d019ef40 	call	d019ef4 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 d019e08:	e037883a 	mov	sp,fp
 d019e0c:	dfc00117 	ldw	ra,4(sp)
 d019e10:	df000017 	ldw	fp,0(sp)
 d019e14:	dec00204 	addi	sp,sp,8
 d019e18:	f800283a 	ret

0d019e1c <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 d019e1c:	defffc04 	addi	sp,sp,-16
 d019e20:	df000315 	stw	fp,12(sp)
 d019e24:	df000304 	addi	fp,sp,12
 d019e28:	e13ffe15 	stw	r4,-8(fp)
 d019e2c:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019e30:	e0bffe17 	ldw	r2,-8(fp)
 d019e34:	10800317 	ldw	r2,12(r2)
 d019e38:	10800404 	addi	r2,r2,16
 d019e3c:	10800037 	ldwio	r2,0(r2)
 d019e40:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 d019e44:	e0fffd17 	ldw	r3,-12(fp)
 d019e48:	00a00434 	movhi	r2,32784
 d019e4c:	10bfffc4 	addi	r2,r2,-1
 d019e50:	1884703a 	and	r2,r3,r2
 d019e54:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 d019e58:	e0bfff17 	ldw	r2,-4(fp)
 d019e5c:	1004953a 	slli	r2,r2,20
 d019e60:	10dffc2c 	andhi	r3,r2,32752
 d019e64:	e0bffd17 	ldw	r2,-12(fp)
 d019e68:	1884b03a 	or	r2,r3,r2
 d019e6c:	10800134 	orhi	r2,r2,4
 d019e70:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019e74:	e0bffe17 	ldw	r2,-8(fp)
 d019e78:	10800317 	ldw	r2,12(r2)
 d019e7c:	10800404 	addi	r2,r2,16
 d019e80:	e0fffd17 	ldw	r3,-12(fp)
 d019e84:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 d019e88:	e037883a 	mov	sp,fp
 d019e8c:	df000017 	ldw	fp,0(sp)
 d019e90:	dec00104 	addi	sp,sp,4
 d019e94:	f800283a 	ret

0d019e98 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 d019e98:	defffd04 	addi	sp,sp,-12
 d019e9c:	df000215 	stw	fp,8(sp)
 d019ea0:	df000204 	addi	fp,sp,8
 d019ea4:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d019ea8:	e0bfff17 	ldw	r2,-4(fp)
 d019eac:	10800317 	ldw	r2,12(r2)
 d019eb0:	10800404 	addi	r2,r2,16
 d019eb4:	10800037 	ldwio	r2,0(r2)
 d019eb8:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 d019ebc:	e0fffe17 	ldw	r3,-8(fp)
 d019ec0:	00bfff34 	movhi	r2,65532
 d019ec4:	10bfffc4 	addi	r2,r2,-1
 d019ec8:	1884703a 	and	r2,r3,r2
 d019ecc:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 d019ed0:	e0bfff17 	ldw	r2,-4(fp)
 d019ed4:	10800317 	ldw	r2,12(r2)
 d019ed8:	10800404 	addi	r2,r2,16
 d019edc:	e0fffe17 	ldw	r3,-8(fp)
 d019ee0:	10c00035 	stwio	r3,0(r2)
  
  return;
}
 d019ee4:	e037883a 	mov	sp,fp
 d019ee8:	df000017 	ldw	fp,0(sp)
 d019eec:	dec00104 	addi	sp,sp,4
 d019ef0:	f800283a 	ret

0d019ef4 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 d019ef4:	defff204 	addi	sp,sp,-56
 d019ef8:	dfc00d15 	stw	ra,52(sp)
 d019efc:	df000c15 	stw	fp,48(sp)
 d019f00:	df000c04 	addi	fp,sp,48
 d019f04:	e13ff415 	stw	r4,-48(fp)
 d019f08:	e17ff515 	stw	r5,-44(fp)
 d019f0c:	e1bff615 	stw	r6,-40(fp)
 d019f10:	e1fff715 	stw	r7,-36(fp)
 d019f14:	e0800217 	ldw	r2,8(fp)
 d019f18:	e0c00817 	ldw	r3,32(fp)
 d019f1c:	e0bff80d 	sth	r2,-32(fp)
 d019f20:	e0fff905 	stb	r3,-28(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 d019f24:	e0bff517 	ldw	r2,-44(fp)
 d019f28:	110007c4 	addi	r4,r2,31
 d019f2c:	e0bff517 	ldw	r2,-44(fp)
 d019f30:	108007c3 	ldbu	r2,31(r2)
 d019f34:	10c03fcc 	andi	r3,r2,255
 d019f38:	00bfdfc4 	movi	r2,-129
 d019f3c:	1886703a 	and	r3,r3,r2
 d019f40:	2005883a 	mov	r2,r4
 d019f44:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 d019f48:	e13ff417 	ldw	r4,-48(fp)
 d019f4c:	e0bff617 	ldw	r2,-40(fp)
 d019f50:	11403fcc 	andi	r5,r2,255
 d019f54:	20800003 	ldbu	r2,0(r4)
 d019f58:	1004703a 	and	r2,r2,zero
 d019f5c:	1007883a 	mov	r3,r2
 d019f60:	2805883a 	mov	r2,r5
 d019f64:	1884b03a 	or	r2,r3,r2
 d019f68:	20800005 	stb	r2,0(r4)
 d019f6c:	e0bff617 	ldw	r2,-40(fp)
 d019f70:	1004d23a 	srli	r2,r2,8
 d019f74:	11403fcc 	andi	r5,r2,255
 d019f78:	20800043 	ldbu	r2,1(r4)
 d019f7c:	1004703a 	and	r2,r2,zero
 d019f80:	1007883a 	mov	r3,r2
 d019f84:	2805883a 	mov	r2,r5
 d019f88:	1884b03a 	or	r2,r3,r2
 d019f8c:	20800045 	stb	r2,1(r4)
 d019f90:	e0bff617 	ldw	r2,-40(fp)
 d019f94:	1004d43a 	srli	r2,r2,16
 d019f98:	11403fcc 	andi	r5,r2,255
 d019f9c:	20800083 	ldbu	r2,2(r4)
 d019fa0:	1004703a 	and	r2,r2,zero
 d019fa4:	1007883a 	mov	r3,r2
 d019fa8:	2805883a 	mov	r2,r5
 d019fac:	1884b03a 	or	r2,r3,r2
 d019fb0:	20800085 	stb	r2,2(r4)
 d019fb4:	e0bff617 	ldw	r2,-40(fp)
 d019fb8:	100ad63a 	srli	r5,r2,24
 d019fbc:	208000c3 	ldbu	r2,3(r4)
 d019fc0:	1004703a 	and	r2,r2,zero
 d019fc4:	1007883a 	mov	r3,r2
 d019fc8:	2805883a 	mov	r2,r5
 d019fcc:	1884b03a 	or	r2,r3,r2
 d019fd0:	208000c5 	stb	r2,3(r4)
  desc->write_addr               = write_addr;
 d019fd4:	e13ff417 	ldw	r4,-48(fp)
 d019fd8:	e0bff717 	ldw	r2,-36(fp)
 d019fdc:	11403fcc 	andi	r5,r2,255
 d019fe0:	20800203 	ldbu	r2,8(r4)
 d019fe4:	1004703a 	and	r2,r2,zero
 d019fe8:	1007883a 	mov	r3,r2
 d019fec:	2805883a 	mov	r2,r5
 d019ff0:	1884b03a 	or	r2,r3,r2
 d019ff4:	20800205 	stb	r2,8(r4)
 d019ff8:	e0bff717 	ldw	r2,-36(fp)
 d019ffc:	1004d23a 	srli	r2,r2,8
 d01a000:	11403fcc 	andi	r5,r2,255
 d01a004:	20800243 	ldbu	r2,9(r4)
 d01a008:	1004703a 	and	r2,r2,zero
 d01a00c:	1007883a 	mov	r3,r2
 d01a010:	2805883a 	mov	r2,r5
 d01a014:	1884b03a 	or	r2,r3,r2
 d01a018:	20800245 	stb	r2,9(r4)
 d01a01c:	e0bff717 	ldw	r2,-36(fp)
 d01a020:	1004d43a 	srli	r2,r2,16
 d01a024:	11403fcc 	andi	r5,r2,255
 d01a028:	20800283 	ldbu	r2,10(r4)
 d01a02c:	1004703a 	and	r2,r2,zero
 d01a030:	1007883a 	mov	r3,r2
 d01a034:	2805883a 	mov	r2,r5
 d01a038:	1884b03a 	or	r2,r3,r2
 d01a03c:	20800285 	stb	r2,10(r4)
 d01a040:	e0bff717 	ldw	r2,-36(fp)
 d01a044:	100ad63a 	srli	r5,r2,24
 d01a048:	208002c3 	ldbu	r2,11(r4)
 d01a04c:	1004703a 	and	r2,r2,zero
 d01a050:	1007883a 	mov	r3,r2
 d01a054:	2805883a 	mov	r2,r5
 d01a058:	1884b03a 	or	r2,r3,r2
 d01a05c:	208002c5 	stb	r2,11(r4)
  desc->next                     = (alt_u32 *) next;
 d01a060:	e1bff517 	ldw	r6,-44(fp)
 d01a064:	e13ff417 	ldw	r4,-48(fp)
 d01a068:	31403fcc 	andi	r5,r6,255
 d01a06c:	20800403 	ldbu	r2,16(r4)
 d01a070:	1004703a 	and	r2,r2,zero
 d01a074:	1007883a 	mov	r3,r2
 d01a078:	2805883a 	mov	r2,r5
 d01a07c:	1884b03a 	or	r2,r3,r2
 d01a080:	20800405 	stb	r2,16(r4)
 d01a084:	3004d23a 	srli	r2,r6,8
 d01a088:	11403fcc 	andi	r5,r2,255
 d01a08c:	20800443 	ldbu	r2,17(r4)
 d01a090:	1004703a 	and	r2,r2,zero
 d01a094:	1007883a 	mov	r3,r2
 d01a098:	2805883a 	mov	r2,r5
 d01a09c:	1884b03a 	or	r2,r3,r2
 d01a0a0:	20800445 	stb	r2,17(r4)
 d01a0a4:	3004d43a 	srli	r2,r6,16
 d01a0a8:	11403fcc 	andi	r5,r2,255
 d01a0ac:	20800483 	ldbu	r2,18(r4)
 d01a0b0:	1004703a 	and	r2,r2,zero
 d01a0b4:	1007883a 	mov	r3,r2
 d01a0b8:	2805883a 	mov	r2,r5
 d01a0bc:	1884b03a 	or	r2,r3,r2
 d01a0c0:	20800485 	stb	r2,18(r4)
 d01a0c4:	300ad63a 	srli	r5,r6,24
 d01a0c8:	208004c3 	ldbu	r2,19(r4)
 d01a0cc:	1004703a 	and	r2,r2,zero
 d01a0d0:	1007883a 	mov	r3,r2
 d01a0d4:	2805883a 	mov	r2,r5
 d01a0d8:	1884b03a 	or	r2,r3,r2
 d01a0dc:	208004c5 	stb	r2,19(r4)
  desc->read_addr_pad            = 0x0;
 d01a0e0:	e0fff417 	ldw	r3,-48(fp)
 d01a0e4:	18800103 	ldbu	r2,4(r3)
 d01a0e8:	1004703a 	and	r2,r2,zero
 d01a0ec:	18800105 	stb	r2,4(r3)
 d01a0f0:	18800143 	ldbu	r2,5(r3)
 d01a0f4:	1004703a 	and	r2,r2,zero
 d01a0f8:	18800145 	stb	r2,5(r3)
 d01a0fc:	18800183 	ldbu	r2,6(r3)
 d01a100:	1004703a 	and	r2,r2,zero
 d01a104:	18800185 	stb	r2,6(r3)
 d01a108:	188001c3 	ldbu	r2,7(r3)
 d01a10c:	1004703a 	and	r2,r2,zero
 d01a110:	188001c5 	stb	r2,7(r3)
  desc->write_addr_pad           = 0x0;
 d01a114:	e0fff417 	ldw	r3,-48(fp)
 d01a118:	18800303 	ldbu	r2,12(r3)
 d01a11c:	1004703a 	and	r2,r2,zero
 d01a120:	18800305 	stb	r2,12(r3)
 d01a124:	18800343 	ldbu	r2,13(r3)
 d01a128:	1004703a 	and	r2,r2,zero
 d01a12c:	18800345 	stb	r2,13(r3)
 d01a130:	18800383 	ldbu	r2,14(r3)
 d01a134:	1004703a 	and	r2,r2,zero
 d01a138:	18800385 	stb	r2,14(r3)
 d01a13c:	188003c3 	ldbu	r2,15(r3)
 d01a140:	1004703a 	and	r2,r2,zero
 d01a144:	188003c5 	stb	r2,15(r3)
  desc->next_pad                 = 0x0;
 d01a148:	e0fff417 	ldw	r3,-48(fp)
 d01a14c:	18800503 	ldbu	r2,20(r3)
 d01a150:	1004703a 	and	r2,r2,zero
 d01a154:	18800505 	stb	r2,20(r3)
 d01a158:	18800543 	ldbu	r2,21(r3)
 d01a15c:	1004703a 	and	r2,r2,zero
 d01a160:	18800545 	stb	r2,21(r3)
 d01a164:	18800583 	ldbu	r2,22(r3)
 d01a168:	1004703a 	and	r2,r2,zero
 d01a16c:	18800585 	stb	r2,22(r3)
 d01a170:	188005c3 	ldbu	r2,23(r3)
 d01a174:	1004703a 	and	r2,r2,zero
 d01a178:	188005c5 	stb	r2,23(r3)
  desc->bytes_to_transfer        = length_or_eop;
 d01a17c:	e13ff417 	ldw	r4,-48(fp)
 d01a180:	e0bff80b 	ldhu	r2,-32(fp)
 d01a184:	11403fcc 	andi	r5,r2,255
 d01a188:	20800603 	ldbu	r2,24(r4)
 d01a18c:	1004703a 	and	r2,r2,zero
 d01a190:	1007883a 	mov	r3,r2
 d01a194:	2805883a 	mov	r2,r5
 d01a198:	1884b03a 	or	r2,r3,r2
 d01a19c:	20800605 	stb	r2,24(r4)
 d01a1a0:	e0bff80b 	ldhu	r2,-32(fp)
 d01a1a4:	1004d23a 	srli	r2,r2,8
 d01a1a8:	117fffcc 	andi	r5,r2,65535
 d01a1ac:	20800643 	ldbu	r2,25(r4)
 d01a1b0:	1004703a 	and	r2,r2,zero
 d01a1b4:	1007883a 	mov	r3,r2
 d01a1b8:	2805883a 	mov	r2,r5
 d01a1bc:	1884b03a 	or	r2,r3,r2
 d01a1c0:	20800645 	stb	r2,25(r4)
  desc->actual_bytes_transferred = 0;
 d01a1c4:	e0fff417 	ldw	r3,-48(fp)
 d01a1c8:	18800703 	ldbu	r2,28(r3)
 d01a1cc:	1004703a 	and	r2,r2,zero
 d01a1d0:	18800705 	stb	r2,28(r3)
 d01a1d4:	18800743 	ldbu	r2,29(r3)
 d01a1d8:	1004703a 	and	r2,r2,zero
 d01a1dc:	18800745 	stb	r2,29(r3)
  desc->status                   = 0x0;
 d01a1e0:	e0bff417 	ldw	r2,-48(fp)
 d01a1e4:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 d01a1e8:	e0800617 	ldw	r2,24(fp)
 d01a1ec:	1007883a 	mov	r3,r2
 d01a1f0:	e0bff417 	ldw	r2,-48(fp)
 d01a1f4:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 d01a1f8:	e0800717 	ldw	r2,28(fp)
 d01a1fc:	1007883a 	mov	r3,r2
 d01a200:	e0bff417 	ldw	r2,-48(fp)
 d01a204:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 d01a208:	e0800317 	ldw	r2,12(fp)
 d01a20c:	1005003a 	cmpeq	r2,r2,zero
 d01a210:	1000031e 	bne	r2,zero,d01a220 <alt_avalon_sgdma_construct_descriptor_burst+0x32c>
 d01a214:	00bfe044 	movi	r2,-127
 d01a218:	e0bfff05 	stb	r2,-4(fp)
 d01a21c:	00000206 	br	d01a228 <alt_avalon_sgdma_construct_descriptor_burst+0x334>
 d01a220:	00bfe004 	movi	r2,-128
 d01a224:	e0bfff05 	stb	r2,-4(fp)
 d01a228:	e0800417 	ldw	r2,16(fp)
 d01a22c:	1005003a 	cmpeq	r2,r2,zero
 d01a230:	1000031e 	bne	r2,zero,d01a240 <alt_avalon_sgdma_construct_descriptor_burst+0x34c>
 d01a234:	00800084 	movi	r2,2
 d01a238:	e0bffe05 	stb	r2,-8(fp)
 d01a23c:	00000106 	br	d01a244 <alt_avalon_sgdma_construct_descriptor_burst+0x350>
 d01a240:	e03ffe05 	stb	zero,-8(fp)
 d01a244:	e0ffff03 	ldbu	r3,-4(fp)
 d01a248:	e13ffe03 	ldbu	r4,-8(fp)
 d01a24c:	1904b03a 	or	r2,r3,r4
 d01a250:	e0bffd05 	stb	r2,-12(fp)
 d01a254:	e0800517 	ldw	r2,20(fp)
 d01a258:	1005003a 	cmpeq	r2,r2,zero
 d01a25c:	1000031e 	bne	r2,zero,d01a26c <alt_avalon_sgdma_construct_descriptor_burst+0x378>
 d01a260:	00800104 	movi	r2,4
 d01a264:	e0bffc05 	stb	r2,-16(fp)
 d01a268:	00000106 	br	d01a270 <alt_avalon_sgdma_construct_descriptor_burst+0x37c>
 d01a26c:	e03ffc05 	stb	zero,-16(fp)
 d01a270:	e0fffd03 	ldbu	r3,-12(fp)
 d01a274:	e13ffc03 	ldbu	r4,-16(fp)
 d01a278:	1904b03a 	or	r2,r3,r4
 d01a27c:	e0bffb05 	stb	r2,-20(fp)
 d01a280:	e0bff903 	ldbu	r2,-28(fp)
 d01a284:	1005003a 	cmpeq	r2,r2,zero
 d01a288:	1000051e 	bne	r2,zero,d01a2a0 <alt_avalon_sgdma_construct_descriptor_burst+0x3ac>
 d01a28c:	e0bff903 	ldbu	r2,-28(fp)
 d01a290:	108003cc 	andi	r2,r2,15
 d01a294:	100490fa 	slli	r2,r2,3
 d01a298:	e0bffa05 	stb	r2,-24(fp)
 d01a29c:	00000106 	br	d01a2a4 <alt_avalon_sgdma_construct_descriptor_burst+0x3b0>
 d01a2a0:	e03ffa05 	stb	zero,-24(fp)
 d01a2a4:	e0fffb03 	ldbu	r3,-20(fp)
 d01a2a8:	e13ffa03 	ldbu	r4,-24(fp)
 d01a2ac:	1904b03a 	or	r2,r3,r4
 d01a2b0:	1007883a 	mov	r3,r2
 d01a2b4:	e0bff417 	ldw	r2,-48(fp)
 d01a2b8:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
 d01a2bc:	e13ff417 	ldw	r4,-48(fp)
 d01a2c0:	01400804 	movi	r5,32
 d01a2c4:	d0396840 	call	d039684 <alt_remap_uncached>
}
 d01a2c8:	e037883a 	mov	sp,fp
 d01a2cc:	dfc00117 	ldw	ra,4(sp)
 d01a2d0:	df000017 	ldw	fp,0(sp)
 d01a2d4:	dec00204 	addi	sp,sp,8
 d01a2d8:	f800283a 	ret

0d01a2dc <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 d01a2dc:	defff904 	addi	sp,sp,-28
 d01a2e0:	dfc00615 	stw	ra,24(sp)
 d01a2e4:	df000515 	stw	fp,20(sp)
 d01a2e8:	df000504 	addi	fp,sp,20
 d01a2ec:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 d01a2f0:	e0bfff17 	ldw	r2,-4(fp)
 d01a2f4:	e0bffe15 	stw	r2,-8(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 d01a2f8:	e0bffe17 	ldw	r2,-8(fp)
 d01a2fc:	10800317 	ldw	r2,12(r2)
 d01a300:	11000404 	addi	r4,r2,16
 d01a304:	e0bffe17 	ldw	r2,-8(fp)
 d01a308:	10800317 	ldw	r2,12(r2)
 d01a30c:	10800404 	addi	r2,r2,16
 d01a310:	10800037 	ldwio	r2,0(r2)
 d01a314:	10a00034 	orhi	r2,r2,32768
 d01a318:	1007883a 	mov	r3,r2
 d01a31c:	2005883a 	mov	r2,r4
 d01a320:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 d01a324:	e0bffe17 	ldw	r2,-8(fp)
 d01a328:	10800317 	ldw	r2,12(r2)
 d01a32c:	10800404 	addi	r2,r2,16
 d01a330:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 d01a334:	e0bffe17 	ldw	r2,-8(fp)
 d01a338:	10800917 	ldw	r2,36(r2)
 d01a33c:	1005003a 	cmpeq	r2,r2,zero
 d01a340:	1000111e 	bne	r2,zero,d01a388 <alt_avalon_sgdma_irq+0xac>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01a344:	0005303a 	rdctl	r2,status
 d01a348:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01a34c:	e0fffc17 	ldw	r3,-16(fp)
 d01a350:	00bfff84 	movi	r2,-2
 d01a354:	1884703a 	and	r2,r3,r2
 d01a358:	1001703a 	wrctl	status,r2
  
  return context;
 d01a35c:	e0bffc17 	ldw	r2,-16(fp)
    cpu_sr = alt_irq_disable_all();
 d01a360:	e0bffd15 	stw	r2,-12(fp)
    (dev->callback)(dev->callback_context);
 d01a364:	e0bffe17 	ldw	r2,-8(fp)
 d01a368:	10c00917 	ldw	r3,36(r2)
 d01a36c:	e0bffe17 	ldw	r2,-8(fp)
 d01a370:	11000a17 	ldw	r4,40(r2)
 d01a374:	183ee83a 	callr	r3
 d01a378:	e0bffd17 	ldw	r2,-12(fp)
 d01a37c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01a380:	e0bffb17 	ldw	r2,-20(fp)
 d01a384:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 d01a388:	e037883a 	mov	sp,fp
 d01a38c:	dfc00117 	ldw	ra,4(sp)
 d01a390:	df000017 	ldw	fp,0(sp)
 d01a394:	dec00204 	addi	sp,sp,8
 d01a398:	f800283a 	ret

0d01a39c <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 d01a39c:	defffa04 	addi	sp,sp,-24
 d01a3a0:	dfc00515 	stw	ra,20(sp)
 d01a3a4:	df000415 	stw	fp,16(sp)
 d01a3a8:	df000404 	addi	fp,sp,16
 d01a3ac:	e13ffd15 	stw	r4,-12(fp)
 d01a3b0:	e17ffe15 	stw	r5,-8(fp)
 d01a3b4:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d01a3b8:	e0bffd17 	ldw	r2,-12(fp)
 d01a3bc:	10800317 	ldw	r2,12(r2)
 d01a3c0:	10800404 	addi	r2,r2,16
 d01a3c4:	1007883a 	mov	r3,r2
 d01a3c8:	00800074 	movhi	r2,1
 d01a3cc:	18800035 	stwio	r2,0(r3)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 d01a3d0:	e0bffd17 	ldw	r2,-12(fp)
 d01a3d4:	10800317 	ldw	r2,12(r2)
 d01a3d8:	10800404 	addi	r2,r2,16
 d01a3dc:	1007883a 	mov	r3,r2
 d01a3e0:	00800074 	movhi	r2,1
 d01a3e4:	18800035 	stwio	r2,0(r3)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 d01a3e8:	e0bffd17 	ldw	r2,-12(fp)
 d01a3ec:	10800317 	ldw	r2,12(r2)
 d01a3f0:	10800404 	addi	r2,r2,16
 d01a3f4:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 d01a3f8:	e0bffd17 	ldw	r2,-12(fp)
 d01a3fc:	10800317 	ldw	r2,12(r2)
 d01a400:	1007883a 	mov	r3,r2
 d01a404:	00803fc4 	movi	r2,255
 d01a408:	18800035 	stwio	r2,0(r3)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 d01a40c:	e13ffd17 	ldw	r4,-12(fp)
 d01a410:	d1602b04 	addi	r5,gp,-32596
 d01a414:	d038b300 	call	d038b30 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 d01a418:	d8000015 	stw	zero,0(sp)
 d01a41c:	e13ffe17 	ldw	r4,-8(fp)
 d01a420:	e17fff17 	ldw	r5,-4(fp)
 d01a424:	018340b4 	movhi	r6,3330
 d01a428:	31a8b704 	addi	r6,r6,-23844
 d01a42c:	e1fffd17 	ldw	r7,-12(fp)
 d01a430:	d038da00 	call	d038da0 <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 d01a434:	e037883a 	mov	sp,fp
 d01a438:	dfc00117 	ldw	ra,4(sp)
 d01a43c:	df000017 	ldw	fp,0(sp)
 d01a440:	dec00204 	addi	sp,sp,8
 d01a444:	f800283a 	ret

0d01a448 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 d01a448:	defffa04 	addi	sp,sp,-24
 d01a44c:	dfc00515 	stw	ra,20(sp)
 d01a450:	df000415 	stw	fp,16(sp)
 d01a454:	df000404 	addi	fp,sp,16
 d01a458:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 d01a45c:	e0bfff17 	ldw	r2,-4(fp)
 d01a460:	10000035 	stwio	zero,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 d01a464:	e0bfff17 	ldw	r2,-4(fp)
 d01a468:	10800104 	addi	r2,r2,4
 d01a46c:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d01a470:	0005303a 	rdctl	r2,status
 d01a474:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d01a478:	e0fffd17 	ldw	r3,-12(fp)
 d01a47c:	00bfff84 	movi	r2,-2
 d01a480:	1884703a 	and	r2,r3,r2
 d01a484:	1001703a 	wrctl	status,r2
  
  return context;
 d01a488:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 d01a48c:	e0bffe15 	stw	r2,-8(fp)
  alt_tick ();
 d01a490:	d03975c0 	call	d03975c <alt_tick>
 d01a494:	e0bffe17 	ldw	r2,-8(fp)
 d01a498:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d01a49c:	e0bffc17 	ldw	r2,-16(fp)
 d01a4a0:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 d01a4a4:	e037883a 	mov	sp,fp
 d01a4a8:	dfc00117 	ldw	ra,4(sp)
 d01a4ac:	df000017 	ldw	fp,0(sp)
 d01a4b0:	dec00204 	addi	sp,sp,8
 d01a4b4:	f800283a 	ret

0d01a4b8 <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 d01a4b8:	defff804 	addi	sp,sp,-32
 d01a4bc:	dfc00715 	stw	ra,28(sp)
 d01a4c0:	df000615 	stw	fp,24(sp)
 d01a4c4:	df000604 	addi	fp,sp,24
 d01a4c8:	e13ffc15 	stw	r4,-16(fp)
 d01a4cc:	e17ffd15 	stw	r5,-12(fp)
 d01a4d0:	e1bffe15 	stw	r6,-8(fp)
 d01a4d4:	e1ffff15 	stw	r7,-4(fp)
 d01a4d8:	e0bfff17 	ldw	r2,-4(fp)
 d01a4dc:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 d01a4e0:	00834174 	movhi	r2,3333
 d01a4e4:	108ad904 	addi	r2,r2,11108
 d01a4e8:	10800017 	ldw	r2,0(r2)
 d01a4ec:	1004c03a 	cmpne	r2,r2,zero
 d01a4f0:	1000041e 	bne	r2,zero,d01a504 <alt_avalon_timer_sc_init+0x4c>
  {
    _alt_tick_rate = nticks;
 d01a4f4:	00c34174 	movhi	r3,3333
 d01a4f8:	18cad904 	addi	r3,r3,11108
 d01a4fc:	e0bffb17 	ldw	r2,-20(fp)
 d01a500:	18800015 	stw	r2,0(r3)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 d01a504:	e0bffc17 	ldw	r2,-16(fp)
 d01a508:	10800104 	addi	r2,r2,4
 d01a50c:	1007883a 	mov	r3,r2
 d01a510:	008001c4 	movi	r2,7
 d01a514:	18800035 	stwio	r2,0(r3)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 d01a518:	d8000015 	stw	zero,0(sp)
 d01a51c:	e13ffd17 	ldw	r4,-12(fp)
 d01a520:	e17ffe17 	ldw	r5,-8(fp)
 d01a524:	018340b4 	movhi	r6,3330
 d01a528:	31a91204 	addi	r6,r6,-23480
 d01a52c:	e1fffc17 	ldw	r7,-16(fp)
 d01a530:	d038da00 	call	d038da0 <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 d01a534:	e037883a 	mov	sp,fp
 d01a538:	dfc00117 	ldw	ra,4(sp)
 d01a53c:	df000017 	ldw	fp,0(sp)
 d01a540:	dec00204 	addi	sp,sp,8
 d01a544:	f800283a 	ret

0d01a548 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 d01a548:	defffb04 	addi	sp,sp,-20
 d01a54c:	df000115 	stw	fp,4(sp)
 d01a550:	df000104 	addi	fp,sp,4
 d01a554:	e1400115 	stw	r5,4(fp)
 d01a558:	e1800215 	stw	r6,8(fp)
 d01a55c:	e1c00315 	stw	r7,12(fp)
 d01a560:	e13fff15 	stw	r4,-4(fp)
 d01a564:	e037883a 	mov	sp,fp
 d01a568:	df000017 	ldw	fp,0(sp)
 d01a56c:	dec00404 	addi	sp,sp,16
 d01a570:	f800283a 	ret

0d01a574 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 d01a574:	defffb04 	addi	sp,sp,-20
 d01a578:	df000415 	stw	fp,16(sp)
 d01a57c:	df000404 	addi	fp,sp,16
 d01a580:	e13ffc15 	stw	r4,-16(fp)
 d01a584:	e17ffd15 	stw	r5,-12(fp)
 d01a588:	e1bffe15 	stw	r6,-8(fp)
 d01a58c:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 d01a590:	e0fffd17 	ldw	r3,-12(fp)
 d01a594:	e0bffc17 	ldw	r2,-16(fp)
 d01a598:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 d01a59c:	e0fffe17 	ldw	r3,-8(fp)
 d01a5a0:	e0bffc17 	ldw	r2,-16(fp)
 d01a5a4:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 d01a5a8:	e0ffff17 	ldw	r3,-4(fp)
 d01a5ac:	e0bffc17 	ldw	r2,-16(fp)
 d01a5b0:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 d01a5b4:	e0c00117 	ldw	r3,4(fp)
 d01a5b8:	e0bffc17 	ldw	r2,-16(fp)
 d01a5bc:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 d01a5c0:	0005883a 	mov	r2,zero
}
 d01a5c4:	e037883a 	mov	sp,fp
 d01a5c8:	df000017 	ldw	fp,0(sp)
 d01a5cc:	dec00104 	addi	sp,sp,4
 d01a5d0:	f800283a 	ret

0d01a5d4 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 d01a5d4:	defff904 	addi	sp,sp,-28
 d01a5d8:	dfc00615 	stw	ra,24(sp)
 d01a5dc:	df000515 	stw	fp,20(sp)
 d01a5e0:	df000504 	addi	fp,sp,20
 d01a5e4:	e13ffd15 	stw	r4,-12(fp)
 d01a5e8:	e17ffe15 	stw	r5,-8(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 d01a5ec:	e03ffb85 	stb	zero,-18(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 d01a5f0:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 d01a5f4:	00000d06 	br	d01a62c <tse_mac_sTxWrite+0x58>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 d01a5f8:	e0bffc17 	ldw	r2,-16(fp)
 d01a5fc:	10800044 	addi	r2,r2,1
 d01a600:	e0bffc15 	stw	r2,-16(fp)
 d01a604:	e0fffc17 	ldw	r3,-16(fp)
 d01a608:	008003f4 	movhi	r2,15
 d01a60c:	10909044 	addi	r2,r2,16961
 d01a610:	1880061e 	bne	r3,r2,d01a62c <tse_mac_sTxWrite+0x58>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 d01a614:	01034174 	movhi	r4,3333
 d01a618:	21321304 	addi	r4,r4,-14260
 d01a61c:	d002cc00 	call	d002cc0 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 d01a620:	00bffa84 	movi	r2,-22
 d01a624:	e0bfff15 	stw	r2,-4(fp)
 d01a628:	00002006 	br	d01a6ac <tse_mac_sTxWrite+0xd8>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 d01a62c:	e0bffd17 	ldw	r2,-12(fp)
 d01a630:	10800117 	ldw	r2,4(r2)
 d01a634:	10800317 	ldw	r2,12(r2)
 d01a638:	10800037 	ldwio	r2,0(r2)
 d01a63c:	1080040c 	andi	r2,r2,16
 d01a640:	1004c03a 	cmpne	r2,r2,zero
 d01a644:	103fec1e 	bne	r2,zero,d01a5f8 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 d01a648:	e0bffd17 	ldw	r2,-12(fp)
 d01a64c:	10800117 	ldw	r2,4(r2)
 d01a650:	10800317 	ldw	r2,12(r2)
 d01a654:	10800404 	addi	r2,r2,16
 d01a658:	10000035 	stwio	zero,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 d01a65c:	e0bffd17 	ldw	r2,-12(fp)
 d01a660:	10800117 	ldw	r2,4(r2)
 d01a664:	10800317 	ldw	r2,12(r2)
 d01a668:	1007883a 	mov	r3,r2
 d01a66c:	00803fc4 	movi	r2,255
 d01a670:	18800035 	stwio	r2,0(r3)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 d01a674:	e0bffd17 	ldw	r2,-12(fp)
 d01a678:	11000117 	ldw	r4,4(r2)
 d01a67c:	e17ffe17 	ldw	r5,-8(fp)
 d01a680:	d0197a00 	call	d0197a0 <alt_avalon_sgdma_do_sync_transfer>
 d01a684:	e0bffb85 	stb	r2,-18(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 d01a688:	e0bffe17 	ldw	r2,-8(fp)
 d01a68c:	10800704 	addi	r2,r2,28
 d01a690:	10800037 	ldwio	r2,0(r2)
 d01a694:	1007883a 	mov	r3,r2
 d01a698:	00bfffc4 	movi	r2,-1
 d01a69c:	1884703a 	and	r2,r3,r2
 d01a6a0:	e0bffb0d 	sth	r2,-20(fp)

  return actualBytesTransferred;
 d01a6a4:	e0bffb0b 	ldhu	r2,-20(fp)
 d01a6a8:	e0bfff15 	stw	r2,-4(fp)
 d01a6ac:	e0bfff17 	ldw	r2,-4(fp)
}
 d01a6b0:	e037883a 	mov	sp,fp
 d01a6b4:	dfc00117 	ldw	ra,4(sp)
 d01a6b8:	df000017 	ldw	fp,0(sp)
 d01a6bc:	dec00204 	addi	sp,sp,8
 d01a6c0:	f800283a 	ret

0d01a6c4 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 d01a6c4:	defff904 	addi	sp,sp,-28
 d01a6c8:	dfc00615 	stw	ra,24(sp)
 d01a6cc:	df000515 	stw	fp,20(sp)
 d01a6d0:	df000504 	addi	fp,sp,20
 d01a6d4:	e13ffd15 	stw	r4,-12(fp)
 d01a6d8:	e17ffe15 	stw	r5,-8(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 d01a6dc:	e03ffb05 	stb	zero,-20(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 d01a6e0:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 d01a6e4:	00000d06 	br	d01a71c <tse_mac_aRxRead+0x58>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 d01a6e8:	e0bffc17 	ldw	r2,-16(fp)
 d01a6ec:	10800044 	addi	r2,r2,1
 d01a6f0:	e0bffc15 	stw	r2,-16(fp)
 d01a6f4:	e0fffc17 	ldw	r3,-16(fp)
 d01a6f8:	008003f4 	movhi	r2,15
 d01a6fc:	10909044 	addi	r2,r2,16961
 d01a700:	1880061e 	bne	r3,r2,d01a71c <tse_mac_aRxRead+0x58>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 d01a704:	01034174 	movhi	r4,3333
 d01a708:	21321a04 	addi	r4,r4,-14232
 d01a70c:	d002cc00 	call	d002cc0 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 d01a710:	00bffa84 	movi	r2,-22
 d01a714:	e0bfff15 	stw	r2,-4(fp)
 d01a718:	00000d06 	br	d01a750 <tse_mac_aRxRead+0x8c>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 d01a71c:	e0bffd17 	ldw	r2,-12(fp)
 d01a720:	10800217 	ldw	r2,8(r2)
 d01a724:	10800317 	ldw	r2,12(r2)
 d01a728:	10800037 	ldwio	r2,0(r2)
 d01a72c:	1080040c 	andi	r2,r2,16
 d01a730:	1004c03a 	cmpne	r2,r2,zero
 d01a734:	103fec1e 	bne	r2,zero,d01a6e8 <tse_mac_aRxRead+0x24>
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 d01a738:	e0bffd17 	ldw	r2,-12(fp)
 d01a73c:	11000217 	ldw	r4,8(r2)
 d01a740:	e17ffe17 	ldw	r5,-8(fp)
 d01a744:	d0196640 	call	d019664 <alt_avalon_sgdma_do_async_transfer>
 d01a748:	e0bffb05 	stb	r2,-20(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
 d01a74c:	e03fff15 	stw	zero,-4(fp)
 d01a750:	e0bfff17 	ldw	r2,-4(fp)
}
 d01a754:	e037883a 	mov	sp,fp
 d01a758:	dfc00117 	ldw	ra,4(sp)
 d01a75c:	df000017 	ldw	fp,0(sp)
 d01a760:	dec00204 	addi	sp,sp,8
 d01a764:	f800283a 	ret

0d01a768 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 d01a768:	defffc04 	addi	sp,sp,-16
 d01a76c:	df000315 	stw	fp,12(sp)
 d01a770:	df000304 	addi	fp,sp,12
 d01a774:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d01a778:	e0bfff17 	ldw	r2,-4(fp)
 d01a77c:	10800204 	addi	r2,r2,8
 d01a780:	10800037 	ldwio	r2,0(r2)
 d01a784:	e0bffd15 	stw	r2,-12(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 d01a788:	e0bfff17 	ldw	r2,-4(fp)
 d01a78c:	10800204 	addi	r2,r2,8
 d01a790:	1007883a 	mov	r3,r2
 d01a794:	00880204 	movi	r2,8200
 d01a798:	18800035 	stwio	r2,0(r3)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 d01a79c:	e03ffe15 	stw	zero,-8(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 d01a7a0:	00000306 	br	d01a7b0 <tse_mac_SwReset+0x48>
 d01a7a4:	e0bffe17 	ldw	r2,-8(fp)
 d01a7a8:	10800044 	addi	r2,r2,1
 d01a7ac:	e0bffe15 	stw	r2,-8(fp)
 d01a7b0:	e0bfff17 	ldw	r2,-4(fp)
 d01a7b4:	10800204 	addi	r2,r2,8
 d01a7b8:	10800037 	ldwio	r2,0(r2)
 d01a7bc:	1088000c 	andi	r2,r2,8192
 d01a7c0:	1005003a 	cmpeq	r2,r2,zero
 d01a7c4:	1000031e 	bne	r2,zero,d01a7d4 <tse_mac_SwReset+0x6c>
 d01a7c8:	e0bffe17 	ldw	r2,-8(fp)
 d01a7cc:	1089c410 	cmplti	r2,r2,10000
 d01a7d0:	103ff41e 	bne	r2,zero,d01a7a4 <tse_mac_SwReset+0x3c>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 d01a7d4:	e0bfff17 	ldw	r2,-4(fp)
 d01a7d8:	10800204 	addi	r2,r2,8
 d01a7dc:	1007883a 	mov	r3,r2
 d01a7e0:	e0bffd17 	ldw	r2,-12(fp)
 d01a7e4:	18800035 	stwio	r2,0(r3)
    return SUCCESS;
 d01a7e8:	0005883a 	mov	r2,zero
}
 d01a7ec:	e037883a 	mov	sp,fp
 d01a7f0:	df000017 	ldw	fp,0(sp)
 d01a7f4:	dec00104 	addi	sp,sp,4
 d01a7f8:	f800283a 	ret

0d01a7fc <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 d01a7fc:	defffd04 	addi	sp,sp,-12
 d01a800:	df000215 	stw	fp,8(sp)
 d01a804:	df000204 	addi	fp,sp,8
 d01a808:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d01a80c:	e0bfff17 	ldw	r2,-4(fp)
 d01a810:	10800204 	addi	r2,r2,8
 d01a814:	10800037 	ldwio	r2,0(r2)
 d01a818:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 d01a81c:	e0fffe17 	ldw	r3,-8(fp)
 d01a820:	00bffdc4 	movi	r2,-9
 d01a824:	1884703a 	and	r2,r3,r2
 d01a828:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 d01a82c:	e0bfff17 	ldw	r2,-4(fp)
 d01a830:	10800204 	addi	r2,r2,8
 d01a834:	1007883a 	mov	r3,r2
 d01a838:	e0bffe17 	ldw	r2,-8(fp)
 d01a83c:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 d01a840:	0005883a 	mov	r2,zero
}
 d01a844:	e037883a 	mov	sp,fp
 d01a848:	df000017 	ldw	fp,0(sp)
 d01a84c:	dec00104 	addi	sp,sp,4
 d01a850:	f800283a 	ret

0d01a854 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 d01a854:	defffd04 	addi	sp,sp,-12
 d01a858:	df000215 	stw	fp,8(sp)
 d01a85c:	df000204 	addi	fp,sp,8
 d01a860:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d01a864:	e0bfff17 	ldw	r2,-4(fp)
 d01a868:	10800204 	addi	r2,r2,8
 d01a86c:	10800037 	ldwio	r2,0(r2)
 d01a870:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d01a874:	e0bffe17 	ldw	r2,-8(fp)
 d01a878:	10800214 	ori	r2,r2,8
 d01a87c:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 d01a880:	e0bfff17 	ldw	r2,-4(fp)
 d01a884:	10800204 	addi	r2,r2,8
 d01a888:	1007883a 	mov	r3,r2
 d01a88c:	e0bffe17 	ldw	r2,-8(fp)
 d01a890:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 d01a894:	0005883a 	mov	r2,zero
}
 d01a898:	e037883a 	mov	sp,fp
 d01a89c:	df000017 	ldw	fp,0(sp)
 d01a8a0:	dec00104 	addi	sp,sp,4
 d01a8a4:	f800283a 	ret

0d01a8a8 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 d01a8a8:	defffa04 	addi	sp,sp,-24
 d01a8ac:	dfc00515 	stw	ra,20(sp)
 d01a8b0:	df000415 	stw	fp,16(sp)
 d01a8b4:	dc000315 	stw	r16,12(sp)
 d01a8b8:	df000304 	addi	fp,sp,12
 d01a8bc:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 d01a8c0:	e03ffd15 	stw	zero,-12(fp)
 d01a8c4:	00002706 	br	d01a964 <alt_tse_phy_add_profile+0xbc>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 d01a8c8:	e0bffd17 	ldw	r2,-12(fp)
 d01a8cc:	00c341b4 	movhi	r3,3334
 d01a8d0:	18f18404 	addi	r3,r3,-14832
 d01a8d4:	1085883a 	add	r2,r2,r2
 d01a8d8:	1085883a 	add	r2,r2,r2
 d01a8dc:	10c5883a 	add	r2,r2,r3
 d01a8e0:	10800017 	ldw	r2,0(r2)
 d01a8e4:	10c01417 	ldw	r3,80(r2)
 d01a8e8:	e0bffe17 	ldw	r2,-8(fp)
 d01a8ec:	10801417 	ldw	r2,80(r2)
 d01a8f0:	1880191e 	bne	r3,r2,d01a958 <alt_tse_phy_add_profile+0xb0>
 d01a8f4:	e0bffd17 	ldw	r2,-12(fp)
 d01a8f8:	00c341b4 	movhi	r3,3334
 d01a8fc:	18f18404 	addi	r3,r3,-14832
 d01a900:	1085883a 	add	r2,r2,r2
 d01a904:	1085883a 	add	r2,r2,r2
 d01a908:	10c5883a 	add	r2,r2,r3
 d01a90c:	10800017 	ldw	r2,0(r2)
 d01a910:	10c01503 	ldbu	r3,84(r2)
 d01a914:	e0bffe17 	ldw	r2,-8(fp)
 d01a918:	10801503 	ldbu	r2,84(r2)
 d01a91c:	18c03fcc 	andi	r3,r3,255
 d01a920:	10803fcc 	andi	r2,r2,255
 d01a924:	18800c1e 	bne	r3,r2,d01a958 <alt_tse_phy_add_profile+0xb0>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 d01a928:	e0bffe17 	ldw	r2,-8(fp)
 d01a92c:	10801417 	ldw	r2,80(r2)
 d01a930:	100b883a 	mov	r5,r2
 d01a934:	e0bffe17 	ldw	r2,-8(fp)
 d01a938:	10801503 	ldbu	r2,84(r2)
 d01a93c:	11803fcc 	andi	r6,r2,255
 d01a940:	01034174 	movhi	r4,3333
 d01a944:	21322104 	addi	r4,r4,-14204
 d01a948:	d0029980 	call	d002998 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 d01a94c:	01034174 	movhi	r4,3333
 d01a950:	21323504 	addi	r4,r4,-14124
 d01a954:	d002cc00 	call	d002cc0 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 d01a958:	e0bffd17 	ldw	r2,-12(fp)
 d01a95c:	10800044 	addi	r2,r2,1
 d01a960:	e0bffd15 	stw	r2,-12(fp)
 d01a964:	d0a07f03 	ldbu	r2,-32260(gp)
 d01a968:	10c03fcc 	andi	r3,r2,255
 d01a96c:	e0bffd17 	ldw	r2,-12(fp)
 d01a970:	10ffd516 	blt	r2,r3,d01a8c8 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 d01a974:	d0a07f03 	ldbu	r2,-32260(gp)
 d01a978:	14003fcc 	andi	r16,r2,255
 d01a97c:	01001904 	movi	r4,100
 d01a980:	d049ec00 	call	d049ec0 <malloc>
 d01a984:	1009883a 	mov	r4,r2
 d01a988:	00c341b4 	movhi	r3,3334
 d01a98c:	18f18404 	addi	r3,r3,-14832
 d01a990:	8405883a 	add	r2,r16,r16
 d01a994:	1085883a 	add	r2,r2,r2
 d01a998:	10c5883a 	add	r2,r2,r3
 d01a99c:	11000015 	stw	r4,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 d01a9a0:	d0a07f03 	ldbu	r2,-32260(gp)
 d01a9a4:	10803fcc 	andi	r2,r2,255
 d01a9a8:	00c341b4 	movhi	r3,3334
 d01a9ac:	18f18404 	addi	r3,r3,-14832
 d01a9b0:	1085883a 	add	r2,r2,r2
 d01a9b4:	1085883a 	add	r2,r2,r2
 d01a9b8:	10c5883a 	add	r2,r2,r3
 d01a9bc:	10800017 	ldw	r2,0(r2)
 d01a9c0:	1004c03a 	cmpne	r2,r2,zero
 d01a9c4:	1000081e 	bne	r2,zero,d01a9e8 <alt_tse_phy_add_profile+0x140>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 d01a9c8:	d0a07f03 	ldbu	r2,-32260(gp)
 d01a9cc:	11403fcc 	andi	r5,r2,255
 d01a9d0:	01034174 	movhi	r4,3333
 d01a9d4:	21324d04 	addi	r4,r4,-14028
 d01a9d8:	d0029980 	call	d002998 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 d01a9dc:	00bfffc4 	movi	r2,-1
 d01a9e0:	e0bfff15 	stw	r2,-4(fp)
 d01a9e4:	00001f06 	br	d01aa64 <alt_tse_phy_add_profile+0x1bc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 d01a9e8:	d0a07f03 	ldbu	r2,-32260(gp)
 d01a9ec:	10803fcc 	andi	r2,r2,255
 d01a9f0:	00c341b4 	movhi	r3,3334
 d01a9f4:	18f18404 	addi	r3,r3,-14832
 d01a9f8:	1085883a 	add	r2,r2,r2
 d01a9fc:	1085883a 	add	r2,r2,r2
 d01aa00:	10c5883a 	add	r2,r2,r3
 d01aa04:	10800017 	ldw	r2,0(r2)
 d01aa08:	e0fffe17 	ldw	r3,-8(fp)
 d01aa0c:	1009883a 	mov	r4,r2
 d01aa10:	180b883a 	mov	r5,r3
 d01aa14:	01801904 	movi	r6,100
 d01aa18:	d0027000 	call	d002700 <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 d01aa1c:	d0a07f03 	ldbu	r2,-32260(gp)
 d01aa20:	10803fcc 	andi	r2,r2,255
 d01aa24:	00c341b4 	movhi	r3,3334
 d01aa28:	18f18404 	addi	r3,r3,-14832
 d01aa2c:	1085883a 	add	r2,r2,r2
 d01aa30:	1085883a 	add	r2,r2,r2
 d01aa34:	10c5883a 	add	r2,r2,r3
 d01aa38:	10800017 	ldw	r2,0(r2)
 d01aa3c:	1009883a 	mov	r4,r2
 d01aa40:	e17ffe17 	ldw	r5,-8(fp)
 d01aa44:	d049f480 	call	d049f48 <strcpy>
    
    phy_profile_count++;
 d01aa48:	d0a07f03 	ldbu	r2,-32260(gp)
 d01aa4c:	10800044 	addi	r2,r2,1
 d01aa50:	d0a07f05 	stb	r2,-32260(gp)
    
    return phy_profile_count - 1;
 d01aa54:	d0a07f03 	ldbu	r2,-32260(gp)
 d01aa58:	10803fcc 	andi	r2,r2,255
 d01aa5c:	10bfffc4 	addi	r2,r2,-1
 d01aa60:	e0bfff15 	stw	r2,-4(fp)
 d01aa64:	e0bfff17 	ldw	r2,-4(fp)
}
 d01aa68:	e037883a 	mov	sp,fp
 d01aa6c:	dfc00217 	ldw	ra,8(sp)
 d01aa70:	df000117 	ldw	fp,4(sp)
 d01aa74:	dc000017 	ldw	r16,0(sp)
 d01aa78:	dec00304 	addi	sp,sp,12
 d01aa7c:	f800283a 	ret

0d01aa80 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 d01aa80:	defff104 	addi	sp,sp,-60
 d01aa84:	dfc00e15 	stw	ra,56(sp)
 d01aa88:	df000d15 	stw	fp,52(sp)
 d01aa8c:	dc000c15 	stw	r16,48(sp)
 d01aa90:	df000c04 	addi	fp,sp,48
 d01aa94:	e13ffb15 	stw	r4,-20(fp)
 d01aa98:	e17ffc15 	stw	r5,-16(fp)
 d01aa9c:	e1bffd15 	stw	r6,-12(fp)
 d01aaa0:	e1fffe15 	stw	r7,-8(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 d01aaa4:	e0bffb17 	ldw	r2,-20(fp)
 d01aaa8:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 d01aaac:	e0bffc17 	ldw	r2,-16(fp)
 d01aab0:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 d01aab4:	e0bffd17 	ldw	r2,-12(fp)
 d01aab8:	e0bff615 	stw	r2,-40(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 d01aabc:	e0bffe17 	ldw	r2,-8(fp)
 d01aac0:	e0bff515 	stw	r2,-44(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 d01aac4:	e0800317 	ldw	r2,12(fp)
 d01aac8:	e0bff415 	stw	r2,-48(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 d01aacc:	e0bff817 	ldw	r2,-32(fp)
 d01aad0:	10800303 	ldbu	r2,12(r2)
 d01aad4:	10803fcc 	andi	r2,r2,255
 d01aad8:	1004c03a 	cmpne	r2,r2,zero
 d01aadc:	1000031e 	bne	r2,zero,d01aaec <alt_tse_system_add_sys+0x6c>
		loop_end = 1;
 d01aae0:	00800044 	movi	r2,1
 d01aae4:	e0bff915 	stw	r2,-28(fp)
 d01aae8:	00001006 	br	d01ab2c <alt_tse_system_add_sys+0xac>
	}
	else if(pmac->tse_num_of_channel > 0) {
 d01aaec:	e0bff817 	ldw	r2,-32(fp)
 d01aaf0:	10800303 	ldbu	r2,12(r2)
 d01aaf4:	10803fcc 	andi	r2,r2,255
 d01aaf8:	1005003a 	cmpeq	r2,r2,zero
 d01aafc:	1000051e 	bne	r2,zero,d01ab14 <alt_tse_system_add_sys+0x94>
		loop_end = pmac->tse_num_of_channel; 
 d01ab00:	e0bff817 	ldw	r2,-32(fp)
 d01ab04:	10800303 	ldbu	r2,12(r2)
 d01ab08:	10803fcc 	andi	r2,r2,255
 d01ab0c:	e0bff915 	stw	r2,-28(fp)
 d01ab10:	00000606 	br	d01ab2c <alt_tse_system_add_sys+0xac>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 d01ab14:	01034174 	movhi	r4,3333
 d01ab18:	21325c04 	addi	r4,r4,-13968
 d01ab1c:	d002cc00 	call	d002cc0 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d01ab20:	00bfffc4 	movi	r2,-1
 d01ab24:	e0bfff15 	stw	r2,-4(fp)
 d01ab28:	00025306 	br	d01b478 <alt_tse_system_add_sys+0x9f8>
	}

	for(i = 0; i < loop_end; i++) {
 d01ab2c:	e03ffa15 	stw	zero,-24(fp)
 d01ab30:	00024d06 	br	d01b468 <alt_tse_system_add_sys+0x9e8>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 d01ab34:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ab38:	10803fcc 	andi	r2,r2,255
 d01ab3c:	1080201c 	xori	r2,r2,128
 d01ab40:	10bfe004 	addi	r2,r2,-128
 d01ab44:	10800110 	cmplti	r2,r2,4
 d01ab48:	10000b1e 	bne	r2,zero,d01ab78 <alt_tse_system_add_sys+0xf8>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 d01ab4c:	01034174 	movhi	r4,3333
 d01ab50:	21326804 	addi	r4,r4,-13920
 d01ab54:	d002cc00 	call	d002cc0 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 d01ab58:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ab5c:	11803fcc 	andi	r6,r2,255
 d01ab60:	3180201c 	xori	r6,r6,128
 d01ab64:	31bfe004 	addi	r6,r6,-128
 d01ab68:	01034174 	movhi	r4,3333
 d01ab6c:	21327804 	addi	r4,r4,-13856
 d01ab70:	01400104 	movi	r5,4
 d01ab74:	d0029980 	call	d002998 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 d01ab78:	e0bff817 	ldw	r2,-32(fp)
 d01ab7c:	1004c03a 	cmpne	r2,r2,zero
 d01ab80:	1000091e 	bne	r2,zero,d01aba8 <alt_tse_system_add_sys+0x128>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 d01ab84:	01034174 	movhi	r4,3333
 d01ab88:	21328704 	addi	r4,r4,-13796
 d01ab8c:	d002cc00 	call	d002cc0 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 d01ab90:	01034174 	movhi	r4,3333
 d01ab94:	21329104 	addi	r4,r4,-13756
 d01ab98:	d002cc00 	call	d002cc0 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d01ab9c:	00bfffc4 	movi	r2,-1
 d01aba0:	e0bfff15 	stw	r2,-4(fp)
 d01aba4:	00023406 	br	d01b478 <alt_tse_system_add_sys+0x9f8>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 d01aba8:	d0a07f83 	ldbu	r2,-32258(gp)
 d01abac:	11403fcc 	andi	r5,r2,255
 d01abb0:	2940201c 	xori	r5,r5,128
 d01abb4:	297fe004 	addi	r5,r5,-128
 d01abb8:	e0bff817 	ldw	r2,-32(fp)
 d01abbc:	10c00017 	ldw	r3,0(r2)
 d01abc0:	e0bffa17 	ldw	r2,-24(fp)
 d01abc4:	100492ba 	slli	r2,r2,10
 d01abc8:	1889883a 	add	r4,r3,r2
 d01abcc:	00c34174 	movhi	r3,3333
 d01abd0:	18c23004 	addi	r3,r3,2240
 d01abd4:	28801224 	muli	r2,r5,72
 d01abd8:	10c5883a 	add	r2,r2,r3
 d01abdc:	11000015 	stw	r4,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 d01abe0:	d0a07f83 	ldbu	r2,-32258(gp)
 d01abe4:	11003fcc 	andi	r4,r2,255
 d01abe8:	2100201c 	xori	r4,r4,128
 d01abec:	213fe004 	addi	r4,r4,-128
 d01abf0:	e0bff817 	ldw	r2,-32(fp)
 d01abf4:	1140010b 	ldhu	r5,4(r2)
 d01abf8:	00c34174 	movhi	r3,3333
 d01abfc:	18c23004 	addi	r3,r3,2240
 d01ac00:	20801224 	muli	r2,r4,72
 d01ac04:	10c5883a 	add	r2,r2,r3
 d01ac08:	10800104 	addi	r2,r2,4
 d01ac0c:	1140000d 	sth	r5,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 d01ac10:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ac14:	11003fcc 	andi	r4,r2,255
 d01ac18:	2100201c 	xori	r4,r4,128
 d01ac1c:	213fe004 	addi	r4,r4,-128
 d01ac20:	e0bff817 	ldw	r2,-32(fp)
 d01ac24:	1140018b 	ldhu	r5,6(r2)
 d01ac28:	00c34174 	movhi	r3,3333
 d01ac2c:	18c23004 	addi	r3,r3,2240
 d01ac30:	20801224 	muli	r2,r4,72
 d01ac34:	10c5883a 	add	r2,r2,r3
 d01ac38:	10800104 	addi	r2,r2,4
 d01ac3c:	1140008d 	sth	r5,2(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 d01ac40:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ac44:	11003fcc 	andi	r4,r2,255
 d01ac48:	2100201c 	xori	r4,r4,128
 d01ac4c:	213fe004 	addi	r4,r4,-128
 d01ac50:	e0bff817 	ldw	r2,-32(fp)
 d01ac54:	11400203 	ldbu	r5,8(r2)
 d01ac58:	00c34174 	movhi	r3,3333
 d01ac5c:	18c23004 	addi	r3,r3,2240
 d01ac60:	20801224 	muli	r2,r4,72
 d01ac64:	10c5883a 	add	r2,r2,r3
 d01ac68:	10800204 	addi	r2,r2,8
 d01ac6c:	11400005 	stb	r5,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 d01ac70:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ac74:	11003fcc 	andi	r4,r2,255
 d01ac78:	2100201c 	xori	r4,r4,128
 d01ac7c:	213fe004 	addi	r4,r4,-128
 d01ac80:	e0bff817 	ldw	r2,-32(fp)
 d01ac84:	11400243 	ldbu	r5,9(r2)
 d01ac88:	00c34174 	movhi	r3,3333
 d01ac8c:	18c23004 	addi	r3,r3,2240
 d01ac90:	20801224 	muli	r2,r4,72
 d01ac94:	10c5883a 	add	r2,r2,r3
 d01ac98:	10800204 	addi	r2,r2,8
 d01ac9c:	11400045 	stb	r5,1(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 d01aca0:	d0a07f83 	ldbu	r2,-32258(gp)
 d01aca4:	11003fcc 	andi	r4,r2,255
 d01aca8:	2100201c 	xori	r4,r4,128
 d01acac:	213fe004 	addi	r4,r4,-128
 d01acb0:	e0bff817 	ldw	r2,-32(fp)
 d01acb4:	11400283 	ldbu	r5,10(r2)
 d01acb8:	00c34174 	movhi	r3,3333
 d01acbc:	18c23004 	addi	r3,r3,2240
 d01acc0:	20801224 	muli	r2,r4,72
 d01acc4:	10c5883a 	add	r2,r2,r3
 d01acc8:	10800204 	addi	r2,r2,8
 d01accc:	11400085 	stb	r5,2(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 d01acd0:	d0a07f83 	ldbu	r2,-32258(gp)
 d01acd4:	11003fcc 	andi	r4,r2,255
 d01acd8:	2100201c 	xori	r4,r4,128
 d01acdc:	213fe004 	addi	r4,r4,-128
 d01ace0:	e0bff817 	ldw	r2,-32(fp)
 d01ace4:	114002c3 	ldbu	r5,11(r2)
 d01ace8:	00c34174 	movhi	r3,3333
 d01acec:	18c23004 	addi	r3,r3,2240
 d01acf0:	20801224 	muli	r2,r4,72
 d01acf4:	10c5883a 	add	r2,r2,r3
 d01acf8:	10800204 	addi	r2,r2,8
 d01acfc:	114000c5 	stb	r5,3(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 d01ad00:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ad04:	11003fcc 	andi	r4,r2,255
 d01ad08:	2100201c 	xori	r4,r4,128
 d01ad0c:	213fe004 	addi	r4,r4,-128
 d01ad10:	e0bff817 	ldw	r2,-32(fp)
 d01ad14:	11400303 	ldbu	r5,12(r2)
 d01ad18:	00c34174 	movhi	r3,3333
 d01ad1c:	18c23004 	addi	r3,r3,2240
 d01ad20:	20801224 	muli	r2,r4,72
 d01ad24:	10c5883a 	add	r2,r2,r3
 d01ad28:	10800304 	addi	r2,r2,12
 d01ad2c:	11400005 	stb	r5,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 d01ad30:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ad34:	11003fcc 	andi	r4,r2,255
 d01ad38:	2100201c 	xori	r4,r4,128
 d01ad3c:	213fe004 	addi	r4,r4,-128
 d01ad40:	e0bff817 	ldw	r2,-32(fp)
 d01ad44:	11400343 	ldbu	r5,13(r2)
 d01ad48:	00c34174 	movhi	r3,3333
 d01ad4c:	18c23004 	addi	r3,r3,2240
 d01ad50:	20801224 	muli	r2,r4,72
 d01ad54:	10c5883a 	add	r2,r2,r3
 d01ad58:	10800304 	addi	r2,r2,12
 d01ad5c:	11400045 	stb	r5,1(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 d01ad60:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ad64:	11003fcc 	andi	r4,r2,255
 d01ad68:	2100201c 	xori	r4,r4,128
 d01ad6c:	213fe004 	addi	r4,r4,-128
 d01ad70:	e0bff817 	ldw	r2,-32(fp)
 d01ad74:	11400383 	ldbu	r5,14(r2)
 d01ad78:	00c34174 	movhi	r3,3333
 d01ad7c:	18c23004 	addi	r3,r3,2240
 d01ad80:	20801224 	muli	r2,r4,72
 d01ad84:	10c5883a 	add	r2,r2,r3
 d01ad88:	10800304 	addi	r2,r2,12
 d01ad8c:	11400085 	stb	r5,2(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 d01ad90:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ad94:	11003fcc 	andi	r4,r2,255
 d01ad98:	2100201c 	xori	r4,r4,128
 d01ad9c:	213fe004 	addi	r4,r4,-128
 d01ada0:	e0bff817 	ldw	r2,-32(fp)
 d01ada4:	114003c3 	ldbu	r5,15(r2)
 d01ada8:	00c34174 	movhi	r3,3333
 d01adac:	18c23004 	addi	r3,r3,2240
 d01adb0:	20801224 	muli	r2,r4,72
 d01adb4:	10c5883a 	add	r2,r2,r3
 d01adb8:	10800304 	addi	r2,r2,12
 d01adbc:	114000c5 	stb	r5,3(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 d01adc0:	d0a07f83 	ldbu	r2,-32258(gp)
 d01adc4:	11003fcc 	andi	r4,r2,255
 d01adc8:	2100201c 	xori	r4,r4,128
 d01adcc:	213fe004 	addi	r4,r4,-128
 d01add0:	e0bff817 	ldw	r2,-32(fp)
 d01add4:	11400403 	ldbu	r5,16(r2)
 d01add8:	00c34174 	movhi	r3,3333
 d01addc:	18c23004 	addi	r3,r3,2240
 d01ade0:	20801224 	muli	r2,r4,72
 d01ade4:	10c5883a 	add	r2,r2,r3
 d01ade8:	10800404 	addi	r2,r2,16
 d01adec:	11400005 	stb	r5,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 d01adf0:	e0bff717 	ldw	r2,-36(fp)
 d01adf4:	1004c03a 	cmpne	r2,r2,zero
 d01adf8:	10000d1e 	bne	r2,zero,d01ae30 <alt_tse_system_add_sys+0x3b0>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 d01adfc:	01034174 	movhi	r4,3333
 d01ae00:	2132a304 	addi	r4,r4,-13684
 d01ae04:	d002cc00 	call	d002cc0 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 d01ae08:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ae0c:	11403fcc 	andi	r5,r2,255
 d01ae10:	2940201c 	xori	r5,r5,128
 d01ae14:	297fe004 	addi	r5,r5,-128
 d01ae18:	01034174 	movhi	r4,3333
 d01ae1c:	2132ae04 	addi	r4,r4,-13640
 d01ae20:	d0029980 	call	d002998 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d01ae24:	00bfffc4 	movi	r2,-1
 d01ae28:	e0bfff15 	stw	r2,-4(fp)
 d01ae2c:	00019206 	br	d01b478 <alt_tse_system_add_sys+0x9f8>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 d01ae30:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ae34:	14003fcc 	andi	r16,r2,255
 d01ae38:	8400201c 	xori	r16,r16,128
 d01ae3c:	843fe004 	addi	r16,r16,-128
 d01ae40:	e0bff717 	ldw	r2,-36(fp)
 d01ae44:	11000017 	ldw	r4,0(r2)
 d01ae48:	d00355c0 	call	d00355c <strlen>
 d01ae4c:	11000044 	addi	r4,r2,1
 d01ae50:	d049ec00 	call	d049ec0 <malloc>
 d01ae54:	1009883a 	mov	r4,r2
 d01ae58:	00c34174 	movhi	r3,3333
 d01ae5c:	18c23004 	addi	r3,r3,2240
 d01ae60:	80801224 	muli	r2,r16,72
 d01ae64:	10c5883a 	add	r2,r2,r3
 d01ae68:	10800504 	addi	r2,r2,20
 d01ae6c:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 d01ae70:	d0a07f83 	ldbu	r2,-32258(gp)
 d01ae74:	10803fcc 	andi	r2,r2,255
 d01ae78:	1080201c 	xori	r2,r2,128
 d01ae7c:	10bfe004 	addi	r2,r2,-128
 d01ae80:	00c34174 	movhi	r3,3333
 d01ae84:	18c23004 	addi	r3,r3,2240
 d01ae88:	10801224 	muli	r2,r2,72
 d01ae8c:	10c5883a 	add	r2,r2,r3
 d01ae90:	10800504 	addi	r2,r2,20
 d01ae94:	10800017 	ldw	r2,0(r2)
 d01ae98:	1004c03a 	cmpne	r2,r2,zero
 d01ae9c:	10000a1e 	bne	r2,zero,d01aec8 <alt_tse_system_add_sys+0x448>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 d01aea0:	d0a07f83 	ldbu	r2,-32258(gp)
 d01aea4:	11403fcc 	andi	r5,r2,255
 d01aea8:	2940201c 	xori	r5,r5,128
 d01aeac:	297fe004 	addi	r5,r5,-128
 d01aeb0:	01034174 	movhi	r4,3333
 d01aeb4:	2132c604 	addi	r4,r4,-13544
 d01aeb8:	d0029980 	call	d002998 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 d01aebc:	00bfffc4 	movi	r2,-1
 d01aec0:	e0bfff15 	stw	r2,-4(fp)
 d01aec4:	00016c06 	br	d01b478 <alt_tse_system_add_sys+0x9f8>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 d01aec8:	d0a07f83 	ldbu	r2,-32258(gp)
 d01aecc:	10803fcc 	andi	r2,r2,255
 d01aed0:	1080201c 	xori	r2,r2,128
 d01aed4:	10bfe004 	addi	r2,r2,-128
 d01aed8:	00c34174 	movhi	r3,3333
 d01aedc:	18c23004 	addi	r3,r3,2240
 d01aee0:	10801224 	muli	r2,r2,72
 d01aee4:	10c5883a 	add	r2,r2,r3
 d01aee8:	10800504 	addi	r2,r2,20
 d01aeec:	11000017 	ldw	r4,0(r2)
 d01aef0:	e0bff717 	ldw	r2,-36(fp)
 d01aef4:	11400017 	ldw	r5,0(r2)
 d01aef8:	d049f480 	call	d049f48 <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 d01aefc:	d0a07f83 	ldbu	r2,-32258(gp)
 d01af00:	14003fcc 	andi	r16,r2,255
 d01af04:	8400201c 	xori	r16,r16,128
 d01af08:	843fe004 	addi	r16,r16,-128
 d01af0c:	e0bff717 	ldw	r2,-36(fp)
 d01af10:	11000117 	ldw	r4,4(r2)
 d01af14:	d00355c0 	call	d00355c <strlen>
 d01af18:	11000044 	addi	r4,r2,1
 d01af1c:	d049ec00 	call	d049ec0 <malloc>
 d01af20:	1009883a 	mov	r4,r2
 d01af24:	00c34174 	movhi	r3,3333
 d01af28:	18c23004 	addi	r3,r3,2240
 d01af2c:	80801224 	muli	r2,r16,72
 d01af30:	10c5883a 	add	r2,r2,r3
 d01af34:	10800604 	addi	r2,r2,24
 d01af38:	11000015 	stw	r4,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 d01af3c:	d0a07f83 	ldbu	r2,-32258(gp)
 d01af40:	10803fcc 	andi	r2,r2,255
 d01af44:	1080201c 	xori	r2,r2,128
 d01af48:	10bfe004 	addi	r2,r2,-128
 d01af4c:	00c34174 	movhi	r3,3333
 d01af50:	18c23004 	addi	r3,r3,2240
 d01af54:	10801224 	muli	r2,r2,72
 d01af58:	10c5883a 	add	r2,r2,r3
 d01af5c:	10800604 	addi	r2,r2,24
 d01af60:	10800017 	ldw	r2,0(r2)
 d01af64:	1004c03a 	cmpne	r2,r2,zero
 d01af68:	10000a1e 	bne	r2,zero,d01af94 <alt_tse_system_add_sys+0x514>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 d01af6c:	d0a07f83 	ldbu	r2,-32258(gp)
 d01af70:	11403fcc 	andi	r5,r2,255
 d01af74:	2940201c 	xori	r5,r5,128
 d01af78:	297fe004 	addi	r5,r5,-128
 d01af7c:	01034174 	movhi	r4,3333
 d01af80:	2132d904 	addi	r4,r4,-13468
 d01af84:	d0029980 	call	d002998 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 d01af88:	00bfffc4 	movi	r2,-1
 d01af8c:	e0bfff15 	stw	r2,-4(fp)
 d01af90:	00013906 	br	d01b478 <alt_tse_system_add_sys+0x9f8>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 d01af94:	d0a07f83 	ldbu	r2,-32258(gp)
 d01af98:	10803fcc 	andi	r2,r2,255
 d01af9c:	1080201c 	xori	r2,r2,128
 d01afa0:	10bfe004 	addi	r2,r2,-128
 d01afa4:	00c34174 	movhi	r3,3333
 d01afa8:	18c23004 	addi	r3,r3,2240
 d01afac:	10801224 	muli	r2,r2,72
 d01afb0:	10c5883a 	add	r2,r2,r3
 d01afb4:	10800604 	addi	r2,r2,24
 d01afb8:	11000017 	ldw	r4,0(r2)
 d01afbc:	e0bff717 	ldw	r2,-36(fp)
 d01afc0:	11400117 	ldw	r5,4(r2)
 d01afc4:	d049f480 	call	d049f48 <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 d01afc8:	d0a07f83 	ldbu	r2,-32258(gp)
 d01afcc:	11003fcc 	andi	r4,r2,255
 d01afd0:	2100201c 	xori	r4,r4,128
 d01afd4:	213fe004 	addi	r4,r4,-128
 d01afd8:	e0bff717 	ldw	r2,-36(fp)
 d01afdc:	1140020b 	ldhu	r5,8(r2)
 d01afe0:	00c34174 	movhi	r3,3333
 d01afe4:	18c23004 	addi	r3,r3,2240
 d01afe8:	20801224 	muli	r2,r4,72
 d01afec:	10c5883a 	add	r2,r2,r3
 d01aff0:	10800704 	addi	r2,r2,28
 d01aff4:	1140000d 	sth	r5,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 d01aff8:	e0bff617 	ldw	r2,-40(fp)
 d01affc:	1004c03a 	cmpne	r2,r2,zero
 d01b000:	1000151e 	bne	r2,zero,d01b058 <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 d01b004:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b008:	10803fcc 	andi	r2,r2,255
 d01b00c:	1080201c 	xori	r2,r2,128
 d01b010:	10bfe004 	addi	r2,r2,-128
 d01b014:	00c34174 	movhi	r3,3333
 d01b018:	18c23004 	addi	r3,r3,2240
 d01b01c:	10801224 	muli	r2,r2,72
 d01b020:	10c5883a 	add	r2,r2,r3
 d01b024:	10800704 	addi	r2,r2,28
 d01b028:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 d01b02c:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b030:	10803fcc 	andi	r2,r2,255
 d01b034:	1080201c 	xori	r2,r2,128
 d01b038:	10bfe004 	addi	r2,r2,-128
 d01b03c:	00c34174 	movhi	r3,3333
 d01b040:	18c23004 	addi	r3,r3,2240
 d01b044:	10801224 	muli	r2,r2,72
 d01b048:	10c5883a 	add	r2,r2,r3
 d01b04c:	10800804 	addi	r2,r2,32
 d01b050:	10000015 	stw	zero,0(r2)
 d01b054:	00001806 	br	d01b0b8 <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 d01b058:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b05c:	11003fcc 	andi	r4,r2,255
 d01b060:	2100201c 	xori	r4,r4,128
 d01b064:	213fe004 	addi	r4,r4,-128
 d01b068:	e0bff617 	ldw	r2,-40(fp)
 d01b06c:	11400003 	ldbu	r5,0(r2)
 d01b070:	00c34174 	movhi	r3,3333
 d01b074:	18c23004 	addi	r3,r3,2240
 d01b078:	20801224 	muli	r2,r4,72
 d01b07c:	10c5883a 	add	r2,r2,r3
 d01b080:	10800704 	addi	r2,r2,28
 d01b084:	11400085 	stb	r5,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 d01b088:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b08c:	11003fcc 	andi	r4,r2,255
 d01b090:	2100201c 	xori	r4,r4,128
 d01b094:	213fe004 	addi	r4,r4,-128
 d01b098:	e0bff617 	ldw	r2,-40(fp)
 d01b09c:	11400117 	ldw	r5,4(r2)
 d01b0a0:	00c34174 	movhi	r3,3333
 d01b0a4:	18c23004 	addi	r3,r3,2240
 d01b0a8:	20801224 	muli	r2,r4,72
 d01b0ac:	10c5883a 	add	r2,r2,r3
 d01b0b0:	10800804 	addi	r2,r2,32
 d01b0b4:	11400015 	stw	r5,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 d01b0b8:	e0bff517 	ldw	r2,-44(fp)
 d01b0bc:	1004c03a 	cmpne	r2,r2,zero
 d01b0c0:	1000471e 	bne	r2,zero,d01b1e0 <alt_tse_system_add_sys+0x760>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 d01b0c4:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b0c8:	10803fcc 	andi	r2,r2,255
 d01b0cc:	1080201c 	xori	r2,r2,128
 d01b0d0:	10bfe004 	addi	r2,r2,-128
 d01b0d4:	00c34174 	movhi	r3,3333
 d01b0d8:	18c23004 	addi	r3,r3,2240
 d01b0dc:	10801224 	muli	r2,r2,72
 d01b0e0:	10c5883a 	add	r2,r2,r3
 d01b0e4:	10800904 	addi	r2,r2,36
 d01b0e8:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 d01b0ec:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b0f0:	10803fcc 	andi	r2,r2,255
 d01b0f4:	1080201c 	xori	r2,r2,128
 d01b0f8:	10bfe004 	addi	r2,r2,-128
 d01b0fc:	00c34174 	movhi	r3,3333
 d01b100:	18c23004 	addi	r3,r3,2240
 d01b104:	10801224 	muli	r2,r2,72
 d01b108:	10c5883a 	add	r2,r2,r3
 d01b10c:	10800a04 	addi	r2,r2,40
 d01b110:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 d01b114:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b118:	10803fcc 	andi	r2,r2,255
 d01b11c:	1080201c 	xori	r2,r2,128
 d01b120:	10bfe004 	addi	r2,r2,-128
 d01b124:	00c34174 	movhi	r3,3333
 d01b128:	18c23004 	addi	r3,r3,2240
 d01b12c:	10801224 	muli	r2,r2,72
 d01b130:	10c5883a 	add	r2,r2,r3
 d01b134:	10800b04 	addi	r2,r2,44
 d01b138:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 d01b13c:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b140:	10803fcc 	andi	r2,r2,255
 d01b144:	1080201c 	xori	r2,r2,128
 d01b148:	10bfe004 	addi	r2,r2,-128
 d01b14c:	00c34174 	movhi	r3,3333
 d01b150:	18c23004 	addi	r3,r3,2240
 d01b154:	10801224 	muli	r2,r2,72
 d01b158:	10c5883a 	add	r2,r2,r3
 d01b15c:	10800c04 	addi	r2,r2,48
 d01b160:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 d01b164:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b168:	10803fcc 	andi	r2,r2,255
 d01b16c:	1080201c 	xori	r2,r2,128
 d01b170:	10bfe004 	addi	r2,r2,-128
 d01b174:	00c34174 	movhi	r3,3333
 d01b178:	18c23004 	addi	r3,r3,2240
 d01b17c:	10801224 	muli	r2,r2,72
 d01b180:	10c5883a 	add	r2,r2,r3
 d01b184:	10800d04 	addi	r2,r2,52
 d01b188:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 d01b18c:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b190:	10803fcc 	andi	r2,r2,255
 d01b194:	1080201c 	xori	r2,r2,128
 d01b198:	10bfe004 	addi	r2,r2,-128
 d01b19c:	00c34174 	movhi	r3,3333
 d01b1a0:	18c23004 	addi	r3,r3,2240
 d01b1a4:	10801224 	muli	r2,r2,72
 d01b1a8:	10c5883a 	add	r2,r2,r3
 d01b1ac:	10800e04 	addi	r2,r2,56
 d01b1b0:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 d01b1b4:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b1b8:	10803fcc 	andi	r2,r2,255
 d01b1bc:	1080201c 	xori	r2,r2,128
 d01b1c0:	10bfe004 	addi	r2,r2,-128
 d01b1c4:	00c34174 	movhi	r3,3333
 d01b1c8:	18c23004 	addi	r3,r3,2240
 d01b1cc:	10801224 	muli	r2,r2,72
 d01b1d0:	10c5883a 	add	r2,r2,r3
 d01b1d4:	10800f04 	addi	r2,r2,60
 d01b1d8:	10000015 	stw	zero,0(r2)
 d01b1dc:	00005406 	br	d01b330 <alt_tse_system_add_sys+0x8b0>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 d01b1e0:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b1e4:	11003fcc 	andi	r4,r2,255
 d01b1e8:	2100201c 	xori	r4,r4,128
 d01b1ec:	213fe004 	addi	r4,r4,-128
 d01b1f0:	e0bff517 	ldw	r2,-44(fp)
 d01b1f4:	11400003 	ldbu	r5,0(r2)
 d01b1f8:	00c34174 	movhi	r3,3333
 d01b1fc:	18c23004 	addi	r3,r3,2240
 d01b200:	20801224 	muli	r2,r4,72
 d01b204:	10c5883a 	add	r2,r2,r3
 d01b208:	10800904 	addi	r2,r2,36
 d01b20c:	11400005 	stb	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 d01b210:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b214:	11003fcc 	andi	r4,r2,255
 d01b218:	2100201c 	xori	r4,r4,128
 d01b21c:	213fe004 	addi	r4,r4,-128
 d01b220:	e0bff517 	ldw	r2,-44(fp)
 d01b224:	11400117 	ldw	r5,4(r2)
 d01b228:	00c34174 	movhi	r3,3333
 d01b22c:	18c23004 	addi	r3,r3,2240
 d01b230:	20801224 	muli	r2,r4,72
 d01b234:	10c5883a 	add	r2,r2,r3
 d01b238:	10800a04 	addi	r2,r2,40
 d01b23c:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 d01b240:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b244:	11003fcc 	andi	r4,r2,255
 d01b248:	2100201c 	xori	r4,r4,128
 d01b24c:	213fe004 	addi	r4,r4,-128
 d01b250:	e0bff517 	ldw	r2,-44(fp)
 d01b254:	11400217 	ldw	r5,8(r2)
 d01b258:	00c34174 	movhi	r3,3333
 d01b25c:	18c23004 	addi	r3,r3,2240
 d01b260:	20801224 	muli	r2,r4,72
 d01b264:	10c5883a 	add	r2,r2,r3
 d01b268:	10800b04 	addi	r2,r2,44
 d01b26c:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 d01b270:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b274:	11003fcc 	andi	r4,r2,255
 d01b278:	2100201c 	xori	r4,r4,128
 d01b27c:	213fe004 	addi	r4,r4,-128
 d01b280:	e0bff517 	ldw	r2,-44(fp)
 d01b284:	11400317 	ldw	r5,12(r2)
 d01b288:	00c34174 	movhi	r3,3333
 d01b28c:	18c23004 	addi	r3,r3,2240
 d01b290:	20801224 	muli	r2,r4,72
 d01b294:	10c5883a 	add	r2,r2,r3
 d01b298:	10800c04 	addi	r2,r2,48
 d01b29c:	11400015 	stw	r5,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 d01b2a0:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b2a4:	11003fcc 	andi	r4,r2,255
 d01b2a8:	2100201c 	xori	r4,r4,128
 d01b2ac:	213fe004 	addi	r4,r4,-128
 d01b2b0:	e0bff517 	ldw	r2,-44(fp)
 d01b2b4:	11400417 	ldw	r5,16(r2)
 d01b2b8:	00c34174 	movhi	r3,3333
 d01b2bc:	18c23004 	addi	r3,r3,2240
 d01b2c0:	20801224 	muli	r2,r4,72
 d01b2c4:	10c5883a 	add	r2,r2,r3
 d01b2c8:	10800d04 	addi	r2,r2,52
 d01b2cc:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 d01b2d0:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b2d4:	11003fcc 	andi	r4,r2,255
 d01b2d8:	2100201c 	xori	r4,r4,128
 d01b2dc:	213fe004 	addi	r4,r4,-128
 d01b2e0:	e0bff517 	ldw	r2,-44(fp)
 d01b2e4:	11400517 	ldw	r5,20(r2)
 d01b2e8:	00c34174 	movhi	r3,3333
 d01b2ec:	18c23004 	addi	r3,r3,2240
 d01b2f0:	20801224 	muli	r2,r4,72
 d01b2f4:	10c5883a 	add	r2,r2,r3
 d01b2f8:	10800e04 	addi	r2,r2,56
 d01b2fc:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 d01b300:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b304:	11003fcc 	andi	r4,r2,255
 d01b308:	2100201c 	xori	r4,r4,128
 d01b30c:	213fe004 	addi	r4,r4,-128
 d01b310:	e0bff517 	ldw	r2,-44(fp)
 d01b314:	11400617 	ldw	r5,24(r2)
 d01b318:	00c34174 	movhi	r3,3333
 d01b31c:	18c23004 	addi	r3,r3,2240
 d01b320:	20801224 	muli	r2,r4,72
 d01b324:	10c5883a 	add	r2,r2,r3
 d01b328:	10800f04 	addi	r2,r2,60
 d01b32c:	11400015 	stw	r5,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 d01b330:	e0bff417 	ldw	r2,-48(fp)
 d01b334:	1004c03a 	cmpne	r2,r2,zero
 d01b338:	1000161e 	bne	r2,zero,d01b394 <alt_tse_system_add_sys+0x914>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 d01b33c:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b340:	10803fcc 	andi	r2,r2,255
 d01b344:	1080201c 	xori	r2,r2,128
 d01b348:	10bfe004 	addi	r2,r2,-128
 d01b34c:	00c34174 	movhi	r3,3333
 d01b350:	18c23004 	addi	r3,r3,2240
 d01b354:	10801224 	muli	r2,r2,72
 d01b358:	10c5883a 	add	r2,r2,r3
 d01b35c:	10c01004 	addi	r3,r2,64
 d01b360:	00bfffc4 	movi	r2,-1
 d01b364:	18800015 	stw	r2,0(r3)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 d01b368:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b36c:	10803fcc 	andi	r2,r2,255
 d01b370:	1080201c 	xori	r2,r2,128
 d01b374:	10bfe004 	addi	r2,r2,-128
 d01b378:	00c34174 	movhi	r3,3333
 d01b37c:	18c23004 	addi	r3,r3,2240
 d01b380:	10801224 	muli	r2,r2,72
 d01b384:	10c5883a 	add	r2,r2,r3
 d01b388:	10801104 	addi	r2,r2,68
 d01b38c:	10000015 	stw	zero,0(r2)
 d01b390:	00001806 	br	d01b3f4 <alt_tse_system_add_sys+0x974>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 d01b394:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b398:	11003fcc 	andi	r4,r2,255
 d01b39c:	2100201c 	xori	r4,r4,128
 d01b3a0:	213fe004 	addi	r4,r4,-128
 d01b3a4:	e0bff417 	ldw	r2,-48(fp)
 d01b3a8:	11400017 	ldw	r5,0(r2)
 d01b3ac:	00c34174 	movhi	r3,3333
 d01b3b0:	18c23004 	addi	r3,r3,2240
 d01b3b4:	20801224 	muli	r2,r4,72
 d01b3b8:	10c5883a 	add	r2,r2,r3
 d01b3bc:	10801004 	addi	r2,r2,64
 d01b3c0:	11400015 	stw	r5,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 d01b3c4:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b3c8:	11003fcc 	andi	r4,r2,255
 d01b3cc:	2100201c 	xori	r4,r4,128
 d01b3d0:	213fe004 	addi	r4,r4,-128
 d01b3d4:	e0bff417 	ldw	r2,-48(fp)
 d01b3d8:	11400117 	ldw	r5,4(r2)
 d01b3dc:	00c34174 	movhi	r3,3333
 d01b3e0:	18c23004 	addi	r3,r3,2240
 d01b3e4:	20801224 	muli	r2,r4,72
 d01b3e8:	10c5883a 	add	r2,r2,r3
 d01b3ec:	10801104 	addi	r2,r2,68
 d01b3f0:	11400015 	stw	r5,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 d01b3f4:	e0bff717 	ldw	r2,-36(fp)
 d01b3f8:	10800304 	addi	r2,r2,12
 d01b3fc:	e0bff715 	stw	r2,-36(fp)
		if(pmem) pmem++;
 d01b400:	e0bff617 	ldw	r2,-40(fp)
 d01b404:	1005003a 	cmpeq	r2,r2,zero
 d01b408:	1000031e 	bne	r2,zero,d01b418 <alt_tse_system_add_sys+0x998>
 d01b40c:	e0bff617 	ldw	r2,-40(fp)
 d01b410:	10800204 	addi	r2,r2,8
 d01b414:	e0bff615 	stw	r2,-40(fp)
		if(pfifo) pfifo++;
 d01b418:	e0bff517 	ldw	r2,-44(fp)
 d01b41c:	1005003a 	cmpeq	r2,r2,zero
 d01b420:	1000031e 	bne	r2,zero,d01b430 <alt_tse_system_add_sys+0x9b0>
 d01b424:	e0bff517 	ldw	r2,-44(fp)
 d01b428:	10800704 	addi	r2,r2,28
 d01b42c:	e0bff515 	stw	r2,-44(fp)
		if(pphy) pphy++;
 d01b430:	e0bff417 	ldw	r2,-48(fp)
 d01b434:	1005003a 	cmpeq	r2,r2,zero
 d01b438:	1000031e 	bne	r2,zero,d01b448 <alt_tse_system_add_sys+0x9c8>
 d01b43c:	e0bff417 	ldw	r2,-48(fp)
 d01b440:	10800204 	addi	r2,r2,8
 d01b444:	e0bff415 	stw	r2,-48(fp)
		
		tse_system_count++;
 d01b448:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b44c:	10800044 	addi	r2,r2,1
 d01b450:	d0a07f85 	stb	r2,-32258(gp)
		max_mac_system = tse_system_count;
 d01b454:	d0a07f83 	ldbu	r2,-32258(gp)
 d01b458:	d0a02d05 	stb	r2,-32588(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 d01b45c:	e0bffa17 	ldw	r2,-24(fp)
 d01b460:	10800044 	addi	r2,r2,1
 d01b464:	e0bffa15 	stw	r2,-24(fp)
 d01b468:	e0fffa17 	ldw	r3,-24(fp)
 d01b46c:	e0bff917 	ldw	r2,-28(fp)
 d01b470:	18bdb016 	blt	r3,r2,d01ab34 <alt_tse_system_add_sys+0xb4>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 d01b474:	e03fff15 	stw	zero,-4(fp)
 d01b478:	e0bfff17 	ldw	r2,-4(fp)
	
}
 d01b47c:	e037883a 	mov	sp,fp
 d01b480:	dfc00217 	ldw	ra,8(sp)
 d01b484:	df000117 	ldw	fp,4(sp)
 d01b488:	dc000017 	ldw	r16,0(sp)
 d01b48c:	dec00304 	addi	sp,sp,12
 d01b490:	f800283a 	ret

0d01b494 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 d01b494:	defff804 	addi	sp,sp,-32
 d01b498:	dfc00715 	stw	ra,28(sp)
 d01b49c:	df000615 	stw	fp,24(sp)
 d01b4a0:	df000604 	addi	fp,sp,24
 d01b4a4:	e13ffd15 	stw	r4,-12(fp)
 d01b4a8:	e17ffe05 	stb	r5,-8(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 d01b4ac:	e03ffc15 	stw	zero,-16(fp)
 d01b4b0:	00004c06 	br	d01b5e4 <alt_tse_sys_enable_mdio_sharing+0x150>
		psys_mac = psys_mac_list[i];
 d01b4b4:	e0bffc17 	ldw	r2,-16(fp)
 d01b4b8:	1085883a 	add	r2,r2,r2
 d01b4bc:	1085883a 	add	r2,r2,r2
 d01b4c0:	1007883a 	mov	r3,r2
 d01b4c4:	e0bffd17 	ldw	r2,-12(fp)
 d01b4c8:	1885883a 	add	r2,r3,r2
 d01b4cc:	10800017 	ldw	r2,0(r2)
 d01b4d0:	e0bffa15 	stw	r2,-24(fp)
		
		if(psys_mac == 0) {
 d01b4d4:	e0bffa17 	ldw	r2,-24(fp)
 d01b4d8:	1004c03a 	cmpne	r2,r2,zero
 d01b4dc:	1000091e 	bne	r2,zero,d01b504 <alt_tse_sys_enable_mdio_sharing+0x70>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 d01b4e0:	01034174 	movhi	r4,3333
 d01b4e4:	21328704 	addi	r4,r4,-13796
 d01b4e8:	d002cc00 	call	d002cc0 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 d01b4ec:	01034174 	movhi	r4,3333
 d01b4f0:	2132ec04 	addi	r4,r4,-13392
 d01b4f4:	d002cc00 	call	d002cc0 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d01b4f8:	00bfffc4 	movi	r2,-1
 d01b4fc:	e0bfff15 	stw	r2,-4(fp)
 d01b500:	00003c06 	br	d01b5f4 <alt_tse_sys_enable_mdio_sharing+0x160>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 d01b504:	e03ffb15 	stw	zero,-20(fp)
 d01b508:	00002f06 	br	d01b5c8 <alt_tse_sys_enable_mdio_sharing+0x134>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 d01b50c:	e0bffa17 	ldw	r2,-24(fp)
 d01b510:	11000017 	ldw	r4,0(r2)
 d01b514:	e0bffb17 	ldw	r2,-20(fp)
 d01b518:	00c34174 	movhi	r3,3333
 d01b51c:	18c23004 	addi	r3,r3,2240
 d01b520:	10801224 	muli	r2,r2,72
 d01b524:	10c5883a 	add	r2,r2,r3
 d01b528:	10800017 	ldw	r2,0(r2)
 d01b52c:	2080231e 	bne	r4,r2,d01b5bc <alt_tse_sys_enable_mdio_sharing+0x128>
				if(tse_mac_device[j].tse_multichannel_mac) {
 d01b530:	e0bffb17 	ldw	r2,-20(fp)
 d01b534:	00c34174 	movhi	r3,3333
 d01b538:	18c23004 	addi	r3,r3,2240
 d01b53c:	10801224 	muli	r2,r2,72
 d01b540:	10c5883a 	add	r2,r2,r3
 d01b544:	10800204 	addi	r2,r2,8
 d01b548:	108000c3 	ldbu	r2,3(r2)
 d01b54c:	10803fcc 	andi	r2,r2,255
 d01b550:	1005003a 	cmpeq	r2,r2,zero
 d01b554:	1000091e 	bne	r2,zero,d01b57c <alt_tse_sys_enable_mdio_sharing+0xe8>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 d01b558:	01034174 	movhi	r4,3333
 d01b55c:	21330004 	addi	r4,r4,-13312
 d01b560:	d002cc00 	call	d002cc0 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 d01b564:	01034174 	movhi	r4,3333
 d01b568:	21331104 	addi	r4,r4,-13244
 d01b56c:	d002cc00 	call	d002cc0 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d01b570:	00bfffc4 	movi	r2,-1
 d01b574:	e0bfff15 	stw	r2,-4(fp)
 d01b578:	00001e06 	br	d01b5f4 <alt_tse_sys_enable_mdio_sharing+0x160>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 d01b57c:	e0bffb17 	ldw	r2,-20(fp)
 d01b580:	00c34174 	movhi	r3,3333
 d01b584:	18c23004 	addi	r3,r3,2240
 d01b588:	10801224 	muli	r2,r2,72
 d01b58c:	10c5883a 	add	r2,r2,r3
 d01b590:	10c00304 	addi	r3,r2,12
 d01b594:	00800044 	movi	r2,1
 d01b598:	18800045 	stb	r2,1(r3)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 d01b59c:	e0bffb17 	ldw	r2,-20(fp)
 d01b5a0:	00c34174 	movhi	r3,3333
 d01b5a4:	18c23004 	addi	r3,r3,2240
 d01b5a8:	10801224 	muli	r2,r2,72
 d01b5ac:	10c5883a 	add	r2,r2,r3
 d01b5b0:	10c00304 	addi	r3,r2,12
 d01b5b4:	e0bffe03 	ldbu	r2,-8(fp)
 d01b5b8:	18800085 	stb	r2,2(r3)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 d01b5bc:	e0bffb17 	ldw	r2,-20(fp)
 d01b5c0:	10800044 	addi	r2,r2,1
 d01b5c4:	e0bffb15 	stw	r2,-20(fp)
 d01b5c8:	d0a02d03 	ldbu	r2,-32588(gp)
 d01b5cc:	10c03fcc 	andi	r3,r2,255
 d01b5d0:	e0bffb17 	ldw	r2,-20(fp)
 d01b5d4:	10ffcd16 	blt	r2,r3,d01b50c <alt_tse_sys_enable_mdio_sharing+0x78>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 d01b5d8:	e0bffc17 	ldw	r2,-16(fp)
 d01b5dc:	10800044 	addi	r2,r2,1
 d01b5e0:	e0bffc15 	stw	r2,-16(fp)
 d01b5e4:	e0fffe03 	ldbu	r3,-8(fp)
 d01b5e8:	e0bffc17 	ldw	r2,-16(fp)
 d01b5ec:	10ffb116 	blt	r2,r3,d01b4b4 <alt_tse_sys_enable_mdio_sharing+0x20>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 d01b5f0:	e03fff15 	stw	zero,-4(fp)
 d01b5f4:	e0bfff17 	ldw	r2,-4(fp)
}
 d01b5f8:	e037883a 	mov	sp,fp
 d01b5fc:	dfc00117 	ldw	ra,4(sp)
 d01b600:	df000017 	ldw	fp,0(sp)
 d01b604:	dec00204 	addi	sp,sp,8
 d01b608:	f800283a 	ret

0d01b60c <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 d01b60c:	defffc04 	addi	sp,sp,-16
 d01b610:	dfc00315 	stw	ra,12(sp)
 d01b614:	df000215 	stw	fp,8(sp)
 d01b618:	df000204 	addi	fp,sp,8
 d01b61c:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 d01b620:	e13fff17 	ldw	r4,-4(fp)
 d01b624:	d01b81c0 	call	d01b81c <alt_tse_get_mac_info>
 d01b628:	10800317 	ldw	r2,12(r2)
 d01b62c:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 d01b630:	e13ffe17 	ldw	r4,-8(fp)
 d01b634:	d01ec880 	call	d01ec88 <alt_tse_phy_get_common_speed>
}
 d01b638:	e037883a 	mov	sp,fp
 d01b63c:	dfc00117 	ldw	ra,4(sp)
 d01b640:	df000017 	ldw	fp,0(sp)
 d01b644:	dec00204 	addi	sp,sp,8
 d01b648:	f800283a 	ret

0d01b64c <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 d01b64c:	defffb04 	addi	sp,sp,-20
 d01b650:	dfc00415 	stw	ra,16(sp)
 d01b654:	df000315 	stw	fp,12(sp)
 d01b658:	df000304 	addi	fp,sp,12
 d01b65c:	e13ffe15 	stw	r4,-8(fp)
 d01b660:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 d01b664:	e13ffe17 	ldw	r4,-8(fp)
 d01b668:	d01b81c0 	call	d01b81c <alt_tse_get_mac_info>
 d01b66c:	10800317 	ldw	r2,12(r2)
 d01b670:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 d01b674:	e13ffd17 	ldw	r4,-12(fp)
 d01b678:	e17fff17 	ldw	r5,-4(fp)
 d01b67c:	d01efa40 	call	d01efa4 <alt_tse_phy_set_common_speed>
}
 d01b680:	e037883a 	mov	sp,fp
 d01b684:	dfc00117 	ldw	ra,4(sp)
 d01b688:	df000017 	ldw	fp,0(sp)
 d01b68c:	dec00204 	addi	sp,sp,8
 d01b690:	f800283a 	ret

0d01b694 <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 d01b694:	defffc04 	addi	sp,sp,-16
 d01b698:	df000315 	stw	fp,12(sp)
 d01b69c:	df000304 	addi	fp,sp,12
 d01b6a0:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 d01b6a4:	e03ffd15 	stw	zero,-12(fp)
 d01b6a8:	00000e06 	br	d01b6e4 <alt_tse_get_system_index+0x50>
        if(psys_info == &tse_mac_device[i]) {
 d01b6ac:	e0bffd17 	ldw	r2,-12(fp)
 d01b6b0:	10801224 	muli	r2,r2,72
 d01b6b4:	1007883a 	mov	r3,r2
 d01b6b8:	00834174 	movhi	r2,3333
 d01b6bc:	10823004 	addi	r2,r2,2240
 d01b6c0:	1887883a 	add	r3,r3,r2
 d01b6c4:	e0bffe17 	ldw	r2,-8(fp)
 d01b6c8:	1880031e 	bne	r3,r2,d01b6d8 <alt_tse_get_system_index+0x44>
            return i;
 d01b6cc:	e0bffd17 	ldw	r2,-12(fp)
 d01b6d0:	e0bfff15 	stw	r2,-4(fp)
 d01b6d4:	00000906 	br	d01b6fc <alt_tse_get_system_index+0x68>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 d01b6d8:	e0bffd17 	ldw	r2,-12(fp)
 d01b6dc:	10800044 	addi	r2,r2,1
 d01b6e0:	e0bffd15 	stw	r2,-12(fp)
 d01b6e4:	d0a02d03 	ldbu	r2,-32588(gp)
 d01b6e8:	10c03fcc 	andi	r3,r2,255
 d01b6ec:	e0bffd17 	ldw	r2,-12(fp)
 d01b6f0:	10ffee16 	blt	r2,r3,d01b6ac <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 d01b6f4:	00bfffc4 	movi	r2,-1
 d01b6f8:	e0bfff15 	stw	r2,-4(fp)
 d01b6fc:	e0bfff17 	ldw	r2,-4(fp)
}
 d01b700:	e037883a 	mov	sp,fp
 d01b704:	df000017 	ldw	fp,0(sp)
 d01b708:	dec00104 	addi	sp,sp,4
 d01b70c:	f800283a 	ret

0d01b710 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 d01b710:	defffc04 	addi	sp,sp,-16
 d01b714:	df000315 	stw	fp,12(sp)
 d01b718:	df000304 	addi	fp,sp,12
 d01b71c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 d01b720:	e03ffd15 	stw	zero,-12(fp)
 d01b724:	00000f06 	br	d01b764 <alt_tse_get_mac_group_index+0x54>
        if(pmac_group == pmac_groups[i]) {
 d01b728:	e0bffd17 	ldw	r2,-12(fp)
 d01b72c:	00c341b4 	movhi	r3,3334
 d01b730:	18f18004 	addi	r3,r3,-14848
 d01b734:	1085883a 	add	r2,r2,r2
 d01b738:	1085883a 	add	r2,r2,r2
 d01b73c:	10c5883a 	add	r2,r2,r3
 d01b740:	10c00017 	ldw	r3,0(r2)
 d01b744:	e0bffe17 	ldw	r2,-8(fp)
 d01b748:	1880031e 	bne	r3,r2,d01b758 <alt_tse_get_mac_group_index+0x48>
            return i;
 d01b74c:	e0bffd17 	ldw	r2,-12(fp)
 d01b750:	e0bfff15 	stw	r2,-4(fp)
 d01b754:	00000906 	br	d01b77c <alt_tse_get_mac_group_index+0x6c>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 d01b758:	e0bffd17 	ldw	r2,-12(fp)
 d01b75c:	10800044 	addi	r2,r2,1
 d01b760:	e0bffd15 	stw	r2,-12(fp)
 d01b764:	d0a07f43 	ldbu	r2,-32259(gp)
 d01b768:	10c03fcc 	andi	r3,r2,255
 d01b76c:	e0bffd17 	ldw	r2,-12(fp)
 d01b770:	10ffed16 	blt	r2,r3,d01b728 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 d01b774:	00bfffc4 	movi	r2,-1
 d01b778:	e0bfff15 	stw	r2,-4(fp)
 d01b77c:	e0bfff17 	ldw	r2,-4(fp)
}
 d01b780:	e037883a 	mov	sp,fp
 d01b784:	df000017 	ldw	fp,0(sp)
 d01b788:	dec00104 	addi	sp,sp,4
 d01b78c:	f800283a 	ret

0d01b790 <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 d01b790:	defffc04 	addi	sp,sp,-16
 d01b794:	df000315 	stw	fp,12(sp)
 d01b798:	df000304 	addi	fp,sp,12
 d01b79c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 d01b7a0:	e03ffd15 	stw	zero,-12(fp)
 d01b7a4:	00001006 	br	d01b7e8 <alt_tse_get_mac_info_index+0x58>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 d01b7a8:	e0bffe17 	ldw	r2,-8(fp)
 d01b7ac:	10c00317 	ldw	r3,12(r2)
 d01b7b0:	e0bffd17 	ldw	r2,-12(fp)
 d01b7b4:	1085883a 	add	r2,r2,r2
 d01b7b8:	1085883a 	add	r2,r2,r2
 d01b7bc:	10c5883a 	add	r2,r2,r3
 d01b7c0:	10800104 	addi	r2,r2,4
 d01b7c4:	10c00017 	ldw	r3,0(r2)
 d01b7c8:	e0bffe17 	ldw	r2,-8(fp)
 d01b7cc:	1880031e 	bne	r3,r2,d01b7dc <alt_tse_get_mac_info_index+0x4c>
            return i;
 d01b7d0:	e0bffd17 	ldw	r2,-12(fp)
 d01b7d4:	e0bfff15 	stw	r2,-4(fp)
 d01b7d8:	00000b06 	br	d01b808 <alt_tse_get_mac_info_index+0x78>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 d01b7dc:	e0bffd17 	ldw	r2,-12(fp)
 d01b7e0:	10800044 	addi	r2,r2,1
 d01b7e4:	e0bffd15 	stw	r2,-12(fp)
 d01b7e8:	e0bffe17 	ldw	r2,-8(fp)
 d01b7ec:	10800317 	ldw	r2,12(r2)
 d01b7f0:	10800003 	ldbu	r2,0(r2)
 d01b7f4:	10c03fcc 	andi	r3,r2,255
 d01b7f8:	e0bffd17 	ldw	r2,-12(fp)
 d01b7fc:	10ffea16 	blt	r2,r3,d01b7a8 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 d01b800:	00bfffc4 	movi	r2,-1
 d01b804:	e0bfff15 	stw	r2,-4(fp)
 d01b808:	e0bfff17 	ldw	r2,-4(fp)
}
 d01b80c:	e037883a 	mov	sp,fp
 d01b810:	df000017 	ldw	fp,0(sp)
 d01b814:	dec00104 	addi	sp,sp,4
 d01b818:	f800283a 	ret

0d01b81c <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 d01b81c:	defff904 	addi	sp,sp,-28
 d01b820:	df000615 	stw	fp,24(sp)
 d01b824:	df000604 	addi	fp,sp,24
 d01b828:	e13ffe15 	stw	r4,-8(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 d01b82c:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 d01b830:	e03ffa15 	stw	zero,-24(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 d01b834:	e03ffd15 	stw	zero,-12(fp)
 d01b838:	00002606 	br	d01b8d4 <alt_tse_get_mac_info+0xb8>
        pmac_group = pmac_groups[i];
 d01b83c:	e0bffd17 	ldw	r2,-12(fp)
 d01b840:	00c341b4 	movhi	r3,3334
 d01b844:	18f18004 	addi	r3,r3,-14848
 d01b848:	1085883a 	add	r2,r2,r2
 d01b84c:	1085883a 	add	r2,r2,r2
 d01b850:	10c5883a 	add	r2,r2,r3
 d01b854:	10800017 	ldw	r2,0(r2)
 d01b858:	e0bffb15 	stw	r2,-20(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 d01b85c:	e03ffc15 	stw	zero,-16(fp)
 d01b860:	00001406 	br	d01b8b4 <alt_tse_get_mac_info+0x98>
            pmac_info = pmac_group->pmac_info[j];
 d01b864:	e0bffc17 	ldw	r2,-16(fp)
 d01b868:	e0fffb17 	ldw	r3,-20(fp)
 d01b86c:	1085883a 	add	r2,r2,r2
 d01b870:	1085883a 	add	r2,r2,r2
 d01b874:	10c5883a 	add	r2,r2,r3
 d01b878:	10800104 	addi	r2,r2,4
 d01b87c:	10800017 	ldw	r2,0(r2)
 d01b880:	e0bffa15 	stw	r2,-24(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 d01b884:	e0bffa17 	ldw	r2,-24(fp)
 d01b888:	10800217 	ldw	r2,8(r2)
 d01b88c:	10800017 	ldw	r2,0(r2)
 d01b890:	1007883a 	mov	r3,r2
 d01b894:	e0bffe17 	ldw	r2,-8(fp)
 d01b898:	1880031e 	bne	r3,r2,d01b8a8 <alt_tse_get_mac_info+0x8c>
                return pmac_info;
 d01b89c:	e0bffa17 	ldw	r2,-24(fp)
 d01b8a0:	e0bfff15 	stw	r2,-4(fp)
 d01b8a4:	00001006 	br	d01b8e8 <alt_tse_get_mac_info+0xcc>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 d01b8a8:	e0bffc17 	ldw	r2,-16(fp)
 d01b8ac:	10800044 	addi	r2,r2,1
 d01b8b0:	e0bffc15 	stw	r2,-16(fp)
 d01b8b4:	e0bffb17 	ldw	r2,-20(fp)
 d01b8b8:	10800003 	ldbu	r2,0(r2)
 d01b8bc:	10c03fcc 	andi	r3,r2,255
 d01b8c0:	e0bffc17 	ldw	r2,-16(fp)
 d01b8c4:	10ffe716 	blt	r2,r3,d01b864 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 d01b8c8:	e0bffd17 	ldw	r2,-12(fp)
 d01b8cc:	10800044 	addi	r2,r2,1
 d01b8d0:	e0bffd15 	stw	r2,-12(fp)
 d01b8d4:	d0a07f43 	ldbu	r2,-32259(gp)
 d01b8d8:	10c03fcc 	andi	r3,r2,255
 d01b8dc:	e0bffd17 	ldw	r2,-12(fp)
 d01b8e0:	10ffd616 	blt	r2,r3,d01b83c <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 d01b8e4:	e03fff15 	stw	zero,-4(fp)
 d01b8e8:	e0bfff17 	ldw	r2,-4(fp)
}
 d01b8ec:	e037883a 	mov	sp,fp
 d01b8f0:	df000017 	ldw	fp,0(sp)
 d01b8f4:	dec00104 	addi	sp,sp,4
 d01b8f8:	f800283a 	ret

0d01b8fc <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 d01b8fc:	defffb04 	addi	sp,sp,-20
 d01b900:	df000415 	stw	fp,16(sp)
 d01b904:	df000404 	addi	fp,sp,16
 d01b908:	e13ffd15 	stw	r4,-12(fp)
 d01b90c:	e17ffe05 	stb	r5,-8(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d01b910:	e0bffd17 	ldw	r2,-12(fp)
 d01b914:	10800204 	addi	r2,r2,8
 d01b918:	10800037 	ldwio	r2,0(r2)
 d01b91c:	e0bffc15 	stw	r2,-16(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 d01b920:	e0bffe03 	ldbu	r2,-8(fp)
 d01b924:	10800098 	cmpnei	r2,r2,2
 d01b928:	1000091e 	bne	r2,zero,d01b950 <alt_tse_mac_set_speed+0x54>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d01b92c:	e0bffc17 	ldw	r2,-16(fp)
 d01b930:	10800214 	ori	r2,r2,8
 d01b934:	e0bffc15 	stw	r2,-16(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d01b938:	e0fffc17 	ldw	r3,-16(fp)
 d01b93c:	00bf8034 	movhi	r2,65024
 d01b940:	10bfffc4 	addi	r2,r2,-1
 d01b944:	1884703a 	and	r2,r3,r2
 d01b948:	e0bffc15 	stw	r2,-16(fp)
 d01b94c:	00001b06 	br	d01b9bc <alt_tse_mac_set_speed+0xc0>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 d01b950:	e0bffe03 	ldbu	r2,-8(fp)
 d01b954:	10800058 	cmpnei	r2,r2,1
 d01b958:	10000a1e 	bne	r2,zero,d01b984 <alt_tse_mac_set_speed+0x88>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d01b95c:	e0fffc17 	ldw	r3,-16(fp)
 d01b960:	00bffdc4 	movi	r2,-9
 d01b964:	1884703a 	and	r2,r3,r2
 d01b968:	e0bffc15 	stw	r2,-16(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d01b96c:	e0fffc17 	ldw	r3,-16(fp)
 d01b970:	00bf8034 	movhi	r2,65024
 d01b974:	10bfffc4 	addi	r2,r2,-1
 d01b978:	1884703a 	and	r2,r3,r2
 d01b97c:	e0bffc15 	stw	r2,-16(fp)
 d01b980:	00000e06 	br	d01b9bc <alt_tse_mac_set_speed+0xc0>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 d01b984:	e0bffe03 	ldbu	r2,-8(fp)
 d01b988:	1004c03a 	cmpne	r2,r2,zero
 d01b98c:	1000081e 	bne	r2,zero,d01b9b0 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d01b990:	e0fffc17 	ldw	r3,-16(fp)
 d01b994:	00bffdc4 	movi	r2,-9
 d01b998:	1884703a 	and	r2,r3,r2
 d01b99c:	e0bffc15 	stw	r2,-16(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d01b9a0:	e0bffc17 	ldw	r2,-16(fp)
 d01b9a4:	10808034 	orhi	r2,r2,512
 d01b9a8:	e0bffc15 	stw	r2,-16(fp)
 d01b9ac:	00000306 	br	d01b9bc <alt_tse_mac_set_speed+0xc0>
  }  
  else {
    return ENP_PARAM;
 d01b9b0:	00bffd84 	movi	r2,-10
 d01b9b4:	e0bfff15 	stw	r2,-4(fp)
 d01b9b8:	00000606 	br	d01b9d4 <alt_tse_mac_set_speed+0xd8>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 d01b9bc:	e0bffd17 	ldw	r2,-12(fp)
 d01b9c0:	10800204 	addi	r2,r2,8
 d01b9c4:	1007883a 	mov	r3,r2
 d01b9c8:	e0bffc17 	ldw	r2,-16(fp)
 d01b9cc:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 d01b9d0:	e03fff15 	stw	zero,-4(fp)
 d01b9d4:	e0bfff17 	ldw	r2,-4(fp)
}
 d01b9d8:	e037883a 	mov	sp,fp
 d01b9dc:	df000017 	ldw	fp,0(sp)
 d01b9e0:	dec00104 	addi	sp,sp,4
 d01b9e4:	f800283a 	ret

0d01b9e8 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 d01b9e8:	defffb04 	addi	sp,sp,-20
 d01b9ec:	df000415 	stw	fp,16(sp)
 d01b9f0:	df000404 	addi	fp,sp,16
 d01b9f4:	e13ffd15 	stw	r4,-12(fp)
 d01b9f8:	e17ffe05 	stb	r5,-8(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 d01b9fc:	e0bffd17 	ldw	r2,-12(fp)
 d01ba00:	10800204 	addi	r2,r2,8
 d01ba04:	10800037 	ldwio	r2,0(r2)
 d01ba08:	e0bffc15 	stw	r2,-16(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 d01ba0c:	e0bffe03 	ldbu	r2,-8(fp)
 d01ba10:	1004c03a 	cmpne	r2,r2,zero
 d01ba14:	1000041e 	bne	r2,zero,d01ba28 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 d01ba18:	e0bffc17 	ldw	r2,-16(fp)
 d01ba1c:	10810014 	ori	r2,r2,1024
 d01ba20:	e0bffc15 	stw	r2,-16(fp)
 d01ba24:	00000b06 	br	d01ba54 <alt_tse_mac_set_duplex+0x6c>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 d01ba28:	e0bffe03 	ldbu	r2,-8(fp)
 d01ba2c:	10800058 	cmpnei	r2,r2,1
 d01ba30:	1000051e 	bne	r2,zero,d01ba48 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 d01ba34:	e0bffc17 	ldw	r2,-16(fp)
 d01ba38:	00feffc4 	movi	r3,-1025
 d01ba3c:	10c4703a 	and	r2,r2,r3
 d01ba40:	e0bffc15 	stw	r2,-16(fp)
 d01ba44:	00000306 	br	d01ba54 <alt_tse_mac_set_duplex+0x6c>
  }
  else {
    return ENP_PARAM;
 d01ba48:	00bffd84 	movi	r2,-10
 d01ba4c:	e0bfff15 	stw	r2,-4(fp)
 d01ba50:	00000606 	br	d01ba6c <alt_tse_mac_set_duplex+0x84>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 d01ba54:	e0bffd17 	ldw	r2,-12(fp)
 d01ba58:	10800204 	addi	r2,r2,8
 d01ba5c:	1007883a 	mov	r3,r2
 d01ba60:	e0bffc17 	ldw	r2,-16(fp)
 d01ba64:	18800035 	stwio	r2,0(r3)
  return SUCCESS;
 d01ba68:	e03fff15 	stw	zero,-4(fp)
 d01ba6c:	e0bfff17 	ldw	r2,-4(fp)

}
 d01ba70:	e037883a 	mov	sp,fp
 d01ba74:	df000017 	ldw	fp,0(sp)
 d01ba78:	dec00104 	addi	sp,sp,4
 d01ba7c:	f800283a 	ret

0d01ba80 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 d01ba80:	deff9804 	addi	sp,sp,-416
 d01ba84:	dfc06715 	stw	ra,412(sp)
 d01ba88:	df006615 	stw	fp,408(sp)
 d01ba8c:	df006604 	addi	fp,sp,408
 d01ba90:	e13fa215 	stw	r4,-376(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d01ba94:	00800044 	movi	r2,1
 d01ba98:	e0bfa185 	stb	r2,-378(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 d01ba9c:	00800044 	movi	r2,1
 d01baa0:	e0bfa145 	stb	r2,-379(fp)
	alt_u8 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 d01baa4:	e0bfa143 	ldbu	r2,-379(fp)
 d01baa8:	1080004c 	andi	r2,r2,1
 d01baac:	e0bfff05 	stb	r2,-4(fp)
 d01bab0:	e0bfa183 	ldbu	r2,-378(fp)
 d01bab4:	10800098 	cmpnei	r2,r2,2
 d01bab8:	1000031e 	bne	r2,zero,d01bac8 <getPHYSpeed+0x48>
 d01babc:	00800084 	movi	r2,2
 d01bac0:	e0bffe05 	stb	r2,-8(fp)
 d01bac4:	00000106 	br	d01bacc <getPHYSpeed+0x4c>
 d01bac8:	e03ffe05 	stb	zero,-8(fp)
 d01bacc:	e0ffff03 	ldbu	r3,-4(fp)
 d01bad0:	e13ffe03 	ldbu	r4,-8(fp)
 d01bad4:	1904b03a 	or	r2,r3,r4
 d01bad8:	e0bffd05 	stb	r2,-12(fp)
 d01badc:	e0bfa183 	ldbu	r2,-378(fp)
 d01bae0:	10800058 	cmpnei	r2,r2,1
 d01bae4:	1000031e 	bne	r2,zero,d01baf4 <getPHYSpeed+0x74>
 d01bae8:	00800104 	movi	r2,4
 d01baec:	e0bffc05 	stb	r2,-16(fp)
 d01baf0:	00000106 	br	d01baf8 <getPHYSpeed+0x78>
 d01baf4:	e03ffc05 	stb	zero,-16(fp)
 d01baf8:	e0fffd03 	ldbu	r3,-12(fp)
 d01bafc:	e13ffc03 	ldbu	r4,-16(fp)
 d01bb00:	1904b03a 	or	r2,r3,r4
 d01bb04:	e0bffb05 	stb	r2,-20(fp)
 d01bb08:	e0bfa183 	ldbu	r2,-378(fp)
 d01bb0c:	1004c03a 	cmpne	r2,r2,zero
 d01bb10:	1000031e 	bne	r2,zero,d01bb20 <getPHYSpeed+0xa0>
 d01bb14:	00800204 	movi	r2,8
 d01bb18:	e0bffa05 	stb	r2,-24(fp)
 d01bb1c:	00000106 	br	d01bb24 <getPHYSpeed+0xa4>
 d01bb20:	e03ffa05 	stb	zero,-24(fp)
 d01bb24:	e0fffb03 	ldbu	r3,-20(fp)
 d01bb28:	e13ffa03 	ldbu	r4,-24(fp)
 d01bb2c:	1904b03a 	or	r2,r3,r4
 d01bb30:	e0bff905 	stb	r2,-28(fp)
 d01bb34:	e0bfa183 	ldbu	r2,-378(fp)
 d01bb38:	108000d8 	cmpnei	r2,r2,3
 d01bb3c:	1000031e 	bne	r2,zero,d01bb4c <getPHYSpeed+0xcc>
 d01bb40:	0005883a 	mov	r2,zero
 d01bb44:	e0bff805 	stb	r2,-32(fp)
 d01bb48:	00000106 	br	d01bb50 <getPHYSpeed+0xd0>
 d01bb4c:	e03ff805 	stb	zero,-32(fp)
 d01bb50:	e0fff903 	ldbu	r3,-28(fp)
 d01bb54:	e13ff803 	ldbu	r4,-32(fp)
 d01bb58:	1904b03a 	or	r2,r3,r4
 d01bb5c:	e0bfa105 	stb	r2,-380(fp)
    
    alt_tse_phy_info *pphy = 0;
 d01bb60:	e03fa015 	stw	zero,-384(fp)
    alt_tse_mac_info *pmac_info = 0;
 d01bb64:	e03f9f15 	stw	zero,-388(fp)
    alt_tse_mac_group *pmac_group = 0;
 d01bb68:	e03f9e15 	stw	zero,-392(fp)
    alt_tse_system_info *psys = 0;
 d01bb6c:	e03f9d15 	stw	zero,-396(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 d01bb70:	e03f9c45 	stb	zero,-399(fp)
    alt_8 mac_group_index = 0;
 d01bb74:	e03f9c05 	stb	zero,-400(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 d01bb78:	d0a07fc3 	ldbu	r2,-32257(gp)
 d01bb7c:	10803fcc 	andi	r2,r2,255
 d01bb80:	1004c03a 	cmpne	r2,r2,zero
 d01bb84:	1000031e 	bne	r2,zero,d01bb94 <getPHYSpeed+0x114>
        alt_tse_phy_init();
 d01bb88:	d01de040 	call	d01de04 <alt_tse_phy_init>
        is_init = 1;
 d01bb8c:	00800044 	movi	r2,1
 d01bb90:	d0a07fc5 	stb	r2,-32257(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 d01bb94:	e13fa217 	ldw	r4,-376(fp)
 d01bb98:	d01b81c0 	call	d01b81c <alt_tse_get_mac_info>
 d01bb9c:	e0bf9f15 	stw	r2,-388(fp)
    
    if(pmac_info == 0) {
 d01bba0:	e0bf9f17 	ldw	r2,-388(fp)
 d01bba4:	1004c03a 	cmpne	r2,r2,zero
 d01bba8:	1000671e 	bne	r2,zero,d01bd48 <getPHYSpeed+0x2c8>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d01bbac:	00800044 	movi	r2,1
 d01bbb0:	e0bfa185 	stb	r2,-378(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d01bbb4:	00800044 	movi	r2,1
 d01bbb8:	e0bfa145 	stb	r2,-379(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 d01bbbc:	e0bfa143 	ldbu	r2,-379(fp)
 d01bbc0:	1080004c 	andi	r2,r2,1
 d01bbc4:	e0bff705 	stb	r2,-36(fp)
 d01bbc8:	e0bfa183 	ldbu	r2,-378(fp)
 d01bbcc:	10800098 	cmpnei	r2,r2,2
 d01bbd0:	1000031e 	bne	r2,zero,d01bbe0 <getPHYSpeed+0x160>
 d01bbd4:	00800084 	movi	r2,2
 d01bbd8:	e0bff605 	stb	r2,-40(fp)
 d01bbdc:	00000106 	br	d01bbe4 <getPHYSpeed+0x164>
 d01bbe0:	e03ff605 	stb	zero,-40(fp)
 d01bbe4:	e0fff703 	ldbu	r3,-36(fp)
 d01bbe8:	e13ff603 	ldbu	r4,-40(fp)
 d01bbec:	1904b03a 	or	r2,r3,r4
 d01bbf0:	e0bff505 	stb	r2,-44(fp)
 d01bbf4:	e0bfa183 	ldbu	r2,-378(fp)
 d01bbf8:	10800058 	cmpnei	r2,r2,1
 d01bbfc:	1000031e 	bne	r2,zero,d01bc0c <getPHYSpeed+0x18c>
 d01bc00:	00800104 	movi	r2,4
 d01bc04:	e0bff405 	stb	r2,-48(fp)
 d01bc08:	00000106 	br	d01bc10 <getPHYSpeed+0x190>
 d01bc0c:	e03ff405 	stb	zero,-48(fp)
 d01bc10:	e0fff503 	ldbu	r3,-44(fp)
 d01bc14:	e13ff403 	ldbu	r4,-48(fp)
 d01bc18:	1904b03a 	or	r2,r3,r4
 d01bc1c:	e0bff305 	stb	r2,-52(fp)
 d01bc20:	e0bfa183 	ldbu	r2,-378(fp)
 d01bc24:	1004c03a 	cmpne	r2,r2,zero
 d01bc28:	1000031e 	bne	r2,zero,d01bc38 <getPHYSpeed+0x1b8>
 d01bc2c:	00800204 	movi	r2,8
 d01bc30:	e0bff205 	stb	r2,-56(fp)
 d01bc34:	00000106 	br	d01bc3c <getPHYSpeed+0x1bc>
 d01bc38:	e03ff205 	stb	zero,-56(fp)
 d01bc3c:	e0fff303 	ldbu	r3,-52(fp)
 d01bc40:	e13ff203 	ldbu	r4,-56(fp)
 d01bc44:	1904b03a 	or	r2,r3,r4
 d01bc48:	e0bff105 	stb	r2,-60(fp)
 d01bc4c:	e0bfa183 	ldbu	r2,-378(fp)
 d01bc50:	108000d8 	cmpnei	r2,r2,3
 d01bc54:	1000031e 	bne	r2,zero,d01bc64 <getPHYSpeed+0x1e4>
 d01bc58:	0005883a 	mov	r2,zero
 d01bc5c:	e0bff005 	stb	r2,-64(fp)
 d01bc60:	00000106 	br	d01bc68 <getPHYSpeed+0x1e8>
 d01bc64:	e03ff005 	stb	zero,-64(fp)
 d01bc68:	e0fff103 	ldbu	r3,-60(fp)
 d01bc6c:	e13ff003 	ldbu	r4,-64(fp)
 d01bc70:	1904b03a 	or	r2,r3,r4
 d01bc74:	1007883a 	mov	r3,r2
 d01bc78:	0005883a 	mov	r2,zero
 d01bc7c:	1884b03a 	or	r2,r3,r2
 d01bc80:	e0bfa105 	stb	r2,-380(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 d01bc84:	e0bfa183 	ldbu	r2,-378(fp)
 d01bc88:	108000a0 	cmpeqi	r2,r2,2
 d01bc8c:	1000161e 	bne	r2,zero,d01bce8 <getPHYSpeed+0x268>
 d01bc90:	e0bfa183 	ldbu	r2,-378(fp)
 d01bc94:	10800060 	cmpeqi	r2,r2,1
 d01bc98:	10000d1e 	bne	r2,zero,d01bcd0 <getPHYSpeed+0x250>
 d01bc9c:	e0bfa183 	ldbu	r2,-378(fp)
 d01bca0:	1004c03a 	cmpne	r2,r2,zero
 d01bca4:	1000041e 	bne	r2,zero,d01bcb8 <getPHYSpeed+0x238>
 d01bca8:	00834174 	movhi	r2,3333
 d01bcac:	10b32004 	addi	r2,r2,-13184
 d01bcb0:	e0bfed15 	stw	r2,-76(fp)
 d01bcb4:	00000306 	br	d01bcc4 <getPHYSpeed+0x244>
 d01bcb8:	00c34174 	movhi	r3,3333
 d01bcbc:	18f32104 	addi	r3,r3,-13180
 d01bcc0:	e0ffed15 	stw	r3,-76(fp)
 d01bcc4:	e13fed17 	ldw	r4,-76(fp)
 d01bcc8:	e13fee15 	stw	r4,-72(fp)
 d01bccc:	00000306 	br	d01bcdc <getPHYSpeed+0x25c>
 d01bcd0:	00834174 	movhi	r2,3333
 d01bcd4:	10b32304 	addi	r2,r2,-13172
 d01bcd8:	e0bfee15 	stw	r2,-72(fp)
 d01bcdc:	e0ffee17 	ldw	r3,-72(fp)
 d01bce0:	e0ffef15 	stw	r3,-68(fp)
 d01bce4:	00000306 	br	d01bcf4 <getPHYSpeed+0x274>
 d01bce8:	01034174 	movhi	r4,3333
 d01bcec:	21332404 	addi	r4,r4,-13168
 d01bcf0:	e13fef15 	stw	r4,-68(fp)
 d01bcf4:	e0bfa143 	ldbu	r2,-379(fp)
 d01bcf8:	10800058 	cmpnei	r2,r2,1
 d01bcfc:	1000041e 	bne	r2,zero,d01bd10 <getPHYSpeed+0x290>
 d01bd00:	00834174 	movhi	r2,3333
 d01bd04:	10b32604 	addi	r2,r2,-13160
 d01bd08:	e0bfec15 	stw	r2,-80(fp)
 d01bd0c:	00000306 	br	d01bd1c <getPHYSpeed+0x29c>
 d01bd10:	00c34174 	movhi	r3,3333
 d01bd14:	18f32804 	addi	r3,r3,-13152
 d01bd18:	e0ffec15 	stw	r3,-80(fp)
 d01bd1c:	01034174 	movhi	r4,3333
 d01bd20:	21332a04 	addi	r4,r4,-13144
 d01bd24:	e17fef17 	ldw	r5,-68(fp)
 d01bd28:	e1bfec17 	ldw	r6,-80(fp)
 d01bd2c:	d0029980 	call	d002998 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 d01bd30:	01034174 	movhi	r4,3333
 d01bd34:	21334204 	addi	r4,r4,-13048
 d01bd38:	d002cc00 	call	d002cc0 <puts>
        return result;
 d01bd3c:	e13fa103 	ldbu	r4,-380(fp)
 d01bd40:	e13feb15 	stw	r4,-84(fp)
 d01bd44:	0002ce06 	br	d01c880 <getPHYSpeed+0xe00>
    }
    
    pphy = pmac_info->pphy_info;
 d01bd48:	e0bf9f17 	ldw	r2,-388(fp)
 d01bd4c:	10800117 	ldw	r2,4(r2)
 d01bd50:	e0bfa015 	stw	r2,-384(fp)
    pmac_group = pmac_info->pmac_group;
 d01bd54:	e0bf9f17 	ldw	r2,-388(fp)
 d01bd58:	10800317 	ldw	r2,12(r2)
 d01bd5c:	e0bf9e15 	stw	r2,-392(fp)
    psys = pmac_info->psys_info;
 d01bd60:	e0bf9f17 	ldw	r2,-388(fp)
 d01bd64:	10800217 	ldw	r2,8(r2)
 d01bd68:	e0bf9d15 	stw	r2,-396(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01bd6c:	e13f9f17 	ldw	r4,-388(fp)
 d01bd70:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01bd74:	e0bf9c45 	stb	r2,-399(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01bd78:	e13f9e17 	ldw	r4,-392(fp)
 d01bd7c:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01bd80:	e0bf9c05 	stb	r2,-400(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 d01bd84:	e0bf9e17 	ldw	r2,-392(fp)
 d01bd88:	10800117 	ldw	r2,4(r2)
 d01bd8c:	10800217 	ldw	r2,8(r2)
 d01bd90:	10800203 	ldbu	r2,8(r2)
 d01bd94:	10803fcc 	andi	r2,r2,255
 d01bd98:	1004c03a 	cmpne	r2,r2,zero
 d01bd9c:	1000791e 	bne	r2,zero,d01bf84 <getPHYSpeed+0x504>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d01bda0:	00800044 	movi	r2,1
 d01bda4:	e0bfa185 	stb	r2,-378(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d01bda8:	00800044 	movi	r2,1
 d01bdac:	e0bfa145 	stb	r2,-379(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 d01bdb0:	e0bfa143 	ldbu	r2,-379(fp)
 d01bdb4:	1080004c 	andi	r2,r2,1
 d01bdb8:	e0bfea05 	stb	r2,-88(fp)
 d01bdbc:	e0bfa183 	ldbu	r2,-378(fp)
 d01bdc0:	10800098 	cmpnei	r2,r2,2
 d01bdc4:	1000031e 	bne	r2,zero,d01bdd4 <getPHYSpeed+0x354>
 d01bdc8:	00800084 	movi	r2,2
 d01bdcc:	e0bfe905 	stb	r2,-92(fp)
 d01bdd0:	00000106 	br	d01bdd8 <getPHYSpeed+0x358>
 d01bdd4:	e03fe905 	stb	zero,-92(fp)
 d01bdd8:	e0ffea03 	ldbu	r3,-88(fp)
 d01bddc:	e13fe903 	ldbu	r4,-92(fp)
 d01bde0:	1904b03a 	or	r2,r3,r4
 d01bde4:	e0bfe805 	stb	r2,-96(fp)
 d01bde8:	e0bfa183 	ldbu	r2,-378(fp)
 d01bdec:	10800058 	cmpnei	r2,r2,1
 d01bdf0:	1000031e 	bne	r2,zero,d01be00 <getPHYSpeed+0x380>
 d01bdf4:	00800104 	movi	r2,4
 d01bdf8:	e0bfe705 	stb	r2,-100(fp)
 d01bdfc:	00000106 	br	d01be04 <getPHYSpeed+0x384>
 d01be00:	e03fe705 	stb	zero,-100(fp)
 d01be04:	e0ffe803 	ldbu	r3,-96(fp)
 d01be08:	e13fe703 	ldbu	r4,-100(fp)
 d01be0c:	1904b03a 	or	r2,r3,r4
 d01be10:	e0bfe605 	stb	r2,-104(fp)
 d01be14:	e0bfa183 	ldbu	r2,-378(fp)
 d01be18:	1004c03a 	cmpne	r2,r2,zero
 d01be1c:	1000031e 	bne	r2,zero,d01be2c <getPHYSpeed+0x3ac>
 d01be20:	00800204 	movi	r2,8
 d01be24:	e0bfe505 	stb	r2,-108(fp)
 d01be28:	00000106 	br	d01be30 <getPHYSpeed+0x3b0>
 d01be2c:	e03fe505 	stb	zero,-108(fp)
 d01be30:	e0ffe603 	ldbu	r3,-104(fp)
 d01be34:	e13fe503 	ldbu	r4,-108(fp)
 d01be38:	1904b03a 	or	r2,r3,r4
 d01be3c:	e0bfe405 	stb	r2,-112(fp)
 d01be40:	e0bfa183 	ldbu	r2,-378(fp)
 d01be44:	108000d8 	cmpnei	r2,r2,3
 d01be48:	1000031e 	bne	r2,zero,d01be58 <getPHYSpeed+0x3d8>
 d01be4c:	0005883a 	mov	r2,zero
 d01be50:	e0bfe305 	stb	r2,-116(fp)
 d01be54:	00000106 	br	d01be5c <getPHYSpeed+0x3dc>
 d01be58:	e03fe305 	stb	zero,-116(fp)
 d01be5c:	e0ffe403 	ldbu	r3,-112(fp)
 d01be60:	e13fe303 	ldbu	r4,-116(fp)
 d01be64:	1904b03a 	or	r2,r3,r4
 d01be68:	1007883a 	mov	r3,r2
 d01be6c:	0005883a 	mov	r2,zero
 d01be70:	1884b03a 	or	r2,r3,r2
 d01be74:	e0bfa105 	stb	r2,-380(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 d01be78:	010003f4 	movhi	r4,15
 d01be7c:	21109004 	addi	r4,r4,16960
 d01be80:	d0398d00 	call	d0398d0 <usleep>
        if(psys->tse_phy_cfg) {
 d01be84:	e0bf9d17 	ldw	r2,-396(fp)
 d01be88:	10801117 	ldw	r2,68(r2)
 d01be8c:	1005003a 	cmpeq	r2,r2,zero
 d01be90:	10000b1e 	bne	r2,zero,d01bec0 <getPHYSpeed+0x440>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 d01be94:	e17f9c07 	ldb	r5,-400(fp)
 d01be98:	e1bf9c47 	ldb	r6,-399(fp)
 d01be9c:	01034174 	movhi	r4,3333
 d01bea0:	21335304 	addi	r4,r4,-12980
 d01bea4:	d0029980 	call	d002998 <printf>
        	result = psys->tse_phy_cfg(pmac);
 d01bea8:	e0bf9d17 	ldw	r2,-396(fp)
 d01beac:	10801117 	ldw	r2,68(r2)
 d01beb0:	e13fa217 	ldw	r4,-376(fp)
 d01beb4:	103ee83a 	callr	r2
 d01beb8:	e0bfa105 	stb	r2,-380(fp)
 d01bebc:	00002e06 	br	d01bf78 <getPHYSpeed+0x4f8>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 d01bec0:	e0bf9c07 	ldb	r2,-400(fp)
 d01bec4:	e0bfe215 	stw	r2,-120(fp)
 d01bec8:	e0bfa183 	ldbu	r2,-378(fp)
 d01becc:	108000a0 	cmpeqi	r2,r2,2
 d01bed0:	1000161e 	bne	r2,zero,d01bf2c <getPHYSpeed+0x4ac>
 d01bed4:	e0bfa183 	ldbu	r2,-378(fp)
 d01bed8:	10800060 	cmpeqi	r2,r2,1
 d01bedc:	10000d1e 	bne	r2,zero,d01bf14 <getPHYSpeed+0x494>
 d01bee0:	e0bfa183 	ldbu	r2,-378(fp)
 d01bee4:	1004c03a 	cmpne	r2,r2,zero
 d01bee8:	1000041e 	bne	r2,zero,d01befc <getPHYSpeed+0x47c>
 d01beec:	00c34174 	movhi	r3,3333
 d01bef0:	18f32004 	addi	r3,r3,-13184
 d01bef4:	e0ffdf15 	stw	r3,-132(fp)
 d01bef8:	00000306 	br	d01bf08 <getPHYSpeed+0x488>
 d01befc:	01034174 	movhi	r4,3333
 d01bf00:	21332104 	addi	r4,r4,-13180
 d01bf04:	e13fdf15 	stw	r4,-132(fp)
 d01bf08:	e0bfdf17 	ldw	r2,-132(fp)
 d01bf0c:	e0bfe015 	stw	r2,-128(fp)
 d01bf10:	00000306 	br	d01bf20 <getPHYSpeed+0x4a0>
 d01bf14:	00c34174 	movhi	r3,3333
 d01bf18:	18f32304 	addi	r3,r3,-13172
 d01bf1c:	e0ffe015 	stw	r3,-128(fp)
 d01bf20:	e13fe017 	ldw	r4,-128(fp)
 d01bf24:	e13fe115 	stw	r4,-124(fp)
 d01bf28:	00000306 	br	d01bf38 <getPHYSpeed+0x4b8>
 d01bf2c:	00834174 	movhi	r2,3333
 d01bf30:	10b32404 	addi	r2,r2,-13168
 d01bf34:	e0bfe115 	stw	r2,-124(fp)
 d01bf38:	e0bfa143 	ldbu	r2,-379(fp)
 d01bf3c:	10800058 	cmpnei	r2,r2,1
 d01bf40:	1000041e 	bne	r2,zero,d01bf54 <getPHYSpeed+0x4d4>
 d01bf44:	00c34174 	movhi	r3,3333
 d01bf48:	18f32604 	addi	r3,r3,-13160
 d01bf4c:	e0ffde15 	stw	r3,-136(fp)
 d01bf50:	00000306 	br	d01bf60 <getPHYSpeed+0x4e0>
 d01bf54:	01034174 	movhi	r4,3333
 d01bf58:	21332804 	addi	r4,r4,-13152
 d01bf5c:	e13fde15 	stw	r4,-136(fp)
 d01bf60:	01034174 	movhi	r4,3333
 d01bf64:	21336504 	addi	r4,r4,-12908
 d01bf68:	e17fe217 	ldw	r5,-120(fp)
 d01bf6c:	e1bfe117 	ldw	r6,-124(fp)
 d01bf70:	e1ffde17 	ldw	r7,-136(fp)
 d01bf74:	d0029980 	call	d002998 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 d01bf78:	e0bfa103 	ldbu	r2,-380(fp)
 d01bf7c:	e0bfeb15 	stw	r2,-84(fp)
 d01bf80:	00023f06 	br	d01c880 <getPHYSpeed+0xe00>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d01bf84:	e0bf9e17 	ldw	r2,-392(fp)
 d01bf88:	10800117 	ldw	r2,4(r2)
 d01bf8c:	10800217 	ldw	r2,8(r2)
 d01bf90:	10800017 	ldw	r2,0(r2)
 d01bf94:	e0bf9b15 	stw	r2,-404(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 d01bf98:	e0bfa017 	ldw	r2,-384(fp)
 d01bf9c:	1004c03a 	cmpne	r2,r2,zero
 d01bfa0:	10006b1e 	bne	r2,zero,d01c150 <getPHYSpeed+0x6d0>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d01bfa4:	00800044 	movi	r2,1
 d01bfa8:	e0bfa185 	stb	r2,-378(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d01bfac:	00800044 	movi	r2,1
 d01bfb0:	e0bfa145 	stb	r2,-379(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 d01bfb4:	e0bfa143 	ldbu	r2,-379(fp)
 d01bfb8:	1080004c 	andi	r2,r2,1
 d01bfbc:	e0bfdd05 	stb	r2,-140(fp)
 d01bfc0:	e0bfa183 	ldbu	r2,-378(fp)
 d01bfc4:	10800098 	cmpnei	r2,r2,2
 d01bfc8:	1000031e 	bne	r2,zero,d01bfd8 <getPHYSpeed+0x558>
 d01bfcc:	00c00084 	movi	r3,2
 d01bfd0:	e0ffdc05 	stb	r3,-144(fp)
 d01bfd4:	00000106 	br	d01bfdc <getPHYSpeed+0x55c>
 d01bfd8:	e03fdc05 	stb	zero,-144(fp)
 d01bfdc:	e13fdd03 	ldbu	r4,-140(fp)
 d01bfe0:	e0ffdc03 	ldbu	r3,-144(fp)
 d01bfe4:	20c4b03a 	or	r2,r4,r3
 d01bfe8:	e0bfdb05 	stb	r2,-148(fp)
 d01bfec:	e0bfa183 	ldbu	r2,-378(fp)
 d01bff0:	10800058 	cmpnei	r2,r2,1
 d01bff4:	1000031e 	bne	r2,zero,d01c004 <getPHYSpeed+0x584>
 d01bff8:	01000104 	movi	r4,4
 d01bffc:	e13fda05 	stb	r4,-152(fp)
 d01c000:	00000106 	br	d01c008 <getPHYSpeed+0x588>
 d01c004:	e03fda05 	stb	zero,-152(fp)
 d01c008:	e0ffdb03 	ldbu	r3,-148(fp)
 d01c00c:	e13fda03 	ldbu	r4,-152(fp)
 d01c010:	1904b03a 	or	r2,r3,r4
 d01c014:	e0bfd905 	stb	r2,-156(fp)
 d01c018:	e0bfa183 	ldbu	r2,-378(fp)
 d01c01c:	1004c03a 	cmpne	r2,r2,zero
 d01c020:	1000031e 	bne	r2,zero,d01c030 <getPHYSpeed+0x5b0>
 d01c024:	00800204 	movi	r2,8
 d01c028:	e0bfd805 	stb	r2,-160(fp)
 d01c02c:	00000106 	br	d01c034 <getPHYSpeed+0x5b4>
 d01c030:	e03fd805 	stb	zero,-160(fp)
 d01c034:	e0ffd903 	ldbu	r3,-156(fp)
 d01c038:	e13fd803 	ldbu	r4,-160(fp)
 d01c03c:	1904b03a 	or	r2,r3,r4
 d01c040:	e0bfd705 	stb	r2,-164(fp)
 d01c044:	e0bfa183 	ldbu	r2,-378(fp)
 d01c048:	108000d8 	cmpnei	r2,r2,3
 d01c04c:	1000031e 	bne	r2,zero,d01c05c <getPHYSpeed+0x5dc>
 d01c050:	0005883a 	mov	r2,zero
 d01c054:	e0bfd605 	stb	r2,-168(fp)
 d01c058:	00000106 	br	d01c060 <getPHYSpeed+0x5e0>
 d01c05c:	e03fd605 	stb	zero,-168(fp)
 d01c060:	e0ffd703 	ldbu	r3,-164(fp)
 d01c064:	e13fd603 	ldbu	r4,-168(fp)
 d01c068:	1904b03a 	or	r2,r3,r4
 d01c06c:	1007883a 	mov	r3,r2
 d01c070:	0005883a 	mov	r2,zero
 d01c074:	1884b03a 	or	r2,r3,r2
 d01c078:	e0bfa105 	stb	r2,-380(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 d01c07c:	e0bf9c07 	ldb	r2,-400(fp)
 d01c080:	e0bfd515 	stw	r2,-172(fp)
 d01c084:	e0ff9c47 	ldb	r3,-399(fp)
 d01c088:	e0ffd415 	stw	r3,-176(fp)
 d01c08c:	e0bfa183 	ldbu	r2,-378(fp)
 d01c090:	108000a0 	cmpeqi	r2,r2,2
 d01c094:	1000161e 	bne	r2,zero,d01c0f0 <getPHYSpeed+0x670>
 d01c098:	e0bfa183 	ldbu	r2,-378(fp)
 d01c09c:	10800060 	cmpeqi	r2,r2,1
 d01c0a0:	10000d1e 	bne	r2,zero,d01c0d8 <getPHYSpeed+0x658>
 d01c0a4:	e0bfa183 	ldbu	r2,-378(fp)
 d01c0a8:	1004c03a 	cmpne	r2,r2,zero
 d01c0ac:	1000041e 	bne	r2,zero,d01c0c0 <getPHYSpeed+0x640>
 d01c0b0:	01034174 	movhi	r4,3333
 d01c0b4:	21332004 	addi	r4,r4,-13184
 d01c0b8:	e13fd115 	stw	r4,-188(fp)
 d01c0bc:	00000306 	br	d01c0cc <getPHYSpeed+0x64c>
 d01c0c0:	00834174 	movhi	r2,3333
 d01c0c4:	10b32104 	addi	r2,r2,-13180
 d01c0c8:	e0bfd115 	stw	r2,-188(fp)
 d01c0cc:	e0ffd117 	ldw	r3,-188(fp)
 d01c0d0:	e0ffd215 	stw	r3,-184(fp)
 d01c0d4:	00000306 	br	d01c0e4 <getPHYSpeed+0x664>
 d01c0d8:	01034174 	movhi	r4,3333
 d01c0dc:	21332304 	addi	r4,r4,-13172
 d01c0e0:	e13fd215 	stw	r4,-184(fp)
 d01c0e4:	e0bfd217 	ldw	r2,-184(fp)
 d01c0e8:	e0bfd315 	stw	r2,-180(fp)
 d01c0ec:	00000306 	br	d01c0fc <getPHYSpeed+0x67c>
 d01c0f0:	00c34174 	movhi	r3,3333
 d01c0f4:	18f32404 	addi	r3,r3,-13168
 d01c0f8:	e0ffd315 	stw	r3,-180(fp)
 d01c0fc:	e0bfa143 	ldbu	r2,-379(fp)
 d01c100:	10800058 	cmpnei	r2,r2,1
 d01c104:	1000041e 	bne	r2,zero,d01c118 <getPHYSpeed+0x698>
 d01c108:	01034174 	movhi	r4,3333
 d01c10c:	21332604 	addi	r4,r4,-13160
 d01c110:	e13fd015 	stw	r4,-192(fp)
 d01c114:	00000306 	br	d01c124 <getPHYSpeed+0x6a4>
 d01c118:	00834174 	movhi	r2,3333
 d01c11c:	10b32804 	addi	r2,r2,-13152
 d01c120:	e0bfd015 	stw	r2,-192(fp)
 d01c124:	e0ffd017 	ldw	r3,-192(fp)
 d01c128:	d8c00015 	stw	r3,0(sp)
 d01c12c:	01034174 	movhi	r4,3333
 d01c130:	21337704 	addi	r4,r4,-12836
 d01c134:	e17fd517 	ldw	r5,-172(fp)
 d01c138:	e1bfd417 	ldw	r6,-176(fp)
 d01c13c:	e1ffd317 	ldw	r7,-180(fp)
 d01c140:	d0029980 	call	d002998 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 d01c144:	e13fa103 	ldbu	r4,-380(fp)
 d01c148:	e13feb15 	stw	r4,-84(fp)
 d01c14c:	0001cc06 	br	d01c880 <getPHYSpeed+0xe00>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 d01c150:	e0bf9f17 	ldw	r2,-388(fp)
 d01c154:	10800003 	ldbu	r2,0(r2)
 d01c158:	10803fcc 	andi	r2,r2,255
 d01c15c:	10800058 	cmpnei	r2,r2,1
 d01c160:	1000081e 	bne	r2,zero,d01c184 <getPHYSpeed+0x704>
			alt_tse_phy_set_adv_1000(pphy, 0);
 d01c164:	e13fa017 	ldw	r4,-384(fp)
 d01c168:	000b883a 	mov	r5,zero
 d01c16c:	d01e74c0 	call	d01e74c <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 d01c170:	e13fa017 	ldw	r4,-384(fp)
 d01c174:	01400134 	movhi	r5,4
 d01c178:	29742404 	addi	r5,r5,-12144
 d01c17c:	d01df180 	call	d01df18 <alt_tse_phy_restart_an>
 d01c180:	00000f06 	br	d01c1c0 <getPHYSpeed+0x740>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 d01c184:	e0bf9f17 	ldw	r2,-388(fp)
 d01c188:	10800003 	ldbu	r2,0(r2)
 d01c18c:	10803fcc 	andi	r2,r2,255
 d01c190:	10800098 	cmpnei	r2,r2,2
 d01c194:	10000a1e 	bne	r2,zero,d01c1c0 <getPHYSpeed+0x740>
			alt_tse_phy_set_adv_100(pphy, 0);
 d01c198:	e13fa017 	ldw	r4,-384(fp)
 d01c19c:	000b883a 	mov	r5,zero
 d01c1a0:	d01e8e00 	call	d01e8e0 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 d01c1a4:	e13fa017 	ldw	r4,-384(fp)
 d01c1a8:	000b883a 	mov	r5,zero
 d01c1ac:	d01eaf00 	call	d01eaf0 <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 d01c1b0:	e13fa017 	ldw	r4,-384(fp)
 d01c1b4:	01400134 	movhi	r5,4
 d01c1b8:	29742404 	addi	r5,r5,-12144
 d01c1bc:	d01df180 	call	d01df18 <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 d01c1c0:	e13fa017 	ldw	r4,-384(fp)
 d01c1c4:	01400134 	movhi	r5,4
 d01c1c8:	29742404 	addi	r5,r5,-12144
 d01c1cc:	d01e0c80 	call	d01e0c8 <alt_tse_phy_check_link>
 d01c1d0:	10bfffd8 	cmpnei	r2,r2,-1
 d01c1d4:	10006b1e 	bne	r2,zero,d01c384 <getPHYSpeed+0x904>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d01c1d8:	00800044 	movi	r2,1
 d01c1dc:	e0bfa185 	stb	r2,-378(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d01c1e0:	00800044 	movi	r2,1
 d01c1e4:	e0bfa145 	stb	r2,-379(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 d01c1e8:	e0bfa143 	ldbu	r2,-379(fp)
 d01c1ec:	1080004c 	andi	r2,r2,1
 d01c1f0:	e0bfcf05 	stb	r2,-196(fp)
 d01c1f4:	e0bfa183 	ldbu	r2,-378(fp)
 d01c1f8:	10800098 	cmpnei	r2,r2,2
 d01c1fc:	1000031e 	bne	r2,zero,d01c20c <getPHYSpeed+0x78c>
 d01c200:	00800084 	movi	r2,2
 d01c204:	e0bfce05 	stb	r2,-200(fp)
 d01c208:	00000106 	br	d01c210 <getPHYSpeed+0x790>
 d01c20c:	e03fce05 	stb	zero,-200(fp)
 d01c210:	e0ffcf03 	ldbu	r3,-196(fp)
 d01c214:	e13fce03 	ldbu	r4,-200(fp)
 d01c218:	1904b03a 	or	r2,r3,r4
 d01c21c:	e0bfcd05 	stb	r2,-204(fp)
 d01c220:	e0bfa183 	ldbu	r2,-378(fp)
 d01c224:	10800058 	cmpnei	r2,r2,1
 d01c228:	1000031e 	bne	r2,zero,d01c238 <getPHYSpeed+0x7b8>
 d01c22c:	00800104 	movi	r2,4
 d01c230:	e0bfcc05 	stb	r2,-208(fp)
 d01c234:	00000106 	br	d01c23c <getPHYSpeed+0x7bc>
 d01c238:	e03fcc05 	stb	zero,-208(fp)
 d01c23c:	e0ffcd03 	ldbu	r3,-204(fp)
 d01c240:	e13fcc03 	ldbu	r4,-208(fp)
 d01c244:	1904b03a 	or	r2,r3,r4
 d01c248:	e0bfcb05 	stb	r2,-212(fp)
 d01c24c:	e0bfa183 	ldbu	r2,-378(fp)
 d01c250:	1004c03a 	cmpne	r2,r2,zero
 d01c254:	1000031e 	bne	r2,zero,d01c264 <getPHYSpeed+0x7e4>
 d01c258:	00800204 	movi	r2,8
 d01c25c:	e0bfca05 	stb	r2,-216(fp)
 d01c260:	00000106 	br	d01c268 <getPHYSpeed+0x7e8>
 d01c264:	e03fca05 	stb	zero,-216(fp)
 d01c268:	e0ffcb03 	ldbu	r3,-212(fp)
 d01c26c:	e13fca03 	ldbu	r4,-216(fp)
 d01c270:	1904b03a 	or	r2,r3,r4
 d01c274:	e0bfc905 	stb	r2,-220(fp)
 d01c278:	e0bfa183 	ldbu	r2,-378(fp)
 d01c27c:	108000d8 	cmpnei	r2,r2,3
 d01c280:	1000031e 	bne	r2,zero,d01c290 <getPHYSpeed+0x810>
 d01c284:	0005883a 	mov	r2,zero
 d01c288:	e0bfc805 	stb	r2,-224(fp)
 d01c28c:	00000106 	br	d01c294 <getPHYSpeed+0x814>
 d01c290:	e03fc805 	stb	zero,-224(fp)
 d01c294:	e0ffc903 	ldbu	r3,-220(fp)
 d01c298:	e13fc803 	ldbu	r4,-224(fp)
 d01c29c:	1904b03a 	or	r2,r3,r4
 d01c2a0:	1007883a 	mov	r3,r2
 d01c2a4:	0005883a 	mov	r2,zero
 d01c2a8:	1884b03a 	or	r2,r3,r2
 d01c2ac:	e0bfa105 	stb	r2,-380(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 d01c2b0:	e0bf9c07 	ldb	r2,-400(fp)
 d01c2b4:	e0bfc715 	stw	r2,-228(fp)
 d01c2b8:	e0ff9c47 	ldb	r3,-399(fp)
 d01c2bc:	e0ffc615 	stw	r3,-232(fp)
 d01c2c0:	e0bfa183 	ldbu	r2,-378(fp)
 d01c2c4:	108000a0 	cmpeqi	r2,r2,2
 d01c2c8:	1000161e 	bne	r2,zero,d01c324 <getPHYSpeed+0x8a4>
 d01c2cc:	e0bfa183 	ldbu	r2,-378(fp)
 d01c2d0:	10800060 	cmpeqi	r2,r2,1
 d01c2d4:	10000d1e 	bne	r2,zero,d01c30c <getPHYSpeed+0x88c>
 d01c2d8:	e0bfa183 	ldbu	r2,-378(fp)
 d01c2dc:	1004c03a 	cmpne	r2,r2,zero
 d01c2e0:	1000041e 	bne	r2,zero,d01c2f4 <getPHYSpeed+0x874>
 d01c2e4:	01034174 	movhi	r4,3333
 d01c2e8:	21332004 	addi	r4,r4,-13184
 d01c2ec:	e13fc315 	stw	r4,-244(fp)
 d01c2f0:	00000306 	br	d01c300 <getPHYSpeed+0x880>
 d01c2f4:	00834174 	movhi	r2,3333
 d01c2f8:	10b32104 	addi	r2,r2,-13180
 d01c2fc:	e0bfc315 	stw	r2,-244(fp)
 d01c300:	e0ffc317 	ldw	r3,-244(fp)
 d01c304:	e0ffc415 	stw	r3,-240(fp)
 d01c308:	00000306 	br	d01c318 <getPHYSpeed+0x898>
 d01c30c:	01034174 	movhi	r4,3333
 d01c310:	21332304 	addi	r4,r4,-13172
 d01c314:	e13fc415 	stw	r4,-240(fp)
 d01c318:	e0bfc417 	ldw	r2,-240(fp)
 d01c31c:	e0bfc515 	stw	r2,-236(fp)
 d01c320:	00000306 	br	d01c330 <getPHYSpeed+0x8b0>
 d01c324:	00c34174 	movhi	r3,3333
 d01c328:	18f32404 	addi	r3,r3,-13168
 d01c32c:	e0ffc515 	stw	r3,-236(fp)
 d01c330:	e0bfa143 	ldbu	r2,-379(fp)
 d01c334:	10800058 	cmpnei	r2,r2,1
 d01c338:	1000041e 	bne	r2,zero,d01c34c <getPHYSpeed+0x8cc>
 d01c33c:	01034174 	movhi	r4,3333
 d01c340:	21332604 	addi	r4,r4,-13160
 d01c344:	e13fc215 	stw	r4,-248(fp)
 d01c348:	00000306 	br	d01c358 <getPHYSpeed+0x8d8>
 d01c34c:	00834174 	movhi	r2,3333
 d01c350:	10b32804 	addi	r2,r2,-13152
 d01c354:	e0bfc215 	stw	r2,-248(fp)
 d01c358:	e0ffc217 	ldw	r3,-248(fp)
 d01c35c:	d8c00015 	stw	r3,0(sp)
 d01c360:	01034174 	movhi	r4,3333
 d01c364:	21338804 	addi	r4,r4,-12768
 d01c368:	e17fc717 	ldw	r5,-228(fp)
 d01c36c:	e1bfc617 	ldw	r6,-232(fp)
 d01c370:	e1ffc517 	ldw	r7,-236(fp)
 d01c374:	d0029980 	call	d002998 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 d01c378:	e13fa103 	ldbu	r4,-380(fp)
 d01c37c:	e13feb15 	stw	r4,-84(fp)
 d01c380:	00013f06 	br	d01c880 <getPHYSpeed+0xe00>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 d01c384:	e0bf9b17 	ldw	r2,-404(fp)
 d01c388:	10801004 	addi	r2,r2,64
 d01c38c:	1009883a 	mov	r4,r2
 d01c390:	e0bfa017 	ldw	r2,-384(fp)
 d01c394:	10800003 	ldbu	r2,0(r2)
 d01c398:	10c03fcc 	andi	r3,r2,255
 d01c39c:	2005883a 	mov	r2,r4
 d01c3a0:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 d01c3a4:	d8000015 	stw	zero,0(sp)
 d01c3a8:	e13fa017 	ldw	r4,-384(fp)
 d01c3ac:	000b883a 	mov	r5,zero
 d01c3b0:	01800384 	movi	r6,14
 d01c3b4:	01c00044 	movi	r7,1
 d01c3b8:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 d01c3bc:	e0bfa017 	ldw	r2,-384(fp)
 d01c3c0:	10800517 	ldw	r2,20(r2)
 d01c3c4:	1004c03a 	cmpne	r2,r2,zero
 d01c3c8:	10003c1e 	bne	r2,zero,d01c4bc <getPHYSpeed+0xa3c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 d01c3cc:	e17f9c07 	ldb	r5,-400(fp)
 d01c3d0:	e1bf9c47 	ldb	r6,-399(fp)
 d01c3d4:	01034174 	movhi	r4,3333
 d01c3d8:	21339c04 	addi	r4,r4,-12688
 d01c3dc:	d0029980 	call	d002998 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d01c3e0:	00800044 	movi	r2,1
 d01c3e4:	e0bfa185 	stb	r2,-378(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d01c3e8:	00800044 	movi	r2,1
 d01c3ec:	e0bfa145 	stb	r2,-379(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 d01c3f0:	e0bfa143 	ldbu	r2,-379(fp)
 d01c3f4:	1080004c 	andi	r2,r2,1
 d01c3f8:	e0bfc105 	stb	r2,-252(fp)
 d01c3fc:	e0bfa183 	ldbu	r2,-378(fp)
 d01c400:	10800098 	cmpnei	r2,r2,2
 d01c404:	1000031e 	bne	r2,zero,d01c414 <getPHYSpeed+0x994>
 d01c408:	00800084 	movi	r2,2
 d01c40c:	e0bfc005 	stb	r2,-256(fp)
 d01c410:	00000106 	br	d01c418 <getPHYSpeed+0x998>
 d01c414:	e03fc005 	stb	zero,-256(fp)
 d01c418:	e0ffc103 	ldbu	r3,-252(fp)
 d01c41c:	e13fc003 	ldbu	r4,-256(fp)
 d01c420:	1904b03a 	or	r2,r3,r4
 d01c424:	e0bfbf05 	stb	r2,-260(fp)
 d01c428:	e0bfa183 	ldbu	r2,-378(fp)
 d01c42c:	10800058 	cmpnei	r2,r2,1
 d01c430:	1000031e 	bne	r2,zero,d01c440 <getPHYSpeed+0x9c0>
 d01c434:	00800104 	movi	r2,4
 d01c438:	e0bfbe05 	stb	r2,-264(fp)
 d01c43c:	00000106 	br	d01c444 <getPHYSpeed+0x9c4>
 d01c440:	e03fbe05 	stb	zero,-264(fp)
 d01c444:	e0ffbf03 	ldbu	r3,-260(fp)
 d01c448:	e13fbe03 	ldbu	r4,-264(fp)
 d01c44c:	1904b03a 	or	r2,r3,r4
 d01c450:	e0bfbd05 	stb	r2,-268(fp)
 d01c454:	e0bfa183 	ldbu	r2,-378(fp)
 d01c458:	1004c03a 	cmpne	r2,r2,zero
 d01c45c:	1000031e 	bne	r2,zero,d01c46c <getPHYSpeed+0x9ec>
 d01c460:	00800204 	movi	r2,8
 d01c464:	e0bfbc05 	stb	r2,-272(fp)
 d01c468:	00000106 	br	d01c470 <getPHYSpeed+0x9f0>
 d01c46c:	e03fbc05 	stb	zero,-272(fp)
 d01c470:	e0ffbd03 	ldbu	r3,-268(fp)
 d01c474:	e13fbc03 	ldbu	r4,-272(fp)
 d01c478:	1904b03a 	or	r2,r3,r4
 d01c47c:	e0bfbb05 	stb	r2,-276(fp)
 d01c480:	e0bfa183 	ldbu	r2,-378(fp)
 d01c484:	108000d8 	cmpnei	r2,r2,3
 d01c488:	1000031e 	bne	r2,zero,d01c498 <getPHYSpeed+0xa18>
 d01c48c:	0005883a 	mov	r2,zero
 d01c490:	e0bfba05 	stb	r2,-280(fp)
 d01c494:	00000106 	br	d01c49c <getPHYSpeed+0xa1c>
 d01c498:	e03fba05 	stb	zero,-280(fp)
 d01c49c:	e0ffbb03 	ldbu	r3,-276(fp)
 d01c4a0:	e13fba03 	ldbu	r4,-280(fp)
 d01c4a4:	1904b03a 	or	r2,r3,r4
 d01c4a8:	1007883a 	mov	r3,r2
 d01c4ac:	0005883a 	mov	r2,zero
 d01c4b0:	1884b03a 	or	r2,r3,r2
 d01c4b4:	e0bfa105 	stb	r2,-380(fp)
 d01c4b8:	0000bd06 	br	d01c7b0 <getPHYSpeed+0xd30>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 d01c4bc:	e0bfa017 	ldw	r2,-384(fp)
 d01c4c0:	10800517 	ldw	r2,20(r2)
 d01c4c4:	10801817 	ldw	r2,96(r2)
 d01c4c8:	1005003a 	cmpeq	r2,r2,zero
 d01c4cc:	10002f1e 	bne	r2,zero,d01c58c <getPHYSpeed+0xb0c>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 d01c4d0:	e0bfa017 	ldw	r2,-384(fp)
 d01c4d4:	10800517 	ldw	r2,20(r2)
 d01c4d8:	10801817 	ldw	r2,96(r2)
 d01c4dc:	e13f9b17 	ldw	r4,-404(fp)
 d01c4e0:	103ee83a 	callr	r2
 d01c4e4:	e0bfa105 	stb	r2,-380(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 d01c4e8:	e0bfa103 	ldbu	r2,-380(fp)
 d01c4ec:	1080008c 	andi	r2,r2,2
 d01c4f0:	1004c03a 	cmpne	r2,r2,zero
 d01c4f4:	1000141e 	bne	r2,zero,d01c548 <getPHYSpeed+0xac8>
 d01c4f8:	e0bfa103 	ldbu	r2,-380(fp)
 d01c4fc:	1080010c 	andi	r2,r2,4
 d01c500:	1004c03a 	cmpne	r2,r2,zero
 d01c504:	10000b1e 	bne	r2,zero,d01c534 <getPHYSpeed+0xab4>
 d01c508:	e0bfa103 	ldbu	r2,-380(fp)
 d01c50c:	1080020c 	andi	r2,r2,8
 d01c510:	1005003a 	cmpeq	r2,r2,zero
 d01c514:	1000021e 	bne	r2,zero,d01c520 <getPHYSpeed+0xaa0>
 d01c518:	e03fb905 	stb	zero,-284(fp)
 d01c51c:	00000206 	br	d01c528 <getPHYSpeed+0xaa8>
 d01c520:	008000c4 	movi	r2,3
 d01c524:	e0bfb905 	stb	r2,-284(fp)
 d01c528:	e0ffb903 	ldbu	r3,-284(fp)
 d01c52c:	e0ffb945 	stb	r3,-283(fp)
 d01c530:	00000206 	br	d01c53c <getPHYSpeed+0xabc>
 d01c534:	01000044 	movi	r4,1
 d01c538:	e13fb945 	stb	r4,-283(fp)
 d01c53c:	e0bfb943 	ldbu	r2,-283(fp)
 d01c540:	e0bfb985 	stb	r2,-282(fp)
 d01c544:	00000206 	br	d01c550 <getPHYSpeed+0xad0>
 d01c548:	00c00084 	movi	r3,2
 d01c54c:	e0ffb985 	stb	r3,-282(fp)
 d01c550:	e13fb983 	ldbu	r4,-282(fp)
 d01c554:	e13fa185 	stb	r4,-378(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 d01c558:	e0bfa103 	ldbu	r2,-380(fp)
 d01c55c:	1080004c 	andi	r2,r2,1
 d01c560:	e0bfa145 	stb	r2,-379(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 d01c564:	e0bfa103 	ldbu	r2,-380(fp)
 d01c568:	1080006c 	andhi	r2,r2,1
 d01c56c:	1005003a 	cmpeq	r2,r2,zero
 d01c570:	10008f1e 	bne	r2,zero,d01c7b0 <getPHYSpeed+0xd30>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 d01c574:	e17f9c07 	ldb	r5,-400(fp)
 d01c578:	e1bf9c47 	ldb	r6,-399(fp)
 d01c57c:	01034174 	movhi	r4,3333
 d01c580:	2133aa04 	addi	r4,r4,-12632
 d01c584:	d0029980 	call	d002998 <printf>
 d01c588:	00008906 	br	d01c7b0 <getPHYSpeed+0xd30>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 d01c58c:	e0bfa017 	ldw	r2,-384(fp)
 d01c590:	10800517 	ldw	r2,20(r2)
 d01c594:	10801583 	ldbu	r2,86(r2)
 d01c598:	10803fcc 	andi	r2,r2,255
 d01c59c:	1004c03a 	cmpne	r2,r2,zero
 d01c5a0:	10003c1e 	bne	r2,zero,d01c694 <getPHYSpeed+0xc14>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 d01c5a4:	e17f9c07 	ldb	r5,-400(fp)
 d01c5a8:	e1bf9c47 	ldb	r6,-399(fp)
 d01c5ac:	01034174 	movhi	r4,3333
 d01c5b0:	2133b704 	addi	r4,r4,-12580
 d01c5b4:	d0029980 	call	d002998 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 d01c5b8:	00800044 	movi	r2,1
 d01c5bc:	e0bfa185 	stb	r2,-378(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 d01c5c0:	00800044 	movi	r2,1
 d01c5c4:	e0bfa145 	stb	r2,-379(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 d01c5c8:	e0bfa143 	ldbu	r2,-379(fp)
 d01c5cc:	1080004c 	andi	r2,r2,1
 d01c5d0:	e0bfb805 	stb	r2,-288(fp)
 d01c5d4:	e0bfa183 	ldbu	r2,-378(fp)
 d01c5d8:	10800098 	cmpnei	r2,r2,2
 d01c5dc:	1000031e 	bne	r2,zero,d01c5ec <getPHYSpeed+0xb6c>
 d01c5e0:	00800084 	movi	r2,2
 d01c5e4:	e0bfb705 	stb	r2,-292(fp)
 d01c5e8:	00000106 	br	d01c5f0 <getPHYSpeed+0xb70>
 d01c5ec:	e03fb705 	stb	zero,-292(fp)
 d01c5f0:	e0ffb803 	ldbu	r3,-288(fp)
 d01c5f4:	e13fb703 	ldbu	r4,-292(fp)
 d01c5f8:	1904b03a 	or	r2,r3,r4
 d01c5fc:	e0bfb605 	stb	r2,-296(fp)
 d01c600:	e0bfa183 	ldbu	r2,-378(fp)
 d01c604:	10800058 	cmpnei	r2,r2,1
 d01c608:	1000031e 	bne	r2,zero,d01c618 <getPHYSpeed+0xb98>
 d01c60c:	00800104 	movi	r2,4
 d01c610:	e0bfb505 	stb	r2,-300(fp)
 d01c614:	00000106 	br	d01c61c <getPHYSpeed+0xb9c>
 d01c618:	e03fb505 	stb	zero,-300(fp)
 d01c61c:	e0ffb603 	ldbu	r3,-296(fp)
 d01c620:	e13fb503 	ldbu	r4,-300(fp)
 d01c624:	1904b03a 	or	r2,r3,r4
 d01c628:	e0bfb405 	stb	r2,-304(fp)
 d01c62c:	e0bfa183 	ldbu	r2,-378(fp)
 d01c630:	1004c03a 	cmpne	r2,r2,zero
 d01c634:	1000031e 	bne	r2,zero,d01c644 <getPHYSpeed+0xbc4>
 d01c638:	00800204 	movi	r2,8
 d01c63c:	e0bfb305 	stb	r2,-308(fp)
 d01c640:	00000106 	br	d01c648 <getPHYSpeed+0xbc8>
 d01c644:	e03fb305 	stb	zero,-308(fp)
 d01c648:	e0ffb403 	ldbu	r3,-304(fp)
 d01c64c:	e13fb303 	ldbu	r4,-308(fp)
 d01c650:	1904b03a 	or	r2,r3,r4
 d01c654:	e0bfb205 	stb	r2,-312(fp)
 d01c658:	e0bfa183 	ldbu	r2,-378(fp)
 d01c65c:	108000d8 	cmpnei	r2,r2,3
 d01c660:	1000031e 	bne	r2,zero,d01c670 <getPHYSpeed+0xbf0>
 d01c664:	0005883a 	mov	r2,zero
 d01c668:	e0bfb105 	stb	r2,-316(fp)
 d01c66c:	00000106 	br	d01c674 <getPHYSpeed+0xbf4>
 d01c670:	e03fb105 	stb	zero,-316(fp)
 d01c674:	e0ffb203 	ldbu	r3,-312(fp)
 d01c678:	e13fb103 	ldbu	r4,-316(fp)
 d01c67c:	1904b03a 	or	r2,r3,r4
 d01c680:	1007883a 	mov	r3,r2
 d01c684:	0005883a 	mov	r2,zero
 d01c688:	1884b03a 	or	r2,r3,r2
 d01c68c:	e0bfa105 	stb	r2,-380(fp)
 d01c690:	00004706 	br	d01c7b0 <getPHYSpeed+0xd30>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 d01c694:	e0bfa017 	ldw	r2,-384(fp)
 d01c698:	10800517 	ldw	r2,20(r2)
 d01c69c:	10801583 	ldbu	r2,86(r2)
 d01c6a0:	11403fcc 	andi	r5,r2,255
 d01c6a4:	e0bfa017 	ldw	r2,-384(fp)
 d01c6a8:	10800517 	ldw	r2,20(r2)
 d01c6ac:	108015c3 	ldbu	r2,87(r2)
 d01c6b0:	11803fcc 	andi	r6,r2,255
 d01c6b4:	e13fa017 	ldw	r4,-384(fp)
 d01c6b8:	01c00084 	movi	r7,2
 d01c6bc:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01c6c0:	e0bfa185 	stb	r2,-378(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 d01c6c4:	e0bfa017 	ldw	r2,-384(fp)
 d01c6c8:	10800517 	ldw	r2,20(r2)
 d01c6cc:	10801583 	ldbu	r2,86(r2)
 d01c6d0:	11403fcc 	andi	r5,r2,255
 d01c6d4:	e0bfa017 	ldw	r2,-384(fp)
 d01c6d8:	10800517 	ldw	r2,20(r2)
 d01c6dc:	10801603 	ldbu	r2,88(r2)
 d01c6e0:	11803fcc 	andi	r6,r2,255
 d01c6e4:	e13fa017 	ldw	r4,-384(fp)
 d01c6e8:	01c00044 	movi	r7,1
 d01c6ec:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01c6f0:	e0bfa145 	stb	r2,-379(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 d01c6f4:	e0bfa143 	ldbu	r2,-379(fp)
 d01c6f8:	1080004c 	andi	r2,r2,1
 d01c6fc:	e0bfb005 	stb	r2,-320(fp)
 d01c700:	e0bfa183 	ldbu	r2,-378(fp)
 d01c704:	10800098 	cmpnei	r2,r2,2
 d01c708:	1000031e 	bne	r2,zero,d01c718 <getPHYSpeed+0xc98>
 d01c70c:	00800084 	movi	r2,2
 d01c710:	e0bfaf05 	stb	r2,-324(fp)
 d01c714:	00000106 	br	d01c71c <getPHYSpeed+0xc9c>
 d01c718:	e03faf05 	stb	zero,-324(fp)
 d01c71c:	e0ffb003 	ldbu	r3,-320(fp)
 d01c720:	e13faf03 	ldbu	r4,-324(fp)
 d01c724:	1904b03a 	or	r2,r3,r4
 d01c728:	e0bfae05 	stb	r2,-328(fp)
 d01c72c:	e0bfa183 	ldbu	r2,-378(fp)
 d01c730:	10800058 	cmpnei	r2,r2,1
 d01c734:	1000031e 	bne	r2,zero,d01c744 <getPHYSpeed+0xcc4>
 d01c738:	00800104 	movi	r2,4
 d01c73c:	e0bfad05 	stb	r2,-332(fp)
 d01c740:	00000106 	br	d01c748 <getPHYSpeed+0xcc8>
 d01c744:	e03fad05 	stb	zero,-332(fp)
 d01c748:	e0ffae03 	ldbu	r3,-328(fp)
 d01c74c:	e13fad03 	ldbu	r4,-332(fp)
 d01c750:	1904b03a 	or	r2,r3,r4
 d01c754:	e0bfac05 	stb	r2,-336(fp)
 d01c758:	e0bfa183 	ldbu	r2,-378(fp)
 d01c75c:	1004c03a 	cmpne	r2,r2,zero
 d01c760:	1000031e 	bne	r2,zero,d01c770 <getPHYSpeed+0xcf0>
 d01c764:	00800204 	movi	r2,8
 d01c768:	e0bfab05 	stb	r2,-340(fp)
 d01c76c:	00000106 	br	d01c774 <getPHYSpeed+0xcf4>
 d01c770:	e03fab05 	stb	zero,-340(fp)
 d01c774:	e0ffac03 	ldbu	r3,-336(fp)
 d01c778:	e13fab03 	ldbu	r4,-340(fp)
 d01c77c:	1904b03a 	or	r2,r3,r4
 d01c780:	e0bfaa05 	stb	r2,-344(fp)
 d01c784:	e0bfa183 	ldbu	r2,-378(fp)
 d01c788:	108000d8 	cmpnei	r2,r2,3
 d01c78c:	1000031e 	bne	r2,zero,d01c79c <getPHYSpeed+0xd1c>
 d01c790:	0005883a 	mov	r2,zero
 d01c794:	e0bfa905 	stb	r2,-348(fp)
 d01c798:	00000106 	br	d01c7a0 <getPHYSpeed+0xd20>
 d01c79c:	e03fa905 	stb	zero,-348(fp)
 d01c7a0:	e0ffaa03 	ldbu	r3,-344(fp)
 d01c7a4:	e13fa903 	ldbu	r4,-348(fp)
 d01c7a8:	1904b03a 	or	r2,r3,r4
 d01c7ac:	e0bfa105 	stb	r2,-380(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 d01c7b0:	e0bf9c07 	ldb	r2,-400(fp)
 d01c7b4:	e0bfa815 	stw	r2,-352(fp)
 d01c7b8:	e0ff9c47 	ldb	r3,-399(fp)
 d01c7bc:	e0ffa715 	stw	r3,-356(fp)
 d01c7c0:	e0bfa183 	ldbu	r2,-378(fp)
 d01c7c4:	108000a0 	cmpeqi	r2,r2,2
 d01c7c8:	1000161e 	bne	r2,zero,d01c824 <getPHYSpeed+0xda4>
 d01c7cc:	e0bfa183 	ldbu	r2,-378(fp)
 d01c7d0:	10800060 	cmpeqi	r2,r2,1
 d01c7d4:	10000d1e 	bne	r2,zero,d01c80c <getPHYSpeed+0xd8c>
 d01c7d8:	e0bfa183 	ldbu	r2,-378(fp)
 d01c7dc:	1004c03a 	cmpne	r2,r2,zero
 d01c7e0:	1000041e 	bne	r2,zero,d01c7f4 <getPHYSpeed+0xd74>
 d01c7e4:	01034174 	movhi	r4,3333
 d01c7e8:	21332004 	addi	r4,r4,-13184
 d01c7ec:	e13fa415 	stw	r4,-368(fp)
 d01c7f0:	00000306 	br	d01c800 <getPHYSpeed+0xd80>
 d01c7f4:	00834174 	movhi	r2,3333
 d01c7f8:	10b32104 	addi	r2,r2,-13180
 d01c7fc:	e0bfa415 	stw	r2,-368(fp)
 d01c800:	e0ffa417 	ldw	r3,-368(fp)
 d01c804:	e0ffa515 	stw	r3,-364(fp)
 d01c808:	00000306 	br	d01c818 <getPHYSpeed+0xd98>
 d01c80c:	01034174 	movhi	r4,3333
 d01c810:	21332304 	addi	r4,r4,-13172
 d01c814:	e13fa515 	stw	r4,-364(fp)
 d01c818:	e0bfa517 	ldw	r2,-364(fp)
 d01c81c:	e0bfa615 	stw	r2,-360(fp)
 d01c820:	00000306 	br	d01c830 <getPHYSpeed+0xdb0>
 d01c824:	00c34174 	movhi	r3,3333
 d01c828:	18f32404 	addi	r3,r3,-13168
 d01c82c:	e0ffa615 	stw	r3,-360(fp)
 d01c830:	e0bfa143 	ldbu	r2,-379(fp)
 d01c834:	10800058 	cmpnei	r2,r2,1
 d01c838:	1000041e 	bne	r2,zero,d01c84c <getPHYSpeed+0xdcc>
 d01c83c:	01034174 	movhi	r4,3333
 d01c840:	21332604 	addi	r4,r4,-13160
 d01c844:	e13fa315 	stw	r4,-372(fp)
 d01c848:	00000306 	br	d01c858 <getPHYSpeed+0xdd8>
 d01c84c:	00834174 	movhi	r2,3333
 d01c850:	10b32804 	addi	r2,r2,-13152
 d01c854:	e0bfa315 	stw	r2,-372(fp)
 d01c858:	e0ffa317 	ldw	r3,-372(fp)
 d01c85c:	d8c00015 	stw	r3,0(sp)
 d01c860:	01034174 	movhi	r4,3333
 d01c864:	2133ce04 	addi	r4,r4,-12488
 d01c868:	e17fa817 	ldw	r5,-352(fp)
 d01c86c:	e1bfa717 	ldw	r6,-356(fp)
 d01c870:	e1ffa617 	ldw	r7,-360(fp)
 d01c874:	d0029980 	call	d002998 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 d01c878:	e13fa103 	ldbu	r4,-380(fp)
 d01c87c:	e13feb15 	stw	r4,-84(fp)
 d01c880:	e0bfeb17 	ldw	r2,-84(fp)
}
 d01c884:	e037883a 	mov	sp,fp
 d01c888:	dfc00117 	ldw	ra,4(sp)
 d01c88c:	df000017 	ldw	fp,0(sp)
 d01c890:	dec00204 	addi	sp,sp,8
 d01c894:	f800283a 	ret

0d01c898 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 d01c898:	defffd04 	addi	sp,sp,-12
 d01c89c:	df000215 	stw	fp,8(sp)
 d01c8a0:	df000204 	addi	fp,sp,8
 d01c8a4:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d01c8a8:	e0bfff17 	ldw	r2,-4(fp)
 d01c8ac:	10800617 	ldw	r2,24(r2)
 d01c8b0:	10800317 	ldw	r2,12(r2)
 d01c8b4:	10800117 	ldw	r2,4(r2)
 d01c8b8:	10800217 	ldw	r2,8(r2)
 d01c8bc:	10800017 	ldw	r2,0(r2)
 d01c8c0:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 d01c8c4:	e0bffe17 	ldw	r2,-8(fp)
 d01c8c8:	10801004 	addi	r2,r2,64
 d01c8cc:	10800037 	ldwio	r2,0(r2)
}
 d01c8d0:	e037883a 	mov	sp,fp
 d01c8d4:	df000017 	ldw	fp,0(sp)
 d01c8d8:	dec00104 	addi	sp,sp,4
 d01c8dc:	f800283a 	ret

0d01c8e0 <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 d01c8e0:	defffc04 	addi	sp,sp,-16
 d01c8e4:	df000315 	stw	fp,12(sp)
 d01c8e8:	df000304 	addi	fp,sp,12
 d01c8ec:	e13ffe15 	stw	r4,-8(fp)
 d01c8f0:	e17fff05 	stb	r5,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d01c8f4:	e0bffe17 	ldw	r2,-8(fp)
 d01c8f8:	10800617 	ldw	r2,24(r2)
 d01c8fc:	10800317 	ldw	r2,12(r2)
 d01c900:	10800117 	ldw	r2,4(r2)
 d01c904:	10800217 	ldw	r2,8(r2)
 d01c908:	10800017 	ldw	r2,0(r2)
 d01c90c:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 d01c910:	e0bffd17 	ldw	r2,-12(fp)
 d01c914:	10801004 	addi	r2,r2,64
 d01c918:	e0ffff03 	ldbu	r3,-4(fp)
 d01c91c:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 d01c920:	0005883a 	mov	r2,zero
}
 d01c924:	e037883a 	mov	sp,fp
 d01c928:	df000017 	ldw	fp,0(sp)
 d01c92c:	dec00104 	addi	sp,sp,4
 d01c930:	f800283a 	ret

0d01c934 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 d01c934:	defff704 	addi	sp,sp,-36
 d01c938:	df000815 	stw	fp,32(sp)
 d01c93c:	df000804 	addi	fp,sp,32
 d01c940:	e13ffb15 	stw	r4,-20(fp)
 d01c944:	e0800117 	ldw	r2,4(fp)
 d01c948:	e17ffc05 	stb	r5,-16(fp)
 d01c94c:	e1bffd05 	stb	r6,-12(fp)
 d01c950:	e1fffe05 	stb	r7,-8(fp)
 d01c954:	e0bfff0d 	sth	r2,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d01c958:	e0bffb17 	ldw	r2,-20(fp)
 d01c95c:	10800617 	ldw	r2,24(r2)
 d01c960:	10800317 	ldw	r2,12(r2)
 d01c964:	10800117 	ldw	r2,4(r2)
 d01c968:	10800217 	ldw	r2,8(r2)
 d01c96c:	10800017 	ldw	r2,0(r2)
 d01c970:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
 d01c974:	e03ffa0d 	sth	zero,-24(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 d01c978:	e03ff915 	stw	zero,-28(fp)
 d01c97c:	00000906 	br	d01c9a4 <alt_tse_phy_wr_mdio_reg+0x70>
    {
        bit_mask <<= 1;
 d01c980:	e0bffa0b 	ldhu	r2,-24(fp)
 d01c984:	1085883a 	add	r2,r2,r2
 d01c988:	e0bffa0d 	sth	r2,-24(fp)
        bit_mask |= 0x01;        
 d01c98c:	e0bffa0b 	ldhu	r2,-24(fp)
 d01c990:	10800054 	ori	r2,r2,1
 d01c994:	e0bffa0d 	sth	r2,-24(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 d01c998:	e0bff917 	ldw	r2,-28(fp)
 d01c99c:	10800044 	addi	r2,r2,1
 d01c9a0:	e0bff915 	stw	r2,-28(fp)
 d01c9a4:	e0fffe03 	ldbu	r3,-8(fp)
 d01c9a8:	e0bff917 	ldw	r2,-28(fp)
 d01c9ac:	10fff416 	blt	r2,r3,d01c980 <alt_tse_phy_wr_mdio_reg+0x4c>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 d01c9b0:	e0fffa0b 	ldhu	r3,-24(fp)
 d01c9b4:	e0bffd03 	ldbu	r2,-12(fp)
 d01c9b8:	1884983a 	sll	r2,r3,r2
 d01c9bc:	e0bffa0d 	sth	r2,-24(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 d01c9c0:	e0bff817 	ldw	r2,-32(fp)
 d01c9c4:	1080a004 	addi	r2,r2,640
 d01c9c8:	1007883a 	mov	r3,r2
 d01c9cc:	e0bffc03 	ldbu	r2,-16(fp)
 d01c9d0:	1085883a 	add	r2,r2,r2
 d01c9d4:	1085883a 	add	r2,r2,r2
 d01c9d8:	1885883a 	add	r2,r3,r2
 d01c9dc:	10800037 	ldwio	r2,0(r2)
 d01c9e0:	e0bffa8d 	sth	r2,-22(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 d01c9e4:	e0bffa0b 	ldhu	r2,-24(fp)
 d01c9e8:	0084303a 	nor	r2,zero,r2
 d01c9ec:	1007883a 	mov	r3,r2
 d01c9f0:	e0bffa8b 	ldhu	r2,-22(fp)
 d01c9f4:	1884703a 	and	r2,r3,r2
 d01c9f8:	e0bffa8d 	sth	r2,-22(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 d01c9fc:	e0ffff0b 	ldhu	r3,-4(fp)
 d01ca00:	e0bffd03 	ldbu	r2,-12(fp)
 d01ca04:	1884983a 	sll	r2,r3,r2
 d01ca08:	1007883a 	mov	r3,r2
 d01ca0c:	e0bffa0b 	ldhu	r2,-24(fp)
 d01ca10:	1884703a 	and	r2,r3,r2
 d01ca14:	1007883a 	mov	r3,r2
 d01ca18:	e0bffa8b 	ldhu	r2,-22(fp)
 d01ca1c:	1884b03a 	or	r2,r3,r2
 d01ca20:	e0bffa8d 	sth	r2,-22(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 d01ca24:	e0bff817 	ldw	r2,-32(fp)
 d01ca28:	1080a004 	addi	r2,r2,640
 d01ca2c:	1007883a 	mov	r3,r2
 d01ca30:	e0bffc03 	ldbu	r2,-16(fp)
 d01ca34:	1085883a 	add	r2,r2,r2
 d01ca38:	1085883a 	add	r2,r2,r2
 d01ca3c:	1885883a 	add	r2,r3,r2
 d01ca40:	e0fffa8b 	ldhu	r3,-22(fp)
 d01ca44:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 d01ca48:	0005883a 	mov	r2,zero
    
}
 d01ca4c:	e037883a 	mov	sp,fp
 d01ca50:	df000017 	ldw	fp,0(sp)
 d01ca54:	dec00104 	addi	sp,sp,4
 d01ca58:	f800283a 	ret

0d01ca5c <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 d01ca5c:	defff704 	addi	sp,sp,-36
 d01ca60:	df000815 	stw	fp,32(sp)
 d01ca64:	df000804 	addi	fp,sp,32
 d01ca68:	e13ffc15 	stw	r4,-16(fp)
 d01ca6c:	e17ffd05 	stb	r5,-12(fp)
 d01ca70:	e1bffe05 	stb	r6,-8(fp)
 d01ca74:	e1ffff05 	stb	r7,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d01ca78:	e0bffc17 	ldw	r2,-16(fp)
 d01ca7c:	10800617 	ldw	r2,24(r2)
 d01ca80:	10800317 	ldw	r2,12(r2)
 d01ca84:	10800117 	ldw	r2,4(r2)
 d01ca88:	10800217 	ldw	r2,8(r2)
 d01ca8c:	10800017 	ldw	r2,0(r2)
 d01ca90:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
 d01ca94:	e03ffa15 	stw	zero,-24(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 d01ca98:	e03ff915 	stw	zero,-28(fp)
 d01ca9c:	00000906 	br	d01cac4 <alt_tse_phy_rd_mdio_reg+0x68>
    {
        bit_mask <<= 1;
 d01caa0:	e0bffa17 	ldw	r2,-24(fp)
 d01caa4:	1085883a 	add	r2,r2,r2
 d01caa8:	e0bffa15 	stw	r2,-24(fp)
        bit_mask |= 0x01;        
 d01caac:	e0bffa17 	ldw	r2,-24(fp)
 d01cab0:	10800054 	ori	r2,r2,1
 d01cab4:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 d01cab8:	e0bff917 	ldw	r2,-28(fp)
 d01cabc:	10800044 	addi	r2,r2,1
 d01cac0:	e0bff915 	stw	r2,-28(fp)
 d01cac4:	e0ffff03 	ldbu	r3,-4(fp)
 d01cac8:	e0bff917 	ldw	r2,-28(fp)
 d01cacc:	10fff416 	blt	r2,r3,d01caa0 <alt_tse_phy_rd_mdio_reg+0x44>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 d01cad0:	e0bff817 	ldw	r2,-32(fp)
 d01cad4:	1080a004 	addi	r2,r2,640
 d01cad8:	1007883a 	mov	r3,r2
 d01cadc:	e0bffd03 	ldbu	r2,-12(fp)
 d01cae0:	1085883a 	add	r2,r2,r2
 d01cae4:	1085883a 	add	r2,r2,r2
 d01cae8:	1885883a 	add	r2,r3,r2
 d01caec:	10800037 	ldwio	r2,0(r2)
 d01caf0:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 d01caf4:	e0fffb0b 	ldhu	r3,-20(fp)
 d01caf8:	e0bffe03 	ldbu	r2,-8(fp)
 d01cafc:	1885d83a 	sra	r2,r3,r2
 d01cb00:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 d01cb04:	e0fffb0b 	ldhu	r3,-20(fp)
 d01cb08:	e0bffa17 	ldw	r2,-24(fp)
 d01cb0c:	1884703a 	and	r2,r3,r2
}
 d01cb10:	e037883a 	mov	sp,fp
 d01cb14:	df000017 	ldw	fp,0(sp)
 d01cb18:	dec00104 	addi	sp,sp,4
 d01cb1c:	f800283a 	ret

0d01cb20 <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 d01cb20:	deff9a04 	addi	sp,sp,-408
 d01cb24:	dfc06515 	stw	ra,404(sp)
 d01cb28:	df006415 	stw	fp,400(sp)
 d01cb2c:	df006404 	addi	fp,sp,400
                            0x11,                   /* Location of Status Register                                   */
                            14,                     /* Location of Speed Status                                      */
                            13,                     /* Location of Duplex Status                                     */
                            10,                     /* Location of Link Status                                       */
                            &marvell_phy_cfg        /* Function pointer to configure Marvell PHY                     */
                           };
 d01cb30:	e13f9c04 	addi	r4,fp,-400
 d01cb34:	01801904 	movi	r6,100
 d01cb38:	000b883a 	mov	r5,zero
 d01cb3c:	d0028800 	call	d002880 <memset>
 d01cb40:	00c34174 	movhi	r3,3333
 d01cb44:	18f3da04 	addi	r3,r3,-12440
 d01cb48:	18800017 	ldw	r2,0(r3)
 d01cb4c:	e0bf9c15 	stw	r2,-400(fp)
 d01cb50:	18800117 	ldw	r2,4(r3)
 d01cb54:	e0bf9d15 	stw	r2,-396(fp)
 d01cb58:	18800217 	ldw	r2,8(r3)
 d01cb5c:	e0bf9e15 	stw	r2,-392(fp)
 d01cb60:	18800317 	ldw	r2,12(r3)
 d01cb64:	e0bf9f15 	stw	r2,-388(fp)
 d01cb68:	e13fa004 	addi	r4,fp,-384
 d01cb6c:	01801004 	movi	r6,64
 d01cb70:	000b883a 	mov	r5,zero
 d01cb74:	d0028800 	call	d002880 <memset>
 d01cb78:	009410c4 	movi	r2,20547
 d01cb7c:	e0bfb015 	stw	r2,-320(fp)
 d01cb80:	00800304 	movi	r2,12
 d01cb84:	e0bfb105 	stb	r2,-316(fp)
 d01cb88:	00800084 	movi	r2,2
 d01cb8c:	e0bfb145 	stb	r2,-315(fp)
 d01cb90:	00800444 	movi	r2,17
 d01cb94:	e0bfb185 	stb	r2,-314(fp)
 d01cb98:	00800384 	movi	r2,14
 d01cb9c:	e0bfb1c5 	stb	r2,-313(fp)
 d01cba0:	00800344 	movi	r2,13
 d01cba4:	e0bfb205 	stb	r2,-312(fp)
 d01cba8:	00800284 	movi	r2,10
 d01cbac:	e0bfb245 	stb	r2,-311(fp)
 d01cbb0:	008340b4 	movhi	r2,3330
 d01cbb4:	10bd2204 	addi	r2,r2,-2936
 d01cbb8:	e0bfb315 	stw	r2,-308(fp)
                            0x11,                            /* Location of Status Register                                   */
                            14,                              /* Location of Speed Status                                      */
                            13,                              /* Location of Duplex Status                                     */
                            10,                              /* Location of Link Status                                       */
                            &marvell_phy_cfg                 /* Function pointer to configure Marvell PHY                     */
                           };
 d01cbbc:	e13fb504 	addi	r4,fp,-300
 d01cbc0:	01801904 	movi	r6,100
 d01cbc4:	000b883a 	mov	r5,zero
 d01cbc8:	d0028800 	call	d002880 <memset>
 d01cbcc:	00c34174 	movhi	r3,3333
 d01cbd0:	18f3ee04 	addi	r3,r3,-12360
 d01cbd4:	18800017 	ldw	r2,0(r3)
 d01cbd8:	e0bfb515 	stw	r2,-300(fp)
 d01cbdc:	18800117 	ldw	r2,4(r3)
 d01cbe0:	e0bfb615 	stw	r2,-296(fp)
 d01cbe4:	18800217 	ldw	r2,8(r3)
 d01cbe8:	e0bfb715 	stw	r2,-292(fp)
 d01cbec:	18800317 	ldw	r2,12(r3)
 d01cbf0:	e0bfb815 	stw	r2,-288(fp)
 d01cbf4:	18800417 	ldw	r2,16(r3)
 d01cbf8:	e0bfb915 	stw	r2,-284(fp)
 d01cbfc:	18800517 	ldw	r2,20(r3)
 d01cc00:	e0bfba15 	stw	r2,-280(fp)
 d01cc04:	18800603 	ldbu	r2,24(r3)
 d01cc08:	e0bfbb05 	stb	r2,-276(fp)
 d01cc0c:	e13fbb44 	addi	r4,fp,-275
 d01cc10:	01800dc4 	movi	r6,55
 d01cc14:	000b883a 	mov	r5,zero
 d01cc18:	d0028800 	call	d002880 <memset>
 d01cc1c:	009410c4 	movi	r2,20547
 d01cc20:	e0bfc915 	stw	r2,-220(fp)
 d01cc24:	00800344 	movi	r2,13
 d01cc28:	e0bfca05 	stb	r2,-216(fp)
 d01cc2c:	00800084 	movi	r2,2
 d01cc30:	e0bfca45 	stb	r2,-215(fp)
 d01cc34:	00800444 	movi	r2,17
 d01cc38:	e0bfca85 	stb	r2,-214(fp)
 d01cc3c:	00800384 	movi	r2,14
 d01cc40:	e0bfcac5 	stb	r2,-213(fp)
 d01cc44:	00800344 	movi	r2,13
 d01cc48:	e0bfcb05 	stb	r2,-212(fp)
 d01cc4c:	00800284 	movi	r2,10
 d01cc50:	e0bfcb45 	stb	r2,-211(fp)
 d01cc54:	008340b4 	movhi	r2,3330
 d01cc58:	10bd2204 	addi	r2,r2,-2936
 d01cc5c:	e0bfcc15 	stw	r2,-208(fp)
                          DP83865_REV,            /* Model Revision Number                            */
                          0x11,                   /* Location of Status Register                      */
                          3,                      /* Location of Speed Status                         */
                          1,                      /* Location of Duplex Status                        */
                          2                       /* Location of Link Status                          */
                         };
 d01cc60:	e13fce04 	addi	r4,fp,-200
 d01cc64:	01801904 	movi	r6,100
 d01cc68:	000b883a 	mov	r5,zero
 d01cc6c:	d0028800 	call	d002880 <memset>
 d01cc70:	00c34174 	movhi	r3,3333
 d01cc74:	18f40204 	addi	r3,r3,-12280
 d01cc78:	18800017 	ldw	r2,0(r3)
 d01cc7c:	e0bfce15 	stw	r2,-200(fp)
 d01cc80:	18800117 	ldw	r2,4(r3)
 d01cc84:	e0bfcf15 	stw	r2,-196(fp)
 d01cc88:	18800217 	ldw	r2,8(r3)
 d01cc8c:	e0bfd015 	stw	r2,-192(fp)
 d01cc90:	18800317 	ldw	r2,12(r3)
 d01cc94:	e0bfd115 	stw	r2,-188(fp)
 d01cc98:	18800403 	ldbu	r2,16(r3)
 d01cc9c:	e0bfd205 	stb	r2,-184(fp)
 d01cca0:	e13fd244 	addi	r4,fp,-183
 d01cca4:	01800fc4 	movi	r6,63
 d01cca8:	000b883a 	mov	r5,zero
 d01ccac:	d0028800 	call	d002880 <memset>
 d01ccb0:	00800234 	movhi	r2,8
 d01ccb4:	108005c4 	addi	r2,r2,23
 d01ccb8:	e0bfe215 	stw	r2,-120(fp)
 d01ccbc:	008001c4 	movi	r2,7
 d01ccc0:	e0bfe305 	stb	r2,-116(fp)
 d01ccc4:	00800284 	movi	r2,10
 d01ccc8:	e0bfe345 	stb	r2,-115(fp)
 d01cccc:	00800444 	movi	r2,17
 d01ccd0:	e0bfe385 	stb	r2,-114(fp)
 d01ccd4:	008000c4 	movi	r2,3
 d01ccd8:	e0bfe3c5 	stb	r2,-113(fp)
 d01ccdc:	00800044 	movi	r2,1
 d01cce0:	e0bfe405 	stb	r2,-112(fp)
 d01cce4:	00800084 	movi	r2,2
 d01cce8:	e0bfe445 	stb	r2,-111(fp)
                           0,                              /* Location of Speed Status    (ignored)                      */
                           0,                              /* Location of Duplex Status   (ignored)                      */
                           0,                              /* Location of Link Status     (ignored)                      */
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
 d01ccec:	e13fe704 	addi	r4,fp,-100
 d01ccf0:	01801904 	movi	r6,100
 d01ccf4:	000b883a 	mov	r5,zero
 d01ccf8:	d0028800 	call	d002880 <memset>
 d01ccfc:	00c34174 	movhi	r3,3333
 d01cd00:	18f41604 	addi	r3,r3,-12200
 d01cd04:	18800017 	ldw	r2,0(r3)
 d01cd08:	e0bfe715 	stw	r2,-100(fp)
 d01cd0c:	18800117 	ldw	r2,4(r3)
 d01cd10:	e0bfe815 	stw	r2,-96(fp)
 d01cd14:	18800217 	ldw	r2,8(r3)
 d01cd18:	e0bfe915 	stw	r2,-92(fp)
 d01cd1c:	18800317 	ldw	r2,12(r3)
 d01cd20:	e0bfea15 	stw	r2,-88(fp)
 d01cd24:	1880040b 	ldhu	r2,16(r3)
 d01cd28:	e0bfeb0d 	sth	r2,-84(fp)
 d01cd2c:	e13feb84 	addi	r4,fp,-82
 d01cd30:	01800f84 	movi	r6,62
 d01cd34:	000b883a 	mov	r5,zero
 d01cd38:	d0028800 	call	d002880 <memset>
 d01cd3c:	00800234 	movhi	r2,8
 d01cd40:	108005c4 	addi	r2,r2,23
 d01cd44:	e0bffb15 	stw	r2,-20(fp)
 d01cd48:	00800244 	movi	r2,9
 d01cd4c:	e0bffc05 	stb	r2,-16(fp)
 d01cd50:	008340b4 	movhi	r2,3330
 d01cd54:	10be0604 	addi	r2,r2,-2024
 d01cd58:	e0bfff15 	stw	r2,-4(fp)
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 d01cd5c:	e13f9c04 	addi	r4,fp,-400
 d01cd60:	d01a8a80 	call	d01a8a8 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 d01cd64:	e13fb504 	addi	r4,fp,-300
 d01cd68:	d01a8a80 	call	d01a8a8 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 d01cd6c:	e13fce04 	addi	r4,fp,-200
 d01cd70:	d01a8a80 	call	d01a8a8 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 d01cd74:	e13fe704 	addi	r4,fp,-100
 d01cd78:	d01a8a80 	call	d01a8a8 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 d01cd7c:	d0a07f03 	ldbu	r2,-32260(gp)
 d01cd80:	10803fcc 	andi	r2,r2,255
}
 d01cd84:	e037883a 	mov	sp,fp
 d01cd88:	dfc00117 	ldw	ra,4(sp)
 d01cd8c:	df000017 	ldw	fp,0(sp)
 d01cd90:	dec00204 	addi	sp,sp,8
 d01cd94:	f800283a 	ret

0d01cd98 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 d01cd98:	defffd04 	addi	sp,sp,-12
 d01cd9c:	dfc00215 	stw	ra,8(sp)
 d01cda0:	df000115 	stw	fp,4(sp)
 d01cda4:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 d01cda8:	d0a07f03 	ldbu	r2,-32260(gp)
 d01cdac:	11403fcc 	andi	r5,r2,255
 d01cdb0:	01034174 	movhi	r4,3333
 d01cdb4:	21342a04 	addi	r4,r4,-12120
 d01cdb8:	d01a5480 	call	d01a548 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 d01cdbc:	e03fff05 	stb	zero,-4(fp)
 d01cdc0:	00006606 	br	d01cf5c <alt_tse_phy_print_profile+0x1c4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 d01cdc4:	e17fff07 	ldb	r5,-4(fp)
 d01cdc8:	01034174 	movhi	r4,3333
 d01cdcc:	21343904 	addi	r4,r4,-12060
 d01cdd0:	d01a5480 	call	d01a548 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 d01cdd4:	e0bfff07 	ldb	r2,-4(fp)
 d01cdd8:	00c341b4 	movhi	r3,3334
 d01cddc:	18f18404 	addi	r3,r3,-14832
 d01cde0:	1085883a 	add	r2,r2,r2
 d01cde4:	1085883a 	add	r2,r2,r2
 d01cde8:	10c5883a 	add	r2,r2,r3
 d01cdec:	10800017 	ldw	r2,0(r2)
 d01cdf0:	100b883a 	mov	r5,r2
 d01cdf4:	01034174 	movhi	r4,3333
 d01cdf8:	21343e04 	addi	r4,r4,-12040
 d01cdfc:	d01a5480 	call	d01a548 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 d01ce00:	e0bfff07 	ldb	r2,-4(fp)
 d01ce04:	00c341b4 	movhi	r3,3334
 d01ce08:	18f18404 	addi	r3,r3,-14832
 d01ce0c:	1085883a 	add	r2,r2,r2
 d01ce10:	1085883a 	add	r2,r2,r2
 d01ce14:	10c5883a 	add	r2,r2,r3
 d01ce18:	10800017 	ldw	r2,0(r2)
 d01ce1c:	10801417 	ldw	r2,80(r2)
 d01ce20:	100b883a 	mov	r5,r2
 d01ce24:	01034174 	movhi	r4,3333
 d01ce28:	21344404 	addi	r4,r4,-12016
 d01ce2c:	d01a5480 	call	d01a548 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 d01ce30:	e0bfff07 	ldb	r2,-4(fp)
 d01ce34:	00c341b4 	movhi	r3,3334
 d01ce38:	18f18404 	addi	r3,r3,-14832
 d01ce3c:	1085883a 	add	r2,r2,r2
 d01ce40:	1085883a 	add	r2,r2,r2
 d01ce44:	10c5883a 	add	r2,r2,r3
 d01ce48:	10800017 	ldw	r2,0(r2)
 d01ce4c:	10801503 	ldbu	r2,84(r2)
 d01ce50:	11403fcc 	andi	r5,r2,255
 d01ce54:	01034174 	movhi	r4,3333
 d01ce58:	21344b04 	addi	r4,r4,-11988
 d01ce5c:	d01a5480 	call	d01a548 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 d01ce60:	e0bfff07 	ldb	r2,-4(fp)
 d01ce64:	00c341b4 	movhi	r3,3334
 d01ce68:	18f18404 	addi	r3,r3,-14832
 d01ce6c:	1085883a 	add	r2,r2,r2
 d01ce70:	1085883a 	add	r2,r2,r2
 d01ce74:	10c5883a 	add	r2,r2,r3
 d01ce78:	10800017 	ldw	r2,0(r2)
 d01ce7c:	10801543 	ldbu	r2,85(r2)
 d01ce80:	11403fcc 	andi	r5,r2,255
 d01ce84:	01034174 	movhi	r4,3333
 d01ce88:	21345204 	addi	r4,r4,-11960
 d01ce8c:	d01a5480 	call	d01a548 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 d01ce90:	e0bfff07 	ldb	r2,-4(fp)
 d01ce94:	00c341b4 	movhi	r3,3334
 d01ce98:	18f18404 	addi	r3,r3,-14832
 d01ce9c:	1085883a 	add	r2,r2,r2
 d01cea0:	1085883a 	add	r2,r2,r2
 d01cea4:	10c5883a 	add	r2,r2,r3
 d01cea8:	10800017 	ldw	r2,0(r2)
 d01ceac:	10801583 	ldbu	r2,86(r2)
 d01ceb0:	11403fcc 	andi	r5,r2,255
 d01ceb4:	01034174 	movhi	r4,3333
 d01ceb8:	21345904 	addi	r4,r4,-11932
 d01cebc:	d01a5480 	call	d01a548 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 d01cec0:	e0bfff07 	ldb	r2,-4(fp)
 d01cec4:	00c341b4 	movhi	r3,3334
 d01cec8:	18f18404 	addi	r3,r3,-14832
 d01cecc:	1085883a 	add	r2,r2,r2
 d01ced0:	1085883a 	add	r2,r2,r2
 d01ced4:	10c5883a 	add	r2,r2,r3
 d01ced8:	10800017 	ldw	r2,0(r2)
 d01cedc:	108015c3 	ldbu	r2,87(r2)
 d01cee0:	11403fcc 	andi	r5,r2,255
 d01cee4:	01034174 	movhi	r4,3333
 d01cee8:	21346004 	addi	r4,r4,-11904
 d01ceec:	d01a5480 	call	d01a548 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 d01cef0:	e0bfff07 	ldb	r2,-4(fp)
 d01cef4:	00c341b4 	movhi	r3,3334
 d01cef8:	18f18404 	addi	r3,r3,-14832
 d01cefc:	1085883a 	add	r2,r2,r2
 d01cf00:	1085883a 	add	r2,r2,r2
 d01cf04:	10c5883a 	add	r2,r2,r3
 d01cf08:	10800017 	ldw	r2,0(r2)
 d01cf0c:	10801603 	ldbu	r2,88(r2)
 d01cf10:	11403fcc 	andi	r5,r2,255
 d01cf14:	01034174 	movhi	r4,3333
 d01cf18:	21346604 	addi	r4,r4,-11880
 d01cf1c:	d01a5480 	call	d01a548 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 d01cf20:	e0bfff07 	ldb	r2,-4(fp)
 d01cf24:	00c341b4 	movhi	r3,3334
 d01cf28:	18f18404 	addi	r3,r3,-14832
 d01cf2c:	1085883a 	add	r2,r2,r2
 d01cf30:	1085883a 	add	r2,r2,r2
 d01cf34:	10c5883a 	add	r2,r2,r3
 d01cf38:	10800017 	ldw	r2,0(r2)
 d01cf3c:	10801643 	ldbu	r2,89(r2)
 d01cf40:	11403fcc 	andi	r5,r2,255
 d01cf44:	01034174 	movhi	r4,3333
 d01cf48:	21346c04 	addi	r4,r4,-11856
 d01cf4c:	d01a5480 	call	d01a548 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 d01cf50:	e0bfff03 	ldbu	r2,-4(fp)
 d01cf54:	10800044 	addi	r2,r2,1
 d01cf58:	e0bfff05 	stb	r2,-4(fp)
 d01cf5c:	e0bfff07 	ldb	r2,-4(fp)
 d01cf60:	d0e07f03 	ldbu	r3,-32260(gp)
 d01cf64:	18c03fcc 	andi	r3,r3,255
 d01cf68:	10ff9616 	blt	r2,r3,d01cdc4 <alt_tse_phy_print_profile+0x2c>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 d01cf6c:	d0a07f03 	ldbu	r2,-32260(gp)
 d01cf70:	10803fcc 	andi	r2,r2,255
}
 d01cf74:	e037883a 	mov	sp,fp
 d01cf78:	dfc00117 	ldw	ra,4(sp)
 d01cf7c:	df000017 	ldw	fp,0(sp)
 d01cf80:	dec00204 	addi	sp,sp,8
 d01cf84:	f800283a 	ret

0d01cf88 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 d01cf88:	defff104 	addi	sp,sp,-60
 d01cf8c:	dfc00e15 	stw	ra,56(sp)
 d01cf90:	df000d15 	stw	fp,52(sp)
 d01cf94:	df000d04 	addi	fp,sp,52
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 d01cf98:	e03ff515 	stw	zero,-44(fp)
    alt_tse_mac_info *pmac_info = 0;
 d01cf9c:	e03ff415 	stw	zero,-48(fp)
    alt_tse_system_info *psys = 0;
 d01cfa0:	e03ff315 	stw	zero,-52(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 d01cfa4:	d0207f45 	stb	zero,-32259(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 d01cfa8:	e03ff645 	stb	zero,-39(fp)
 d01cfac:	0001ae06 	br	d01d668 <alt_tse_mac_group_init+0x6e0>
        psys = &tse_mac_device[i];
 d01cfb0:	e0bff647 	ldb	r2,-39(fp)
 d01cfb4:	10801224 	muli	r2,r2,72
 d01cfb8:	1007883a 	mov	r3,r2
 d01cfbc:	00834174 	movhi	r2,3333
 d01cfc0:	10823004 	addi	r2,r2,2240
 d01cfc4:	1885883a 	add	r2,r3,r2
 d01cfc8:	e0bff315 	stw	r2,-52(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 d01cfcc:	e0bff317 	ldw	r2,-52(fp)
 d01cfd0:	10800517 	ldw	r2,20(r2)
 d01cfd4:	1005003a 	cmpeq	r2,r2,zero
 d01cfd8:	1001a01e 	bne	r2,zero,d01d65c <alt_tse_mac_group_init+0x6d4>
 d01cfdc:	e0bff317 	ldw	r2,-52(fp)
 d01cfe0:	10800617 	ldw	r2,24(r2)
 d01cfe4:	1005003a 	cmpeq	r2,r2,zero
 d01cfe8:	10019c1e 	bne	r2,zero,d01d65c <alt_tse_mac_group_init+0x6d4>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 d01cfec:	d0a07f43 	ldbu	r2,-32259(gp)
 d01cff0:	11403fcc 	andi	r5,r2,255
 d01cff4:	e0bff317 	ldw	r2,-52(fp)
 d01cff8:	10800017 	ldw	r2,0(r2)
 d01cffc:	100d883a 	mov	r6,r2
 d01d000:	01034174 	movhi	r4,3333
 d01d004:	21347204 	addi	r4,r4,-11832
 d01d008:	d0029980 	call	d002998 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 d01d00c:	01000504 	movi	r4,20
 d01d010:	d049ec00 	call	d049ec0 <malloc>
 d01d014:	e0bff515 	stw	r2,-44(fp)
            if(!pmac_group) {
 d01d018:	e0bff517 	ldw	r2,-44(fp)
 d01d01c:	1004c03a 	cmpne	r2,r2,zero
 d01d020:	1000081e 	bne	r2,zero,d01d044 <alt_tse_mac_group_init+0xbc>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 d01d024:	d0a07f43 	ldbu	r2,-32259(gp)
 d01d028:	11403fcc 	andi	r5,r2,255
 d01d02c:	01034174 	movhi	r4,3333
 d01d030:	21347e04 	addi	r4,r4,-11784
 d01d034:	d0029980 	call	d002998 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 d01d038:	00bfffc4 	movi	r2,-1
 d01d03c:	e0bfff15 	stw	r2,-4(fp)
 d01d040:	00018e06 	br	d01d67c <alt_tse_mac_group_init+0x6f4>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 d01d044:	e0bff317 	ldw	r2,-52(fp)
 d01d048:	108002c3 	ldbu	r2,11(r2)
 d01d04c:	10803fcc 	andi	r2,r2,255
 d01d050:	1005003a 	cmpeq	r2,r2,zero
 d01d054:	1000111e 	bne	r2,zero,d01d09c <alt_tse_mac_group_init+0x114>
                pmac_group->channel = psys->tse_num_of_channel;
 d01d058:	e0bff317 	ldw	r2,-52(fp)
 d01d05c:	10c00303 	ldbu	r3,12(r2)
 d01d060:	e0bff517 	ldw	r2,-44(fp)
 d01d064:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 d01d068:	01034174 	movhi	r4,3333
 d01d06c:	21348c04 	addi	r4,r4,-11728
 d01d070:	d01a5480 	call	d01a548 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 d01d074:	e0bff517 	ldw	r2,-44(fp)
 d01d078:	10800003 	ldbu	r2,0(r2)
 d01d07c:	11403fcc 	andi	r5,r2,255
 d01d080:	01034174 	movhi	r4,3333
 d01d084:	21349704 	addi	r4,r4,-11684
 d01d088:	d01a5480 	call	d01a548 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 d01d08c:	01034174 	movhi	r4,3333
 d01d090:	2134a204 	addi	r4,r4,-11640
 d01d094:	d01a5480 	call	d01a548 <no_printf>
 d01d098:	00001f06 	br	d01d118 <alt_tse_mac_group_init+0x190>
            }
            else if(psys->tse_mdio_shared) {
 d01d09c:	e0bff317 	ldw	r2,-52(fp)
 d01d0a0:	10800343 	ldbu	r2,13(r2)
 d01d0a4:	10803fcc 	andi	r2,r2,255
 d01d0a8:	1005003a 	cmpeq	r2,r2,zero
 d01d0ac:	1000111e 	bne	r2,zero,d01d0f4 <alt_tse_mac_group_init+0x16c>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 d01d0b0:	e0bff317 	ldw	r2,-52(fp)
 d01d0b4:	10c00383 	ldbu	r3,14(r2)
 d01d0b8:	e0bff517 	ldw	r2,-44(fp)
 d01d0bc:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 d01d0c0:	01034174 	movhi	r4,3333
 d01d0c4:	2134ad04 	addi	r4,r4,-11596
 d01d0c8:	d01a5480 	call	d01a548 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 d01d0cc:	01034174 	movhi	r4,3333
 d01d0d0:	2134a204 	addi	r4,r4,-11640
 d01d0d4:	d01a5480 	call	d01a548 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 d01d0d8:	e0bff517 	ldw	r2,-44(fp)
 d01d0dc:	10800003 	ldbu	r2,0(r2)
 d01d0e0:	11403fcc 	andi	r5,r2,255
 d01d0e4:	01034174 	movhi	r4,3333
 d01d0e8:	2134b804 	addi	r4,r4,-11552
 d01d0ec:	d01a5480 	call	d01a548 <no_printf>
 d01d0f0:	00000906 	br	d01d118 <alt_tse_mac_group_init+0x190>
            }
            else {
                pmac_group->channel = 1;
 d01d0f4:	e0fff517 	ldw	r3,-44(fp)
 d01d0f8:	00800044 	movi	r2,1
 d01d0fc:	18800005 	stb	r2,0(r3)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 d01d100:	01034174 	movhi	r4,3333
 d01d104:	2134ad04 	addi	r4,r4,-11596
 d01d108:	d01a5480 	call	d01a548 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 d01d10c:	01034174 	movhi	r4,3333
 d01d110:	2134c304 	addi	r4,r4,-11508
 d01d114:	d01a5480 	call	d01a548 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 d01d118:	e03ff605 	stb	zero,-40(fp)
 d01d11c:	00013806 	br	d01d600 <alt_tse_mac_group_init+0x678>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 d01d120:	01000404 	movi	r4,16
 d01d124:	d049ec00 	call	d049ec0 <malloc>
 d01d128:	e0bff415 	stw	r2,-48(fp)
                if(!pmac_info) {
 d01d12c:	e0bff417 	ldw	r2,-48(fp)
 d01d130:	1004c03a 	cmpne	r2,r2,zero
 d01d134:	1000091e 	bne	r2,zero,d01d15c <alt_tse_mac_group_init+0x1d4>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 d01d138:	d0a07f43 	ldbu	r2,-32259(gp)
 d01d13c:	11403fcc 	andi	r5,r2,255
 d01d140:	e1bff607 	ldb	r6,-40(fp)
 d01d144:	01034174 	movhi	r4,3333
 d01d148:	2134ce04 	addi	r4,r4,-11464
 d01d14c:	d0029980 	call	d002998 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 d01d150:	00ffffc4 	movi	r3,-1
 d01d154:	e0ffff15 	stw	r3,-4(fp)
 d01d158:	00014806 	br	d01d67c <alt_tse_mac_group_init+0x6f4>
                }
                
                pmac_info->pmac_group = pmac_group;
 d01d15c:	e0fff417 	ldw	r3,-48(fp)
 d01d160:	e0bff517 	ldw	r2,-44(fp)
 d01d164:	18800315 	stw	r2,12(r3)
                
                pmac_info->pphy_info = 0;
 d01d168:	e0bff417 	ldw	r2,-48(fp)
 d01d16c:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 d01d170:	e0fff647 	ldb	r3,-39(fp)
 d01d174:	e0bff607 	ldb	r2,-40(fp)
 d01d178:	1885883a 	add	r2,r3,r2
 d01d17c:	10801224 	muli	r2,r2,72
 d01d180:	1007883a 	mov	r3,r2
 d01d184:	00834174 	movhi	r2,3333
 d01d188:	10823004 	addi	r2,r2,2240
 d01d18c:	1887883a 	add	r3,r3,r2
 d01d190:	e0bff417 	ldw	r2,-48(fp)
 d01d194:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 d01d198:	e0bff417 	ldw	r2,-48(fp)
 d01d19c:	10800217 	ldw	r2,8(r2)
 d01d1a0:	10800517 	ldw	r2,20(r2)
 d01d1a4:	1005003a 	cmpeq	r2,r2,zero
 d01d1a8:	1000051e 	bne	r2,zero,d01d1c0 <alt_tse_mac_group_init+0x238>
 d01d1ac:	e0bff417 	ldw	r2,-48(fp)
 d01d1b0:	10800217 	ldw	r2,8(r2)
 d01d1b4:	10800617 	ldw	r2,24(r2)
 d01d1b8:	1004c03a 	cmpne	r2,r2,zero
 d01d1bc:	1000091e 	bne	r2,zero,d01d1e4 <alt_tse_mac_group_init+0x25c>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 d01d1c0:	e0bff647 	ldb	r2,-39(fp)
 d01d1c4:	e0fff607 	ldb	r3,-40(fp)
 d01d1c8:	10cb883a 	add	r5,r2,r3
 d01d1cc:	01034174 	movhi	r4,3333
 d01d1d0:	2134e004 	addi	r4,r4,-11392
 d01d1d4:	d0029980 	call	d002998 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 d01d1d8:	00bfffc4 	movi	r2,-1
 d01d1dc:	e0bfff15 	stw	r2,-4(fp)
 d01d1e0:	00012606 	br	d01d67c <alt_tse_mac_group_init+0x6f4>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 d01d1e4:	e0bff417 	ldw	r2,-48(fp)
 d01d1e8:	10800217 	ldw	r2,8(r2)
 d01d1ec:	10800243 	ldbu	r2,9(r2)
 d01d1f0:	10803fcc 	andi	r2,r2,255
 d01d1f4:	1005003a 	cmpeq	r2,r2,zero
 d01d1f8:	10000e1e 	bne	r2,zero,d01d234 <alt_tse_mac_group_init+0x2ac>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 d01d1fc:	e0bff417 	ldw	r2,-48(fp)
 d01d200:	10800217 	ldw	r2,8(r2)
 d01d204:	10800283 	ldbu	r2,10(r2)
 d01d208:	10803fcc 	andi	r2,r2,255
 d01d20c:	1005003a 	cmpeq	r2,r2,zero
 d01d210:	1000041e 	bne	r2,zero,d01d224 <alt_tse_mac_group_init+0x29c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 d01d214:	e0fff417 	ldw	r3,-48(fp)
 d01d218:	00800084 	movi	r2,2
 d01d21c:	18800005 	stb	r2,0(r3)
 d01d220:	00000606 	br	d01d23c <alt_tse_mac_group_init+0x2b4>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 d01d224:	e0fff417 	ldw	r3,-48(fp)
 d01d228:	00800044 	movi	r2,1
 d01d22c:	18800005 	stb	r2,0(r3)
 d01d230:	00000206 	br	d01d23c <alt_tse_mac_group_init+0x2b4>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 d01d234:	e0bff417 	ldw	r2,-48(fp)
 d01d238:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 d01d23c:	e0bff417 	ldw	r2,-48(fp)
 d01d240:	10800217 	ldw	r2,8(r2)
 d01d244:	10800343 	ldbu	r2,13(r2)
 d01d248:	10803fcc 	andi	r2,r2,255
 d01d24c:	1005003a 	cmpeq	r2,r2,zero
 d01d250:	10006d1e 	bne	r2,zero,d01d408 <alt_tse_mac_group_init+0x480>
 d01d254:	e0bff417 	ldw	r2,-48(fp)
 d01d258:	10800217 	ldw	r2,8(r2)
 d01d25c:	108002c3 	ldbu	r2,11(r2)
 d01d260:	10803fcc 	andi	r2,r2,255
 d01d264:	1004c03a 	cmpne	r2,r2,zero
 d01d268:	1000671e 	bne	r2,zero,d01d408 <alt_tse_mac_group_init+0x480>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 d01d26c:	e17ff607 	ldb	r5,-40(fp)
 d01d270:	e0bff417 	ldw	r2,-48(fp)
 d01d274:	10800217 	ldw	r2,8(r2)
 d01d278:	10800017 	ldw	r2,0(r2)
 d01d27c:	100d883a 	mov	r6,r2
 d01d280:	01034174 	movhi	r4,3333
 d01d284:	2134ef04 	addi	r4,r4,-11332
 d01d288:	d01a5480 	call	d01a548 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 d01d28c:	e17ff607 	ldb	r5,-40(fp)
 d01d290:	e0fff647 	ldb	r3,-39(fp)
 d01d294:	e0bff607 	ldb	r2,-40(fp)
 d01d298:	188d883a 	add	r6,r3,r2
 d01d29c:	01034174 	movhi	r4,3333
 d01d2a0:	2134fb04 	addi	r4,r4,-11284
 d01d2a4:	d01a5480 	call	d01a548 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 d01d2a8:	e0bff417 	ldw	r2,-48(fp)
 d01d2ac:	10800003 	ldbu	r2,0(r2)
 d01d2b0:	10803fcc 	andi	r2,r2,255
 d01d2b4:	e0bffe15 	stw	r2,-8(fp)
 d01d2b8:	e0fffe17 	ldw	r3,-8(fp)
 d01d2bc:	18800060 	cmpeqi	r2,r3,1
 d01d2c0:	10000e1e 	bne	r2,zero,d01d2fc <alt_tse_mac_group_init+0x374>
 d01d2c4:	e0fffe17 	ldw	r3,-8(fp)
 d01d2c8:	188000a0 	cmpeqi	r2,r3,2
 d01d2cc:	1000041e 	bne	r2,zero,d01d2e0 <alt_tse_mac_group_init+0x358>
 d01d2d0:	e0fffe17 	ldw	r3,-8(fp)
 d01d2d4:	1805003a 	cmpeq	r2,r3,zero
 d01d2d8:	10000f1e 	bne	r2,zero,d01d318 <alt_tse_mac_group_init+0x390>
 d01d2dc:	00001506 	br	d01d334 <alt_tse_mac_group_init+0x3ac>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 d01d2e0:	e17ff607 	ldb	r5,-40(fp)
 d01d2e4:	01034174 	movhi	r4,3333
 d01d2e8:	21350a04 	addi	r4,r4,-11224
 d01d2ec:	01834174 	movhi	r6,3333
 d01d2f0:	31b51504 	addi	r6,r6,-11180
 d01d2f4:	d01a5480 	call	d01a548 <no_printf>
                            break;
 d01d2f8:	00001406 	br	d01d34c <alt_tse_mac_group_init+0x3c4>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 d01d2fc:	e17ff607 	ldb	r5,-40(fp)
 d01d300:	01034174 	movhi	r4,3333
 d01d304:	21350a04 	addi	r4,r4,-11224
 d01d308:	01834174 	movhi	r6,3333
 d01d30c:	31b51a04 	addi	r6,r6,-11160
 d01d310:	d01a5480 	call	d01a548 <no_printf>
                            break;
 d01d314:	00000d06 	br	d01d34c <alt_tse_mac_group_init+0x3c4>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 d01d318:	e17ff607 	ldb	r5,-40(fp)
 d01d31c:	01034174 	movhi	r4,3333
 d01d320:	21350a04 	addi	r4,r4,-11224
 d01d324:	01834174 	movhi	r6,3333
 d01d328:	31b52004 	addi	r6,r6,-11136
 d01d32c:	d01a5480 	call	d01a548 <no_printf>
                            break;
 d01d330:	00000606 	br	d01d34c <alt_tse_mac_group_init+0x3c4>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 d01d334:	e17ff607 	ldb	r5,-40(fp)
 d01d338:	01034174 	movhi	r4,3333
 d01d33c:	21350a04 	addi	r4,r4,-11224
 d01d340:	01834174 	movhi	r6,3333
 d01d344:	31b32104 	addi	r6,r6,-13180
 d01d348:	d01a5480 	call	d01a548 <no_printf>
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 d01d34c:	e0bff417 	ldw	r2,-48(fp)
 d01d350:	10800217 	ldw	r2,8(r2)
 d01d354:	108003c3 	ldbu	r2,15(r2)
 d01d358:	10803fcc 	andi	r2,r2,255
 d01d35c:	1005003a 	cmpeq	r2,r2,zero
 d01d360:	10009c1e 	bne	r2,zero,d01d5d4 <alt_tse_mac_group_init+0x64c>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 d01d364:	e0bff607 	ldb	r2,-40(fp)
 d01d368:	e0bffd15 	stw	r2,-12(fp)
 d01d36c:	e0bff417 	ldw	r2,-48(fp)
 d01d370:	10800217 	ldw	r2,8(r2)
 d01d374:	108003c3 	ldbu	r2,15(r2)
 d01d378:	10803fcc 	andi	r2,r2,255
 d01d37c:	1005003a 	cmpeq	r2,r2,zero
 d01d380:	1000041e 	bne	r2,zero,d01d394 <alt_tse_mac_group_init+0x40c>
 d01d384:	00c34174 	movhi	r3,3333
 d01d388:	18f52704 	addi	r3,r3,-11108
 d01d38c:	e0fffc15 	stw	r3,-16(fp)
 d01d390:	00000306 	br	d01d3a0 <alt_tse_mac_group_init+0x418>
 d01d394:	00834174 	movhi	r2,3333
 d01d398:	10b52804 	addi	r2,r2,-11104
 d01d39c:	e0bffc15 	stw	r2,-16(fp)
 d01d3a0:	01034174 	movhi	r4,3333
 d01d3a4:	21352904 	addi	r4,r4,-11100
 d01d3a8:	e17ffd17 	ldw	r5,-12(fp)
 d01d3ac:	e1bffc17 	ldw	r6,-16(fp)
 d01d3b0:	d01a5480 	call	d01a548 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 d01d3b4:	e0fff607 	ldb	r3,-40(fp)
 d01d3b8:	e0fffb15 	stw	r3,-20(fp)
 d01d3bc:	e0bff417 	ldw	r2,-48(fp)
 d01d3c0:	10800217 	ldw	r2,8(r2)
 d01d3c4:	10800403 	ldbu	r2,16(r2)
 d01d3c8:	10803fcc 	andi	r2,r2,255
 d01d3cc:	1005003a 	cmpeq	r2,r2,zero
 d01d3d0:	1000041e 	bne	r2,zero,d01d3e4 <alt_tse_mac_group_init+0x45c>
 d01d3d4:	00834174 	movhi	r2,3333
 d01d3d8:	10b52704 	addi	r2,r2,-11108
 d01d3dc:	e0bffa15 	stw	r2,-24(fp)
 d01d3e0:	00000306 	br	d01d3f0 <alt_tse_mac_group_init+0x468>
 d01d3e4:	00c34174 	movhi	r3,3333
 d01d3e8:	18f52804 	addi	r3,r3,-11104
 d01d3ec:	e0fffa15 	stw	r3,-24(fp)
 d01d3f0:	01034174 	movhi	r4,3333
 d01d3f4:	21353404 	addi	r4,r4,-11056
 d01d3f8:	e17ffb17 	ldw	r5,-20(fp)
 d01d3fc:	e1bffa17 	ldw	r6,-24(fp)
 d01d400:	d01a5480 	call	d01a548 <no_printf>
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 d01d404:	00007306 	br	d01d5d4 <alt_tse_mac_group_init+0x64c>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 d01d408:	e0bff607 	ldb	r2,-40(fp)
 d01d40c:	1004c03a 	cmpne	r2,r2,zero
 d01d410:	10004d1e 	bne	r2,zero,d01d548 <alt_tse_mac_group_init+0x5c0>
	                    switch(pmac_info->mac_type) {
 d01d414:	e0bff417 	ldw	r2,-48(fp)
 d01d418:	10800003 	ldbu	r2,0(r2)
 d01d41c:	10803fcc 	andi	r2,r2,255
 d01d420:	e0bff915 	stw	r2,-28(fp)
 d01d424:	e0fff917 	ldw	r3,-28(fp)
 d01d428:	18800060 	cmpeqi	r2,r3,1
 d01d42c:	10000d1e 	bne	r2,zero,d01d464 <alt_tse_mac_group_init+0x4dc>
 d01d430:	e0fff917 	ldw	r3,-28(fp)
 d01d434:	188000a0 	cmpeqi	r2,r3,2
 d01d438:	1000041e 	bne	r2,zero,d01d44c <alt_tse_mac_group_init+0x4c4>
 d01d43c:	e0fff917 	ldw	r3,-28(fp)
 d01d440:	1805003a 	cmpeq	r2,r3,zero
 d01d444:	10000d1e 	bne	r2,zero,d01d47c <alt_tse_mac_group_init+0x4f4>
 d01d448:	00001206 	br	d01d494 <alt_tse_mac_group_init+0x50c>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 d01d44c:	01034174 	movhi	r4,3333
 d01d450:	21353f04 	addi	r4,r4,-11012
 d01d454:	01434174 	movhi	r5,3333
 d01d458:	29751504 	addi	r5,r5,-11180
 d01d45c:	d01a5480 	call	d01a548 <no_printf>
	                            break;
 d01d460:	00001106 	br	d01d4a8 <alt_tse_mac_group_init+0x520>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 d01d464:	01034174 	movhi	r4,3333
 d01d468:	21353f04 	addi	r4,r4,-11012
 d01d46c:	01434174 	movhi	r5,3333
 d01d470:	29751a04 	addi	r5,r5,-11160
 d01d474:	d01a5480 	call	d01a548 <no_printf>
	                            break;
 d01d478:	00000b06 	br	d01d4a8 <alt_tse_mac_group_init+0x520>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 d01d47c:	01034174 	movhi	r4,3333
 d01d480:	21353f04 	addi	r4,r4,-11012
 d01d484:	01434174 	movhi	r5,3333
 d01d488:	29752004 	addi	r5,r5,-11136
 d01d48c:	d01a5480 	call	d01a548 <no_printf>
	                            break;
 d01d490:	00000506 	br	d01d4a8 <alt_tse_mac_group_init+0x520>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 d01d494:	01034174 	movhi	r4,3333
 d01d498:	21353f04 	addi	r4,r4,-11012
 d01d49c:	01434174 	movhi	r5,3333
 d01d4a0:	29732104 	addi	r5,r5,-13180
 d01d4a4:	d01a5480 	call	d01a548 <no_printf>
	                    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 d01d4a8:	e0bff417 	ldw	r2,-48(fp)
 d01d4ac:	10800217 	ldw	r2,8(r2)
 d01d4b0:	108003c3 	ldbu	r2,15(r2)
 d01d4b4:	10803fcc 	andi	r2,r2,255
 d01d4b8:	1005003a 	cmpeq	r2,r2,zero
 d01d4bc:	1000221e 	bne	r2,zero,d01d548 <alt_tse_mac_group_init+0x5c0>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 d01d4c0:	e0bff417 	ldw	r2,-48(fp)
 d01d4c4:	10800217 	ldw	r2,8(r2)
 d01d4c8:	108003c3 	ldbu	r2,15(r2)
 d01d4cc:	10803fcc 	andi	r2,r2,255
 d01d4d0:	1005003a 	cmpeq	r2,r2,zero
 d01d4d4:	1000041e 	bne	r2,zero,d01d4e8 <alt_tse_mac_group_init+0x560>
 d01d4d8:	00834174 	movhi	r2,3333
 d01d4dc:	10b52704 	addi	r2,r2,-11108
 d01d4e0:	e0bff815 	stw	r2,-32(fp)
 d01d4e4:	00000306 	br	d01d4f4 <alt_tse_mac_group_init+0x56c>
 d01d4e8:	00c34174 	movhi	r3,3333
 d01d4ec:	18f52804 	addi	r3,r3,-11104
 d01d4f0:	e0fff815 	stw	r3,-32(fp)
 d01d4f4:	01034174 	movhi	r4,3333
 d01d4f8:	21354a04 	addi	r4,r4,-10968
 d01d4fc:	e17ff817 	ldw	r5,-32(fp)
 d01d500:	d01a5480 	call	d01a548 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 d01d504:	e0bff417 	ldw	r2,-48(fp)
 d01d508:	10800217 	ldw	r2,8(r2)
 d01d50c:	10800403 	ldbu	r2,16(r2)
 d01d510:	10803fcc 	andi	r2,r2,255
 d01d514:	1005003a 	cmpeq	r2,r2,zero
 d01d518:	1000041e 	bne	r2,zero,d01d52c <alt_tse_mac_group_init+0x5a4>
 d01d51c:	00834174 	movhi	r2,3333
 d01d520:	10b52704 	addi	r2,r2,-11108
 d01d524:	e0bff715 	stw	r2,-36(fp)
 d01d528:	00000306 	br	d01d538 <alt_tse_mac_group_init+0x5b0>
 d01d52c:	00c34174 	movhi	r3,3333
 d01d530:	18f52804 	addi	r3,r3,-11104
 d01d534:	e0fff715 	stw	r3,-36(fp)
 d01d538:	01034174 	movhi	r4,3333
 d01d53c:	21355504 	addi	r4,r4,-10924
 d01d540:	e17ff717 	ldw	r5,-36(fp)
 d01d544:	d01a5480 	call	d01a548 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 d01d548:	e0bff417 	ldw	r2,-48(fp)
 d01d54c:	10800217 	ldw	r2,8(r2)
 d01d550:	108002c3 	ldbu	r2,11(r2)
 d01d554:	10803fcc 	andi	r2,r2,255
 d01d558:	1005003a 	cmpeq	r2,r2,zero
 d01d55c:	1000101e 	bne	r2,zero,d01d5a0 <alt_tse_mac_group_init+0x618>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 d01d560:	e17ff607 	ldb	r5,-40(fp)
 d01d564:	e0bff417 	ldw	r2,-48(fp)
 d01d568:	10800217 	ldw	r2,8(r2)
 d01d56c:	10800017 	ldw	r2,0(r2)
 d01d570:	100d883a 	mov	r6,r2
 d01d574:	01034174 	movhi	r4,3333
 d01d578:	21356004 	addi	r4,r4,-10880
 d01d57c:	d01a5480 	call	d01a548 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 d01d580:	e17ff607 	ldb	r5,-40(fp)
 d01d584:	e0fff647 	ldb	r3,-39(fp)
 d01d588:	e0bff607 	ldb	r2,-40(fp)
 d01d58c:	188d883a 	add	r6,r3,r2
 d01d590:	01034174 	movhi	r4,3333
 d01d594:	21356c04 	addi	r4,r4,-10832
 d01d598:	d01a5480 	call	d01a548 <no_printf>
 d01d59c:	00000d06 	br	d01d5d4 <alt_tse_mac_group_init+0x64c>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 d01d5a0:	e0bff417 	ldw	r2,-48(fp)
 d01d5a4:	10800217 	ldw	r2,8(r2)
 d01d5a8:	10800017 	ldw	r2,0(r2)
 d01d5ac:	100b883a 	mov	r5,r2
 d01d5b0:	01034174 	movhi	r4,3333
 d01d5b4:	21357b04 	addi	r4,r4,-10772
 d01d5b8:	d01a5480 	call	d01a548 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 d01d5bc:	e0fff647 	ldb	r3,-39(fp)
 d01d5c0:	e0bff607 	ldb	r2,-40(fp)
 d01d5c4:	188b883a 	add	r5,r3,r2
 d01d5c8:	01034174 	movhi	r4,3333
 d01d5cc:	21358704 	addi	r4,r4,-10724
 d01d5d0:	d01a5480 	call	d01a548 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 d01d5d4:	e0bff607 	ldb	r2,-40(fp)
 d01d5d8:	e0fff517 	ldw	r3,-44(fp)
 d01d5dc:	1085883a 	add	r2,r2,r2
 d01d5e0:	1085883a 	add	r2,r2,r2
 d01d5e4:	10c5883a 	add	r2,r2,r3
 d01d5e8:	10c00104 	addi	r3,r2,4
 d01d5ec:	e0bff417 	ldw	r2,-48(fp)
 d01d5f0:	18800015 	stw	r2,0(r3)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 d01d5f4:	e0bff603 	ldbu	r2,-40(fp)
 d01d5f8:	10800044 	addi	r2,r2,1
 d01d5fc:	e0bff605 	stb	r2,-40(fp)
 d01d600:	e0fff607 	ldb	r3,-40(fp)
 d01d604:	e0bff517 	ldw	r2,-44(fp)
 d01d608:	10800003 	ldbu	r2,0(r2)
 d01d60c:	10803fcc 	andi	r2,r2,255
 d01d610:	18bec316 	blt	r3,r2,d01d120 <alt_tse_mac_group_init+0x198>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 d01d614:	d0a07f43 	ldbu	r2,-32259(gp)
 d01d618:	10803fcc 	andi	r2,r2,255
 d01d61c:	00c341b4 	movhi	r3,3334
 d01d620:	18f18004 	addi	r3,r3,-14848
 d01d624:	1085883a 	add	r2,r2,r2
 d01d628:	1085883a 	add	r2,r2,r2
 d01d62c:	10c7883a 	add	r3,r2,r3
 d01d630:	e0bff517 	ldw	r2,-44(fp)
 d01d634:	18800015 	stw	r2,0(r3)
            
            mac_group_count++;
 d01d638:	d0a07f43 	ldbu	r2,-32259(gp)
 d01d63c:	10800044 	addi	r2,r2,1
 d01d640:	d0a07f45 	stb	r2,-32259(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 d01d644:	e0bff517 	ldw	r2,-44(fp)
 d01d648:	10c00003 	ldbu	r3,0(r2)
 d01d64c:	e0bff643 	ldbu	r2,-39(fp)
 d01d650:	1885883a 	add	r2,r3,r2
 d01d654:	10bfffc4 	addi	r2,r2,-1
 d01d658:	e0bff645 	stb	r2,-39(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 d01d65c:	e0bff643 	ldbu	r2,-39(fp)
 d01d660:	10800044 	addi	r2,r2,1
 d01d664:	e0bff645 	stb	r2,-39(fp)
 d01d668:	e0bff647 	ldb	r2,-39(fp)
 d01d66c:	d0e02d03 	ldbu	r3,-32588(gp)
 d01d670:	18c03fcc 	andi	r3,r3,255
 d01d674:	10fe4e16 	blt	r2,r3,d01cfb0 <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 d01d678:	e03fff15 	stw	zero,-4(fp)
 d01d67c:	e0bfff17 	ldw	r2,-4(fp)
}
 d01d680:	e037883a 	mov	sp,fp
 d01d684:	dfc00117 	ldw	ra,4(sp)
 d01d688:	df000017 	ldw	fp,0(sp)
 d01d68c:	dec00204 	addi	sp,sp,8
 d01d690:	f800283a 	ret

0d01d694 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 d01d694:	deffec04 	addi	sp,sp,-80
 d01d698:	dfc01315 	stw	ra,76(sp)
 d01d69c:	df001215 	stw	fp,72(sp)
 d01d6a0:	df001204 	addi	fp,sp,72
 d01d6a4:	e13ffe15 	stw	r4,-8(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 d01d6a8:	e03ffc15 	stw	zero,-16(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 d01d6ac:	e03ff615 	stw	zero,-40(fp)
    
    alt_8 phy_info_count = 0;
 d01d6b0:	e03ff505 	stb	zero,-44(fp)
    
    alt_tse_phy_info *pphy = 0;
 d01d6b4:	e03ff415 	stw	zero,-48(fp)
    alt_tse_mac_info *pmac_info = 0;
 d01d6b8:	e03ff315 	stw	zero,-52(fp)
    alt_tse_system_info *psys = 0;
 d01d6bc:	e03ff215 	stw	zero,-56(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d01d6c0:	e0bffe17 	ldw	r2,-8(fp)
 d01d6c4:	10800117 	ldw	r2,4(r2)
 d01d6c8:	10800217 	ldw	r2,8(r2)
 d01d6cc:	10800017 	ldw	r2,0(r2)
 d01d6d0:	e0bff115 	stw	r2,-60(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 d01d6d4:	e0bff117 	ldw	r2,-60(fp)
 d01d6d8:	10801004 	addi	r2,r2,64
 d01d6dc:	10800037 	ldwio	r2,0(r2)
 d01d6e0:	e0bff015 	stw	r2,-64(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01d6e4:	e13ffe17 	ldw	r4,-8(fp)
 d01d6e8:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01d6ec:	e0bfef05 	stb	r2,-68(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 d01d6f0:	e03ffb05 	stb	zero,-20(fp)
 d01d6f4:	0000c806 	br	d01da18 <alt_tse_mac_get_phy+0x384>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 d01d6f8:	e0bff117 	ldw	r2,-60(fp)
 d01d6fc:	10801004 	addi	r2,r2,64
 d01d700:	e0fffb03 	ldbu	r3,-20(fp)
 d01d704:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 d01d708:	e0bff117 	ldw	r2,-60(fp)
 d01d70c:	1080a204 	addi	r2,r2,648
 d01d710:	10800037 	ldwio	r2,0(r2)
 d01d714:	e0bffd15 	stw	r2,-12(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 d01d718:	e0bff117 	ldw	r2,-60(fp)
 d01d71c:	1080a304 	addi	r2,r2,652
 d01d720:	10800037 	ldwio	r2,0(r2)
 d01d724:	e0bffc15 	stw	r2,-16(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 d01d728:	e0fffd17 	ldw	r3,-12(fp)
 d01d72c:	e0bffc17 	ldw	r2,-16(fp)
 d01d730:	1880b626 	beq	r3,r2,d01da0c <alt_tse_mac_get_phy+0x378>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 d01d734:	01000704 	movi	r4,28
 d01d738:	d049ec00 	call	d049ec0 <malloc>
 d01d73c:	e0bff415 	stw	r2,-48(fp)
            if(!pphy) {
 d01d740:	e0bff417 	ldw	r2,-48(fp)
 d01d744:	1004c03a 	cmpne	r2,r2,zero
 d01d748:	1000081e 	bne	r2,zero,d01d76c <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 d01d74c:	e17fef07 	ldb	r5,-68(fp)
 d01d750:	e1bff507 	ldb	r6,-44(fp)
 d01d754:	01034174 	movhi	r4,3333
 d01d758:	21359604 	addi	r4,r4,-10664
 d01d75c:	d0029980 	call	d002998 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 d01d760:	00bfffc4 	movi	r2,-1
 d01d764:	e0bfff15 	stw	r2,-4(fp)
 d01d768:	0000ca06 	br	d01da94 <alt_tse_mac_get_phy+0x400>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 d01d76c:	e0fff417 	ldw	r3,-48(fp)
 d01d770:	e0bffb03 	ldbu	r2,-20(fp)
 d01d774:	18800005 	stb	r2,0(r3)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 d01d778:	e0bffd17 	ldw	r2,-12(fp)
 d01d77c:	100691ba 	slli	r3,r2,6
 d01d780:	e0bffc17 	ldw	r2,-16(fp)
 d01d784:	1005d2ba 	srai	r2,r2,10
 d01d788:	10800fcc 	andi	r2,r2,63
 d01d78c:	1884b03a 	or	r2,r3,r2
 d01d790:	e0bffa15 	stw	r2,-24(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 d01d794:	e0bffc17 	ldw	r2,-16(fp)
 d01d798:	1005d13a 	srai	r2,r2,4
 d01d79c:	10800fcc 	andi	r2,r2,63
 d01d7a0:	e0bff945 	stb	r2,-27(fp)
            revision_number = phyid2 & 0x0f;
 d01d7a4:	e0bffc17 	ldw	r2,-16(fp)
 d01d7a8:	108003cc 	andi	r2,r2,15
 d01d7ac:	e0bff905 	stb	r2,-28(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 d01d7b0:	e03ff705 	stb	zero,-36(fp)
            for(i = 0; i < phy_profile_count; i++) {
 d01d7b4:	e03ff815 	stw	zero,-32(fp)
 d01d7b8:	00003106 	br	d01d880 <alt_tse_mac_get_phy+0x1ec>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 d01d7bc:	e0bff817 	ldw	r2,-32(fp)
 d01d7c0:	00c341b4 	movhi	r3,3334
 d01d7c4:	18f18404 	addi	r3,r3,-14832
 d01d7c8:	1085883a 	add	r2,r2,r2
 d01d7cc:	1085883a 	add	r2,r2,r2
 d01d7d0:	10c5883a 	add	r2,r2,r3
 d01d7d4:	10800017 	ldw	r2,0(r2)
 d01d7d8:	10c01417 	ldw	r3,80(r2)
 d01d7dc:	e0bffa17 	ldw	r2,-24(fp)
 d01d7e0:	1880241e 	bne	r3,r2,d01d874 <alt_tse_mac_get_phy+0x1e0>
 d01d7e4:	e0bff817 	ldw	r2,-32(fp)
 d01d7e8:	00c341b4 	movhi	r3,3334
 d01d7ec:	18f18404 	addi	r3,r3,-14832
 d01d7f0:	1085883a 	add	r2,r2,r2
 d01d7f4:	1085883a 	add	r2,r2,r2
 d01d7f8:	10c5883a 	add	r2,r2,r3
 d01d7fc:	10800017 	ldw	r2,0(r2)
 d01d800:	10801503 	ldbu	r2,84(r2)
 d01d804:	10c03fcc 	andi	r3,r2,255
 d01d808:	e0bff943 	ldbu	r2,-27(fp)
 d01d80c:	1880191e 	bne	r3,r2,d01d874 <alt_tse_mac_get_phy+0x1e0>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 d01d810:	e0bff817 	ldw	r2,-32(fp)
 d01d814:	00c341b4 	movhi	r3,3334
 d01d818:	18f18404 	addi	r3,r3,-14832
 d01d81c:	1085883a 	add	r2,r2,r2
 d01d820:	1085883a 	add	r2,r2,r2
 d01d824:	10c5883a 	add	r2,r2,r3
 d01d828:	10c00017 	ldw	r3,0(r2)
 d01d82c:	e0bff417 	ldw	r2,-48(fp)
 d01d830:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 d01d834:	e0bff817 	ldw	r2,-32(fp)
 d01d838:	00c341b4 	movhi	r3,3334
 d01d83c:	18f18404 	addi	r3,r3,-14832
 d01d840:	1085883a 	add	r2,r2,r2
 d01d844:	1085883a 	add	r2,r2,r2
 d01d848:	10c5883a 	add	r2,r2,r3
 d01d84c:	10800017 	ldw	r2,0(r2)
 d01d850:	100b883a 	mov	r5,r2
 d01d854:	e1bffb03 	ldbu	r6,-20(fp)
 d01d858:	e1ffef07 	ldb	r7,-68(fp)
 d01d85c:	01034174 	movhi	r4,3333
 d01d860:	2135a504 	addi	r4,r4,-10604
 d01d864:	d0029980 	call	d002998 <printf>
                    is_phy_in_profile = 1;
 d01d868:	00800044 	movi	r2,1
 d01d86c:	e0bff705 	stb	r2,-36(fp)
                    break;
 d01d870:	00000706 	br	d01d890 <alt_tse_mac_get_phy+0x1fc>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 d01d874:	e0bff817 	ldw	r2,-32(fp)
 d01d878:	10800044 	addi	r2,r2,1
 d01d87c:	e0bff815 	stw	r2,-32(fp)
 d01d880:	d0a07f03 	ldbu	r2,-32260(gp)
 d01d884:	10c03fcc 	andi	r3,r2,255
 d01d888:	e0bff817 	ldw	r2,-32(fp)
 d01d88c:	10ffcb16 	blt	r2,r3,d01d7bc <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 d01d890:	e0bff703 	ldbu	r2,-36(fp)
 d01d894:	1004c03a 	cmpne	r2,r2,zero
 d01d898:	10000d1e 	bne	r2,zero,d01d8d0 <alt_tse_mac_get_phy+0x23c>
                pphy->pphy_profile = 0;
 d01d89c:	e0bff417 	ldw	r2,-48(fp)
 d01d8a0:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 d01d8a4:	e17ffb03 	ldbu	r5,-20(fp)
 d01d8a8:	e1bfef07 	ldb	r6,-68(fp)
 d01d8ac:	01034174 	movhi	r4,3333
 d01d8b0:	2135b504 	addi	r4,r4,-10540
 d01d8b4:	d0029980 	call	d002998 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 d01d8b8:	01034174 	movhi	r4,3333
 d01d8bc:	2135c604 	addi	r4,r4,-10472
 d01d8c0:	d002cc00 	call	d002cc0 <puts>
                return_value++;
 d01d8c4:	e0bff617 	ldw	r2,-40(fp)
 d01d8c8:	10800044 	addi	r2,r2,1
 d01d8cc:	e0bff615 	stw	r2,-40(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 d01d8d0:	e17ffa17 	ldw	r5,-24(fp)
 d01d8d4:	01034174 	movhi	r4,3333
 d01d8d8:	2135d304 	addi	r4,r4,-10420
 d01d8dc:	d01a5480 	call	d01a548 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 d01d8e0:	e17ff943 	ldbu	r5,-27(fp)
 d01d8e4:	01034174 	movhi	r4,3333
 d01d8e8:	2135de04 	addi	r4,r4,-10376
 d01d8ec:	d01a5480 	call	d01a548 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 d01d8f0:	e17ff903 	ldbu	r5,-28(fp)
 d01d8f4:	01034174 	movhi	r4,3333
 d01d8f8:	2135e904 	addi	r4,r4,-10332
 d01d8fc:	d01a5480 	call	d01a548 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 d01d900:	e13ffe17 	ldw	r4,-8(fp)
 d01d904:	e17ff417 	ldw	r5,-48(fp)
 d01d908:	d01daac0 	call	d01daac <alt_tse_mac_associate_phy>
 d01d90c:	1004c03a 	cmpne	r2,r2,zero
 d01d910:	1000381e 	bne	r2,zero,d01d9f4 <alt_tse_mac_get_phy+0x360>
            	
            	pmac_info = pphy->pmac_info;
 d01d914:	e0bff417 	ldw	r2,-48(fp)
 d01d918:	10800617 	ldw	r2,24(r2)
 d01d91c:	e0bff315 	stw	r2,-52(fp)
            	psys = pmac_info->psys_info;
 d01d920:	e0bff317 	ldw	r2,-52(fp)
 d01d924:	10800217 	ldw	r2,8(r2)
 d01d928:	e0bff215 	stw	r2,-56(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 d01d92c:	d8000015 	stw	zero,0(sp)
 d01d930:	e13ff417 	ldw	r4,-48(fp)
 d01d934:	000b883a 	mov	r5,zero
 d01d938:	01800384 	movi	r6,14
 d01d93c:	01c00044 	movi	r7,1
 d01d940:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 d01d944:	e13ff417 	ldw	r4,-48(fp)
 d01d948:	01400044 	movi	r5,1
 d01d94c:	d01e74c0 	call	d01e74c <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 d01d950:	e13ff417 	ldw	r4,-48(fp)
 d01d954:	01400044 	movi	r5,1
 d01d958:	d01e8e00 	call	d01e8e0 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 d01d95c:	e13ff417 	ldw	r4,-48(fp)
 d01d960:	01400044 	movi	r5,1
 d01d964:	d01eaf00 	call	d01eaf0 <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 d01d968:	e13ff417 	ldw	r4,-48(fp)
 d01d96c:	014003f4 	movhi	r5,15
 d01d970:	29509004 	addi	r5,r5,16960
 d01d974:	d01df180 	call	d01df18 <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 d01d978:	e0bff417 	ldw	r2,-48(fp)
 d01d97c:	10800517 	ldw	r2,20(r2)
 d01d980:	1005003a 	cmpeq	r2,r2,zero
 d01d984:	1000101e 	bne	r2,zero,d01d9c8 <alt_tse_mac_get_phy+0x334>
		            if(pphy->pphy_profile->phy_cfg) {
 d01d988:	e0bff417 	ldw	r2,-48(fp)
 d01d98c:	10800517 	ldw	r2,20(r2)
 d01d990:	10801717 	ldw	r2,92(r2)
 d01d994:	1005003a 	cmpeq	r2,r2,zero
 d01d998:	10000b1e 	bne	r2,zero,d01d9c8 <alt_tse_mac_get_phy+0x334>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 d01d99c:	e0bff417 	ldw	r2,-48(fp)
 d01d9a0:	10800517 	ldw	r2,20(r2)
 d01d9a4:	100b883a 	mov	r5,r2
 d01d9a8:	01034174 	movhi	r4,3333
 d01d9ac:	2135f404 	addi	r4,r4,-10288
 d01d9b0:	d01a5480 	call	d01a548 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 d01d9b4:	e0bff417 	ldw	r2,-48(fp)
 d01d9b8:	10800517 	ldw	r2,20(r2)
 d01d9bc:	10801717 	ldw	r2,92(r2)
 d01d9c0:	e13ff117 	ldw	r4,-60(fp)
 d01d9c4:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 d01d9c8:	e0bff217 	ldw	r2,-56(fp)
 d01d9cc:	10801117 	ldw	r2,68(r2)
 d01d9d0:	1005003a 	cmpeq	r2,r2,zero
 d01d9d4:	1000071e 	bne	r2,zero,d01d9f4 <alt_tse_mac_get_phy+0x360>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 d01d9d8:	01034174 	movhi	r4,3333
 d01d9dc:	21360204 	addi	r4,r4,-10232
 d01d9e0:	d01a5480 	call	d01a548 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 d01d9e4:	e0bff217 	ldw	r2,-56(fp)
 d01d9e8:	10801117 	ldw	r2,68(r2)
 d01d9ec:	e13ff117 	ldw	r4,-60(fp)
 d01d9f0:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 d01d9f4:	01034174 	movhi	r4,3333
 d01d9f8:	21361004 	addi	r4,r4,-10176
 d01d9fc:	d01a5480 	call	d01a548 <no_printf>
	            
            phy_info_count++;
 d01da00:	e0bff503 	ldbu	r2,-44(fp)
 d01da04:	10800044 	addi	r2,r2,1
 d01da08:	e0bff505 	stb	r2,-44(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 d01da0c:	e0bffb03 	ldbu	r2,-20(fp)
 d01da10:	10800044 	addi	r2,r2,1
 d01da14:	e0bffb05 	stb	r2,-20(fp)
 d01da18:	e0bffb03 	ldbu	r2,-20(fp)
 d01da1c:	10800830 	cmpltui	r2,r2,32
 d01da20:	103f351e 	bne	r2,zero,d01d6f8 <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 d01da24:	e0bffe17 	ldw	r2,-8(fp)
 d01da28:	10800003 	ldbu	r2,0(r2)
 d01da2c:	10c03fcc 	andi	r3,r2,255
 d01da30:	e0bff507 	ldb	r2,-44(fp)
 d01da34:	18801026 	beq	r3,r2,d01da78 <alt_tse_mac_get_phy+0x3e4>
        if(phy_info_count == 0) {
 d01da38:	e0bff507 	ldb	r2,-44(fp)
 d01da3c:	1004c03a 	cmpne	r2,r2,zero
 d01da40:	1000051e 	bne	r2,zero,d01da58 <alt_tse_mac_get_phy+0x3c4>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 d01da44:	e17fef07 	ldb	r5,-68(fp)
 d01da48:	01034174 	movhi	r4,3333
 d01da4c:	21361104 	addi	r4,r4,-10172
 d01da50:	d0029980 	call	d002998 <printf>
 d01da54:	00000806 	br	d01da78 <alt_tse_mac_get_phy+0x3e4>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 d01da58:	e17fef07 	ldb	r5,-68(fp)
 d01da5c:	e1bff507 	ldb	r6,-44(fp)
 d01da60:	e0bffe17 	ldw	r2,-8(fp)
 d01da64:	10800003 	ldbu	r2,0(r2)
 d01da68:	11c03fcc 	andi	r7,r2,255
 d01da6c:	01034174 	movhi	r4,3333
 d01da70:	21361d04 	addi	r4,r4,-10124
 d01da74:	d0029980 	call	d002998 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 d01da78:	e0bff117 	ldw	r2,-60(fp)
 d01da7c:	10801004 	addi	r2,r2,64
 d01da80:	1007883a 	mov	r3,r2
 d01da84:	e0bff017 	ldw	r2,-64(fp)
 d01da88:	18800035 	stwio	r2,0(r3)
    
    return return_value;
 d01da8c:	e0bff617 	ldw	r2,-40(fp)
 d01da90:	e0bfff15 	stw	r2,-4(fp)
 d01da94:	e0bfff17 	ldw	r2,-4(fp)
}
 d01da98:	e037883a 	mov	sp,fp
 d01da9c:	dfc00117 	ldw	ra,4(sp)
 d01daa0:	df000017 	ldw	fp,0(sp)
 d01daa4:	dec00204 	addi	sp,sp,8
 d01daa8:	f800283a 	ret

0d01daac <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 d01daac:	defff604 	addi	sp,sp,-40
 d01dab0:	dfc00915 	stw	ra,36(sp)
 d01dab4:	df000815 	stw	fp,32(sp)
 d01dab8:	df000804 	addi	fp,sp,32
 d01dabc:	e13ffe15 	stw	r4,-8(fp)
 d01dac0:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 d01dac4:	e03ffc15 	stw	zero,-16(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 d01dac8:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_info *pmac_info = 0;
 d01dacc:	e03ff915 	stw	zero,-28(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 d01dad0:	e03ff885 	stb	zero,-30(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01dad4:	e13ffe17 	ldw	r4,-8(fp)
 d01dad8:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01dadc:	e0bff845 	stb	r2,-31(fp)
    alt_8 sys_info_index = 0;
 d01dae0:	e03ff805 	stb	zero,-32(fp)
    
    is_mapped = 0;
 d01dae4:	e03ffb05 	stb	zero,-20(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 d01dae8:	e03ffd15 	stw	zero,-12(fp)
 d01daec:	00002906 	br	d01db94 <alt_tse_mac_associate_phy+0xe8>
        pmac_info = pmac_group->pmac_info[i];
 d01daf0:	e0bffd17 	ldw	r2,-12(fp)
 d01daf4:	e0fffe17 	ldw	r3,-8(fp)
 d01daf8:	1085883a 	add	r2,r2,r2
 d01dafc:	1085883a 	add	r2,r2,r2
 d01db00:	10c5883a 	add	r2,r2,r3
 d01db04:	10800104 	addi	r2,r2,4
 d01db08:	10800017 	ldw	r2,0(r2)
 d01db0c:	e0bff915 	stw	r2,-28(fp)
        psys = pmac_info->psys_info;
 d01db10:	e0bff917 	ldw	r2,-28(fp)
 d01db14:	10800217 	ldw	r2,8(r2)
 d01db18:	e0bffa15 	stw	r2,-24(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 d01db1c:	e0bffa17 	ldw	r2,-24(fp)
 d01db20:	10c01017 	ldw	r3,64(r2)
 d01db24:	e0bfff17 	ldw	r2,-4(fp)
 d01db28:	10800003 	ldbu	r2,0(r2)
 d01db2c:	10803fcc 	andi	r2,r2,255
 d01db30:	1880151e 	bne	r3,r2,d01db88 <alt_tse_mac_associate_phy+0xdc>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01db34:	e13ff917 	ldw	r4,-28(fp)
 d01db38:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01db3c:	e0bff885 	stb	r2,-30(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 d01db40:	e13ffa17 	ldw	r4,-24(fp)
 d01db44:	d01b6940 	call	d01b694 <alt_tse_get_system_index>
 d01db48:	e0bff805 	stb	r2,-32(fp)
	        
            pmac_info->pphy_info = pphy;
 d01db4c:	e0fff917 	ldw	r3,-28(fp)
 d01db50:	e0bfff17 	ldw	r2,-4(fp)
 d01db54:	18800115 	stw	r2,4(r3)
            pphy->pmac_info = pmac_info;
 d01db58:	e0ffff17 	ldw	r3,-4(fp)
 d01db5c:	e0bff917 	ldw	r2,-28(fp)
 d01db60:	18800615 	stw	r2,24(r3)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 d01db64:	e17ff847 	ldb	r5,-31(fp)
 d01db68:	e1bff887 	ldb	r6,-30(fp)
 d01db6c:	e1fff807 	ldb	r7,-32(fp)
 d01db70:	01034174 	movhi	r4,3333
 d01db74:	21363c04 	addi	r4,r4,-10000
 d01db78:	d0029980 	call	d002998 <printf>
            is_mapped = 1;
 d01db7c:	00800044 	movi	r2,1
 d01db80:	e0bffb05 	stb	r2,-20(fp)
            break;
 d01db84:	00000806 	br	d01dba8 <alt_tse_mac_associate_phy+0xfc>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 d01db88:	e0bffd17 	ldw	r2,-12(fp)
 d01db8c:	10800044 	addi	r2,r2,1
 d01db90:	e0bffd15 	stw	r2,-12(fp)
 d01db94:	e0bffe17 	ldw	r2,-8(fp)
 d01db98:	10800003 	ldbu	r2,0(r2)
 d01db9c:	10c03fcc 	andi	r3,r2,255
 d01dba0:	e0bffd17 	ldw	r2,-12(fp)
 d01dba4:	10ffd216 	blt	r2,r3,d01daf0 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 d01dba8:	e0bffb03 	ldbu	r2,-20(fp)
 d01dbac:	1004c03a 	cmpne	r2,r2,zero
 d01dbb0:	10003b1e 	bne	r2,zero,d01dca0 <alt_tse_mac_associate_phy+0x1f4>
        for(i = 0; i < pmac_group->channel; i++) {
 d01dbb4:	e03ffd15 	stw	zero,-12(fp)
 d01dbb8:	00003406 	br	d01dc8c <alt_tse_mac_associate_phy+0x1e0>
            pmac_info = pmac_group->pmac_info[i];
 d01dbbc:	e0bffd17 	ldw	r2,-12(fp)
 d01dbc0:	e0fffe17 	ldw	r3,-8(fp)
 d01dbc4:	1085883a 	add	r2,r2,r2
 d01dbc8:	1085883a 	add	r2,r2,r2
 d01dbcc:	10c5883a 	add	r2,r2,r3
 d01dbd0:	10800104 	addi	r2,r2,4
 d01dbd4:	10800017 	ldw	r2,0(r2)
 d01dbd8:	e0bff915 	stw	r2,-28(fp)
            psys = pmac_info->psys_info;
 d01dbdc:	e0bff917 	ldw	r2,-28(fp)
 d01dbe0:	10800217 	ldw	r2,8(r2)
 d01dbe4:	e0bffa15 	stw	r2,-24(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 d01dbe8:	e0bffa17 	ldw	r2,-24(fp)
 d01dbec:	10800517 	ldw	r2,20(r2)
 d01dbf0:	1005003a 	cmpeq	r2,r2,zero
 d01dbf4:	1000221e 	bne	r2,zero,d01dc80 <alt_tse_mac_associate_phy+0x1d4>
 d01dbf8:	e0bffa17 	ldw	r2,-24(fp)
 d01dbfc:	10800617 	ldw	r2,24(r2)
 d01dc00:	1005003a 	cmpeq	r2,r2,zero
 d01dc04:	10001e1e 	bne	r2,zero,d01dc80 <alt_tse_mac_associate_phy+0x1d4>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 d01dc08:	e0bffa17 	ldw	r2,-24(fp)
 d01dc0c:	10801017 	ldw	r2,64(r2)
 d01dc10:	10bfffd8 	cmpnei	r2,r2,-1
 d01dc14:	10001a1e 	bne	r2,zero,d01dc80 <alt_tse_mac_associate_phy+0x1d4>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01dc18:	e13ff917 	ldw	r4,-28(fp)
 d01dc1c:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01dc20:	e0bff885 	stb	r2,-30(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 d01dc24:	e13ffa17 	ldw	r4,-24(fp)
 d01dc28:	d01b6940 	call	d01b694 <alt_tse_get_system_index>
 d01dc2c:	e0bff805 	stb	r2,-32(fp)
                
                pmac_info->pphy_info = pphy;
 d01dc30:	e0fff917 	ldw	r3,-28(fp)
 d01dc34:	e0bfff17 	ldw	r2,-4(fp)
 d01dc38:	18800115 	stw	r2,4(r3)
                pphy->pmac_info = pmac_info;
 d01dc3c:	e0ffff17 	ldw	r3,-4(fp)
 d01dc40:	e0bff917 	ldw	r2,-28(fp)
 d01dc44:	18800615 	stw	r2,24(r3)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 d01dc48:	e0bfff17 	ldw	r2,-4(fp)
 d01dc4c:	10800003 	ldbu	r2,0(r2)
 d01dc50:	10c03fcc 	andi	r3,r2,255
 d01dc54:	e0bffa17 	ldw	r2,-24(fp)
 d01dc58:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 d01dc5c:	e17ff847 	ldb	r5,-31(fp)
 d01dc60:	e1bff887 	ldb	r6,-30(fp)
 d01dc64:	e1fff807 	ldb	r7,-32(fp)
 d01dc68:	01034174 	movhi	r4,3333
 d01dc6c:	21364c04 	addi	r4,r4,-9936
 d01dc70:	d0029980 	call	d002998 <printf>
                is_mapped = 1;
 d01dc74:	00800044 	movi	r2,1
 d01dc78:	e0bffb05 	stb	r2,-20(fp)
                break;
 d01dc7c:	00000806 	br	d01dca0 <alt_tse_mac_associate_phy+0x1f4>
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 d01dc80:	e0bffd17 	ldw	r2,-12(fp)
 d01dc84:	10800044 	addi	r2,r2,1
 d01dc88:	e0bffd15 	stw	r2,-12(fp)
 d01dc8c:	e0bffe17 	ldw	r2,-8(fp)
 d01dc90:	10800003 	ldbu	r2,0(r2)
 d01dc94:	10c03fcc 	andi	r3,r2,255
 d01dc98:	e0bffd17 	ldw	r2,-12(fp)
 d01dc9c:	10ffc716 	blt	r2,r3,d01dbbc <alt_tse_mac_associate_phy+0x110>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 d01dca0:	e0bffb03 	ldbu	r2,-20(fp)
 d01dca4:	1004c03a 	cmpne	r2,r2,zero
 d01dca8:	1000081e 	bne	r2,zero,d01dccc <alt_tse_mac_associate_phy+0x220>
    	pphy->pmac_info = 0;
 d01dcac:	e0bfff17 	ldw	r2,-4(fp)
 d01dcb0:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 d01dcb4:	e17ff847 	ldb	r5,-31(fp)
 d01dcb8:	01034174 	movhi	r4,3333
 d01dcbc:	21365d04 	addi	r4,r4,-9868
 d01dcc0:	d0029980 	call	d002998 <printf>
        return_value = TSE_PHY_MAP_ERROR;
 d01dcc4:	00bfffc4 	movi	r2,-1
 d01dcc8:	e0bffc15 	stw	r2,-16(fp)
    }
    
    return return_value;
 d01dccc:	e0bffc17 	ldw	r2,-16(fp)
}
 d01dcd0:	e037883a 	mov	sp,fp
 d01dcd4:	dfc00117 	ldw	ra,4(sp)
 d01dcd8:	df000017 	ldw	fp,0(sp)
 d01dcdc:	dec00204 	addi	sp,sp,8
 d01dce0:	f800283a 	ret

0d01dce4 <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 d01dce4:	defff804 	addi	sp,sp,-32
 d01dce8:	dfc00715 	stw	ra,28(sp)
 d01dcec:	df000615 	stw	fp,24(sp)
 d01dcf0:	df000604 	addi	fp,sp,24
 d01dcf4:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 d01dcf8:	e0bfff17 	ldw	r2,-4(fp)
 d01dcfc:	10800217 	ldw	r2,8(r2)
 d01dd00:	e0bffe15 	stw	r2,-8(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 d01dd04:	e0bffe17 	ldw	r2,-8(fp)
 d01dd08:	10800017 	ldw	r2,0(r2)
 d01dd0c:	e0bffd15 	stw	r2,-12(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d01dd10:	e0bfff17 	ldw	r2,-4(fp)
 d01dd14:	10800317 	ldw	r2,12(r2)
 d01dd18:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01dd1c:	e13fff17 	ldw	r4,-4(fp)
 d01dd20:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01dd24:	e0bffb45 	stb	r2,-19(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01dd28:	e13ffc17 	ldw	r4,-16(fp)
 d01dd2c:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01dd30:	e0bffb05 	stb	r2,-20(fp)

    if(psys->tse_pcs_ena) {
 d01dd34:	e0bffe17 	ldw	r2,-8(fp)
 d01dd38:	108003c3 	ldbu	r2,15(r2)
 d01dd3c:	10803fcc 	andi	r2,r2,255
 d01dd40:	1005003a 	cmpeq	r2,r2,zero
 d01dd44:	1000291e 	bne	r2,zero,d01ddec <alt_tse_phy_cfg_pcs+0x108>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 d01dd48:	e17ffb07 	ldb	r5,-20(fp)
 d01dd4c:	e1bffb47 	ldb	r6,-19(fp)
 d01dd50:	01034174 	movhi	r4,3333
 d01dd54:	21368e04 	addi	r4,r4,-9672
 d01dd58:	d0029980 	call	d002998 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 d01dd5c:	e0bffd17 	ldw	r2,-12(fp)
 d01dd60:	10808004 	addi	r2,r2,512
 d01dd64:	10801404 	addi	r2,r2,80
 d01dd68:	10800037 	ldwio	r2,0(r2)
 d01dd6c:	e0bffa15 	stw	r2,-24(fp)
        
        if(psys->tse_pcs_sgmii) {
 d01dd70:	e0bffe17 	ldw	r2,-8(fp)
 d01dd74:	10800403 	ldbu	r2,16(r2)
 d01dd78:	10803fcc 	andi	r2,r2,255
 d01dd7c:	1005003a 	cmpeq	r2,r2,zero
 d01dd80:	10000d1e 	bne	r2,zero,d01ddb8 <alt_tse_phy_cfg_pcs+0xd4>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 d01dd84:	e17ffb07 	ldb	r5,-20(fp)
 d01dd88:	e1bffb47 	ldb	r6,-19(fp)
 d01dd8c:	01034174 	movhi	r4,3333
 d01dd90:	21369c04 	addi	r4,r4,-9616
 d01dd94:	d0029980 	call	d002998 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 d01dd98:	e0bffd17 	ldw	r2,-12(fp)
 d01dd9c:	10808004 	addi	r2,r2,512
 d01dda0:	11001404 	addi	r4,r2,80
 d01dda4:	e0bffa17 	ldw	r2,-24(fp)
 d01dda8:	10c000d4 	ori	r3,r2,3
 d01ddac:	2005883a 	mov	r2,r4
 d01ddb0:	10c00035 	stwio	r3,0(r2)
 d01ddb4:	00000d06 	br	d01ddec <alt_tse_phy_cfg_pcs+0x108>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 d01ddb8:	e17ffb07 	ldb	r5,-20(fp)
 d01ddbc:	e1bffb47 	ldb	r6,-19(fp)
 d01ddc0:	01034174 	movhi	r4,3333
 d01ddc4:	2136a804 	addi	r4,r4,-9568
 d01ddc8:	d0029980 	call	d002998 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 d01ddcc:	e0bffd17 	ldw	r2,-12(fp)
 d01ddd0:	10808004 	addi	r2,r2,512
 d01ddd4:	11001404 	addi	r4,r2,80
 d01ddd8:	e0fffa17 	ldw	r3,-24(fp)
 d01dddc:	00bfff04 	movi	r2,-4
 d01dde0:	1886703a 	and	r3,r3,r2
 d01dde4:	2005883a 	mov	r2,r4
 d01dde8:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 d01ddec:	0005883a 	mov	r2,zero
}
 d01ddf0:	e037883a 	mov	sp,fp
 d01ddf4:	dfc00117 	ldw	ra,4(sp)
 d01ddf8:	df000017 	ldw	fp,0(sp)
 d01ddfc:	dec00204 	addi	sp,sp,8
 d01de00:	f800283a 	ret

0d01de04 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 d01de04:	defffb04 	addi	sp,sp,-20
 d01de08:	dfc00415 	stw	ra,16(sp)
 d01de0c:	df000315 	stw	fp,12(sp)
 d01de10:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 d01de14:	e03fff45 	stb	zero,-3(fp)
	alt_8 j = 0;
 d01de18:	e03fff05 	stb	zero,-4(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 d01de1c:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 d01de20:	e03ffd15 	stw	zero,-12(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 d01de24:	d01cb200 	call	d01cb20 <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 d01de28:	d01cd980 	call	d01cd98 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 d01de2c:	d01cf880 	call	d01cf88 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 d01de30:	e03fff45 	stb	zero,-3(fp)
 d01de34:	00002e06 	br	d01def0 <alt_tse_phy_init+0xec>
        pmac_group = pmac_groups[i];
 d01de38:	e0bfff47 	ldb	r2,-3(fp)
 d01de3c:	00c341b4 	movhi	r3,3334
 d01de40:	18f18004 	addi	r3,r3,-14848
 d01de44:	1085883a 	add	r2,r2,r2
 d01de48:	1085883a 	add	r2,r2,r2
 d01de4c:	10c5883a 	add	r2,r2,r3
 d01de50:	10800017 	ldw	r2,0(r2)
 d01de54:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 d01de58:	e0bffe17 	ldw	r2,-8(fp)
 d01de5c:	10800117 	ldw	r2,4(r2)
 d01de60:	10800217 	ldw	r2,8(r2)
 d01de64:	10800203 	ldbu	r2,8(r2)
 d01de68:	10803fcc 	andi	r2,r2,255
 d01de6c:	1005003a 	cmpeq	r2,r2,zero
 d01de70:	1000031e 	bne	r2,zero,d01de80 <alt_tse_phy_init+0x7c>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 d01de74:	e13ffe17 	ldw	r4,-8(fp)
 d01de78:	d01d6940 	call	d01d694 <alt_tse_mac_get_phy>
 d01de7c:	00000506 	br	d01de94 <alt_tse_phy_init+0x90>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 d01de80:	e17fff47 	ldb	r5,-3(fp)
 d01de84:	e1bfff07 	ldb	r6,-4(fp)
 d01de88:	01034174 	movhi	r4,3333
 d01de8c:	2136b404 	addi	r4,r4,-9520
 d01de90:	d0029980 	call	d002998 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 d01de94:	e03fff05 	stb	zero,-4(fp)
 d01de98:	00000d06 	br	d01ded0 <alt_tse_phy_init+0xcc>
            pmac_info = pmac_group->pmac_info[j];
 d01de9c:	e0bfff07 	ldb	r2,-4(fp)
 d01dea0:	e0fffe17 	ldw	r3,-8(fp)
 d01dea4:	1085883a 	add	r2,r2,r2
 d01dea8:	1085883a 	add	r2,r2,r2
 d01deac:	10c5883a 	add	r2,r2,r3
 d01deb0:	10800104 	addi	r2,r2,4
 d01deb4:	10800017 	ldw	r2,0(r2)
 d01deb8:	e0bffd15 	stw	r2,-12(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 d01debc:	e13ffd17 	ldw	r4,-12(fp)
 d01dec0:	d01dce40 	call	d01dce4 <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 d01dec4:	e0bfff03 	ldbu	r2,-4(fp)
 d01dec8:	10800044 	addi	r2,r2,1
 d01decc:	e0bfff05 	stb	r2,-4(fp)
 d01ded0:	e0ffff07 	ldb	r3,-4(fp)
 d01ded4:	e0bffe17 	ldw	r2,-8(fp)
 d01ded8:	10800003 	ldbu	r2,0(r2)
 d01dedc:	10803fcc 	andi	r2,r2,255
 d01dee0:	18bfee16 	blt	r3,r2,d01de9c <alt_tse_phy_init+0x98>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 d01dee4:	e0bfff43 	ldbu	r2,-3(fp)
 d01dee8:	10800044 	addi	r2,r2,1
 d01deec:	e0bfff45 	stb	r2,-3(fp)
 d01def0:	e0bfff47 	ldb	r2,-3(fp)
 d01def4:	d0e07f43 	ldbu	r3,-32259(gp)
 d01def8:	18c03fcc 	andi	r3,r3,255
 d01defc:	10ffce16 	blt	r2,r3,d01de38 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 d01df00:	0005883a 	mov	r2,zero
}
 d01df04:	e037883a 	mov	sp,fp
 d01df08:	dfc00117 	ldw	ra,4(sp)
 d01df0c:	df000017 	ldw	fp,0(sp)
 d01df10:	dec00204 	addi	sp,sp,8
 d01df14:	f800283a 	ret

0d01df18 <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 d01df18:	defff604 	addi	sp,sp,-40
 d01df1c:	dfc00915 	stw	ra,36(sp)
 d01df20:	df000815 	stw	fp,32(sp)
 d01df24:	df000804 	addi	fp,sp,32
 d01df28:	e13ffd15 	stw	r4,-12(fp)
 d01df2c:	e17ffe15 	stw	r5,-8(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d01df30:	e0bffd17 	ldw	r2,-12(fp)
 d01df34:	10800617 	ldw	r2,24(r2)
 d01df38:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d01df3c:	e0bffc17 	ldw	r2,-16(fp)
 d01df40:	10800317 	ldw	r2,12(r2)
 d01df44:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01df48:	e13ffc17 	ldw	r4,-16(fp)
 d01df4c:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01df50:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01df54:	e13ffb17 	ldw	r4,-20(fp)
 d01df58:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01df5c:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d01df60:	e13ffd17 	ldw	r4,-12(fp)
 d01df64:	d01c8980 	call	d01c898 <alt_tse_phy_rd_mdio_addr>
 d01df68:	e0bffa05 	stb	r2,-24(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d01df6c:	e0bffd17 	ldw	r2,-12(fp)
 d01df70:	10800003 	ldbu	r2,0(r2)
 d01df74:	11403fcc 	andi	r5,r2,255
 d01df78:	e13ffd17 	ldw	r4,-12(fp)
 d01df7c:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 d01df80:	e13ffd17 	ldw	r4,-12(fp)
 d01df84:	01400044 	movi	r5,1
 d01df88:	018000c4 	movi	r6,3
 d01df8c:	01c00044 	movi	r7,1
 d01df90:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01df94:	1004c03a 	cmpne	r2,r2,zero
 d01df98:	10000b1e 	bne	r2,zero,d01dfc8 <alt_tse_phy_restart_an+0xb0>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 d01df9c:	e17ffa47 	ldb	r5,-23(fp)
 d01dfa0:	e1bffa87 	ldb	r6,-22(fp)
 d01dfa4:	01034174 	movhi	r4,3333
 d01dfa8:	2136ca04 	addi	r4,r4,-9432
 d01dfac:	d0029980 	call	d002998 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d01dfb0:	e17ffa03 	ldbu	r5,-24(fp)
 d01dfb4:	e13ffd17 	ldw	r4,-12(fp)
 d01dfb8:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 d01dfbc:	00bfff84 	movi	r2,-2
 d01dfc0:	e0bfff15 	stw	r2,-4(fp)
 d01dfc4:	00003a06 	br	d01e0b0 <alt_tse_phy_restart_an+0x198>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 d01dfc8:	00800044 	movi	r2,1
 d01dfcc:	d8800015 	stw	r2,0(sp)
 d01dfd0:	e13ffd17 	ldw	r4,-12(fp)
 d01dfd4:	000b883a 	mov	r5,zero
 d01dfd8:	01800304 	movi	r6,12
 d01dfdc:	01c00044 	movi	r7,1
 d01dfe0:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 d01dfe4:	00800044 	movi	r2,1
 d01dfe8:	d8800015 	stw	r2,0(sp)
 d01dfec:	e13ffd17 	ldw	r4,-12(fp)
 d01dff0:	000b883a 	mov	r5,zero
 d01dff4:	01800244 	movi	r6,9
 d01dff8:	01c00044 	movi	r7,1
 d01dffc:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 d01e000:	e17ffa47 	ldb	r5,-23(fp)
 d01e004:	e1bffa87 	ldb	r6,-22(fp)
 d01e008:	01034174 	movhi	r4,3333
 d01e00c:	2136da04 	addi	r4,r4,-9368
 d01e010:	d0029980 	call	d002998 <printf>
    
    alt_32 timeout = 0;
 d01e014:	e03ff915 	stw	zero,-28(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 d01e018:	00001506 	br	d01e070 <alt_tse_phy_restart_an+0x158>
        if(timeout++ > timeout_threshold) {
 d01e01c:	e0fff917 	ldw	r3,-28(fp)
 d01e020:	e0bffe17 	ldw	r2,-8(fp)
 d01e024:	10c5803a 	cmpltu	r2,r2,r3
 d01e028:	1007883a 	mov	r3,r2
 d01e02c:	e0bff917 	ldw	r2,-28(fp)
 d01e030:	10800044 	addi	r2,r2,1
 d01e034:	e0bff915 	stw	r2,-28(fp)
 d01e038:	18803fcc 	andi	r2,r3,255
 d01e03c:	1005003a 	cmpeq	r2,r2,zero
 d01e040:	10000b1e 	bne	r2,zero,d01e070 <alt_tse_phy_restart_an+0x158>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 d01e044:	e17ffa47 	ldb	r5,-23(fp)
 d01e048:	e1bffa87 	ldb	r6,-22(fp)
 d01e04c:	01034174 	movhi	r4,3333
 d01e050:	2136ec04 	addi	r4,r4,-9296
 d01e054:	d0029980 	call	d002998 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d01e058:	e17ffa03 	ldbu	r5,-24(fp)
 d01e05c:	e13ffd17 	ldw	r4,-12(fp)
 d01e060:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 d01e064:	00bfffc4 	movi	r2,-1
 d01e068:	e0bfff15 	stw	r2,-4(fp)
 d01e06c:	00001006 	br	d01e0b0 <alt_tse_phy_restart_an+0x198>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 d01e070:	e13ffd17 	ldw	r4,-12(fp)
 d01e074:	01400044 	movi	r5,1
 d01e078:	01800144 	movi	r6,5
 d01e07c:	01c00044 	movi	r7,1
 d01e080:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e084:	1005003a 	cmpeq	r2,r2,zero
 d01e088:	103fe41e 	bne	r2,zero,d01e01c <alt_tse_phy_restart_an+0x104>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 d01e08c:	e17ffa47 	ldb	r5,-23(fp)
 d01e090:	e1bffa87 	ldb	r6,-22(fp)
 d01e094:	01034174 	movhi	r4,3333
 d01e098:	2136f804 	addi	r4,r4,-9248
 d01e09c:	d0029980 	call	d002998 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d01e0a0:	e17ffa03 	ldbu	r5,-24(fp)
 d01e0a4:	e13ffd17 	ldw	r4,-12(fp)
 d01e0a8:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 d01e0ac:	e03fff15 	stw	zero,-4(fp)
 d01e0b0:	e0bfff17 	ldw	r2,-4(fp)
}
 d01e0b4:	e037883a 	mov	sp,fp
 d01e0b8:	dfc00117 	ldw	ra,4(sp)
 d01e0bc:	df000017 	ldw	fp,0(sp)
 d01e0c0:	dec00204 	addi	sp,sp,8
 d01e0c4:	f800283a 	ret

0d01e0c8 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 d01e0c8:	defff804 	addi	sp,sp,-32
 d01e0cc:	dfc00715 	stw	ra,28(sp)
 d01e0d0:	df000615 	stw	fp,24(sp)
 d01e0d4:	df000604 	addi	fp,sp,24
 d01e0d8:	e13ffd15 	stw	r4,-12(fp)
 d01e0dc:	e17ffe15 	stw	r5,-8(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d01e0e0:	e0bffd17 	ldw	r2,-12(fp)
 d01e0e4:	10800617 	ldw	r2,24(r2)
 d01e0e8:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d01e0ec:	e0bffc17 	ldw	r2,-16(fp)
 d01e0f0:	10800317 	ldw	r2,12(r2)
 d01e0f4:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01e0f8:	e13ffc17 	ldw	r4,-16(fp)
 d01e0fc:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01e100:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 d01e104:	e13ffb17 	ldw	r4,-20(fp)
 d01e108:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01e10c:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d01e110:	e13ffd17 	ldw	r4,-12(fp)
 d01e114:	d01c8980 	call	d01c898 <alt_tse_phy_rd_mdio_addr>
 d01e118:	e0bffa05 	stb	r2,-24(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d01e11c:	e0bffd17 	ldw	r2,-12(fp)
 d01e120:	10800003 	ldbu	r2,0(r2)
 d01e124:	11403fcc 	andi	r5,r2,255
 d01e128:	e13ffd17 	ldw	r4,-12(fp)
 d01e12c:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 d01e130:	e17ffa47 	ldb	r5,-23(fp)
 d01e134:	e1bffa87 	ldb	r6,-22(fp)
 d01e138:	01034174 	movhi	r4,3333
 d01e13c:	21370404 	addi	r4,r4,-9200
 d01e140:	d0029980 	call	d002998 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 d01e144:	e13ffd17 	ldw	r4,-12(fp)
 d01e148:	000b883a 	mov	r5,zero
 d01e14c:	01800384 	movi	r6,14
 d01e150:	01c00044 	movi	r7,1
 d01e154:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e158:	1004c03a 	cmpne	r2,r2,zero
 d01e15c:	1000071e 	bne	r2,zero,d01e17c <alt_tse_phy_check_link+0xb4>
 d01e160:	e13ffd17 	ldw	r4,-12(fp)
 d01e164:	01400044 	movi	r5,1
 d01e168:	01800144 	movi	r6,5
 d01e16c:	01c00044 	movi	r7,1
 d01e170:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e174:	1004c03a 	cmpne	r2,r2,zero
 d01e178:	1000151e 	bne	r2,zero,d01e1d0 <alt_tse_phy_check_link+0x108>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 d01e17c:	e17ffa47 	ldb	r5,-23(fp)
 d01e180:	e1bffa87 	ldb	r6,-22(fp)
 d01e184:	01034174 	movhi	r4,3333
 d01e188:	21370f04 	addi	r4,r4,-9156
 d01e18c:	d0029980 	call	d002998 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 d01e190:	e13ffd17 	ldw	r4,-12(fp)
 d01e194:	e17ffe17 	ldw	r5,-8(fp)
 d01e198:	d01df180 	call	d01df18 <alt_tse_phy_restart_an>
 d01e19c:	10bfffd8 	cmpnei	r2,r2,-1
 d01e1a0:	10000b1e 	bne	r2,zero,d01e1d0 <alt_tse_phy_check_link+0x108>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 d01e1a4:	e17ffa47 	ldb	r5,-23(fp)
 d01e1a8:	e1bffa87 	ldb	r6,-22(fp)
 d01e1ac:	01034174 	movhi	r4,3333
 d01e1b0:	21372304 	addi	r4,r4,-9076
 d01e1b4:	d0029980 	call	d002998 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d01e1b8:	e17ffa03 	ldbu	r5,-24(fp)
 d01e1bc:	e13ffd17 	ldw	r4,-12(fp)
 d01e1c0:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 d01e1c4:	00bfffc4 	movi	r2,-1
 d01e1c8:	e0bfff15 	stw	r2,-4(fp)
 d01e1cc:	00000906 	br	d01e1f4 <alt_tse_phy_check_link+0x12c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 d01e1d0:	e17ffa47 	ldb	r5,-23(fp)
 d01e1d4:	e1bffa87 	ldb	r6,-22(fp)
 d01e1d8:	01034174 	movhi	r4,3333
 d01e1dc:	21373004 	addi	r4,r4,-9024
 d01e1e0:	d0029980 	call	d002998 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d01e1e4:	e17ffa03 	ldbu	r5,-24(fp)
 d01e1e8:	e13ffd17 	ldw	r4,-12(fp)
 d01e1ec:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 d01e1f0:	e03fff15 	stw	zero,-4(fp)
 d01e1f4:	e0bfff17 	ldw	r2,-4(fp)
}
 d01e1f8:	e037883a 	mov	sp,fp
 d01e1fc:	dfc00117 	ldw	ra,4(sp)
 d01e200:	df000017 	ldw	fp,0(sp)
 d01e204:	dec00204 	addi	sp,sp,8
 d01e208:	f800283a 	ret

0d01e20c <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 d01e20c:	defff804 	addi	sp,sp,-32
 d01e210:	dfc00715 	stw	ra,28(sp)
 d01e214:	df000615 	stw	fp,24(sp)
 d01e218:	df000604 	addi	fp,sp,24
 d01e21c:	e13ffe15 	stw	r4,-8(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 d01e220:	e03ffd15 	stw	zero,-12(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d01e224:	e0bffe17 	ldw	r2,-8(fp)
 d01e228:	10800617 	ldw	r2,24(r2)
 d01e22c:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d01e230:	e0bffc17 	ldw	r2,-16(fp)
 d01e234:	10800317 	ldw	r2,12(r2)
 d01e238:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01e23c:	e13ffc17 	ldw	r4,-16(fp)
 d01e240:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01e244:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 d01e248:	e13ffb17 	ldw	r4,-20(fp)
 d01e24c:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01e250:	e0bffa45 	stb	r2,-23(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d01e254:	e13ffe17 	ldw	r4,-8(fp)
 d01e258:	d01c8980 	call	d01c898 <alt_tse_phy_rd_mdio_addr>
 d01e25c:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d01e260:	e0bffe17 	ldw	r2,-8(fp)
 d01e264:	10800003 	ldbu	r2,0(r2)
 d01e268:	11403fcc 	andi	r5,r2,255
 d01e26c:	e13ffe17 	ldw	r4,-8(fp)
 d01e270:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 d01e274:	e13ffe17 	ldw	r4,-8(fp)
 d01e278:	01400044 	movi	r5,1
 d01e27c:	018000c4 	movi	r6,3
 d01e280:	01c00044 	movi	r7,1
 d01e284:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e288:	1004c03a 	cmpne	r2,r2,zero
 d01e28c:	10000b1e 	bne	r2,zero,d01e2bc <alt_tse_phy_get_cap+0xb0>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 d01e290:	e17ffa47 	ldb	r5,-23(fp)
 d01e294:	e1bffa87 	ldb	r6,-22(fp)
 d01e298:	01034174 	movhi	r4,3333
 d01e29c:	2136ca04 	addi	r4,r4,-9432
 d01e2a0:	d0029980 	call	d002998 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d01e2a4:	e17ffa03 	ldbu	r5,-24(fp)
 d01e2a8:	e13ffe17 	ldw	r4,-8(fp)
 d01e2ac:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 d01e2b0:	00bfff84 	movi	r2,-2
 d01e2b4:	e0bfff15 	stw	r2,-4(fp)
 d01e2b8:	00011e06 	br	d01e734 <alt_tse_phy_get_cap+0x528>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 d01e2bc:	e13ffe17 	ldw	r4,-8(fp)
 d01e2c0:	01400134 	movhi	r5,4
 d01e2c4:	29742404 	addi	r5,r5,-12144
 d01e2c8:	d01df180 	call	d01df18 <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 d01e2cc:	e13ffe17 	ldw	r4,-8(fp)
 d01e2d0:	01400044 	movi	r5,1
 d01e2d4:	01800144 	movi	r6,5
 d01e2d8:	01c00044 	movi	r7,1
 d01e2dc:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e2e0:	1004c03a 	cmpne	r2,r2,zero
 d01e2e4:	1000021e 	bne	r2,zero,d01e2f0 <alt_tse_phy_get_cap+0xe4>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 d01e2e8:	00bfffc4 	movi	r2,-1
 d01e2ec:	e0bffd15 	stw	r2,-12(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 d01e2f0:	e13ffe17 	ldw	r4,-8(fp)
 d01e2f4:	014003c4 	movi	r5,15
 d01e2f8:	018003c4 	movi	r6,15
 d01e2fc:	01c00044 	movi	r7,1
 d01e300:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e304:	1007883a 	mov	r3,r2
 d01e308:	e0bffe17 	ldw	r2,-8(fp)
 d01e30c:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 d01e310:	e13ffe17 	ldw	r4,-8(fp)
 d01e314:	014003c4 	movi	r5,15
 d01e318:	01800384 	movi	r6,14
 d01e31c:	01c00044 	movi	r7,1
 d01e320:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e324:	1007883a 	mov	r3,r2
 d01e328:	e0bffe17 	ldw	r2,-8(fp)
 d01e32c:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 d01e330:	e13ffe17 	ldw	r4,-8(fp)
 d01e334:	014003c4 	movi	r5,15
 d01e338:	01800344 	movi	r6,13
 d01e33c:	01c00044 	movi	r7,1
 d01e340:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e344:	1007883a 	mov	r3,r2
 d01e348:	e0bffe17 	ldw	r2,-8(fp)
 d01e34c:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 d01e350:	e13ffe17 	ldw	r4,-8(fp)
 d01e354:	014003c4 	movi	r5,15
 d01e358:	01800304 	movi	r6,12
 d01e35c:	01c00044 	movi	r7,1
 d01e360:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e364:	1007883a 	mov	r3,r2
 d01e368:	e0bffe17 	ldw	r2,-8(fp)
 d01e36c:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 d01e370:	e13ffe17 	ldw	r4,-8(fp)
 d01e374:	01400044 	movi	r5,1
 d01e378:	018003c4 	movi	r6,15
 d01e37c:	01c00044 	movi	r7,1
 d01e380:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e384:	1007883a 	mov	r3,r2
 d01e388:	e0bffe17 	ldw	r2,-8(fp)
 d01e38c:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 d01e390:	e13ffe17 	ldw	r4,-8(fp)
 d01e394:	01400044 	movi	r5,1
 d01e398:	01800384 	movi	r6,14
 d01e39c:	01c00044 	movi	r7,1
 d01e3a0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e3a4:	1007883a 	mov	r3,r2
 d01e3a8:	e0bffe17 	ldw	r2,-8(fp)
 d01e3ac:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 d01e3b0:	e13ffe17 	ldw	r4,-8(fp)
 d01e3b4:	01400044 	movi	r5,1
 d01e3b8:	01800344 	movi	r6,13
 d01e3bc:	01c00044 	movi	r7,1
 d01e3c0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e3c4:	1007883a 	mov	r3,r2
 d01e3c8:	e0bffe17 	ldw	r2,-8(fp)
 d01e3cc:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 d01e3d0:	e13ffe17 	ldw	r4,-8(fp)
 d01e3d4:	01400044 	movi	r5,1
 d01e3d8:	01800284 	movi	r6,10
 d01e3dc:	01c00044 	movi	r7,1
 d01e3e0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e3e4:	1007883a 	mov	r3,r2
 d01e3e8:	e0bffe17 	ldw	r2,-8(fp)
 d01e3ec:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 d01e3f0:	e13ffe17 	ldw	r4,-8(fp)
 d01e3f4:	01400044 	movi	r5,1
 d01e3f8:	01800244 	movi	r6,9
 d01e3fc:	01c00044 	movi	r7,1
 d01e400:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e404:	1007883a 	mov	r3,r2
 d01e408:	e0bffe17 	ldw	r2,-8(fp)
 d01e40c:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 d01e410:	e13ffe17 	ldw	r4,-8(fp)
 d01e414:	01400044 	movi	r5,1
 d01e418:	01800304 	movi	r6,12
 d01e41c:	01c00044 	movi	r7,1
 d01e420:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e424:	1007883a 	mov	r3,r2
 d01e428:	e0bffe17 	ldw	r2,-8(fp)
 d01e42c:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 d01e430:	e13ffe17 	ldw	r4,-8(fp)
 d01e434:	01400044 	movi	r5,1
 d01e438:	018002c4 	movi	r6,11
 d01e43c:	01c00044 	movi	r7,1
 d01e440:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e444:	1007883a 	mov	r3,r2
 d01e448:	e0bffe17 	ldw	r2,-8(fp)
 d01e44c:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 d01e450:	e13ffe17 	ldw	r4,-8(fp)
 d01e454:	01400284 	movi	r5,10
 d01e458:	018002c4 	movi	r6,11
 d01e45c:	01c00044 	movi	r7,1
 d01e460:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e464:	1007883a 	mov	r3,r2
 d01e468:	e0bffe17 	ldw	r2,-8(fp)
 d01e46c:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 d01e470:	e13ffe17 	ldw	r4,-8(fp)
 d01e474:	01400284 	movi	r5,10
 d01e478:	01800284 	movi	r6,10
 d01e47c:	01c00044 	movi	r7,1
 d01e480:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e484:	1007883a 	mov	r3,r2
 d01e488:	e0bffe17 	ldw	r2,-8(fp)
 d01e48c:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 d01e490:	e13ffe17 	ldw	r4,-8(fp)
 d01e494:	01400144 	movi	r5,5
 d01e498:	01800244 	movi	r6,9
 d01e49c:	01c00044 	movi	r7,1
 d01e4a0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e4a4:	1007883a 	mov	r3,r2
 d01e4a8:	e0bffe17 	ldw	r2,-8(fp)
 d01e4ac:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 d01e4b0:	e13ffe17 	ldw	r4,-8(fp)
 d01e4b4:	01400144 	movi	r5,5
 d01e4b8:	01800204 	movi	r6,8
 d01e4bc:	01c00044 	movi	r7,1
 d01e4c0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e4c4:	1007883a 	mov	r3,r2
 d01e4c8:	e0bffe17 	ldw	r2,-8(fp)
 d01e4cc:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 d01e4d0:	e13ffe17 	ldw	r4,-8(fp)
 d01e4d4:	01400144 	movi	r5,5
 d01e4d8:	018001c4 	movi	r6,7
 d01e4dc:	01c00044 	movi	r7,1
 d01e4e0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e4e4:	1007883a 	mov	r3,r2
 d01e4e8:	e0bffe17 	ldw	r2,-8(fp)
 d01e4ec:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 d01e4f0:	e13ffe17 	ldw	r4,-8(fp)
 d01e4f4:	01400144 	movi	r5,5
 d01e4f8:	01800184 	movi	r6,6
 d01e4fc:	01c00044 	movi	r7,1
 d01e500:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e504:	1007883a 	mov	r3,r2
 d01e508:	e0bffe17 	ldw	r2,-8(fp)
 d01e50c:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 d01e510:	e13ffe17 	ldw	r4,-8(fp)
 d01e514:	01400144 	movi	r5,5
 d01e518:	01800144 	movi	r6,5
 d01e51c:	01c00044 	movi	r7,1
 d01e520:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e524:	1007883a 	mov	r3,r2
 d01e528:	e0bffe17 	ldw	r2,-8(fp)
 d01e52c:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 d01e530:	e17ffa47 	ldb	r5,-23(fp)
 d01e534:	e1bffa87 	ldb	r6,-22(fp)
 d01e538:	01034174 	movhi	r4,3333
 d01e53c:	21373b04 	addi	r4,r4,-8980
 d01e540:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 d01e544:	e0bffe17 	ldw	r2,-8(fp)
 d01e548:	10800043 	ldbu	r2,1(r2)
 d01e54c:	11403fcc 	andi	r5,r2,255
 d01e550:	01034174 	movhi	r4,3333
 d01e554:	21374604 	addi	r4,r4,-8936
 d01e558:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 d01e55c:	e0bffe17 	ldw	r2,-8(fp)
 d01e560:	10800083 	ldbu	r2,2(r2)
 d01e564:	11403fcc 	andi	r5,r2,255
 d01e568:	01034174 	movhi	r4,3333
 d01e56c:	21375004 	addi	r4,r4,-8896
 d01e570:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 d01e574:	e0bffe17 	ldw	r2,-8(fp)
 d01e578:	108000c3 	ldbu	r2,3(r2)
 d01e57c:	11403fcc 	andi	r5,r2,255
 d01e580:	01034174 	movhi	r4,3333
 d01e584:	21375a04 	addi	r4,r4,-8856
 d01e588:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 d01e58c:	e0bffe17 	ldw	r2,-8(fp)
 d01e590:	10800103 	ldbu	r2,4(r2)
 d01e594:	11403fcc 	andi	r5,r2,255
 d01e598:	01034174 	movhi	r4,3333
 d01e59c:	21376404 	addi	r4,r4,-8816
 d01e5a0:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 d01e5a4:	e0bffe17 	ldw	r2,-8(fp)
 d01e5a8:	10800143 	ldbu	r2,5(r2)
 d01e5ac:	11403fcc 	andi	r5,r2,255
 d01e5b0:	01034174 	movhi	r4,3333
 d01e5b4:	21376e04 	addi	r4,r4,-8776
 d01e5b8:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 d01e5bc:	e0bffe17 	ldw	r2,-8(fp)
 d01e5c0:	10800183 	ldbu	r2,6(r2)
 d01e5c4:	11403fcc 	andi	r5,r2,255
 d01e5c8:	01034174 	movhi	r4,3333
 d01e5cc:	21377804 	addi	r4,r4,-8736
 d01e5d0:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 d01e5d4:	e0bffe17 	ldw	r2,-8(fp)
 d01e5d8:	108001c3 	ldbu	r2,7(r2)
 d01e5dc:	11403fcc 	andi	r5,r2,255
 d01e5e0:	01034174 	movhi	r4,3333
 d01e5e4:	21378204 	addi	r4,r4,-8696
 d01e5e8:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 d01e5ec:	e0bffe17 	ldw	r2,-8(fp)
 d01e5f0:	10800203 	ldbu	r2,8(r2)
 d01e5f4:	11403fcc 	andi	r5,r2,255
 d01e5f8:	01034174 	movhi	r4,3333
 d01e5fc:	21378c04 	addi	r4,r4,-8656
 d01e600:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 d01e604:	e0bffe17 	ldw	r2,-8(fp)
 d01e608:	10800243 	ldbu	r2,9(r2)
 d01e60c:	11403fcc 	andi	r5,r2,255
 d01e610:	01034174 	movhi	r4,3333
 d01e614:	21379604 	addi	r4,r4,-8616
 d01e618:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 d01e61c:	e0bffe17 	ldw	r2,-8(fp)
 d01e620:	10800283 	ldbu	r2,10(r2)
 d01e624:	11403fcc 	andi	r5,r2,255
 d01e628:	01034174 	movhi	r4,3333
 d01e62c:	2137a004 	addi	r4,r4,-8576
 d01e630:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 d01e634:	e0bffe17 	ldw	r2,-8(fp)
 d01e638:	108002c3 	ldbu	r2,11(r2)
 d01e63c:	11403fcc 	andi	r5,r2,255
 d01e640:	01034174 	movhi	r4,3333
 d01e644:	2137aa04 	addi	r4,r4,-8536
 d01e648:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "\n");
 d01e64c:	01034174 	movhi	r4,3333
 d01e650:	21361004 	addi	r4,r4,-10176
 d01e654:	d01a5480 	call	d01a548 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 d01e658:	e17ffa47 	ldb	r5,-23(fp)
 d01e65c:	e1bffa87 	ldb	r6,-22(fp)
 d01e660:	01034174 	movhi	r4,3333
 d01e664:	2137b404 	addi	r4,r4,-8496
 d01e668:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 d01e66c:	e0bffe17 	ldw	r2,-8(fp)
 d01e670:	10800303 	ldbu	r2,12(r2)
 d01e674:	11403fcc 	andi	r5,r2,255
 d01e678:	01034174 	movhi	r4,3333
 d01e67c:	21375a04 	addi	r4,r4,-8856
 d01e680:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 d01e684:	e0bffe17 	ldw	r2,-8(fp)
 d01e688:	10800343 	ldbu	r2,13(r2)
 d01e68c:	11403fcc 	andi	r5,r2,255
 d01e690:	01034174 	movhi	r4,3333
 d01e694:	21376404 	addi	r4,r4,-8816
 d01e698:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 d01e69c:	e0bffe17 	ldw	r2,-8(fp)
 d01e6a0:	10800383 	ldbu	r2,14(r2)
 d01e6a4:	11403fcc 	andi	r5,r2,255
 d01e6a8:	01034174 	movhi	r4,3333
 d01e6ac:	21376e04 	addi	r4,r4,-8776
 d01e6b0:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 d01e6b4:	e0bffe17 	ldw	r2,-8(fp)
 d01e6b8:	108003c3 	ldbu	r2,15(r2)
 d01e6bc:	11403fcc 	andi	r5,r2,255
 d01e6c0:	01034174 	movhi	r4,3333
 d01e6c4:	2137c104 	addi	r4,r4,-8444
 d01e6c8:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 d01e6cc:	e0bffe17 	ldw	r2,-8(fp)
 d01e6d0:	10800403 	ldbu	r2,16(r2)
 d01e6d4:	11403fcc 	andi	r5,r2,255
 d01e6d8:	01034174 	movhi	r4,3333
 d01e6dc:	2137cb04 	addi	r4,r4,-8404
 d01e6e0:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 d01e6e4:	e0bffe17 	ldw	r2,-8(fp)
 d01e6e8:	10800443 	ldbu	r2,17(r2)
 d01e6ec:	11403fcc 	andi	r5,r2,255
 d01e6f0:	01034174 	movhi	r4,3333
 d01e6f4:	2137d504 	addi	r4,r4,-8364
 d01e6f8:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 d01e6fc:	e0bffe17 	ldw	r2,-8(fp)
 d01e700:	10800483 	ldbu	r2,18(r2)
 d01e704:	11403fcc 	andi	r5,r2,255
 d01e708:	01034174 	movhi	r4,3333
 d01e70c:	2137df04 	addi	r4,r4,-8324
 d01e710:	d01a5480 	call	d01a548 <no_printf>
    tse_dprintf(6, "\n");
 d01e714:	01034174 	movhi	r4,3333
 d01e718:	21361004 	addi	r4,r4,-10176
 d01e71c:	d01a5480 	call	d01a548 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d01e720:	e17ffa03 	ldbu	r5,-24(fp)
 d01e724:	e13ffe17 	ldw	r4,-8(fp)
 d01e728:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 d01e72c:	e0bffd17 	ldw	r2,-12(fp)
 d01e730:	e0bfff15 	stw	r2,-4(fp)
 d01e734:	e0bfff17 	ldw	r2,-4(fp)
    
}
 d01e738:	e037883a 	mov	sp,fp
 d01e73c:	dfc00117 	ldw	ra,4(sp)
 d01e740:	df000017 	ldw	fp,0(sp)
 d01e744:	dec00204 	addi	sp,sp,8
 d01e748:	f800283a 	ret

0d01e74c <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 d01e74c:	defff704 	addi	sp,sp,-36
 d01e750:	dfc00815 	stw	ra,32(sp)
 d01e754:	df000715 	stw	fp,28(sp)
 d01e758:	df000704 	addi	fp,sp,28
 d01e75c:	e13ffe15 	stw	r4,-8(fp)
 d01e760:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d01e764:	e0bffe17 	ldw	r2,-8(fp)
 d01e768:	10800617 	ldw	r2,24(r2)
 d01e76c:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d01e770:	e0bffc17 	ldw	r2,-16(fp)
 d01e774:	10800317 	ldw	r2,12(r2)
 d01e778:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01e77c:	e13ffc17 	ldw	r4,-16(fp)
 d01e780:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01e784:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01e788:	e13ffb17 	ldw	r4,-20(fp)
 d01e78c:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01e790:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d01e794:	e13ffe17 	ldw	r4,-8(fp)
 d01e798:	d01c8980 	call	d01c898 <alt_tse_phy_rd_mdio_addr>
 d01e79c:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d01e7a0:	e0bffe17 	ldw	r2,-8(fp)
 d01e7a4:	10800003 	ldbu	r2,0(r2)
 d01e7a8:	11403fcc 	andi	r5,r2,255
 d01e7ac:	e13ffe17 	ldw	r4,-8(fp)
 d01e7b0:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 d01e7b4:	e0bfff03 	ldbu	r2,-4(fp)
 d01e7b8:	1005003a 	cmpeq	r2,r2,zero
 d01e7bc:	1000271e 	bne	r2,zero,d01e85c <alt_tse_phy_set_adv_1000+0x110>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 d01e7c0:	e13ffe17 	ldw	r4,-8(fp)
 d01e7c4:	014003c4 	movi	r5,15
 d01e7c8:	01800344 	movi	r6,13
 d01e7cc:	01c00044 	movi	r7,1
 d01e7d0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e7d4:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 d01e7d8:	e0bffd03 	ldbu	r2,-12(fp)
 d01e7dc:	d8800015 	stw	r2,0(sp)
 d01e7e0:	e13ffe17 	ldw	r4,-8(fp)
 d01e7e4:	01400244 	movi	r5,9
 d01e7e8:	01800244 	movi	r6,9
 d01e7ec:	01c00044 	movi	r7,1
 d01e7f0:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d01e7f4:	e17ffa47 	ldb	r5,-23(fp)
 d01e7f8:	e1bffa87 	ldb	r6,-22(fp)
 d01e7fc:	e1fffd03 	ldbu	r7,-12(fp)
 d01e800:	01034174 	movhi	r4,3333
 d01e804:	2137e904 	addi	r4,r4,-8284
 d01e808:	d01a5480 	call	d01a548 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 d01e80c:	e13ffe17 	ldw	r4,-8(fp)
 d01e810:	014003c4 	movi	r5,15
 d01e814:	01800304 	movi	r6,12
 d01e818:	01c00044 	movi	r7,1
 d01e81c:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e820:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 d01e824:	e0bffd03 	ldbu	r2,-12(fp)
 d01e828:	d8800015 	stw	r2,0(sp)
 d01e82c:	e13ffe17 	ldw	r4,-8(fp)
 d01e830:	01400244 	movi	r5,9
 d01e834:	01800204 	movi	r6,8
 d01e838:	01c00044 	movi	r7,1
 d01e83c:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d01e840:	e17ffa47 	ldb	r5,-23(fp)
 d01e844:	e1bffa87 	ldb	r6,-22(fp)
 d01e848:	e1fffd03 	ldbu	r7,-12(fp)
 d01e84c:	01034174 	movhi	r4,3333
 d01e850:	2137fc04 	addi	r4,r4,-8208
 d01e854:	d01a5480 	call	d01a548 <no_printf>
 d01e858:	00001806 	br	d01e8bc <alt_tse_phy_set_adv_1000+0x170>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 d01e85c:	d8000015 	stw	zero,0(sp)
 d01e860:	e13ffe17 	ldw	r4,-8(fp)
 d01e864:	01400244 	movi	r5,9
 d01e868:	01800244 	movi	r6,9
 d01e86c:	01c00044 	movi	r7,1
 d01e870:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d01e874:	e17ffa47 	ldb	r5,-23(fp)
 d01e878:	e1bffa87 	ldb	r6,-22(fp)
 d01e87c:	01034174 	movhi	r4,3333
 d01e880:	2137e904 	addi	r4,r4,-8284
 d01e884:	000f883a 	mov	r7,zero
 d01e888:	d01a5480 	call	d01a548 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 d01e88c:	d8000015 	stw	zero,0(sp)
 d01e890:	e13ffe17 	ldw	r4,-8(fp)
 d01e894:	01400244 	movi	r5,9
 d01e898:	01800204 	movi	r6,8
 d01e89c:	01c00044 	movi	r7,1
 d01e8a0:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d01e8a4:	e17ffa47 	ldb	r5,-23(fp)
 d01e8a8:	e1bffa87 	ldb	r6,-22(fp)
 d01e8ac:	01034174 	movhi	r4,3333
 d01e8b0:	21380f04 	addi	r4,r4,-8132
 d01e8b4:	000f883a 	mov	r7,zero
 d01e8b8:	d01a5480 	call	d01a548 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 d01e8bc:	e17ffa03 	ldbu	r5,-24(fp)
 d01e8c0:	e13ffe17 	ldw	r4,-8(fp)
 d01e8c4:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 d01e8c8:	0005883a 	mov	r2,zero
}
 d01e8cc:	e037883a 	mov	sp,fp
 d01e8d0:	dfc00117 	ldw	ra,4(sp)
 d01e8d4:	df000017 	ldw	fp,0(sp)
 d01e8d8:	dec00204 	addi	sp,sp,8
 d01e8dc:	f800283a 	ret

0d01e8e0 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 d01e8e0:	defff704 	addi	sp,sp,-36
 d01e8e4:	dfc00815 	stw	ra,32(sp)
 d01e8e8:	df000715 	stw	fp,28(sp)
 d01e8ec:	df000704 	addi	fp,sp,28
 d01e8f0:	e13ffe15 	stw	r4,-8(fp)
 d01e8f4:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d01e8f8:	e0bffe17 	ldw	r2,-8(fp)
 d01e8fc:	10800617 	ldw	r2,24(r2)
 d01e900:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d01e904:	e0bffc17 	ldw	r2,-16(fp)
 d01e908:	10800317 	ldw	r2,12(r2)
 d01e90c:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01e910:	e13ffc17 	ldw	r4,-16(fp)
 d01e914:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01e918:	e0bffa85 	stb	r2,-22(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01e91c:	e13ffb17 	ldw	r4,-20(fp)
 d01e920:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01e924:	e0bffa45 	stb	r2,-23(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d01e928:	e13ffe17 	ldw	r4,-8(fp)
 d01e92c:	d01c8980 	call	d01c898 <alt_tse_phy_rd_mdio_addr>
 d01e930:	e0bffa05 	stb	r2,-24(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d01e934:	e0bffe17 	ldw	r2,-8(fp)
 d01e938:	10800003 	ldbu	r2,0(r2)
 d01e93c:	11403fcc 	andi	r5,r2,255
 d01e940:	e13ffe17 	ldw	r4,-8(fp)
 d01e944:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 d01e948:	e0bfff03 	ldbu	r2,-4(fp)
 d01e94c:	1005003a 	cmpeq	r2,r2,zero
 d01e950:	10003a1e 	bne	r2,zero,d01ea3c <alt_tse_phy_set_adv_100+0x15c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 d01e954:	e13ffe17 	ldw	r4,-8(fp)
 d01e958:	01400044 	movi	r5,1
 d01e95c:	018003c4 	movi	r6,15
 d01e960:	01c00044 	movi	r7,1
 d01e964:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e968:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 d01e96c:	e0bffd03 	ldbu	r2,-12(fp)
 d01e970:	d8800015 	stw	r2,0(sp)
 d01e974:	e13ffe17 	ldw	r4,-8(fp)
 d01e978:	01400104 	movi	r5,4
 d01e97c:	01800244 	movi	r6,9
 d01e980:	01c00044 	movi	r7,1
 d01e984:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 d01e988:	e17ffa47 	ldb	r5,-23(fp)
 d01e98c:	e1bffa87 	ldb	r6,-22(fp)
 d01e990:	e1fffd03 	ldbu	r7,-12(fp)
 d01e994:	01034174 	movhi	r4,3333
 d01e998:	21382104 	addi	r4,r4,-8060
 d01e99c:	d01a5480 	call	d01a548 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 d01e9a0:	e13ffe17 	ldw	r4,-8(fp)
 d01e9a4:	01400044 	movi	r5,1
 d01e9a8:	01800384 	movi	r6,14
 d01e9ac:	01c00044 	movi	r7,1
 d01e9b0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01e9b4:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 d01e9b8:	e0bffd03 	ldbu	r2,-12(fp)
 d01e9bc:	d8800015 	stw	r2,0(sp)
 d01e9c0:	e13ffe17 	ldw	r4,-8(fp)
 d01e9c4:	01400104 	movi	r5,4
 d01e9c8:	01800204 	movi	r6,8
 d01e9cc:	01c00044 	movi	r7,1
 d01e9d0:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d01e9d4:	e17ffa47 	ldb	r5,-23(fp)
 d01e9d8:	e1bffa87 	ldb	r6,-22(fp)
 d01e9dc:	e1fffd03 	ldbu	r7,-12(fp)
 d01e9e0:	01034174 	movhi	r4,3333
 d01e9e4:	21383104 	addi	r4,r4,-7996
 d01e9e8:	d01a5480 	call	d01a548 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 d01e9ec:	e13ffe17 	ldw	r4,-8(fp)
 d01e9f0:	01400044 	movi	r5,1
 d01e9f4:	01800344 	movi	r6,13
 d01e9f8:	01c00044 	movi	r7,1
 d01e9fc:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01ea00:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 d01ea04:	e0bffd03 	ldbu	r2,-12(fp)
 d01ea08:	d8800015 	stw	r2,0(sp)
 d01ea0c:	e13ffe17 	ldw	r4,-8(fp)
 d01ea10:	01400104 	movi	r5,4
 d01ea14:	018001c4 	movi	r6,7
 d01ea18:	01c00044 	movi	r7,1
 d01ea1c:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d01ea20:	e17ffa47 	ldb	r5,-23(fp)
 d01ea24:	e1bffa87 	ldb	r6,-22(fp)
 d01ea28:	e1fffd03 	ldbu	r7,-12(fp)
 d01ea2c:	01034174 	movhi	r4,3333
 d01ea30:	21384404 	addi	r4,r4,-7920
 d01ea34:	d01a5480 	call	d01a548 <no_printf>
 d01ea38:	00002406 	br	d01eacc <alt_tse_phy_set_adv_100+0x1ec>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 d01ea3c:	d8000015 	stw	zero,0(sp)
 d01ea40:	e13ffe17 	ldw	r4,-8(fp)
 d01ea44:	01400104 	movi	r5,4
 d01ea48:	01800244 	movi	r6,9
 d01ea4c:	01c00044 	movi	r7,1
 d01ea50:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 d01ea54:	e17ffa47 	ldb	r5,-23(fp)
 d01ea58:	e1bffa87 	ldb	r6,-22(fp)
 d01ea5c:	01034174 	movhi	r4,3333
 d01ea60:	21382104 	addi	r4,r4,-8060
 d01ea64:	000f883a 	mov	r7,zero
 d01ea68:	d01a5480 	call	d01a548 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 d01ea6c:	d8000015 	stw	zero,0(sp)
 d01ea70:	e13ffe17 	ldw	r4,-8(fp)
 d01ea74:	01400104 	movi	r5,4
 d01ea78:	01800204 	movi	r6,8
 d01ea7c:	01c00044 	movi	r7,1
 d01ea80:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d01ea84:	e17ffa47 	ldb	r5,-23(fp)
 d01ea88:	e1bffa87 	ldb	r6,-22(fp)
 d01ea8c:	01034174 	movhi	r4,3333
 d01ea90:	21383104 	addi	r4,r4,-7996
 d01ea94:	000f883a 	mov	r7,zero
 d01ea98:	d01a5480 	call	d01a548 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 d01ea9c:	d8000015 	stw	zero,0(sp)
 d01eaa0:	e13ffe17 	ldw	r4,-8(fp)
 d01eaa4:	01400104 	movi	r5,4
 d01eaa8:	018001c4 	movi	r6,7
 d01eaac:	01c00044 	movi	r7,1
 d01eab0:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d01eab4:	e17ffa47 	ldb	r5,-23(fp)
 d01eab8:	e1bffa87 	ldb	r6,-22(fp)
 d01eabc:	01034174 	movhi	r4,3333
 d01eac0:	21384404 	addi	r4,r4,-7920
 d01eac4:	000f883a 	mov	r7,zero
 d01eac8:	d01a5480 	call	d01a548 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 d01eacc:	e17ffa03 	ldbu	r5,-24(fp)
 d01ead0:	e13ffe17 	ldw	r4,-8(fp)
 d01ead4:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 d01ead8:	0005883a 	mov	r2,zero
}
 d01eadc:	e037883a 	mov	sp,fp
 d01eae0:	dfc00117 	ldw	ra,4(sp)
 d01eae4:	df000017 	ldw	fp,0(sp)
 d01eae8:	dec00204 	addi	sp,sp,8
 d01eaec:	f800283a 	ret

0d01eaf0 <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 d01eaf0:	defff504 	addi	sp,sp,-44
 d01eaf4:	dfc00a15 	stw	ra,40(sp)
 d01eaf8:	df000915 	stw	fp,36(sp)
 d01eafc:	df000904 	addi	fp,sp,36
 d01eb00:	e13ffe15 	stw	r4,-8(fp)
 d01eb04:	e17fff05 	stb	r5,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 d01eb08:	e0bffe17 	ldw	r2,-8(fp)
 d01eb0c:	10800617 	ldw	r2,24(r2)
 d01eb10:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 d01eb14:	e0bffc17 	ldw	r2,-16(fp)
 d01eb18:	10800317 	ldw	r2,12(r2)
 d01eb1c:	e0bffb15 	stw	r2,-20(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01eb20:	e13ffc17 	ldw	r4,-16(fp)
 d01eb24:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01eb28:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01eb2c:	e13ffb17 	ldw	r4,-20(fp)
 d01eb30:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01eb34:	e0bff915 	stw	r2,-28(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 d01eb38:	e13ffe17 	ldw	r4,-8(fp)
 d01eb3c:	d01c8980 	call	d01c898 <alt_tse_phy_rd_mdio_addr>
 d01eb40:	e0bff815 	stw	r2,-32(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d01eb44:	e0bffe17 	ldw	r2,-8(fp)
 d01eb48:	10800003 	ldbu	r2,0(r2)
 d01eb4c:	11403fcc 	andi	r5,r2,255
 d01eb50:	e13ffe17 	ldw	r4,-8(fp)
 d01eb54:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 d01eb58:	e0bfff03 	ldbu	r2,-4(fp)
 d01eb5c:	1005003a 	cmpeq	r2,r2,zero
 d01eb60:	1000271e 	bne	r2,zero,d01ec00 <alt_tse_phy_set_adv_10+0x110>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 d01eb64:	e13ffe17 	ldw	r4,-8(fp)
 d01eb68:	01400044 	movi	r5,1
 d01eb6c:	01800304 	movi	r6,12
 d01eb70:	01c00044 	movi	r7,1
 d01eb74:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01eb78:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 d01eb7c:	e0bffd03 	ldbu	r2,-12(fp)
 d01eb80:	d8800015 	stw	r2,0(sp)
 d01eb84:	e13ffe17 	ldw	r4,-8(fp)
 d01eb88:	01400104 	movi	r5,4
 d01eb8c:	01800184 	movi	r6,6
 d01eb90:	01c00044 	movi	r7,1
 d01eb94:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d01eb98:	e1fffd03 	ldbu	r7,-12(fp)
 d01eb9c:	01034174 	movhi	r4,3333
 d01eba0:	21385704 	addi	r4,r4,-7844
 d01eba4:	e17ff917 	ldw	r5,-28(fp)
 d01eba8:	e1bffa17 	ldw	r6,-24(fp)
 d01ebac:	d01a5480 	call	d01a548 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 d01ebb0:	e13ffe17 	ldw	r4,-8(fp)
 d01ebb4:	01400044 	movi	r5,1
 d01ebb8:	018002c4 	movi	r6,11
 d01ebbc:	01c00044 	movi	r7,1
 d01ebc0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01ebc4:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 d01ebc8:	e0bffd03 	ldbu	r2,-12(fp)
 d01ebcc:	d8800015 	stw	r2,0(sp)
 d01ebd0:	e13ffe17 	ldw	r4,-8(fp)
 d01ebd4:	01400104 	movi	r5,4
 d01ebd8:	01800144 	movi	r6,5
 d01ebdc:	01c00044 	movi	r7,1
 d01ebe0:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 d01ebe4:	e1fffd03 	ldbu	r7,-12(fp)
 d01ebe8:	01034174 	movhi	r4,3333
 d01ebec:	21386a04 	addi	r4,r4,-7768
 d01ebf0:	e17ff917 	ldw	r5,-28(fp)
 d01ebf4:	e1bffa17 	ldw	r6,-24(fp)
 d01ebf8:	d01a5480 	call	d01a548 <no_printf>
 d01ebfc:	00001806 	br	d01ec60 <alt_tse_phy_set_adv_10+0x170>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 d01ec00:	d8000015 	stw	zero,0(sp)
 d01ec04:	e13ffe17 	ldw	r4,-8(fp)
 d01ec08:	01400104 	movi	r5,4
 d01ec0c:	01800184 	movi	r6,6
 d01ec10:	01c00044 	movi	r7,1
 d01ec14:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d01ec18:	01034174 	movhi	r4,3333
 d01ec1c:	21385704 	addi	r4,r4,-7844
 d01ec20:	e17ff917 	ldw	r5,-28(fp)
 d01ec24:	e1bffa17 	ldw	r6,-24(fp)
 d01ec28:	000f883a 	mov	r7,zero
 d01ec2c:	d01a5480 	call	d01a548 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 d01ec30:	d8000015 	stw	zero,0(sp)
 d01ec34:	e13ffe17 	ldw	r4,-8(fp)
 d01ec38:	01400104 	movi	r5,4
 d01ec3c:	01800144 	movi	r6,5
 d01ec40:	01c00044 	movi	r7,1
 d01ec44:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 d01ec48:	01034174 	movhi	r4,3333
 d01ec4c:	21386a04 	addi	r4,r4,-7768
 d01ec50:	e17ff917 	ldw	r5,-28(fp)
 d01ec54:	e1bffa17 	ldw	r6,-24(fp)
 d01ec58:	000f883a 	mov	r7,zero
 d01ec5c:	d01a5480 	call	d01a548 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 d01ec60:	e0bff817 	ldw	r2,-32(fp)
 d01ec64:	11403fcc 	andi	r5,r2,255
 d01ec68:	e13ffe17 	ldw	r4,-8(fp)
 d01ec6c:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 d01ec70:	0005883a 	mov	r2,zero
}
 d01ec74:	e037883a 	mov	sp,fp
 d01ec78:	dfc00117 	ldw	ra,4(sp)
 d01ec7c:	df000017 	ldw	fp,0(sp)
 d01ec80:	dec00204 	addi	sp,sp,8
 d01ec84:	f800283a 	ret

0d01ec88 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 d01ec88:	defff604 	addi	sp,sp,-40
 d01ec8c:	dfc00915 	stw	ra,36(sp)
 d01ec90:	df000815 	stw	fp,32(sp)
 d01ec94:	df000804 	addi	fp,sp,32
 d01ec98:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 d01ec9c:	00800044 	movi	r2,1
 d01eca0:	e0bffd85 	stb	r2,-10(fp)
	alt_u8 common_100 = 1;
 d01eca4:	00800044 	movi	r2,1
 d01eca8:	e0bffd45 	stb	r2,-11(fp)
	alt_u8 common_10 = 1;
 d01ecac:	00800044 	movi	r2,1
 d01ecb0:	e0bffd05 	stb	r2,-12(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 d01ecb4:	00800044 	movi	r2,1
 d01ecb8:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 d01ecbc:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_phy_info *pphy = 0;
 d01ecc0:	e03ff915 	stw	zero,-28(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01ecc4:	e13fff17 	ldw	r4,-4(fp)
 d01ecc8:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01eccc:	e0bff805 	stb	r2,-32(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 d01ecd0:	e03ffe15 	stw	zero,-8(fp)
 d01ecd4:	00001d06 	br	d01ed4c <alt_tse_phy_get_common_speed+0xc4>
        pmac_info = pmac_group->pmac_info[i];
 d01ecd8:	e0bffe17 	ldw	r2,-8(fp)
 d01ecdc:	e0ffff17 	ldw	r3,-4(fp)
 d01ece0:	1085883a 	add	r2,r2,r2
 d01ece4:	1085883a 	add	r2,r2,r2
 d01ece8:	10c5883a 	add	r2,r2,r3
 d01ecec:	10800104 	addi	r2,r2,4
 d01ecf0:	10800017 	ldw	r2,0(r2)
 d01ecf4:	e0bffa15 	stw	r2,-24(fp)
        pphy = pmac_info->pphy_info;
 d01ecf8:	e0bffa17 	ldw	r2,-24(fp)
 d01ecfc:	10800117 	ldw	r2,4(r2)
 d01ed00:	e0bff915 	stw	r2,-28(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 d01ed04:	e0bff917 	ldw	r2,-28(fp)
 d01ed08:	1005003a 	cmpeq	r2,r2,zero
 d01ed0c:	1000091e 	bne	r2,zero,d01ed34 <alt_tse_phy_get_common_speed+0xac>
            alt_tse_phy_set_adv_1000(pphy, 1);
 d01ed10:	e13ff917 	ldw	r4,-28(fp)
 d01ed14:	01400044 	movi	r5,1
 d01ed18:	d01e74c0 	call	d01e74c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 d01ed1c:	e13ff917 	ldw	r4,-28(fp)
 d01ed20:	01400044 	movi	r5,1
 d01ed24:	d01e8e00 	call	d01e8e0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 d01ed28:	e13ff917 	ldw	r4,-28(fp)
 d01ed2c:	01400044 	movi	r5,1
 d01ed30:	d01eaf00 	call	d01eaf0 <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 d01ed34:	01034174 	movhi	r4,3333
 d01ed38:	21361004 	addi	r4,r4,-10176
 d01ed3c:	d01a5480 	call	d01a548 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 d01ed40:	e0bffe17 	ldw	r2,-8(fp)
 d01ed44:	10800044 	addi	r2,r2,1
 d01ed48:	e0bffe15 	stw	r2,-8(fp)
 d01ed4c:	e0bfff17 	ldw	r2,-4(fp)
 d01ed50:	10800003 	ldbu	r2,0(r2)
 d01ed54:	10c03fcc 	andi	r3,r2,255
 d01ed58:	e0bffe17 	ldw	r2,-8(fp)
 d01ed5c:	10ffde16 	blt	r2,r3,d01ecd8 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 d01ed60:	e03ffe15 	stw	zero,-8(fp)
 d01ed64:	00005406 	br	d01eeb8 <alt_tse_phy_get_common_speed+0x230>

        pmac_info = pmac_group->pmac_info[i];
 d01ed68:	e0bffe17 	ldw	r2,-8(fp)
 d01ed6c:	e0ffff17 	ldw	r3,-4(fp)
 d01ed70:	1085883a 	add	r2,r2,r2
 d01ed74:	1085883a 	add	r2,r2,r2
 d01ed78:	10c5883a 	add	r2,r2,r3
 d01ed7c:	10800104 	addi	r2,r2,4
 d01ed80:	10800017 	ldw	r2,0(r2)
 d01ed84:	e0bffa15 	stw	r2,-24(fp)
        pphy = pmac_info->pphy_info;
 d01ed88:	e0bffa17 	ldw	r2,-24(fp)
 d01ed8c:	10800117 	ldw	r2,4(r2)
 d01ed90:	e0bff915 	stw	r2,-28(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 d01ed94:	e0bff917 	ldw	r2,-28(fp)
 d01ed98:	1005003a 	cmpeq	r2,r2,zero
 d01ed9c:	1000431e 	bne	r2,zero,d01eeac <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 d01eda0:	e13ff917 	ldw	r4,-28(fp)
 d01eda4:	d01e20c0 	call	d01e20c <alt_tse_phy_get_cap>
 d01eda8:	1004c03a 	cmpne	r2,r2,zero
 d01edac:	10003f1e 	bne	r2,zero,d01eeac <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 d01edb0:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 d01edb4:	e0bffa17 	ldw	r2,-24(fp)
 d01edb8:	10800003 	ldbu	r2,0(r2)
 d01edbc:	10803fcc 	andi	r2,r2,255
 d01edc0:	10800058 	cmpnei	r2,r2,1
 d01edc4:	1000021e 	bne	r2,zero,d01edd0 <alt_tse_phy_get_common_speed+0x148>
            common_1000 = 0;
 d01edc8:	e03ffd85 	stb	zero,-10(fp)
 d01edcc:	00000706 	br	d01edec <alt_tse_phy_get_common_speed+0x164>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 d01edd0:	e0bffa17 	ldw	r2,-24(fp)
 d01edd4:	10800003 	ldbu	r2,0(r2)
 d01edd8:	10803fcc 	andi	r2,r2,255
 d01eddc:	10800098 	cmpnei	r2,r2,2
 d01ede0:	1000021e 	bne	r2,zero,d01edec <alt_tse_phy_get_common_speed+0x164>
            common_100 = 0;
 d01ede4:	e03ffd45 	stb	zero,-11(fp)
            common_10 = 0;            
 d01ede8:	e03ffd05 	stb	zero,-12(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 d01edec:	e0bff917 	ldw	r2,-28(fp)
 d01edf0:	10c000c3 	ldbu	r3,3(r2)
 d01edf4:	e0bff917 	ldw	r2,-28(fp)
 d01edf8:	10800303 	ldbu	r2,12(r2)
 d01edfc:	1884703a 	and	r2,r3,r2
 d01ee00:	1007883a 	mov	r3,r2
 d01ee04:	e0bffd83 	ldbu	r2,-10(fp)
 d01ee08:	10c4703a 	and	r2,r2,r3
 d01ee0c:	e0bffd85 	stb	r2,-10(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 d01ee10:	e0bff917 	ldw	r2,-28(fp)
 d01ee14:	10c00183 	ldbu	r3,6(r2)
 d01ee18:	e0bff917 	ldw	r2,-28(fp)
 d01ee1c:	108003c3 	ldbu	r2,15(r2)
 d01ee20:	1884703a 	and	r2,r3,r2
 d01ee24:	1009883a 	mov	r4,r2
 d01ee28:	e0bff917 	ldw	r2,-28(fp)
 d01ee2c:	10c001c3 	ldbu	r3,7(r2)
 d01ee30:	e0bff917 	ldw	r2,-28(fp)
 d01ee34:	10800403 	ldbu	r2,16(r2)
 d01ee38:	1884703a 	and	r2,r3,r2
 d01ee3c:	2084b03a 	or	r2,r4,r2
 d01ee40:	1009883a 	mov	r4,r2
 d01ee44:	e0bff917 	ldw	r2,-28(fp)
 d01ee48:	10c00143 	ldbu	r3,5(r2)
 d01ee4c:	e0bff917 	ldw	r2,-28(fp)
 d01ee50:	10800383 	ldbu	r2,14(r2)
 d01ee54:	1884703a 	and	r2,r3,r2
 d01ee58:	2084b03a 	or	r2,r4,r2
 d01ee5c:	1007883a 	mov	r3,r2
 d01ee60:	e0bffd43 	ldbu	r2,-11(fp)
 d01ee64:	10c4703a 	and	r2,r2,r3
 d01ee68:	e0bffd45 	stb	r2,-11(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 d01ee6c:	e0bff917 	ldw	r2,-28(fp)
 d01ee70:	10c00283 	ldbu	r3,10(r2)
 d01ee74:	e0bff917 	ldw	r2,-28(fp)
 d01ee78:	10800443 	ldbu	r2,17(r2)
 d01ee7c:	1884703a 	and	r2,r3,r2
 d01ee80:	1009883a 	mov	r4,r2
 d01ee84:	e0bff917 	ldw	r2,-28(fp)
 d01ee88:	10c002c3 	ldbu	r3,11(r2)
 d01ee8c:	e0bff917 	ldw	r2,-28(fp)
 d01ee90:	10800483 	ldbu	r2,18(r2)
 d01ee94:	1884703a 	and	r2,r3,r2
 d01ee98:	2084b03a 	or	r2,r4,r2
 d01ee9c:	1007883a 	mov	r3,r2
 d01eea0:	e0bffd03 	ldbu	r2,-12(fp)
 d01eea4:	10c4703a 	and	r2,r2,r3
 d01eea8:	e0bffd05 	stb	r2,-12(fp)
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 d01eeac:	e0bffe17 	ldw	r2,-8(fp)
 d01eeb0:	10800044 	addi	r2,r2,1
 d01eeb4:	e0bffe15 	stw	r2,-8(fp)
 d01eeb8:	e0bfff17 	ldw	r2,-4(fp)
 d01eebc:	10800003 	ldbu	r2,0(r2)
 d01eec0:	10c03fcc 	andi	r3,r2,255
 d01eec4:	e0bffe17 	ldw	r2,-8(fp)
 d01eec8:	10ffa716 	blt	r2,r3,d01ed68 <alt_tse_phy_get_common_speed+0xe0>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 d01eecc:	e0bffb03 	ldbu	r2,-20(fp)
 d01eed0:	10800058 	cmpnei	r2,r2,1
 d01eed4:	1000071e 	bne	r2,zero,d01eef4 <alt_tse_phy_get_common_speed+0x26c>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 d01eed8:	00bfffc4 	movi	r2,-1
 d01eedc:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 d01eee0:	e17ff807 	ldb	r5,-32(fp)
 d01eee4:	01034174 	movhi	r4,3333
 d01eee8:	21387d04 	addi	r4,r4,-7692
 d01eeec:	d0029980 	call	d002998 <printf>
 d01eef0:	00002606 	br	d01ef8c <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_1000) {
 d01eef4:	e0bffd83 	ldbu	r2,-10(fp)
 d01eef8:	1005003a 	cmpeq	r2,r2,zero
 d01eefc:	1000081e 	bne	r2,zero,d01ef20 <alt_tse_phy_get_common_speed+0x298>
        common_speed = TSE_PHY_SPEED_1000;
 d01ef00:	00800084 	movi	r2,2
 d01ef04:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 d01ef08:	e17ff807 	ldb	r5,-32(fp)
 d01ef0c:	01034174 	movhi	r4,3333
 d01ef10:	21388f04 	addi	r4,r4,-7620
 d01ef14:	0180fa04 	movi	r6,1000
 d01ef18:	d0029980 	call	d002998 <printf>
 d01ef1c:	00001b06 	br	d01ef8c <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_100) {
 d01ef20:	e0bffd43 	ldbu	r2,-11(fp)
 d01ef24:	1005003a 	cmpeq	r2,r2,zero
 d01ef28:	1000081e 	bne	r2,zero,d01ef4c <alt_tse_phy_get_common_speed+0x2c4>
        common_speed = TSE_PHY_SPEED_100;
 d01ef2c:	00800044 	movi	r2,1
 d01ef30:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 d01ef34:	e17ff807 	ldb	r5,-32(fp)
 d01ef38:	01034174 	movhi	r4,3333
 d01ef3c:	21388f04 	addi	r4,r4,-7620
 d01ef40:	01801904 	movi	r6,100
 d01ef44:	d0029980 	call	d002998 <printf>
 d01ef48:	00001006 	br	d01ef8c <alt_tse_phy_get_common_speed+0x304>
    }
    else if(common_10) {
 d01ef4c:	e0bffd03 	ldbu	r2,-12(fp)
 d01ef50:	1005003a 	cmpeq	r2,r2,zero
 d01ef54:	1000071e 	bne	r2,zero,d01ef74 <alt_tse_phy_get_common_speed+0x2ec>
        common_speed = TSE_PHY_SPEED_10;
 d01ef58:	e03ffc15 	stw	zero,-16(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 d01ef5c:	e17ff807 	ldb	r5,-32(fp)
 d01ef60:	01034174 	movhi	r4,3333
 d01ef64:	21388f04 	addi	r4,r4,-7620
 d01ef68:	01800284 	movi	r6,10
 d01ef6c:	d0029980 	call	d002998 <printf>
 d01ef70:	00000606 	br	d01ef8c <alt_tse_phy_get_common_speed+0x304>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 d01ef74:	00bfffc4 	movi	r2,-1
 d01ef78:	e0bffc15 	stw	r2,-16(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 d01ef7c:	e17ff807 	ldb	r5,-32(fp)
 d01ef80:	01034174 	movhi	r4,3333
 d01ef84:	21389c04 	addi	r4,r4,-7568
 d01ef88:	d0029980 	call	d002998 <printf>

    return common_speed;
 d01ef8c:	e0bffc17 	ldw	r2,-16(fp)
}
 d01ef90:	e037883a 	mov	sp,fp
 d01ef94:	dfc00117 	ldw	ra,4(sp)
 d01ef98:	df000017 	ldw	fp,0(sp)
 d01ef9c:	dec00204 	addi	sp,sp,8
 d01efa0:	f800283a 	ret

0d01efa4 <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 d01efa4:	deffec04 	addi	sp,sp,-80
 d01efa8:	dfc01315 	stw	ra,76(sp)
 d01efac:	df001215 	stw	fp,72(sp)
 d01efb0:	dc401115 	stw	r17,68(sp)
 d01efb4:	dc001015 	stw	r16,64(sp)
 d01efb8:	df001004 	addi	fp,sp,64
 d01efbc:	e13ff915 	stw	r4,-28(fp)
 d01efc0:	e17ffa15 	stw	r5,-24(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 d01efc4:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 d01efc8:	e03ff515 	stw	zero,-44(fp)
    alt_tse_system_info *psys = 0;
 d01efcc:	e03ff415 	stw	zero,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 d01efd0:	e03ff345 	stb	zero,-51(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 d01efd4:	e13ff917 	ldw	r4,-28(fp)
 d01efd8:	d01b7100 	call	d01b710 <alt_tse_get_mac_group_index>
 d01efdc:	e0bff305 	stb	r2,-52(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 d01efe0:	e0bff917 	ldw	r2,-28(fp)
 d01efe4:	10800117 	ldw	r2,4(r2)
 d01efe8:	10800217 	ldw	r2,8(r2)
 d01efec:	10800017 	ldw	r2,0(r2)
 d01eff0:	e0bff215 	stw	r2,-56(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 d01eff4:	e0bff217 	ldw	r2,-56(fp)
 d01eff8:	10801004 	addi	r2,r2,64
 d01effc:	10800037 	ldwio	r2,0(r2)
 d01f000:	e0bff115 	stw	r2,-60(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 d01f004:	e0bffa17 	ldw	r2,-24(fp)
 d01f008:	1004803a 	cmplt	r2,r2,zero
 d01f00c:	1000031e 	bne	r2,zero,d01f01c <alt_tse_phy_set_common_speed+0x78>
 d01f010:	e0bffa17 	ldw	r2,-24(fp)
 d01f014:	108000d0 	cmplti	r2,r2,3
 d01f018:	10000d1e 	bne	r2,zero,d01f050 <alt_tse_phy_set_common_speed+0xac>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 d01f01c:	e17ff307 	ldb	r5,-52(fp)
 d01f020:	01034174 	movhi	r4,3333
 d01f024:	2138a904 	addi	r4,r4,-7516
 d01f028:	e1bffa17 	ldw	r6,-24(fp)
 d01f02c:	d0029980 	call	d002998 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 d01f030:	e0bff217 	ldw	r2,-56(fp)
 d01f034:	10801004 	addi	r2,r2,64
 d01f038:	1007883a 	mov	r3,r2
 d01f03c:	e0bff117 	ldw	r2,-60(fp)
 d01f040:	18800035 	stwio	r2,0(r3)
        return TSE_PHY_SPEED_NO_COMMON;
 d01f044:	00bfffc4 	movi	r2,-1
 d01f048:	e0bfff15 	stw	r2,-4(fp)
 d01f04c:	00010606 	br	d01f468 <alt_tse_phy_set_common_speed+0x4c4>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 d01f050:	e03ff815 	stw	zero,-32(fp)
 d01f054:	0000dd06 	br	d01f3cc <alt_tse_phy_set_common_speed+0x428>
        pmac_info = pmac_group->pmac_info[i];
 d01f058:	e0bff817 	ldw	r2,-32(fp)
 d01f05c:	e0fff917 	ldw	r3,-28(fp)
 d01f060:	1085883a 	add	r2,r2,r2
 d01f064:	1085883a 	add	r2,r2,r2
 d01f068:	10c5883a 	add	r2,r2,r3
 d01f06c:	10800104 	addi	r2,r2,4
 d01f070:	10800017 	ldw	r2,0(r2)
 d01f074:	e0bff515 	stw	r2,-44(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 d01f078:	e13ff517 	ldw	r4,-44(fp)
 d01f07c:	d01b7900 	call	d01b790 <alt_tse_get_mac_info_index>
 d01f080:	e0bff345 	stb	r2,-51(fp)

        pphy = pmac_info->pphy_info;
 d01f084:	e0bff517 	ldw	r2,-44(fp)
 d01f088:	10800117 	ldw	r2,4(r2)
 d01f08c:	e0bff615 	stw	r2,-40(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 d01f090:	e0bff617 	ldw	r2,-40(fp)
 d01f094:	1005003a 	cmpeq	r2,r2,zero
 d01f098:	1000c91e 	bne	r2,zero,d01f3c0 <alt_tse_phy_set_common_speed+0x41c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 d01f09c:	e0bff517 	ldw	r2,-44(fp)
 d01f0a0:	10800217 	ldw	r2,8(r2)
 d01f0a4:	e0bff415 	stw	r2,-48(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 d01f0a8:	e0bff617 	ldw	r2,-40(fp)
 d01f0ac:	10800003 	ldbu	r2,0(r2)
 d01f0b0:	11403fcc 	andi	r5,r2,255
 d01f0b4:	e13ff617 	ldw	r4,-40(fp)
 d01f0b8:	d01c8e00 	call	d01c8e0 <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 d01f0bc:	e0bff617 	ldw	r2,-40(fp)
 d01f0c0:	108000c3 	ldbu	r2,3(r2)
 d01f0c4:	10803fcc 	andi	r2,r2,255
 d01f0c8:	1004c03a 	cmpne	r2,r2,zero
 d01f0cc:	10000f1e 	bne	r2,zero,d01f10c <alt_tse_phy_set_common_speed+0x168>
 d01f0d0:	e0bff617 	ldw	r2,-40(fp)
 d01f0d4:	10800103 	ldbu	r2,4(r2)
 d01f0d8:	10803fcc 	andi	r2,r2,255
 d01f0dc:	1004c03a 	cmpne	r2,r2,zero
 d01f0e0:	10000a1e 	bne	r2,zero,d01f10c <alt_tse_phy_set_common_speed+0x168>
 d01f0e4:	e0bff617 	ldw	r2,-40(fp)
 d01f0e8:	10800043 	ldbu	r2,1(r2)
 d01f0ec:	10803fcc 	andi	r2,r2,255
 d01f0f0:	1004c03a 	cmpne	r2,r2,zero
 d01f0f4:	1000051e 	bne	r2,zero,d01f10c <alt_tse_phy_set_common_speed+0x168>
 d01f0f8:	e0bff617 	ldw	r2,-40(fp)
 d01f0fc:	10800083 	ldbu	r2,2(r2)
 d01f100:	10803fcc 	andi	r2,r2,255
 d01f104:	1005003a 	cmpeq	r2,r2,zero
 d01f108:	1000031e 	bne	r2,zero,d01f118 <alt_tse_phy_set_common_speed+0x174>
 d01f10c:	00800044 	movi	r2,1
 d01f110:	e0bffe15 	stw	r2,-8(fp)
 d01f114:	00000106 	br	d01f11c <alt_tse_phy_set_common_speed+0x178>
 d01f118:	e03ffe15 	stw	zero,-8(fp)
 d01f11c:	e0bffe17 	ldw	r2,-8(fp)
 d01f120:	e0bff705 	stb	r2,-36(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 d01f124:	e0bff703 	ldbu	r2,-36(fp)
 d01f128:	1004c03a 	cmpne	r2,r2,zero
 d01f12c:	1000101e 	bne	r2,zero,d01f170 <alt_tse_phy_set_common_speed+0x1cc>
 d01f130:	e0bffa17 	ldw	r2,-24(fp)
 d01f134:	10800098 	cmpnei	r2,r2,2
 d01f138:	10000d1e 	bne	r2,zero,d01f170 <alt_tse_phy_set_common_speed+0x1cc>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 d01f13c:	e17ff307 	ldb	r5,-52(fp)
 d01f140:	e1bff347 	ldb	r6,-51(fp)
 d01f144:	01034174 	movhi	r4,3333
 d01f148:	2138bd04 	addi	r4,r4,-7436
 d01f14c:	d0029980 	call	d002998 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 d01f150:	e0bff217 	ldw	r2,-56(fp)
 d01f154:	10801004 	addi	r2,r2,64
 d01f158:	1007883a 	mov	r3,r2
 d01f15c:	e0bff117 	ldw	r2,-60(fp)
 d01f160:	18800035 	stwio	r2,0(r3)
            return TSE_PHY_SPEED_NO_COMMON;
 d01f164:	00bfffc4 	movi	r2,-1
 d01f168:	e0bfff15 	stw	r2,-4(fp)
 d01f16c:	0000be06 	br	d01f468 <alt_tse_phy_set_common_speed+0x4c4>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 d01f170:	e13ff617 	ldw	r4,-40(fp)
 d01f174:	01400044 	movi	r5,1
 d01f178:	018000c4 	movi	r6,3
 d01f17c:	01c00044 	movi	r7,1
 d01f180:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01f184:	1004c03a 	cmpne	r2,r2,zero
 d01f188:	1000151e 	bne	r2,zero,d01f1e0 <alt_tse_phy_set_common_speed+0x23c>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 d01f18c:	e0bff703 	ldbu	r2,-36(fp)
 d01f190:	1005003a 	cmpeq	r2,r2,zero
 d01f194:	1000091e 	bne	r2,zero,d01f1bc <alt_tse_phy_set_common_speed+0x218>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 d01f198:	e0bffa17 	ldw	r2,-24(fp)
 d01f19c:	1005d07a 	srai	r2,r2,1
 d01f1a0:	10bfffcc 	andi	r2,r2,65535
 d01f1a4:	d8800015 	stw	r2,0(sp)
 d01f1a8:	e13ff617 	ldw	r4,-40(fp)
 d01f1ac:	000b883a 	mov	r5,zero
 d01f1b0:	01800184 	movi	r6,6
 d01f1b4:	01c00044 	movi	r7,1
 d01f1b8:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 d01f1bc:	e0bffa17 	ldw	r2,-24(fp)
 d01f1c0:	10bfffcc 	andi	r2,r2,65535
 d01f1c4:	d8800015 	stw	r2,0(sp)
 d01f1c8:	e13ff617 	ldw	r4,-40(fp)
 d01f1cc:	000b883a 	mov	r5,zero
 d01f1d0:	01800344 	movi	r6,13
 d01f1d4:	01c00044 	movi	r7,1
 d01f1d8:	d01c9340 	call	d01c934 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 d01f1dc:	00007806 	br	d01f3c0 <alt_tse_phy_set_common_speed+0x41c>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 d01f1e0:	e0bffa17 	ldw	r2,-24(fp)
 d01f1e4:	10800098 	cmpnei	r2,r2,2
 d01f1e8:	10000a1e 	bne	r2,zero,d01f214 <alt_tse_phy_set_common_speed+0x270>
            alt_tse_phy_set_adv_1000(pphy, 1);
 d01f1ec:	e13ff617 	ldw	r4,-40(fp)
 d01f1f0:	01400044 	movi	r5,1
 d01f1f4:	d01e74c0 	call	d01e74c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 d01f1f8:	e13ff617 	ldw	r4,-40(fp)
 d01f1fc:	01400044 	movi	r5,1
 d01f200:	d01e8e00 	call	d01e8e0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 d01f204:	e13ff617 	ldw	r4,-40(fp)
 d01f208:	01400044 	movi	r5,1
 d01f20c:	d01eaf00 	call	d01eaf0 <alt_tse_phy_set_adv_10>
 d01f210:	00002306 	br	d01f2a0 <alt_tse_phy_set_common_speed+0x2fc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 d01f214:	e0bffa17 	ldw	r2,-24(fp)
 d01f218:	10800058 	cmpnei	r2,r2,1
 d01f21c:	10000a1e 	bne	r2,zero,d01f248 <alt_tse_phy_set_common_speed+0x2a4>
            alt_tse_phy_set_adv_1000(pphy, 0);
 d01f220:	e13ff617 	ldw	r4,-40(fp)
 d01f224:	000b883a 	mov	r5,zero
 d01f228:	d01e74c0 	call	d01e74c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 d01f22c:	e13ff617 	ldw	r4,-40(fp)
 d01f230:	01400044 	movi	r5,1
 d01f234:	d01e8e00 	call	d01e8e0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 d01f238:	e13ff617 	ldw	r4,-40(fp)
 d01f23c:	01400044 	movi	r5,1
 d01f240:	d01eaf00 	call	d01eaf0 <alt_tse_phy_set_adv_10>
 d01f244:	00001606 	br	d01f2a0 <alt_tse_phy_set_common_speed+0x2fc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 d01f248:	e0bffa17 	ldw	r2,-24(fp)
 d01f24c:	1004c03a 	cmpne	r2,r2,zero
 d01f250:	10000a1e 	bne	r2,zero,d01f27c <alt_tse_phy_set_common_speed+0x2d8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 d01f254:	e13ff617 	ldw	r4,-40(fp)
 d01f258:	000b883a 	mov	r5,zero
 d01f25c:	d01e74c0 	call	d01e74c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 d01f260:	e13ff617 	ldw	r4,-40(fp)
 d01f264:	000b883a 	mov	r5,zero
 d01f268:	d01e8e00 	call	d01e8e0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 d01f26c:	e13ff617 	ldw	r4,-40(fp)
 d01f270:	01400044 	movi	r5,1
 d01f274:	d01eaf00 	call	d01eaf0 <alt_tse_phy_set_adv_10>
 d01f278:	00000906 	br	d01f2a0 <alt_tse_phy_set_common_speed+0x2fc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 d01f27c:	e13ff617 	ldw	r4,-40(fp)
 d01f280:	000b883a 	mov	r5,zero
 d01f284:	d01e74c0 	call	d01e74c <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 d01f288:	e13ff617 	ldw	r4,-40(fp)
 d01f28c:	000b883a 	mov	r5,zero
 d01f290:	d01e8e00 	call	d01e8e0 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 d01f294:	e13ff617 	ldw	r4,-40(fp)
 d01f298:	000b883a 	mov	r5,zero
 d01f29c:	d01eaf00 	call	d01eaf0 <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 d01f2a0:	e13ff617 	ldw	r4,-40(fp)
 d01f2a4:	01400044 	movi	r5,1
 d01f2a8:	01800144 	movi	r6,5
 d01f2ac:	01c00044 	movi	r7,1
 d01f2b0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01f2b4:	10800058 	cmpnei	r2,r2,1
 d01f2b8:	1000341e 	bne	r2,zero,d01f38c <alt_tse_phy_set_common_speed+0x3e8>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 d01f2bc:	e0bff703 	ldbu	r2,-36(fp)
 d01f2c0:	1005003a 	cmpeq	r2,r2,zero
 d01f2c4:	10000d1e 	bne	r2,zero,d01f2fc <alt_tse_phy_set_common_speed+0x358>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 d01f2c8:	e0bff617 	ldw	r2,-40(fp)
 d01f2cc:	10800517 	ldw	r2,20(r2)
 d01f2d0:	10801583 	ldbu	r2,86(r2)
 d01f2d4:	11403fcc 	andi	r5,r2,255
 d01f2d8:	e0bff617 	ldw	r2,-40(fp)
 d01f2dc:	10800517 	ldw	r2,20(r2)
 d01f2e0:	108015c3 	ldbu	r2,87(r2)
 d01f2e4:	11803fcc 	andi	r6,r2,255
 d01f2e8:	e13ff617 	ldw	r4,-40(fp)
 d01f2ec:	01c00084 	movi	r7,2
 d01f2f0:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01f2f4:	e0bff785 	stb	r2,-34(fp)
 d01f2f8:	00000c06 	br	d01f32c <alt_tse_phy_set_common_speed+0x388>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 d01f2fc:	e0bff617 	ldw	r2,-40(fp)
 d01f300:	10800517 	ldw	r2,20(r2)
 d01f304:	10801583 	ldbu	r2,86(r2)
 d01f308:	11403fcc 	andi	r5,r2,255
 d01f30c:	e0bff617 	ldw	r2,-40(fp)
 d01f310:	10800517 	ldw	r2,20(r2)
 d01f314:	108015c3 	ldbu	r2,87(r2)
 d01f318:	11803fcc 	andi	r6,r2,255
 d01f31c:	e13ff617 	ldw	r4,-40(fp)
 d01f320:	01c00044 	movi	r7,1
 d01f324:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01f328:	e0bff785 	stb	r2,-34(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 d01f32c:	e0fff783 	ldbu	r3,-34(fp)
 d01f330:	e0bffa17 	ldw	r2,-24(fp)
 d01f334:	18800426 	beq	r3,r2,d01f348 <alt_tse_phy_set_common_speed+0x3a4>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 d01f338:	e13ff617 	ldw	r4,-40(fp)
 d01f33c:	01400134 	movhi	r5,4
 d01f340:	29742404 	addi	r5,r5,-12144
 d01f344:	d01df180 	call	d01df18 <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 d01f348:	e0bff617 	ldw	r2,-40(fp)
 d01f34c:	10800517 	ldw	r2,20(r2)
 d01f350:	10801583 	ldbu	r2,86(r2)
 d01f354:	11403fcc 	andi	r5,r2,255
 d01f358:	e0bff617 	ldw	r2,-40(fp)
 d01f35c:	10800517 	ldw	r2,20(r2)
 d01f360:	10801603 	ldbu	r2,88(r2)
 d01f364:	11803fcc 	andi	r6,r2,255
 d01f368:	e13ff617 	ldw	r4,-40(fp)
 d01f36c:	01c00044 	movi	r7,1
 d01f370:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01f374:	e0bff745 	stb	r2,-35(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 d01f378:	e0bff417 	ldw	r2,-48(fp)
 d01f37c:	10800017 	ldw	r2,0(r2)
 d01f380:	1009883a 	mov	r4,r2
 d01f384:	e17ff743 	ldbu	r5,-35(fp)
 d01f388:	d01b9e80 	call	d01b9e8 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 d01f38c:	e43ff307 	ldb	r16,-52(fp)
 d01f390:	e47ff347 	ldb	r17,-51(fp)
 d01f394:	e13ff617 	ldw	r4,-40(fp)
 d01f398:	01400044 	movi	r5,1
 d01f39c:	000d883a 	mov	r6,zero
 d01f3a0:	01c00404 	movi	r7,16
 d01f3a4:	d01ca5c0 	call	d01ca5c <alt_tse_phy_rd_mdio_reg>
 d01f3a8:	100f883a 	mov	r7,r2
 d01f3ac:	01034174 	movhi	r4,3333
 d01f3b0:	2138d404 	addi	r4,r4,-7344
 d01f3b4:	800b883a 	mov	r5,r16
 d01f3b8:	880d883a 	mov	r6,r17
 d01f3bc:	d0029980 	call	d002998 <printf>
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 d01f3c0:	e0bff817 	ldw	r2,-32(fp)
 d01f3c4:	10800044 	addi	r2,r2,1
 d01f3c8:	e0bff815 	stw	r2,-32(fp)
 d01f3cc:	e0bff917 	ldw	r2,-28(fp)
 d01f3d0:	10800003 	ldbu	r2,0(r2)
 d01f3d4:	10c03fcc 	andi	r3,r2,255
 d01f3d8:	e0bff817 	ldw	r2,-32(fp)
 d01f3dc:	10ff1e16 	blt	r2,r3,d01f058 <alt_tse_phy_set_common_speed+0xb4>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 d01f3e0:	e0bff307 	ldb	r2,-52(fp)
 d01f3e4:	e0bffd15 	stw	r2,-12(fp)
 d01f3e8:	e0bffa17 	ldw	r2,-24(fp)
 d01f3ec:	108000a0 	cmpeqi	r2,r2,2
 d01f3f0:	10000b1e 	bne	r2,zero,d01f420 <alt_tse_phy_set_common_speed+0x47c>
 d01f3f4:	e0bffa17 	ldw	r2,-24(fp)
 d01f3f8:	10800058 	cmpnei	r2,r2,1
 d01f3fc:	1000031e 	bne	r2,zero,d01f40c <alt_tse_phy_set_common_speed+0x468>
 d01f400:	00801904 	movi	r2,100
 d01f404:	e0bffb15 	stw	r2,-20(fp)
 d01f408:	00000206 	br	d01f414 <alt_tse_phy_set_common_speed+0x470>
 d01f40c:	00800284 	movi	r2,10
 d01f410:	e0bffb15 	stw	r2,-20(fp)
 d01f414:	e0bffb17 	ldw	r2,-20(fp)
 d01f418:	e0bffc15 	stw	r2,-16(fp)
 d01f41c:	00000206 	br	d01f428 <alt_tse_phy_set_common_speed+0x484>
 d01f420:	0080fa04 	movi	r2,1000
 d01f424:	e0bffc15 	stw	r2,-16(fp)
 d01f428:	01034174 	movhi	r4,3333
 d01f42c:	2138e004 	addi	r4,r4,-7296
 d01f430:	e17ffd17 	ldw	r5,-12(fp)
 d01f434:	e1bffc17 	ldw	r6,-16(fp)
 d01f438:	d0029980 	call	d002998 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 d01f43c:	e0bffa17 	ldw	r2,-24(fp)
 d01f440:	11403fcc 	andi	r5,r2,255
 d01f444:	e13ff217 	ldw	r4,-56(fp)
 d01f448:	d01b8fc0 	call	d01b8fc <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 d01f44c:	e0bff217 	ldw	r2,-56(fp)
 d01f450:	10801004 	addi	r2,r2,64
 d01f454:	1007883a 	mov	r3,r2
 d01f458:	e0bff117 	ldw	r2,-60(fp)
 d01f45c:	18800035 	stwio	r2,0(r3)
        
    return common_speed;
 d01f460:	e0bffa17 	ldw	r2,-24(fp)
 d01f464:	e0bfff15 	stw	r2,-4(fp)
 d01f468:	e0bfff17 	ldw	r2,-4(fp)
}
 d01f46c:	e037883a 	mov	sp,fp
 d01f470:	dfc00317 	ldw	ra,12(sp)
 d01f474:	df000217 	ldw	fp,8(sp)
 d01f478:	dc400117 	ldw	r17,4(sp)
 d01f47c:	dc000017 	ldw	r16,0(sp)
 d01f480:	dec00404 	addi	sp,sp,16
 d01f484:	f800283a 	ret

0d01f488 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 d01f488:	defffc04 	addi	sp,sp,-16
 d01f48c:	dfc00315 	stw	ra,12(sp)
 d01f490:	df000215 	stw	fp,8(sp)
 d01f494:	df000204 	addi	fp,sp,8
 d01f498:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 d01f49c:	e0bfff17 	ldw	r2,-4(fp)
 d01f4a0:	1080a104 	addi	r2,r2,644
 d01f4a4:	10800037 	ldwio	r2,0(r2)
 d01f4a8:	1080080c 	andi	r2,r2,32
 d01f4ac:	1004c03a 	cmpne	r2,r2,zero
 d01f4b0:	1000191e 	bne	r2,zero,d01f518 <marvell_phy_cfg+0x90>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 d01f4b4:	01034174 	movhi	r4,3333
 d01f4b8:	2138f104 	addi	r4,r4,-7228
 d01f4bc:	d002cc00 	call	d002cc0 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 d01f4c0:	e0bfff17 	ldw	r2,-4(fp)
 d01f4c4:	1080a004 	addi	r2,r2,640
 d01f4c8:	10801004 	addi	r2,r2,64
 d01f4cc:	1007883a 	mov	r3,r2
 d01f4d0:	00801e04 	movi	r2,120
 d01f4d4:	18800035 	stwio	r2,0(r3)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 d01f4d8:	01034174 	movhi	r4,3333
 d01f4dc:	2138fa04 	addi	r4,r4,-7192
 d01f4e0:	d002cc00 	call	d002cc0 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 d01f4e4:	e0bfff17 	ldw	r2,-4(fp)
 d01f4e8:	1080a004 	addi	r2,r2,640
 d01f4ec:	10800037 	ldwio	r2,0(r2)
 d01f4f0:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 d01f4f4:	e0bfff17 	ldw	r2,-4(fp)
 d01f4f8:	1080a004 	addi	r2,r2,640
 d01f4fc:	1009883a 	mov	r4,r2
 d01f500:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f504:	00a00004 	movi	r2,-32768
 d01f508:	1884b03a 	or	r2,r3,r2
 d01f50c:	10ffffcc 	andi	r3,r2,65535
 d01f510:	2005883a 	mov	r2,r4
 d01f514:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 d01f518:	0005883a 	mov	r2,zero
}
 d01f51c:	e037883a 	mov	sp,fp
 d01f520:	dfc00117 	ldw	ra,4(sp)
 d01f524:	df000017 	ldw	fp,0(sp)
 d01f528:	dec00204 	addi	sp,sp,8
 d01f52c:	f800283a 	ret

0d01f530 <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 d01f530:	defffc04 	addi	sp,sp,-16
 d01f534:	dfc00315 	stw	ra,12(sp)
 d01f538:	df000215 	stw	fp,8(sp)
 d01f53c:	df000204 	addi	fp,sp,8
 d01f540:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 d01f544:	e0bfff17 	ldw	r2,-4(fp)
 d01f548:	1080bb04 	addi	r2,r2,748
 d01f54c:	10800037 	ldwio	r2,0(r2)
 d01f550:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 d01f554:	00fffc04 	movi	r3,-16
 d01f558:	e0bffe0b 	ldhu	r2,-8(fp)
 d01f55c:	10c4703a 	and	r2,r2,r3
 d01f560:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 d01f564:	01034174 	movhi	r4,3333
 d01f568:	2138ff04 	addi	r4,r4,-7172
 d01f56c:	d002cc00 	call	d002cc0 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 d01f570:	e0bfff17 	ldw	r2,-4(fp)
 d01f574:	1080bb04 	addi	r2,r2,748
 d01f578:	1009883a 	mov	r4,r2
 d01f57c:	e0bffe0b 	ldhu	r2,-8(fp)
 d01f580:	108003d4 	ori	r2,r2,15
 d01f584:	10ffffcc 	andi	r3,r2,65535
 d01f588:	2005883a 	mov	r2,r4
 d01f58c:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 d01f590:	01034174 	movhi	r4,3333
 d01f594:	21390b04 	addi	r4,r4,-7124
 d01f598:	d002cc00 	call	d002cc0 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 d01f59c:	e0bfff17 	ldw	r2,-4(fp)
 d01f5a0:	1080b404 	addi	r2,r2,720
 d01f5a4:	10800037 	ldwio	r2,0(r2)
 d01f5a8:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 d01f5ac:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f5b0:	00bfdf44 	movi	r2,-131
 d01f5b4:	1884703a 	and	r2,r3,r2
 d01f5b8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 d01f5bc:	e0bfff17 	ldw	r2,-4(fp)
 d01f5c0:	1080b404 	addi	r2,r2,720
 d01f5c4:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f5c8:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 d01f5cc:	01034174 	movhi	r4,3333
 d01f5d0:	2138fa04 	addi	r4,r4,-7192
 d01f5d4:	d002cc00 	call	d002cc0 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 d01f5d8:	e0bfff17 	ldw	r2,-4(fp)
 d01f5dc:	1080a004 	addi	r2,r2,640
 d01f5e0:	10800037 	ldwio	r2,0(r2)
 d01f5e4:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 d01f5e8:	e0bfff17 	ldw	r2,-4(fp)
 d01f5ec:	1080a004 	addi	r2,r2,640
 d01f5f0:	1009883a 	mov	r4,r2
 d01f5f4:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f5f8:	00a00004 	movi	r2,-32768
 d01f5fc:	1884b03a 	or	r2,r3,r2
 d01f600:	10ffffcc 	andi	r3,r2,65535
 d01f604:	2005883a 	mov	r2,r4
 d01f608:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 d01f60c:	00800044 	movi	r2,1
}
 d01f610:	e037883a 	mov	sp,fp
 d01f614:	dfc00117 	ldw	ra,4(sp)
 d01f618:	df000017 	ldw	fp,0(sp)
 d01f61c:	dec00204 	addi	sp,sp,8
 d01f620:	f800283a 	ret

0d01f624 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 d01f624:	defffc04 	addi	sp,sp,-16
 d01f628:	dfc00315 	stw	ra,12(sp)
 d01f62c:	df000215 	stw	fp,8(sp)
 d01f630:	df000204 	addi	fp,sp,8
 d01f634:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 d01f638:	e0bfff17 	ldw	r2,-4(fp)
 d01f63c:	1080bb04 	addi	r2,r2,748
 d01f640:	10800037 	ldwio	r2,0(r2)
 d01f644:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 d01f648:	00fffc04 	movi	r3,-16
 d01f64c:	e0bffe0b 	ldhu	r2,-8(fp)
 d01f650:	10c4703a 	and	r2,r2,r3
 d01f654:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 d01f658:	01034174 	movhi	r4,3333
 d01f65c:	21391504 	addi	r4,r4,-7084
 d01f660:	d002cc00 	call	d002cc0 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 d01f664:	e0bfff17 	ldw	r2,-4(fp)
 d01f668:	1080bb04 	addi	r2,r2,748
 d01f66c:	1009883a 	mov	r4,r2
 d01f670:	e0bffe0b 	ldhu	r2,-8(fp)
 d01f674:	10800114 	ori	r2,r2,4
 d01f678:	10ffffcc 	andi	r3,r2,65535
 d01f67c:	2005883a 	mov	r2,r4
 d01f680:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 d01f684:	01034174 	movhi	r4,3333
 d01f688:	21390b04 	addi	r4,r4,-7124
 d01f68c:	d002cc00 	call	d002cc0 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 d01f690:	e0bfff17 	ldw	r2,-4(fp)
 d01f694:	1080b404 	addi	r2,r2,720
 d01f698:	10800037 	ldwio	r2,0(r2)
 d01f69c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 d01f6a0:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f6a4:	00bfdf44 	movi	r2,-131
 d01f6a8:	1884703a 	and	r2,r3,r2
 d01f6ac:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 d01f6b0:	e0bfff17 	ldw	r2,-4(fp)
 d01f6b4:	1080b404 	addi	r2,r2,720
 d01f6b8:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f6bc:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 d01f6c0:	01034174 	movhi	r4,3333
 d01f6c4:	2138fa04 	addi	r4,r4,-7192
 d01f6c8:	d002cc00 	call	d002cc0 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 d01f6cc:	e0bfff17 	ldw	r2,-4(fp)
 d01f6d0:	1080a004 	addi	r2,r2,640
 d01f6d4:	10800037 	ldwio	r2,0(r2)
 d01f6d8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 d01f6dc:	e0bfff17 	ldw	r2,-4(fp)
 d01f6e0:	1080a004 	addi	r2,r2,640
 d01f6e4:	1009883a 	mov	r4,r2
 d01f6e8:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f6ec:	00a00004 	movi	r2,-32768
 d01f6f0:	1884b03a 	or	r2,r3,r2
 d01f6f4:	10ffffcc 	andi	r3,r2,65535
 d01f6f8:	2005883a 	mov	r2,r4
 d01f6fc:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 d01f700:	00800044 	movi	r2,1
}
 d01f704:	e037883a 	mov	sp,fp
 d01f708:	dfc00117 	ldw	ra,4(sp)
 d01f70c:	df000017 	ldw	fp,0(sp)
 d01f710:	dec00204 	addi	sp,sp,8
 d01f714:	f800283a 	ret

0d01f718 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 d01f718:	defffc04 	addi	sp,sp,-16
 d01f71c:	dfc00315 	stw	ra,12(sp)
 d01f720:	df000215 	stw	fp,8(sp)
 d01f724:	df000204 	addi	fp,sp,8
 d01f728:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 d01f72c:	e0bfff17 	ldw	r2,-4(fp)
 d01f730:	1080bb04 	addi	r2,r2,748
 d01f734:	10800037 	ldwio	r2,0(r2)
 d01f738:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 d01f73c:	00fffc04 	movi	r3,-16
 d01f740:	e0bffe0b 	ldhu	r2,-8(fp)
 d01f744:	10c4703a 	and	r2,r2,r3
 d01f748:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 d01f74c:	01034174 	movhi	r4,3333
 d01f750:	21392a04 	addi	r4,r4,-7000
 d01f754:	d002cc00 	call	d002cc0 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 d01f758:	e0bfff17 	ldw	r2,-4(fp)
 d01f75c:	1080bb04 	addi	r2,r2,748
 d01f760:	1009883a 	mov	r4,r2
 d01f764:	e0bffe0b 	ldhu	r2,-8(fp)
 d01f768:	108002d4 	ori	r2,r2,11
 d01f76c:	10ffffcc 	andi	r3,r2,65535
 d01f770:	2005883a 	mov	r2,r4
 d01f774:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 d01f778:	01034174 	movhi	r4,3333
 d01f77c:	21393904 	addi	r4,r4,-6940
 d01f780:	d002cc00 	call	d002cc0 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 d01f784:	e0bfff17 	ldw	r2,-4(fp)
 d01f788:	1080b404 	addi	r2,r2,720
 d01f78c:	10800037 	ldwio	r2,0(r2)
 d01f790:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 d01f794:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f798:	00bfdf44 	movi	r2,-131
 d01f79c:	1884703a 	and	r2,r3,r2
 d01f7a0:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 d01f7a4:	e0bffe0b 	ldhu	r2,-8(fp)
 d01f7a8:	10802094 	ori	r2,r2,130
 d01f7ac:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 d01f7b0:	e0bfff17 	ldw	r2,-4(fp)
 d01f7b4:	1080b404 	addi	r2,r2,720
 d01f7b8:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f7bc:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 d01f7c0:	01034174 	movhi	r4,3333
 d01f7c4:	2138fa04 	addi	r4,r4,-7192
 d01f7c8:	d002cc00 	call	d002cc0 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 d01f7cc:	e0bfff17 	ldw	r2,-4(fp)
 d01f7d0:	1080a004 	addi	r2,r2,640
 d01f7d4:	10800037 	ldwio	r2,0(r2)
 d01f7d8:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 d01f7dc:	e0bfff17 	ldw	r2,-4(fp)
 d01f7e0:	1080a004 	addi	r2,r2,640
 d01f7e4:	1009883a 	mov	r4,r2
 d01f7e8:	e0fffe0b 	ldhu	r3,-8(fp)
 d01f7ec:	00a00004 	movi	r2,-32768
 d01f7f0:	1884b03a 	or	r2,r3,r2
 d01f7f4:	10ffffcc 	andi	r3,r2,65535
 d01f7f8:	2005883a 	mov	r2,r4
 d01f7fc:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 d01f800:	00800044 	movi	r2,1
    
}
 d01f804:	e037883a 	mov	sp,fp
 d01f808:	dfc00117 	ldw	ra,4(sp)
 d01f80c:	df000017 	ldw	fp,0(sp)
 d01f810:	dec00204 	addi	sp,sp,8
 d01f814:	f800283a 	ret

0d01f818 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 d01f818:	defffc04 	addi	sp,sp,-16
 d01f81c:	df000315 	stw	fp,12(sp)
 d01f820:	df000304 	addi	fp,sp,12
 d01f824:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 d01f828:	e03ffe15 	stw	zero,-8(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 d01f82c:	e0bfff17 	ldw	r2,-4(fp)
 d01f830:	1080b004 	addi	r2,r2,704
 d01f834:	10800037 	ldwio	r2,0(r2)
 d01f838:	e0bffd15 	stw	r2,-12(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 d01f83c:	e0bffd17 	ldw	r2,-12(fp)
 d01f840:	1080008c 	andi	r2,r2,2
 d01f844:	1005003a 	cmpeq	r2,r2,zero
 d01f848:	1000041e 	bne	r2,zero,d01f85c <DP83848C_link_status_read+0x44>
		link_status |= 0x8;
 d01f84c:	e0bffe17 	ldw	r2,-8(fp)
 d01f850:	10800214 	ori	r2,r2,8
 d01f854:	e0bffe15 	stw	r2,-8(fp)
 d01f858:	00000306 	br	d01f868 <DP83848C_link_status_read+0x50>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 d01f85c:	e0bffe17 	ldw	r2,-8(fp)
 d01f860:	10800114 	ori	r2,r2,4
 d01f864:	e0bffe15 	stw	r2,-8(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 d01f868:	e0bffd17 	ldw	r2,-12(fp)
 d01f86c:	1080010c 	andi	r2,r2,4
 d01f870:	1005003a 	cmpeq	r2,r2,zero
 d01f874:	1000031e 	bne	r2,zero,d01f884 <DP83848C_link_status_read+0x6c>
		link_status |= 0x1;
 d01f878:	e0bffe17 	ldw	r2,-8(fp)
 d01f87c:	10800054 	ori	r2,r2,1
 d01f880:	e0bffe15 	stw	r2,-8(fp)
	}
	
	return link_status;
 d01f884:	e0bffe17 	ldw	r2,-8(fp)
}
 d01f888:	e037883a 	mov	sp,fp
 d01f88c:	df000017 	ldw	fp,0(sp)
 d01f890:	dec00104 	addi	sp,sp,4
 d01f894:	f800283a 	ret

0d01f898 <triple_speed_ethernet_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t triple_speed_ethernet_init(
    alt_iniche_dev              *p_dev)
{
 d01f898:	defff904 	addi	sp,sp,-28
 d01f89c:	dfc00615 	stw	ra,24(sp)
 d01f8a0:	df000515 	stw	fp,20(sp)
 d01f8a4:	df000504 	addi	fp,sp,20
 d01f8a8:	e13ffe15 	stw	r4,-8(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 d01f8ac:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_system_info *psys_info = 0;
 d01f8b0:	e03ffb15 	stw	zero,-20(fp)
    #ifdef PRINTIF
        dprintf("triple_speed_ethernet_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 d01f8b4:	e03ffd15 	stw	zero,-12(fp)
 d01f8b8:	00001206 	br	d01f904 <triple_speed_ethernet_init+0x6c>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 d01f8bc:	e0bffd17 	ldw	r2,-12(fp)
 d01f8c0:	00c341b4 	movhi	r3,3334
 d01f8c4:	18f18804 	addi	r3,r3,-14816
 d01f8c8:	10800324 	muli	r2,r2,12
 d01f8cc:	10c5883a 	add	r2,r2,r3
 d01f8d0:	10c00017 	ldw	r3,0(r2)
 d01f8d4:	e0bffe17 	ldw	r2,-8(fp)
 d01f8d8:	1880071e 	bne	r3,r2,d01f8f8 <triple_speed_ethernet_init+0x60>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 d01f8dc:	e0bffd17 	ldw	r2,-12(fp)
 d01f8e0:	10800324 	muli	r2,r2,12
 d01f8e4:	1007883a 	mov	r3,r2
 d01f8e8:	008341b4 	movhi	r2,3334
 d01f8ec:	10b18804 	addi	r2,r2,-14816
 d01f8f0:	1885883a 	add	r2,r3,r2
 d01f8f4:	e0bffc15 	stw	r2,-16(fp)
    #ifdef PRINTIF
        dprintf("triple_speed_ethernet_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 d01f8f8:	e0bffd17 	ldw	r2,-12(fp)
 d01f8fc:	10800044 	addi	r2,r2,1
 d01f900:	e0bffd15 	stw	r2,-12(fp)
 d01f904:	d0a08003 	ldbu	r2,-32256(gp)
 d01f908:	10c03fcc 	andi	r3,r2,255
 d01f90c:	e0bffd17 	ldw	r2,-12(fp)
 d01f910:	10ffea16 	blt	r2,r3,d01f8bc <triple_speed_ethernet_init+0x24>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 d01f914:	e0bffc17 	ldw	r2,-16(fp)
 d01f918:	1004c03a 	cmpne	r2,r2,zero
 d01f91c:	1000031e 	bne	r2,zero,d01f92c <triple_speed_ethernet_init+0x94>
        return ENP_HARDWARE;
 d01f920:	00bff744 	movi	r2,-35
 d01f924:	e0bfff15 	stw	r2,-4(fp)
 d01f928:	00002c06 	br	d01f9dc <triple_speed_ethernet_init+0x144>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 d01f92c:	e03ffd15 	stw	zero,-12(fp)
 d01f930:	00001306 	br	d01f980 <triple_speed_ethernet_init+0xe8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 d01f934:	e0bffd17 	ldw	r2,-12(fp)
 d01f938:	00c34174 	movhi	r3,3333
 d01f93c:	18c23004 	addi	r3,r3,2240
 d01f940:	10801224 	muli	r2,r2,72
 d01f944:	10c5883a 	add	r2,r2,r3
 d01f948:	10c00017 	ldw	r3,0(r2)
 d01f94c:	e0bffc17 	ldw	r2,-16(fp)
 d01f950:	10800117 	ldw	r2,4(r2)
 d01f954:	1880071e 	bne	r3,r2,d01f974 <triple_speed_ethernet_init+0xdc>
            psys_info = &tse_mac_device[i];
 d01f958:	e0bffd17 	ldw	r2,-12(fp)
 d01f95c:	10801224 	muli	r2,r2,72
 d01f960:	1007883a 	mov	r3,r2
 d01f964:	00834174 	movhi	r2,3333
 d01f968:	10823004 	addi	r2,r2,2240
 d01f96c:	1885883a 	add	r2,r3,r2
 d01f970:	e0bffb15 	stw	r2,-20(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 d01f974:	e0bffd17 	ldw	r2,-12(fp)
 d01f978:	10800044 	addi	r2,r2,1
 d01f97c:	e0bffd15 	stw	r2,-12(fp)
 d01f980:	00834174 	movhi	r2,3333
 d01f984:	108a4e04 	addi	r2,r2,10552
 d01f988:	10800003 	ldbu	r2,0(r2)
 d01f98c:	10c03fcc 	andi	r3,r2,255
 d01f990:	e0bffd17 	ldw	r2,-12(fp)
 d01f994:	10ffe716 	blt	r2,r3,d01f934 <triple_speed_ethernet_init+0x9c>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 d01f998:	e0bffb17 	ldw	r2,-20(fp)
 d01f99c:	1004c03a 	cmpne	r2,r2,zero
 d01f9a0:	1000031e 	bne	r2,zero,d01f9b0 <triple_speed_ethernet_init+0x118>
        return ENP_HARDWARE;
 d01f9a4:	00bff744 	movi	r2,-35
 d01f9a8:	e0bfff15 	stw	r2,-4(fp)
 d01f9ac:	00000b06 	br	d01f9dc <triple_speed_ethernet_init+0x144>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 d01f9b0:	e0bffe17 	ldw	r2,-8(fp)
 d01f9b4:	11000517 	ldw	r4,20(r2)
 d01f9b8:	e0bffc17 	ldw	r2,-16(fp)
 d01f9bc:	10800203 	ldbu	r2,8(r2)
 d01f9c0:	10803fcc 	andi	r2,r2,255
 d01f9c4:	10801224 	muli	r2,r2,72
 d01f9c8:	1007883a 	mov	r3,r2
 d01f9cc:	e0bffb17 	ldw	r2,-20(fp)
 d01f9d0:	188b883a 	add	r5,r3,r2
 d01f9d4:	d01f9f40 	call	d01f9f4 <prep_tse_mac>
    
    return SUCCESS;
 d01f9d8:	e03fff15 	stw	zero,-4(fp)
 d01f9dc:	e0bfff17 	ldw	r2,-4(fp)
}
 d01f9e0:	e037883a 	mov	sp,fp
 d01f9e4:	dfc00117 	ldw	ra,4(sp)
 d01f9e8:	df000017 	ldw	fp,0(sp)
 d01f9ec:	dec00204 	addi	sp,sp,8
 d01f9f0:	f800283a 	ret

0d01f9f4 <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 d01f9f4:	defffb04 	addi	sp,sp,-20
 d01f9f8:	dfc00415 	stw	ra,16(sp)
 d01f9fc:	df000315 	stw	fp,12(sp)
 d01fa00:	df000304 	addi	fp,sp,12
 d01fa04:	e13ffe15 	stw	r4,-8(fp)
 d01fa08:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 d01fa0c:	01034174 	movhi	r4,3333
 d01fa10:	21394304 	addi	r4,r4,-6900
 d01fa14:	e17ffe17 	ldw	r5,-8(fp)
 d01fa18:	d0029980 	call	d002998 <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 d01fa1c:	e0bffe17 	ldw	r2,-8(fp)
 d01fa20:	00c341b4 	movhi	r3,3334
 d01fa24:	18f19404 	addi	r3,r3,-14768
 d01fa28:	10801324 	muli	r2,r2,76
 d01fa2c:	10c5883a 	add	r2,r2,r3
 d01fa30:	10800c04 	addi	r2,r2,48
 d01fa34:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 d01fa38:	e0bffe17 	ldw	r2,-8(fp)
 d01fa3c:	00c341b4 	movhi	r3,3334
 d01fa40:	18f19404 	addi	r3,r3,-14768
 d01fa44:	10801324 	muli	r2,r2,76
 d01fa48:	10c5883a 	add	r2,r2,r3
 d01fa4c:	10c01204 	addi	r3,r2,72
 d01fa50:	e0bfff17 	ldw	r2,-4(fp)
 d01fa54:	18800015 	stw	r2,0(r3)

        ifp = nets[index];
 d01fa58:	e0bffe17 	ldw	r2,-8(fp)
 d01fa5c:	00c341b4 	movhi	r3,3334
 d01fa60:	18f2a504 	addi	r3,r3,-13676
 d01fa64:	1085883a 	add	r2,r2,r2
 d01fa68:	1085883a 	add	r2,r2,r2
 d01fa6c:	10c5883a 	add	r2,r2,r3
 d01fa70:	10800017 	ldw	r2,0(r2)
 d01fa74:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 d01fa78:	e0bffd17 	ldw	r2,-12(fp)
 d01fa7c:	10c02717 	ldw	r3,156(r2)
 d01fa80:	00800084 	movi	r2,2
 d01fa84:	18800615 	stw	r2,24(r3)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 d01fa88:	e0bffd17 	ldw	r2,-12(fp)
 d01fa8c:	10c02717 	ldw	r3,156(r2)
 d01fa90:	00800084 	movi	r2,2
 d01fa94:	18800715 	stw	r2,28(r3)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 d01fa98:	e0bffd17 	ldw	r2,-12(fp)
 d01fa9c:	10c02717 	ldw	r3,156(r2)
 d01faa0:	00834174 	movhi	r2,3333
 d01faa4:	108ac904 	addi	r2,r2,11044
 d01faa8:	10800017 	ldw	r2,0(r2)
 d01faac:	18800815 	stw	r2,32(r3)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 d01fab0:	e0bffd17 	ldw	r2,-12(fp)
 d01fab4:	11002717 	ldw	r4,156(r2)
 d01fab8:	e0bffe17 	ldw	r2,-8(fp)
 d01fabc:	10801324 	muli	r2,r2,76
 d01fac0:	10c00604 	addi	r3,r2,24
 d01fac4:	008341b4 	movhi	r2,3334
 d01fac8:	10b19404 	addi	r2,r2,-14768
 d01facc:	1885883a 	add	r2,r3,r2
 d01fad0:	20800515 	stw	r2,20(r4)
        ifp->n_mib->ifDescr =       (u_char*)"Altera TSE MAC ethernet";
 d01fad4:	e0bffd17 	ldw	r2,-12(fp)
 d01fad8:	10c02717 	ldw	r3,156(r2)
 d01fadc:	00834174 	movhi	r2,3333
 d01fae0:	10b94804 	addi	r2,r2,-6880
 d01fae4:	18800115 	stw	r2,4(r3)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 d01fae8:	e0fffd17 	ldw	r3,-12(fp)
 d01faec:	00800404 	movi	r2,16
 d01faf0:	18800815 	stw	r2,32(r3)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 d01faf4:	e0fffd17 	ldw	r3,-12(fp)
 d01faf8:	00800184 	movi	r2,6
 d01fafc:	18801115 	stw	r2,68(r3)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 d01fb00:	e0bffd17 	ldw	r2,-12(fp)
 d01fb04:	10c02717 	ldw	r3,156(r2)
 d01fb08:	00800184 	movi	r2,6
 d01fb0c:	18800215 	stw	r2,8(r3)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 d01fb10:	e0fffd17 	ldw	r3,-12(fp)
 d01fb14:	00817a84 	movi	r2,1514
 d01fb18:	18800915 	stw	r2,36(r3)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 d01fb1c:	e0fffd17 	ldw	r3,-12(fp)
 d01fb20:	008340b4 	movhi	r2,3330
 d01fb24:	10bf1604 	addi	r2,r2,-936
 d01fb28:	18800215 	stw	r2,8(r3)
        ifp->pkt_send =     NULL;
 d01fb2c:	e0bffd17 	ldw	r2,-12(fp)
 d01fb30:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 d01fb34:	e0fffd17 	ldw	r3,-12(fp)
 d01fb38:	008340b4 	movhi	r2,3330
 d01fb3c:	1081d004 	addi	r2,r2,1856
 d01fb40:	18800315 	stw	r2,12(r3)
        ifp->n_close =      tse_mac_close;
 d01fb44:	e0fffd17 	ldw	r3,-12(fp)
 d01fb48:	008340b4 	movhi	r2,3330
 d01fb4c:	1083c604 	addi	r2,r2,3864
 d01fb50:	18800515 	stw	r2,20(r3)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 d01fb54:	00c340b4 	movhi	r3,3330
 d01fb58:	18c3b604 	addi	r3,r3,3800
 d01fb5c:	e0bffd17 	ldw	r2,-12(fp)
 d01fb60:	10c00715 	stw	r3,28(r2)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 d01fb64:	e0bffd17 	ldw	r2,-12(fp)
 d01fb68:	10802a17 	ldw	r2,168(r2)
 d01fb6c:	10c00214 	ori	r3,r2,8
 d01fb70:	e0bffd17 	ldw	r2,-12(fp)
 d01fb74:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 d01fb78:	e0bffe17 	ldw	r2,-8(fp)
 d01fb7c:	00c341b4 	movhi	r3,3334
 d01fb80:	18f2a504 	addi	r3,r3,-13676
 d01fb84:	1085883a 	add	r2,r2,r2
 d01fb88:	1085883a 	add	r2,r2,r2
 d01fb8c:	10c5883a 	add	r2,r2,r3
 d01fb90:	10800017 	ldw	r2,0(r2)
 d01fb94:	11002717 	ldw	r4,156(r2)
 d01fb98:	e0bffe17 	ldw	r2,-8(fp)
 d01fb9c:	10801324 	muli	r2,r2,76
 d01fba0:	10c00604 	addi	r3,r2,24
 d01fba4:	008341b4 	movhi	r2,3334
 d01fba8:	10b19404 	addi	r2,r2,-14768
 d01fbac:	1885883a 	add	r2,r3,r2
 d01fbb0:	20800515 	stw	r2,20(r4)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 d01fbb4:	e0bffe17 	ldw	r2,-8(fp)
 d01fbb8:	10801324 	muli	r2,r2,76
 d01fbbc:	10c00604 	addi	r3,r2,24
 d01fbc0:	008341b4 	movhi	r2,3334
 d01fbc4:	10b19404 	addi	r2,r2,-14768
 d01fbc8:	1885883a 	add	r2,r3,r2
 d01fbcc:	100b883a 	mov	r5,r2
 d01fbd0:	e13ffd17 	ldw	r4,-12(fp)
 d01fbd4:	d0012e40 	call	d0012e4 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 d01fbd8:	e0bffe17 	ldw	r2,-8(fp)
 d01fbdc:	00c341b4 	movhi	r3,3334
 d01fbe0:	18f19404 	addi	r3,r3,-14768
 d01fbe4:	10801324 	muli	r2,r2,76
 d01fbe8:	10c7883a 	add	r3,r2,r3
 d01fbec:	e0bffe17 	ldw	r2,-8(fp)
 d01fbf0:	18800015 	stw	r2,0(r3)
        tse[index].netp = ifp;
 d01fbf4:	e0bffe17 	ldw	r2,-8(fp)
 d01fbf8:	00c341b4 	movhi	r3,3334
 d01fbfc:	18f19404 	addi	r3,r3,-14768
 d01fc00:	10801324 	muli	r2,r2,76
 d01fc04:	10c5883a 	add	r2,r2,r3
 d01fc08:	10c00804 	addi	r3,r2,32
 d01fc0c:	e0bffd17 	ldw	r2,-12(fp)
 d01fc10:	18800015 	stw	r2,0(r3)
        ifp->n_local = (void*)(&tse[index]);
 d01fc14:	e0bffe17 	ldw	r2,-8(fp)
 d01fc18:	10801324 	muli	r2,r2,76
 d01fc1c:	1007883a 	mov	r3,r2
 d01fc20:	008341b4 	movhi	r2,3334
 d01fc24:	10b19404 	addi	r2,r2,-14768
 d01fc28:	1887883a 	add	r3,r3,r2
 d01fc2c:	e0bffd17 	ldw	r2,-12(fp)
 d01fc30:	10c02815 	stw	r3,160(r2)
    
        index++;
 d01fc34:	e0bffe17 	ldw	r2,-8(fp)
 d01fc38:	10800044 	addi	r2,r2,1
 d01fc3c:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 d01fc40:	e0bffe17 	ldw	r2,-8(fp)
}
 d01fc44:	e037883a 	mov	sp,fp
 d01fc48:	dfc00117 	ldw	ra,4(sp)
 d01fc4c:	df000017 	ldw	fp,0(sp)
 d01fc50:	dec00204 	addi	sp,sp,8
 d01fc54:	f800283a 	ret

0d01fc58 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 d01fc58:	deffee04 	addi	sp,sp,-72
 d01fc5c:	dfc01115 	stw	ra,68(sp)
 d01fc60:	df001015 	stw	fp,64(sp)
 d01fc64:	df001004 	addi	fp,sp,64
 d01fc68:	e13ffe15 	stw	r4,-8(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 d01fc6c:	e03ff815 	stw	zero,-32(fp)
   
   NET ifp;
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 d01fc70:	e0bffe17 	ldw	r2,-8(fp)
 d01fc74:	00c341b4 	movhi	r3,3334
 d01fc78:	18f19404 	addi	r3,r3,-14768
 d01fc7c:	10801324 	muli	r2,r2,76
 d01fc80:	10c5883a 	add	r2,r2,r3
 d01fc84:	10801204 	addi	r2,r2,72
 d01fc88:	10800017 	ldw	r2,0(r2)
 d01fc8c:	e0bff415 	stw	r2,-48(fp)
   
   dprintf("[tse_mac_init]\n");
 d01fc90:	01034174 	movhi	r4,3333
 d01fc94:	21394e04 	addi	r4,r4,-6856
 d01fc98:	d002cc00 	call	d002cc0 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 d01fc9c:	e0bff417 	ldw	r2,-48(fp)
 d01fca0:	10800783 	ldbu	r2,30(r2)
 d01fca4:	10803fcc 	andi	r2,r2,255
 d01fca8:	10800058 	cmpnei	r2,r2,1
 d01fcac:	10000b1e 	bne	r2,zero,d01fcdc <tse_mac_init+0x84>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 d01fcb0:	e13ffe17 	ldw	r4,-8(fp)
 d01fcb4:	e0bff417 	ldw	r2,-48(fp)
 d01fcb8:	10800817 	ldw	r2,32(r2)
 d01fcbc:	100b883a 	mov	r5,r2
 d01fcc0:	00c341b4 	movhi	r3,3334
 d01fcc4:	18f19404 	addi	r3,r3,-14768
 d01fcc8:	20801324 	muli	r2,r4,76
 d01fccc:	10c5883a 	add	r2,r2,r3
 d01fcd0:	10800f04 	addi	r2,r2,60
 d01fcd4:	11400015 	stw	r5,0(r2)
 d01fcd8:	00001306 	br	d01fd28 <tse_mac_init+0xd0>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 d01fcdc:	01002804 	movi	r4,160
 d01fce0:	d03986c0 	call	d03986c <alt_uncached_malloc>
 d01fce4:	e0bff315 	stw	r2,-52(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 d01fce8:	00000306 	br	d01fcf8 <tse_mac_init+0xa0>
        {
            temp_desc++;
 d01fcec:	e0bff317 	ldw	r2,-52(fp)
 d01fcf0:	10800044 	addi	r2,r2,1
 d01fcf4:	e0bff315 	stw	r2,-52(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 d01fcf8:	e0bff317 	ldw	r2,-52(fp)
 d01fcfc:	108007cc 	andi	r2,r2,31
 d01fd00:	1004c03a 	cmpne	r2,r2,zero
 d01fd04:	103ff91e 	bne	r2,zero,d01fcec <tse_mac_init+0x94>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 d01fd08:	e0bffe17 	ldw	r2,-8(fp)
 d01fd0c:	e13ff317 	ldw	r4,-52(fp)
 d01fd10:	00c341b4 	movhi	r3,3334
 d01fd14:	18f19404 	addi	r3,r3,-14768
 d01fd18:	10801324 	muli	r2,r2,76
 d01fd1c:	10c5883a 	add	r2,r2,r3
 d01fd20:	10800f04 	addi	r2,r2,60
 d01fd24:	11000015 	stw	r4,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 d01fd28:	e0bff417 	ldw	r2,-48(fp)
 d01fd2c:	11000517 	ldw	r4,20(r2)
 d01fd30:	d019cdc0 	call	d019cdc <alt_avalon_sgdma_open>
 d01fd34:	e0bff615 	stw	r2,-40(fp)
   
   if(!sgdma_tx_dev) {
 d01fd38:	e0bff617 	ldw	r2,-40(fp)
 d01fd3c:	1004c03a 	cmpne	r2,r2,zero
 d01fd40:	1000061e 	bne	r2,zero,d01fd5c <tse_mac_init+0x104>
      dprintf("[triple_speed_ethernet_init] Error opening TX SGDMA\n");
 d01fd44:	01034174 	movhi	r4,3333
 d01fd48:	21395204 	addi	r4,r4,-6840
 d01fd4c:	d002cc00 	call	d002cc0 <puts>
      return ENP_RESOURCE;
 d01fd50:	00bffa84 	movi	r2,-22
 d01fd54:	e0bfff15 	stw	r2,-4(fp)
 d01fd58:	00027306 	br	d020728 <tse_mac_init+0xad0>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 d01fd5c:	e0bff417 	ldw	r2,-48(fp)
 d01fd60:	11000617 	ldw	r4,24(r2)
 d01fd64:	d019cdc0 	call	d019cdc <alt_avalon_sgdma_open>
 d01fd68:	e0bff515 	stw	r2,-44(fp)
   if(!sgdma_rx_dev) {
 d01fd6c:	e0bff517 	ldw	r2,-44(fp)
 d01fd70:	1004c03a 	cmpne	r2,r2,zero
 d01fd74:	1000061e 	bne	r2,zero,d01fd90 <tse_mac_init+0x138>
      dprintf("[triple_speed_ethernet_init] Error opening RX SGDMA\n");
 d01fd78:	01034174 	movhi	r4,3333
 d01fd7c:	21395f04 	addi	r4,r4,-6788
 d01fd80:	d002cc00 	call	d002cc0 <puts>
      return ENP_RESOURCE;
 d01fd84:	00bffa84 	movi	r2,-22
 d01fd88:	e0bfff15 	stw	r2,-4(fp)
 d01fd8c:	00026606 	br	d020728 <tse_mac_init+0xad0>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 d01fd90:	e0bffe17 	ldw	r2,-8(fp)
 d01fd94:	10801324 	muli	r2,r2,76
 d01fd98:	10c00104 	addi	r3,r2,4
 d01fd9c:	008341b4 	movhi	r2,3334
 d01fda0:	10b19404 	addi	r2,r2,-14768
 d01fda4:	1889883a 	add	r4,r3,r2
 d01fda8:	e0bff417 	ldw	r2,-48(fp)
 d01fdac:	11400017 	ldw	r5,0(r2)
 d01fdb0:	e0bff617 	ldw	r2,-40(fp)
 d01fdb4:	100d883a 	mov	r6,r2
 d01fdb8:	e0bff517 	ldw	r2,-44(fp)
 d01fdbc:	100f883a 	mov	r7,r2
 d01fdc0:	d8000015 	stw	zero,0(sp)
 d01fdc4:	d01a5740 	call	d01a574 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 d01fdc8:	e0bffe17 	ldw	r2,-8(fp)
 d01fdcc:	00c341b4 	movhi	r3,3334
 d01fdd0:	18f19404 	addi	r3,r3,-14768
 d01fdd4:	10801324 	muli	r2,r2,76
 d01fdd8:	10c5883a 	add	r2,r2,r3
 d01fddc:	10800304 	addi	r2,r2,12
 d01fde0:	10800017 	ldw	r2,0(r2)
 d01fde4:	10800317 	ldw	r2,12(r2)
 d01fde8:	10800404 	addi	r2,r2,16
 d01fdec:	1007883a 	mov	r3,r2
 d01fdf0:	00800074 	movhi	r2,1
 d01fdf4:	18800035 	stwio	r2,0(r3)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 d01fdf8:	e0bffe17 	ldw	r2,-8(fp)
 d01fdfc:	00c341b4 	movhi	r3,3334
 d01fe00:	18f19404 	addi	r3,r3,-14768
 d01fe04:	10801324 	muli	r2,r2,76
 d01fe08:	10c5883a 	add	r2,r2,r3
 d01fe0c:	10800304 	addi	r2,r2,12
 d01fe10:	10800017 	ldw	r2,0(r2)
 d01fe14:	10800317 	ldw	r2,12(r2)
 d01fe18:	10800404 	addi	r2,r2,16
 d01fe1c:	10000035 	stwio	zero,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 d01fe20:	e13ffe17 	ldw	r4,-8(fp)
 d01fe24:	e0bff417 	ldw	r2,-48(fp)
 d01fe28:	1080070b 	ldhu	r2,28(r2)
 d01fe2c:	117fffcc 	andi	r5,r2,65535
 d01fe30:	00c341b4 	movhi	r3,3334
 d01fe34:	18f19404 	addi	r3,r3,-14768
 d01fe38:	20801324 	muli	r2,r4,76
 d01fe3c:	10c5883a 	add	r2,r2,r3
 d01fe40:	10800904 	addi	r2,r2,36
 d01fe44:	11400015 	stw	r5,0(r2)
   ifp = tse[iface].netp;
 d01fe48:	e0bffe17 	ldw	r2,-8(fp)
 d01fe4c:	00c341b4 	movhi	r3,3334
 d01fe50:	18f19404 	addi	r3,r3,-14768
 d01fe54:	10801324 	muli	r2,r2,76
 d01fe58:	10c5883a 	add	r2,r2,r3
 d01fe5c:	10800804 	addi	r2,r2,32
 d01fe60:	10800017 	ldw	r2,0(r2)
 d01fe64:	e0bff715 	stw	r2,-36(fp)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 d01fe68:	e0bffe17 	ldw	r2,-8(fp)
 d01fe6c:	00c341b4 	movhi	r3,3334
 d01fe70:	18f19404 	addi	r3,r3,-14768
 d01fe74:	10801324 	muli	r2,r2,76
 d01fe78:	10c5883a 	add	r2,r2,r3
 d01fe7c:	10800104 	addi	r2,r2,4
 d01fe80:	11000017 	ldw	r4,0(r2)
 d01fe84:	d01ba800 	call	d01ba80 <getPHYSpeed>
 d01fe88:	e0bffa15 	stw	r2,-24(fp)
   speed = (result >> 1) & 0x07;
 d01fe8c:	e0bffa17 	ldw	r2,-24(fp)
 d01fe90:	1005d07a 	srai	r2,r2,1
 d01fe94:	108001cc 	andi	r2,r2,7
 d01fe98:	e0bffc15 	stw	r2,-16(fp)
   duplex = result & 0x01;
 d01fe9c:	e0bffa17 	ldw	r2,-24(fp)
 d01fea0:	1080004c 	andi	r2,r2,1
 d01fea4:	e0bffb15 	stw	r2,-20(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 d01fea8:	e0bffe17 	ldw	r2,-8(fp)
 d01feac:	00c341b4 	movhi	r3,3334
 d01feb0:	18f19404 	addi	r3,r3,-14768
 d01feb4:	10801324 	muli	r2,r2,76
 d01feb8:	10c5883a 	add	r2,r2,r3
 d01febc:	10800104 	addi	r2,r2,4
 d01fec0:	10800017 	ldw	r2,0(r2)
 d01fec4:	10800204 	addi	r2,r2,8
 d01fec8:	1007883a 	mov	r3,r2
 d01fecc:	008800c4 	movi	r2,8195
 d01fed0:	18800035 	stwio	r2,0(r3)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 d01fed4:	e03ff915 	stw	zero,-28(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 d01fed8:	00000906 	br	d01ff00 <tse_mac_init+0x2a8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 d01fedc:	e0bff917 	ldw	r2,-28(fp)
 d01fee0:	1089c448 	cmpgei	r2,r2,10001
 d01fee4:	1007883a 	mov	r3,r2
 d01fee8:	e0bff917 	ldw	r2,-28(fp)
 d01feec:	10800044 	addi	r2,r2,1
 d01fef0:	e0bff915 	stw	r2,-28(fp)
 d01fef4:	18803fcc 	andi	r2,r3,255
 d01fef8:	1004c03a 	cmpne	r2,r2,zero
 d01fefc:	10000c1e 	bne	r2,zero,d01ff30 <tse_mac_init+0x2d8>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 d01ff00:	e0bffe17 	ldw	r2,-8(fp)
 d01ff04:	00c341b4 	movhi	r3,3334
 d01ff08:	18f19404 	addi	r3,r3,-14768
 d01ff0c:	10801324 	muli	r2,r2,76
 d01ff10:	10c5883a 	add	r2,r2,r3
 d01ff14:	10800104 	addi	r2,r2,4
 d01ff18:	10800017 	ldw	r2,0(r2)
 d01ff1c:	10800204 	addi	r2,r2,8
 d01ff20:	10800037 	ldwio	r2,0(r2)
 d01ff24:	1088000c 	andi	r2,r2,8192
 d01ff28:	1004c03a 	cmpne	r2,r2,zero
 d01ff2c:	103feb1e 	bne	r2,zero,d01fedc <tse_mac_init+0x284>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
     }
   }
   if(x >= 10000) {
 d01ff30:	e0bff917 	ldw	r2,-28(fp)
 d01ff34:	1089c410 	cmplti	r2,r2,10000
 d01ff38:	1000031e 	bne	r2,zero,d01ff48 <tse_mac_init+0x2f0>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 d01ff3c:	01034174 	movhi	r4,3333
 d01ff40:	21396c04 	addi	r4,r4,-6736
 d01ff44:	d002cc00 	call	d002cc0 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 d01ff48:	e0bffe17 	ldw	r2,-8(fp)
 d01ff4c:	00c341b4 	movhi	r3,3334
 d01ff50:	18f19404 	addi	r3,r3,-14768
 d01ff54:	10801324 	muli	r2,r2,76
 d01ff58:	10c5883a 	add	r2,r2,r3
 d01ff5c:	10800104 	addi	r2,r2,4
 d01ff60:	10800017 	ldw	r2,0(r2)
 d01ff64:	10800204 	addi	r2,r2,8
 d01ff68:	10800037 	ldwio	r2,0(r2)
 d01ff6c:	e0bffd15 	stw	r2,-12(fp)
   if( (dat & 0x03) != 0 ) {
 d01ff70:	e0bffd17 	ldw	r2,-12(fp)
 d01ff74:	108000cc 	andi	r2,r2,3
 d01ff78:	1005003a 	cmpeq	r2,r2,zero
 d01ff7c:	1000051e 	bne	r2,zero,d01ff94 <tse_mac_init+0x33c>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 d01ff80:	01034174 	movhi	r4,3333
 d01ff84:	21397504 	addi	r4,r4,-6700
 d01ff88:	e17ffd17 	ldw	r5,-12(fp)
 d01ff8c:	d0029980 	call	d002998 <printf>
 d01ff90:	00000506 	br	d01ffa8 <tse_mac_init+0x350>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 d01ff94:	01034174 	movhi	r4,3333
 d01ff98:	21398904 	addi	r4,r4,-6620
 d01ff9c:	e17ff917 	ldw	r5,-28(fp)
 d01ffa0:	e1bffd17 	ldw	r6,-12(fp)
 d01ffa4:	d0029980 	call	d002998 <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 d01ffa8:	e0bff417 	ldw	r2,-48(fp)
 d01ffac:	10800903 	ldbu	r2,36(r2)
 d01ffb0:	10803fcc 	andi	r2,r2,255
 d01ffb4:	10800058 	cmpnei	r2,r2,1
 d01ffb8:	1000351e 	bne	r2,zero,d020090 <tse_mac_init+0x438>
      int channel_loop = 0;
 d01ffbc:	e03ff215 	stw	zero,-56(fp)
      int mac_loop = 0;
 d01ffc0:	e03ff115 	stw	zero,-60(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 d01ffc4:	e03ff215 	stw	zero,-56(fp)
 d01ffc8:	00002b06 	br	d020078 <tse_mac_init+0x420>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 d01ffcc:	e03ff115 	stw	zero,-60(fp)
 d01ffd0:	00001b06 	br	d020040 <tse_mac_init+0x3e8>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 d01ffd4:	e0bff217 	ldw	r2,-56(fp)
 d01ffd8:	00c341b4 	movhi	r3,3334
 d01ffdc:	18f18004 	addi	r3,r3,-14848
 d01ffe0:	1085883a 	add	r2,r2,r2
 d01ffe4:	1085883a 	add	r2,r2,r2
 d01ffe8:	10c5883a 	add	r2,r2,r3
 d01ffec:	10c00017 	ldw	r3,0(r2)
 d01fff0:	e0bff117 	ldw	r2,-60(fp)
 d01fff4:	1085883a 	add	r2,r2,r2
 d01fff8:	1085883a 	add	r2,r2,r2
 d01fffc:	10c5883a 	add	r2,r2,r3
 d020000:	10800104 	addi	r2,r2,4
 d020004:	10800017 	ldw	r2,0(r2)
 d020008:	10c00217 	ldw	r3,8(r2)
 d02000c:	e0bff417 	ldw	r2,-48(fp)
 d020010:	1880081e 	bne	r3,r2,d020034 <tse_mac_init+0x3dc>
            tse[iface].channel = mac_loop;
 d020014:	e0bffe17 	ldw	r2,-8(fp)
 d020018:	00c341b4 	movhi	r3,3334
 d02001c:	18f19404 	addi	r3,r3,-14768
 d020020:	10801324 	muli	r2,r2,76
 d020024:	10c5883a 	add	r2,r2,r3
 d020028:	10c00d04 	addi	r3,r2,52
 d02002c:	e0bff117 	ldw	r2,-60(fp)
 d020030:	18800015 	stw	r2,0(r3)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 d020034:	e0bff117 	ldw	r2,-60(fp)
 d020038:	10800044 	addi	r2,r2,1
 d02003c:	e0bff115 	stw	r2,-60(fp)
 d020040:	e0bff217 	ldw	r2,-56(fp)
 d020044:	00c341b4 	movhi	r3,3334
 d020048:	18f18004 	addi	r3,r3,-14848
 d02004c:	1085883a 	add	r2,r2,r2
 d020050:	1085883a 	add	r2,r2,r2
 d020054:	10c5883a 	add	r2,r2,r3
 d020058:	10800017 	ldw	r2,0(r2)
 d02005c:	10800003 	ldbu	r2,0(r2)
 d020060:	10c03fcc 	andi	r3,r2,255
 d020064:	e0bff117 	ldw	r2,-60(fp)
 d020068:	10ffda16 	blt	r2,r3,d01ffd4 <tse_mac_init+0x37c>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 d02006c:	e0bff217 	ldw	r2,-56(fp)
 d020070:	10800044 	addi	r2,r2,1
 d020074:	e0bff215 	stw	r2,-56(fp)
 d020078:	00834174 	movhi	r2,3333
 d02007c:	108aa044 	addi	r2,r2,10881
 d020080:	10800003 	ldbu	r2,0(r2)
 d020084:	10c03fcc 	andi	r3,r2,255
 d020088:	e0bff217 	ldw	r2,-56(fp)
 d02008c:	10ffcf16 	blt	r2,r3,d01ffcc <tse_mac_init+0x374>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 d020090:	e0bff417 	ldw	r2,-48(fp)
 d020094:	10800903 	ldbu	r2,36(r2)
 d020098:	10803fcc 	andi	r2,r2,255
 d02009c:	10800058 	cmpnei	r2,r2,1
 d0200a0:	1000121e 	bne	r2,zero,d0200ec <tse_mac_init+0x494>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 d0200a4:	e0bff417 	ldw	r2,-48(fp)
 d0200a8:	10800d17 	ldw	r2,52(r2)
 d0200ac:	1009883a 	mov	r4,r2
 d0200b0:	e0bff417 	ldw	r2,-48(fp)
 d0200b4:	10800f17 	ldw	r2,60(r2)
 d0200b8:	1007883a 	mov	r3,r2
 d0200bc:	2005883a 	mov	r2,r4
 d0200c0:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 d0200c4:	e0bff417 	ldw	r2,-48(fp)
 d0200c8:	10800d17 	ldw	r2,52(r2)
 d0200cc:	11000204 	addi	r4,r2,8
 d0200d0:	e0bff417 	ldw	r2,-48(fp)
 d0200d4:	10800f17 	ldw	r2,60(r2)
 d0200d8:	10bfdd04 	addi	r2,r2,-140
 d0200dc:	1007883a 	mov	r3,r2
 d0200e0:	2005883a 	mov	r2,r4
 d0200e4:	10c00035 	stwio	r3,0(r2)
 d0200e8:	00006506 	br	d020280 <tse_mac_init+0x628>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 d0200ec:	e0bffe17 	ldw	r2,-8(fp)
 d0200f0:	00c341b4 	movhi	r3,3334
 d0200f4:	18f19404 	addi	r3,r3,-14768
 d0200f8:	10801324 	muli	r2,r2,76
 d0200fc:	10c5883a 	add	r2,r2,r3
 d020100:	10800104 	addi	r2,r2,4
 d020104:	10800017 	ldw	r2,0(r2)
 d020108:	10800504 	addi	r2,r2,20
 d02010c:	1007883a 	mov	r3,r2
 d020110:	00817b84 	movi	r2,1518
 d020114:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 d020118:	e0bffe17 	ldw	r2,-8(fp)
 d02011c:	00c341b4 	movhi	r3,3334
 d020120:	18f19404 	addi	r3,r3,-14768
 d020124:	10801324 	muli	r2,r2,76
 d020128:	10c5883a 	add	r2,r2,r3
 d02012c:	10800104 	addi	r2,r2,4
 d020130:	10800017 	ldw	r2,0(r2)
 d020134:	10800b04 	addi	r2,r2,44
 d020138:	1007883a 	mov	r3,r2
 d02013c:	00800204 	movi	r2,8
 d020140:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 d020144:	e0bffe17 	ldw	r2,-8(fp)
 d020148:	00c341b4 	movhi	r3,3334
 d02014c:	18f19404 	addi	r3,r3,-14768
 d020150:	10801324 	muli	r2,r2,76
 d020154:	10c5883a 	add	r2,r2,r3
 d020158:	10800104 	addi	r2,r2,4
 d02015c:	10800017 	ldw	r2,0(r2)
 d020160:	10800c04 	addi	r2,r2,48
 d020164:	1007883a 	mov	r3,r2
 d020168:	00800204 	movi	r2,8
 d02016c:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 d020170:	e0bffe17 	ldw	r2,-8(fp)
 d020174:	00c341b4 	movhi	r3,3334
 d020178:	18f19404 	addi	r3,r3,-14768
 d02017c:	10801324 	muli	r2,r2,76
 d020180:	10c5883a 	add	r2,r2,r3
 d020184:	10800104 	addi	r2,r2,4
 d020188:	10800017 	ldw	r2,0(r2)
 d02018c:	10800d04 	addi	r2,r2,52
 d020190:	1007883a 	mov	r3,r2
 d020194:	00800204 	movi	r2,8
 d020198:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 d02019c:	e0bffe17 	ldw	r2,-8(fp)
 d0201a0:	00c341b4 	movhi	r3,3334
 d0201a4:	18f19404 	addi	r3,r3,-14768
 d0201a8:	10801324 	muli	r2,r2,76
 d0201ac:	10c5883a 	add	r2,r2,r3
 d0201b0:	10800104 	addi	r2,r2,4
 d0201b4:	10800017 	ldw	r2,0(r2)
 d0201b8:	10800e04 	addi	r2,r2,56
 d0201bc:	1007883a 	mov	r3,r2
 d0201c0:	008000c4 	movi	r2,3
 d0201c4:	18800035 	stwio	r2,0(r3)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 d0201c8:	e0bffe17 	ldw	r2,-8(fp)
 d0201cc:	00c341b4 	movhi	r3,3334
 d0201d0:	18f19404 	addi	r3,r3,-14768
 d0201d4:	10801324 	muli	r2,r2,76
 d0201d8:	10c5883a 	add	r2,r2,r3
 d0201dc:	10800104 	addi	r2,r2,4
 d0201e0:	10800017 	ldw	r2,0(r2)
 d0201e4:	11000904 	addi	r4,r2,36
 d0201e8:	e0bff417 	ldw	r2,-48(fp)
 d0201ec:	1080010b 	ldhu	r2,4(r2)
 d0201f0:	10bfffcc 	andi	r2,r2,65535
 d0201f4:	10fffc04 	addi	r3,r2,-16
 d0201f8:	2005883a 	mov	r2,r4
 d0201fc:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 d020200:	e0bffe17 	ldw	r2,-8(fp)
 d020204:	00c341b4 	movhi	r3,3334
 d020208:	18f19404 	addi	r3,r3,-14768
 d02020c:	10801324 	muli	r2,r2,76
 d020210:	10c5883a 	add	r2,r2,r3
 d020214:	10800104 	addi	r2,r2,4
 d020218:	10800017 	ldw	r2,0(r2)
 d02021c:	10800a04 	addi	r2,r2,40
 d020220:	10000035 	stwio	zero,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 d020224:	e0bffe17 	ldw	r2,-8(fp)
 d020228:	00c341b4 	movhi	r3,3334
 d02022c:	18f19404 	addi	r3,r3,-14768
 d020230:	10801324 	muli	r2,r2,76
 d020234:	10c5883a 	add	r2,r2,r3
 d020238:	10800104 	addi	r2,r2,4
 d02023c:	10800017 	ldw	r2,0(r2)
 d020240:	11000704 	addi	r4,r2,28
 d020244:	e0bff417 	ldw	r2,-48(fp)
 d020248:	1080018b 	ldhu	r2,6(r2)
 d02024c:	10bfffcc 	andi	r2,r2,65535
 d020250:	10fffc04 	addi	r3,r2,-16
 d020254:	2005883a 	mov	r2,r4
 d020258:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 d02025c:	e0bffe17 	ldw	r2,-8(fp)
 d020260:	00c341b4 	movhi	r3,3334
 d020264:	18f19404 	addi	r3,r3,-14768
 d020268:	10801324 	muli	r2,r2,76
 d02026c:	10c5883a 	add	r2,r2,r3
 d020270:	10800104 	addi	r2,r2,4
 d020274:	10800017 	ldw	r2,0(r2)
 d020278:	10800804 	addi	r2,r2,32
 d02027c:	10000035 	stwio	zero,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 d020280:	e0bffe17 	ldw	r2,-8(fp)
 d020284:	00c341b4 	movhi	r3,3334
 d020288:	18f19404 	addi	r3,r3,-14768
 d02028c:	10801324 	muli	r2,r2,76
 d020290:	10c5883a 	add	r2,r2,r3
 d020294:	10800104 	addi	r2,r2,4
 d020298:	10800017 	ldw	r2,0(r2)
 d02029c:	10803a04 	addi	r2,r2,232
 d0202a0:	1007883a 	mov	r3,r2
 d0202a4:	00800134 	movhi	r2,4
 d0202a8:	18800035 	stwio	r2,0(r3)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 d0202ac:	e0bffe17 	ldw	r2,-8(fp)
 d0202b0:	00c341b4 	movhi	r3,3334
 d0202b4:	18f19404 	addi	r3,r3,-14768
 d0202b8:	10801324 	muli	r2,r2,76
 d0202bc:	10c5883a 	add	r2,r2,r3
 d0202c0:	10800104 	addi	r2,r2,4
 d0202c4:	10800017 	ldw	r2,0(r2)
 d0202c8:	10803a04 	addi	r2,r2,232
 d0202cc:	10800037 	ldwio	r2,0(r2)
 d0202d0:	1080012c 	andhi	r2,r2,4
 d0202d4:	1005003a 	cmpeq	r2,r2,zero
 d0202d8:	1000201e 	bne	r2,zero,d02035c <tse_mac_init+0x704>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 d0202dc:	e0bffe17 	ldw	r2,-8(fp)
 d0202e0:	00c341b4 	movhi	r3,3334
 d0202e4:	18f19404 	addi	r3,r3,-14768
 d0202e8:	10801324 	muli	r2,r2,76
 d0202ec:	10c5883a 	add	r2,r2,r3
 d0202f0:	10c00a04 	addi	r3,r2,40
 d0202f4:	00800044 	movi	r2,1
 d0202f8:	18800015 	stw	r2,0(r3)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 d0202fc:	e0bffe17 	ldw	r2,-8(fp)
 d020300:	00c341b4 	movhi	r3,3334
 d020304:	18f19404 	addi	r3,r3,-14768
 d020308:	10801324 	muli	r2,r2,76
 d02030c:	10c5883a 	add	r2,r2,r3
 d020310:	10800104 	addi	r2,r2,4
 d020314:	10800017 	ldw	r2,0(r2)
 d020318:	10803b04 	addi	r2,r2,236
 d02031c:	1007883a 	mov	r3,r2
 d020320:	00808034 	movhi	r2,512
 d020324:	18800035 	stwio	r2,0(r3)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 d020328:	e0bffe17 	ldw	r2,-8(fp)
 d02032c:	00c341b4 	movhi	r3,3334
 d020330:	18f19404 	addi	r3,r3,-14768
 d020334:	10801324 	muli	r2,r2,76
 d020338:	10c5883a 	add	r2,r2,r3
 d02033c:	10800104 	addi	r2,r2,4
 d020340:	10800017 	ldw	r2,0(r2)
 d020344:	10803b04 	addi	r2,r2,236
 d020348:	10800037 	ldwio	r2,0(r2)
 d02034c:	1080802c 	andhi	r2,r2,512
 d020350:	1004c03a 	cmpne	r2,r2,zero
 d020354:	10000f1e 	bne	r2,zero,d020394 <tse_mac_init+0x73c>
 d020358:	00001d06 	br	d0203d0 <tse_mac_init+0x778>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 d02035c:	e0bffe17 	ldw	r2,-8(fp)
 d020360:	00c341b4 	movhi	r3,3334
 d020364:	18f19404 	addi	r3,r3,-14768
 d020368:	10801324 	muli	r2,r2,76
 d02036c:	10c5883a 	add	r2,r2,r3
 d020370:	10800a04 	addi	r2,r2,40
 d020374:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 d020378:	01034174 	movhi	r4,3333
 d02037c:	21399104 	addi	r4,r4,-6588
 d020380:	01400084 	movi	r5,2
 d020384:	d0029980 	call	d002998 <printf>
      return ENP_LOGIC;
 d020388:	00bffd44 	movi	r2,-11
 d02038c:	e0bfff15 	stw	r2,-4(fp)
 d020390:	0000e506 	br	d020728 <tse_mac_init+0xad0>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 d020394:	e0bffe17 	ldw	r2,-8(fp)
 d020398:	00c341b4 	movhi	r3,3334
 d02039c:	18f19404 	addi	r3,r3,-14768
 d0203a0:	10801324 	muli	r2,r2,76
 d0203a4:	10c5883a 	add	r2,r2,r3
 d0203a8:	10c00b04 	addi	r3,r2,44
 d0203ac:	00800044 	movi	r2,1
 d0203b0:	18800015 	stw	r2,0(r3)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 d0203b4:	00810034 	movhi	r2,1024
 d0203b8:	108080c4 	addi	r2,r2,515
 d0203bc:	e0bffd15 	stw	r2,-12(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 d0203c0:	e0bffc17 	ldw	r2,-16(fp)
 d0203c4:	10800060 	cmpeqi	r2,r2,1
 d0203c8:	10000f1e 	bne	r2,zero,d020408 <tse_mac_init+0x7b0>
 d0203cc:	00001706 	br	d02042c <tse_mac_init+0x7d4>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 d0203d0:	e0bffe17 	ldw	r2,-8(fp)
 d0203d4:	00c341b4 	movhi	r3,3334
 d0203d8:	18f19404 	addi	r3,r3,-14768
 d0203dc:	10801324 	muli	r2,r2,76
 d0203e0:	10c5883a 	add	r2,r2,r3
 d0203e4:	10800b04 	addi	r2,r2,44
 d0203e8:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 d0203ec:	01034174 	movhi	r4,3333
 d0203f0:	2139a904 	addi	r4,r4,-6492
 d0203f4:	01400084 	movi	r5,2
 d0203f8:	d0029980 	call	d002998 <printf>
      return ENP_LOGIC;
 d0203fc:	00bffd44 	movi	r2,-11
 d020400:	e0bfff15 	stw	r2,-4(fp)
 d020404:	0000c806 	br	d020728 <tse_mac_init+0xad0>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d020408:	e0bffd17 	ldw	r2,-12(fp)
 d02040c:	10800214 	ori	r2,r2,8
 d020410:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d020414:	e0fffd17 	ldw	r3,-12(fp)
 d020418:	00bf8034 	movhi	r2,65024
 d02041c:	10bfffc4 	addi	r2,r2,-1
 d020420:	1884703a 	and	r2,r3,r2
 d020424:	e0bffd15 	stw	r2,-12(fp)
 d020428:	00002106 	br	d0204b0 <tse_mac_init+0x858>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 d02042c:	e0bffc17 	ldw	r2,-16(fp)
 d020430:	10800098 	cmpnei	r2,r2,2
 d020434:	10000a1e 	bne	r2,zero,d020460 <tse_mac_init+0x808>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d020438:	e0fffd17 	ldw	r3,-12(fp)
 d02043c:	00bffdc4 	movi	r2,-9
 d020440:	1884703a 	and	r2,r3,r2
 d020444:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d020448:	e0fffd17 	ldw	r3,-12(fp)
 d02044c:	00bf8034 	movhi	r2,65024
 d020450:	10bfffc4 	addi	r2,r2,-1
 d020454:	1884703a 	and	r2,r3,r2
 d020458:	e0bffd15 	stw	r2,-12(fp)
 d02045c:	00001406 	br	d0204b0 <tse_mac_init+0x858>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 d020460:	e0bffc17 	ldw	r2,-16(fp)
 d020464:	10800118 	cmpnei	r2,r2,4
 d020468:	1000081e 	bne	r2,zero,d02048c <tse_mac_init+0x834>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d02046c:	e0fffd17 	ldw	r3,-12(fp)
 d020470:	00bffdc4 	movi	r2,-9
 d020474:	1884703a 	and	r2,r3,r2
 d020478:	e0bffd15 	stw	r2,-12(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d02047c:	e0bffd17 	ldw	r2,-12(fp)
 d020480:	10808034 	orhi	r2,r2,512
 d020484:	e0bffd15 	stw	r2,-12(fp)
 d020488:	00000906 	br	d0204b0 <tse_mac_init+0x858>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 d02048c:	e0fffd17 	ldw	r3,-12(fp)
 d020490:	00bffdc4 	movi	r2,-9
 d020494:	1884703a 	and	r2,r3,r2
 d020498:	e0bffd15 	stw	r2,-12(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 d02049c:	e0fffd17 	ldw	r3,-12(fp)
 d0204a0:	00bf8034 	movhi	r2,65024
 d0204a4:	10bfffc4 	addi	r2,r2,-1
 d0204a8:	1884703a 	and	r2,r3,r2
 d0204ac:	e0bffd15 	stw	r2,-12(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 d0204b0:	e0bffb17 	ldw	r2,-20(fp)
 d0204b4:	1004c03a 	cmpne	r2,r2,zero
 d0204b8:	1000041e 	bne	r2,zero,d0204cc <tse_mac_init+0x874>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 d0204bc:	e0bffd17 	ldw	r2,-12(fp)
 d0204c0:	10810014 	ori	r2,r2,1024
 d0204c4:	e0bffd15 	stw	r2,-12(fp)
 d0204c8:	00000406 	br	d0204dc <tse_mac_init+0x884>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 d0204cc:	e0bffd17 	ldw	r2,-12(fp)
 d0204d0:	00feffc4 	movi	r3,-1025
 d0204d4:	10c4703a 	and	r2,r2,r3
 d0204d8:	e0bffd15 	stw	r2,-12(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 d0204dc:	e0bffe17 	ldw	r2,-8(fp)
 d0204e0:	00c341b4 	movhi	r3,3334
 d0204e4:	18f19404 	addi	r3,r3,-14768
 d0204e8:	10801324 	muli	r2,r2,76
 d0204ec:	10c5883a 	add	r2,r2,r3
 d0204f0:	10800104 	addi	r2,r2,4
 d0204f4:	10800017 	ldw	r2,0(r2)
 d0204f8:	10800204 	addi	r2,r2,8
 d0204fc:	1007883a 	mov	r3,r2
 d020500:	e0bffd17 	ldw	r2,-12(fp)
 d020504:	18800035 	stwio	r2,0(r3)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 d020508:	e0bffe17 	ldw	r2,-8(fp)
 d02050c:	00c341b4 	movhi	r3,3334
 d020510:	18f19404 	addi	r3,r3,-14768
 d020514:	10801324 	muli	r2,r2,76
 d020518:	10c5883a 	add	r2,r2,r3
 d02051c:	10800104 	addi	r2,r2,4
 d020520:	10800017 	ldw	r2,0(r2)
 d020524:	10800204 	addi	r2,r2,8
 d020528:	11400037 	ldwio	r5,0(r2)
 d02052c:	01034174 	movhi	r4,3333
 d020530:	2139c104 	addi	r4,r4,-6396
 d020534:	d0029980 	call	d002998 <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 d020538:	e0bffe17 	ldw	r2,-8(fp)
 d02053c:	00c341b4 	movhi	r3,3334
 d020540:	18f19404 	addi	r3,r3,-14768
 d020544:	10801324 	muli	r2,r2,76
 d020548:	10c5883a 	add	r2,r2,r3
 d02054c:	10800104 	addi	r2,r2,4
 d020550:	10800017 	ldw	r2,0(r2)
 d020554:	11400304 	addi	r5,r2,12
 d020558:	e0bffe17 	ldw	r2,-8(fp)
 d02055c:	00c341b4 	movhi	r3,3334
 d020560:	18f19404 	addi	r3,r3,-14768
 d020564:	10801324 	muli	r2,r2,76
 d020568:	10c5883a 	add	r2,r2,r3
 d02056c:	10800604 	addi	r2,r2,24
 d020570:	10800003 	ldbu	r2,0(r2)
 d020574:	11003fcc 	andi	r4,r2,255
 d020578:	e0bffe17 	ldw	r2,-8(fp)
 d02057c:	00c341b4 	movhi	r3,3334
 d020580:	18f19404 	addi	r3,r3,-14768
 d020584:	10801324 	muli	r2,r2,76
 d020588:	10c5883a 	add	r2,r2,r3
 d02058c:	10800644 	addi	r2,r2,25
 d020590:	10800003 	ldbu	r2,0(r2)
 d020594:	10803fcc 	andi	r2,r2,255
 d020598:	1004923a 	slli	r2,r2,8
 d02059c:	2088b03a 	or	r4,r4,r2
 d0205a0:	e0bffe17 	ldw	r2,-8(fp)
 d0205a4:	00c341b4 	movhi	r3,3334
 d0205a8:	18f19404 	addi	r3,r3,-14768
 d0205ac:	10801324 	muli	r2,r2,76
 d0205b0:	10c5883a 	add	r2,r2,r3
 d0205b4:	10800684 	addi	r2,r2,26
 d0205b8:	10800003 	ldbu	r2,0(r2)
 d0205bc:	10803fcc 	andi	r2,r2,255
 d0205c0:	1004943a 	slli	r2,r2,16
 d0205c4:	2088b03a 	or	r4,r4,r2
 d0205c8:	e0bffe17 	ldw	r2,-8(fp)
 d0205cc:	00c341b4 	movhi	r3,3334
 d0205d0:	18f19404 	addi	r3,r3,-14768
 d0205d4:	10801324 	muli	r2,r2,76
 d0205d8:	10c5883a 	add	r2,r2,r3
 d0205dc:	108006c4 	addi	r2,r2,27
 d0205e0:	10800003 	ldbu	r2,0(r2)
 d0205e4:	10803fcc 	andi	r2,r2,255
 d0205e8:	1004963a 	slli	r2,r2,24
 d0205ec:	2086b03a 	or	r3,r4,r2
 d0205f0:	2805883a 	mov	r2,r5
 d0205f4:	10c00035 	stwio	r3,0(r2)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 d0205f8:	e0bffe17 	ldw	r2,-8(fp)
 d0205fc:	00c341b4 	movhi	r3,3334
 d020600:	18f19404 	addi	r3,r3,-14768
 d020604:	10801324 	muli	r2,r2,76
 d020608:	10c5883a 	add	r2,r2,r3
 d02060c:	10800104 	addi	r2,r2,4
 d020610:	10800017 	ldw	r2,0(r2)
 d020614:	11400404 	addi	r5,r2,16
 d020618:	e0bffe17 	ldw	r2,-8(fp)
 d02061c:	00c341b4 	movhi	r3,3334
 d020620:	18f19404 	addi	r3,r3,-14768
 d020624:	10801324 	muli	r2,r2,76
 d020628:	10c5883a 	add	r2,r2,r3
 d02062c:	10800704 	addi	r2,r2,28
 d020630:	10800003 	ldbu	r2,0(r2)
 d020634:	11003fcc 	andi	r4,r2,255
 d020638:	e0bffe17 	ldw	r2,-8(fp)
 d02063c:	00c341b4 	movhi	r3,3334
 d020640:	18f19404 	addi	r3,r3,-14768
 d020644:	10801324 	muli	r2,r2,76
 d020648:	10c5883a 	add	r2,r2,r3
 d02064c:	10800744 	addi	r2,r2,29
 d020650:	10800003 	ldbu	r2,0(r2)
 d020654:	10803fcc 	andi	r2,r2,255
 d020658:	1004923a 	slli	r2,r2,8
 d02065c:	2084b03a 	or	r2,r4,r2
 d020660:	10ffffcc 	andi	r3,r2,65535
 d020664:	2805883a 	mov	r2,r5
 d020668:	10c00035 	stwio	r3,0(r2)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 d02066c:	e0bffe17 	ldw	r2,-8(fp)
 d020670:	00c341b4 	movhi	r3,3334
 d020674:	18f2a504 	addi	r3,r3,-13676
 d020678:	1085883a 	add	r2,r2,r2
 d02067c:	1085883a 	add	r2,r2,r2
 d020680:	10c5883a 	add	r2,r2,r3
 d020684:	10800017 	ldw	r2,0(r2)
 d020688:	10c02717 	ldw	r3,156(r2)
 d02068c:	00800044 	movi	r2,1
 d020690:	18800615 	stw	r2,24(r3)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 d020694:	e0bffe17 	ldw	r2,-8(fp)
 d020698:	00c341b4 	movhi	r3,3334
 d02069c:	18f2a504 	addi	r3,r3,-13676
 d0206a0:	1085883a 	add	r2,r2,r2
 d0206a4:	1085883a 	add	r2,r2,r2
 d0206a8:	10c5883a 	add	r2,r2,r3
 d0206ac:	10800017 	ldw	r2,0(r2)
 d0206b0:	10c02717 	ldw	r3,156(r2)
 d0206b4:	00800044 	movi	r2,1
 d0206b8:	18800715 	stw	r2,28(r3)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 d0206bc:	e0bffe17 	ldw	r2,-8(fp)
 d0206c0:	00c341b4 	movhi	r3,3334
 d0206c4:	18f19404 	addi	r3,r3,-14768
 d0206c8:	10801324 	muli	r2,r2,76
 d0206cc:	10c5883a 	add	r2,r2,r3
 d0206d0:	10800304 	addi	r2,r2,12
 d0206d4:	11000017 	ldw	r4,0(r2)
 d0206d8:	e0bffe17 	ldw	r2,-8(fp)
 d0206dc:	10801324 	muli	r2,r2,76
 d0206e0:	1007883a 	mov	r3,r2
 d0206e4:	008341b4 	movhi	r2,3334
 d0206e8:	10b19404 	addi	r2,r2,-14768
 d0206ec:	188f883a 	add	r7,r3,r2
 d0206f0:	014340b4 	movhi	r5,3330
 d0206f4:	29428e04 	addi	r5,r5,2616
 d0206f8:	01800604 	movi	r6,24
 d0206fc:	d019b700 	call	d019b70 <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 d020700:	e0bffe17 	ldw	r2,-8(fp)
 d020704:	10801324 	muli	r2,r2,76
 d020708:	1007883a 	mov	r3,r2
 d02070c:	008341b4 	movhi	r2,3334
 d020710:	10b19404 	addi	r2,r2,-14768
 d020714:	1889883a 	add	r4,r3,r2
 d020718:	d020ae00 	call	d020ae0 <tse_sgdma_read_init>
 d02071c:	e0bff815 	stw	r2,-32(fp)
  
  return status;
 d020720:	e0bff817 	ldw	r2,-32(fp)
 d020724:	e0bfff15 	stw	r2,-4(fp)
 d020728:	e0bfff17 	ldw	r2,-4(fp)
}
 d02072c:	e037883a 	mov	sp,fp
 d020730:	dfc00117 	ldw	ra,4(sp)
 d020734:	df000017 	ldw	fp,0(sp)
 d020738:	dec00204 	addi	sp,sp,8
 d02073c:	f800283a 	ret

0d020740 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 d020740:	defe6304 	addi	sp,sp,-1652
 d020744:	dfc19c15 	stw	ra,1648(sp)
 d020748:	df019b15 	stw	fp,1644(sp)
 d02074c:	df019b04 	addi	fp,sp,1644
 d020750:	e13ffc15 	stw	r4,-16(fp)
 d020754:	e17ffd15 	stw	r5,-12(fp)
 d020758:	e1bffe15 	stw	r6,-8(fp)
   int result,i,tx_length;
   unsigned len = data_bytes;
 d02075c:	e0bffe17 	ldw	r2,-8(fp)
 d020760:	e0be7215 	stw	r2,-1592(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 d020764:	e0bffc17 	ldw	r2,-16(fp)
 d020768:	10802817 	ldw	r2,160(r2)
 d02076c:	e0be7115 	stw	r2,-1596(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 d020770:	e0be7117 	ldw	r2,-1596(fp)
 d020774:	10801217 	ldw	r2,72(r2)
 d020778:	e0be7015 	stw	r2,-1600(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d02077c:	0005303a 	rdctl	r2,status
 d020780:	e0be6c15 	stw	r2,-1616(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d020784:	e0fe6c17 	ldw	r3,-1616(fp)
 d020788:	00bfff84 	movi	r2,-2
 d02078c:	1884703a 	and	r2,r3,r2
 d020790:	1001703a 	wrctl	status,r2
  
  return context;
 d020794:	e0be6c17 	ldw	r2,-1616(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 d020798:	e0be6d15 	stw	r2,-1612(fp)
   mi = &tse_ptr->mi;
 d02079c:	e0be7117 	ldw	r2,-1596(fp)
 d0207a0:	10800104 	addi	r2,r2,4
 d0207a4:	e0be6f15 	stw	r2,-1604(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 d0207a8:	e0be7117 	ldw	r2,-1596(fp)
 d0207ac:	10800c17 	ldw	r2,48(r2)
 d0207b0:	1005003a 	cmpeq	r2,r2,zero
 d0207b4:	10000a1e 	bne	r2,zero,d0207e0 <tse_mac_raw_send+0xa0>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 d0207b8:	01034174 	movhi	r4,3333
 d0207bc:	2139cd04 	addi	r4,r4,-6348
 d0207c0:	d002cc00 	call	d002cc0 <puts>
 d0207c4:	e0be6d17 	ldw	r2,-1612(fp)
 d0207c8:	e0be6b15 	stw	r2,-1620(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0207cc:	e0be6b17 	ldw	r2,-1620(fp)
 d0207d0:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 d0207d4:	00bffa84 	movi	r2,-22
 d0207d8:	e0bfff15 	stw	r2,-4(fp)
 d0207dc:	00009006 	br	d020a20 <tse_mac_raw_send+0x2e0>
   }
 
   tse_ptr->sem = 1;  
 d0207e0:	e0fe7117 	ldw	r3,-1596(fp)
 d0207e4:	00800044 	movi	r2,1
 d0207e8:	18800c15 	stw	r2,48(r3)

   if(((unsigned long)data & 0x03) == 0) 
 d0207ec:	e0bffd17 	ldw	r2,-12(fp)
 d0207f0:	108000cc 	andi	r2,r2,3
 d0207f4:	1004c03a 	cmpne	r2,r2,zero
 d0207f8:	1000031e 	bne	r2,zero,d020808 <tse_mac_raw_send+0xc8>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 d0207fc:	e0bffd17 	ldw	r2,-12(fp)
 d020800:	e0be6e15 	stw	r2,-1608(fp)
 d020804:	00001406 	br	d020858 <tse_mac_raw_send+0x118>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 d020808:	e03e7415 	stw	zero,-1584(fp)
 d02080c:	00000d06 	br	d020844 <tse_mac_raw_send+0x104>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 d020810:	e13e7417 	ldw	r4,-1584(fp)
 d020814:	e0be7417 	ldw	r2,-1584(fp)
 d020818:	1007883a 	mov	r3,r2
 d02081c:	e0bffd17 	ldw	r2,-12(fp)
 d020820:	1885883a 	add	r2,r3,r2
 d020824:	10800023 	ldbuio	r2,0(r2)
 d020828:	1007883a 	mov	r3,r2
 d02082c:	e0be7604 	addi	r2,fp,-1576
 d020830:	1105883a 	add	r2,r2,r4
 d020834:	10c00005 	stb	r3,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 d020838:	e0be7417 	ldw	r2,-1584(fp)
 d02083c:	10800044 	addi	r2,r2,1
 d020840:	e0be7415 	stw	r2,-1584(fp)
 d020844:	e0fe7417 	ldw	r3,-1584(fp)
 d020848:	e0be7217 	ldw	r2,-1592(fp)
 d02084c:	18bff036 	bltu	r3,r2,d020810 <tse_mac_raw_send+0xd0>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 d020850:	e0be7604 	addi	r2,fp,-1576
 d020854:	e0be6e15 	stw	r2,-1608(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 d020858:	e13e6e17 	ldw	r4,-1608(fp)
 d02085c:	01400104 	movi	r5,4
 d020860:	d03964c0 	call	d03964c <alt_remap_cached>
 d020864:	e0be6e15 	stw	r2,-1608(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 d020868:	e0be7017 	ldw	r2,-1600(fp)
 d02086c:	10800903 	ldbu	r2,36(r2)
 d020870:	10803fcc 	andi	r2,r2,255
 d020874:	10800058 	cmpnei	r2,r2,1
 d020878:	1000241e 	bne	r2,zero,d02090c <tse_mac_raw_send+0x1cc>
 d02087c:	e0be7217 	ldw	r2,-1592(fp)
 d020880:	108003f0 	cmpltui	r2,r2,15
 d020884:	1000211e 	bne	r2,zero,d02090c <tse_mac_raw_send+0x1cc>
 d020888:	e0be7017 	ldw	r2,-1600(fp)
 d02088c:	10800b17 	ldw	r2,44(r2)
 d020890:	1007883a 	mov	r3,r2
 d020894:	e0be7117 	ldw	r2,-1596(fp)
 d020898:	10800d17 	ldw	r2,52(r2)
 d02089c:	1085883a 	add	r2,r2,r2
 d0208a0:	1085883a 	add	r2,r2,r2
 d0208a4:	1885883a 	add	r2,r3,r2
 d0208a8:	10800037 	ldwio	r2,0(r2)
 d0208ac:	10800388 	cmpgei	r2,r2,14
 d0208b0:	1000161e 	bne	r2,zero,d02090c <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 d0208b4:	e0be7117 	ldw	r2,-1596(fp)
 d0208b8:	11000f17 	ldw	r4,60(r2)
 d0208bc:	e0be7117 	ldw	r2,-1596(fp)
 d0208c0:	10800f17 	ldw	r2,60(r2)
 d0208c4:	11400804 	addi	r5,r2,32
 d0208c8:	e1be6e17 	ldw	r6,-1608(fp)
 d0208cc:	e0be7217 	ldw	r2,-1592(fp)
 d0208d0:	11ffffcc 	andi	r7,r2,65535
 d0208d4:	d8000015 	stw	zero,0(sp)
 d0208d8:	00800044 	movi	r2,1
 d0208dc:	d8800115 	stw	r2,4(sp)
 d0208e0:	00800044 	movi	r2,1
 d0208e4:	d8800215 	stw	r2,8(sp)
 d0208e8:	d8000315 	stw	zero,12(sp)
 d0208ec:	d019a780 	call	d019a78 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 d0208f0:	e0be7117 	ldw	r2,-1596(fp)
 d0208f4:	11400f17 	ldw	r5,60(r2)
 d0208f8:	e13e6f17 	ldw	r4,-1604(fp)
 d0208fc:	d01a5d40 	call	d01a5d4 <tse_mac_sTxWrite>
 d020900:	e0be7315 	stw	r2,-1588(fp)
        result = 0;
 d020904:	e03e7515 	stw	zero,-1580(fp)
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 d020908:	00001b06 	br	d020978 <tse_mac_raw_send+0x238>
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 d02090c:	e0be7217 	ldw	r2,-1592(fp)
 d020910:	108003f0 	cmpltui	r2,r2,15
 d020914:	1000161e 	bne	r2,zero,d020970 <tse_mac_raw_send+0x230>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 d020918:	e0be7117 	ldw	r2,-1596(fp)
 d02091c:	11000f17 	ldw	r4,60(r2)
 d020920:	e0be7117 	ldw	r2,-1596(fp)
 d020924:	10800f17 	ldw	r2,60(r2)
 d020928:	11400804 	addi	r5,r2,32
 d02092c:	e1be6e17 	ldw	r6,-1608(fp)
 d020930:	e0be7217 	ldw	r2,-1592(fp)
 d020934:	11ffffcc 	andi	r7,r2,65535
 d020938:	d8000015 	stw	zero,0(sp)
 d02093c:	00800044 	movi	r2,1
 d020940:	d8800115 	stw	r2,4(sp)
 d020944:	00800044 	movi	r2,1
 d020948:	d8800215 	stw	r2,8(sp)
 d02094c:	d8000315 	stw	zero,12(sp)
 d020950:	d019a780 	call	d019a78 <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 d020954:	e0be7117 	ldw	r2,-1596(fp)
 d020958:	11400f17 	ldw	r5,60(r2)
 d02095c:	e13e6f17 	ldw	r4,-1604(fp)
 d020960:	d01a5d40 	call	d01a5d4 <tse_mac_sTxWrite>
 d020964:	e0be7315 	stw	r2,-1588(fp)
       result = 0;
 d020968:	e03e7515 	stw	zero,-1580(fp)
 d02096c:	00000206 	br	d020978 <tse_mac_raw_send+0x238>

   } else {
       result = -3;
 d020970:	00bfff44 	movi	r2,-3
 d020974:	e0be7515 	stw	r2,-1580(fp)
   }

   if(result < 0)   /* SGDMA not available */
 d020978:	e0be7517 	ldw	r2,-1580(fp)
 d02097c:	1004403a 	cmpge	r2,r2,zero
 d020980:	1000131e 	bne	r2,zero,d0209d0 <tse_mac_raw_send+0x290>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 d020984:	01034174 	movhi	r4,3333
 d020988:	2139d404 	addi	r4,r4,-6320
 d02098c:	e17e7517 	ldw	r5,-1580(fp)
 d020990:	e1be7217 	ldw	r6,-1592(fp)
 d020994:	d0029980 	call	d002998 <printf>
      net->n_mib->ifOutDiscards++;
 d020998:	e0bffc17 	ldw	r2,-16(fp)
 d02099c:	10c02717 	ldw	r3,156(r2)
 d0209a0:	18801217 	ldw	r2,72(r3)
 d0209a4:	10800044 	addi	r2,r2,1
 d0209a8:	18801215 	stw	r2,72(r3)
      tse_ptr->sem = 0;
 d0209ac:	e0be7117 	ldw	r2,-1596(fp)
 d0209b0:	10000c15 	stw	zero,48(r2)
 d0209b4:	e0be6d17 	ldw	r2,-1612(fp)
 d0209b8:	e0be6a15 	stw	r2,-1624(fp)
 d0209bc:	e0be6a17 	ldw	r2,-1624(fp)
 d0209c0:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 d0209c4:	00bffa84 	movi	r2,-22
 d0209c8:	e0bfff15 	stw	r2,-4(fp)
 d0209cc:	00001406 	br	d020a20 <tse_mac_raw_send+0x2e0>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 d0209d0:	e0bffc17 	ldw	r2,-16(fp)
 d0209d4:	11002717 	ldw	r4,156(r2)
 d0209d8:	e0bffc17 	ldw	r2,-16(fp)
 d0209dc:	10802717 	ldw	r2,156(r2)
 d0209e0:	10c00f17 	ldw	r3,60(r2)
 d0209e4:	e0bffe17 	ldw	r2,-8(fp)
 d0209e8:	1885883a 	add	r2,r3,r2
 d0209ec:	20800f15 	stw	r2,60(r4)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 d0209f0:	e0bffc17 	ldw	r2,-16(fp)
 d0209f4:	10c02717 	ldw	r3,156(r2)
 d0209f8:	18801017 	ldw	r2,64(r3)
 d0209fc:	10800044 	addi	r2,r2,1
 d020a00:	18801015 	stw	r2,64(r3)
      tse_ptr->sem = 0;
 d020a04:	e0be7117 	ldw	r2,-1596(fp)
 d020a08:	10000c15 	stw	zero,48(r2)
 d020a0c:	e0be6d17 	ldw	r2,-1612(fp)
 d020a10:	e0be6915 	stw	r2,-1628(fp)
 d020a14:	e0be6917 	ldw	r2,-1628(fp)
 d020a18:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 d020a1c:	e03fff15 	stw	zero,-4(fp)
 d020a20:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d020a24:	e037883a 	mov	sp,fp
 d020a28:	dfc00117 	ldw	ra,4(sp)
 d020a2c:	df000017 	ldw	fp,0(sp)
 d020a30:	dec00204 	addi	sp,sp,8
 d020a34:	f800283a 	ret

0d020a38 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 d020a38:	defffa04 	addi	sp,sp,-24
 d020a3c:	dfc00515 	stw	ra,20(sp)
 d020a40:	df000415 	stw	fp,16(sp)
 d020a44:	df000404 	addi	fp,sp,16
 d020a48:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 d020a4c:	e0bfff17 	ldw	r2,-4(fp)
 d020a50:	e0bffe15 	stw	r2,-8(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 d020a54:	008341b4 	movhi	r2,3334
 d020a58:	10b1e004 	addi	r2,r2,-14464
 d020a5c:	10800217 	ldw	r2,8(r2)
 d020a60:	e0bffc15 	stw	r2,-16(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 d020a64:	e0bffe17 	ldw	r2,-8(fp)
 d020a68:	10800317 	ldw	r2,12(r2)
 d020a6c:	10800317 	ldw	r2,12(r2)
 d020a70:	10800037 	ldwio	r2,0(r2)
 d020a74:	e0bffd05 	stb	r2,-12(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 d020a78:	e0bffd03 	ldbu	r2,-12(fp)
 d020a7c:	1080030c 	andi	r2,r2,12
 d020a80:	1005003a 	cmpeq	r2,r2,zero
 d020a84:	1000111e 	bne	r2,zero,d020acc <tse_sgdmaRx_isr+0x94>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 d020a88:	e13ffe17 	ldw	r4,-8(fp)
 d020a8c:	d020c880 	call	d020c88 <tse_mac_rcv>
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 d020a90:	e0bffe17 	ldw	r2,-8(fp)
 d020a94:	11000317 	ldw	r4,12(r2)
 d020a98:	e0bffe17 	ldw	r2,-8(fp)
 d020a9c:	10800f17 	ldw	r2,60(r2)
 d020aa0:	11401004 	addi	r5,r2,64
 d020aa4:	d0196640 	call	d019664 <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 d020aa8:	008341b4 	movhi	r2,3334
 d020aac:	10b1e004 	addi	r2,r2,-14464
 d020ab0:	10c00217 	ldw	r3,8(r2)
 d020ab4:	e0bffc17 	ldw	r2,-16(fp)
 d020ab8:	10c0040e 	bge	r2,r3,d020acc <tse_sgdmaRx_isr+0x94>
      SignalPktDemux();
 d020abc:	00834174 	movhi	r2,3333
 d020ac0:	108acc04 	addi	r2,r2,11056
 d020ac4:	11000017 	ldw	r4,0(r2)
 d020ac8:	d01364c0 	call	d01364c <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 d020acc:	e037883a 	mov	sp,fp
 d020ad0:	dfc00117 	ldw	ra,4(sp)
 d020ad4:	df000017 	ldw	fp,0(sp)
 d020ad8:	dec00204 	addi	sp,sp,8
 d020adc:	f800283a 	ret

0d020ae0 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 d020ae0:	defff904 	addi	sp,sp,-28
 d020ae4:	dfc00615 	stw	ra,24(sp)
 d020ae8:	df000515 	stw	fp,20(sp)
 d020aec:	dc000415 	stw	r16,16(sp)
 d020af0:	df000404 	addi	fp,sp,16
 d020af4:	e13ffe15 	stw	r4,-8(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 d020af8:	e0bffe17 	ldw	r2,-8(fp)
 d020afc:	10000e15 	stw	zero,56(r2)
 d020b00:	00004406 	br	d020c14 <tse_sgdma_read_init+0x134>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 d020b04:	e0bffe17 	ldw	r2,-8(fp)
 d020b08:	14000e17 	ldw	r16,56(r2)
 d020b0c:	01017f04 	movi	r4,1532
 d020b10:	d0287a40 	call	d0287a4 <pk_alloc>
 d020b14:	1009883a 	mov	r4,r2
 d020b18:	e0fffe17 	ldw	r3,-8(fp)
 d020b1c:	8405883a 	add	r2,r16,r16
 d020b20:	1085883a 	add	r2,r2,r2
 d020b24:	10c5883a 	add	r2,r2,r3
 d020b28:	10801104 	addi	r2,r2,68
 d020b2c:	11000015 	stw	r4,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 d020b30:	e0bffe17 	ldw	r2,-8(fp)
 d020b34:	10800e17 	ldw	r2,56(r2)
 d020b38:	e0fffe17 	ldw	r3,-8(fp)
 d020b3c:	1085883a 	add	r2,r2,r2
 d020b40:	1085883a 	add	r2,r2,r2
 d020b44:	10c5883a 	add	r2,r2,r3
 d020b48:	10801104 	addi	r2,r2,68
 d020b4c:	10800017 	ldw	r2,0(r2)
 d020b50:	1004c03a 	cmpne	r2,r2,zero
 d020b54:	10000c1e 	bne	r2,zero,d020b88 <tse_sgdma_read_init+0xa8>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 d020b58:	01034174 	movhi	r4,3333
 d020b5c:	2139e004 	addi	r4,r4,-6272
 d020b60:	d002cc00 	call	d002cc0 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 d020b64:	e0bffe17 	ldw	r2,-8(fp)
 d020b68:	10800817 	ldw	r2,32(r2)
 d020b6c:	10c02717 	ldw	r3,156(r2)
 d020b70:	18800c17 	ldw	r2,48(r3)
 d020b74:	10800044 	addi	r2,r2,1
 d020b78:	18800c15 	stw	r2,48(r3)
      
      return ENP_NOBUFFER;
 d020b7c:	00bffac4 	movi	r2,-21
 d020b80:	e0bfff15 	stw	r2,-4(fp)
 d020b84:	00003906 	br	d020c6c <tse_sgdma_read_init+0x18c>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 d020b88:	e0bffe17 	ldw	r2,-8(fp)
 d020b8c:	10800e17 	ldw	r2,56(r2)
 d020b90:	e0fffe17 	ldw	r3,-8(fp)
 d020b94:	1085883a 	add	r2,r2,r2
 d020b98:	1085883a 	add	r2,r2,r2
 d020b9c:	10c5883a 	add	r2,r2,r3
 d020ba0:	10801104 	addi	r2,r2,68
 d020ba4:	10800017 	ldw	r2,0(r2)
 d020ba8:	11000117 	ldw	r4,4(r2)
 d020bac:	01400104 	movi	r5,4
 d020bb0:	d03964c0 	call	d03964c <alt_remap_cached>
 d020bb4:	e0bffd15 	stw	r2,-12(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 d020bb8:	e0bffe17 	ldw	r2,-8(fp)
 d020bbc:	10c00f17 	ldw	r3,60(r2)
 d020bc0:	e0bffe17 	ldw	r2,-8(fp)
 d020bc4:	10800e17 	ldw	r2,56(r2)
 d020bc8:	1004917a 	slli	r2,r2,5
 d020bcc:	1885883a 	add	r2,r3,r2
 d020bd0:	11001004 	addi	r4,r2,64
 d020bd4:	e0bffe17 	ldw	r2,-8(fp)
 d020bd8:	10c00f17 	ldw	r3,60(r2)
 d020bdc:	e0bffe17 	ldw	r2,-8(fp)
 d020be0:	10800e17 	ldw	r2,56(r2)
 d020be4:	1004917a 	slli	r2,r2,5
 d020be8:	1885883a 	add	r2,r3,r2
 d020bec:	11401804 	addi	r5,r2,96
 d020bf0:	d8000015 	stw	zero,0(sp)
 d020bf4:	e1bffd17 	ldw	r6,-12(fp)
 d020bf8:	000f883a 	mov	r7,zero
 d020bfc:	d0199b40 	call	d0199b4 <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 d020c00:	e0bffe17 	ldw	r2,-8(fp)
 d020c04:	10800e17 	ldw	r2,56(r2)
 d020c08:	10c00044 	addi	r3,r2,1
 d020c0c:	e0bffe17 	ldw	r2,-8(fp)
 d020c10:	10c00e15 	stw	r3,56(r2)
 d020c14:	e0bffe17 	ldw	r2,-8(fp)
 d020c18:	10800e17 	ldw	r2,56(r2)
 d020c1c:	10800050 	cmplti	r2,r2,1
 d020c20:	103fb81e 	bne	r2,zero,d020b04 <tse_sgdma_read_init+0x24>
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 d020c24:	e0bffe17 	ldw	r2,-8(fp)
 d020c28:	11400e17 	ldw	r5,56(r2)
 d020c2c:	01034174 	movhi	r4,3333
 d020c30:	2139f104 	addi	r4,r4,-6204
 d020c34:	d0029980 	call	d002998 <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 d020c38:	e0bffe17 	ldw	r2,-8(fp)
 d020c3c:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 d020c40:	e0bffe17 	ldw	r2,-8(fp)
 d020c44:	10800f17 	ldw	r2,60(r2)
 d020c48:	10c01004 	addi	r3,r2,64
 d020c4c:	e0bffe17 	ldw	r2,-8(fp)
 d020c50:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 d020c54:	e0bffe17 	ldw	r2,-8(fp)
 d020c58:	11000104 	addi	r4,r2,4
 d020c5c:	e0bffe17 	ldw	r2,-8(fp)
 d020c60:	11401017 	ldw	r5,64(r2)
 d020c64:	d01a6c40 	call	d01a6c4 <tse_mac_aRxRead>
  
  return SUCCESS;
 d020c68:	e03fff15 	stw	zero,-4(fp)
 d020c6c:	e0bfff17 	ldw	r2,-4(fp)
}
 d020c70:	e037883a 	mov	sp,fp
 d020c74:	dfc00217 	ldw	ra,8(sp)
 d020c78:	df000117 	ldw	fp,4(sp)
 d020c7c:	dc000017 	ldw	r16,0(sp)
 d020c80:	dec00304 	addi	sp,sp,12
 d020c84:	f800283a 	ret

0d020c88 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 d020c88:	defff704 	addi	sp,sp,-36
 d020c8c:	dfc00815 	stw	ra,32(sp)
 d020c90:	df000715 	stw	fp,28(sp)
 d020c94:	df000704 	addi	fp,sp,28
 d020c98:	e13fff15 	stw	r4,-4(fp)
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 d020c9c:	e0bfff17 	ldw	r2,-4(fp)
 d020ca0:	10c00f17 	ldw	r3,60(r2)
 d020ca4:	e0bfff17 	ldw	r2,-4(fp)
 d020ca8:	10800e17 	ldw	r2,56(r2)
 d020cac:	1004917a 	slli	r2,r2,5
 d020cb0:	1885883a 	add	r2,r3,r2
 d020cb4:	10c01004 	addi	r3,r2,64
 d020cb8:	e0bfff17 	ldw	r2,-4(fp)
 d020cbc:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 d020cc0:	e0bfff17 	ldw	r2,-4(fp)
 d020cc4:	10801017 	ldw	r2,64(r2)
 d020cc8:	10800704 	addi	r2,r2,28
 d020ccc:	10800037 	ldwio	r2,0(r2)
 d020cd0:	1005d43a 	srai	r2,r2,16
 d020cd4:	1007883a 	mov	r3,r2
 d020cd8:	00bfffc4 	movi	r2,-1
 d020cdc:	1884703a 	and	r2,r3,r2
 d020ce0:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 d020ce4:	e0bfff17 	ldw	r2,-4(fp)
 d020ce8:	10801017 	ldw	r2,64(r2)
 d020cec:	10800704 	addi	r2,r2,28
 d020cf0:	1080002b 	ldhuio	r2,0(r2)
 d020cf4:	10bfff84 	addi	r2,r2,-2
 d020cf8:	e0bffd15 	stw	r2,-12(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 d020cfc:	e0bfff17 	ldw	r2,-4(fp)
 d020d00:	10800817 	ldw	r2,32(r2)
 d020d04:	11002717 	ldw	r4,156(r2)
 d020d08:	e0bfff17 	ldw	r2,-4(fp)
 d020d0c:	10800817 	ldw	r2,32(r2)
 d020d10:	10802717 	ldw	r2,156(r2)
 d020d14:	10c00917 	ldw	r3,36(r2)
 d020d18:	e0bffd17 	ldw	r2,-12(fp)
 d020d1c:	1885883a 	add	r2,r3,r2
 d020d20:	20800915 	stw	r2,36(r4)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 d020d24:	e0bfff17 	ldw	r2,-4(fp)
 d020d28:	10800e17 	ldw	r2,56(r2)
 d020d2c:	e0ffff17 	ldw	r3,-4(fp)
 d020d30:	1085883a 	add	r2,r2,r2
 d020d34:	1085883a 	add	r2,r2,r2
 d020d38:	10c5883a 	add	r2,r2,r3
 d020d3c:	10801104 	addi	r2,r2,68
 d020d40:	10800017 	ldw	r2,0(r2)
 d020d44:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 d020d48:	e0bffb17 	ldw	r2,-20(fp)
 d020d4c:	10800117 	ldw	r2,4(r2)
 d020d50:	10c00404 	addi	r3,r2,16
 d020d54:	e0bffb17 	ldw	r2,-20(fp)
 d020d58:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 d020d5c:	e0bffd17 	ldw	r2,-12(fp)
 d020d60:	10bffc84 	addi	r2,r2,-14
 d020d64:	1007883a 	mov	r3,r2
 d020d68:	e0bffb17 	ldw	r2,-20(fp)
 d020d6c:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 d020d70:	00834174 	movhi	r2,3333
 d020d74:	108ac904 	addi	r2,r2,11044
 d020d78:	10800017 	ldw	r2,0(r2)
 d020d7c:	1007883a 	mov	r3,r2
 d020d80:	e0bffb17 	ldw	r2,-20(fp)
 d020d84:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 d020d88:	e0bfff17 	ldw	r2,-4(fp)
 d020d8c:	10c00817 	ldw	r3,32(r2)
 d020d90:	e0bffb17 	ldw	r2,-20(fp)
 d020d94:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 d020d98:	e0bffb17 	ldw	r2,-20(fp)
 d020d9c:	10800117 	ldw	r2,4(r2)
 d020da0:	10800084 	addi	r2,r2,2
 d020da4:	e0bffe15 	stw	r2,-8(fp)
    rx_packet->type = eth->e_type;
 d020da8:	e0bffe17 	ldw	r2,-8(fp)
 d020dac:	10c0030b 	ldhu	r3,12(r2)
 d020db0:	e0bffb17 	ldw	r2,-20(fp)
 d020db4:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 d020db8:	e0bff903 	ldbu	r2,-28(fp)
 d020dbc:	10801fcc 	andi	r2,r2,127
 d020dc0:	1004c03a 	cmpne	r2,r2,zero
 d020dc4:	1000251e 	bne	r2,zero,d020e5c <tse_mac_rcv+0x1d4>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 d020dc8:	01017f04 	movi	r4,1532
 d020dcc:	d0287a40 	call	d0287a4 <pk_alloc>
 d020dd0:	e0bffc15 	stw	r2,-16(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 d020dd4:	e0bffc17 	ldw	r2,-16(fp)
 d020dd8:	1004c03a 	cmpne	r2,r2,zero
 d020ddc:	10000a1e 	bne	r2,zero,d020e08 <tse_mac_rcv+0x180>
        dprintf("No free buffers for rx\n");
 d020de0:	01034174 	movhi	r4,3333
 d020de4:	213a0204 	addi	r4,r4,-6136
 d020de8:	d002cc00 	call	d002cc0 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 d020dec:	e0bfff17 	ldw	r2,-4(fp)
 d020df0:	10800817 	ldw	r2,32(r2)
 d020df4:	10c02717 	ldw	r3,156(r2)
 d020df8:	18800c17 	ldw	r2,48(r3)
 d020dfc:	10800044 	addi	r2,r2,1
 d020e00:	18800c15 	stw	r2,48(r3)
 d020e04:	00001806 	br	d020e68 <tse_mac_rcv+0x1e0>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 d020e08:	e0bfff17 	ldw	r2,-4(fp)
 d020e0c:	10800e17 	ldw	r2,56(r2)
 d020e10:	e0ffff17 	ldw	r3,-4(fp)
 d020e14:	1085883a 	add	r2,r2,r2
 d020e18:	1085883a 	add	r2,r2,r2
 d020e1c:	10c5883a 	add	r2,r2,r3
 d020e20:	10801104 	addi	r2,r2,68
 d020e24:	11400017 	ldw	r5,0(r2)
 d020e28:	010341b4 	movhi	r4,3334
 d020e2c:	2131e004 	addi	r4,r4,-14464
 d020e30:	d028d780 	call	d028d78 <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 d020e34:	e0bfff17 	ldw	r2,-4(fp)
 d020e38:	10800e17 	ldw	r2,56(r2)
 d020e3c:	e0ffff17 	ldw	r3,-4(fp)
 d020e40:	1085883a 	add	r2,r2,r2
 d020e44:	1085883a 	add	r2,r2,r2
 d020e48:	10c5883a 	add	r2,r2,r3
 d020e4c:	10c01104 	addi	r3,r2,68
 d020e50:	e0bffc17 	ldw	r2,-16(fp)
 d020e54:	18800015 	stw	r2,0(r3)
 d020e58:	00000306 	br	d020e68 <tse_mac_rcv+0x1e0>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 d020e5c:	01034174 	movhi	r4,3333
 d020e60:	213a0804 	addi	r4,r4,-6112
 d020e64:	d002cc00 	call	d002cc0 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 d020e68:	e0bfff17 	ldw	r2,-4(fp)
 d020e6c:	10800e17 	ldw	r2,56(r2)
 d020e70:	e0ffff17 	ldw	r3,-4(fp)
 d020e74:	1085883a 	add	r2,r2,r2
 d020e78:	1085883a 	add	r2,r2,r2
 d020e7c:	10c5883a 	add	r2,r2,r3
 d020e80:	10801104 	addi	r2,r2,68
 d020e84:	10800017 	ldw	r2,0(r2)
 d020e88:	11000117 	ldw	r4,4(r2)
 d020e8c:	01400104 	movi	r5,4
 d020e90:	d03964c0 	call	d03964c <alt_remap_cached>
 d020e94:	e0bffa15 	stw	r2,-24(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 d020e98:	e0bfff17 	ldw	r2,-4(fp)
 d020e9c:	10801017 	ldw	r2,64(r2)
 d020ea0:	10800204 	addi	r2,r2,8
 d020ea4:	e0fffa17 	ldw	r3,-24(fp)
 d020ea8:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 d020eac:	e0bfff17 	ldw	r2,-4(fp)
 d020eb0:	10801017 	ldw	r2,64(r2)
 d020eb4:	10800704 	addi	r2,r2,28
 d020eb8:	1007883a 	mov	r3,r2
 d020ebc:	00a04034 	movhi	r2,33024
 d020ec0:	18800035 	stwio	r2,0(r3)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 d020ec4:	e037883a 	mov	sp,fp
 d020ec8:	dfc00117 	ldw	ra,4(sp)
 d020ecc:	df000017 	ldw	fp,0(sp)
 d020ed0:	dec00204 	addi	sp,sp,8
 d020ed4:	f800283a 	ret

0d020ed8 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 d020ed8:	defffc04 	addi	sp,sp,-16
 d020edc:	dfc00315 	stw	ra,12(sp)
 d020ee0:	df000215 	stw	fp,8(sp)
 d020ee4:	df000204 	addi	fp,sp,8
 d020ee8:	e13ffe15 	stw	r4,-8(fp)
 d020eec:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 d020ef0:	e13ffe17 	ldw	r4,-8(fp)
 d020ef4:	01434174 	movhi	r5,3333
 d020ef8:	297a1404 	addi	r5,r5,-6064
 d020efc:	d02486c0 	call	d02486c <ns_printf>
   return SUCCESS;
 d020f00:	0005883a 	mov	r2,zero
}
 d020f04:	e037883a 	mov	sp,fp
 d020f08:	dfc00117 	ldw	ra,4(sp)
 d020f0c:	df000017 	ldw	fp,0(sp)
 d020f10:	dec00204 	addi	sp,sp,8
 d020f14:	f800283a 	ret

0d020f18 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 d020f18:	defffc04 	addi	sp,sp,-16
 d020f1c:	dfc00315 	stw	ra,12(sp)
 d020f20:	df000215 	stw	fp,8(sp)
 d020f24:	df000204 	addi	fp,sp,8
 d020f28:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 d020f2c:	e0bfff17 	ldw	r2,-4(fp)
 d020f30:	00c341b4 	movhi	r3,3334
 d020f34:	18f2a504 	addi	r3,r3,-13676
 d020f38:	1085883a 	add	r2,r2,r2
 d020f3c:	1085883a 	add	r2,r2,r2
 d020f40:	10c5883a 	add	r2,r2,r3
 d020f44:	10800017 	ldw	r2,0(r2)
 d020f48:	10c02717 	ldw	r3,156(r2)
 d020f4c:	00800084 	movi	r2,2
 d020f50:	18800615 	stw	r2,24(r3)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 d020f54:	e0bfff17 	ldw	r2,-4(fp)
 d020f58:	00c341b4 	movhi	r3,3334
 d020f5c:	18f19404 	addi	r3,r3,-14768
 d020f60:	10801324 	muli	r2,r2,76
 d020f64:	10c5883a 	add	r2,r2,r3
 d020f68:	10800304 	addi	r2,r2,12
 d020f6c:	11000017 	ldw	r4,0(r2)
 d020f70:	000b883a 	mov	r5,zero
 d020f74:	000d883a 	mov	r6,zero
 d020f78:	000f883a 	mov	r7,zero
 d020f7c:	d019b700 	call	d019b70 <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 d020f80:	e0bfff17 	ldw	r2,-4(fp)
 d020f84:	00c341b4 	movhi	r3,3334
 d020f88:	18f19404 	addi	r3,r3,-14768
 d020f8c:	10801324 	muli	r2,r2,76
 d020f90:	10c5883a 	add	r2,r2,r3
 d020f94:	10800104 	addi	r2,r2,4
 d020f98:	10800017 	ldw	r2,0(r2)
 d020f9c:	10800204 	addi	r2,r2,8
 d020fa0:	10800037 	ldwio	r2,0(r2)
 d020fa4:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 d020fa8:	e0bfff17 	ldw	r2,-4(fp)
 d020fac:	00c341b4 	movhi	r3,3334
 d020fb0:	18f19404 	addi	r3,r3,-14768
 d020fb4:	10801324 	muli	r2,r2,76
 d020fb8:	10c5883a 	add	r2,r2,r3
 d020fbc:	10800104 	addi	r2,r2,4
 d020fc0:	10800017 	ldw	r2,0(r2)
 d020fc4:	11000204 	addi	r4,r2,8
 d020fc8:	e0fffe17 	ldw	r3,-8(fp)
 d020fcc:	00bfff44 	movi	r2,-3
 d020fd0:	1886703a 	and	r3,r3,r2
 d020fd4:	2005883a 	mov	r2,r4
 d020fd8:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 d020fdc:	e0bfff17 	ldw	r2,-4(fp)
 d020fe0:	00c341b4 	movhi	r3,3334
 d020fe4:	18f2a504 	addi	r3,r3,-13676
 d020fe8:	1085883a 	add	r2,r2,r2
 d020fec:	1085883a 	add	r2,r2,r2
 d020ff0:	10c5883a 	add	r2,r2,r3
 d020ff4:	10800017 	ldw	r2,0(r2)
 d020ff8:	10c02717 	ldw	r3,156(r2)
 d020ffc:	00800084 	movi	r2,2
 d021000:	18800715 	stw	r2,28(r3)

  return SUCCESS;
 d021004:	0005883a 	mov	r2,zero
}
 d021008:	e037883a 	mov	sp,fp
 d02100c:	dfc00117 	ldw	ra,4(sp)
 d021010:	df000017 	ldw	fp,0(sp)
 d021014:	dec00204 	addi	sp,sp,8
 d021018:	f800283a 	ret

0d02101c <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 d02101c:	defffc04 	addi	sp,sp,-16
 d021020:	dfc00315 	stw	ra,12(sp)
 d021024:	df000215 	stw	fp,8(sp)
 d021028:	df000204 	addi	fp,sp,8
 d02102c:	e13ffe15 	stw	r4,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 d021030:	e0bffe17 	ldw	r2,-8(fp)
 d021034:	10800808 	cmpgei	r2,r2,32
 d021038:	1000041e 	bne	r2,zero,d02104c <close+0x30>
 d02103c:	e13ffe17 	ldw	r4,-8(fp)
 d021040:	d0389300 	call	d038930 <alt_close>
 d021044:	e0bfff15 	stw	r2,-4(fp)
 d021048:	00000306 	br	d021058 <close+0x3c>
 d02104c:	e13ffe17 	ldw	r4,-8(fp)
 d021050:	d02da180 	call	d02da18 <t_socketclose>
 d021054:	e0bfff15 	stw	r2,-4(fp)
 d021058:	e0bfff17 	ldw	r2,-4(fp)
}
 d02105c:	e037883a 	mov	sp,fp
 d021060:	dfc00117 	ldw	ra,4(sp)
 d021064:	df000017 	ldw	fp,0(sp)
 d021068:	dec00204 	addi	sp,sp,8
 d02106c:	f800283a 	ret

0d021070 <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 d021070:	defff504 	addi	sp,sp,-44
 d021074:	dfc00a15 	stw	ra,40(sp)
 d021078:	df000915 	stw	fp,36(sp)
 d02107c:	df000904 	addi	fp,sp,36
 d021080:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 d021084:	d0a02e17 	ldw	r2,-32584(gp)
 d021088:	e0bffa15 	stw	r2,-24(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 d02108c:	d0a02e04 	addi	r2,gp,-32584
 d021090:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 d021094:	00003e06 	br	d021190 <iniche_devices_init+0x120>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 d021098:	e0fffa17 	ldw	r3,-24(fp)
 d02109c:	e0bffa17 	ldw	r2,-24(fp)
 d0210a0:	18800415 	stw	r2,16(r3)
        p_dev->if_num = if_count;
 d0210a4:	e0fffa17 	ldw	r3,-24(fp)
 d0210a8:	e0bfff17 	ldw	r2,-4(fp)
 d0210ac:	18800515 	stw	r2,20(r3)
        p_dev->p_net = nets[p_dev->if_num];
 d0210b0:	e0bffa17 	ldw	r2,-24(fp)
 d0210b4:	10800517 	ldw	r2,20(r2)
 d0210b8:	00c341b4 	movhi	r3,3334
 d0210bc:	18f2a504 	addi	r3,r3,-13676
 d0210c0:	1085883a 	add	r2,r2,r2
 d0210c4:	1085883a 	add	r2,r2,r2
 d0210c8:	10c5883a 	add	r2,r2,r3
 d0210cc:	10c00017 	ldw	r3,0(r2)
 d0210d0:	e0bffa17 	ldw	r2,-24(fp)
 d0210d4:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 d0210d8:	e0bffa17 	ldw	r2,-24(fp)
 d0210dc:	10800317 	ldw	r2,12(r2)
 d0210e0:	e13ffa17 	ldw	r4,-24(fp)
 d0210e4:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 d0210e8:	e0bffa17 	ldw	r2,-24(fp)
 d0210ec:	10800617 	ldw	r2,24(r2)
 d0210f0:	e0bff815 	stw	r2,-32(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 d0210f4:	e17ffb04 	addi	r5,fp,-20
 d0210f8:	e1bffc04 	addi	r6,fp,-16
 d0210fc:	e1fffd04 	addi	r7,fp,-12
 d021100:	e0bffe04 	addi	r2,fp,-8
 d021104:	d8800015 	stw	r2,0(sp)
 d021108:	e13ffa17 	ldw	r4,-24(fp)
 d02110c:	d00133c0 	call	d00133c <get_ip_addr>
 d021110:	1005003a 	cmpeq	r2,r2,zero
 d021114:	1000181e 	bne	r2,zero,d021178 <iniche_devices_init+0x108>
            /* 
             * OR in the DHCP flag, if enabled. This will allow any
             * application-specific flag setting in get_ip_addr(), such 
             * as enabling AUTOIP, to occur 
             */
            if (use_dhcp) {
 d021118:	e0bffe17 	ldw	r2,-8(fp)
 d02111c:	1005003a 	cmpeq	r2,r2,zero
 d021120:	1000051e 	bne	r2,zero,d021138 <iniche_devices_init+0xc8>
                p_net->n_flags |= NF_DHCPC;
 d021124:	e0bff817 	ldw	r2,-32(fp)
 d021128:	10802a17 	ldw	r2,168(r2)
 d02112c:	10c04014 	ori	r3,r2,256
 d021130:	e0bff817 	ldw	r2,-32(fp)
 d021134:	10c02a15 	stw	r3,168(r2)
            }
#endif
            p_net->n_ipaddr = ipaddr;
 d021138:	e0fffb17 	ldw	r3,-20(fp)
 d02113c:	e0bff817 	ldw	r2,-32(fp)
 d021140:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 d021144:	e0fffc17 	ldw	r3,-16(fp)
 d021148:	e0bff817 	ldw	r2,-32(fp)
 d02114c:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 d021150:	e0fffd17 	ldw	r3,-12(fp)
 d021154:	e0bff817 	ldw	r2,-32(fp)
 d021158:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 d02115c:	e0fff817 	ldw	r3,-32(fp)
 d021160:	00834134 	movhi	r2,3332
 d021164:	10ab2404 	addi	r2,r2,-21360
 d021168:	18802b15 	stw	r2,172(r3)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 d02116c:	e0fff817 	ldw	r3,-32(fp)
 d021170:	00800084 	movi	r2,2
 d021174:	18802f05 	stb	r2,188(r3)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 d021178:	e0bfff17 	ldw	r2,-4(fp)
 d02117c:	10800044 	addi	r2,r2,1
 d021180:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 d021184:	e0bffa17 	ldw	r2,-24(fp)
 d021188:	10800017 	ldw	r2,0(r2)
 d02118c:	e0bffa15 	stw	r2,-24(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 d021190:	e0fffa17 	ldw	r3,-24(fp)
 d021194:	e0bff917 	ldw	r2,-28(fp)
 d021198:	18bfbf1e 	bne	r3,r2,d021098 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 d02119c:	e0bfff17 	ldw	r2,-4(fp)
}
 d0211a0:	e037883a 	mov	sp,fp
 d0211a4:	dfc00117 	ldw	ra,4(sp)
 d0211a8:	df000017 	ldw	fp,0(sp)
 d0211ac:	dec00204 	addi	sp,sp,8
 d0211b0:	f800283a 	ret

0d0211b4 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 d0211b4:	defff804 	addi	sp,sp,-32
 d0211b8:	dfc00715 	stw	ra,28(sp)
 d0211bc:	df000615 	stw	fp,24(sp)
 d0211c0:	df000604 	addi	fp,sp,24
 d0211c4:	e13ffc15 	stw	r4,-16(fp)
 d0211c8:	e17ffd15 	stw	r5,-12(fp)
 d0211cc:	e1bffe15 	stw	r6,-8(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
 d0211d0:	e0bffc17 	ldw	r2,-16(fp)
 d0211d4:	10800808 	cmpgei	r2,r2,32
 d0211d8:	1000061e 	bne	r2,zero,d0211f4 <read+0x40>
 d0211dc:	e13ffc17 	ldw	r4,-16(fp)
 d0211e0:	e17ffd17 	ldw	r5,-12(fp)
 d0211e4:	e1bffe17 	ldw	r6,-8(fp)
 d0211e8:	d03946c0 	call	d03946c <alt_read>
 d0211ec:	e0bfff15 	stw	r2,-4(fp)
 d0211f0:	00000806 	br	d021214 <read+0x60>
 d0211f4:	e1bffe17 	ldw	r6,-8(fp)
 d0211f8:	d8000015 	stw	zero,0(sp)
 d0211fc:	d8000115 	stw	zero,4(sp)
 d021200:	e13ffc17 	ldw	r4,-16(fp)
 d021204:	e17ffd17 	ldw	r5,-12(fp)
 d021208:	000f883a 	mov	r7,zero
 d02120c:	d023de00 	call	d023de0 <bsd_recvfrom>
 d021210:	e0bfff15 	stw	r2,-4(fp)
 d021214:	e0bfff17 	ldw	r2,-4(fp)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
}
 d021218:	e037883a 	mov	sp,fp
 d02121c:	dfc00117 	ldw	ra,4(sp)
 d021220:	df000017 	ldw	fp,0(sp)
 d021224:	dec00204 	addi	sp,sp,8
 d021228:	f800283a 	ret

0d02122c <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 d02122c:	defffa04 	addi	sp,sp,-24
 d021230:	dfc00515 	stw	ra,20(sp)
 d021234:	df000415 	stw	fp,16(sp)
 d021238:	df000404 	addi	fp,sp,16
 d02123c:	e13ffc15 	stw	r4,-16(fp)
 d021240:	e17ffd15 	stw	r5,-12(fp)
 d021244:	e1bffe15 	stw	r6,-8(fp)
  if (fd < ALT_MAX_FD)
 d021248:	e0bffc17 	ldw	r2,-16(fp)
 d02124c:	10800808 	cmpgei	r2,r2,32
 d021250:	1000061e 	bne	r2,zero,d02126c <write+0x40>
  {
    return alt_write (fd, ptr, len);
 d021254:	e13ffc17 	ldw	r4,-16(fp)
 d021258:	e17ffd17 	ldw	r5,-12(fp)
 d02125c:	e1bffe17 	ldw	r6,-8(fp)
 d021260:	d0399e80 	call	d0399e8 <alt_write>
 d021264:	e0bfff15 	stw	r2,-4(fp)
 d021268:	00000606 	br	d021284 <write+0x58>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 d02126c:	e17ffd17 	ldw	r5,-12(fp)
 d021270:	e1bffe17 	ldw	r6,-8(fp)
 d021274:	e13ffc17 	ldw	r4,-16(fp)
 d021278:	000f883a 	mov	r7,zero
 d02127c:	d02d70c0 	call	d02d70c <t_send>
 d021280:	e0bfff15 	stw	r2,-4(fp)
 d021284:	e0bfff17 	ldw	r2,-4(fp)
  }  
}
 d021288:	e037883a 	mov	sp,fp
 d02128c:	dfc00117 	ldw	ra,4(sp)
 d021290:	df000017 	ldw	fp,0(sp)
 d021294:	dec00204 	addi	sp,sp,8
 d021298:	f800283a 	ret

0d02129c <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 d02129c:	defff704 	addi	sp,sp,-36
 d0212a0:	dfc00815 	stw	ra,32(sp)
 d0212a4:	df000715 	stw	fp,28(sp)
 d0212a8:	df000704 	addi	fp,sp,28
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 d0212ac:	e03ffa15 	stw	zero,-24(fp)
 d0212b0:	00005806 	br	d021414 <Netinit+0x178>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 d0212b4:	e0bffa17 	ldw	r2,-24(fp)
 d0212b8:	00c341b4 	movhi	r3,3334
 d0212bc:	18f2a504 	addi	r3,r3,-13676
 d0212c0:	1085883a 	add	r2,r2,r2
 d0212c4:	1085883a 	add	r2,r2,r2
 d0212c8:	10c5883a 	add	r2,r2,r3
 d0212cc:	10800017 	ldw	r2,0(r2)
 d0212d0:	10802717 	ldw	r2,156(r2)
 d0212d4:	10800217 	ldw	r2,8(r2)
 d0212d8:	10800198 	cmpnei	r2,r2,6
 d0212dc:	1000261e 	bne	r2,zero,d021378 <Netinit+0xdc>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 d0212e0:	e0bffa17 	ldw	r2,-24(fp)
 d0212e4:	00c341b4 	movhi	r3,3334
 d0212e8:	18f2a504 	addi	r3,r3,-13676
 d0212ec:	1085883a 	add	r2,r2,r2
 d0212f0:	1085883a 	add	r2,r2,r2
 d0212f4:	10c5883a 	add	r2,r2,r3
 d0212f8:	10800017 	ldw	r2,0(r2)
 d0212fc:	10800917 	ldw	r2,36(r2)
 d021300:	1004c03a 	cmpne	r2,r2,zero
 d021304:	1000091e 	bne	r2,zero,d02132c <Netinit+0x90>
            nets[i]->n_mtu = 1514;
 d021308:	e0bffa17 	ldw	r2,-24(fp)
 d02130c:	00c341b4 	movhi	r3,3334
 d021310:	18f2a504 	addi	r3,r3,-13676
 d021314:	1085883a 	add	r2,r2,r2
 d021318:	1085883a 	add	r2,r2,r2
 d02131c:	10c5883a 	add	r2,r2,r3
 d021320:	10c00017 	ldw	r3,0(r2)
 d021324:	00817a84 	movi	r2,1514
 d021328:	18800915 	stw	r2,36(r3)

         if (nets[i]->n_lnh == 0)
 d02132c:	e0bffa17 	ldw	r2,-24(fp)
 d021330:	00c341b4 	movhi	r3,3334
 d021334:	18f2a504 	addi	r3,r3,-13676
 d021338:	1085883a 	add	r2,r2,r2
 d02133c:	1085883a 	add	r2,r2,r2
 d021340:	10c5883a 	add	r2,r2,r3
 d021344:	10800017 	ldw	r2,0(r2)
 d021348:	10800817 	ldw	r2,32(r2)
 d02134c:	1004c03a 	cmpne	r2,r2,zero
 d021350:	1000091e 	bne	r2,zero,d021378 <Netinit+0xdc>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 d021354:	e0bffa17 	ldw	r2,-24(fp)
 d021358:	00c341b4 	movhi	r3,3334
 d02135c:	18f2a504 	addi	r3,r3,-13676
 d021360:	1085883a 	add	r2,r2,r2
 d021364:	1085883a 	add	r2,r2,r2
 d021368:	10c5883a 	add	r2,r2,r3
 d02136c:	10c00017 	ldw	r3,0(r2)
 d021370:	00800404 	movi	r2,16
 d021374:	18800815 	stw	r2,32(r3)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 d021378:	e0bffa17 	ldw	r2,-24(fp)
 d02137c:	00c341b4 	movhi	r3,3334
 d021380:	18f2a504 	addi	r3,r3,-13676
 d021384:	1085883a 	add	r2,r2,r2
 d021388:	1085883a 	add	r2,r2,r2
 d02138c:	10c5883a 	add	r2,r2,r3
 d021390:	10800017 	ldw	r2,0(r2)
 d021394:	10800817 	ldw	r2,32(r2)
 d021398:	d0e08117 	ldw	r3,-32252(gp)
 d02139c:	e0ffff15 	stw	r3,-4(fp)
 d0213a0:	e0bffe15 	stw	r2,-8(fp)
 d0213a4:	e0bffe17 	ldw	r2,-8(fp)
 d0213a8:	e0ffff17 	ldw	r3,-4(fp)
 d0213ac:	10c0020e 	bge	r2,r3,d0213b8 <Netinit+0x11c>
 d0213b0:	e0bfff17 	ldw	r2,-4(fp)
 d0213b4:	e0bffe15 	stw	r2,-8(fp)
 d0213b8:	e0fffe17 	ldw	r3,-8(fp)
 d0213bc:	d0e08115 	stw	r3,-32252(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 d0213c0:	e0bffa17 	ldw	r2,-24(fp)
 d0213c4:	00c341b4 	movhi	r3,3334
 d0213c8:	18f2a504 	addi	r3,r3,-13676
 d0213cc:	1085883a 	add	r2,r2,r2
 d0213d0:	1085883a 	add	r2,r2,r2
 d0213d4:	10c5883a 	add	r2,r2,r3
 d0213d8:	10800017 	ldw	r2,0(r2)
 d0213dc:	10800917 	ldw	r2,36(r2)
 d0213e0:	d0e08217 	ldw	r3,-32248(gp)
 d0213e4:	e0fffd15 	stw	r3,-12(fp)
 d0213e8:	e0bffc15 	stw	r2,-16(fp)
 d0213ec:	e0bffc17 	ldw	r2,-16(fp)
 d0213f0:	e0fffd17 	ldw	r3,-12(fp)
 d0213f4:	10c0020e 	bge	r2,r3,d021400 <Netinit+0x164>
 d0213f8:	e0bffd17 	ldw	r2,-12(fp)
 d0213fc:	e0bffc15 	stw	r2,-16(fp)
 d021400:	e0fffc17 	ldw	r3,-16(fp)
 d021404:	d0e08215 	stw	r3,-32248(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 d021408:	e0bffa17 	ldw	r2,-24(fp)
 d02140c:	10800044 	addi	r2,r2,1
 d021410:	e0bffa15 	stw	r2,-24(fp)
 d021414:	00834174 	movhi	r2,3333
 d021418:	108aa504 	addi	r2,r2,10900
 d02141c:	10800017 	ldw	r2,0(r2)
 d021420:	1007883a 	mov	r3,r2
 d021424:	e0bffa17 	ldw	r2,-24(fp)
 d021428:	10ffa216 	blt	r2,r3,d0212b4 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 d02142c:	008341b4 	movhi	r2,3334
 d021430:	10b1e004 	addi	r2,r2,-14464
 d021434:	10000115 	stw	zero,4(r2)
 d021438:	008341b4 	movhi	r2,3334
 d02143c:	10b1e004 	addi	r2,r2,-14464
 d021440:	10c00117 	ldw	r3,4(r2)
 d021444:	008341b4 	movhi	r2,3334
 d021448:	10b1e004 	addi	r2,r2,-14464
 d02144c:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 d021450:	008341b4 	movhi	r2,3334
 d021454:	10b1e004 	addi	r2,r2,-14464
 d021458:	10000215 	stw	zero,8(r2)
 d02145c:	008341b4 	movhi	r2,3334
 d021460:	10b1e004 	addi	r2,r2,-14464
 d021464:	10c00217 	ldw	r3,8(r2)
 d021468:	008341b4 	movhi	r2,3334
 d02146c:	10b1e004 	addi	r2,r2,-14464
 d021470:	10c00415 	stw	r3,16(r2)
 d021474:	008341b4 	movhi	r2,3334
 d021478:	10b1e004 	addi	r2,r2,-14464
 d02147c:	10c00417 	ldw	r3,16(r2)
 d021480:	008341b4 	movhi	r2,3334
 d021484:	10b1e004 	addi	r2,r2,-14464
 d021488:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d02148c:	01000084 	movi	r4,2
 d021490:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   e = pk_init();
 d021494:	d0285140 	call	d028514 <pk_init>
 d021498:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02149c:	01000084 	movi	r4,2
 d0214a0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 d0214a4:	e0bff917 	ldw	r2,-28(fp)
 d0214a8:	1005003a 	cmpeq	r2,r2,zero
 d0214ac:	1000031e 	bne	r2,zero,d0214bc <Netinit+0x220>
      return e;
 d0214b0:	e0bff917 	ldw	r2,-28(fp)
 d0214b4:	e0bffb15 	stw	r2,-20(fp)
 d0214b8:	00010506 	br	d0218d0 <Netinit+0x634>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 d0214bc:	010340b4 	movhi	r4,3330
 d0214c0:	21069204 	addi	r4,r4,6728
 d0214c4:	d02245c0 	call	d02245c <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 d0214c8:	e03ffa15 	stw	zero,-24(fp)
 d0214cc:	0000f906 	br	d0218b4 <Netinit+0x618>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 d0214d0:	e0bffa17 	ldw	r2,-24(fp)
 d0214d4:	00c341b4 	movhi	r3,3334
 d0214d8:	18f2a504 	addi	r3,r3,-13676
 d0214dc:	1085883a 	add	r2,r2,r2
 d0214e0:	1085883a 	add	r2,r2,r2
 d0214e4:	10c5883a 	add	r2,r2,r3
 d0214e8:	10800017 	ldw	r2,0(r2)
 d0214ec:	10800217 	ldw	r2,8(r2)
 d0214f0:	1005003a 	cmpeq	r2,r2,zero
 d0214f4:	1000931e 	bne	r2,zero,d021744 <Netinit+0x4a8>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 d0214f8:	e0bffa17 	ldw	r2,-24(fp)
 d0214fc:	00c341b4 	movhi	r3,3334
 d021500:	18f2a504 	addi	r3,r3,-13676
 d021504:	1085883a 	add	r2,r2,r2
 d021508:	1085883a 	add	r2,r2,r2
 d02150c:	10c5883a 	add	r2,r2,r3
 d021510:	10800017 	ldw	r2,0(r2)
 d021514:	10800217 	ldw	r2,8(r2)
 d021518:	e13ffa17 	ldw	r4,-24(fp)
 d02151c:	103ee83a 	callr	r2
 d021520:	e0bff915 	stw	r2,-28(fp)
 d021524:	e0bff917 	ldw	r2,-28(fp)
 d021528:	1005003a 	cmpeq	r2,r2,zero
 d02152c:	1000101e 	bne	r2,zero,d021570 <Netinit+0x2d4>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 d021530:	01034174 	movhi	r4,3333
 d021534:	213a2004 	addi	r4,r4,-6016
 d021538:	e17ff917 	ldw	r5,-28(fp)
 d02153c:	e1bffa17 	ldw	r6,-24(fp)
 d021540:	d0029980 	call	d002998 <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 d021544:	e0bffa17 	ldw	r2,-24(fp)
 d021548:	00c341b4 	movhi	r3,3334
 d02154c:	18f2a504 	addi	r3,r3,-13676
 d021550:	1085883a 	add	r2,r2,r2
 d021554:	1085883a 	add	r2,r2,r2
 d021558:	10c5883a 	add	r2,r2,r3
 d02155c:	10800017 	ldw	r2,0(r2)
 d021560:	10c02717 	ldw	r3,156(r2)
 d021564:	00800084 	movi	r2,2
 d021568:	18800715 	stw	r2,28(r3)
            continue;   /* ignore ifaces which fail */
 d02156c:	0000ce06 	br	d0218a8 <Netinit+0x60c>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 d021570:	e0bffa17 	ldw	r2,-24(fp)
 d021574:	00c341b4 	movhi	r3,3334
 d021578:	18f2a504 	addi	r3,r3,-13676
 d02157c:	1085883a 	add	r2,r2,r2
 d021580:	1085883a 	add	r2,r2,r2
 d021584:	10c5883a 	add	r2,r2,r3
 d021588:	10800017 	ldw	r2,0(r2)
 d02158c:	10802717 	ldw	r2,156(r2)
 d021590:	10800217 	ldw	r2,8(r2)
 d021594:	10800198 	cmpnei	r2,r2,6
 d021598:	1000111e 	bne	r2,zero,d0215e0 <Netinit+0x344>
            nets[i]->n_flags |= NF_BCAST;
 d02159c:	e0bffa17 	ldw	r2,-24(fp)
 d0215a0:	00c341b4 	movhi	r3,3334
 d0215a4:	18f2a504 	addi	r3,r3,-13676
 d0215a8:	1085883a 	add	r2,r2,r2
 d0215ac:	1085883a 	add	r2,r2,r2
 d0215b0:	10c5883a 	add	r2,r2,r3
 d0215b4:	11000017 	ldw	r4,0(r2)
 d0215b8:	e0bffa17 	ldw	r2,-24(fp)
 d0215bc:	00c341b4 	movhi	r3,3334
 d0215c0:	18f2a504 	addi	r3,r3,-13676
 d0215c4:	1085883a 	add	r2,r2,r2
 d0215c8:	1085883a 	add	r2,r2,r2
 d0215cc:	10c5883a 	add	r2,r2,r3
 d0215d0:	10800017 	ldw	r2,0(r2)
 d0215d4:	10802a17 	ldw	r2,168(r2)
 d0215d8:	10800054 	ori	r2,r2,1
 d0215dc:	20802a15 	stw	r2,168(r4)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 d0215e0:	e0bffa17 	ldw	r2,-24(fp)
 d0215e4:	00c341b4 	movhi	r3,3334
 d0215e8:	18f2a504 	addi	r3,r3,-13676
 d0215ec:	1085883a 	add	r2,r2,r2
 d0215f0:	1085883a 	add	r2,r2,r2
 d0215f4:	10c5883a 	add	r2,r2,r3
 d0215f8:	10800017 	ldw	r2,0(r2)
 d0215fc:	10c02717 	ldw	r3,156(r2)
 d021600:	00800044 	movi	r2,1
 d021604:	18800615 	stw	r2,24(r3)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 d021608:	e0bffa17 	ldw	r2,-24(fp)
 d02160c:	00c341b4 	movhi	r3,3334
 d021610:	18f2a504 	addi	r3,r3,-13676
 d021614:	1085883a 	add	r2,r2,r2
 d021618:	1085883a 	add	r2,r2,r2
 d02161c:	10c5883a 	add	r2,r2,r3
 d021620:	10800017 	ldw	r2,0(r2)
 d021624:	10800103 	ldbu	r2,4(r2)
 d021628:	10803fcc 	andi	r2,r2,255
 d02162c:	1080201c 	xori	r2,r2,128
 d021630:	10bfe004 	addi	r2,r2,-128
 d021634:	1004c03a 	cmpne	r2,r2,zero
 d021638:	1000421e 	bne	r2,zero,d021744 <Netinit+0x4a8>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 d02163c:	e0bffa17 	ldw	r2,-24(fp)
 d021640:	00c341b4 	movhi	r3,3334
 d021644:	18f2a504 	addi	r3,r3,-13676
 d021648:	1085883a 	add	r2,r2,r2
 d02164c:	1085883a 	add	r2,r2,r2
 d021650:	10c5883a 	add	r2,r2,r3
 d021654:	10800017 	ldw	r2,0(r2)
 d021658:	10802717 	ldw	r2,156(r2)
 d02165c:	10800217 	ldw	r2,8(r2)
 d021660:	10800198 	cmpnei	r2,r2,6
 d021664:	1000131e 	bne	r2,zero,d0216b4 <Netinit+0x418>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 d021668:	e0bffa17 	ldw	r2,-24(fp)
 d02166c:	00c341b4 	movhi	r3,3334
 d021670:	18f2a504 	addi	r3,r3,-13676
 d021674:	1085883a 	add	r2,r2,r2
 d021678:	1085883a 	add	r2,r2,r2
 d02167c:	10c5883a 	add	r2,r2,r3
 d021680:	10c00017 	ldw	r3,0(r2)
 d021684:	00801944 	movi	r2,101
 d021688:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 't';
 d02168c:	e0bffa17 	ldw	r2,-24(fp)
 d021690:	00c341b4 	movhi	r3,3334
 d021694:	18f2a504 	addi	r3,r3,-13676
 d021698:	1085883a 	add	r2,r2,r2
 d02169c:	1085883a 	add	r2,r2,r2
 d0216a0:	10c5883a 	add	r2,r2,r3
 d0216a4:	10c00017 	ldw	r3,0(r2)
 d0216a8:	00801d04 	movi	r2,116
 d0216ac:	18800145 	stb	r2,5(r3)
 d0216b0:	00001206 	br	d0216fc <Netinit+0x460>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 d0216b4:	e0bffa17 	ldw	r2,-24(fp)
 d0216b8:	00c341b4 	movhi	r3,3334
 d0216bc:	18f2a504 	addi	r3,r3,-13676
 d0216c0:	1085883a 	add	r2,r2,r2
 d0216c4:	1085883a 	add	r2,r2,r2
 d0216c8:	10c5883a 	add	r2,r2,r3
 d0216cc:	10c00017 	ldw	r3,0(r2)
 d0216d0:	00801a44 	movi	r2,105
 d0216d4:	18800105 	stb	r2,4(r3)
               nets[i]->name[1] = 'f';
 d0216d8:	e0bffa17 	ldw	r2,-24(fp)
 d0216dc:	00c341b4 	movhi	r3,3334
 d0216e0:	18f2a504 	addi	r3,r3,-13676
 d0216e4:	1085883a 	add	r2,r2,r2
 d0216e8:	1085883a 	add	r2,r2,r2
 d0216ec:	10c5883a 	add	r2,r2,r3
 d0216f0:	10c00017 	ldw	r3,0(r2)
 d0216f4:	00801984 	movi	r2,102
 d0216f8:	18800145 	stb	r2,5(r3)
            }
            nets[i]->name[2] = (char)(i + '1');
 d0216fc:	e0bffa17 	ldw	r2,-24(fp)
 d021700:	00c341b4 	movhi	r3,3334
 d021704:	18f2a504 	addi	r3,r3,-13676
 d021708:	1085883a 	add	r2,r2,r2
 d02170c:	1085883a 	add	r2,r2,r2
 d021710:	10c5883a 	add	r2,r2,r3
 d021714:	10c00017 	ldw	r3,0(r2)
 d021718:	e0bffa17 	ldw	r2,-24(fp)
 d02171c:	10800c44 	addi	r2,r2,49
 d021720:	18800185 	stb	r2,6(r3)
            nets[i]->name[3] = '\0';
 d021724:	e0bffa17 	ldw	r2,-24(fp)
 d021728:	00c341b4 	movhi	r3,3334
 d02172c:	18f2a504 	addi	r3,r3,-13676
 d021730:	1085883a 	add	r2,r2,r2
 d021734:	1085883a 	add	r2,r2,r2
 d021738:	10c5883a 	add	r2,r2,r3
 d02173c:	10800017 	ldw	r2,0(r2)
 d021740:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 d021744:	e13ffa17 	ldw	r4,-24(fp)
 d021748:	d0218e80 	call	d0218e8 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 d02174c:	e0bffa17 	ldw	r2,-24(fp)
 d021750:	00c341b4 	movhi	r3,3334
 d021754:	18f2a504 	addi	r3,r3,-13676
 d021758:	1085883a 	add	r2,r2,r2
 d02175c:	1085883a 	add	r2,r2,r2
 d021760:	10c5883a 	add	r2,r2,r3
 d021764:	10800017 	ldw	r2,0(r2)
 d021768:	10800a17 	ldw	r2,40(r2)
 d02176c:	1005003a 	cmpeq	r2,r2,zero
 d021770:	10004d1e 	bne	r2,zero,d0218a8 <Netinit+0x60c>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 d021774:	e0bffa17 	ldw	r2,-24(fp)
 d021778:	00c341b4 	movhi	r3,3334
 d02177c:	18f2a504 	addi	r3,r3,-13676
 d021780:	1085883a 	add	r2,r2,r2
 d021784:	1085883a 	add	r2,r2,r2
 d021788:	10c5883a 	add	r2,r2,r3
 d02178c:	11400017 	ldw	r5,0(r2)
 d021790:	e0bffa17 	ldw	r2,-24(fp)
 d021794:	00c341b4 	movhi	r3,3334
 d021798:	18f2a504 	addi	r3,r3,-13676
 d02179c:	1085883a 	add	r2,r2,r2
 d0217a0:	1085883a 	add	r2,r2,r2
 d0217a4:	10c5883a 	add	r2,r2,r3
 d0217a8:	10800017 	ldw	r2,0(r2)
 d0217ac:	11000a17 	ldw	r4,40(r2)
 d0217b0:	e0bffa17 	ldw	r2,-24(fp)
 d0217b4:	00c341b4 	movhi	r3,3334
 d0217b8:	18f2a504 	addi	r3,r3,-13676
 d0217bc:	1085883a 	add	r2,r2,r2
 d0217c0:	1085883a 	add	r2,r2,r2
 d0217c4:	10c5883a 	add	r2,r2,r3
 d0217c8:	10800017 	ldw	r2,0(r2)
 d0217cc:	10800c17 	ldw	r2,48(r2)
 d0217d0:	0084303a 	nor	r2,zero,r2
 d0217d4:	2084b03a 	or	r2,r4,r2
 d0217d8:	28800e15 	stw	r2,56(r5)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 d0217dc:	e0bffa17 	ldw	r2,-24(fp)
 d0217e0:	00c341b4 	movhi	r3,3334
 d0217e4:	18f2a504 	addi	r3,r3,-13676
 d0217e8:	1085883a 	add	r2,r2,r2
 d0217ec:	1085883a 	add	r2,r2,r2
 d0217f0:	10c5883a 	add	r2,r2,r3
 d0217f4:	11400017 	ldw	r5,0(r2)
 d0217f8:	e0bffa17 	ldw	r2,-24(fp)
 d0217fc:	00c341b4 	movhi	r3,3334
 d021800:	18f2a504 	addi	r3,r3,-13676
 d021804:	1085883a 	add	r2,r2,r2
 d021808:	1085883a 	add	r2,r2,r2
 d02180c:	10c5883a 	add	r2,r2,r3
 d021810:	10800017 	ldw	r2,0(r2)
 d021814:	11000a17 	ldw	r4,40(r2)
 d021818:	e0bffa17 	ldw	r2,-24(fp)
 d02181c:	00c341b4 	movhi	r3,3334
 d021820:	18f2a504 	addi	r3,r3,-13676
 d021824:	1085883a 	add	r2,r2,r2
 d021828:	1085883a 	add	r2,r2,r2
 d02182c:	10c5883a 	add	r2,r2,r3
 d021830:	10800017 	ldw	r2,0(r2)
 d021834:	10800c17 	ldw	r2,48(r2)
 d021838:	2084703a 	and	r2,r4,r2
 d02183c:	28800f15 	stw	r2,60(r5)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 d021840:	e0bffa17 	ldw	r2,-24(fp)
 d021844:	00c341b4 	movhi	r3,3334
 d021848:	18f2a504 	addi	r3,r3,-13676
 d02184c:	1085883a 	add	r2,r2,r2
 d021850:	1085883a 	add	r2,r2,r2
 d021854:	10c5883a 	add	r2,r2,r3
 d021858:	11400017 	ldw	r5,0(r2)
 d02185c:	e0bffa17 	ldw	r2,-24(fp)
 d021860:	00c341b4 	movhi	r3,3334
 d021864:	18f2a504 	addi	r3,r3,-13676
 d021868:	1085883a 	add	r2,r2,r2
 d02186c:	1085883a 	add	r2,r2,r2
 d021870:	10c5883a 	add	r2,r2,r3
 d021874:	10800017 	ldw	r2,0(r2)
 d021878:	11000a17 	ldw	r4,40(r2)
 d02187c:	e0bffa17 	ldw	r2,-24(fp)
 d021880:	00c341b4 	movhi	r3,3334
 d021884:	18f2a504 	addi	r3,r3,-13676
 d021888:	1085883a 	add	r2,r2,r2
 d02188c:	1085883a 	add	r2,r2,r2
 d021890:	10c5883a 	add	r2,r2,r3
 d021894:	10800017 	ldw	r2,0(r2)
 d021898:	10800c17 	ldw	r2,48(r2)
 d02189c:	0084303a 	nor	r2,zero,r2
 d0218a0:	2084b03a 	or	r2,r4,r2
 d0218a4:	28801015 	stw	r2,64(r5)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 d0218a8:	e0bffa17 	ldw	r2,-24(fp)
 d0218ac:	10800044 	addi	r2,r2,1
 d0218b0:	e0bffa15 	stw	r2,-24(fp)
 d0218b4:	00834174 	movhi	r2,3333
 d0218b8:	108aa504 	addi	r2,r2,10900
 d0218bc:	10800017 	ldw	r2,0(r2)
 d0218c0:	1007883a 	mov	r3,r2
 d0218c4:	e0bffa17 	ldw	r2,-24(fp)
 d0218c8:	10ff0116 	blt	r2,r3,d0214d0 <Netinit+0x234>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 d0218cc:	e03ffb15 	stw	zero,-20(fp)
 d0218d0:	e0bffb17 	ldw	r2,-20(fp)
}
 d0218d4:	e037883a 	mov	sp,fp
 d0218d8:	dfc00117 	ldw	ra,4(sp)
 d0218dc:	df000017 	ldw	fp,0(sp)
 d0218e0:	dec00204 	addi	sp,sp,8
 d0218e4:	f800283a 	ret

0d0218e8 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 d0218e8:	defffc04 	addi	sp,sp,-16
 d0218ec:	dfc00315 	stw	ra,12(sp)
 d0218f0:	df000215 	stw	fp,8(sp)
 d0218f4:	df000204 	addi	fp,sp,8
 d0218f8:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 d0218fc:	e0bfff17 	ldw	r2,-4(fp)
 d021900:	00c341b4 	movhi	r3,3334
 d021904:	18f2a504 	addi	r3,r3,-13676
 d021908:	1085883a 	add	r2,r2,r2
 d02190c:	1085883a 	add	r2,r2,r2
 d021910:	10c5883a 	add	r2,r2,r3
 d021914:	10800017 	ldw	r2,0(r2)
 d021918:	10800c17 	ldw	r2,48(r2)
 d02191c:	1004c03a 	cmpne	r2,r2,zero
 d021920:	1000441e 	bne	r2,zero,d021a34 <fixup_subnet_mask+0x14c>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 d021924:	e0bfff17 	ldw	r2,-4(fp)
 d021928:	00c341b4 	movhi	r3,3334
 d02192c:	18f2a504 	addi	r3,r3,-13676
 d021930:	1085883a 	add	r2,r2,r2
 d021934:	1085883a 	add	r2,r2,r2
 d021938:	10c5883a 	add	r2,r2,r3
 d02193c:	10800017 	ldw	r2,0(r2)
 d021940:	10800a17 	ldw	r2,40(r2)
 d021944:	1080200c 	andi	r2,r2,128
 d021948:	1004c03a 	cmpne	r2,r2,zero
 d02194c:	1000031e 	bne	r2,zero,d02195c <fixup_subnet_mask+0x74>
      smask = 0xFF000000L;
 d021950:	00bfc034 	movhi	r2,65280
 d021954:	e0bffe15 	stw	r2,-8(fp)
 d021958:	00001f06 	br	d0219d8 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 d02195c:	e0bfff17 	ldw	r2,-4(fp)
 d021960:	00c341b4 	movhi	r3,3334
 d021964:	18f2a504 	addi	r3,r3,-13676
 d021968:	1085883a 	add	r2,r2,r2
 d02196c:	1085883a 	add	r2,r2,r2
 d021970:	10c5883a 	add	r2,r2,r3
 d021974:	10800017 	ldw	r2,0(r2)
 d021978:	10800a17 	ldw	r2,40(r2)
 d02197c:	1080300c 	andi	r2,r2,192
 d021980:	10802018 	cmpnei	r2,r2,128
 d021984:	1000031e 	bne	r2,zero,d021994 <fixup_subnet_mask+0xac>
      smask = 0xFFFF0000L;
 d021988:	00bffff4 	movhi	r2,65535
 d02198c:	e0bffe15 	stw	r2,-8(fp)
 d021990:	00001106 	br	d0219d8 <fixup_subnet_mask+0xf0>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 d021994:	e0bfff17 	ldw	r2,-4(fp)
 d021998:	00c341b4 	movhi	r3,3334
 d02199c:	18f2a504 	addi	r3,r3,-13676
 d0219a0:	1085883a 	add	r2,r2,r2
 d0219a4:	1085883a 	add	r2,r2,r2
 d0219a8:	10c5883a 	add	r2,r2,r3
 d0219ac:	10800017 	ldw	r2,0(r2)
 d0219b0:	10800a17 	ldw	r2,40(r2)
 d0219b4:	1080380c 	andi	r2,r2,224
 d0219b8:	10803018 	cmpnei	r2,r2,192
 d0219bc:	1000031e 	bne	r2,zero,d0219cc <fixup_subnet_mask+0xe4>
      smask = 0xFFFFFF00L;
 d0219c0:	00bfc004 	movi	r2,-256
 d0219c4:	e0bffe15 	stw	r2,-8(fp)
 d0219c8:	00000306 	br	d0219d8 <fixup_subnet_mask+0xf0>
   else
   {
      dtrap();    /* bad logic or setup values */
 d0219cc:	d0293e80 	call	d0293e8 <dtrap>
      smask = 0xFFFFFF00L;
 d0219d0:	00bfc004 	movi	r2,-256
 d0219d4:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 d0219d8:	e0bfff17 	ldw	r2,-4(fp)
 d0219dc:	00c341b4 	movhi	r3,3334
 d0219e0:	18f2a504 	addi	r3,r3,-13676
 d0219e4:	1085883a 	add	r2,r2,r2
 d0219e8:	1085883a 	add	r2,r2,r2
 d0219ec:	10c5883a 	add	r2,r2,r3
 d0219f0:	11000017 	ldw	r4,0(r2)
 d0219f4:	e0bffe17 	ldw	r2,-8(fp)
 d0219f8:	1004d63a 	srli	r2,r2,24
 d0219fc:	10c03fcc 	andi	r3,r2,255
 d021a00:	e0bffe17 	ldw	r2,-8(fp)
 d021a04:	1004d23a 	srli	r2,r2,8
 d021a08:	10bfc00c 	andi	r2,r2,65280
 d021a0c:	1886b03a 	or	r3,r3,r2
 d021a10:	e0bffe17 	ldw	r2,-8(fp)
 d021a14:	10bfc00c 	andi	r2,r2,65280
 d021a18:	1004923a 	slli	r2,r2,8
 d021a1c:	1886b03a 	or	r3,r3,r2
 d021a20:	e0bffe17 	ldw	r2,-8(fp)
 d021a24:	10803fcc 	andi	r2,r2,255
 d021a28:	1004963a 	slli	r2,r2,24
 d021a2c:	1884b03a 	or	r2,r3,r2
 d021a30:	20800c15 	stw	r2,48(r4)
}
 d021a34:	e037883a 	mov	sp,fp
 d021a38:	dfc00117 	ldw	ra,4(sp)
 d021a3c:	df000017 	ldw	fp,0(sp)
 d021a40:	dec00204 	addi	sp,sp,8
 d021a44:	f800283a 	ret

0d021a48 <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 d021a48:	defffc04 	addi	sp,sp,-16
 d021a4c:	dfc00315 	stw	ra,12(sp)
 d021a50:	df000215 	stw	fp,8(sp)
 d021a54:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 d021a58:	e03ffe15 	stw	zero,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 d021a5c:	d0a08317 	ldw	r2,-32244(gp)
 d021a60:	1080010c 	andi	r2,r2,4
 d021a64:	1005003a 	cmpeq	r2,r2,zero
 d021a68:	1000031e 	bne	r2,zero,d021a78 <netclose+0x30>
 d021a6c:	01034174 	movhi	r4,3333
 d021a70:	213a2704 	addi	r4,r4,-5988
 d021a74:	d002cc00 	call	d002cc0 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 d021a78:	008341b4 	movhi	r2,3334
 d021a7c:	10b4e604 	addi	r2,r2,-11368
 d021a80:	10800017 	ldw	r2,0(r2)
 d021a84:	e0bfff15 	stw	r2,-4(fp)
 d021a88:	00002106 	br	d021b10 <netclose+0xc8>
   {
      if (ifp->n_close)
 d021a8c:	e0bfff17 	ldw	r2,-4(fp)
 d021a90:	10800517 	ldw	r2,20(r2)
 d021a94:	1005003a 	cmpeq	r2,r2,zero
 d021a98:	10000e1e 	bne	r2,zero,d021ad4 <netclose+0x8c>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 d021a9c:	e0bfff17 	ldw	r2,-4(fp)
 d021aa0:	10802717 	ldw	r2,156(r2)
 d021aa4:	11400117 	ldw	r5,4(r2)
 d021aa8:	01034174 	movhi	r4,3333
 d021aac:	213a2c04 	addi	r4,r4,-5968
 d021ab0:	d0029980 	call	d002998 <printf>
         (*(ifp->n_close))(index++);
 d021ab4:	e0bfff17 	ldw	r2,-4(fp)
 d021ab8:	10c00517 	ldw	r3,20(r2)
 d021abc:	e13ffe17 	ldw	r4,-8(fp)
 d021ac0:	e0bffe17 	ldw	r2,-8(fp)
 d021ac4:	10800044 	addi	r2,r2,1
 d021ac8:	e0bffe15 	stw	r2,-8(fp)
 d021acc:	183ee83a 	callr	r3
 d021ad0:	00000c06 	br	d021b04 <netclose+0xbc>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 d021ad4:	d0a08317 	ldw	r2,-32244(gp)
 d021ad8:	1080010c 	andi	r2,r2,4
 d021adc:	1005003a 	cmpeq	r2,r2,zero
 d021ae0:	1000051e 	bne	r2,zero,d021af8 <netclose+0xb0>
 d021ae4:	e0bfff17 	ldw	r2,-4(fp)
 d021ae8:	11400104 	addi	r5,r2,4
 d021aec:	01034174 	movhi	r4,3333
 d021af0:	213a3304 	addi	r4,r4,-5940
 d021af4:	d0029980 	call	d002998 <printf>
#endif
         index++;
 d021af8:	e0bffe17 	ldw	r2,-8(fp)
 d021afc:	10800044 	addi	r2,r2,1
 d021b00:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 d021b04:	e0bfff17 	ldw	r2,-4(fp)
 d021b08:	10800017 	ldw	r2,0(r2)
 d021b0c:	e0bfff15 	stw	r2,-4(fp)
 d021b10:	e0bfff17 	ldw	r2,-4(fp)
 d021b14:	1004c03a 	cmpne	r2,r2,zero
 d021b18:	103fdc1e 	bne	r2,zero,d021a8c <netclose+0x44>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 d021b1c:	e037883a 	mov	sp,fp
 d021b20:	dfc00117 	ldw	ra,4(sp)
 d021b24:	df000017 	ldw	fp,0(sp)
 d021b28:	dec00204 	addi	sp,sp,8
 d021b2c:	f800283a 	ret

0d021b30 <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 d021b30:	defff804 	addi	sp,sp,-32
 d021b34:	dfc00715 	stw	ra,28(sp)
 d021b38:	df000615 	stw	fp,24(sp)
 d021b3c:	df000604 	addi	fp,sp,24
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 d021b40:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 d021b44:	0000e506 	br	d021edc <pktdemux+0x3ac>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 d021b48:	008341b4 	movhi	r2,3334
 d021b4c:	10b34c04 	addi	r2,r2,-13008
 d021b50:	10c00217 	ldw	r3,8(r2)
 d021b54:	e0bffb17 	ldw	r2,-20(fp)
 d021b58:	1884803a 	cmplt	r2,r3,r2
 d021b5c:	1007883a 	mov	r3,r2
 d021b60:	e0bffb17 	ldw	r2,-20(fp)
 d021b64:	10800044 	addi	r2,r2,1
 d021b68:	e0bffb15 	stw	r2,-20(fp)
 d021b6c:	18803fcc 	andi	r2,r3,255
 d021b70:	1005003a 	cmpeq	r2,r2,zero
 d021b74:	1000021e 	bne	r2,zero,d021b80 <pktdemux+0x50>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 d021b78:	d0252d40 	call	d0252d4 <tk_yield>
         pkts = 0;   /* reset counter */
 d021b7c:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 d021b80:	01000044 	movi	r4,1
 d021b84:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 d021b88:	010341b4 	movhi	r4,3334
 d021b8c:	2131e004 	addi	r4,r4,-14464
 d021b90:	d028cb00 	call	d028cb0 <getq>
 d021b94:	e0bffe15 	stw	r2,-8(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 d021b98:	01000044 	movi	r4,1
 d021b9c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 d021ba0:	e0bffe17 	ldw	r2,-8(fp)
 d021ba4:	1004c03a 	cmpne	r2,r2,zero
 d021ba8:	1000031e 	bne	r2,zero,d021bb8 <pktdemux+0x88>
 d021bac:	01034174 	movhi	r4,3333
 d021bb0:	213a3a04 	addi	r4,r4,-5912
 d021bb4:	d0246440 	call	d024644 <panic>
      ifc = pkt->net;
 d021bb8:	e0bffe17 	ldw	r2,-8(fp)
 d021bbc:	10800617 	ldw	r2,24(r2)
 d021bc0:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 d021bc4:	e0bffd17 	ldw	r2,-12(fp)
 d021bc8:	10802717 	ldw	r2,156(r2)
 d021bcc:	e0bffc15 	stw	r2,-16(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 d021bd0:	e0bffe17 	ldw	r2,-8(fp)
 d021bd4:	10800117 	ldw	r2,4(r2)
 d021bd8:	11400084 	addi	r5,r2,2
 d021bdc:	e13ffd17 	ldw	r4,-12(fp)
 d021be0:	d03c7f00 	call	d03c7f0 <isbcast>
 d021be4:	1005003a 	cmpeq	r2,r2,zero
 d021be8:	1000061e 	bne	r2,zero,d021c04 <pktdemux+0xd4>
         mib->ifInNUcastPkts++;
 d021bec:	e0bffc17 	ldw	r2,-16(fp)
 d021bf0:	10800b17 	ldw	r2,44(r2)
 d021bf4:	10c00044 	addi	r3,r2,1
 d021bf8:	e0bffc17 	ldw	r2,-16(fp)
 d021bfc:	10c00b15 	stw	r3,44(r2)
 d021c00:	00000506 	br	d021c18 <pktdemux+0xe8>
      else
         mib->ifInUcastPkts++;
 d021c04:	e0bffc17 	ldw	r2,-16(fp)
 d021c08:	10800a17 	ldw	r2,40(r2)
 d021c0c:	10c00044 	addi	r3,r2,1
 d021c10:	e0bffc17 	ldw	r2,-16(fp)
 d021c14:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 d021c18:	e0bffc17 	ldw	r2,-16(fp)
 d021c1c:	10800617 	ldw	r2,24(r2)
 d021c20:	10800098 	cmpnei	r2,r2,2
 d021c24:	10000c1e 	bne	r2,zero,d021c58 <pktdemux+0x128>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d021c28:	01000084 	movi	r4,2
 d021c2c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 d021c30:	e13ffe17 	ldw	r4,-8(fp)
 d021c34:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d021c38:	01000084 	movi	r4,2
 d021c3c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 d021c40:	e0bffc17 	ldw	r2,-16(fp)
 d021c44:	10800c17 	ldw	r2,48(r2)
 d021c48:	10c00044 	addi	r3,r2,1
 d021c4c:	e0bffc17 	ldw	r2,-16(fp)
 d021c50:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 d021c54:	0000a106 	br	d021edc <pktdemux+0x3ac>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 d021c58:	e0bffe17 	ldw	r2,-8(fp)
 d021c5c:	10800117 	ldw	r2,4(r2)
 d021c60:	10bfff04 	addi	r2,r2,-4
 d021c64:	10800003 	ldbu	r2,0(r2)
 d021c68:	10803fcc 	andi	r2,r2,255
 d021c6c:	1080201c 	xori	r2,r2,128
 d021c70:	10bfe004 	addi	r2,r2,-128
 d021c74:	10801358 	cmpnei	r2,r2,77
 d021c78:	10000b1e 	bne	r2,zero,d021ca8 <pktdemux+0x178>
 d021c7c:	e0bffe17 	ldw	r2,-8(fp)
 d021c80:	10c00117 	ldw	r3,4(r2)
 d021c84:	e0bffe17 	ldw	r2,-8(fp)
 d021c88:	10800217 	ldw	r2,8(r2)
 d021c8c:	1885883a 	add	r2,r3,r2
 d021c90:	10800003 	ldbu	r2,0(r2)
 d021c94:	10803fcc 	andi	r2,r2,255
 d021c98:	1080201c 	xori	r2,r2,128
 d021c9c:	10bfe004 	addi	r2,r2,-128
 d021ca0:	10801360 	cmpeqi	r2,r2,77
 d021ca4:	1000041e 	bne	r2,zero,d021cb8 <pktdemux+0x188>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 d021ca8:	d0293e80 	call	d0293e8 <dtrap>
         panic("pktdemux: corrupt pkt");
 d021cac:	01034174 	movhi	r4,3333
 d021cb0:	213a4004 	addi	r4,r4,-5888
 d021cb4:	d0246440 	call	d024644 <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 d021cb8:	e0bffd17 	ldw	r2,-12(fp)
 d021cbc:	10802a17 	ldw	r2,168(r2)
 d021cc0:	1080020c 	andi	r2,r2,8
 d021cc4:	1004c03a 	cmpne	r2,r2,zero
 d021cc8:	10004d1e 	bne	r2,zero,d021e00 <pktdemux+0x2d0>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 d021ccc:	e0bffd17 	ldw	r2,-12(fp)
 d021cd0:	10802717 	ldw	r2,156(r2)
 d021cd4:	10800217 	ldw	r2,8(r2)
 d021cd8:	108001a0 	cmpeqi	r2,r2,6
 d021cdc:	1000011e 	bne	r2,zero,d021ce4 <pktdemux+0x1b4>
 d021ce0:	00003a06 	br	d021dcc <pktdemux+0x29c>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 d021ce4:	e0bffe17 	ldw	r2,-8(fp)
 d021ce8:	10800117 	ldw	r2,4(r2)
 d021cec:	10800084 	addi	r2,r2,2
 d021cf0:	e0bffa15 	stw	r2,-24(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 d021cf4:	e0bffa17 	ldw	r2,-24(fp)
 d021cf8:	10800304 	addi	r2,r2,12
 d021cfc:	10800003 	ldbu	r2,0(r2)
 d021d00:	10803fcc 	andi	r2,r2,255
 d021d04:	1080201c 	xori	r2,r2,128
 d021d08:	10bfe004 	addi	r2,r2,-128
 d021d0c:	1004923a 	slli	r2,r2,8
 d021d10:	1007883a 	mov	r3,r2
 d021d14:	e0bffa17 	ldw	r2,-24(fp)
 d021d18:	10800344 	addi	r2,r2,13
 d021d1c:	10800003 	ldbu	r2,0(r2)
 d021d20:	10803fcc 	andi	r2,r2,255
 d021d24:	1080201c 	xori	r2,r2,128
 d021d28:	10bfe004 	addi	r2,r2,-128
 d021d2c:	10803fcc 	andi	r2,r2,255
 d021d30:	1885883a 	add	r2,r3,r2
 d021d34:	10bfffcc 	andi	r2,r2,65535
 d021d38:	1004d23a 	srli	r2,r2,8
 d021d3c:	10803fcc 	andi	r2,r2,255
 d021d40:	1009883a 	mov	r4,r2
 d021d44:	e0bffa17 	ldw	r2,-24(fp)
 d021d48:	10800304 	addi	r2,r2,12
 d021d4c:	10800003 	ldbu	r2,0(r2)
 d021d50:	10803fcc 	andi	r2,r2,255
 d021d54:	1080201c 	xori	r2,r2,128
 d021d58:	10bfe004 	addi	r2,r2,-128
 d021d5c:	1004923a 	slli	r2,r2,8
 d021d60:	1007883a 	mov	r3,r2
 d021d64:	e0bffa17 	ldw	r2,-24(fp)
 d021d68:	10800344 	addi	r2,r2,13
 d021d6c:	10800003 	ldbu	r2,0(r2)
 d021d70:	10803fcc 	andi	r2,r2,255
 d021d74:	1080201c 	xori	r2,r2,128
 d021d78:	10bfe004 	addi	r2,r2,-128
 d021d7c:	10803fcc 	andi	r2,r2,255
 d021d80:	1885883a 	add	r2,r3,r2
 d021d84:	10bfffcc 	andi	r2,r2,65535
 d021d88:	1004923a 	slli	r2,r2,8
 d021d8c:	1007883a 	mov	r3,r2
 d021d90:	00bfc004 	movi	r2,-256
 d021d94:	1884703a 	and	r2,r3,r2
 d021d98:	2084b03a 	or	r2,r4,r2
 d021d9c:	1007883a 	mov	r3,r2
 d021da0:	e0bffe17 	ldw	r2,-8(fp)
 d021da4:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 d021da8:	e0bffe17 	ldw	r2,-8(fp)
 d021dac:	10c00117 	ldw	r3,4(r2)
 d021db0:	e0bffe17 	ldw	r2,-8(fp)
 d021db4:	10800617 	ldw	r2,24(r2)
 d021db8:	10800817 	ldw	r2,32(r2)
 d021dbc:	1887883a 	add	r3,r3,r2
 d021dc0:	e0bffe17 	ldw	r2,-8(fp)
 d021dc4:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 d021dc8:	00000d06 	br	d021e00 <pktdemux+0x2d0>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 d021dcc:	e0bffd17 	ldw	r2,-12(fp)
 d021dd0:	10802717 	ldw	r2,156(r2)
 d021dd4:	11400217 	ldw	r5,8(r2)
 d021dd8:	01034174 	movhi	r4,3333
 d021ddc:	213a4604 	addi	r4,r4,-5864
 d021de0:	d0029980 	call	d002998 <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d021de4:	01000084 	movi	r4,2
 d021de8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free(pkt);
 d021dec:	e13ffe17 	ldw	r4,-8(fp)
 d021df0:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d021df4:	01000084 	movi	r4,2
 d021df8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            continue;
 d021dfc:	00003706 	br	d021edc <pktdemux+0x3ac>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 d021e00:	e0bffe17 	ldw	r2,-8(fp)
 d021e04:	1080080b 	ldhu	r2,32(r2)
 d021e08:	10bfffcc 	andi	r2,r2,65535
 d021e0c:	e0bfff15 	stw	r2,-4(fp)
 d021e10:	e0ffff17 	ldw	r3,-4(fp)
 d021e14:	18800220 	cmpeqi	r2,r3,8
 d021e18:	1000041e 	bne	r2,zero,d021e2c <pktdemux+0x2fc>
 d021e1c:	e0ffff17 	ldw	r3,-4(fp)
 d021e20:	18818220 	cmpeqi	r2,r3,1544
 d021e24:	1000081e 	bne	r2,zero,d021e48 <pktdemux+0x318>
 d021e28:	00000e06 	br	d021e64 <pktdemux+0x334>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 d021e2c:	0009883a 	mov	r4,zero
 d021e30:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 d021e34:	e13ffe17 	ldw	r4,-8(fp)
 d021e38:	d040a400 	call	d040a40 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 d021e3c:	0009883a 	mov	r4,zero
 d021e40:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         break;
 d021e44:	00002506 	br	d021edc <pktdemux+0x3ac>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 d021e48:	0009883a 	mov	r4,zero
 d021e4c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         arprcv(pkt);
 d021e50:	e13ffe17 	ldw	r4,-8(fp)
 d021e54:	d03bf800 	call	d03bf80 <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 d021e58:	0009883a 	mov	r4,zero
 d021e5c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         break;
 d021e60:	00001e06 	br	d021edc <pktdemux+0x3ac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 d021e64:	d0a08317 	ldw	r2,-32244(gp)
 d021e68:	1081000c 	andi	r2,r2,1024
 d021e6c:	1005003a 	cmpeq	r2,r2,zero
 d021e70:	10000f1e 	bne	r2,zero,d021eb0 <pktdemux+0x380>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 d021e74:	e0bffe17 	ldw	r2,-8(fp)
 d021e78:	1080080b 	ldhu	r2,32(r2)
 d021e7c:	10bfffcc 	andi	r2,r2,65535
 d021e80:	1004d23a 	srli	r2,r2,8
 d021e84:	10bfffcc 	andi	r2,r2,65535
 d021e88:	10c03fcc 	andi	r3,r2,255
 d021e8c:	e0bffe17 	ldw	r2,-8(fp)
 d021e90:	1080080b 	ldhu	r2,32(r2)
 d021e94:	10bfffcc 	andi	r2,r2,65535
 d021e98:	1004923a 	slli	r2,r2,8
 d021e9c:	10bfc00c 	andi	r2,r2,65280
 d021ea0:	188ab03a 	or	r5,r3,r2
 d021ea4:	01034174 	movhi	r4,3333
 d021ea8:	213a4e04 	addi	r4,r4,-5832
 d021eac:	d0029980 	call	d002998 <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 d021eb0:	e0bffd17 	ldw	r2,-12(fp)
 d021eb4:	10c02717 	ldw	r3,156(r2)
 d021eb8:	18800e17 	ldw	r2,56(r3)
 d021ebc:	10800044 	addi	r2,r2,1
 d021ec0:	18800e15 	stw	r2,56(r3)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d021ec4:	01000084 	movi	r4,2
 d021ec8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 d021ecc:	e13ffe17 	ldw	r4,-8(fp)
 d021ed0:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d021ed4:	01000084 	movi	r4,2
 d021ed8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 d021edc:	008341b4 	movhi	r2,3334
 d021ee0:	10b1e004 	addi	r2,r2,-14464
 d021ee4:	10800217 	ldw	r2,8(r2)
 d021ee8:	1004c03a 	cmpne	r2,r2,zero
 d021eec:	103f161e 	bne	r2,zero,d021b48 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 d021ef0:	e037883a 	mov	sp,fp
 d021ef4:	dfc00117 	ldw	ra,4(sp)
 d021ef8:	df000017 	ldw	fp,0(sp)
 d021efc:	dec00204 	addi	sp,sp,8
 d021f00:	f800283a 	ret

0d021f04 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 d021f04:	defffc04 	addi	sp,sp,-16
 d021f08:	df000315 	stw	fp,12(sp)
 d021f0c:	df000304 	addi	fp,sp,12
 d021f10:	e13ffd15 	stw	r4,-12(fp)
 d021f14:	e17ffe15 	stw	r5,-8(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 d021f18:	00834174 	movhi	r2,3333
 d021f1c:	108ac904 	addi	r2,r2,11044
 d021f20:	10800017 	ldw	r2,0(r2)
 d021f24:	1004403a 	cmpge	r2,r2,zero
 d021f28:	1000141e 	bne	r2,zero,d021f7c <c_older+0x78>
 d021f2c:	00834174 	movhi	r2,3333
 d021f30:	108ac904 	addi	r2,r2,11044
 d021f34:	10c00017 	ldw	r3,0(r2)
 d021f38:	e0bffd17 	ldw	r2,-12(fp)
 d021f3c:	18800536 	bltu	r3,r2,d021f54 <c_older+0x50>
 d021f40:	00834174 	movhi	r2,3333
 d021f44:	108ac904 	addi	r2,r2,11044
 d021f48:	10c00017 	ldw	r3,0(r2)
 d021f4c:	e0bffe17 	ldw	r2,-8(fp)
 d021f50:	18800a2e 	bgeu	r3,r2,d021f7c <c_older+0x78>
 d021f54:	00834174 	movhi	r2,3333
 d021f58:	108ac904 	addi	r2,r2,11044
 d021f5c:	10c00017 	ldw	r3,0(r2)
 d021f60:	e0bffd17 	ldw	r2,-12(fp)
 d021f64:	10c00e36 	bltu	r2,r3,d021fa0 <c_older+0x9c>
 d021f68:	00834174 	movhi	r2,3333
 d021f6c:	108ac904 	addi	r2,r2,11044
 d021f70:	10c00017 	ldw	r3,0(r2)
 d021f74:	e0bffe17 	ldw	r2,-8(fp)
 d021f78:	10c00936 	bltu	r2,r3,d021fa0 <c_older+0x9c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
   {
      if (ct1 < ct2)
 d021f7c:	e0fffd17 	ldw	r3,-12(fp)
 d021f80:	e0bffe17 	ldw	r2,-8(fp)
 d021f84:	1880032e 	bgeu	r3,r2,d021f94 <c_older+0x90>
         return(ct1);      /* then smaller is oldest */
 d021f88:	e0bffd17 	ldw	r2,-12(fp)
 d021f8c:	e0bfff15 	stw	r2,-4(fp)
 d021f90:	00000b06 	br	d021fc0 <c_older+0xbc>
      else 
         return(ct2);
 d021f94:	e0bffe17 	ldw	r2,-8(fp)
 d021f98:	e0bfff15 	stw	r2,-4(fp)
 d021f9c:	00000806 	br	d021fc0 <c_older+0xbc>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 d021fa0:	e0fffd17 	ldw	r3,-12(fp)
 d021fa4:	e0bffe17 	ldw	r2,-8(fp)
 d021fa8:	18800336 	bltu	r3,r2,d021fb8 <c_older+0xb4>
      return(ct1);
 d021fac:	e0bffd17 	ldw	r2,-12(fp)
 d021fb0:	e0bfff15 	stw	r2,-4(fp)
 d021fb4:	00000206 	br	d021fc0 <c_older+0xbc>
   else
      return(ct2);
 d021fb8:	e0bffe17 	ldw	r2,-8(fp)
 d021fbc:	e0bfff15 	stw	r2,-4(fp)
 d021fc0:	e0bfff17 	ldw	r2,-4(fp)
}
 d021fc4:	e037883a 	mov	sp,fp
 d021fc8:	df000017 	ldw	fp,0(sp)
 d021fcc:	dec00104 	addi	sp,sp,4
 d021fd0:	f800283a 	ret

0d021fd4 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 d021fd4:	defffa04 	addi	sp,sp,-24
 d021fd8:	dfc00515 	stw	ra,20(sp)
 d021fdc:	df000415 	stw	fp,16(sp)
 d021fe0:	df000404 	addi	fp,sp,16
 d021fe4:	e13ffd15 	stw	r4,-12(fp)
 d021fe8:	e17ffe15 	stw	r5,-8(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 d021fec:	e0bffd17 	ldw	r2,-12(fp)
 d021ff0:	10800617 	ldw	r2,24(r2)
 d021ff4:	10802717 	ldw	r2,156(r2)
 d021ff8:	e0bffc15 	stw	r2,-16(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 d021ffc:	e0bffc17 	ldw	r2,-16(fp)
 d022000:	10800617 	ldw	r2,24(r2)
 d022004:	10800098 	cmpnei	r2,r2,2
 d022008:	1000091e 	bne	r2,zero,d022030 <ip2mac+0x5c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d02200c:	01000084 	movi	r4,2
 d022010:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d022014:	e13ffd17 	ldw	r4,-12(fp)
 d022018:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02201c:	01000084 	movi	r4,2
 d022020:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 d022024:	00bff7c4 	movi	r2,-33
 d022028:	e0bfff15 	stw	r2,-4(fp)
 d02202c:	00004c06 	br	d022160 <ip2mac+0x18c>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 d022030:	e0bffd17 	ldw	r2,-12(fp)
 d022034:	10800617 	ldw	r2,24(r2)
 d022038:	10800817 	ldw	r2,32(r2)
 d02203c:	1005003a 	cmpeq	r2,r2,zero
 d022040:	1000081e 	bne	r2,zero,d022064 <ip2mac+0x90>
 d022044:	e0bffc17 	ldw	r2,-16(fp)
 d022048:	10800217 	ldw	r2,8(r2)
 d02204c:	108005e0 	cmpeqi	r2,r2,23
 d022050:	1000041e 	bne	r2,zero,d022064 <ip2mac+0x90>
 d022054:	e0bffc17 	ldw	r2,-16(fp)
 d022058:	10800217 	ldw	r2,8(r2)
 d02205c:	10800718 	cmpnei	r2,r2,28
 d022060:	1000291e 	bne	r2,zero,d022108 <ip2mac+0x134>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 d022064:	e0bffc17 	ldw	r2,-16(fp)
 d022068:	10801017 	ldw	r2,64(r2)
 d02206c:	10c00044 	addi	r3,r2,1
 d022070:	e0bffc17 	ldw	r2,-16(fp)
 d022074:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 d022078:	e0bffc17 	ldw	r2,-16(fp)
 d02207c:	10c00f17 	ldw	r3,60(r2)
 d022080:	e0bffd17 	ldw	r2,-12(fp)
 d022084:	10800417 	ldw	r2,16(r2)
 d022088:	1887883a 	add	r3,r3,r2
 d02208c:	e0bffc17 	ldw	r2,-16(fp)
 d022090:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 d022094:	e0bffd17 	ldw	r2,-12(fp)
 d022098:	10800617 	ldw	r2,24(r2)
 d02209c:	10800417 	ldw	r2,16(r2)
 d0220a0:	1005003a 	cmpeq	r2,r2,zero
 d0220a4:	1000061e 	bne	r2,zero,d0220c0 <ip2mac+0xec>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 d0220a8:	e0bffd17 	ldw	r2,-12(fp)
 d0220ac:	10800617 	ldw	r2,24(r2)
 d0220b0:	10800417 	ldw	r2,16(r2)
 d0220b4:	e13ffd17 	ldw	r4,-12(fp)
 d0220b8:	103ee83a 	callr	r2
 d0220bc:	00001006 	br	d022100 <ip2mac+0x12c>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 d0220c0:	e0bffd17 	ldw	r2,-12(fp)
 d0220c4:	10800617 	ldw	r2,24(r2)
 d0220c8:	10c00317 	ldw	r3,12(r2)
 d0220cc:	e0bffd17 	ldw	r2,-12(fp)
 d0220d0:	11000617 	ldw	r4,24(r2)
 d0220d4:	e0bffd17 	ldw	r2,-12(fp)
 d0220d8:	11400317 	ldw	r5,12(r2)
 d0220dc:	e0bffd17 	ldw	r2,-12(fp)
 d0220e0:	11800417 	ldw	r6,16(r2)
 d0220e4:	183ee83a 	callr	r3
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d0220e8:	01000084 	movi	r4,2
 d0220ec:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 d0220f0:	e13ffd17 	ldw	r4,-12(fp)
 d0220f4:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0220f8:	01000084 	movi	r4,2
 d0220fc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 d022100:	e03fff15 	stw	zero,-4(fp)
 d022104:	00001606 	br	d022160 <ip2mac+0x18c>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 d022108:	e0bffd17 	ldw	r2,-12(fp)
 d02210c:	10800617 	ldw	r2,24(r2)
 d022110:	10800a17 	ldw	r2,40(r2)
 d022114:	1004c03a 	cmpne	r2,r2,zero
 d022118:	10000d1e 	bne	r2,zero,d022150 <ip2mac+0x17c>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 d02211c:	e0bffd17 	ldw	r2,-12(fp)
 d022120:	10800717 	ldw	r2,28(r2)
 d022124:	10bfffe0 	cmpeqi	r2,r2,-1
 d022128:	1000091e 	bne	r2,zero,d022150 <ip2mac+0x17c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d02212c:	01000084 	movi	r4,2
 d022130:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 d022134:	e13ffd17 	ldw	r4,-12(fp)
 d022138:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02213c:	01000084 	movi	r4,2
 d022140:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 d022144:	00bff884 	movi	r2,-30
 d022148:	e0bfff15 	stw	r2,-4(fp)
 d02214c:	00000406 	br	d022160 <ip2mac+0x18c>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 d022150:	e13ffd17 	ldw	r4,-12(fp)
 d022154:	e17ffe17 	ldw	r5,-8(fp)
 d022158:	d03c1e00 	call	d03c1e0 <send_via_arp>
 d02215c:	e0bfff15 	stw	r2,-4(fp)
 d022160:	e0bfff17 	ldw	r2,-4(fp)
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 d022164:	e037883a 	mov	sp,fp
 d022168:	dfc00117 	ldw	ra,4(sp)
 d02216c:	df000017 	ldw	fp,0(sp)
 d022170:	dec00204 	addi	sp,sp,8
 d022174:	f800283a 	ret

0d022178 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 d022178:	defffb04 	addi	sp,sp,-20
 d02217c:	dfc00415 	stw	ra,16(sp)
 d022180:	df000315 	stw	fp,12(sp)
 d022184:	df000304 	addi	fp,sp,12
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 d022188:	e03ffd15 	stw	zero,-12(fp)
 d02218c:	00002a06 	br	d022238 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 d022190:	e13ffd17 	ldw	r4,-12(fp)
 d022194:	e0bffd17 	ldw	r2,-12(fp)
 d022198:	10803024 	muli	r2,r2,192
 d02219c:	1007883a 	mov	r3,r2
 d0221a0:	008341b4 	movhi	r2,3334
 d0221a4:	10b1e504 	addi	r2,r2,-14444
 d0221a8:	188b883a 	add	r5,r3,r2
 d0221ac:	00c341b4 	movhi	r3,3334
 d0221b0:	18f2a504 	addi	r3,r3,-13676
 d0221b4:	2105883a 	add	r2,r4,r4
 d0221b8:	1085883a 	add	r2,r2,r2
 d0221bc:	10c5883a 	add	r2,r2,r3
 d0221c0:	11400015 	stw	r5,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 d0221c4:	e0bffd17 	ldw	r2,-12(fp)
 d0221c8:	00c341b4 	movhi	r3,3334
 d0221cc:	18f2a504 	addi	r3,r3,-13676
 d0221d0:	1085883a 	add	r2,r2,r2
 d0221d4:	1085883a 	add	r2,r2,r2
 d0221d8:	10c5883a 	add	r2,r2,r3
 d0221dc:	11000017 	ldw	r4,0(r2)
 d0221e0:	e0bffd17 	ldw	r2,-12(fp)
 d0221e4:	00c341b4 	movhi	r3,3334
 d0221e8:	18f2a504 	addi	r3,r3,-13676
 d0221ec:	1085883a 	add	r2,r2,r2
 d0221f0:	1085883a 	add	r2,r2,r2
 d0221f4:	10c5883a 	add	r2,r2,r3
 d0221f8:	10800017 	ldw	r2,0(r2)
 d0221fc:	10801204 	addi	r2,r2,72
 d022200:	20802715 	stw	r2,156(r4)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 d022204:	e0bffd17 	ldw	r2,-12(fp)
 d022208:	00c341b4 	movhi	r3,3334
 d02220c:	18f2a504 	addi	r3,r3,-13676
 d022210:	1085883a 	add	r2,r2,r2
 d022214:	1085883a 	add	r2,r2,r2
 d022218:	10c5883a 	add	r2,r2,r3
 d02221c:	11400017 	ldw	r5,0(r2)
 d022220:	010341b4 	movhi	r4,3334
 d022224:	2134e604 	addi	r4,r4,-11368
 d022228:	d028d780 	call	d028d78 <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 d02222c:	e0bffd17 	ldw	r2,-12(fp)
 d022230:	10800044 	addi	r2,r2,1
 d022234:	e0bffd15 	stw	r2,-12(fp)
 d022238:	e0bffd17 	ldw	r2,-12(fp)
 d02223c:	10800110 	cmplti	r2,r2,4
 d022240:	103fd31e 	bne	r2,zero,d022190 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 d022244:	d0a08417 	ldw	r2,-32240(gp)
 d022248:	1009883a 	mov	r4,r2
 d02224c:	d041b6c0 	call	d041b6c <prep_ifaces>
 d022250:	d0a08415 	stw	r2,-32240(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 d022254:	d0a08417 	ldw	r2,-32240(gp)
 d022258:	1004c03a 	cmpne	r2,r2,zero
 d02225c:	1000041e 	bne	r2,zero,d022270 <ip_startup+0xf8>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 d022260:	00834174 	movhi	r2,3333
 d022264:	10ba5f04 	addi	r2,r2,-5764
 d022268:	e0bfff15 	stw	r2,-4(fp)
 d02226c:	00007506 	br	d022444 <ip_startup+0x2cc>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 d022270:	d0a08417 	ldw	r2,-32240(gp)
 d022274:	e0bffd15 	stw	r2,-12(fp)
 d022278:	00001506 	br	d0222d0 <ip_startup+0x158>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 d02227c:	e0bffd17 	ldw	r2,-12(fp)
 d022280:	00c341b4 	movhi	r3,3334
 d022284:	18f2a504 	addi	r3,r3,-13676
 d022288:	1085883a 	add	r2,r2,r2
 d02228c:	1085883a 	add	r2,r2,r2
 d022290:	10c5883a 	add	r2,r2,r3
 d022294:	10800017 	ldw	r2,0(r2)
 d022298:	100b883a 	mov	r5,r2
 d02229c:	010341b4 	movhi	r4,3334
 d0222a0:	2134e604 	addi	r4,r4,-11368
 d0222a4:	d028e280 	call	d028e28 <qdel>
      nets[i] = NULL;               /* remove from array */
 d0222a8:	e0bffd17 	ldw	r2,-12(fp)
 d0222ac:	00c341b4 	movhi	r3,3334
 d0222b0:	18f2a504 	addi	r3,r3,-13676
 d0222b4:	1085883a 	add	r2,r2,r2
 d0222b8:	1085883a 	add	r2,r2,r2
 d0222bc:	10c5883a 	add	r2,r2,r3
 d0222c0:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 d0222c4:	e0bffd17 	ldw	r2,-12(fp)
 d0222c8:	10800044 	addi	r2,r2,1
 d0222cc:	e0bffd15 	stw	r2,-12(fp)
 d0222d0:	e0bffd17 	ldw	r2,-12(fp)
 d0222d4:	10800110 	cmplti	r2,r2,4
 d0222d8:	103fe81e 	bne	r2,zero,d02227c <ip_startup+0x104>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 d0222dc:	d0295240 	call	d029524 <clock_init>
   exit_hook(clock_c);
 d0222e0:	010340f4 	movhi	r4,3331
 d0222e4:	21255804 	addi	r4,r4,-27296
 d0222e8:	d02245c0 	call	d02245c <exit_hook>

   e = Netinit();    /* start net interface(s) */
 d0222ec:	d02129c0 	call	d02129c <Netinit>
 d0222f0:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d0222f4:	e0bffe17 	ldw	r2,-8(fp)
 d0222f8:	1005003a 	cmpeq	r2,r2,zero
 d0222fc:	1000041e 	bne	r2,zero,d022310 <ip_startup+0x198>
   {
      return("unable to initialize net");
 d022300:	00834174 	movhi	r2,3333
 d022304:	10ba6904 	addi	r2,r2,-5724
 d022308:	e0bfff15 	stw	r2,-4(fp)
 d02230c:	00004d06 	br	d022444 <ip_startup+0x2cc>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 d022310:	d03b2cc0 	call	d03b2cc <etainit>
 d022314:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d022318:	e0bffe17 	ldw	r2,-8(fp)
 d02231c:	1005003a 	cmpeq	r2,r2,zero
 d022320:	1000051e 	bne	r2,zero,d022338 <ip_startup+0x1c0>
   {
      ip_exit();
 d022324:	d0224c80 	call	d0224c8 <ip_exit>
      return("unable to initialize arp");
 d022328:	00834174 	movhi	r2,3333
 d02232c:	10ba7004 	addi	r2,r2,-5696
 d022330:	e0bfff15 	stw	r2,-4(fp)
 d022334:	00004306 	br	d022444 <ip_startup+0x2cc>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 d022338:	d03ca040 	call	d03ca04 <ip_init>
 d02233c:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d022340:	e0bffe17 	ldw	r2,-8(fp)
 d022344:	1005003a 	cmpeq	r2,r2,zero
 d022348:	1000051e 	bne	r2,zero,d022360 <ip_startup+0x1e8>
   {
      ip_exit();
 d02234c:	d0224c80 	call	d0224c8 <ip_exit>
      return("unable to initialize IP");
 d022350:	00834174 	movhi	r2,3333
 d022354:	10ba7704 	addi	r2,r2,-5668
 d022358:	e0bfff15 	stw	r2,-4(fp)
 d02235c:	00003906 	br	d022444 <ip_startup+0x2cc>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 d022360:	d0226280 	call	d022628 <igmp_init>
 d022364:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d022368:	e0bffe17 	ldw	r2,-8(fp)
 d02236c:	1005003a 	cmpeq	r2,r2,zero
 d022370:	1000041e 	bne	r2,zero,d022384 <ip_startup+0x20c>
   {
      ip_exit();
 d022374:	d0224c80 	call	d0224c8 <ip_exit>
      return(ipmcfail_str);
 d022378:	d0a03017 	ldw	r2,-32576(gp)
 d02237c:	e0bfff15 	stw	r2,-4(fp)
 d022380:	00003006 	br	d022444 <ip_startup+0x2cc>
   }

   for (i = 0; i < (int)ifNumber; i++)
 d022384:	e03ffd15 	stw	zero,-12(fp)
 d022388:	00001e06 	br	d022404 <ip_startup+0x28c>
   {
      if (nets[i]->n_mcastlist != NULL)
 d02238c:	e0bffd17 	ldw	r2,-12(fp)
 d022390:	00c341b4 	movhi	r3,3334
 d022394:	18f2a504 	addi	r3,r3,-13676
 d022398:	1085883a 	add	r2,r2,r2
 d02239c:	1085883a 	add	r2,r2,r2
 d0223a0:	10c5883a 	add	r2,r2,r3
 d0223a4:	10800017 	ldw	r2,0(r2)
 d0223a8:	10802b17 	ldw	r2,172(r2)
 d0223ac:	1005003a 	cmpeq	r2,r2,zero
 d0223b0:	1000111e 	bne	r2,zero,d0223f8 <ip_startup+0x280>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 d0223b4:	e0bffd17 	ldw	r2,-12(fp)
 d0223b8:	00c341b4 	movhi	r3,3334
 d0223bc:	18f2a504 	addi	r3,r3,-13676
 d0223c0:	1085883a 	add	r2,r2,r2
 d0223c4:	1085883a 	add	r2,r2,r2
 d0223c8:	10c5883a 	add	r2,r2,r3
 d0223cc:	11400017 	ldw	r5,0(r2)
 d0223d0:	01034174 	movhi	r4,3333
 d0223d4:	210aa904 	addi	r4,r4,10916
 d0223d8:	01800104 	movi	r6,4
 d0223dc:	d04187c0 	call	d04187c <in_addmulti>
 d0223e0:	1004c03a 	cmpne	r2,r2,zero
 d0223e4:	1000041e 	bne	r2,zero,d0223f8 <ip_startup+0x280>
      {
         ip_exit();
 d0223e8:	d0224c80 	call	d0224c8 <ip_exit>
         return(ipmcfail_str);
 d0223ec:	d0a03017 	ldw	r2,-32576(gp)
 d0223f0:	e0bfff15 	stw	r2,-4(fp)
 d0223f4:	00001306 	br	d022444 <ip_startup+0x2cc>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 d0223f8:	e0bffd17 	ldw	r2,-12(fp)
 d0223fc:	10800044 	addi	r2,r2,1
 d022400:	e0bffd15 	stw	r2,-12(fp)
 d022404:	d0a08417 	ldw	r2,-32240(gp)
 d022408:	1007883a 	mov	r3,r2
 d02240c:	e0bffd17 	ldw	r2,-12(fp)
 d022410:	10ffde16 	blt	r2,r3,d02238c <ip_startup+0x214>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 d022414:	d037a700 	call	d037a70 <tcpinit>
 d022418:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d02241c:	e0bffe17 	ldw	r2,-8(fp)
 d022420:	1005003a 	cmpeq	r2,r2,zero
 d022424:	1000051e 	bne	r2,zero,d02243c <ip_startup+0x2c4>
   {
      ip_exit();
 d022428:	d0224c80 	call	d0224c8 <ip_exit>
      return("unable to initialize TCP");
 d02242c:	00834174 	movhi	r2,3333
 d022430:	10ba7d04 	addi	r2,r2,-5644
 d022434:	e0bfff15 	stw	r2,-4(fp)
 d022438:	00000206 	br	d022444 <ip_startup+0x2cc>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 d02243c:	d041c280 	call	d041c28 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 d022440:	e03fff15 	stw	zero,-4(fp)
 d022444:	e0bfff17 	ldw	r2,-4(fp)
}
 d022448:	e037883a 	mov	sp,fp
 d02244c:	dfc00117 	ldw	ra,4(sp)
 d022450:	df000017 	ldw	fp,0(sp)
 d022454:	dec00204 	addi	sp,sp,8
 d022458:	f800283a 	ret

0d02245c <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 d02245c:	defffd04 	addi	sp,sp,-12
 d022460:	dfc00215 	stw	ra,8(sp)
 d022464:	df000115 	stw	fp,4(sp)
 d022468:	df000104 	addi	fp,sp,4
 d02246c:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 d022470:	d0a08517 	ldw	r2,-32236(gp)
 d022474:	10800390 	cmplti	r2,r2,14
 d022478:	1000031e 	bne	r2,zero,d022488 <exit_hook+0x2c>
      panic("exit_hook");
 d02247c:	01034174 	movhi	r4,3333
 d022480:	213a8404 	addi	r4,r4,-5616
 d022484:	d0246440 	call	d024644 <panic>

   closers[++nclosers] = func;
 d022488:	d0a08517 	ldw	r2,-32236(gp)
 d02248c:	10800044 	addi	r2,r2,1
 d022490:	d0a08515 	stw	r2,-32236(gp)
 d022494:	d0a08517 	ldw	r2,-32236(gp)
 d022498:	00c34174 	movhi	r3,3333
 d02249c:	18cc8404 	addi	r3,r3,12816
 d0224a0:	1085883a 	add	r2,r2,r2
 d0224a4:	1085883a 	add	r2,r2,r2
 d0224a8:	10c7883a 	add	r3,r2,r3
 d0224ac:	e0bfff17 	ldw	r2,-4(fp)
 d0224b0:	18800015 	stw	r2,0(r3)
}
 d0224b4:	e037883a 	mov	sp,fp
 d0224b8:	dfc00117 	ldw	ra,4(sp)
 d0224bc:	df000017 	ldw	fp,0(sp)
 d0224c0:	dec00204 	addi	sp,sp,8
 d0224c4:	f800283a 	ret

0d0224c8 <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 d0224c8:	defffd04 	addi	sp,sp,-12
 d0224cc:	dfc00215 	stw	ra,8(sp)
 d0224d0:	df000115 	stw	fp,4(sp)
 d0224d4:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 d0224d8:	d0a08517 	ldw	r2,-32236(gp)
 d0224dc:	e0bfff15 	stw	r2,-4(fp)
 d0224e0:	00002506 	br	d022578 <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 d0224e4:	e0bfff17 	ldw	r2,-4(fp)
 d0224e8:	00c34174 	movhi	r3,3333
 d0224ec:	18cc8404 	addi	r3,r3,12816
 d0224f0:	1085883a 	add	r2,r2,r2
 d0224f4:	1085883a 	add	r2,r2,r2
 d0224f8:	10c5883a 	add	r2,r2,r3
 d0224fc:	11400017 	ldw	r5,0(r2)
 d022500:	01034174 	movhi	r4,3333
 d022504:	213a8704 	addi	r4,r4,-5604
 d022508:	d0029980 	call	d002998 <printf>
#endif
      if(closers[n])
 d02250c:	e0bfff17 	ldw	r2,-4(fp)
 d022510:	00c34174 	movhi	r3,3333
 d022514:	18cc8404 	addi	r3,r3,12816
 d022518:	1085883a 	add	r2,r2,r2
 d02251c:	1085883a 	add	r2,r2,r2
 d022520:	10c5883a 	add	r2,r2,r3
 d022524:	10800017 	ldw	r2,0(r2)
 d022528:	1005003a 	cmpeq	r2,r2,zero
 d02252c:	10000f1e 	bne	r2,zero,d02256c <ip_exit+0xa4>
      {
         (*closers[n])();
 d022530:	e0bfff17 	ldw	r2,-4(fp)
 d022534:	00c34174 	movhi	r3,3333
 d022538:	18cc8404 	addi	r3,r3,12816
 d02253c:	1085883a 	add	r2,r2,r2
 d022540:	1085883a 	add	r2,r2,r2
 d022544:	10c5883a 	add	r2,r2,r3
 d022548:	10800017 	ldw	r2,0(r2)
 d02254c:	103ee83a 	callr	r2
         closers[n] = NULL;
 d022550:	e0bfff17 	ldw	r2,-4(fp)
 d022554:	00c34174 	movhi	r3,3333
 d022558:	18cc8404 	addi	r3,r3,12816
 d02255c:	1085883a 	add	r2,r2,r2
 d022560:	1085883a 	add	r2,r2,r2
 d022564:	10c5883a 	add	r2,r2,r3
 d022568:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 d02256c:	e0bfff17 	ldw	r2,-4(fp)
 d022570:	10bfffc4 	addi	r2,r2,-1
 d022574:	e0bfff15 	stw	r2,-4(fp)
 d022578:	e0bfff17 	ldw	r2,-4(fp)
 d02257c:	1004c03a 	cmpne	r2,r2,zero
 d022580:	103fd81e 	bne	r2,zero,d0224e4 <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 d022584:	e037883a 	mov	sp,fp
 d022588:	dfc00117 	ldw	ra,4(sp)
 d02258c:	df000017 	ldw	fp,0(sp)
 d022590:	dec00204 	addi	sp,sp,8
 d022594:	f800283a 	ret

0d022598 <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 d022598:	defffa04 	addi	sp,sp,-24
 d02259c:	dfc00515 	stw	ra,20(sp)
 d0225a0:	df000415 	stw	fp,16(sp)
 d0225a4:	df000404 	addi	fp,sp,16
 d0225a8:	e13ffe15 	stw	r4,-8(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 d0225ac:	008341b4 	movhi	r2,3334
 d0225b0:	10b4e604 	addi	r2,r2,-11368
 d0225b4:	10800017 	ldw	r2,0(r2)
 d0225b8:	e0bffc15 	stw	r2,-16(fp)
 d0225bc:	e03ffd15 	stw	zero,-12(fp)
 d0225c0:	00000c06 	br	d0225f4 <if_netnumber+0x5c>
   {
      if(ifp == nptr)
 d0225c4:	e0fffc17 	ldw	r3,-16(fp)
 d0225c8:	e0bffe17 	ldw	r2,-8(fp)
 d0225cc:	1880031e 	bne	r3,r2,d0225dc <if_netnumber+0x44>
        return (int)i;
 d0225d0:	e0bffd17 	ldw	r2,-12(fp)
 d0225d4:	e0bfff15 	stw	r2,-4(fp)
 d0225d8:	00000d06 	br	d022610 <if_netnumber+0x78>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 d0225dc:	e0bffc17 	ldw	r2,-16(fp)
 d0225e0:	10800017 	ldw	r2,0(r2)
 d0225e4:	e0bffc15 	stw	r2,-16(fp)
 d0225e8:	e0bffd17 	ldw	r2,-12(fp)
 d0225ec:	10800044 	addi	r2,r2,1
 d0225f0:	e0bffd15 	stw	r2,-12(fp)
 d0225f4:	e0bffc17 	ldw	r2,-16(fp)
 d0225f8:	1004c03a 	cmpne	r2,r2,zero
 d0225fc:	103ff11e 	bne	r2,zero,d0225c4 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 d022600:	01034174 	movhi	r4,3333
 d022604:	213a8e04 	addi	r4,r4,-5576
 d022608:	d0246440 	call	d024644 <panic>
   return 0;
 d02260c:	e03fff15 	stw	zero,-4(fp)
 d022610:	e0bfff17 	ldw	r2,-4(fp)
}
 d022614:	e037883a 	mov	sp,fp
 d022618:	dfc00117 	ldw	ra,4(sp)
 d02261c:	df000017 	ldw	fp,0(sp)
 d022620:	dec00204 	addi	sp,sp,8
 d022624:	f800283a 	ret

0d022628 <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 d022628:	defffe04 	addi	sp,sp,-8
 d02262c:	df000115 	stw	fp,4(sp)
 d022630:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 d022634:	00804034 	movhi	r2,256
 d022638:	10803804 	addi	r2,r2,224
 d02263c:	d0a08815 	stw	r2,-32224(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 d022640:	00808034 	movhi	r2,512
 d022644:	10803804 	addi	r2,r2,224
 d022648:	d0a08915 	stw	r2,-32220(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 d02264c:	008341b4 	movhi	r2,3334
 d022650:	10b4e604 	addi	r2,r2,-11368
 d022654:	10800017 	ldw	r2,0(r2)
 d022658:	e0bfff15 	stw	r2,-4(fp)
 d02265c:	00001006 	br	d0226a0 <igmp_init+0x78>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 d022660:	e0bfff17 	ldw	r2,-4(fp)
 d022664:	10802f03 	ldbu	r2,188(r2)
 d022668:	10803fcc 	andi	r2,r2,255
 d02266c:	10800058 	cmpnei	r2,r2,1
 d022670:	1000041e 	bne	r2,zero,d022684 <igmp_init+0x5c>
      {
         ifp->igmpv1_rtr_present = 1;
 d022674:	e0ffff17 	ldw	r3,-4(fp)
 d022678:	00800044 	movi	r2,1
 d02267c:	18802d05 	stb	r2,180(r3)
 d022680:	00000406 	br	d022694 <igmp_init+0x6c>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 d022684:	e0bfff17 	ldw	r2,-4(fp)
 d022688:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 d02268c:	e0bfff17 	ldw	r2,-4(fp)
 d022690:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 d022694:	e0bfff17 	ldw	r2,-4(fp)
 d022698:	10800017 	ldw	r2,0(r2)
 d02269c:	e0bfff15 	stw	r2,-4(fp)
 d0226a0:	e0bfff17 	ldw	r2,-4(fp)
 d0226a4:	1004c03a 	cmpne	r2,r2,zero
 d0226a8:	103fed1e 	bne	r2,zero,d022660 <igmp_init+0x38>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 d0226ac:	00834174 	movhi	r2,3333
 d0226b0:	108ac904 	addi	r2,r2,11044
 d0226b4:	10800017 	ldw	r2,0(r2)
 d0226b8:	10800504 	addi	r2,r2,20
 d0226bc:	d0a08715 	stw	r2,-32228(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 d0226c0:	d0208615 	stw	zero,-32232(gp)

   return IGMP_OK;
 d0226c4:	0005883a 	mov	r2,zero
}
 d0226c8:	e037883a 	mov	sp,fp
 d0226cc:	df000017 	ldw	fp,0(sp)
 d0226d0:	dec00104 	addi	sp,sp,4
 d0226d4:	f800283a 	ret

0d0226d8 <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 d0226d8:	defff904 	addi	sp,sp,-28
 d0226dc:	dfc00615 	stw	ra,24(sp)
 d0226e0:	df000515 	stw	fp,20(sp)
 d0226e4:	df000504 	addi	fp,sp,20
 d0226e8:	e13ffd15 	stw	r4,-12(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 d0226ec:	008341b4 	movhi	r2,3334
 d0226f0:	10b2a904 	addi	r2,r2,-13660
 d0226f4:	10800017 	ldw	r2,0(r2)
 d0226f8:	10c00044 	addi	r3,r2,1
 d0226fc:	008341b4 	movhi	r2,3334
 d022700:	10b2a904 	addi	r2,r2,-13660
 d022704:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 d022708:	e13ffd17 	ldw	r4,-12(fp)
 d02270c:	d022f080 	call	d022f08 <igmp_validate>
 d022710:	e0bffb15 	stw	r2,-20(fp)
 d022714:	e0bffb17 	ldw	r2,-20(fp)
 d022718:	1004c03a 	cmpne	r2,r2,zero
 d02271c:	10001e1e 	bne	r2,zero,d022798 <igmp_input+0xc0>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 d022720:	e0bffd17 	ldw	r2,-12(fp)
 d022724:	10800617 	ldw	r2,24(r2)
 d022728:	10802f03 	ldbu	r2,188(r2)
 d02272c:	e0bffc05 	stb	r2,-16(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 d022730:	e0bffc03 	ldbu	r2,-16(fp)
 d022734:	e0bfff15 	stw	r2,-4(fp)
 d022738:	e0ffff17 	ldw	r3,-4(fp)
 d02273c:	18800060 	cmpeqi	r2,r3,1
 d022740:	1000041e 	bne	r2,zero,d022754 <igmp_input+0x7c>
 d022744:	e0ffff17 	ldw	r3,-4(fp)
 d022748:	188000a0 	cmpeqi	r2,r3,2
 d02274c:	1000051e 	bne	r2,zero,d022764 <igmp_input+0x8c>
 d022750:	00000806 	br	d022774 <igmp_input+0x9c>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 d022754:	e13ffd17 	ldw	r4,-12(fp)
 d022758:	d0436cc0 	call	d0436cc <igmpv1_input>
 d02275c:	e0bffe15 	stw	r2,-8(fp)
 d022760:	00001506 	br	d0227b8 <igmp_input+0xe0>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 d022764:	e13ffd17 	ldw	r4,-12(fp)
 d022768:	d0439bc0 	call	d0439bc <igmpv2_input>
 d02276c:	e0bffe15 	stw	r2,-8(fp)
 d022770:	00001106 	br	d0227b8 <igmp_input+0xe0>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 d022774:	008341b4 	movhi	r2,3334
 d022778:	10b2a904 	addi	r2,r2,-13660
 d02277c:	10800d17 	ldw	r2,52(r2)
 d022780:	10c00044 	addi	r3,r2,1
 d022784:	008341b4 	movhi	r2,3334
 d022788:	10b2a904 	addi	r2,r2,-13660
 d02278c:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 d022790:	00bfffc4 	movi	r2,-1
 d022794:	e0bffb15 	stw	r2,-20(fp)
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d022798:	01000084 	movi	r4,2
 d02279c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free(p);
 d0227a0:	e13ffd17 	ldw	r4,-12(fp)
 d0227a4:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0227a8:	01000084 	movi	r4,2
 d0227ac:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      
   return rc;
 d0227b0:	e0bffb17 	ldw	r2,-20(fp)
 d0227b4:	e0bffe15 	stw	r2,-8(fp)
 d0227b8:	e0bffe17 	ldw	r2,-8(fp)
}
 d0227bc:	e037883a 	mov	sp,fp
 d0227c0:	dfc00117 	ldw	ra,4(sp)
 d0227c4:	df000017 	ldw	fp,0(sp)
 d0227c8:	dec00204 	addi	sp,sp,8
 d0227cc:	f800283a 	ret

0d0227d0 <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 d0227d0:	defffc04 	addi	sp,sp,-16
 d0227d4:	dfc00315 	stw	ra,12(sp)
 d0227d8:	df000215 	stw	fp,8(sp)
 d0227dc:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 d0227e0:	0009883a 	mov	r4,zero
 d0227e4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 d0227e8:	d0a08617 	ldw	r2,-32232(gp)
 d0227ec:	1004c03a 	cmpne	r2,r2,zero
 d0227f0:	1000031e 	bne	r2,zero,d022800 <igmp_fasttimo+0x30>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 d0227f4:	0009883a 	mov	r4,zero
 d0227f8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return;
 d0227fc:	00005506 	br	d022954 <igmp_fasttimo+0x184>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d022800:	008341b4 	movhi	r2,3334
 d022804:	10b4e604 	addi	r2,r2,-11368
 d022808:	10800017 	ldw	r2,0(r2)
 d02280c:	e0bffe15 	stw	r2,-8(fp)
 d022810:	00004606 	br	d02292c <igmp_fasttimo+0x15c>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 d022814:	e0bffe17 	ldw	r2,-8(fp)
 d022818:	10802c17 	ldw	r2,176(r2)
 d02281c:	e0bfff15 	stw	r2,-4(fp)
 d022820:	00003c06 	br	d022914 <igmp_fasttimo+0x144>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 d022824:	e0bfff17 	ldw	r2,-4(fp)
 d022828:	10800017 	ldw	r2,0(r2)
 d02282c:	1005003a 	cmpeq	r2,r2,zero
 d022830:	1000351e 	bne	r2,zero,d022908 <igmp_fasttimo+0x138>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 d022834:	e0bfff17 	ldw	r2,-4(fp)
 d022838:	10800317 	ldw	r2,12(r2)
 d02283c:	1005003a 	cmpeq	r2,r2,zero
 d022840:	1000311e 	bne	r2,zero,d022908 <igmp_fasttimo+0x138>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 d022844:	e0bfff17 	ldw	r2,-4(fp)
 d022848:	10800317 	ldw	r2,12(r2)
 d02284c:	10ffffc4 	addi	r3,r2,-1
 d022850:	e0bfff17 	ldw	r2,-4(fp)
 d022854:	10c00315 	stw	r3,12(r2)
 d022858:	e0bfff17 	ldw	r2,-4(fp)
 d02285c:	10800317 	ldw	r2,12(r2)
 d022860:	1004c03a 	cmpne	r2,r2,zero
 d022864:	1000281e 	bne	r2,zero,d022908 <igmp_fasttimo+0x138>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 d022868:	e0bffe17 	ldw	r2,-8(fp)
 d02286c:	10802d03 	ldbu	r2,180(r2)
 d022870:	10803fcc 	andi	r2,r2,255
 d022874:	1005003a 	cmpeq	r2,r2,zero
 d022878:	1000041e 	bne	r2,zero,d02288c <igmp_fasttimo+0xbc>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 d02287c:	01000484 	movi	r4,18
 d022880:	e17fff17 	ldw	r5,-4(fp)
 d022884:	d0229680 	call	d022968 <igmp_send>
 d022888:	00000306 	br	d022898 <igmp_fasttimo+0xc8>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 d02288c:	01000584 	movi	r4,22
 d022890:	e17fff17 	ldw	r5,-4(fp)
 d022894:	d0229680 	call	d022968 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 d022898:	e0bffe17 	ldw	r2,-8(fp)
 d02289c:	10802f03 	ldbu	r2,188(r2)
 d0228a0:	10803fcc 	andi	r2,r2,255
 d0228a4:	10800098 	cmpnei	r2,r2,2
 d0228a8:	1000141e 	bne	r2,zero,d0228fc <igmp_fasttimo+0x12c>
            {
               inm->last2send_report = IGMP_TRUE;
 d0228ac:	e0ffff17 	ldw	r3,-4(fp)
 d0228b0:	00800044 	movi	r2,1
 d0228b4:	18800405 	stb	r2,16(r3)
               
               if (ifp->igmpv1_rtr_present)
 d0228b8:	e0bffe17 	ldw	r2,-8(fp)
 d0228bc:	10802d03 	ldbu	r2,180(r2)
 d0228c0:	10803fcc 	andi	r2,r2,255
 d0228c4:	1005003a 	cmpeq	r2,r2,zero
 d0228c8:	10000c1e 	bne	r2,zero,d0228fc <igmp_fasttimo+0x12c>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 d0228cc:	e0bffe17 	ldw	r2,-8(fp)
 d0228d0:	10c02e17 	ldw	r3,184(r2)
 d0228d4:	00a71014 	movui	r2,40000
 d0228d8:	1887883a 	add	r3,r3,r2
 d0228dc:	00834174 	movhi	r2,3333
 d0228e0:	108ac904 	addi	r2,r2,11044
 d0228e4:	10800017 	ldw	r2,0(r2)
 d0228e8:	1880042e 	bgeu	r3,r2,d0228fc <igmp_fasttimo+0x12c>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 d0228ec:	e0bffe17 	ldw	r2,-8(fp)
 d0228f0:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 d0228f4:	e0bffe17 	ldw	r2,-8(fp)
 d0228f8:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 d0228fc:	d0a08617 	ldw	r2,-32232(gp)
 d022900:	10bfffc4 	addi	r2,r2,-1
 d022904:	d0a08615 	stw	r2,-32232(gp)
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 d022908:	e0bfff17 	ldw	r2,-4(fp)
 d02290c:	10800517 	ldw	r2,20(r2)
 d022910:	e0bfff15 	stw	r2,-4(fp)
 d022914:	e0bfff17 	ldw	r2,-4(fp)
 d022918:	1004c03a 	cmpne	r2,r2,zero
 d02291c:	103fc11e 	bne	r2,zero,d022824 <igmp_fasttimo+0x54>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d022920:	e0bffe17 	ldw	r2,-8(fp)
 d022924:	10800017 	ldw	r2,0(r2)
 d022928:	e0bffe15 	stw	r2,-8(fp)
 d02292c:	e0bffe17 	ldw	r2,-8(fp)
 d022930:	1004c03a 	cmpne	r2,r2,zero
 d022934:	103fb71e 	bne	r2,zero,d022814 <igmp_fasttimo+0x44>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 d022938:	00834174 	movhi	r2,3333
 d02293c:	108ac904 	addi	r2,r2,11044
 d022940:	10800017 	ldw	r2,0(r2)
 d022944:	10800504 	addi	r2,r2,20
 d022948:	d0a08715 	stw	r2,-32228(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 d02294c:	0009883a 	mov	r4,zero
 d022950:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   
   return;
}
 d022954:	e037883a 	mov	sp,fp
 d022958:	dfc00117 	ldw	ra,4(sp)
 d02295c:	df000017 	ldw	fp,0(sp)
 d022960:	dec00204 	addi	sp,sp,8
 d022964:	f800283a 	ret

0d022968 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 d022968:	deffdd04 	addi	sp,sp,-140
 d02296c:	dfc02215 	stw	ra,136(sp)
 d022970:	df002115 	stw	fp,132(sp)
 d022974:	df002104 	addi	fp,sp,132
 d022978:	e17fff15 	stw	r5,-4(fp)
 d02297c:	e13ffe05 	stb	r4,-8(fp)
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   int i;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 d022980:	00800504 	movi	r2,20
 d022984:	e0bffd05 	stb	r2,-12(fp)
 d022988:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 d02298c:	00834174 	movhi	r2,3333
 d022990:	108aa204 	addi	r2,r2,10888
 d022994:	10800017 	ldw	r2,0(r2)
 d022998:	10800704 	addi	r2,r2,28
 d02299c:	e0bfdf05 	stb	r2,-132(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 d0229a0:	e0bffe03 	ldbu	r2,-8(fp)
 d0229a4:	108005e0 	cmpeqi	r2,r2,23
 d0229a8:	1000031e 	bne	r2,zero,d0229b8 <igmp_send+0x50>
 d0229ac:	e0bffe03 	ldbu	r2,-8(fp)
 d0229b0:	10800598 	cmpnei	r2,r2,22
 d0229b4:	1000031e 	bne	r2,zero,d0229c4 <igmp_send+0x5c>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 d0229b8:	e0bfdf03 	ldbu	r2,-132(fp)
 d0229bc:	10800104 	addi	r2,r2,4
 d0229c0:	e0bfdf05 	stb	r2,-132(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 d0229c4:	01000084 	movi	r4,2
 d0229c8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 d0229cc:	e13fdf03 	ldbu	r4,-132(fp)
 d0229d0:	d0287a40 	call	d0287a4 <pk_alloc>
 d0229d4:	e0bfe615 	stw	r2,-104(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d0229d8:	01000084 	movi	r4,2
 d0229dc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 d0229e0:	e0bfe617 	ldw	r2,-104(fp)
 d0229e4:	1004c03a 	cmpne	r2,r2,zero
 d0229e8:	1000081e 	bne	r2,zero,d022a0c <igmp_send+0xa4>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 d0229ec:	008341b4 	movhi	r2,3334
 d0229f0:	10b2a904 	addi	r2,r2,-13660
 d0229f4:	10800c17 	ldw	r2,48(r2)
 d0229f8:	10c00044 	addi	r3,r2,1
 d0229fc:	008341b4 	movhi	r2,3334
 d022a00:	10b2a904 	addi	r2,r2,-13660
 d022a04:	10c00c15 	stw	r3,48(r2)
      return;
 d022a08:	00007c06 	br	d022bfc <igmp_send+0x294>
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 d022a0c:	e0bfe617 	ldw	r2,-104(fp)
 d022a10:	10800317 	ldw	r2,12(r2)
 d022a14:	e0bfe315 	stw	r2,-116(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 d022a18:	e0bfff17 	ldw	r2,-4(fp)
 d022a1c:	10800117 	ldw	r2,4(r2)
 d022a20:	10c00a17 	ldw	r3,40(r2)
 d022a24:	e0bfe317 	ldw	r2,-116(fp)
 d022a28:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 d022a2c:	e0bffe03 	ldbu	r2,-8(fp)
 d022a30:	108005d8 	cmpnei	r2,r2,23
 d022a34:	1000041e 	bne	r2,zero,d022a48 <igmp_send+0xe0>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 d022a38:	d0e08917 	ldw	r3,-32220(gp)
 d022a3c:	e0bfe317 	ldw	r2,-116(fp)
 d022a40:	10c00415 	stw	r3,16(r2)
 d022a44:	00000406 	br	d022a58 <igmp_send+0xf0>
   }
   else
      pip->ip_dest = inm->inm_addr;
 d022a48:	e0bfff17 	ldw	r2,-4(fp)
 d022a4c:	10c00017 	ldw	r3,0(r2)
 d022a50:	e0bfe317 	ldw	r2,-116(fp)
 d022a54:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 d022a58:	e0bfe317 	ldw	r2,-116(fp)
 d022a5c:	10c00417 	ldw	r3,16(r2)
 d022a60:	e0bfe617 	ldw	r2,-104(fp)
 d022a64:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 d022a68:	e0bfe617 	ldw	r2,-104(fp)
 d022a6c:	10800317 	ldw	r2,12(r2)
 d022a70:	10800504 	addi	r2,r2,20
 d022a74:	e0bfe115 	stw	r2,-124(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 d022a78:	e0bffe03 	ldbu	r2,-8(fp)
 d022a7c:	108005e0 	cmpeqi	r2,r2,23
 d022a80:	1000031e 	bne	r2,zero,d022a90 <igmp_send+0x128>
 d022a84:	e0bffe03 	ldbu	r2,-8(fp)
 d022a88:	10800598 	cmpnei	r2,r2,22
 d022a8c:	1000061e 	bne	r2,zero,d022aa8 <igmp_send+0x140>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 d022a90:	e0bfe117 	ldw	r2,-124(fp)
 d022a94:	10800104 	addi	r2,r2,4
 d022a98:	e0bfe115 	stw	r2,-124(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 d022a9c:	e0bffd04 	addi	r2,fp,-12
 d022aa0:	e0bfe015 	stw	r2,-128(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 d022aa4:	00000306 	br	d022ab4 <igmp_send+0x14c>
      tmpp += IP_RTR_ALERT_OPT_SIZE;
      optp = &(opts [0]); /* one option (IP Router Alert) */
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 d022aa8:	e0bffd04 	addi	r2,fp,-12
 d022aac:	10800044 	addi	r2,r2,1
 d022ab0:	e0bfe015 	stw	r2,-128(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 d022ab4:	e0bfe117 	ldw	r2,-124(fp)
 d022ab8:	e0bfe515 	stw	r2,-108(fp)
   
   igmp->igmp_type = type;
 d022abc:	e0ffe517 	ldw	r3,-108(fp)
 d022ac0:	e0bffe03 	ldbu	r2,-8(fp)
 d022ac4:	18800005 	stb	r2,0(r3)
   igmp->igmp_code = 0;
 d022ac8:	e0bfe517 	ldw	r2,-108(fp)
 d022acc:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 d022ad0:	e0bfff17 	ldw	r2,-4(fp)
 d022ad4:	10c00017 	ldw	r3,0(r2)
 d022ad8:	e0bfe517 	ldw	r2,-108(fp)
 d022adc:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 d022ae0:	e0bfe517 	ldw	r2,-108(fp)
 d022ae4:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 d022ae8:	e13fe517 	ldw	r4,-108(fp)
 d022aec:	01400104 	movi	r5,4
 d022af0:	d0242340 	call	d024234 <cksum>
 d022af4:	0084303a 	nor	r2,zero,r2
 d022af8:	1007883a 	mov	r3,r2
 d022afc:	e0bfe517 	ldw	r2,-108(fp)
 d022b00:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 d022b04:	e0bfe704 	addi	r2,fp,-100
 d022b08:	e0bfe415 	stw	r2,-112(fp)
   MEMSET(imop, 0, sizeof(simo));
 d022b0c:	e0bfe417 	ldw	r2,-112(fp)
 d022b10:	1009883a 	mov	r4,r2
 d022b14:	01801604 	movi	r6,88
 d022b18:	000b883a 	mov	r5,zero
 d022b1c:	d0028800 	call	d002880 <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 d022b20:	e0bfff17 	ldw	r2,-4(fp)
 d022b24:	10c00117 	ldw	r3,4(r2)
 d022b28:	e0bfe417 	ldw	r2,-112(fp)
 d022b2c:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 d022b30:	e0ffe417 	ldw	r3,-112(fp)
 d022b34:	00800044 	movi	r2,1
 d022b38:	18800105 	stb	r2,4(r3)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 d022b3c:	e0bfe417 	ldw	r2,-112(fp)
 d022b40:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 d022b44:	e0ffe117 	ldw	r3,-124(fp)
 d022b48:	e0bfe617 	ldw	r2,-104(fp)
 d022b4c:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 d022b50:	e0ffe617 	ldw	r3,-104(fp)
 d022b54:	00800204 	movi	r2,8
 d022b58:	18800415 	stw	r2,16(r3)
   p->imo = imop;
 d022b5c:	e0ffe617 	ldw	r3,-104(fp)
 d022b60:	e0bfe417 	ldw	r2,-112(fp)
 d022b64:	18800b15 	stw	r2,44(r3)
   
   i = ip_write2 (IGMP_PROT, p, optp);
 d022b68:	01000084 	movi	r4,2
 d022b6c:	e17fe617 	ldw	r5,-104(fp)
 d022b70:	e1bfe017 	ldw	r6,-128(fp)
 d022b74:	d03d66c0 	call	d03d66c <ip_write2>
 d022b78:	e0bfe215 	stw	r2,-120(fp)

   if (type == IGMPv2_LEAVE_GROUP)
 d022b7c:	e0bffe03 	ldbu	r2,-8(fp)
 d022b80:	108005d8 	cmpnei	r2,r2,23
 d022b84:	1000081e 	bne	r2,zero,d022ba8 <igmp_send+0x240>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 d022b88:	008341b4 	movhi	r2,3334
 d022b8c:	10b2a904 	addi	r2,r2,-13660
 d022b90:	10801717 	ldw	r2,92(r2)
 d022b94:	10c00044 	addi	r3,r2,1
 d022b98:	008341b4 	movhi	r2,3334
 d022b9c:	10b2a904 	addi	r2,r2,-13660
 d022ba0:	10c01715 	stw	r3,92(r2)
 d022ba4:	00001506 	br	d022bfc <igmp_send+0x294>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 d022ba8:	e0bffe03 	ldbu	r2,-8(fp)
 d022bac:	10800598 	cmpnei	r2,r2,22
 d022bb0:	1000081e 	bne	r2,zero,d022bd4 <igmp_send+0x26c>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 d022bb4:	008341b4 	movhi	r2,3334
 d022bb8:	10b2a904 	addi	r2,r2,-13660
 d022bbc:	10801817 	ldw	r2,96(r2)
 d022bc0:	10c00044 	addi	r3,r2,1
 d022bc4:	008341b4 	movhi	r2,3334
 d022bc8:	10b2a904 	addi	r2,r2,-13660
 d022bcc:	10c01815 	stw	r3,96(r2)
 d022bd0:	00000a06 	br	d022bfc <igmp_send+0x294>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 d022bd4:	e0bffe03 	ldbu	r2,-8(fp)
 d022bd8:	10800498 	cmpnei	r2,r2,18
 d022bdc:	1000071e 	bne	r2,zero,d022bfc <igmp_send+0x294>
      ++igmpstats.igmp_v1_reports_sent;
 d022be0:	008341b4 	movhi	r2,3334
 d022be4:	10b2a904 	addi	r2,r2,-13660
 d022be8:	10801617 	ldw	r2,88(r2)
 d022bec:	10c00044 	addi	r3,r2,1
 d022bf0:	008341b4 	movhi	r2,3334
 d022bf4:	10b2a904 	addi	r2,r2,-13660
 d022bf8:	10c01615 	stw	r3,88(r2)
}
 d022bfc:	e037883a 	mov	sp,fp
 d022c00:	dfc00117 	ldw	ra,4(sp)
 d022c04:	df000017 	ldw	fp,0(sp)
 d022c08:	dec00204 	addi	sp,sp,8
 d022c0c:	f800283a 	ret

0d022c10 <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 d022c10:	defffc04 	addi	sp,sp,-16
 d022c14:	dfc00315 	stw	ra,12(sp)
 d022c18:	df000215 	stw	fp,8(sp)
 d022c1c:	df000204 	addi	fp,sp,8
 d022c20:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 d022c24:	e0bfff17 	ldw	r2,-4(fp)
 d022c28:	10800117 	ldw	r2,4(r2)
 d022c2c:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 d022c30:	e0bfff17 	ldw	r2,-4(fp)
 d022c34:	10c00017 	ldw	r3,0(r2)
 d022c38:	d0a08817 	ldw	r2,-32224(gp)
 d022c3c:	1880031e 	bne	r3,r2,d022c4c <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 d022c40:	e0bfff17 	ldw	r2,-4(fp)
 d022c44:	10000315 	stw	zero,12(r2)
 d022c48:	00008b06 	br	d022e78 <igmp_joingroup+0x268>
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 d022c4c:	e0bffe17 	ldw	r2,-8(fp)
 d022c50:	10802d03 	ldbu	r2,180(r2)
 d022c54:	10803fcc 	andi	r2,r2,255
 d022c58:	1005003a 	cmpeq	r2,r2,zero
 d022c5c:	10003e1e 	bne	r2,zero,d022d58 <igmp_joingroup+0x148>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 d022c60:	01000484 	movi	r4,18
 d022c64:	e17fff17 	ldw	r5,-4(fp)
 d022c68:	d0229680 	call	d022968 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 d022c6c:	008341b4 	movhi	r2,3334
 d022c70:	10b4eb04 	addi	r2,r2,-11348
 d022c74:	11000217 	ldw	r4,8(r2)
 d022c78:	008341b4 	movhi	r2,3334
 d022c7c:	10b2a504 	addi	r2,r2,-13676
 d022c80:	10800017 	ldw	r2,0(r2)
 d022c84:	10800a17 	ldw	r2,40(r2)
 d022c88:	1004d63a 	srli	r2,r2,24
 d022c8c:	10c03fcc 	andi	r3,r2,255
 d022c90:	008341b4 	movhi	r2,3334
 d022c94:	10b2a504 	addi	r2,r2,-13676
 d022c98:	10800017 	ldw	r2,0(r2)
 d022c9c:	10800a17 	ldw	r2,40(r2)
 d022ca0:	1004d23a 	srli	r2,r2,8
 d022ca4:	10bfc00c 	andi	r2,r2,65280
 d022ca8:	1886b03a 	or	r3,r3,r2
 d022cac:	008341b4 	movhi	r2,3334
 d022cb0:	10b2a504 	addi	r2,r2,-13676
 d022cb4:	10800017 	ldw	r2,0(r2)
 d022cb8:	10800a17 	ldw	r2,40(r2)
 d022cbc:	10bfc00c 	andi	r2,r2,65280
 d022cc0:	1004923a 	slli	r2,r2,8
 d022cc4:	1886b03a 	or	r3,r3,r2
 d022cc8:	008341b4 	movhi	r2,3334
 d022ccc:	10b2a504 	addi	r2,r2,-13676
 d022cd0:	10800017 	ldw	r2,0(r2)
 d022cd4:	10800a17 	ldw	r2,40(r2)
 d022cd8:	10803fcc 	andi	r2,r2,255
 d022cdc:	1004963a 	slli	r2,r2,24
 d022ce0:	1884b03a 	or	r2,r3,r2
 d022ce4:	2089883a 	add	r4,r4,r2
 d022ce8:	e0bfff17 	ldw	r2,-4(fp)
 d022cec:	10800017 	ldw	r2,0(r2)
 d022cf0:	1004d63a 	srli	r2,r2,24
 d022cf4:	10c03fcc 	andi	r3,r2,255
 d022cf8:	e0bfff17 	ldw	r2,-4(fp)
 d022cfc:	10800017 	ldw	r2,0(r2)
 d022d00:	1004d23a 	srli	r2,r2,8
 d022d04:	10bfc00c 	andi	r2,r2,65280
 d022d08:	1886b03a 	or	r3,r3,r2
 d022d0c:	e0bfff17 	ldw	r2,-4(fp)
 d022d10:	10800017 	ldw	r2,0(r2)
 d022d14:	10bfc00c 	andi	r2,r2,65280
 d022d18:	1004923a 	slli	r2,r2,8
 d022d1c:	1886b03a 	or	r3,r3,r2
 d022d20:	e0bfff17 	ldw	r2,-4(fp)
 d022d24:	10800017 	ldw	r2,0(r2)
 d022d28:	10803fcc 	andi	r2,r2,255
 d022d2c:	1004963a 	slli	r2,r2,24
 d022d30:	1884b03a 	or	r2,r3,r2
 d022d34:	2087883a 	add	r3,r4,r2
 d022d38:	00800c84 	movi	r2,50
 d022d3c:	1885203a 	divu	r2,r3,r2
 d022d40:	10800ca4 	muli	r2,r2,50
 d022d44:	1885c83a 	sub	r2,r3,r2
 d022d48:	10c00044 	addi	r3,r2,1
 d022d4c:	e0bfff17 	ldw	r2,-4(fp)
 d022d50:	10c00315 	stw	r3,12(r2)
 d022d54:	00003d06 	br	d022e4c <igmp_joingroup+0x23c>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 d022d58:	01000584 	movi	r4,22
 d022d5c:	e17fff17 	ldw	r5,-4(fp)
 d022d60:	d0229680 	call	d022968 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 d022d64:	008341b4 	movhi	r2,3334
 d022d68:	10b4eb04 	addi	r2,r2,-11348
 d022d6c:	11000217 	ldw	r4,8(r2)
 d022d70:	008341b4 	movhi	r2,3334
 d022d74:	10b2a504 	addi	r2,r2,-13676
 d022d78:	10800017 	ldw	r2,0(r2)
 d022d7c:	10800a17 	ldw	r2,40(r2)
 d022d80:	1004d63a 	srli	r2,r2,24
 d022d84:	10c03fcc 	andi	r3,r2,255
 d022d88:	008341b4 	movhi	r2,3334
 d022d8c:	10b2a504 	addi	r2,r2,-13676
 d022d90:	10800017 	ldw	r2,0(r2)
 d022d94:	10800a17 	ldw	r2,40(r2)
 d022d98:	1004d23a 	srli	r2,r2,8
 d022d9c:	10bfc00c 	andi	r2,r2,65280
 d022da0:	1886b03a 	or	r3,r3,r2
 d022da4:	008341b4 	movhi	r2,3334
 d022da8:	10b2a504 	addi	r2,r2,-13676
 d022dac:	10800017 	ldw	r2,0(r2)
 d022db0:	10800a17 	ldw	r2,40(r2)
 d022db4:	10bfc00c 	andi	r2,r2,65280
 d022db8:	1004923a 	slli	r2,r2,8
 d022dbc:	1886b03a 	or	r3,r3,r2
 d022dc0:	008341b4 	movhi	r2,3334
 d022dc4:	10b2a504 	addi	r2,r2,-13676
 d022dc8:	10800017 	ldw	r2,0(r2)
 d022dcc:	10800a17 	ldw	r2,40(r2)
 d022dd0:	10803fcc 	andi	r2,r2,255
 d022dd4:	1004963a 	slli	r2,r2,24
 d022dd8:	1884b03a 	or	r2,r3,r2
 d022ddc:	2089883a 	add	r4,r4,r2
 d022de0:	e0bfff17 	ldw	r2,-4(fp)
 d022de4:	10800017 	ldw	r2,0(r2)
 d022de8:	1004d63a 	srli	r2,r2,24
 d022dec:	10c03fcc 	andi	r3,r2,255
 d022df0:	e0bfff17 	ldw	r2,-4(fp)
 d022df4:	10800017 	ldw	r2,0(r2)
 d022df8:	1004d23a 	srli	r2,r2,8
 d022dfc:	10bfc00c 	andi	r2,r2,65280
 d022e00:	1886b03a 	or	r3,r3,r2
 d022e04:	e0bfff17 	ldw	r2,-4(fp)
 d022e08:	10800017 	ldw	r2,0(r2)
 d022e0c:	10bfc00c 	andi	r2,r2,65280
 d022e10:	1004923a 	slli	r2,r2,8
 d022e14:	1886b03a 	or	r3,r3,r2
 d022e18:	e0bfff17 	ldw	r2,-4(fp)
 d022e1c:	10800017 	ldw	r2,0(r2)
 d022e20:	10803fcc 	andi	r2,r2,255
 d022e24:	1004963a 	slli	r2,r2,24
 d022e28:	1884b03a 	or	r2,r3,r2
 d022e2c:	2087883a 	add	r3,r4,r2
 d022e30:	00800c84 	movi	r2,50
 d022e34:	1885203a 	divu	r2,r3,r2
 d022e38:	10800ca4 	muli	r2,r2,50
 d022e3c:	1885c83a 	sub	r2,r3,r2
 d022e40:	10c00044 	addi	r3,r2,1
 d022e44:	e0bfff17 	ldw	r2,-4(fp)
 d022e48:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 d022e4c:	e0bffe17 	ldw	r2,-8(fp)
 d022e50:	10802f03 	ldbu	r2,188(r2)
 d022e54:	10803fcc 	andi	r2,r2,255
 d022e58:	10800098 	cmpnei	r2,r2,2
 d022e5c:	1000031e 	bne	r2,zero,d022e6c <igmp_joingroup+0x25c>
      {
         inm->last2send_report = IGMP_TRUE;
 d022e60:	e0ffff17 	ldw	r3,-4(fp)
 d022e64:	00800044 	movi	r2,1
 d022e68:	18800405 	stb	r2,16(r3)
      }

      ++igmp_timers_are_running;
 d022e6c:	d0a08617 	ldw	r2,-32232(gp)
 d022e70:	10800044 	addi	r2,r2,1
 d022e74:	d0a08615 	stw	r2,-32232(gp)
   }
   
   return;
}     
 d022e78:	e037883a 	mov	sp,fp
 d022e7c:	dfc00117 	ldw	ra,4(sp)
 d022e80:	df000017 	ldw	fp,0(sp)
 d022e84:	dec00204 	addi	sp,sp,8
 d022e88:	f800283a 	ret

0d022e8c <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 d022e8c:	defffc04 	addi	sp,sp,-16
 d022e90:	dfc00315 	stw	ra,12(sp)
 d022e94:	df000215 	stw	fp,8(sp)
 d022e98:	df000204 	addi	fp,sp,8
 d022e9c:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 d022ea0:	e0bfff17 	ldw	r2,-4(fp)
 d022ea4:	10800117 	ldw	r2,4(r2)
 d022ea8:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 d022eac:	e0bffe17 	ldw	r2,-8(fp)
 d022eb0:	10802f03 	ldbu	r2,188(r2)
 d022eb4:	10803fcc 	andi	r2,r2,255
 d022eb8:	10800098 	cmpnei	r2,r2,2
 d022ebc:	10000d1e 	bne	r2,zero,d022ef4 <igmp_leavegroup+0x68>
 d022ec0:	e0bffe17 	ldw	r2,-8(fp)
 d022ec4:	10802d03 	ldbu	r2,180(r2)
 d022ec8:	10803fcc 	andi	r2,r2,255
 d022ecc:	1004c03a 	cmpne	r2,r2,zero
 d022ed0:	1000081e 	bne	r2,zero,d022ef4 <igmp_leavegroup+0x68>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 d022ed4:	e0bfff17 	ldw	r2,-4(fp)
 d022ed8:	10800403 	ldbu	r2,16(r2)
 d022edc:	10803fcc 	andi	r2,r2,255
 d022ee0:	10800058 	cmpnei	r2,r2,1
 d022ee4:	1000031e 	bne	r2,zero,d022ef4 <igmp_leavegroup+0x68>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 d022ee8:	010005c4 	movi	r4,23
 d022eec:	e17fff17 	ldw	r5,-4(fp)
 d022ef0:	d0229680 	call	d022968 <igmp_send>
   }
   
   return;
}
 d022ef4:	e037883a 	mov	sp,fp
 d022ef8:	dfc00117 	ldw	ra,4(sp)
 d022efc:	df000017 	ldw	fp,0(sp)
 d022f00:	dec00204 	addi	sp,sp,8
 d022f04:	f800283a 	ret

0d022f08 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 d022f08:	defff504 	addi	sp,sp,-44
 d022f0c:	dfc00a15 	stw	ra,40(sp)
 d022f10:	df000915 	stw	fp,36(sp)
 d022f14:	df000904 	addi	fp,sp,36
 d022f18:	e13ffe15 	stw	r4,-8(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 d022f1c:	e0bffe17 	ldw	r2,-8(fp)
 d022f20:	10800317 	ldw	r2,12(r2)
 d022f24:	e0bffd15 	stw	r2,-12(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 d022f28:	e0bffe17 	ldw	r2,-8(fp)
 d022f2c:	10c00417 	ldw	r3,16(r2)
 d022f30:	e0bffd17 	ldw	r2,-12(fp)
 d022f34:	10800003 	ldbu	r2,0(r2)
 d022f38:	10803fcc 	andi	r2,r2,255
 d022f3c:	108003cc 	andi	r2,r2,15
 d022f40:	1085883a 	add	r2,r2,r2
 d022f44:	1085883a 	add	r2,r2,r2
 d022f48:	1885c83a 	sub	r2,r3,r2
 d022f4c:	e0bffc15 	stw	r2,-16(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 d022f50:	e0bffc17 	ldw	r2,-16(fp)
 d022f54:	10800220 	cmpeqi	r2,r2,8
 d022f58:	10000a1e 	bne	r2,zero,d022f84 <igmp_validate+0x7c>
   {
      ++igmpstats.igmp_badlen_rcvd;
 d022f5c:	008341b4 	movhi	r2,3334
 d022f60:	10b2a904 	addi	r2,r2,-13660
 d022f64:	10800a17 	ldw	r2,40(r2)
 d022f68:	10c00044 	addi	r3,r2,1
 d022f6c:	008341b4 	movhi	r2,3334
 d022f70:	10b2a904 	addi	r2,r2,-13660
 d022f74:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 d022f78:	00bff804 	movi	r2,-32
 d022f7c:	e0bfff15 	stw	r2,-4(fp)
 d022f80:	0000b206 	br	d02324c <igmp_validate+0x344>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 d022f84:	e0bffd17 	ldw	r2,-12(fp)
 d022f88:	10800003 	ldbu	r2,0(r2)
 d022f8c:	10803fcc 	andi	r2,r2,255
 d022f90:	108003cc 	andi	r2,r2,15
 d022f94:	1085883a 	add	r2,r2,r2
 d022f98:	1085883a 	add	r2,r2,r2
 d022f9c:	1007883a 	mov	r3,r2
 d022fa0:	e0bffd17 	ldw	r2,-12(fp)
 d022fa4:	1885883a 	add	r2,r3,r2
 d022fa8:	e0bffb15 	stw	r2,-20(fp)
   osum = igmp->igmp_cksum;
 d022fac:	e0bffb17 	ldw	r2,-20(fp)
 d022fb0:	1080008b 	ldhu	r2,2(r2)
 d022fb4:	e0bffa0d 	sth	r2,-24(fp)
   igmp->igmp_cksum = 0;
 d022fb8:	e0bffb17 	ldw	r2,-20(fp)
 d022fbc:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 d022fc0:	e0bffc17 	ldw	r2,-16(fp)
 d022fc4:	1005d07a 	srai	r2,r2,1
 d022fc8:	100b883a 	mov	r5,r2
 d022fcc:	e13ffb17 	ldw	r4,-20(fp)
 d022fd0:	d0242340 	call	d024234 <cksum>
 d022fd4:	0084303a 	nor	r2,zero,r2
 d022fd8:	e0bff98d 	sth	r2,-26(fp)
   if (xsum != osum)
 d022fdc:	e0fff98b 	ldhu	r3,-26(fp)
 d022fe0:	e0bffa0b 	ldhu	r2,-24(fp)
 d022fe4:	18800d26 	beq	r3,r2,d02301c <igmp_validate+0x114>
   {
      igmp->igmp_cksum = osum;
 d022fe8:	e0fffb17 	ldw	r3,-20(fp)
 d022fec:	e0bffa0b 	ldhu	r2,-24(fp)
 d022ff0:	1880008d 	sth	r2,2(r3)
      ++igmpstats.igmp_badsum_rcvd;
 d022ff4:	008341b4 	movhi	r2,3334
 d022ff8:	10b2a904 	addi	r2,r2,-13660
 d022ffc:	10800b17 	ldw	r2,44(r2)
 d023000:	10c00044 	addi	r3,r2,1
 d023004:	008341b4 	movhi	r2,3334
 d023008:	10b2a904 	addi	r2,r2,-13660
 d02300c:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 d023010:	00bff804 	movi	r2,-32
 d023014:	e0bfff15 	stw	r2,-4(fp)
 d023018:	00008c06 	br	d02324c <igmp_validate+0x344>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 d02301c:	e0bffb17 	ldw	r2,-20(fp)
 d023020:	10800003 	ldbu	r2,0(r2)
 d023024:	e0bff905 	stb	r2,-28(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 d023028:	e0bffb17 	ldw	r2,-20(fp)
 d02302c:	10800117 	ldw	r2,4(r2)
 d023030:	1004d63a 	srli	r2,r2,24
 d023034:	10c03fcc 	andi	r3,r2,255
 d023038:	e0bffb17 	ldw	r2,-20(fp)
 d02303c:	10800117 	ldw	r2,4(r2)
 d023040:	1004d23a 	srli	r2,r2,8
 d023044:	10bfc00c 	andi	r2,r2,65280
 d023048:	1886b03a 	or	r3,r3,r2
 d02304c:	e0bffb17 	ldw	r2,-20(fp)
 d023050:	10800117 	ldw	r2,4(r2)
 d023054:	10bfc00c 	andi	r2,r2,65280
 d023058:	1004923a 	slli	r2,r2,8
 d02305c:	1886b03a 	or	r3,r3,r2
 d023060:	e0bffb17 	ldw	r2,-20(fp)
 d023064:	10800117 	ldw	r2,4(r2)
 d023068:	10803fcc 	andi	r2,r2,255
 d02306c:	1004963a 	slli	r2,r2,24
 d023070:	1884b03a 	or	r2,r3,r2
 d023074:	e0bff815 	stw	r2,-32(fp)
   resp_time = igmp->igmp_code;
 d023078:	e0bffb17 	ldw	r2,-20(fp)
 d02307c:	10800043 	ldbu	r2,1(r2)
 d023080:	e0bff705 	stb	r2,-36(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 d023084:	e0bff903 	ldbu	r2,-28(fp)
 d023088:	10800458 	cmpnei	r2,r2,17
 d02308c:	1000381e 	bne	r2,zero,d023170 <igmp_validate+0x268>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 d023090:	e0bff703 	ldbu	r2,-36(fp)
 d023094:	1005003a 	cmpeq	r2,r2,zero
 d023098:	1000061e 	bne	r2,zero,d0230b4 <igmp_validate+0x1ac>
 d02309c:	e0bff703 	ldbu	r2,-36(fp)
 d0230a0:	1005003a 	cmpeq	r2,r2,zero
 d0230a4:	1000111e 	bne	r2,zero,d0230ec <igmp_validate+0x1e4>
 d0230a8:	e0bff817 	ldw	r2,-32(fp)
 d0230ac:	1004c03a 	cmpne	r2,r2,zero
 d0230b0:	10000e1e 	bne	r2,zero,d0230ec <igmp_validate+0x1e4>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 d0230b4:	e0bffd17 	ldw	r2,-12(fp)
 d0230b8:	10c00417 	ldw	r3,16(r2)
 d0230bc:	d0a08817 	ldw	r2,-32224(gp)
 d0230c0:	18800a26 	beq	r3,r2,d0230ec <igmp_validate+0x1e4>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 d0230c4:	008341b4 	movhi	r2,3334
 d0230c8:	10b2a904 	addi	r2,r2,-13660
 d0230cc:	10800e17 	ldw	r2,56(r2)
 d0230d0:	10c00044 	addi	r3,r2,1
 d0230d4:	008341b4 	movhi	r2,3334
 d0230d8:	10b2a904 	addi	r2,r2,-13660
 d0230dc:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 d0230e0:	00bff804 	movi	r2,-32
 d0230e4:	e0bfff15 	stw	r2,-4(fp)
 d0230e8:	00005806 	br	d02324c <igmp_validate+0x344>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 d0230ec:	e0bff703 	ldbu	r2,-36(fp)
 d0230f0:	1005003a 	cmpeq	r2,r2,zero
 d0230f4:	10001e1e 	bne	r2,zero,d023170 <igmp_validate+0x268>
 d0230f8:	e0bff817 	ldw	r2,-32(fp)
 d0230fc:	1005003a 	cmpeq	r2,r2,zero
 d023100:	10001b1e 	bne	r2,zero,d023170 <igmp_validate+0x268>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 d023104:	e0bffe17 	ldw	r2,-8(fp)
 d023108:	10800617 	ldw	r2,24(r2)
 d02310c:	10802f03 	ldbu	r2,188(r2)
 d023110:	10803fcc 	andi	r2,r2,255
 d023114:	10800058 	cmpnei	r2,r2,1
 d023118:	1000031e 	bne	r2,zero,d023128 <igmp_validate+0x220>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 d02311c:	00bff804 	movi	r2,-32
 d023120:	e0bfff15 	stw	r2,-4(fp)
 d023124:	00004906 	br	d02324c <igmp_validate+0x344>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 d023128:	e0bff817 	ldw	r2,-32(fp)
 d02312c:	10fc002c 	andhi	r3,r2,61440
 d023130:	00b80034 	movhi	r2,57344
 d023134:	1880041e 	bne	r3,r2,d023148 <igmp_validate+0x240>
 d023138:	e0bffb17 	ldw	r2,-20(fp)
 d02313c:	10c00117 	ldw	r3,4(r2)
 d023140:	d0a08817 	ldw	r2,-32224(gp)
 d023144:	18800a1e 	bne	r3,r2,d023170 <igmp_validate+0x268>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 d023148:	008341b4 	movhi	r2,3334
 d02314c:	10b2a904 	addi	r2,r2,-13660
 d023150:	10801117 	ldw	r2,68(r2)
 d023154:	10c00044 	addi	r3,r2,1
 d023158:	008341b4 	movhi	r2,3334
 d02315c:	10b2a904 	addi	r2,r2,-13660
 d023160:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 d023164:	00bff804 	movi	r2,-32
 d023168:	e0bfff15 	stw	r2,-4(fp)
 d02316c:	00003706 	br	d02324c <igmp_validate+0x344>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 d023170:	e0bff903 	ldbu	r2,-28(fp)
 d023174:	108004a0 	cmpeqi	r2,r2,18
 d023178:	1000031e 	bne	r2,zero,d023188 <igmp_validate+0x280>
 d02317c:	e0bff903 	ldbu	r2,-28(fp)
 d023180:	10800598 	cmpnei	r2,r2,22
 d023184:	1000131e 	bne	r2,zero,d0231d4 <igmp_validate+0x2cc>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 d023188:	e0bffb17 	ldw	r2,-20(fp)
 d02318c:	10c00117 	ldw	r3,4(r2)
 d023190:	e0bffd17 	ldw	r2,-12(fp)
 d023194:	10800417 	ldw	r2,16(r2)
 d023198:	1880041e 	bne	r3,r2,d0231ac <igmp_validate+0x2a4>
 d02319c:	e0bff817 	ldw	r2,-32(fp)
 d0231a0:	10fc002c 	andhi	r3,r2,61440
 d0231a4:	00b80034 	movhi	r2,57344
 d0231a8:	18800a26 	beq	r3,r2,d0231d4 <igmp_validate+0x2cc>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 d0231ac:	008341b4 	movhi	r2,3334
 d0231b0:	10b2a904 	addi	r2,r2,-13660
 d0231b4:	10800f17 	ldw	r2,60(r2)
 d0231b8:	10c00044 	addi	r3,r2,1
 d0231bc:	008341b4 	movhi	r2,3334
 d0231c0:	10b2a904 	addi	r2,r2,-13660
 d0231c4:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 d0231c8:	00bff804 	movi	r2,-32
 d0231cc:	e0bfff15 	stw	r2,-4(fp)
 d0231d0:	00001e06 	br	d02324c <igmp_validate+0x344>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 d0231d4:	e0bff903 	ldbu	r2,-28(fp)
 d0231d8:	108005e0 	cmpeqi	r2,r2,23
 d0231dc:	10000b1e 	bne	r2,zero,d02320c <igmp_validate+0x304>
 d0231e0:	e0bff903 	ldbu	r2,-28(fp)
 d0231e4:	108005a0 	cmpeqi	r2,r2,22
 d0231e8:	1000081e 	bne	r2,zero,d02320c <igmp_validate+0x304>
 d0231ec:	e0bff903 	ldbu	r2,-28(fp)
 d0231f0:	10800458 	cmpnei	r2,r2,17
 d0231f4:	1000141e 	bne	r2,zero,d023248 <igmp_validate+0x340>
 d0231f8:	e0bffb17 	ldw	r2,-20(fp)
 d0231fc:	10800043 	ldbu	r2,1(r2)
 d023200:	10803fcc 	andi	r2,r2,255
 d023204:	1005003a 	cmpeq	r2,r2,zero
 d023208:	10000f1e 	bne	r2,zero,d023248 <igmp_validate+0x340>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 d02320c:	e13ffd17 	ldw	r4,-12(fp)
 d023210:	d04400c0 	call	d04400c <igmpv2_chk4_rtr_alert_opt>
 d023214:	10803fcc 	andi	r2,r2,255
 d023218:	1004c03a 	cmpne	r2,r2,zero
 d02321c:	10000a1e 	bne	r2,zero,d023248 <igmp_validate+0x340>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 d023220:	008341b4 	movhi	r2,3334
 d023224:	10b2a904 	addi	r2,r2,-13660
 d023228:	10801417 	ldw	r2,80(r2)
 d02322c:	10c00044 	addi	r3,r2,1
 d023230:	008341b4 	movhi	r2,3334
 d023234:	10b2a904 	addi	r2,r2,-13660
 d023238:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 d02323c:	00bff804 	movi	r2,-32
 d023240:	e0bfff15 	stw	r2,-4(fp)
 d023244:	00000106 	br	d02324c <igmp_validate+0x344>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 d023248:	e03fff15 	stw	zero,-4(fp)
 d02324c:	e0bfff17 	ldw	r2,-4(fp)
}
 d023250:	e037883a 	mov	sp,fp
 d023254:	dfc00117 	ldw	ra,4(sp)
 d023258:	df000017 	ldw	fp,0(sp)
 d02325c:	dec00204 	addi	sp,sp,8
 d023260:	f800283a 	ret

0d023264 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 d023264:	defff504 	addi	sp,sp,-44
 d023268:	dfc00a15 	stw	ra,40(sp)
 d02326c:	df000915 	stw	fp,36(sp)
 d023270:	df000904 	addi	fp,sp,36
 d023274:	e13ffa15 	stw	r4,-24(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d023278:	008341b4 	movhi	r2,3334
 d02327c:	10b4e604 	addi	r2,r2,-11368
 d023280:	10800017 	ldw	r2,0(r2)
 d023284:	e0bff915 	stw	r2,-28(fp)
 d023288:	00004506 	br	d0233a0 <igmp_print_stats+0x13c>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 d02328c:	e0bff917 	ldw	r2,-28(fp)
 d023290:	10800104 	addi	r2,r2,4
 d023294:	e0bfff15 	stw	r2,-4(fp)
 d023298:	e0bff917 	ldw	r2,-28(fp)
 d02329c:	10802f03 	ldbu	r2,188(r2)
 d0232a0:	10803fcc 	andi	r2,r2,255
 d0232a4:	e0bffe15 	stw	r2,-8(fp)
 d0232a8:	e0bff917 	ldw	r2,-28(fp)
 d0232ac:	10802f03 	ldbu	r2,188(r2)
 d0232b0:	10803fcc 	andi	r2,r2,255
 d0232b4:	10800058 	cmpnei	r2,r2,1
 d0232b8:	1000041e 	bne	r2,zero,d0232cc <igmp_print_stats+0x68>
 d0232bc:	00834174 	movhi	r2,3333
 d0232c0:	10ba9104 	addi	r2,r2,-5564
 d0232c4:	e0bffd15 	stw	r2,-12(fp)
 d0232c8:	00000306 	br	d0232d8 <igmp_print_stats+0x74>
 d0232cc:	00834174 	movhi	r2,3333
 d0232d0:	10ba9204 	addi	r2,r2,-5560
 d0232d4:	e0bffd15 	stw	r2,-12(fp)
 d0232d8:	e0bffd17 	ldw	r2,-12(fp)
 d0232dc:	d8800015 	stw	r2,0(sp)
 d0232e0:	e13ffa17 	ldw	r4,-24(fp)
 d0232e4:	01434174 	movhi	r5,3333
 d0232e8:	297a9304 	addi	r5,r5,-5556
 d0232ec:	e1bfff17 	ldw	r6,-4(fp)
 d0232f0:	e1fffe17 	ldw	r7,-8(fp)
 d0232f4:	d02486c0 	call	d02486c <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 d0232f8:	e0bff917 	ldw	r2,-28(fp)
 d0232fc:	10802f03 	ldbu	r2,188(r2)
 d023300:	10803fcc 	andi	r2,r2,255
 d023304:	10800098 	cmpnei	r2,r2,2
 d023308:	10001e1e 	bne	r2,zero,d023384 <igmp_print_stats+0x120>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 d02330c:	e0bff917 	ldw	r2,-28(fp)
 d023310:	10802d03 	ldbu	r2,180(r2)
 d023314:	10803fcc 	andi	r2,r2,255
 d023318:	e0bffc15 	stw	r2,-16(fp)
 d02331c:	e0bff917 	ldw	r2,-28(fp)
 d023320:	10802d03 	ldbu	r2,180(r2)
 d023324:	10803fcc 	andi	r2,r2,255
 d023328:	10800058 	cmpnei	r2,r2,1
 d02332c:	1000041e 	bne	r2,zero,d023340 <igmp_print_stats+0xdc>
 d023330:	00834174 	movhi	r2,3333
 d023334:	10ba9804 	addi	r2,r2,-5536
 d023338:	e0bffb15 	stw	r2,-20(fp)
 d02333c:	00000306 	br	d02334c <igmp_print_stats+0xe8>
 d023340:	00834174 	movhi	r2,3333
 d023344:	10ba9a04 	addi	r2,r2,-5528
 d023348:	e0bffb15 	stw	r2,-20(fp)
 d02334c:	e0bff917 	ldw	r2,-28(fp)
 d023350:	10c02e17 	ldw	r3,184(r2)
 d023354:	00834174 	movhi	r2,3333
 d023358:	108ac904 	addi	r2,r2,11044
 d02335c:	10800017 	ldw	r2,0(r2)
 d023360:	d8c00015 	stw	r3,0(sp)
 d023364:	d8800115 	stw	r2,4(sp)
 d023368:	e13ffa17 	ldw	r4,-24(fp)
 d02336c:	01434174 	movhi	r5,3333
 d023370:	297a9c04 	addi	r5,r5,-5520
 d023374:	e1bffc17 	ldw	r6,-16(fp)
 d023378:	e1fffb17 	ldw	r7,-20(fp)
 d02337c:	d02486c0 	call	d02486c <ns_printf>
 d023380:	00000406 	br	d023394 <igmp_print_stats+0x130>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 d023384:	e13ffa17 	ldw	r4,-24(fp)
 d023388:	01434174 	movhi	r5,3333
 d02338c:	297aa704 	addi	r5,r5,-5476
 d023390:	d02486c0 	call	d02486c <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d023394:	e0bff917 	ldw	r2,-28(fp)
 d023398:	10800017 	ldw	r2,0(r2)
 d02339c:	e0bff915 	stw	r2,-28(fp)
 d0233a0:	e0bff917 	ldw	r2,-28(fp)
 d0233a4:	1004c03a 	cmpne	r2,r2,zero
 d0233a8:	103fb81e 	bne	r2,zero,d02328c <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 d0233ac:	008341b4 	movhi	r2,3334
 d0233b0:	10b2a904 	addi	r2,r2,-13660
 d0233b4:	11800017 	ldw	r6,0(r2)
 d0233b8:	d1e08617 	ldw	r7,-32232(gp)
 d0233bc:	e13ffa17 	ldw	r4,-24(fp)
 d0233c0:	01434174 	movhi	r5,3333
 d0233c4:	297aa804 	addi	r5,r5,-5472
 d0233c8:	d02486c0 	call	d02486c <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 d0233cc:	008341b4 	movhi	r2,3334
 d0233d0:	10b2a904 	addi	r2,r2,-13660
 d0233d4:	11800117 	ldw	r6,4(r2)
 d0233d8:	e13ffa17 	ldw	r4,-24(fp)
 d0233dc:	01434174 	movhi	r5,3333
 d0233e0:	297ab504 	addi	r5,r5,-5420
 d0233e4:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 d0233e8:	008341b4 	movhi	r2,3334
 d0233ec:	10b2a904 	addi	r2,r2,-13660
 d0233f0:	11800217 	ldw	r6,8(r2)
 d0233f4:	e13ffa17 	ldw	r4,-24(fp)
 d0233f8:	01434174 	movhi	r5,3333
 d0233fc:	297ac604 	addi	r5,r5,-5352
 d023400:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 d023404:	008341b4 	movhi	r2,3334
 d023408:	10b2a904 	addi	r2,r2,-13660
 d02340c:	11800317 	ldw	r6,12(r2)
 d023410:	e13ffa17 	ldw	r4,-24(fp)
 d023414:	01434174 	movhi	r5,3333
 d023418:	297ad204 	addi	r5,r5,-5304
 d02341c:	d02486c0 	call	d02486c <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 d023420:	008341b4 	movhi	r2,3334
 d023424:	10b2a904 	addi	r2,r2,-13660
 d023428:	11800417 	ldw	r6,16(r2)
 d02342c:	e13ffa17 	ldw	r4,-24(fp)
 d023430:	01434174 	movhi	r5,3333
 d023434:	297ae504 	addi	r5,r5,-5228
 d023438:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 d02343c:	008341b4 	movhi	r2,3334
 d023440:	10b2a904 	addi	r2,r2,-13660
 d023444:	11800517 	ldw	r6,20(r2)
 d023448:	008341b4 	movhi	r2,3334
 d02344c:	10b2a904 	addi	r2,r2,-13660
 d023450:	11c00617 	ldw	r7,24(r2)
 d023454:	e13ffa17 	ldw	r4,-24(fp)
 d023458:	01434174 	movhi	r5,3333
 d02345c:	297af604 	addi	r5,r5,-5160
 d023460:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 d023464:	008341b4 	movhi	r2,3334
 d023468:	10b2a904 	addi	r2,r2,-13660
 d02346c:	11800717 	ldw	r6,28(r2)
 d023470:	e13ffa17 	ldw	r4,-24(fp)
 d023474:	01434174 	movhi	r5,3333
 d023478:	297ad204 	addi	r5,r5,-5304
 d02347c:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 d023480:	008341b4 	movhi	r2,3334
 d023484:	10b2a904 	addi	r2,r2,-13660
 d023488:	11800817 	ldw	r6,32(r2)
 d02348c:	e13ffa17 	ldw	r4,-24(fp)
 d023490:	01434174 	movhi	r5,3333
 d023494:	297b0904 	addi	r5,r5,-5084
 d023498:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 d02349c:	008341b4 	movhi	r2,3334
 d0234a0:	10b2a904 	addi	r2,r2,-13660
 d0234a4:	11800917 	ldw	r6,36(r2)
 d0234a8:	e13ffa17 	ldw	r4,-24(fp)
 d0234ac:	01434174 	movhi	r5,3333
 d0234b0:	297b1a04 	addi	r5,r5,-5016
 d0234b4:	d02486c0 	call	d02486c <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 d0234b8:	008341b4 	movhi	r2,3334
 d0234bc:	10b2a904 	addi	r2,r2,-13660
 d0234c0:	11801717 	ldw	r6,92(r2)
 d0234c4:	008341b4 	movhi	r2,3334
 d0234c8:	10b2a904 	addi	r2,r2,-13660
 d0234cc:	11c01817 	ldw	r7,96(r2)
 d0234d0:	e13ffa17 	ldw	r4,-24(fp)
 d0234d4:	01434174 	movhi	r5,3333
 d0234d8:	297b2604 	addi	r5,r5,-4968
 d0234dc:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 d0234e0:	008341b4 	movhi	r2,3334
 d0234e4:	10b2a904 	addi	r2,r2,-13660
 d0234e8:	11801617 	ldw	r6,88(r2)
 d0234ec:	e13ffa17 	ldw	r4,-24(fp)
 d0234f0:	01434174 	movhi	r5,3333
 d0234f4:	297b3904 	addi	r5,r5,-4892
 d0234f8:	d02486c0 	call	d02486c <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 d0234fc:	008341b4 	movhi	r2,3334
 d023500:	10b2a904 	addi	r2,r2,-13660
 d023504:	11800a17 	ldw	r6,40(r2)
 d023508:	e13ffa17 	ldw	r4,-24(fp)
 d02350c:	01434174 	movhi	r5,3333
 d023510:	297b4504 	addi	r5,r5,-4844
 d023514:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 d023518:	008341b4 	movhi	r2,3334
 d02351c:	10b2a904 	addi	r2,r2,-13660
 d023520:	11800b17 	ldw	r6,44(r2)
 d023524:	e13ffa17 	ldw	r4,-24(fp)
 d023528:	01434174 	movhi	r5,3333
 d02352c:	297b5104 	addi	r5,r5,-4796
 d023530:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 d023534:	008341b4 	movhi	r2,3334
 d023538:	10b2a904 	addi	r2,r2,-13660
 d02353c:	11800c17 	ldw	r6,48(r2)
 d023540:	008341b4 	movhi	r2,3334
 d023544:	10b2a904 	addi	r2,r2,-13660
 d023548:	11c00d17 	ldw	r7,52(r2)
 d02354c:	e13ffa17 	ldw	r4,-24(fp)
 d023550:	01434174 	movhi	r5,3333
 d023554:	297b5d04 	addi	r5,r5,-4748
 d023558:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 d02355c:	008341b4 	movhi	r2,3334
 d023560:	10b2a904 	addi	r2,r2,-13660
 d023564:	11800e17 	ldw	r6,56(r2)
 d023568:	008341b4 	movhi	r2,3334
 d02356c:	10b2a904 	addi	r2,r2,-13660
 d023570:	11c00f17 	ldw	r7,60(r2)
 d023574:	e13ffa17 	ldw	r4,-24(fp)
 d023578:	01434174 	movhi	r5,3333
 d02357c:	297b7104 	addi	r5,r5,-4668
 d023580:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 d023584:	008341b4 	movhi	r2,3334
 d023588:	10b2a904 	addi	r2,r2,-13660
 d02358c:	11801117 	ldw	r6,68(r2)
 d023590:	e13ffa17 	ldw	r4,-24(fp)
 d023594:	01434174 	movhi	r5,3333
 d023598:	297b8104 	addi	r5,r5,-4604
 d02359c:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 d0235a0:	008341b4 	movhi	r2,3334
 d0235a4:	10b2a904 	addi	r2,r2,-13660
 d0235a8:	11801217 	ldw	r6,72(r2)
 d0235ac:	e13ffa17 	ldw	r4,-24(fp)
 d0235b0:	01434174 	movhi	r5,3333
 d0235b4:	297b8e04 	addi	r5,r5,-4552
 d0235b8:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 d0235bc:	008341b4 	movhi	r2,3334
 d0235c0:	10b2a904 	addi	r2,r2,-13660
 d0235c4:	11801317 	ldw	r6,76(r2)
 d0235c8:	e13ffa17 	ldw	r4,-24(fp)
 d0235cc:	01434174 	movhi	r5,3333
 d0235d0:	297ba104 	addi	r5,r5,-4476
 d0235d4:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 d0235d8:	008341b4 	movhi	r2,3334
 d0235dc:	10b2a904 	addi	r2,r2,-13660
 d0235e0:	11801417 	ldw	r6,80(r2)
 d0235e4:	e13ffa17 	ldw	r4,-24(fp)
 d0235e8:	01434174 	movhi	r5,3333
 d0235ec:	297bb204 	addi	r5,r5,-4408
 d0235f0:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 d0235f4:	008341b4 	movhi	r2,3334
 d0235f8:	10b2a904 	addi	r2,r2,-13660
 d0235fc:	11801017 	ldw	r6,64(r2)
 d023600:	e13ffa17 	ldw	r4,-24(fp)
 d023604:	01434174 	movhi	r5,3333
 d023608:	297bc404 	addi	r5,r5,-4336
 d02360c:	d02486c0 	call	d02486c <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 d023610:	008341b4 	movhi	r2,3334
 d023614:	10b2a904 	addi	r2,r2,-13660
 d023618:	11801517 	ldw	r6,84(r2)
 d02361c:	e13ffa17 	ldw	r4,-24(fp)
 d023620:	01434174 	movhi	r5,3333
 d023624:	297bd404 	addi	r5,r5,-4272
 d023628:	d02486c0 	call	d02486c <ns_printf>
   
   return IGMP_OK;
 d02362c:	0005883a 	mov	r2,zero
}
 d023630:	e037883a 	mov	sp,fp
 d023634:	dfc00117 	ldw	ra,4(sp)
 d023638:	df000017 	ldw	fp,0(sp)
 d02363c:	dec00204 	addi	sp,sp,8
 d023640:	f800283a 	ret

0d023644 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 d023644:	defff304 	addi	sp,sp,-52
 d023648:	dfc00c15 	stw	ra,48(sp)
 d02364c:	df000b15 	stw	fp,44(sp)
 d023650:	df000b04 	addi	fp,sp,44
 d023654:	e13ffc15 	stw	r4,-16(fp)
 d023658:	e17ffd15 	stw	r5,-12(fp)
 d02365c:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 d023660:	e0bffc17 	ldw	r2,-16(fp)
 d023664:	10bff804 	addi	r2,r2,-32
 d023668:	1085883a 	add	r2,r2,r2
 d02366c:	1085883a 	add	r2,r2,r2
 d023670:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 d023674:	008341b4 	movhi	r2,3334
 d023678:	10b3e204 	addi	r2,r2,-12408
 d02367c:	e0bff515 	stw	r2,-44(fp)
 d023680:	00000606 	br	d02369c <bsd_accept+0x58>
 d023684:	e0fff517 	ldw	r3,-44(fp)
 d023688:	e0bff717 	ldw	r2,-36(fp)
 d02368c:	18800626 	beq	r3,r2,d0236a8 <bsd_accept+0x64>
 d023690:	e0bff517 	ldw	r2,-44(fp)
 d023694:	10800017 	ldw	r2,0(r2)
 d023698:	e0bff515 	stw	r2,-44(fp)
 d02369c:	e0bff517 	ldw	r2,-44(fp)
 d0236a0:	1004c03a 	cmpne	r2,r2,zero
 d0236a4:	103ff71e 	bne	r2,zero,d023684 <bsd_accept+0x40>
 d0236a8:	e0fff517 	ldw	r3,-44(fp)
 d0236ac:	e0bff717 	ldw	r2,-36(fp)
 d0236b0:	18800426 	beq	r3,r2,d0236c4 <bsd_accept+0x80>
 d0236b4:	d0293e80 	call	d0293e8 <dtrap>
 d0236b8:	00bfffc4 	movi	r2,-1
 d0236bc:	e0bfff15 	stw	r2,-4(fp)
 d0236c0:	00002806 	br	d023764 <bsd_accept+0x120>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 d0236c4:	e0bffd17 	ldw	r2,-12(fp)
 d0236c8:	1005003a 	cmpeq	r2,r2,zero
 d0236cc:	1000091e 	bne	r2,zero,d0236f4 <bsd_accept+0xb0>
   {
      if (addrlen == 0)
 d0236d0:	e0bffe17 	ldw	r2,-8(fp)
 d0236d4:	1004c03a 	cmpne	r2,r2,zero
 d0236d8:	1000061e 	bne	r2,zero,d0236f4 <bsd_accept+0xb0>
      {
         so->so_error = EFAULT;
 d0236dc:	e0fff717 	ldw	r3,-36(fp)
 d0236e0:	00800384 	movi	r2,14
 d0236e4:	18800615 	stw	r2,24(r3)
         return -1;
 d0236e8:	00bfffc4 	movi	r2,-1
 d0236ec:	e0bfff15 	stw	r2,-4(fp)
 d0236f0:	00001c06 	br	d023764 <bsd_accept+0x120>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 d0236f4:	e17ff804 	addi	r5,fp,-32
 d0236f8:	e13ffc17 	ldw	r4,-16(fp)
 d0236fc:	e1bffe17 	ldw	r6,-8(fp)
 d023700:	d02c75c0 	call	d02c75c <t_accept>
 d023704:	e0bff615 	stw	r2,-40(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 d023708:	e0bff617 	ldw	r2,-40(fp)
 d02370c:	10bfffe0 	cmpeqi	r2,r2,-1
 d023710:	1000121e 	bne	r2,zero,d02375c <bsd_accept+0x118>
 d023714:	e0bffd17 	ldw	r2,-12(fp)
 d023718:	1005003a 	cmpeq	r2,r2,zero
 d02371c:	10000f1e 	bne	r2,zero,d02375c <bsd_accept+0x118>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 d023720:	e0bffe17 	ldw	r2,-8(fp)
 d023724:	10800017 	ldw	r2,0(r2)
 d023728:	10800470 	cmpltui	r2,r2,17
 d02372c:	1000031e 	bne	r2,zero,d02373c <bsd_accept+0xf8>
         *addrlen = sizeof(struct sockaddr_in);
 d023730:	e0fffe17 	ldw	r3,-8(fp)
 d023734:	00800404 	movi	r2,16
 d023738:	18800015 	stw	r2,0(r3)
      MEMCPY(addr, &laddr, *addrlen);
 d02373c:	e0bffe17 	ldw	r2,-8(fp)
 d023740:	10800017 	ldw	r2,0(r2)
 d023744:	100d883a 	mov	r6,r2
 d023748:	e0bffd17 	ldw	r2,-12(fp)
 d02374c:	e0fff804 	addi	r3,fp,-32
 d023750:	1009883a 	mov	r4,r2
 d023754:	180b883a 	mov	r5,r3
 d023758:	d0027000 	call	d002700 <memcpy>
   }

   return lret;
 d02375c:	e0bff617 	ldw	r2,-40(fp)
 d023760:	e0bfff15 	stw	r2,-4(fp)
 d023764:	e0bfff17 	ldw	r2,-4(fp)
}
 d023768:	e037883a 	mov	sp,fp
 d02376c:	dfc00117 	ldw	ra,4(sp)
 d023770:	df000017 	ldw	fp,0(sp)
 d023774:	dec00204 	addi	sp,sp,8
 d023778:	f800283a 	ret

0d02377c <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 d02377c:	defff204 	addi	sp,sp,-56
 d023780:	dfc00d15 	stw	ra,52(sp)
 d023784:	df000c15 	stw	fp,48(sp)
 d023788:	df000c04 	addi	fp,sp,48
 d02378c:	e13ffc15 	stw	r4,-16(fp)
 d023790:	e17ffd15 	stw	r5,-12(fp)
 d023794:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 d023798:	e0bffc17 	ldw	r2,-16(fp)
 d02379c:	10bff804 	addi	r2,r2,-32
 d0237a0:	1085883a 	add	r2,r2,r2
 d0237a4:	1085883a 	add	r2,r2,r2
 d0237a8:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 d0237ac:	008341b4 	movhi	r2,3334
 d0237b0:	10b3e204 	addi	r2,r2,-12408
 d0237b4:	e0bff415 	stw	r2,-48(fp)
 d0237b8:	00000606 	br	d0237d4 <bsd_getpeername+0x58>
 d0237bc:	e0fff417 	ldw	r3,-48(fp)
 d0237c0:	e0bff617 	ldw	r2,-40(fp)
 d0237c4:	18800626 	beq	r3,r2,d0237e0 <bsd_getpeername+0x64>
 d0237c8:	e0bff417 	ldw	r2,-48(fp)
 d0237cc:	10800017 	ldw	r2,0(r2)
 d0237d0:	e0bff415 	stw	r2,-48(fp)
 d0237d4:	e0bff417 	ldw	r2,-48(fp)
 d0237d8:	1004c03a 	cmpne	r2,r2,zero
 d0237dc:	103ff71e 	bne	r2,zero,d0237bc <bsd_getpeername+0x40>
 d0237e0:	e0fff417 	ldw	r3,-48(fp)
 d0237e4:	e0bff617 	ldw	r2,-40(fp)
 d0237e8:	18800426 	beq	r3,r2,d0237fc <bsd_getpeername+0x80>
 d0237ec:	d0293e80 	call	d0293e8 <dtrap>
 d0237f0:	00bfffc4 	movi	r2,-1
 d0237f4:	e0bfff15 	stw	r2,-4(fp)
 d0237f8:	00002506 	br	d023890 <bsd_getpeername+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 d0237fc:	e0bffe17 	ldw	r2,-8(fp)
 d023800:	1004c03a 	cmpne	r2,r2,zero
 d023804:	1000061e 	bne	r2,zero,d023820 <bsd_getpeername+0xa4>
   {
      so->so_error = EFAULT;
 d023808:	e0fff617 	ldw	r3,-40(fp)
 d02380c:	00800384 	movi	r2,14
 d023810:	18800615 	stw	r2,24(r3)
      return -1;
 d023814:	00bfffc4 	movi	r2,-1
 d023818:	e0bfff15 	stw	r2,-4(fp)
 d02381c:	00001c06 	br	d023890 <bsd_getpeername+0x114>
   }
   lnamelen = *namelen;
 d023820:	e0bffe17 	ldw	r2,-8(fp)
 d023824:	10800017 	ldw	r2,0(r2)
 d023828:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 d02382c:	e17ff704 	addi	r5,fp,-36
 d023830:	e1bffb04 	addi	r6,fp,-20
 d023834:	e13ffc17 	ldw	r4,-16(fp)
 d023838:	d02cc9c0 	call	d02cc9c <t_getpeername>
 d02383c:	e0bff515 	stw	r2,-44(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 d023840:	e0bff517 	ldw	r2,-44(fp)
 d023844:	10bfffe0 	cmpeqi	r2,r2,-1
 d023848:	10000f1e 	bne	r2,zero,d023888 <bsd_getpeername+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 d02384c:	e0bffb17 	ldw	r2,-20(fp)
 d023850:	10800470 	cmpltui	r2,r2,17
 d023854:	1000021e 	bne	r2,zero,d023860 <bsd_getpeername+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 d023858:	00800404 	movi	r2,16
 d02385c:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 d023860:	e0bffb17 	ldw	r2,-20(fp)
 d023864:	100d883a 	mov	r6,r2
 d023868:	e0bffd17 	ldw	r2,-12(fp)
 d02386c:	e0fff704 	addi	r3,fp,-36
 d023870:	1009883a 	mov	r4,r2
 d023874:	180b883a 	mov	r5,r3
 d023878:	d0027000 	call	d002700 <memcpy>
      *namelen = lnamelen;
 d02387c:	e0fffb17 	ldw	r3,-20(fp)
 d023880:	e0bffe17 	ldw	r2,-8(fp)
 d023884:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 d023888:	e0bff517 	ldw	r2,-44(fp)
 d02388c:	e0bfff15 	stw	r2,-4(fp)
 d023890:	e0bfff17 	ldw	r2,-4(fp)
}
 d023894:	e037883a 	mov	sp,fp
 d023898:	dfc00117 	ldw	ra,4(sp)
 d02389c:	df000017 	ldw	fp,0(sp)
 d0238a0:	dec00204 	addi	sp,sp,8
 d0238a4:	f800283a 	ret

0d0238a8 <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 d0238a8:	defff204 	addi	sp,sp,-56
 d0238ac:	dfc00d15 	stw	ra,52(sp)
 d0238b0:	df000c15 	stw	fp,48(sp)
 d0238b4:	df000c04 	addi	fp,sp,48
 d0238b8:	e13ffc15 	stw	r4,-16(fp)
 d0238bc:	e17ffd15 	stw	r5,-12(fp)
 d0238c0:	e1bffe15 	stw	r6,-8(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 d0238c4:	e0bffc17 	ldw	r2,-16(fp)
 d0238c8:	10bff804 	addi	r2,r2,-32
 d0238cc:	1085883a 	add	r2,r2,r2
 d0238d0:	1085883a 	add	r2,r2,r2
 d0238d4:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 d0238d8:	008341b4 	movhi	r2,3334
 d0238dc:	10b3e204 	addi	r2,r2,-12408
 d0238e0:	e0bff415 	stw	r2,-48(fp)
 d0238e4:	00000606 	br	d023900 <bsd_getsockname+0x58>
 d0238e8:	e0fff417 	ldw	r3,-48(fp)
 d0238ec:	e0bff617 	ldw	r2,-40(fp)
 d0238f0:	18800626 	beq	r3,r2,d02390c <bsd_getsockname+0x64>
 d0238f4:	e0bff417 	ldw	r2,-48(fp)
 d0238f8:	10800017 	ldw	r2,0(r2)
 d0238fc:	e0bff415 	stw	r2,-48(fp)
 d023900:	e0bff417 	ldw	r2,-48(fp)
 d023904:	1004c03a 	cmpne	r2,r2,zero
 d023908:	103ff71e 	bne	r2,zero,d0238e8 <bsd_getsockname+0x40>
 d02390c:	e0fff417 	ldw	r3,-48(fp)
 d023910:	e0bff617 	ldw	r2,-40(fp)
 d023914:	18800426 	beq	r3,r2,d023928 <bsd_getsockname+0x80>
 d023918:	d0293e80 	call	d0293e8 <dtrap>
 d02391c:	00bfffc4 	movi	r2,-1
 d023920:	e0bfff15 	stw	r2,-4(fp)
 d023924:	00002506 	br	d0239bc <bsd_getsockname+0x114>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 d023928:	e0bffe17 	ldw	r2,-8(fp)
 d02392c:	1004c03a 	cmpne	r2,r2,zero
 d023930:	1000061e 	bne	r2,zero,d02394c <bsd_getsockname+0xa4>
   {
      so->so_error = EFAULT;
 d023934:	e0fff617 	ldw	r3,-40(fp)
 d023938:	00800384 	movi	r2,14
 d02393c:	18800615 	stw	r2,24(r3)
      return -1;
 d023940:	00bfffc4 	movi	r2,-1
 d023944:	e0bfff15 	stw	r2,-4(fp)
 d023948:	00001c06 	br	d0239bc <bsd_getsockname+0x114>
   }
   lnamelen = *namelen;
 d02394c:	e0bffe17 	ldw	r2,-8(fp)
 d023950:	10800017 	ldw	r2,0(r2)
 d023954:	e0bffb15 	stw	r2,-20(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 d023958:	e17ff704 	addi	r5,fp,-36
 d02395c:	e1bffb04 	addi	r6,fp,-20
 d023960:	e13ffc17 	ldw	r4,-16(fp)
 d023964:	d02cce00 	call	d02cce0 <t_getsockname>
 d023968:	e0bff515 	stw	r2,-44(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 d02396c:	e0bff517 	ldw	r2,-44(fp)
 d023970:	10bfffe0 	cmpeqi	r2,r2,-1
 d023974:	10000f1e 	bne	r2,zero,d0239b4 <bsd_getsockname+0x10c>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 d023978:	e0bffb17 	ldw	r2,-20(fp)
 d02397c:	10800470 	cmpltui	r2,r2,17
 d023980:	1000021e 	bne	r2,zero,d02398c <bsd_getsockname+0xe4>
         lnamelen = sizeof(struct sockaddr_in);
 d023984:	00800404 	movi	r2,16
 d023988:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 d02398c:	e0bffb17 	ldw	r2,-20(fp)
 d023990:	100d883a 	mov	r6,r2
 d023994:	e0bffd17 	ldw	r2,-12(fp)
 d023998:	e0fff704 	addi	r3,fp,-36
 d02399c:	1009883a 	mov	r4,r2
 d0239a0:	180b883a 	mov	r5,r3
 d0239a4:	d0027000 	call	d002700 <memcpy>
      *namelen = lnamelen;
 d0239a8:	e0fffb17 	ldw	r3,-20(fp)
 d0239ac:	e0bffe17 	ldw	r2,-8(fp)
 d0239b0:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 d0239b4:	e0bff517 	ldw	r2,-44(fp)
 d0239b8:	e0bfff15 	stw	r2,-4(fp)
 d0239bc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0239c0:	e037883a 	mov	sp,fp
 d0239c4:	dfc00117 	ldw	ra,4(sp)
 d0239c8:	df000017 	ldw	fp,0(sp)
 d0239cc:	dec00204 	addi	sp,sp,8
 d0239d0:	f800283a 	ret

0d0239d4 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 d0239d4:	defffb04 	addi	sp,sp,-20
 d0239d8:	df000415 	stw	fp,16(sp)
 d0239dc:	df000404 	addi	fp,sp,16
 d0239e0:	e13ffc15 	stw	r4,-16(fp)
 d0239e4:	e17ffd15 	stw	r5,-12(fp)
   USE_ARG(level);

   switch (name)
 d0239e8:	e0bffd17 	ldw	r2,-12(fp)
 d0239ec:	e0bfff15 	stw	r2,-4(fp)
 d0239f0:	e0ffff17 	ldw	r3,-4(fp)
 d0239f4:	18802020 	cmpeqi	r2,r3,128
 d0239f8:	1000491e 	bne	r2,zero,d023b20 <bsd_i_sockoptlen+0x14c>
 d0239fc:	e0ffff17 	ldw	r3,-4(fp)
 d023a00:	18802048 	cmpgei	r2,r3,129
 d023a04:	1000251e 	bne	r2,zero,d023a9c <bsd_i_sockoptlen+0xc8>
 d023a08:	e0ffff17 	ldw	r3,-4(fp)
 d023a0c:	18800308 	cmpgei	r2,r3,12
 d023a10:	1000141e 	bne	r2,zero,d023a64 <bsd_i_sockoptlen+0x90>
 d023a14:	e0ffff17 	ldw	r3,-4(fp)
 d023a18:	18800288 	cmpgei	r2,r3,10
 d023a1c:	10004c1e 	bne	r2,zero,d023b50 <bsd_i_sockoptlen+0x17c>
 d023a20:	e0ffff17 	ldw	r3,-4(fp)
 d023a24:	18800120 	cmpeqi	r2,r3,4
 d023a28:	1000431e 	bne	r2,zero,d023b38 <bsd_i_sockoptlen+0x164>
 d023a2c:	e0ffff17 	ldw	r3,-4(fp)
 d023a30:	18800148 	cmpgei	r2,r3,5
 d023a34:	1000041e 	bne	r2,zero,d023a48 <bsd_i_sockoptlen+0x74>
 d023a38:	e0ffff17 	ldw	r3,-4(fp)
 d023a3c:	188000e0 	cmpeqi	r2,r3,3
 d023a40:	1000491e 	bne	r2,zero,d023b68 <bsd_i_sockoptlen+0x194>
 d023a44:	00004b06 	br	d023b74 <bsd_i_sockoptlen+0x1a0>
 d023a48:	e0ffff17 	ldw	r3,-4(fp)
 d023a4c:	18800220 	cmpeqi	r2,r3,8
 d023a50:	1000391e 	bne	r2,zero,d023b38 <bsd_i_sockoptlen+0x164>
 d023a54:	e0ffff17 	ldw	r3,-4(fp)
 d023a58:	18800260 	cmpeqi	r2,r3,9
 d023a5c:	1000391e 	bne	r2,zero,d023b44 <bsd_i_sockoptlen+0x170>
 d023a60:	00004406 	br	d023b74 <bsd_i_sockoptlen+0x1a0>
 d023a64:	e0ffff17 	ldw	r3,-4(fp)
 d023a68:	18800420 	cmpeqi	r2,r3,16
 d023a6c:	1000321e 	bne	r2,zero,d023b38 <bsd_i_sockoptlen+0x164>
 d023a70:	e0ffff17 	ldw	r3,-4(fp)
 d023a74:	18800448 	cmpgei	r2,r3,17
 d023a78:	1000041e 	bne	r2,zero,d023a8c <bsd_i_sockoptlen+0xb8>
 d023a7c:	e0ffff17 	ldw	r3,-4(fp)
 d023a80:	18800388 	cmpgei	r2,r3,14
 d023a84:	10003b1e 	bne	r2,zero,d023b74 <bsd_i_sockoptlen+0x1a0>
 d023a88:	00003406 	br	d023b5c <bsd_i_sockoptlen+0x188>
 d023a8c:	e0ffff17 	ldw	r3,-4(fp)
 d023a90:	18800820 	cmpeqi	r2,r3,32
 d023a94:	1000281e 	bne	r2,zero,d023b38 <bsd_i_sockoptlen+0x164>
 d023a98:	00003606 	br	d023b74 <bsd_i_sockoptlen+0x1a0>
 d023a9c:	e0ffff17 	ldw	r3,-4(fp)
 d023aa0:	188401c8 	cmpgei	r2,r3,4103
 d023aa4:	10000e1e 	bne	r2,zero,d023ae0 <bsd_i_sockoptlen+0x10c>
 d023aa8:	e0ffff17 	ldw	r3,-4(fp)
 d023aac:	18840148 	cmpgei	r2,r3,4101
 d023ab0:	10001e1e 	bne	r2,zero,d023b2c <bsd_i_sockoptlen+0x158>
 d023ab4:	e0ffff17 	ldw	r3,-4(fp)
 d023ab8:	18804020 	cmpeqi	r2,r3,256
 d023abc:	10001e1e 	bne	r2,zero,d023b38 <bsd_i_sockoptlen+0x164>
 d023ac0:	e0ffff17 	ldw	r3,-4(fp)
 d023ac4:	18804010 	cmplti	r2,r3,256
 d023ac8:	10002a1e 	bne	r2,zero,d023b74 <bsd_i_sockoptlen+0x1a0>
 d023acc:	e0ffff17 	ldw	r3,-4(fp)
 d023ad0:	18bbffc4 	addi	r2,r3,-4097
 d023ad4:	108000a8 	cmpgeui	r2,r2,2
 d023ad8:	1000261e 	bne	r2,zero,d023b74 <bsd_i_sockoptlen+0x1a0>
 d023adc:	00001606 	br	d023b38 <bsd_i_sockoptlen+0x164>
 d023ae0:	e0ffff17 	ldw	r3,-4(fp)
 d023ae4:	18840588 	cmpgei	r2,r3,4118
 d023ae8:	1000071e 	bne	r2,zero,d023b08 <bsd_i_sockoptlen+0x134>
 d023aec:	e0ffff17 	ldw	r3,-4(fp)
 d023af0:	18840508 	cmpgei	r2,r3,4116
 d023af4:	1000081e 	bne	r2,zero,d023b18 <bsd_i_sockoptlen+0x144>
 d023af8:	e0ffff17 	ldw	r3,-4(fp)
 d023afc:	18840248 	cmpgei	r2,r3,4105
 d023b00:	10001c1e 	bne	r2,zero,d023b74 <bsd_i_sockoptlen+0x1a0>
 d023b04:	00000c06 	br	d023b38 <bsd_i_sockoptlen+0x164>
 d023b08:	e0ffff17 	ldw	r3,-4(fp)
 d023b0c:	188405a0 	cmpeqi	r2,r3,4118
 d023b10:	1000091e 	bne	r2,zero,d023b38 <bsd_i_sockoptlen+0x164>
 d023b14:	00001706 	br	d023b74 <bsd_i_sockoptlen+0x1a0>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 d023b18:	e03ffe15 	stw	zero,-8(fp)
 d023b1c:	00001606 	br	d023b78 <bsd_i_sockoptlen+0x1a4>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 d023b20:	00800204 	movi	r2,8
 d023b24:	e0bffe15 	stw	r2,-8(fp)
 d023b28:	00001306 	br	d023b78 <bsd_i_sockoptlen+0x1a4>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 d023b2c:	00c00084 	movi	r3,2
 d023b30:	e0fffe15 	stw	r3,-8(fp)
 d023b34:	00001006 	br	d023b78 <bsd_i_sockoptlen+0x1a4>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 d023b38:	00800104 	movi	r2,4
 d023b3c:	e0bffe15 	stw	r2,-8(fp)
 d023b40:	00000d06 	br	d023b78 <bsd_i_sockoptlen+0x1a4>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 d023b44:	00c00104 	movi	r3,4
 d023b48:	e0fffe15 	stw	r3,-8(fp)
 d023b4c:	00000a06 	br	d023b78 <bsd_i_sockoptlen+0x1a4>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 d023b50:	00800044 	movi	r2,1
 d023b54:	e0bffe15 	stw	r2,-8(fp)
 d023b58:	00000706 	br	d023b78 <bsd_i_sockoptlen+0x1a4>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 d023b5c:	00c00204 	movi	r3,8
 d023b60:	e0fffe15 	stw	r3,-8(fp)
 d023b64:	00000406 	br	d023b78 <bsd_i_sockoptlen+0x1a4>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 d023b68:	00800104 	movi	r2,4
 d023b6c:	e0bffe15 	stw	r2,-8(fp)
 d023b70:	00000106 	br	d023b78 <bsd_i_sockoptlen+0x1a4>
   default:
      /* we don't know what type these options are */
      return 0;
 d023b74:	e03ffe15 	stw	zero,-8(fp)
 d023b78:	e0bffe17 	ldw	r2,-8(fp)
   }
   
}
 d023b7c:	e037883a 	mov	sp,fp
 d023b80:	df000017 	ldw	fp,0(sp)
 d023b84:	dec00104 	addi	sp,sp,4
 d023b88:	f800283a 	ret

0d023b8c <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 d023b8c:	defff404 	addi	sp,sp,-48
 d023b90:	dfc00b15 	stw	ra,44(sp)
 d023b94:	df000a15 	stw	fp,40(sp)
 d023b98:	df000a04 	addi	fp,sp,40
 d023b9c:	e13ffb15 	stw	r4,-20(fp)
 d023ba0:	e17ffc15 	stw	r5,-16(fp)
 d023ba4:	e1bffd15 	stw	r6,-12(fp)
 d023ba8:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 d023bac:	e0bffb17 	ldw	r2,-20(fp)
 d023bb0:	10bff804 	addi	r2,r2,-32
 d023bb4:	1085883a 	add	r2,r2,r2
 d023bb8:	1085883a 	add	r2,r2,r2
 d023bbc:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d023bc0:	008341b4 	movhi	r2,3334
 d023bc4:	10b3e204 	addi	r2,r2,-12408
 d023bc8:	e0bff715 	stw	r2,-36(fp)
 d023bcc:	00000606 	br	d023be8 <bsd_getsockopt+0x5c>
 d023bd0:	e0fff717 	ldw	r3,-36(fp)
 d023bd4:	e0bffa17 	ldw	r2,-24(fp)
 d023bd8:	18800626 	beq	r3,r2,d023bf4 <bsd_getsockopt+0x68>
 d023bdc:	e0bff717 	ldw	r2,-36(fp)
 d023be0:	10800017 	ldw	r2,0(r2)
 d023be4:	e0bff715 	stw	r2,-36(fp)
 d023be8:	e0bff717 	ldw	r2,-36(fp)
 d023bec:	1004c03a 	cmpne	r2,r2,zero
 d023bf0:	103ff71e 	bne	r2,zero,d023bd0 <bsd_getsockopt+0x44>
 d023bf4:	e0fff717 	ldw	r3,-36(fp)
 d023bf8:	e0bffa17 	ldw	r2,-24(fp)
 d023bfc:	18800426 	beq	r3,r2,d023c10 <bsd_getsockopt+0x84>
 d023c00:	d0293e80 	call	d0293e8 <dtrap>
 d023c04:	00bfffc4 	movi	r2,-1
 d023c08:	e0bfff15 	stw	r2,-4(fp)
 d023c0c:	00002106 	br	d023c94 <bsd_getsockopt+0x108>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 d023c10:	e13ffc17 	ldw	r4,-16(fp)
 d023c14:	e17ffd17 	ldw	r5,-12(fp)
 d023c18:	d0239d40 	call	d0239d4 <bsd_i_sockoptlen>
 d023c1c:	e0bff915 	stw	r2,-28(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 d023c20:	e0800217 	ldw	r2,8(fp)
 d023c24:	1005003a 	cmpeq	r2,r2,zero
 d023c28:	1000041e 	bne	r2,zero,d023c3c <bsd_getsockopt+0xb0>
 d023c2c:	e0800217 	ldw	r2,8(fp)
 d023c30:	10c00017 	ldw	r3,0(r2)
 d023c34:	e0bff917 	ldw	r2,-28(fp)
 d023c38:	1880060e 	bge	r3,r2,d023c54 <bsd_getsockopt+0xc8>
   {
      so->so_error = EFAULT;
 d023c3c:	e0fffa17 	ldw	r3,-24(fp)
 d023c40:	00800384 	movi	r2,14
 d023c44:	18800615 	stw	r2,24(r3)
      return -1;
 d023c48:	00bfffc4 	movi	r2,-1
 d023c4c:	e0bfff15 	stw	r2,-4(fp)
 d023c50:	00001006 	br	d023c94 <bsd_getsockopt+0x108>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 d023c54:	e0bff917 	ldw	r2,-28(fp)
 d023c58:	d8800015 	stw	r2,0(sp)
 d023c5c:	e13ffb17 	ldw	r4,-20(fp)
 d023c60:	e17ffc17 	ldw	r5,-16(fp)
 d023c64:	e1bffd17 	ldw	r6,-12(fp)
 d023c68:	e1fffe17 	ldw	r7,-8(fp)
 d023c6c:	d02d0fc0 	call	d02d0fc <t_getsockopt>
 d023c70:	e0bff815 	stw	r2,-32(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 d023c74:	e0bff817 	ldw	r2,-32(fp)
 d023c78:	1004c03a 	cmpne	r2,r2,zero
 d023c7c:	1000031e 	bne	r2,zero,d023c8c <bsd_getsockopt+0x100>
   {
      *optlen = loptlen;
 d023c80:	e0c00217 	ldw	r3,8(fp)
 d023c84:	e0bff917 	ldw	r2,-28(fp)
 d023c88:	18800015 	stw	r2,0(r3)
   }

   return e;
 d023c8c:	e0bff817 	ldw	r2,-32(fp)
 d023c90:	e0bfff15 	stw	r2,-4(fp)
 d023c94:	e0bfff17 	ldw	r2,-4(fp)
   
}
 d023c98:	e037883a 	mov	sp,fp
 d023c9c:	dfc00117 	ldw	ra,4(sp)
 d023ca0:	df000017 	ldw	fp,0(sp)
 d023ca4:	dec00204 	addi	sp,sp,8
 d023ca8:	f800283a 	ret

0d023cac <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 d023cac:	defff404 	addi	sp,sp,-48
 d023cb0:	dfc00915 	stw	ra,36(sp)
 d023cb4:	df000815 	stw	fp,32(sp)
 d023cb8:	df000804 	addi	fp,sp,32
 d023cbc:	e13ffd15 	stw	r4,-12(fp)
 d023cc0:	e1800215 	stw	r6,8(fp)
 d023cc4:	e1c00315 	stw	r7,12(fp)
 d023cc8:	e17ffe15 	stw	r5,-8(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 d023ccc:	e0bffd17 	ldw	r2,-12(fp)
 d023cd0:	10bff804 	addi	r2,r2,-32
 d023cd4:	1085883a 	add	r2,r2,r2
 d023cd8:	1085883a 	add	r2,r2,r2
 d023cdc:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d023ce0:	008341b4 	movhi	r2,3334
 d023ce4:	10b3e204 	addi	r2,r2,-12408
 d023ce8:	e0bff915 	stw	r2,-28(fp)
 d023cec:	00000606 	br	d023d08 <bsd_ioctl+0x5c>
 d023cf0:	e0fff917 	ldw	r3,-28(fp)
 d023cf4:	e0bffa17 	ldw	r2,-24(fp)
 d023cf8:	18800626 	beq	r3,r2,d023d14 <bsd_ioctl+0x68>
 d023cfc:	e0bff917 	ldw	r2,-28(fp)
 d023d00:	10800017 	ldw	r2,0(r2)
 d023d04:	e0bff915 	stw	r2,-28(fp)
 d023d08:	e0bff917 	ldw	r2,-28(fp)
 d023d0c:	1004c03a 	cmpne	r2,r2,zero
 d023d10:	103ff71e 	bne	r2,zero,d023cf0 <bsd_ioctl+0x44>
 d023d14:	e0fff917 	ldw	r3,-28(fp)
 d023d18:	e0bffa17 	ldw	r2,-24(fp)
 d023d1c:	18800426 	beq	r3,r2,d023d30 <bsd_ioctl+0x84>
 d023d20:	d0293e80 	call	d0293e8 <dtrap>
 d023d24:	00bfffc4 	movi	r2,-1
 d023d28:	e0bfff15 	stw	r2,-4(fp)
 d023d2c:	00001a06 	br	d023d98 <bsd_ioctl+0xec>

   va_start(argptr, request);
 d023d30:	e0800204 	addi	r2,fp,8
 d023d34:	e0bffb15 	stw	r2,-20(fp)

   switch (request)
 d023d38:	e0bffe17 	ldw	r2,-8(fp)
 d023d3c:	108405a0 	cmpeqi	r2,r2,4118
 d023d40:	1000011e 	bne	r2,zero,d023d48 <bsd_ioctl+0x9c>
 d023d44:	00000f06 	br	d023d84 <bsd_ioctl+0xd8>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 d023d48:	e0fffb17 	ldw	r3,-20(fp)
 d023d4c:	18800104 	addi	r2,r3,4
 d023d50:	e0bffb15 	stw	r2,-20(fp)
 d023d54:	1805883a 	mov	r2,r3
 d023d58:	10800017 	ldw	r2,0(r2)
 d023d5c:	e0bffc15 	stw	r2,-16(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 d023d60:	e1fffc04 	addi	r7,fp,-16
 d023d64:	00800104 	movi	r2,4
 d023d68:	d8800015 	stw	r2,0(sp)
 d023d6c:	e13ffd17 	ldw	r4,-12(fp)
 d023d70:	017fffc4 	movi	r5,-1
 d023d74:	01840584 	movi	r6,4118
 d023d78:	d02cf200 	call	d02cf20 <t_setsockopt>
 d023d7c:	e0bfff15 	stw	r2,-4(fp)
 d023d80:	00000506 	br	d023d98 <bsd_ioctl+0xec>
   default:
      so->so_error = EINVAL;
 d023d84:	e0fffa17 	ldw	r3,-24(fp)
 d023d88:	00800584 	movi	r2,22
 d023d8c:	18800615 	stw	r2,24(r3)
      return -1;
 d023d90:	00bfffc4 	movi	r2,-1
 d023d94:	e0bfff15 	stw	r2,-4(fp)
 d023d98:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d023d9c:	e037883a 	mov	sp,fp
 d023da0:	dfc00117 	ldw	ra,4(sp)
 d023da4:	df000017 	ldw	fp,0(sp)
 d023da8:	dec00404 	addi	sp,sp,16
 d023dac:	f800283a 	ret

0d023db0 <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 d023db0:	defffd04 	addi	sp,sp,-12
 d023db4:	dfc00215 	stw	ra,8(sp)
 d023db8:	df000115 	stw	fp,4(sp)
 d023dbc:	df000104 	addi	fp,sp,4
 d023dc0:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 d023dc4:	e13fff17 	ldw	r4,-4(fp)
 d023dc8:	d02448c0 	call	d02448c <print_ipad>
}
 d023dcc:	e037883a 	mov	sp,fp
 d023dd0:	dfc00117 	ldw	ra,4(sp)
 d023dd4:	df000017 	ldw	fp,0(sp)
 d023dd8:	dec00204 	addi	sp,sp,8
 d023ddc:	f800283a 	ret

0d023de0 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 d023de0:	deffef04 	addi	sp,sp,-68
 d023de4:	dfc01015 	stw	ra,64(sp)
 d023de8:	df000f15 	stw	fp,60(sp)
 d023dec:	df000f04 	addi	fp,sp,60
 d023df0:	e13ffb15 	stw	r4,-20(fp)
 d023df4:	e17ffc15 	stw	r5,-16(fp)
 d023df8:	e1bffd15 	stw	r6,-12(fp)
 d023dfc:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 d023e00:	e03ffa15 	stw	zero,-24(fp)
   int lret;

   so = LONG2SO(s);
 d023e04:	e0bffb17 	ldw	r2,-20(fp)
 d023e08:	10bff804 	addi	r2,r2,-32
 d023e0c:	1085883a 	add	r2,r2,r2
 d023e10:	1085883a 	add	r2,r2,r2
 d023e14:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 d023e18:	008341b4 	movhi	r2,3334
 d023e1c:	10b3e204 	addi	r2,r2,-12408
 d023e20:	e0bff315 	stw	r2,-52(fp)
 d023e24:	00000606 	br	d023e40 <bsd_recvfrom+0x60>
 d023e28:	e0fff317 	ldw	r3,-52(fp)
 d023e2c:	e0bff517 	ldw	r2,-44(fp)
 d023e30:	18800626 	beq	r3,r2,d023e4c <bsd_recvfrom+0x6c>
 d023e34:	e0bff317 	ldw	r2,-52(fp)
 d023e38:	10800017 	ldw	r2,0(r2)
 d023e3c:	e0bff315 	stw	r2,-52(fp)
 d023e40:	e0bff317 	ldw	r2,-52(fp)
 d023e44:	1004c03a 	cmpne	r2,r2,zero
 d023e48:	103ff71e 	bne	r2,zero,d023e28 <bsd_recvfrom+0x48>
 d023e4c:	e0fff317 	ldw	r3,-52(fp)
 d023e50:	e0bff517 	ldw	r2,-44(fp)
 d023e54:	18800426 	beq	r3,r2,d023e68 <bsd_recvfrom+0x88>
 d023e58:	d0293e80 	call	d0293e8 <dtrap>
 d023e5c:	00bfffc4 	movi	r2,-1
 d023e60:	e0bfff15 	stw	r2,-4(fp)
 d023e64:	00003006 	br	d023f28 <bsd_recvfrom+0x148>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 d023e68:	e0800217 	ldw	r2,8(fp)
 d023e6c:	1005003a 	cmpeq	r2,r2,zero
 d023e70:	10000c1e 	bne	r2,zero,d023ea4 <bsd_recvfrom+0xc4>
   {
      if (fromlen == NULL)
 d023e74:	e0800317 	ldw	r2,12(fp)
 d023e78:	1004c03a 	cmpne	r2,r2,zero
 d023e7c:	1000061e 	bne	r2,zero,d023e98 <bsd_recvfrom+0xb8>
      {
         so->so_error = EFAULT;
 d023e80:	e0fff517 	ldw	r3,-44(fp)
 d023e84:	00800384 	movi	r2,14
 d023e88:	18800615 	stw	r2,24(r3)
         return -1;
 d023e8c:	00bfffc4 	movi	r2,-1
 d023e90:	e0bfff15 	stw	r2,-4(fp)
 d023e94:	00002406 	br	d023f28 <bsd_recvfrom+0x148>
      }
      lfromlen = *fromlen;
 d023e98:	e0800317 	ldw	r2,12(fp)
 d023e9c:	10800017 	ldw	r2,0(r2)
 d023ea0:	e0bffa15 	stw	r2,-24(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 d023ea4:	e17ffc17 	ldw	r5,-16(fp)
 d023ea8:	e0bff604 	addi	r2,fp,-40
 d023eac:	d8800015 	stw	r2,0(sp)
 d023eb0:	e0bffa04 	addi	r2,fp,-24
 d023eb4:	d8800115 	stw	r2,4(sp)
 d023eb8:	e13ffb17 	ldw	r4,-20(fp)
 d023ebc:	e1bffd17 	ldw	r6,-12(fp)
 d023ec0:	e1fffe17 	ldw	r7,-8(fp)
 d023ec4:	d02d3900 	call	d02d390 <t_recvfrom>
 d023ec8:	e0bff415 	stw	r2,-48(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 d023ecc:	e0bff417 	ldw	r2,-48(fp)
 d023ed0:	10bfffe0 	cmpeqi	r2,r2,-1
 d023ed4:	1000121e 	bne	r2,zero,d023f20 <bsd_recvfrom+0x140>
 d023ed8:	e0800217 	ldw	r2,8(fp)
 d023edc:	1005003a 	cmpeq	r2,r2,zero
 d023ee0:	10000f1e 	bne	r2,zero,d023f20 <bsd_recvfrom+0x140>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 d023ee4:	e0bffa17 	ldw	r2,-24(fp)
 d023ee8:	10800470 	cmpltui	r2,r2,17
 d023eec:	1000021e 	bne	r2,zero,d023ef8 <bsd_recvfrom+0x118>
         lfromlen = sizeof(struct sockaddr_in);
 d023ef0:	00800404 	movi	r2,16
 d023ef4:	e0bffa15 	stw	r2,-24(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 d023ef8:	e0bffa17 	ldw	r2,-24(fp)
 d023efc:	100d883a 	mov	r6,r2
 d023f00:	e0800217 	ldw	r2,8(fp)
 d023f04:	e0fff604 	addi	r3,fp,-40
 d023f08:	1009883a 	mov	r4,r2
 d023f0c:	180b883a 	mov	r5,r3
 d023f10:	d0027000 	call	d002700 <memcpy>
      *fromlen = lfromlen;
 d023f14:	e0fffa17 	ldw	r3,-24(fp)
 d023f18:	e0800317 	ldw	r2,12(fp)
 d023f1c:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 d023f20:	e0bff417 	ldw	r2,-48(fp)
 d023f24:	e0bfff15 	stw	r2,-4(fp)
 d023f28:	e0bfff17 	ldw	r2,-4(fp)
}
 d023f2c:	e037883a 	mov	sp,fp
 d023f30:	dfc00117 	ldw	ra,4(sp)
 d023f34:	df000017 	ldw	fp,0(sp)
 d023f38:	dec00204 	addi	sp,sp,8
 d023f3c:	f800283a 	ret

0d023f40 <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 d023f40:	defff804 	addi	sp,sp,-32
 d023f44:	dfc00715 	stw	ra,28(sp)
 d023f48:	df000615 	stw	fp,24(sp)
 d023f4c:	df000604 	addi	fp,sp,24
 d023f50:	e13ffc15 	stw	r4,-16(fp)
 d023f54:	e17ffd15 	stw	r5,-12(fp)
 d023f58:	e1bffe15 	stw	r6,-8(fp)
 d023f5c:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 d023f60:	e0800217 	ldw	r2,8(fp)
 d023f64:	1005003a 	cmpeq	r2,r2,zero
 d023f68:	10003f1e 	bne	r2,zero,d024068 <bsd_select+0x128>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 d023f6c:	00801904 	movi	r2,100
 d023f70:	e0bffa15 	stw	r2,-24(fp)
      if (tps >= 1000)
 d023f74:	e0bffa17 	ldw	r2,-24(fp)
 d023f78:	1080fa10 	cmplti	r2,r2,1000
 d023f7c:	10000b1e 	bne	r2,zero,d023fac <bsd_select+0x6c>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 d023f80:	e0800217 	ldw	r2,8(fp)
 d023f84:	10800117 	ldw	r2,4(r2)
 d023f88:	10c00c84 	addi	r3,r2,50
 d023f8c:	00801904 	movi	r2,100
 d023f90:	1887283a 	div	r3,r3,r2
 d023f94:	e0bffa17 	ldw	r2,-24(fp)
 d023f98:	1887383a 	mul	r3,r3,r2
 d023f9c:	0089c404 	movi	r2,10000
 d023fa0:	1885283a 	div	r2,r3,r2
 d023fa4:	e0bffb15 	stw	r2,-20(fp)
 d023fa8:	00002806 	br	d02404c <bsd_select+0x10c>
      }
      else if (tps >= 100)
 d023fac:	e0bffa17 	ldw	r2,-24(fp)
 d023fb0:	10801910 	cmplti	r2,r2,100
 d023fb4:	10000b1e 	bne	r2,zero,d023fe4 <bsd_select+0xa4>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 d023fb8:	e0800217 	ldw	r2,8(fp)
 d023fbc:	10800117 	ldw	r2,4(r2)
 d023fc0:	10c07d04 	addi	r3,r2,500
 d023fc4:	0080fa04 	movi	r2,1000
 d023fc8:	1887283a 	div	r3,r3,r2
 d023fcc:	e0bffa17 	ldw	r2,-24(fp)
 d023fd0:	1887383a 	mul	r3,r3,r2
 d023fd4:	0080fa04 	movi	r2,1000
 d023fd8:	1885283a 	div	r2,r3,r2
 d023fdc:	e0bffb15 	stw	r2,-20(fp)
 d023fe0:	00001a06 	br	d02404c <bsd_select+0x10c>
      }
      else if (tps >= 10)
 d023fe4:	e0bffa17 	ldw	r2,-24(fp)
 d023fe8:	10800290 	cmplti	r2,r2,10
 d023fec:	10000b1e 	bne	r2,zero,d02401c <bsd_select+0xdc>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 d023ff0:	e0800217 	ldw	r2,8(fp)
 d023ff4:	10800117 	ldw	r2,4(r2)
 d023ff8:	10c4e204 	addi	r3,r2,5000
 d023ffc:	0089c404 	movi	r2,10000
 d024000:	1887283a 	div	r3,r3,r2
 d024004:	e0bffa17 	ldw	r2,-24(fp)
 d024008:	1887383a 	mul	r3,r3,r2
 d02400c:	00801904 	movi	r2,100
 d024010:	1885283a 	div	r2,r3,r2
 d024014:	e0bffb15 	stw	r2,-20(fp)
 d024018:	00000c06 	br	d02404c <bsd_select+0x10c>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 d02401c:	e0800217 	ldw	r2,8(fp)
 d024020:	10c00117 	ldw	r3,4(r2)
 d024024:	00b0d414 	movui	r2,50000
 d024028:	1887883a 	add	r3,r3,r2
 d02402c:	008000b4 	movhi	r2,2
 d024030:	10a1a804 	addi	r2,r2,-31072
 d024034:	1887283a 	div	r3,r3,r2
 d024038:	e0bffa17 	ldw	r2,-24(fp)
 d02403c:	1887383a 	mul	r3,r3,r2
 d024040:	00800284 	movi	r2,10
 d024044:	1885283a 	div	r2,r3,r2
 d024048:	e0bffb15 	stw	r2,-20(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 d02404c:	e0800217 	ldw	r2,8(fp)
 d024050:	10800017 	ldw	r2,0(r2)
 d024054:	10c01924 	muli	r3,r2,100
 d024058:	e0bffb17 	ldw	r2,-20(fp)
 d02405c:	1885883a 	add	r2,r3,r2
 d024060:	e0bffb15 	stw	r2,-20(fp)
 d024064:	00000206 	br	d024070 <bsd_select+0x130>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 d024068:	00bfffc4 	movi	r2,-1
 d02406c:	e0bffb15 	stw	r2,-20(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 d024070:	e13ffd17 	ldw	r4,-12(fp)
 d024074:	e17ffe17 	ldw	r5,-8(fp)
 d024078:	e1bfff17 	ldw	r6,-4(fp)
 d02407c:	e1fffb17 	ldw	r7,-20(fp)
 d024080:	d0312a80 	call	d0312a8 <t_select>
}
 d024084:	e037883a 	mov	sp,fp
 d024088:	dfc00117 	ldw	ra,4(sp)
 d02408c:	df000017 	ldw	fp,0(sp)
 d024090:	dec00204 	addi	sp,sp,8
 d024094:	f800283a 	ret

0d024098 <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 d024098:	defff604 	addi	sp,sp,-40
 d02409c:	dfc00915 	stw	ra,36(sp)
 d0240a0:	df000815 	stw	fp,32(sp)
 d0240a4:	df000804 	addi	fp,sp,32
 d0240a8:	e13ffb15 	stw	r4,-20(fp)
 d0240ac:	e17ffc15 	stw	r5,-16(fp)
 d0240b0:	e1bffd15 	stw	r6,-12(fp)
 d0240b4:	e1fffe15 	stw	r7,-8(fp)
   struct socket * so;

   so = LONG2SO(s);
 d0240b8:	e0bffb17 	ldw	r2,-20(fp)
 d0240bc:	10bff804 	addi	r2,r2,-32
 d0240c0:	1085883a 	add	r2,r2,r2
 d0240c4:	1085883a 	add	r2,r2,r2
 d0240c8:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d0240cc:	008341b4 	movhi	r2,3334
 d0240d0:	10b3e204 	addi	r2,r2,-12408
 d0240d4:	e0bff915 	stw	r2,-28(fp)
 d0240d8:	00000606 	br	d0240f4 <bsd_setsockopt+0x5c>
 d0240dc:	e0fff917 	ldw	r3,-28(fp)
 d0240e0:	e0bffa17 	ldw	r2,-24(fp)
 d0240e4:	18800626 	beq	r3,r2,d024100 <bsd_setsockopt+0x68>
 d0240e8:	e0bff917 	ldw	r2,-28(fp)
 d0240ec:	10800017 	ldw	r2,0(r2)
 d0240f0:	e0bff915 	stw	r2,-28(fp)
 d0240f4:	e0bff917 	ldw	r2,-28(fp)
 d0240f8:	1004c03a 	cmpne	r2,r2,zero
 d0240fc:	103ff71e 	bne	r2,zero,d0240dc <bsd_setsockopt+0x44>
 d024100:	e0fff917 	ldw	r3,-28(fp)
 d024104:	e0bffa17 	ldw	r2,-24(fp)
 d024108:	18800426 	beq	r3,r2,d02411c <bsd_setsockopt+0x84>
 d02410c:	d0293e80 	call	d0293e8 <dtrap>
 d024110:	00bfffc4 	movi	r2,-1
 d024114:	e0bfff15 	stw	r2,-4(fp)
 d024118:	00001406 	br	d02416c <bsd_setsockopt+0xd4>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 d02411c:	e13ffc17 	ldw	r4,-16(fp)
 d024120:	e17ffd17 	ldw	r5,-12(fp)
 d024124:	d0239d40 	call	d0239d4 <bsd_i_sockoptlen>
 d024128:	1007883a 	mov	r3,r2
 d02412c:	e0800217 	ldw	r2,8(fp)
 d024130:	10c0060e 	bge	r2,r3,d02414c <bsd_setsockopt+0xb4>
   {
      so->so_error = EFAULT;
 d024134:	e0fffa17 	ldw	r3,-24(fp)
 d024138:	00800384 	movi	r2,14
 d02413c:	18800615 	stw	r2,24(r3)
      return -1;
 d024140:	00bfffc4 	movi	r2,-1
 d024144:	e0bfff15 	stw	r2,-4(fp)
 d024148:	00000806 	br	d02416c <bsd_setsockopt+0xd4>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 d02414c:	e0800217 	ldw	r2,8(fp)
 d024150:	d8800015 	stw	r2,0(sp)
 d024154:	e13ffb17 	ldw	r4,-20(fp)
 d024158:	e17ffc17 	ldw	r5,-16(fp)
 d02415c:	e1bffd17 	ldw	r6,-12(fp)
 d024160:	e1fffe17 	ldw	r7,-8(fp)
 d024164:	d02cf200 	call	d02cf20 <t_setsockopt>
 d024168:	e0bfff15 	stw	r2,-4(fp)
 d02416c:	e0bfff17 	ldw	r2,-4(fp)
}
 d024170:	e037883a 	mov	sp,fp
 d024174:	dfc00117 	ldw	ra,4(sp)
 d024178:	df000017 	ldw	fp,0(sp)
 d02417c:	dec00204 	addi	sp,sp,8
 d024180:	f800283a 	ret

0d024184 <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 d024184:	defffa04 	addi	sp,sp,-24
 d024188:	df000515 	stw	fp,20(sp)
 d02418c:	df000504 	addi	fp,sp,20
 d024190:	e13ffe15 	stw	r4,-8(fp)
 d024194:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 d024198:	e0bffe17 	ldw	r2,-8(fp)
 d02419c:	e0bffd15 	stw	r2,-12(fp)
   unsigned long sum = 0;
 d0241a0:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 d0241a4:	e0bfff17 	ldw	r2,-4(fp)
 d0241a8:	e0bffb15 	stw	r2,-20(fp)

   while (--count >= 0)
 d0241ac:	00000906 	br	d0241d4 <ccksum+0x50>
   {
      /*  This is the inner loop */
      sum += *addr++;
 d0241b0:	e0bffd17 	ldw	r2,-12(fp)
 d0241b4:	1080000b 	ldhu	r2,0(r2)
 d0241b8:	10ffffcc 	andi	r3,r2,65535
 d0241bc:	e0bffc17 	ldw	r2,-16(fp)
 d0241c0:	10c5883a 	add	r2,r2,r3
 d0241c4:	e0bffc15 	stw	r2,-16(fp)
 d0241c8:	e0bffd17 	ldw	r2,-12(fp)
 d0241cc:	10800084 	addi	r2,r2,2
 d0241d0:	e0bffd15 	stw	r2,-12(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 d0241d4:	e0bffb17 	ldw	r2,-20(fp)
 d0241d8:	10bfffc4 	addi	r2,r2,-1
 d0241dc:	e0bffb15 	stw	r2,-20(fp)
 d0241e0:	e0bffb17 	ldw	r2,-20(fp)
 d0241e4:	1004403a 	cmpge	r2,r2,zero
 d0241e8:	103ff11e 	bne	r2,zero,d0241b0 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 d0241ec:	e0bffc17 	ldw	r2,-16(fp)
 d0241f0:	10ffffcc 	andi	r3,r2,65535
 d0241f4:	e0bffc17 	ldw	r2,-16(fp)
 d0241f8:	1004d43a 	srli	r2,r2,16
 d0241fc:	1885883a 	add	r2,r3,r2
 d024200:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 d024204:	e0bffc17 	ldw	r2,-16(fp)
 d024208:	10ffffcc 	andi	r3,r2,65535
 d02420c:	e0bffc17 	ldw	r2,-16(fp)
 d024210:	1004d43a 	srli	r2,r2,16
 d024214:	1885883a 	add	r2,r3,r2
 d024218:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 d02421c:	e0bffc17 	ldw	r2,-16(fp)
 d024220:	10bfffcc 	andi	r2,r2,65535
}
 d024224:	e037883a 	mov	sp,fp
 d024228:	df000017 	ldw	fp,0(sp)
 d02422c:	dec00104 	addi	sp,sp,4
 d024230:	f800283a 	ret

0d024234 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 d024234:	defffb04 	addi	sp,sp,-20
 d024238:	dfc00415 	stw	ra,16(sp)
 d02423c:	df000315 	stw	fp,12(sp)
 d024240:	df000304 	addi	fp,sp,12
 d024244:	e13ffd15 	stw	r4,-12(fp)
 d024248:	e17ffe15 	stw	r5,-8(fp)
   switch (cksum_select)
 d02424c:	d0a03117 	ldw	r2,-32572(gp)
 d024250:	108000a0 	cmpeqi	r2,r2,2
 d024254:	1000061e 	bne	r2,zero,d024270 <cksum+0x3c>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 d024258:	e13ffd17 	ldw	r4,-12(fp)
 d02425c:	e17ffe17 	ldw	r5,-8(fp)
 d024260:	d0241840 	call	d024184 <ccksum>
 d024264:	10bfffcc 	andi	r2,r2,65535
 d024268:	e0bfff15 	stw	r2,-4(fp)
 d02426c:	00000506 	br	d024284 <cksum+0x50>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 d024270:	e13ffd17 	ldw	r4,-12(fp)
 d024274:	e17ffe17 	ldw	r5,-8(fp)
 d024278:	d0292540 	call	d029254 <asm_cksum>
 d02427c:	10bfffcc 	andi	r2,r2,65535
 d024280:	e0bfff15 	stw	r2,-4(fp)
 d024284:	e0bfff17 	ldw	r2,-4(fp)
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 d024288:	e037883a 	mov	sp,fp
 d02428c:	dfc00117 	ldw	ra,4(sp)
 d024290:	df000017 	ldw	fp,0(sp)
 d024294:	dec00204 	addi	sp,sp,8
 d024298:	f800283a 	ret

0d02429c <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 d02429c:	defffe04 	addi	sp,sp,-8
 d0242a0:	dfc00115 	stw	ra,4(sp)
 d0242a4:	df000015 	stw	fp,0(sp)
 d0242a8:	d839883a 	mov	fp,sp
   dtrap();
 d0242ac:	d0293e80 	call	d0293e8 <dtrap>
   return 0;
 d0242b0:	0005883a 	mov	r2,zero
}
 d0242b4:	e037883a 	mov	sp,fp
 d0242b8:	dfc00117 	ldw	ra,4(sp)
 d0242bc:	df000017 	ldw	fp,0(sp)
 d0242c0:	dec00204 	addi	sp,sp,8
 d0242c4:	f800283a 	ret

0d0242c8 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 d0242c8:	defffe04 	addi	sp,sp,-8
 d0242cc:	df000115 	stw	fp,4(sp)
 d0242d0:	df000104 	addi	fp,sp,4
 d0242d4:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 d0242d8:	00000306 	br	d0242e8 <nextarg+0x20>
 d0242dc:	e0bfff17 	ldw	r2,-4(fp)
 d0242e0:	10800044 	addi	r2,r2,1
 d0242e4:	e0bfff15 	stw	r2,-4(fp)
 d0242e8:	e0bfff17 	ldw	r2,-4(fp)
 d0242ec:	10800003 	ldbu	r2,0(r2)
 d0242f0:	10803fcc 	andi	r2,r2,255
 d0242f4:	1080201c 	xori	r2,r2,128
 d0242f8:	10bfe004 	addi	r2,r2,-128
 d0242fc:	10800848 	cmpgei	r2,r2,33
 d024300:	103ff61e 	bne	r2,zero,d0242dc <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 d024304:	00000306 	br	d024314 <nextarg+0x4c>
 d024308:	e0bfff17 	ldw	r2,-4(fp)
 d02430c:	10800044 	addi	r2,r2,1
 d024310:	e0bfff15 	stw	r2,-4(fp)
 d024314:	e0bfff17 	ldw	r2,-4(fp)
 d024318:	10800003 	ldbu	r2,0(r2)
 d02431c:	10803fcc 	andi	r2,r2,255
 d024320:	1080201c 	xori	r2,r2,128
 d024324:	10bfe004 	addi	r2,r2,-128
 d024328:	10800820 	cmpeqi	r2,r2,32
 d02432c:	103ff61e 	bne	r2,zero,d024308 <nextarg+0x40>
      return (argp);
 d024330:	e0bfff17 	ldw	r2,-4(fp)
}
 d024334:	e037883a 	mov	sp,fp
 d024338:	df000017 	ldw	fp,0(sp)
 d02433c:	dec00104 	addi	sp,sp,4
 d024340:	f800283a 	ret

0d024344 <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 d024344:	defff704 	addi	sp,sp,-36
 d024348:	dfc00815 	stw	ra,32(sp)
 d02434c:	df000715 	stw	fp,28(sp)
 d024350:	df000704 	addi	fp,sp,28
 d024354:	e13ffc15 	stw	r4,-16(fp)
 d024358:	e17ffd15 	stw	r5,-12(fp)
 d02435c:	e1bffe15 	stw	r6,-8(fp)
   u_char * data  =  (u_char *)buffer;
 d024360:	e0bffd17 	ldw	r2,-12(fp)
 d024364:	e0bffb15 	stw	r2,-20(fp)
   unsigned int count;
   char  c;

   while (len)
 d024368:	00004006 	br	d02446c <hexdump+0x128>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 d02436c:	e03ffa15 	stw	zero,-24(fp)
 d024370:	00000c06 	br	d0243a4 <hexdump+0x60>
         ns_printf(pio, "%02x ", *(data + count));
 d024374:	e0fffa17 	ldw	r3,-24(fp)
 d024378:	e0bffb17 	ldw	r2,-20(fp)
 d02437c:	1885883a 	add	r2,r3,r2
 d024380:	10800003 	ldbu	r2,0(r2)
 d024384:	11803fcc 	andi	r6,r2,255
 d024388:	e13ffc17 	ldw	r4,-16(fp)
 d02438c:	01434174 	movhi	r5,3333
 d024390:	297be404 	addi	r5,r5,-4208
 d024394:	d02486c0 	call	d02486c <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 d024398:	e0bffa17 	ldw	r2,-24(fp)
 d02439c:	10800044 	addi	r2,r2,1
 d0243a0:	e0bffa15 	stw	r2,-24(fp)
 d0243a4:	e0bffa17 	ldw	r2,-24(fp)
 d0243a8:	10800428 	cmpgeui	r2,r2,16
 d0243ac:	1000031e 	bne	r2,zero,d0243bc <hexdump+0x78>
 d0243b0:	e0fffa17 	ldw	r3,-24(fp)
 d0243b4:	e0bffe17 	ldw	r2,-8(fp)
 d0243b8:	18bfee36 	bltu	r3,r2,d024374 <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 d0243bc:	e03ffa15 	stw	zero,-24(fp)
 d0243c0:	00001806 	br	d024424 <hexdump+0xe0>
      {
         c = *(data + count);
 d0243c4:	e0fffa17 	ldw	r3,-24(fp)
 d0243c8:	e0bffb17 	ldw	r2,-20(fp)
 d0243cc:	1885883a 	add	r2,r3,r2
 d0243d0:	10800003 	ldbu	r2,0(r2)
 d0243d4:	e0bff905 	stb	r2,-28(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 d0243d8:	e0bff907 	ldb	r2,-28(fp)
 d0243dc:	10800810 	cmplti	r2,r2,32
 d0243e0:	1000061e 	bne	r2,zero,d0243fc <hexdump+0xb8>
 d0243e4:	e0bff907 	ldb	r2,-28(fp)
 d0243e8:	10801fe0 	cmpeqi	r2,r2,127
 d0243ec:	1000031e 	bne	r2,zero,d0243fc <hexdump+0xb8>
 d0243f0:	e0bff907 	ldb	r2,-28(fp)
 d0243f4:	e0bfff15 	stw	r2,-4(fp)
 d0243f8:	00000206 	br	d024404 <hexdump+0xc0>
 d0243fc:	00800b84 	movi	r2,46
 d024400:	e0bfff15 	stw	r2,-4(fp)
 d024404:	e13ffc17 	ldw	r4,-16(fp)
 d024408:	01434174 	movhi	r5,3333
 d02440c:	297be604 	addi	r5,r5,-4200
 d024410:	e1bfff17 	ldw	r6,-4(fp)
 d024414:	d02486c0 	call	d02486c <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 d024418:	e0bffa17 	ldw	r2,-24(fp)
 d02441c:	10800044 	addi	r2,r2,1
 d024420:	e0bffa15 	stw	r2,-24(fp)
 d024424:	e0bffa17 	ldw	r2,-24(fp)
 d024428:	10800428 	cmpgeui	r2,r2,16
 d02442c:	1000031e 	bne	r2,zero,d02443c <hexdump+0xf8>
 d024430:	e0fffa17 	ldw	r3,-24(fp)
 d024434:	e0bffe17 	ldw	r2,-8(fp)
 d024438:	18bfe236 	bltu	r3,r2,d0243c4 <hexdump+0x80>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 d02443c:	e13ffc17 	ldw	r4,-16(fp)
 d024440:	01434174 	movhi	r5,3333
 d024444:	297be704 	addi	r5,r5,-4196
 d024448:	d02486c0 	call	d02486c <ns_printf>
      len -= count;
 d02444c:	e0fffe17 	ldw	r3,-8(fp)
 d024450:	e0bffa17 	ldw	r2,-24(fp)
 d024454:	1885c83a 	sub	r2,r3,r2
 d024458:	e0bffe15 	stw	r2,-8(fp)
      data += count;
 d02445c:	e0fffa17 	ldw	r3,-24(fp)
 d024460:	e0bffb17 	ldw	r2,-20(fp)
 d024464:	10c5883a 	add	r2,r2,r3
 d024468:	e0bffb15 	stw	r2,-20(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 d02446c:	e0bffe17 	ldw	r2,-8(fp)
 d024470:	1004c03a 	cmpne	r2,r2,zero
 d024474:	103fbd1e 	bne	r2,zero,d02436c <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 d024478:	e037883a 	mov	sp,fp
 d02447c:	dfc00117 	ldw	ra,4(sp)
 d024480:	df000017 	ldw	fp,0(sp)
 d024484:	dec00204 	addi	sp,sp,8
 d024488:	f800283a 	ret

0d02448c <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 d02448c:	defffa04 	addi	sp,sp,-24
 d024490:	dfc00515 	stw	ra,20(sp)
 d024494:	df000415 	stw	fp,16(sp)
 d024498:	df000404 	addi	fp,sp,16
 d02449c:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 d0244a0:	e0bfff17 	ldw	r2,-4(fp)
 d0244a4:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
 d0244a8:	e0bffe03 	ldbu	r2,-8(fp)
 d0244ac:	11803fcc 	andi	r6,r2,255
 d0244b0:	e0bffe43 	ldbu	r2,-7(fp)
 d0244b4:	11c03fcc 	andi	r7,r2,255
 d0244b8:	e0bffe83 	ldbu	r2,-6(fp)
 d0244bc:	10c03fcc 	andi	r3,r2,255
 d0244c0:	e0bffec3 	ldbu	r2,-5(fp)
 d0244c4:	10803fcc 	andi	r2,r2,255
 d0244c8:	d8c00015 	stw	r3,0(sp)
 d0244cc:	d8800115 	stw	r2,4(sp)
 d0244d0:	010341b4 	movhi	r4,3334
 d0244d4:	2132c684 	addi	r4,r4,-13542
 d0244d8:	01434174 	movhi	r5,3333
 d0244dc:	297be804 	addi	r5,r5,-4192
 d0244e0:	d002d340 	call	d002d34 <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 d0244e4:	008341b4 	movhi	r2,3334
 d0244e8:	10b2c684 	addi	r2,r2,-13542
}
 d0244ec:	e037883a 	mov	sp,fp
 d0244f0:	dfc00117 	ldw	ra,4(sp)
 d0244f4:	df000017 	ldw	fp,0(sp)
 d0244f8:	dec00204 	addi	sp,sp,8
 d0244fc:	f800283a 	ret

0d024500 <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 d024500:	defff804 	addi	sp,sp,-32
 d024504:	dfc00715 	stw	ra,28(sp)
 d024508:	df000615 	stw	fp,24(sp)
 d02450c:	df000604 	addi	fp,sp,24
 d024510:	e13fff15 	stw	r4,-4(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 d024514:	e0ffff17 	ldw	r3,-4(fp)
 d024518:	00801904 	movi	r2,100
 d02451c:	1885203a 	divu	r2,r3,r2
 d024520:	e0bfff15 	stw	r2,-4(fp)
   seconds = (unsigned)(timetick%60);
 d024524:	e0ffff17 	ldw	r3,-4(fp)
 d024528:	00800f04 	movi	r2,60
 d02452c:	1885203a 	divu	r2,r3,r2
 d024530:	10800f24 	muli	r2,r2,60
 d024534:	1885c83a 	sub	r2,r3,r2
 d024538:	e0bffe15 	stw	r2,-8(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 d02453c:	e0ffff17 	ldw	r3,-4(fp)
 d024540:	00800f04 	movi	r2,60
 d024544:	1885203a 	divu	r2,r3,r2
 d024548:	e0bfff15 	stw	r2,-4(fp)
   minutes = (unsigned)(timetick%60);
 d02454c:	e0ffff17 	ldw	r3,-4(fp)
 d024550:	00800f04 	movi	r2,60
 d024554:	1885203a 	divu	r2,r3,r2
 d024558:	10800f24 	muli	r2,r2,60
 d02455c:	1885c83a 	sub	r2,r3,r2
 d024560:	e0bffd15 	stw	r2,-12(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 d024564:	e0ffff17 	ldw	r3,-4(fp)
 d024568:	00800f04 	movi	r2,60
 d02456c:	1885203a 	divu	r2,r3,r2
 d024570:	e0bfff15 	stw	r2,-4(fp)
   hours = (unsigned)(timetick%24);
 d024574:	e0ffff17 	ldw	r3,-4(fp)
 d024578:	00800604 	movi	r2,24
 d02457c:	1885203a 	divu	r2,r3,r2
 d024580:	10800624 	muli	r2,r2,24
 d024584:	1885c83a 	sub	r2,r3,r2
 d024588:	e0bffc15 	stw	r2,-16(fp)
   timetick = timetick/24;    /* turn timetick into days */
 d02458c:	e0ffff17 	ldw	r3,-4(fp)
 d024590:	00800604 	movi	r2,24
 d024594:	1885203a 	divu	r2,r3,r2
 d024598:	e0bfff15 	stw	r2,-4(fp)

   if (timetick)  /* Is there a whole number of days? */
 d02459c:	e0bfff17 	ldw	r2,-4(fp)
 d0245a0:	1005003a 	cmpeq	r2,r2,zero
 d0245a4:	10000c1e 	bne	r2,zero,d0245d8 <print_uptime+0xd8>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 d0245a8:	e0bffd17 	ldw	r2,-12(fp)
 d0245ac:	d8800015 	stw	r2,0(sp)
 d0245b0:	e0bffe17 	ldw	r2,-8(fp)
 d0245b4:	d8800115 	stw	r2,4(sp)
 d0245b8:	01034174 	movhi	r4,3333
 d0245bc:	210c9304 	addi	r4,r4,12876
 d0245c0:	01434174 	movhi	r5,3333
 d0245c4:	297beb04 	addi	r5,r5,-4180
 d0245c8:	e1bfff17 	ldw	r6,-4(fp)
 d0245cc:	e1fffc17 	ldw	r7,-16(fp)
 d0245d0:	d002d340 	call	d002d34 <sprintf>
 d0245d4:	00001406 	br	d024628 <print_uptime+0x128>
    timetick, hours, minutes, seconds);
   else if (hours)
 d0245d8:	e0bffc17 	ldw	r2,-16(fp)
 d0245dc:	1005003a 	cmpeq	r2,r2,zero
 d0245e0:	10000a1e 	bne	r2,zero,d02460c <print_uptime+0x10c>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 d0245e4:	e0bffe17 	ldw	r2,-8(fp)
 d0245e8:	d8800015 	stw	r2,0(sp)
 d0245ec:	01034174 	movhi	r4,3333
 d0245f0:	210c9304 	addi	r4,r4,12876
 d0245f4:	01434174 	movhi	r5,3333
 d0245f8:	297bf104 	addi	r5,r5,-4156
 d0245fc:	e1bffc17 	ldw	r6,-16(fp)
 d024600:	e1fffd17 	ldw	r7,-12(fp)
 d024604:	d002d340 	call	d002d34 <sprintf>
 d024608:	00000706 	br	d024628 <print_uptime+0x128>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 d02460c:	01034174 	movhi	r4,3333
 d024610:	210c9304 	addi	r4,r4,12876
 d024614:	01434174 	movhi	r5,3333
 d024618:	297bf604 	addi	r5,r5,-4136
 d02461c:	e1bffd17 	ldw	r6,-12(fp)
 d024620:	e1fffe17 	ldw	r7,-8(fp)
 d024624:	d002d340 	call	d002d34 <sprintf>
   return tistring;
 d024628:	00834174 	movhi	r2,3333
 d02462c:	108c9304 	addi	r2,r2,12876
}
 d024630:	e037883a 	mov	sp,fp
 d024634:	dfc00117 	ldw	ra,4(sp)
 d024638:	df000017 	ldw	fp,0(sp)
 d02463c:	dec00204 	addi	sp,sp,8
 d024640:	f800283a 	ret

0d024644 <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 d024644:	defffd04 	addi	sp,sp,-12
 d024648:	dfc00215 	stw	ra,8(sp)
 d02464c:	df000115 	stw	fp,4(sp)
 d024650:	df000104 	addi	fp,sp,4
 d024654:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 d024658:	01034174 	movhi	r4,3333
 d02465c:	213bfb04 	addi	r4,r4,-4116
 d024660:	e17fff17 	ldw	r5,-4(fp)
 d024664:	d0029980 	call	d002998 <printf>
   dtrap();                   /* try to hook debugger */
 d024668:	d0293e80 	call	d0293e8 <dtrap>
   netexit(1);                /* try to clean up */
 d02466c:	01000044 	movi	r4,1
 d024670:	d041c000 	call	d041c00 <netexit>
}
 d024674:	e037883a 	mov	sp,fp
 d024678:	dfc00117 	ldw	ra,4(sp)
 d02467c:	df000017 	ldw	fp,0(sp)
 d024680:	dec00204 	addi	sp,sp,8
 d024684:	f800283a 	ret

0d024688 <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 d024688:	defffb04 	addi	sp,sp,-20
 d02468c:	df000415 	stw	fp,16(sp)
 d024690:	df000404 	addi	fp,sp,16
 d024694:	e13ffe15 	stw	r4,-8(fp)
 d024698:	e17fff05 	stb	r5,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 d02469c:	008341b4 	movhi	r2,3334
 d0246a0:	10b2c204 	addi	r2,r2,-13560
 d0246a4:	e0bffc15 	stw	r2,-16(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 d0246a8:	e03ffd15 	stw	zero,-12(fp)
 d0246ac:	00004406 	br	d0247c0 <print_eth+0x138>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 d0246b0:	e0bffe17 	ldw	r2,-8(fp)
 d0246b4:	10800003 	ldbu	r2,0(r2)
 d0246b8:	10803fcc 	andi	r2,r2,255
 d0246bc:	1080201c 	xori	r2,r2,128
 d0246c0:	10bfe004 	addi	r2,r2,-128
 d0246c4:	1005d13a 	srai	r2,r2,4
 d0246c8:	108003cc 	andi	r2,r2,15
 d0246cc:	10800c04 	addi	r2,r2,48
 d0246d0:	1007883a 	mov	r3,r2
 d0246d4:	e0bffc17 	ldw	r2,-16(fp)
 d0246d8:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 d0246dc:	e0bffc17 	ldw	r2,-16(fp)
 d0246e0:	10800003 	ldbu	r2,0(r2)
 d0246e4:	10803fcc 	andi	r2,r2,255
 d0246e8:	1080201c 	xori	r2,r2,128
 d0246ec:	10bfe004 	addi	r2,r2,-128
 d0246f0:	10800e90 	cmplti	r2,r2,58
 d0246f4:	1000061e 	bne	r2,zero,d024710 <print_eth+0x88>
         (*out) += 7;
 d0246f8:	e0bffc17 	ldw	r2,-16(fp)
 d0246fc:	10800003 	ldbu	r2,0(r2)
 d024700:	108001c4 	addi	r2,r2,7
 d024704:	1007883a 	mov	r3,r2
 d024708:	e0bffc17 	ldw	r2,-16(fp)
 d02470c:	10c00005 	stb	r3,0(r2)
      out++;
 d024710:	e0bffc17 	ldw	r2,-16(fp)
 d024714:	10800044 	addi	r2,r2,1
 d024718:	e0bffc15 	stw	r2,-16(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 d02471c:	e0bffe17 	ldw	r2,-8(fp)
 d024720:	10800003 	ldbu	r2,0(r2)
 d024724:	108003cc 	andi	r2,r2,15
 d024728:	10800c04 	addi	r2,r2,48
 d02472c:	1007883a 	mov	r3,r2
 d024730:	e0bffc17 	ldw	r2,-16(fp)
 d024734:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 d024738:	e0bffc17 	ldw	r2,-16(fp)
 d02473c:	10800003 	ldbu	r2,0(r2)
 d024740:	10803fcc 	andi	r2,r2,255
 d024744:	1080201c 	xori	r2,r2,128
 d024748:	10bfe004 	addi	r2,r2,-128
 d02474c:	10800e90 	cmplti	r2,r2,58
 d024750:	1000061e 	bne	r2,zero,d02476c <print_eth+0xe4>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 d024754:	e0bffc17 	ldw	r2,-16(fp)
 d024758:	10800003 	ldbu	r2,0(r2)
 d02475c:	108001c4 	addi	r2,r2,7
 d024760:	1007883a 	mov	r3,r2
 d024764:	e0bffc17 	ldw	r2,-16(fp)
 d024768:	10c00005 	stb	r3,0(r2)
      out++;
 d02476c:	e0bffc17 	ldw	r2,-16(fp)
 d024770:	10800044 	addi	r2,r2,1
 d024774:	e0bffc15 	stw	r2,-16(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 d024778:	e0bfff07 	ldb	r2,-4(fp)
 d02477c:	1005003a 	cmpeq	r2,r2,zero
 d024780:	1000091e 	bne	r2,zero,d0247a8 <print_eth+0x120>
 d024784:	e0bffd17 	ldw	r2,-12(fp)
 d024788:	10800148 	cmpgei	r2,r2,5
 d02478c:	1000061e 	bne	r2,zero,d0247a8 <print_eth+0x120>
         *out++ = spacer;
 d024790:	e0fffc17 	ldw	r3,-16(fp)
 d024794:	e0bfff03 	ldbu	r2,-4(fp)
 d024798:	18800005 	stb	r2,0(r3)
 d02479c:	e0bffc17 	ldw	r2,-16(fp)
 d0247a0:	10800044 	addi	r2,r2,1
 d0247a4:	e0bffc15 	stw	r2,-16(fp)
      addr++;
 d0247a8:	e0bffe17 	ldw	r2,-8(fp)
 d0247ac:	10800044 	addi	r2,r2,1
 d0247b0:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 d0247b4:	e0bffd17 	ldw	r2,-12(fp)
 d0247b8:	10800044 	addi	r2,r2,1
 d0247bc:	e0bffd15 	stw	r2,-12(fp)
 d0247c0:	e0bffd17 	ldw	r2,-12(fp)
 d0247c4:	10800190 	cmplti	r2,r2,6
 d0247c8:	103fb91e 	bne	r2,zero,d0246b0 <print_eth+0x28>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 d0247cc:	e0bffc17 	ldw	r2,-16(fp)
 d0247d0:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 d0247d4:	008341b4 	movhi	r2,3334
 d0247d8:	10b2c204 	addi	r2,r2,-13560
}
 d0247dc:	e037883a 	mov	sp,fp
 d0247e0:	df000017 	ldw	fp,0(sp)
 d0247e4:	dec00104 	addi	sp,sp,4
 d0247e8:	f800283a 	ret

0d0247ec <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 d0247ec:	defffd04 	addi	sp,sp,-12
 d0247f0:	df000215 	stw	fp,8(sp)
 d0247f4:	df000204 	addi	fp,sp,8
 d0247f8:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 d0247fc:	e0bfff17 	ldw	r2,-4(fp)
 d024800:	e0bffe15 	stw	r2,-8(fp)
 d024804:	00000d06 	br	d02483c <uslash+0x50>
      if (*cp == '\\')
 d024808:	e0bffe17 	ldw	r2,-8(fp)
 d02480c:	10800003 	ldbu	r2,0(r2)
 d024810:	10803fcc 	andi	r2,r2,255
 d024814:	1080201c 	xori	r2,r2,128
 d024818:	10bfe004 	addi	r2,r2,-128
 d02481c:	10801718 	cmpnei	r2,r2,92
 d024820:	1000031e 	bne	r2,zero,d024830 <uslash+0x44>
      *cp = '/';
 d024824:	e0fffe17 	ldw	r3,-8(fp)
 d024828:	00800bc4 	movi	r2,47
 d02482c:	18800005 	stb	r2,0(r3)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 d024830:	e0bffe17 	ldw	r2,-8(fp)
 d024834:	10800044 	addi	r2,r2,1
 d024838:	e0bffe15 	stw	r2,-8(fp)
 d02483c:	e0bffe17 	ldw	r2,-8(fp)
 d024840:	10800003 	ldbu	r2,0(r2)
 d024844:	10803fcc 	andi	r2,r2,255
 d024848:	1080201c 	xori	r2,r2,128
 d02484c:	10bfe004 	addi	r2,r2,-128
 d024850:	1004c03a 	cmpne	r2,r2,zero
 d024854:	103fec1e 	bne	r2,zero,d024808 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 d024858:	e0bfff17 	ldw	r2,-4(fp)
}
 d02485c:	e037883a 	mov	sp,fp
 d024860:	df000017 	ldw	fp,0(sp)
 d024864:	dec00104 	addi	sp,sp,4
 d024868:	f800283a 	ret

0d02486c <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 d02486c:	defff204 	addi	sp,sp,-56
 d024870:	dfc00b15 	stw	ra,44(sp)
 d024874:	df000a15 	stw	fp,40(sp)
 d024878:	dc400915 	stw	r17,36(sp)
 d02487c:	dc000815 	stw	r16,32(sp)
 d024880:	df000804 	addi	fp,sp,32
 d024884:	e13ffd15 	stw	r4,-12(fp)
 d024888:	e1800415 	stw	r6,16(fp)
 d02488c:	e1c00515 	stw	r7,20(fp)
 d024890:	e17ffe15 	stw	r5,-8(fp)
   char *   outbuf=NULL;
 d024894:	e03ffb15 	stw	zero,-20(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 d024898:	00802704 	movi	r2,156
 d02489c:	e0bff915 	stw	r2,-28(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 d0248a0:	e0bffd17 	ldw	r2,-12(fp)
 d0248a4:	e0bff815 	stw	r2,-32(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 d0248a8:	e0bff817 	ldw	r2,-32(fp)
 d0248ac:	1004c03a 	cmpne	r2,r2,zero
 d0248b0:	1000091e 	bne	r2,zero,d0248d8 <ns_printf+0x6c>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 d0248b4:	e0800404 	addi	r2,fp,16
 d0248b8:	e0bffc15 	stw	r2,-16(fp)
      ret_value = vprintf(format,argList);
 d0248bc:	e17ffc17 	ldw	r5,-16(fp)
 d0248c0:	e13ffe17 	ldw	r4,-8(fp)
 d0248c4:	d04a3fc0 	call	d04a3fc <vprintf>
 d0248c8:	e0bffa15 	stw	r2,-24(fp)
      va_end(argList);
      return ret_value;
 d0248cc:	e0bffa17 	ldw	r2,-24(fp)
 d0248d0:	e0bfff15 	stw	r2,-4(fp)
 d0248d4:	00003e06 	br	d0249d0 <ns_printf+0x164>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 d0248d8:	e0bff817 	ldw	r2,-32(fp)
 d0248dc:	10800117 	ldw	r2,4(r2)
 d0248e0:	1004c03a 	cmpne	r2,r2,zero
 d0248e4:	1000031e 	bne	r2,zero,d0248f4 <ns_printf+0x88>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 d0248e8:	00bfffc4 	movi	r2,-1
 d0248ec:	e0bfff15 	stw	r2,-4(fp)
 d0248f0:	00003706 	br	d0249d0 <ns_printf+0x164>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 d0248f4:	e13ffe17 	ldw	r4,-8(fp)
 d0248f8:	d00355c0 	call	d00355c <strlen>
 d0248fc:	e0bffa15 	stw	r2,-24(fp)
   if (ret_value >= MAXIOSIZE)
 d024900:	e0bffa17 	ldw	r2,-24(fp)
 d024904:	10802710 	cmplti	r2,r2,156
 d024908:	1000041e 	bne	r2,zero,d02491c <ns_printf+0xb0>
   {
      buf_size += ret_value ;
 d02490c:	e0bff917 	ldw	r2,-28(fp)
 d024910:	e0fffa17 	ldw	r3,-24(fp)
 d024914:	10c5883a 	add	r2,r2,r3
 d024918:	e0bff915 	stw	r2,-28(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 d02491c:	e13ff917 	ldw	r4,-28(fp)
 d024920:	d029e2c0 	call	d029e2c <npalloc>
 d024924:	e0bffb15 	stw	r2,-20(fp)

   if (outbuf == NULL)
 d024928:	e0bffb17 	ldw	r2,-20(fp)
 d02492c:	1004c03a 	cmpne	r2,r2,zero
 d024930:	1000031e 	bne	r2,zero,d024940 <ns_printf+0xd4>
   {
      return -2;
 d024934:	00bfff84 	movi	r2,-2
 d024938:	e0bfff15 	stw	r2,-4(fp)
 d02493c:	00002406 	br	d0249d0 <ns_printf+0x164>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 d024940:	e0800404 	addi	r2,fp,16
 d024944:	e0bffc15 	stw	r2,-16(fp)
   ret_value = vsprintf(outbuf,format,argList);
 d024948:	e1bffc17 	ldw	r6,-16(fp)
 d02494c:	e13ffb17 	ldw	r4,-20(fp)
 d024950:	e17ffe17 	ldw	r5,-8(fp)
 d024954:	d04a46c0 	call	d04a46c <vsprintf>
 d024958:	e0bffa15 	stw	r2,-24(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 d02495c:	e13ffb17 	ldw	r4,-20(fp)
 d024960:	d00355c0 	call	d00355c <strlen>
 d024964:	1007883a 	mov	r3,r2
 d024968:	e0bff917 	ldw	r2,-28(fp)
 d02496c:	10c0080e 	bge	r2,r3,d024990 <ns_printf+0x124>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 d024970:	01034174 	movhi	r4,3333
 d024974:	213bfe04 	addi	r4,r4,-4104
 d024978:	d0246440 	call	d024644 <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 d02497c:	e0fff917 	ldw	r3,-28(fp)
 d024980:	e0bffb17 	ldw	r2,-20(fp)
 d024984:	1885883a 	add	r2,r3,r2
 d024988:	10bfffc4 	addi	r2,r2,-1
 d02498c:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 d024990:	e0bff817 	ldw	r2,-32(fp)
 d024994:	14400117 	ldw	r17,4(r2)
 d024998:	e0bff817 	ldw	r2,-32(fp)
 d02499c:	14000217 	ldw	r16,8(r2)
 d0249a0:	e13ffb17 	ldw	r4,-20(fp)
 d0249a4:	d00355c0 	call	d00355c <strlen>
 d0249a8:	100d883a 	mov	r6,r2
 d0249ac:	8009883a 	mov	r4,r16
 d0249b0:	e17ffb17 	ldw	r5,-20(fp)
 d0249b4:	883ee83a 	callr	r17
 d0249b8:	e0bffa15 	stw	r2,-24(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 d0249bc:	e13ffb17 	ldw	r4,-20(fp)
 d0249c0:	d029f200 	call	d029f20 <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 d0249c4:	d0252d40 	call	d0252d4 <tk_yield>

   return ret_value ;
 d0249c8:	e0bffa17 	ldw	r2,-24(fp)
 d0249cc:	e0bfff15 	stw	r2,-4(fp)
 d0249d0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0249d4:	e037883a 	mov	sp,fp
 d0249d8:	dfc00317 	ldw	ra,12(sp)
 d0249dc:	df000217 	ldw	fp,8(sp)
 d0249e0:	dc400117 	ldw	r17,4(sp)
 d0249e4:	dc000017 	ldw	r16,0(sp)
 d0249e8:	dec00604 	addi	sp,sp,24
 d0249ec:	f800283a 	ret

0d0249f0 <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 d0249f0:	defffb04 	addi	sp,sp,-20
 d0249f4:	dfc00415 	stw	ra,16(sp)
 d0249f8:	df000315 	stw	fp,12(sp)
 d0249fc:	df000304 	addi	fp,sp,12
 d024a00:	e13ffd15 	stw	r4,-12(fp)
 d024a04:	e17ffe15 	stw	r5,-8(fp)
 d024a08:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 d024a0c:	01034174 	movhi	r4,3333
 d024a10:	213c0504 	addi	r4,r4,-4076
 d024a14:	e17ffe17 	ldw	r5,-8(fp)
 d024a18:	d0029980 	call	d002998 <printf>
   USE_ARG(s);
   return len;
 d024a1c:	e0bfff17 	ldw	r2,-4(fp)
}
 d024a20:	e037883a 	mov	sp,fp
 d024a24:	dfc00117 	ldw	ra,4(sp)
 d024a28:	df000017 	ldw	fp,0(sp)
 d024a2c:	dec00204 	addi	sp,sp,8
 d024a30:	f800283a 	ret

0d024a34 <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 d024a34:	defff904 	addi	sp,sp,-28
 d024a38:	dfc00615 	stw	ra,24(sp)
 d024a3c:	df000515 	stw	fp,20(sp)
 d024a40:	df000504 	addi	fp,sp,20
 d024a44:	e13ffd15 	stw	r4,-12(fp)
 d024a48:	e17ffe15 	stw	r5,-8(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 d024a4c:	e0bffd17 	ldw	r2,-12(fp)
 d024a50:	e0bffb15 	stw	r2,-20(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 d024a54:	e0fffe17 	ldw	r3,-8(fp)
 d024a58:	00800504 	movi	r2,20
 d024a5c:	1885283a 	div	r2,r3,r2
 d024a60:	10800524 	muli	r2,r2,20
 d024a64:	1885c83a 	sub	r2,r3,r2
 d024a68:	1004c03a 	cmpne	r2,r2,zero
 d024a6c:	1000281e 	bne	r2,zero,d024b10 <con_page+0xdc>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 d024a70:	e0bffb17 	ldw	r2,-20(fp)
 d024a74:	1005003a 	cmpeq	r2,r2,zero
 d024a78:	1000251e 	bne	r2,zero,d024b10 <con_page+0xdc>
 d024a7c:	e0bffb17 	ldw	r2,-20(fp)
 d024a80:	10800317 	ldw	r2,12(r2)
 d024a84:	1005003a 	cmpeq	r2,r2,zero
 d024a88:	1000211e 	bne	r2,zero,d024b10 <con_page+0xdc>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 d024a8c:	e13ffb17 	ldw	r4,-20(fp)
 d024a90:	01434174 	movhi	r5,3333
 d024a94:	297c0604 	addi	r5,r5,-4072
 d024a98:	d02486c0 	call	d02486c <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 d024a9c:	e0bffb17 	ldw	r2,-20(fp)
 d024aa0:	10c00317 	ldw	r3,12(r2)
 d024aa4:	e0bffb17 	ldw	r2,-20(fp)
 d024aa8:	11000217 	ldw	r4,8(r2)
 d024aac:	183ee83a 	callr	r3
 d024ab0:	e0bffc15 	stw	r2,-16(fp)
            if (ch == 0)
 d024ab4:	e0bffc17 	ldw	r2,-16(fp)
 d024ab8:	1004c03a 	cmpne	r2,r2,zero
 d024abc:	1000011e 	bne	r2,zero,d024ac4 <con_page+0x90>
               tk_yield();    /* Give timeslice to other processes */
 d024ac0:	d0252d40 	call	d0252d4 <tk_yield>
         } while (ch == 0) ;
 d024ac4:	e0bffc17 	ldw	r2,-16(fp)
 d024ac8:	1005003a 	cmpeq	r2,r2,zero
 d024acc:	103ff31e 	bne	r2,zero,d024a9c <con_page+0x68>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 d024ad0:	e0bffc17 	ldw	r2,-16(fp)
 d024ad4:	10bfffd8 	cmpnei	r2,r2,-1
 d024ad8:	1000031e 	bne	r2,zero,d024ae8 <con_page+0xb4>
            return 1 ;
 d024adc:	00800044 	movi	r2,1
 d024ae0:	e0bfff15 	stw	r2,-4(fp)
 d024ae4:	00000b06 	br	d024b14 <con_page+0xe0>

         ns_printf(pio,"\n");
 d024ae8:	e13ffb17 	ldw	r4,-20(fp)
 d024aec:	01434174 	movhi	r5,3333
 d024af0:	297be704 	addi	r5,r5,-4196
 d024af4:	d02486c0 	call	d02486c <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 d024af8:	e0bffc17 	ldw	r2,-16(fp)
 d024afc:	108006d8 	cmpnei	r2,r2,27
 d024b00:	1000031e 	bne	r2,zero,d024b10 <con_page+0xdc>
            return 1 ;
 d024b04:	00800044 	movi	r2,1
 d024b08:	e0bfff15 	stw	r2,-4(fp)
 d024b0c:	00000106 	br	d024b14 <con_page+0xe0>
      }
   }
   return  0;
 d024b10:	e03fff15 	stw	zero,-4(fp)
 d024b14:	e0bfff17 	ldw	r2,-4(fp)
}
 d024b18:	e037883a 	mov	sp,fp
 d024b1c:	dfc00117 	ldw	ra,4(sp)
 d024b20:	df000017 	ldw	fp,0(sp)
 d024b24:	dec00204 	addi	sp,sp,8
 d024b28:	f800283a 	ret

0d024b2c <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 d024b2c:	defff604 	addi	sp,sp,-40
 d024b30:	dfc00915 	stw	ra,36(sp)
 d024b34:	df000815 	stw	fp,32(sp)
 d024b38:	df000804 	addi	fp,sp,32
 d024b3c:	e13ffc15 	stw	r4,-16(fp)
 d024b40:	e17ffd15 	stw	r5,-12(fp)
 d024b44:	e1bffe15 	stw	r6,-8(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 d024b48:	e0bffc17 	ldw	r2,-16(fp)
 d024b4c:	e0bff915 	stw	r2,-28(fp)
   char **pargv = NULL;
 d024b50:	e03ff815 	stw	zero,-32(fp)
   *pargc_index = 0;
 d024b54:	e0bffe17 	ldw	r2,-8(fp)
 d024b58:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 d024b5c:	e0bffc17 	ldw	r2,-16(fp)
 d024b60:	1004c03a 	cmpne	r2,r2,zero
 d024b64:	1000021e 	bne	r2,zero,d024b70 <parse_args+0x44>
   {
      return (NULL);
 d024b68:	e03fff15 	stw	zero,-4(fp)
 d024b6c:	00007406 	br	d024d40 <parse_args+0x214>
   }
   len = strlen(buf);
 d024b70:	e13ffc17 	ldw	r4,-16(fp)
 d024b74:	d00355c0 	call	d00355c <strlen>
 d024b78:	e0bffa15 	stw	r2,-24(fp)
   if (len <= 0)
 d024b7c:	e0bffa17 	ldw	r2,-24(fp)
 d024b80:	10800048 	cmpgei	r2,r2,1
 d024b84:	1000021e 	bne	r2,zero,d024b90 <parse_args+0x64>
   {
      return (NULL);
 d024b88:	e03fff15 	stw	zero,-4(fp)
 d024b8c:	00006c06 	br	d024d40 <parse_args+0x214>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 d024b90:	e0bffd17 	ldw	r2,-12(fp)
 d024b94:	1085883a 	add	r2,r2,r2
 d024b98:	1085883a 	add	r2,r2,r2
 d024b9c:	1009883a 	mov	r4,r2
 d024ba0:	d029e2c0 	call	d029e2c <npalloc>
 d024ba4:	e0bff815 	stw	r2,-32(fp)
   if (pargv == NULL)
 d024ba8:	e0bff817 	ldw	r2,-32(fp)
 d024bac:	1004c03a 	cmpne	r2,r2,zero
 d024bb0:	1000051e 	bne	r2,zero,d024bc8 <parse_args+0x9c>
   {
      return (NULL);
 d024bb4:	e03fff15 	stw	zero,-4(fp)
 d024bb8:	00006106 	br	d024d40 <parse_args+0x214>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 d024bbc:	e0bff917 	ldw	r2,-28(fp)
 d024bc0:	10800044 	addi	r2,r2,1
 d024bc4:	e0bff915 	stw	r2,-28(fp)
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 d024bc8:	e0bff917 	ldw	r2,-28(fp)
 d024bcc:	10800003 	ldbu	r2,0(r2)
 d024bd0:	10803fcc 	andi	r2,r2,255
 d024bd4:	1080201c 	xori	r2,r2,128
 d024bd8:	10bfe004 	addi	r2,r2,-128
 d024bdc:	10800820 	cmpeqi	r2,r2,32
 d024be0:	103ff61e 	bne	r2,zero,d024bbc <parse_args+0x90>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 d024be4:	00003206 	br	d024cb0 <parse_args+0x184>
   {
      pargv[(*pargc_index)] = bp;
 d024be8:	e0bffe17 	ldw	r2,-8(fp)
 d024bec:	10800017 	ldw	r2,0(r2)
 d024bf0:	1085883a 	add	r2,r2,r2
 d024bf4:	1085883a 	add	r2,r2,r2
 d024bf8:	1007883a 	mov	r3,r2
 d024bfc:	e0bff817 	ldw	r2,-32(fp)
 d024c00:	1887883a 	add	r3,r3,r2
 d024c04:	e0bff917 	ldw	r2,-28(fp)
 d024c08:	18800015 	stw	r2,0(r3)
      (*pargc_index)++;
 d024c0c:	e0bffe17 	ldw	r2,-8(fp)
 d024c10:	10800017 	ldw	r2,0(r2)
 d024c14:	10c00044 	addi	r3,r2,1
 d024c18:	e0bffe17 	ldw	r2,-8(fp)
 d024c1c:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 d024c20:	00000306 	br	d024c30 <parse_args+0x104>
      {
         bp++; 
 d024c24:	e0bff917 	ldw	r2,-28(fp)
 d024c28:	10800044 	addi	r2,r2,1
 d024c2c:	e0bff915 	stw	r2,-28(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 d024c30:	e0bff917 	ldw	r2,-28(fp)
 d024c34:	10800003 	ldbu	r2,0(r2)
 d024c38:	10803fcc 	andi	r2,r2,255
 d024c3c:	1080201c 	xori	r2,r2,128
 d024c40:	10bfe004 	addi	r2,r2,-128
 d024c44:	10800820 	cmpeqi	r2,r2,32
 d024c48:	10000b1e 	bne	r2,zero,d024c78 <parse_args+0x14c>
 d024c4c:	e0bff917 	ldw	r2,-28(fp)
 d024c50:	10800003 	ldbu	r2,0(r2)
 d024c54:	10803fcc 	andi	r2,r2,255
 d024c58:	1080201c 	xori	r2,r2,128
 d024c5c:	10bfe004 	addi	r2,r2,-128
 d024c60:	1004c03a 	cmpne	r2,r2,zero
 d024c64:	103fef1e 	bne	r2,zero,d024c24 <parse_args+0xf8>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 d024c68:	00000306 	br	d024c78 <parse_args+0x14c>
      {
         bp++; 
 d024c6c:	e0bff917 	ldw	r2,-28(fp)
 d024c70:	10800044 	addi	r2,r2,1
 d024c74:	e0bff915 	stw	r2,-28(fp)
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 d024c78:	e0bff917 	ldw	r2,-28(fp)
 d024c7c:	10800003 	ldbu	r2,0(r2)
 d024c80:	10803fcc 	andi	r2,r2,255
 d024c84:	1080201c 	xori	r2,r2,128
 d024c88:	10bfe004 	addi	r2,r2,-128
 d024c8c:	10800818 	cmpnei	r2,r2,32
 d024c90:	1000071e 	bne	r2,zero,d024cb0 <parse_args+0x184>
 d024c94:	e0bff917 	ldw	r2,-28(fp)
 d024c98:	10800003 	ldbu	r2,0(r2)
 d024c9c:	10803fcc 	andi	r2,r2,255
 d024ca0:	1080201c 	xori	r2,r2,128
 d024ca4:	10bfe004 	addi	r2,r2,-128
 d024ca8:	1004c03a 	cmpne	r2,r2,zero
 d024cac:	103fef1e 	bne	r2,zero,d024c6c <parse_args+0x140>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 d024cb0:	e0bff917 	ldw	r2,-28(fp)
 d024cb4:	10800003 	ldbu	r2,0(r2)
 d024cb8:	10803fcc 	andi	r2,r2,255
 d024cbc:	1080201c 	xori	r2,r2,128
 d024cc0:	10bfe004 	addi	r2,r2,-128
 d024cc4:	1005003a 	cmpeq	r2,r2,zero
 d024cc8:	1000041e 	bne	r2,zero,d024cdc <parse_args+0x1b0>
 d024ccc:	e0bffe17 	ldw	r2,-8(fp)
 d024cd0:	10c00017 	ldw	r3,0(r2)
 d024cd4:	e0bffd17 	ldw	r2,-12(fp)
 d024cd8:	18bfc316 	blt	r3,r2,d024be8 <parse_args+0xbc>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 d024cdc:	e03ffb15 	stw	zero,-20(fp)
 d024ce0:	00001206 	br	d024d2c <parse_args+0x200>
   {
      if (buf[i] == ' ')
 d024ce4:	e0bffb17 	ldw	r2,-20(fp)
 d024ce8:	1007883a 	mov	r3,r2
 d024cec:	e0bffc17 	ldw	r2,-16(fp)
 d024cf0:	1885883a 	add	r2,r3,r2
 d024cf4:	10800003 	ldbu	r2,0(r2)
 d024cf8:	10803fcc 	andi	r2,r2,255
 d024cfc:	1080201c 	xori	r2,r2,128
 d024d00:	10bfe004 	addi	r2,r2,-128
 d024d04:	10800818 	cmpnei	r2,r2,32
 d024d08:	1000051e 	bne	r2,zero,d024d20 <parse_args+0x1f4>
         buf[i] = '\0';
 d024d0c:	e0bffb17 	ldw	r2,-20(fp)
 d024d10:	1007883a 	mov	r3,r2
 d024d14:	e0bffc17 	ldw	r2,-16(fp)
 d024d18:	1885883a 	add	r2,r3,r2
 d024d1c:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 d024d20:	e0bffb17 	ldw	r2,-20(fp)
 d024d24:	10800044 	addi	r2,r2,1
 d024d28:	e0bffb15 	stw	r2,-20(fp)
 d024d2c:	e0fffb17 	ldw	r3,-20(fp)
 d024d30:	e0bffa17 	ldw	r2,-24(fp)
 d024d34:	18bfeb16 	blt	r3,r2,d024ce4 <parse_args+0x1b8>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 d024d38:	e0bff817 	ldw	r2,-32(fp)
 d024d3c:	e0bfff15 	stw	r2,-4(fp)
 d024d40:	e0bfff17 	ldw	r2,-4(fp)
}
 d024d44:	e037883a 	mov	sp,fp
 d024d48:	dfc00117 	ldw	ra,4(sp)
 d024d4c:	df000017 	ldw	fp,0(sp)
 d024d50:	dec00204 	addi	sp,sp,8
 d024d54:	f800283a 	ret

0d024d58 <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 d024d58:	defffb04 	addi	sp,sp,-20
 d024d5c:	dfc00415 	stw	ra,16(sp)
 d024d60:	df000315 	stw	fp,12(sp)
 d024d64:	df000304 	addi	fp,sp,12
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 d024d68:	d0208c15 	stw	zero,-32208(gp)

   e = prep_modules();
 d024d6c:	d03acb40 	call	d03acb4 <prep_modules>
 d024d70:	e0bffd15 	stw	r2,-12(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 d024d74:	e03ffe15 	stw	zero,-8(fp)
 d024d78:	00001c06 	br	d024dec <netmain+0x94>
   {
      e = TK_NEWTASK(&nettasks[i]);
 d024d7c:	e0bffe17 	ldw	r2,-8(fp)
 d024d80:	10800624 	muli	r2,r2,24
 d024d84:	1007883a 	mov	r3,r2
 d024d88:	00834174 	movhi	r2,3333
 d024d8c:	10892f04 	addi	r2,r2,9404
 d024d90:	1889883a 	add	r4,r3,r2
 d024d94:	d0297d00 	call	d0297d0 <TK_NEWTASK>
 d024d98:	e0bffd15 	stw	r2,-12(fp)
      if (e != 0)
 d024d9c:	e0bffd17 	ldw	r2,-12(fp)
 d024da0:	1005003a 	cmpeq	r2,r2,zero
 d024da4:	10000e1e 	bne	r2,zero,d024de0 <netmain+0x88>
      {
         dprintf("task create error\n");
 d024da8:	01034174 	movhi	r4,3333
 d024dac:	213c1804 	addi	r4,r4,-4000
 d024db0:	d002cc00 	call	d002cc0 <puts>
         panic((char *)&nettasks[i].name);
 d024db4:	e0bffe17 	ldw	r2,-8(fp)
 d024db8:	10800624 	muli	r2,r2,24
 d024dbc:	10c00104 	addi	r3,r2,4
 d024dc0:	00834174 	movhi	r2,3333
 d024dc4:	10892f04 	addi	r2,r2,9404
 d024dc8:	1885883a 	add	r2,r3,r2
 d024dcc:	1009883a 	mov	r4,r2
 d024dd0:	d0246440 	call	d024644 <panic>
         return -1;  /* compiler warnings */
 d024dd4:	00bfffc4 	movi	r2,-1
 d024dd8:	e0bfff15 	stw	r2,-4(fp)
 d024ddc:	00001506 	br	d024e34 <netmain+0xdc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 d024de0:	e0bffe17 	ldw	r2,-8(fp)
 d024de4:	10800044 	addi	r2,r2,1
 d024de8:	e0bffe15 	stw	r2,-8(fp)
 d024dec:	d0e03217 	ldw	r3,-32568(gp)
 d024df0:	e0bffe17 	ldw	r2,-8(fp)
 d024df4:	10ffe116 	blt	r2,r3,d024d7c <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 d024df8:	d03b1780 	call	d03b178 <create_apptasks>
 d024dfc:	e0bffd15 	stw	r2,-12(fp)
   if (e != 0) 
 d024e00:	e0bffd17 	ldw	r2,-12(fp)
 d024e04:	1005003a 	cmpeq	r2,r2,zero
 d024e08:	1000091e 	bne	r2,zero,d024e30 <netmain+0xd8>
   {
      dprintf("task create error\n");
 d024e0c:	01034174 	movhi	r4,3333
 d024e10:	213c1804 	addi	r4,r4,-4000
 d024e14:	d002cc00 	call	d002cc0 <puts>
      panic("netmain");
 d024e18:	01034174 	movhi	r4,3333
 d024e1c:	213c1d04 	addi	r4,r4,-3980
 d024e20:	d0246440 	call	d024644 <panic>
      return -1;  /* compiler warnings */
 d024e24:	00bfffc4 	movi	r2,-1
 d024e28:	e0bfff15 	stw	r2,-4(fp)
 d024e2c:	00000106 	br	d024e34 <netmain+0xdc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 d024e30:	e03fff15 	stw	zero,-4(fp)
 d024e34:	e0bfff17 	ldw	r2,-4(fp)
#endif
#endif   /* NO_INET_STACK */
}
 d024e38:	e037883a 	mov	sp,fp
 d024e3c:	dfc00117 	ldw	ra,4(sp)
 d024e40:	df000017 	ldw	fp,0(sp)
 d024e44:	dec00204 	addi	sp,sp,8
 d024e48:	f800283a 	ret

0d024e4c <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 d024e4c:	defffc04 	addi	sp,sp,-16
 d024e50:	dfc00315 	stw	ra,12(sp)
 d024e54:	df000215 	stw	fp,8(sp)
 d024e58:	df000204 	addi	fp,sp,8
 d024e5c:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 d024e60:	d03a93c0 	call	d03a93c <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 d024e64:	00800044 	movi	r2,1
 d024e68:	d0a08c15 	stw	r2,-32208(gp)
 d024e6c:	00000006 	br	d024e70 <tk_netmain+0x24>

   for (;;)
   {
      TK_NETRX_BLOCK();
 d024e70:	00834174 	movhi	r2,3333
 d024e74:	108acc04 	addi	r2,r2,11056
 d024e78:	11000017 	ldw	r4,0(r2)
 d024e7c:	01401904 	movi	r5,100
 d024e80:	e1bffe04 	addi	r6,fp,-8
 d024e84:	d0132540 	call	d013254 <OSSemPend>
 d024e88:	e0bffe03 	ldbu	r2,-8(fp)
 d024e8c:	10803fcc 	andi	r2,r2,255
 d024e90:	1005003a 	cmpeq	r2,r2,zero
 d024e94:	1000051e 	bne	r2,zero,d024eac <tk_netmain+0x60>
 d024e98:	e0bffe03 	ldbu	r2,-8(fp)
 d024e9c:	10803fcc 	andi	r2,r2,255
 d024ea0:	108002a0 	cmpeqi	r2,r2,10
 d024ea4:	1000011e 	bne	r2,zero,d024eac <tk_netmain+0x60>
 d024ea8:	d0293e80 	call	d0293e8 <dtrap>
      netmain_wakes++;  /* count wakeups */
 d024eac:	d0a08a17 	ldw	r2,-32216(gp)
 d024eb0:	10800044 	addi	r2,r2,1
 d024eb4:	d0a08a15 	stw	r2,-32216(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 d024eb8:	008341b4 	movhi	r2,3334
 d024ebc:	10b1e004 	addi	r2,r2,-14464
 d024ec0:	10800217 	ldw	r2,8(r2)
 d024ec4:	1005003a 	cmpeq	r2,r2,zero
 d024ec8:	103fe91e 	bne	r2,zero,d024e70 <tk_netmain+0x24>
         pktdemux();
 d024ecc:	d021b300 	call	d021b30 <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 d024ed0:	003fe706 	br	d024e70 <tk_netmain+0x24>

0d024ed4 <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 d024ed4:	defffd04 	addi	sp,sp,-12
 d024ed8:	dfc00215 	stw	ra,8(sp)
 d024edc:	df000115 	stw	fp,4(sp)
 d024ee0:	df000104 	addi	fp,sp,4
 d024ee4:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 d024ee8:	00000306 	br	d024ef8 <tk_nettick+0x24>
       * request and then we receive a NAK. At this point the DHCP
       * client is reset to INIT state and dhc_second() needs to be
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
 d024eec:	d027a400 	call	d027a40 <dhc_second>
#endif
      TK_SLEEP(1);
 d024ef0:	01000084 	movi	r4,2
 d024ef4:	d0153e80 	call	d0153e8 <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 d024ef8:	d0a08c17 	ldw	r2,-32208(gp)
 d024efc:	1005003a 	cmpeq	r2,r2,zero
 d024f00:	103ffa1e 	bne	r2,zero,d024eec <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 d024f04:	01000084 	movi	r4,2
 d024f08:	d0153e80 	call	d0153e8 <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 d024f0c:	d0a08b17 	ldw	r2,-32212(gp)
 d024f10:	10800044 	addi	r2,r2,1
 d024f14:	d0a08b15 	stw	r2,-32212(gp)
      inet_timer();  /* let various timeouts occur */
 d024f18:	d03ad0c0 	call	d03ad0c <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 d024f1c:	003ff906 	br	d024f04 <tk_nettick+0x30>

0d024f20 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 d024f20:	defffe04 	addi	sp,sp,-8
 d024f24:	dfc00115 	stw	ra,4(sp)
 d024f28:	df000015 	stw	fp,0(sp)
 d024f2c:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 d024f30:	01000084 	movi	r4,2
 d024f34:	d0153e80 	call	d0153e8 <OSTimeDly>
}
 d024f38:	e037883a 	mov	sp,fp
 d024f3c:	dfc00117 	ldw	ra,4(sp)
 d024f40:	df000017 	ldw	fp,0(sp)
 d024f44:	dec00204 	addi	sp,sp,8
 d024f48:	f800283a 	ret

0d024f4c <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 d024f4c:	defffc04 	addi	sp,sp,-16
 d024f50:	dfc00315 	stw	ra,12(sp)
 d024f54:	df000215 	stw	fp,8(sp)
 d024f58:	df000204 	addi	fp,sp,8
 d024f5c:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 d024f60:	e0bfff17 	ldw	r2,-4(fp)
 d024f64:	10800003 	ldbu	r2,0(r2)
 d024f68:	11003fcc 	andi	r4,r2,255
 d024f6c:	d014be80 	call	d014be8 <OSTaskResume>
 d024f70:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 d024f74:	e0bffe03 	ldbu	r2,-8(fp)
 d024f78:	1005003a 	cmpeq	r2,r2,zero
 d024f7c:	10000a1e 	bne	r2,zero,d024fa8 <TK_OSTaskResume+0x5c>
 d024f80:	e0bffe03 	ldbu	r2,-8(fp)
 d024f84:	10801120 	cmpeqi	r2,r2,68
 d024f88:	1000071e 	bne	r2,zero,d024fa8 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 d024f8c:	01034174 	movhi	r4,3333
 d024f90:	213c1f04 	addi	r4,r4,-3972
 d024f94:	d002cc00 	call	d002cc0 <puts>
      dtrap();
 d024f98:	d0293e80 	call	d0293e8 <dtrap>
      panic("TK_OSTaskResume");      
 d024f9c:	01034174 	movhi	r4,3333
 d024fa0:	213c2c04 	addi	r4,r4,-3920
 d024fa4:	d0246440 	call	d024644 <panic>
   }
#endif
}
 d024fa8:	e037883a 	mov	sp,fp
 d024fac:	dfc00117 	ldw	ra,4(sp)
 d024fb0:	df000017 	ldw	fp,0(sp)
 d024fb4:	dec00204 	addi	sp,sp,8
 d024fb8:	f800283a 	ret

0d024fbc <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 d024fbc:	defffb04 	addi	sp,sp,-20
 d024fc0:	dfc00415 	stw	ra,16(sp)
 d024fc4:	df000315 	stw	fp,12(sp)
 d024fc8:	df000304 	addi	fp,sp,12
 d024fcc:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 d024fd0:	e03ffd15 	stw	zero,-12(fp)
 d024fd4:	00005006 	br	d025118 <tcp_sleep+0x15c>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 d024fd8:	e0bffd17 	ldw	r2,-12(fp)
 d024fdc:	00c341b4 	movhi	r3,3334
 d024fe0:	18f39004 	addi	r3,r3,-12736
 d024fe4:	10800324 	muli	r2,r2,12
 d024fe8:	10c5883a 	add	r2,r2,r3
 d024fec:	10800104 	addi	r2,r2,4
 d024ff0:	10800017 	ldw	r2,0(r2)
 d024ff4:	1004c03a 	cmpne	r2,r2,zero
 d024ff8:	1000441e 	bne	r2,zero,d02510c <tcp_sleep+0x150>
      {
         global_TCPwakeup_set[i].soc_event = event;
 d024ffc:	e0bffd17 	ldw	r2,-12(fp)
 d025000:	00c341b4 	movhi	r3,3334
 d025004:	18f39004 	addi	r3,r3,-12736
 d025008:	10800324 	muli	r2,r2,12
 d02500c:	10c5883a 	add	r2,r2,r3
 d025010:	10c00104 	addi	r3,r2,4
 d025014:	e0bfff17 	ldw	r2,-4(fp)
 d025018:	18800015 	stw	r2,0(r3)
         global_TCPwakeup_set[i].ctick = cticks;
 d02501c:	e13ffd17 	ldw	r4,-12(fp)
 d025020:	00834174 	movhi	r2,3333
 d025024:	108ac904 	addi	r2,r2,11044
 d025028:	11400017 	ldw	r5,0(r2)
 d02502c:	00c341b4 	movhi	r3,3334
 d025030:	18f39004 	addi	r3,r3,-12736
 d025034:	20800324 	muli	r2,r4,12
 d025038:	10c5883a 	add	r2,r2,r3
 d02503c:	11400015 	stw	r5,0(r2)
         if (i > global_TCPwakeup_setIndx)
 d025040:	00834174 	movhi	r2,3333
 d025044:	108ac804 	addi	r2,r2,11040
 d025048:	10c00017 	ldw	r3,0(r2)
 d02504c:	e0bffd17 	ldw	r2,-12(fp)
 d025050:	1880040e 	bge	r3,r2,d025064 <tcp_sleep+0xa8>
            global_TCPwakeup_setIndx = i;
 d025054:	00c34174 	movhi	r3,3333
 d025058:	18cac804 	addi	r3,r3,11040
 d02505c:	e0bffd17 	ldw	r2,-12(fp)
 d025060:	18800015 	stw	r2,0(r3)

         tcp_sleep_count++;
 d025064:	00834174 	movhi	r2,3333
 d025068:	108ac404 	addi	r2,r2,11024
 d02506c:	10800017 	ldw	r2,0(r2)
 d025070:	10c00044 	addi	r3,r2,1
 d025074:	00834174 	movhi	r2,3333
 d025078:	108ac404 	addi	r2,r2,11024
 d02507c:	10c00015 	stw	r3,0(r2)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 d025080:	0009883a 	mov	r4,zero
 d025084:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 d025088:	e0bffd17 	ldw	r2,-12(fp)
 d02508c:	00c341b4 	movhi	r3,3334
 d025090:	18f39004 	addi	r3,r3,-12736
 d025094:	10800324 	muli	r2,r2,12
 d025098:	10c5883a 	add	r2,r2,r3
 d02509c:	10800204 	addi	r2,r2,8
 d0250a0:	11000017 	ldw	r4,0(r2)
 d0250a4:	e1bffe04 	addi	r6,fp,-8
 d0250a8:	01401904 	movi	r5,100
 d0250ac:	d0132540 	call	d013254 <OSSemPend>
         if (err == 10)
 d0250b0:	e0bffe03 	ldbu	r2,-8(fp)
 d0250b4:	10803fcc 	andi	r2,r2,255
 d0250b8:	10800298 	cmpnei	r2,r2,10
 d0250bc:	1000101e 	bne	r2,zero,d025100 <tcp_sleep+0x144>
         {
            ++tcp_sleep_timeout;
 d0250c0:	d0a08e17 	ldw	r2,-32200(gp)
 d0250c4:	10800044 	addi	r2,r2,1
 d0250c8:	d0a08e15 	stw	r2,-32200(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 d0250cc:	e0bffd17 	ldw	r2,-12(fp)
 d0250d0:	00c341b4 	movhi	r3,3334
 d0250d4:	18f39004 	addi	r3,r3,-12736
 d0250d8:	10800324 	muli	r2,r2,12
 d0250dc:	10c5883a 	add	r2,r2,r3
 d0250e0:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 d0250e4:	e0bffd17 	ldw	r2,-12(fp)
 d0250e8:	00c341b4 	movhi	r3,3334
 d0250ec:	18f39004 	addi	r3,r3,-12736
 d0250f0:	10800324 	muli	r2,r2,12
 d0250f4:	10c5883a 	add	r2,r2,r3
 d0250f8:	10800104 	addi	r2,r2,4
 d0250fc:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 d025100:	0009883a 	mov	r4,zero
 d025104:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         return;
 d025108:	00000f06 	br	d025148 <tcp_sleep+0x18c>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 d02510c:	e0bffd17 	ldw	r2,-12(fp)
 d025110:	10800044 	addi	r2,r2,1
 d025114:	e0bffd15 	stw	r2,-12(fp)
 d025118:	e0bffd17 	ldw	r2,-12(fp)
 d02511c:	10800510 	cmplti	r2,r2,20
 d025120:	103fad1e 	bne	r2,zero,d024fd8 <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 d025124:	00c34174 	movhi	r3,3333
 d025128:	18cac804 	addi	r3,r3,11040
 d02512c:	e0bffd17 	ldw	r2,-12(fp)
 d025130:	18800015 	stw	r2,0(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 d025134:	0009883a 	mov	r4,zero
 d025138:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 d02513c:	d0252d40 	call	d0252d4 <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 d025140:	0009883a 	mov	r4,zero
 d025144:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
}
 d025148:	e037883a 	mov	sp,fp
 d02514c:	dfc00117 	ldw	ra,4(sp)
 d025150:	df000017 	ldw	fp,0(sp)
 d025154:	dec00204 	addi	sp,sp,8
 d025158:	f800283a 	ret

0d02515c <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 d02515c:	defffc04 	addi	sp,sp,-16
 d025160:	dfc00315 	stw	ra,12(sp)
 d025164:	df000215 	stw	fp,8(sp)
 d025168:	df000204 	addi	fp,sp,8
 d02516c:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 d025170:	d00e1ac0 	call	d00e1ac <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 d025174:	e03ffe15 	stw	zero,-8(fp)
 d025178:	00003006 	br	d02523c <tcp_wakeup+0xe0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 d02517c:	e0bffe17 	ldw	r2,-8(fp)
 d025180:	00c341b4 	movhi	r3,3334
 d025184:	18f39004 	addi	r3,r3,-12736
 d025188:	10800324 	muli	r2,r2,12
 d02518c:	10c5883a 	add	r2,r2,r3
 d025190:	10800017 	ldw	r2,0(r2)
 d025194:	1005003a 	cmpeq	r2,r2,zero
 d025198:	1000251e 	bne	r2,zero,d025230 <tcp_wakeup+0xd4>
 d02519c:	e0bffe17 	ldw	r2,-8(fp)
 d0251a0:	00c341b4 	movhi	r3,3334
 d0251a4:	18f39004 	addi	r3,r3,-12736
 d0251a8:	10800324 	muli	r2,r2,12
 d0251ac:	10c5883a 	add	r2,r2,r3
 d0251b0:	10800104 	addi	r2,r2,4
 d0251b4:	10c00017 	ldw	r3,0(r2)
 d0251b8:	e0bfff17 	ldw	r2,-4(fp)
 d0251bc:	18801c1e 	bne	r3,r2,d025230 <tcp_wakeup+0xd4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 d0251c0:	e0bffe17 	ldw	r2,-8(fp)
 d0251c4:	00c341b4 	movhi	r3,3334
 d0251c8:	18f39004 	addi	r3,r3,-12736
 d0251cc:	10800324 	muli	r2,r2,12
 d0251d0:	10c5883a 	add	r2,r2,r3
 d0251d4:	10800204 	addi	r2,r2,8
 d0251d8:	11000017 	ldw	r4,0(r2)
 d0251dc:	d01364c0 	call	d01364c <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 d0251e0:	e0bffe17 	ldw	r2,-8(fp)
 d0251e4:	00c341b4 	movhi	r3,3334
 d0251e8:	18f39004 	addi	r3,r3,-12736
 d0251ec:	10800324 	muli	r2,r2,12
 d0251f0:	10c5883a 	add	r2,r2,r3
 d0251f4:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 d0251f8:	e0bffe17 	ldw	r2,-8(fp)
 d0251fc:	00c341b4 	movhi	r3,3334
 d025200:	18f39004 	addi	r3,r3,-12736
 d025204:	10800324 	muli	r2,r2,12
 d025208:	10c5883a 	add	r2,r2,r3
 d02520c:	10800104 	addi	r2,r2,4
 d025210:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 d025214:	00834174 	movhi	r2,3333
 d025218:	108ac504 	addi	r2,r2,11028
 d02521c:	10800017 	ldw	r2,0(r2)
 d025220:	10c00044 	addi	r3,r2,1
 d025224:	00834174 	movhi	r2,3333
 d025228:	108ac504 	addi	r2,r2,11028
 d02522c:	10c00015 	stw	r3,0(r2)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 d025230:	e0bffe17 	ldw	r2,-8(fp)
 d025234:	10800044 	addi	r2,r2,1
 d025238:	e0bffe15 	stw	r2,-8(fp)
 d02523c:	e0bffe17 	ldw	r2,-8(fp)
 d025240:	10800510 	cmplti	r2,r2,20
 d025244:	103fcd1e 	bne	r2,zero,d02517c <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 d025248:	d00e2380 	call	d00e238 <OSSchedUnlock>
}
 d02524c:	e037883a 	mov	sp,fp
 d025250:	dfc00117 	ldw	ra,4(sp)
 d025254:	df000017 	ldw	fp,0(sp)
 d025258:	dec00204 	addi	sp,sp,8
 d02525c:	f800283a 	ret

0d025260 <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 d025260:	deffe104 	addi	sp,sp,-124
 d025264:	dfc01e15 	stw	ra,120(sp)
 d025268:	df001d15 	stw	fp,116(sp)
 d02526c:	df001d04 	addi	fp,sp,116
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 d025270:	e17fe404 	addi	r5,fp,-112
 d025274:	01003fc4 	movi	r4,255
 d025278:	d0152280 	call	d015228 <OSTaskQuery>
 d02527c:	e0bfe345 	stb	r2,-115(fp)

   if (err == OS_NO_ERR)
 d025280:	e0bfe343 	ldbu	r2,-115(fp)
 d025284:	1004c03a 	cmpne	r2,r2,zero
 d025288:	1000051e 	bne	r2,zero,d0252a0 <TK_OSTaskQuery+0x40>
   {
      task_prio = task_data.OSTCBPrio;
 d02528c:	e0bff083 	ldbu	r2,-62(fp)
 d025290:	e0bfe305 	stb	r2,-116(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 d025294:	e0bfe303 	ldbu	r2,-116(fp)
 d025298:	e0bfff15 	stw	r2,-4(fp)
 d02529c:	00000706 	br	d0252bc <TK_OSTaskQuery+0x5c>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 d0252a0:	01034174 	movhi	r4,3333
 d0252a4:	213c3004 	addi	r4,r4,-3904
 d0252a8:	d0029980 	call	d002998 <printf>
      panic("TK_OSTaskQuery");
 d0252ac:	01034174 	movhi	r4,3333
 d0252b0:	213c3d04 	addi	r4,r4,-3852
 d0252b4:	d0246440 	call	d024644 <panic>
      return 0;
 d0252b8:	e03fff15 	stw	zero,-4(fp)
 d0252bc:	e0bfff17 	ldw	r2,-4(fp)
   }
   
   return task_prio;
}
 d0252c0:	e037883a 	mov	sp,fp
 d0252c4:	dfc00117 	ldw	ra,4(sp)
 d0252c8:	df000017 	ldw	fp,0(sp)
 d0252cc:	dec00204 	addi	sp,sp,8
 d0252d0:	f800283a 	ret

0d0252d4 <tk_yield>:



void
tk_yield(void)
{
 d0252d4:	defffe04 	addi	sp,sp,-8
 d0252d8:	dfc00115 	stw	ra,4(sp)
 d0252dc:	df000015 	stw	fp,0(sp)
 d0252e0:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 d0252e4:	01000044 	movi	r4,1
 d0252e8:	d0153e80 	call	d0153e8 <OSTimeDly>
}
 d0252ec:	e037883a 	mov	sp,fp
 d0252f0:	dfc00117 	ldw	ra,4(sp)
 d0252f4:	df000017 	ldw	fp,0(sp)
 d0252f8:	dec00204 	addi	sp,sp,8
 d0252fc:	f800283a 	ret

0d025300 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 d025300:	deffef04 	addi	sp,sp,-68
 d025304:	dfc01015 	stw	ra,64(sp)
 d025308:	df000f15 	stw	fp,60(sp)
 d02530c:	df000f04 	addi	fp,sp,60
 d025310:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 d025314:	e13fff17 	ldw	r4,-4(fp)
 d025318:	01434174 	movhi	r5,3333
 d02531c:	297c4104 	addi	r5,r5,-3836
 d025320:	d02486c0 	call	d02486c <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 d025324:	00834174 	movhi	r2,3333
 d025328:	108a9104 	addi	r2,r2,10820
 d02532c:	11800017 	ldw	r6,0(r2)
 d025330:	e13fff17 	ldw	r4,-4(fp)
 d025334:	01434174 	movhi	r5,3333
 d025338:	297c4704 	addi	r5,r5,-3812
 d02533c:	d02486c0 	call	d02486c <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 d025340:	e13fff17 	ldw	r4,-4(fp)
 d025344:	01434174 	movhi	r5,3333
 d025348:	297c4f04 	addi	r5,r5,-3780
 d02534c:	d02486c0 	call	d02486c <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 d025350:	e03ff515 	stw	zero,-44(fp)
 d025354:	00005106 	br	d02549c <tk_stats+0x19c>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 d025358:	e0bff517 	ldw	r2,-44(fp)
 d02535c:	00c341b4 	movhi	r3,3334
 d025360:	18f13304 	addi	r3,r3,-15156
 d025364:	1085883a 	add	r2,r2,r2
 d025368:	1085883a 	add	r2,r2,r2
 d02536c:	10c5883a 	add	r2,r2,r3
 d025370:	10800017 	ldw	r2,0(r2)
 d025374:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 d025378:	e0bff417 	ldw	r2,-48(fp)
 d02537c:	1005003a 	cmpeq	r2,r2,zero
 d025380:	1000431e 	bne	r2,zero,d025490 <tk_stats+0x190>
 d025384:	e0bff417 	ldw	r2,-48(fp)
 d025388:	10800060 	cmpeqi	r2,r2,1
 d02538c:	1000401e 	bne	r2,zero,d025490 <tk_stats+0x190>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 d025390:	e0bff417 	ldw	r2,-48(fp)
 d025394:	10800c83 	ldbu	r2,50(r2)
 d025398:	11003fcc 	andi	r4,r2,255
 d02539c:	e17ff604 	addi	r5,fp,-40
 d0253a0:	e1bffe44 	addi	r6,fp,-7
 d0253a4:	d01486c0 	call	d01486c <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 d0253a8:	e0bff417 	ldw	r2,-48(fp)
 d0253ac:	10800c83 	ldbu	r2,50(r2)
 d0253b0:	11c03fcc 	andi	r7,r2,255
 d0253b4:	e0bff417 	ldw	r2,-48(fp)
 d0253b8:	10800c03 	ldbu	r2,48(r2)
 d0253bc:	10803fcc 	andi	r2,r2,255
 d0253c0:	e1bff604 	addi	r6,fp,-40
 d0253c4:	d8800015 	stw	r2,0(sp)
 d0253c8:	e13fff17 	ldw	r4,-4(fp)
 d0253cc:	01434174 	movhi	r5,3333
 d0253d0:	297c5f04 	addi	r5,r5,-3716
 d0253d4:	d02486c0 	call	d02486c <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 d0253d8:	e0bff417 	ldw	r2,-48(fp)
 d0253dc:	10800217 	ldw	r2,8(r2)
 d0253e0:	1005003a 	cmpeq	r2,r2,zero
 d0253e4:	1000261e 	bne	r2,zero,d025480 <tk_stats+0x180>
 d0253e8:	e0bff417 	ldw	r2,-48(fp)
 d0253ec:	10800317 	ldw	r2,12(r2)
 d0253f0:	1005003a 	cmpeq	r2,r2,zero
 d0253f4:	1000221e 	bne	r2,zero,d025480 <tk_stats+0x180>
      {
         sp = tcb->OSTCBStkBottom + 1;
 d0253f8:	e0bff417 	ldw	r2,-48(fp)
 d0253fc:	10800217 	ldw	r2,8(r2)
 d025400:	10800104 	addi	r2,r2,4
 d025404:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 d025408:	00000306 	br	d025418 <tk_stats+0x118>
            sp++;
 d02540c:	e0bff317 	ldw	r2,-52(fp)
 d025410:	10800104 	addi	r2,r2,4
 d025414:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 d025418:	e0bff317 	ldw	r2,-52(fp)
 d02541c:	10800017 	ldw	r2,0(r2)
 d025420:	1005003a 	cmpeq	r2,r2,zero
 d025424:	103ff91e 	bne	r2,zero,d02540c <tk_stats+0x10c>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 d025428:	e0bff417 	ldw	r2,-48(fp)
 d02542c:	11000317 	ldw	r4,12(r2)
 d025430:	e0fff317 	ldw	r3,-52(fp)
 d025434:	e0bff417 	ldw	r2,-48(fp)
 d025438:	10800217 	ldw	r2,8(r2)
 d02543c:	1885c83a 	sub	r2,r3,r2
 d025440:	1005d0ba 	srai	r2,r2,2
 d025444:	2085c83a 	sub	r2,r4,r2
 d025448:	1085883a 	add	r2,r2,r2
 d02544c:	1085883a 	add	r2,r2,r2
 d025450:	e0bff215 	stw	r2,-56(fp)
         ns_printf(pio, "%6d,      %6d\n",
 d025454:	e0bff417 	ldw	r2,-48(fp)
 d025458:	10800317 	ldw	r2,12(r2)
 d02545c:	1085883a 	add	r2,r2,r2
 d025460:	1085883a 	add	r2,r2,r2
 d025464:	100d883a 	mov	r6,r2
 d025468:	e13fff17 	ldw	r4,-4(fp)
 d02546c:	01434174 	movhi	r5,3333
 d025470:	297c6704 	addi	r5,r5,-3684
 d025474:	e1fff217 	ldw	r7,-56(fp)
 d025478:	d02486c0 	call	d02486c <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 d02547c:	00000406 	br	d025490 <tk_stats+0x190>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 d025480:	e13fff17 	ldw	r4,-4(fp)
 d025484:	01434174 	movhi	r5,3333
 d025488:	297c6b04 	addi	r5,r5,-3668
 d02548c:	d02486c0 	call	d02486c <ns_printf>
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 d025490:	e0bff517 	ldw	r2,-44(fp)
 d025494:	10800044 	addi	r2,r2,1
 d025498:	e0bff515 	stw	r2,-44(fp)
 d02549c:	e0bff517 	ldw	r2,-44(fp)
 d0254a0:	10800550 	cmplti	r2,r2,21
 d0254a4:	103fac1e 	bne	r2,zero,d025358 <tk_stats+0x58>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 d0254a8:	00834174 	movhi	r2,3333
 d0254ac:	108ac404 	addi	r2,r2,11024
 d0254b0:	11800017 	ldw	r6,0(r2)
 d0254b4:	00834174 	movhi	r2,3333
 d0254b8:	108ac504 	addi	r2,r2,11028
 d0254bc:	11c00017 	ldw	r7,0(r2)
 d0254c0:	e13fff17 	ldw	r4,-4(fp)
 d0254c4:	01434174 	movhi	r5,3333
 d0254c8:	297c6f04 	addi	r5,r5,-3652
 d0254cc:	d02486c0 	call	d02486c <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 d0254d0:	00834174 	movhi	r2,3333
 d0254d4:	108ac804 	addi	r2,r2,11040
 d0254d8:	11800017 	ldw	r6,0(r2)
 d0254dc:	d1e08e17 	ldw	r7,-32200(gp)
 d0254e0:	e13fff17 	ldw	r4,-4(fp)
 d0254e4:	01434174 	movhi	r5,3333
 d0254e8:	297c7b04 	addi	r5,r5,-3604
 d0254ec:	d02486c0 	call	d02486c <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 d0254f0:	0005883a 	mov	r2,zero
}
 d0254f4:	e037883a 	mov	sp,fp
 d0254f8:	dfc00117 	ldw	ra,4(sp)
 d0254fc:	df000017 	ldw	fp,0(sp)
 d025500:	dec00204 	addi	sp,sp,8
 d025504:	f800283a 	ret

0d025508 <dhc_get_srv_ipaddr>:
 * RETURNS: 
 */

ip_addr 
dhc_get_srv_ipaddr(u_char *options /* after magic cookie */) 
{
 d025508:	defffa04 	addi	sp,sp,-24
 d02550c:	dfc00515 	stw	ra,20(sp)
 d025510:	df000415 	stw	fp,16(sp)
 d025514:	df000404 	addi	fp,sp,16
 d025518:	e13fff15 	stw	r4,-4(fp)
    u_char * opts;
    u_char   optlen;
   ip_addr srv_ipaddr = 0;
 d02551c:	e03ffc15 	stw	zero,-16(fp)

   if ((opts = find_opt(DHOP_SERVER, options)) != NULL) 
 d025520:	01000d84 	movi	r4,54
 d025524:	e17fff17 	ldw	r5,-4(fp)
 d025528:	d0284480 	call	d028448 <find_opt>
 d02552c:	e0bffe15 	stw	r2,-8(fp)
 d025530:	e0bffe17 	ldw	r2,-8(fp)
 d025534:	1005003a 	cmpeq	r2,r2,zero
 d025538:	1000111e 	bne	r2,zero,d025580 <dhc_get_srv_ipaddr+0x78>
   {
      opts++;
 d02553c:	e0bffe17 	ldw	r2,-8(fp)
 d025540:	10800044 	addi	r2,r2,1
 d025544:	e0bffe15 	stw	r2,-8(fp)
      optlen = *opts;
 d025548:	e0bffe17 	ldw	r2,-8(fp)
 d02554c:	10800003 	ldbu	r2,0(r2)
 d025550:	e0bffd05 	stb	r2,-12(fp)
      opts++;
 d025554:	e0bffe17 	ldw	r2,-8(fp)
 d025558:	10800044 	addi	r2,r2,1
 d02555c:	e0bffe15 	stw	r2,-8(fp)
      srv_ipaddr = dh_getlong(opts);
 d025560:	e13ffe17 	ldw	r4,-8(fp)
 d025564:	d0276b80 	call	d0276b8 <dh_getlong>
 d025568:	e0bffc15 	stw	r2,-16(fp)
      opts += optlen;
 d02556c:	e0bffd03 	ldbu	r2,-12(fp)
 d025570:	1007883a 	mov	r3,r2
 d025574:	e0bffe17 	ldw	r2,-8(fp)
 d025578:	10c5883a 	add	r2,r2,r3
 d02557c:	e0bffe15 	stw	r2,-8(fp)
   }

   return (srv_ipaddr);
 d025580:	e0bffc17 	ldw	r2,-16(fp)
} 
 d025584:	e037883a 	mov	sp,fp
 d025588:	dfc00117 	ldw	ra,4(sp)
 d02558c:	df000017 	ldw	fp,0(sp)
 d025590:	dec00204 	addi	sp,sp,8
 d025594:	f800283a 	ret

0d025598 <dhc_init>:
 * RETURNS: Returns 0 if OK, else negative error code from net.h file 
 */

int
dhc_init(void)
{
 d025598:	defffb04 	addi	sp,sp,-20
 d02559c:	dfc00415 	stw	ra,16(sp)
 d0255a0:	df000315 	stw	fp,12(sp)
 d0255a4:	df000304 	addi	fp,sp,12
   int   i;

   /* open UDP connection to receive incoming DHCP replys */
   dhc_conn = udp_open(0L,    /* wildcard foriegn host */
 d0255a8:	00bfff44 	movi	r2,-3
 d0255ac:	d8800015 	stw	r2,0(sp)
 d0255b0:	0009883a 	mov	r4,zero
 d0255b4:	014010c4 	movi	r5,67
 d0255b8:	01801104 	movi	r6,68
 d0255bc:	01c340b4 	movhi	r7,3330
 d0255c0:	39d5a604 	addi	r7,r7,22168
 d0255c4:	d028f380 	call	d028f38 <udp_open>
 d0255c8:	d0a08f15 	stw	r2,-32196(gp)
      BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT,
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
 d0255cc:	d0a08f17 	ldw	r2,-32196(gp)
 d0255d0:	1004c03a 	cmpne	r2,r2,zero
 d0255d4:	1000031e 	bne	r2,zero,d0255e4 <dhc_init+0x4c>
      return ENP_RESOURCE;
 d0255d8:	00bffa84 	movi	r2,-22
 d0255dc:	e0bfff15 	stw	r2,-4(fp)
 d0255e0:	00001606 	br	d02563c <dhc_init+0xa4>

   for (i = 0; i < MAXNETS; i++)
 d0255e4:	e03ffe15 	stw	zero,-8(fp)
 d0255e8:	00001006 	br	d02562c <dhc_init+0x94>
   {
      dhc_states[i].state = DHCS_UNUSED;
 d0255ec:	e0bffe17 	ldw	r2,-8(fp)
 d0255f0:	00c341b4 	movhi	r3,3334
 d0255f4:	18f2cb04 	addi	r3,r3,-13524
 d0255f8:	10800f24 	muli	r2,r2,60
 d0255fc:	10c5883a 	add	r2,r2,r3
 d025600:	10000015 	stw	zero,0(r2)
      dhc_states[i].tries = 0;
 d025604:	e0bffe17 	ldw	r2,-8(fp)
 d025608:	00c341b4 	movhi	r3,3334
 d02560c:	18f2cb04 	addi	r3,r3,-13524
 d025610:	10800f24 	muli	r2,r2,60
 d025614:	10c5883a 	add	r2,r2,r3
 d025618:	10800104 	addi	r2,r2,4
 d02561c:	10000015 	stw	zero,0(r2)
      dhc_upcall, DHCPDATA);

   if (!dhc_conn)
      return ENP_RESOURCE;

   for (i = 0; i < MAXNETS; i++)
 d025620:	e0bffe17 	ldw	r2,-8(fp)
 d025624:	10800044 	addi	r2,r2,1
 d025628:	e0bffe15 	stw	r2,-8(fp)
 d02562c:	e0bffe17 	ldw	r2,-8(fp)
 d025630:	10800110 	cmplti	r2,r2,4
 d025634:	103fed1e 	bne	r2,zero,d0255ec <dhc_init+0x54>
   {
      dhc_states[i].state = DHCS_UNUSED;
      dhc_states[i].tries = 0;
   }

   return 0;
 d025638:	e03fff15 	stw	zero,-4(fp)
 d02563c:	e0bfff17 	ldw	r2,-4(fp)
}
 d025640:	e037883a 	mov	sp,fp
 d025644:	dfc00117 	ldw	ra,4(sp)
 d025648:	df000017 	ldw	fp,0(sp)
 d02564c:	dec00204 	addi	sp,sp,8
 d025650:	f800283a 	ret

0d025654 <dhc_set_callback>:
 * RETURNS: 
 */

void
dhc_set_callback(int iface, int (*routine)(int,int) )
{
 d025654:	defffd04 	addi	sp,sp,-12
 d025658:	df000215 	stw	fp,8(sp)
 d02565c:	df000204 	addi	fp,sp,8
 d025660:	e13ffe15 	stw	r4,-8(fp)
 d025664:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].callback = routine;
 d025668:	e0bffe17 	ldw	r2,-8(fp)
 d02566c:	00c341b4 	movhi	r3,3334
 d025670:	18f2cb04 	addi	r3,r3,-13524
 d025674:	10800f24 	muli	r2,r2,60
 d025678:	10c5883a 	add	r2,r2,r3
 d02567c:	10c00e04 	addi	r3,r2,56
 d025680:	e0bfff17 	ldw	r2,-4(fp)
 d025684:	18800015 	stw	r2,0(r3)
}
 d025688:	e037883a 	mov	sp,fp
 d02568c:	df000017 	ldw	fp,0(sp)
 d025690:	dec00104 	addi	sp,sp,4
 d025694:	f800283a 	ret

0d025698 <dhc_upcall>:
 * returned
 */

int
dhc_upcall(PACKET pkt, void * data)
{
 d025698:	defff204 	addi	sp,sp,-56
 d02569c:	dfc00d15 	stw	ra,52(sp)
 d0256a0:	df000c15 	stw	fp,48(sp)
 d0256a4:	dc000b15 	stw	r16,44(sp)
 d0256a8:	df000b04 	addi	fp,sp,44
 d0256ac:	e13ffb15 	stw	r4,-20(fp)
 d0256b0:	e17ffc15 	stw	r5,-16(fp)
   struct bootp * bp;
   int      len      =  pkt->nb_plen;  /* len of UDP data - the bootp/dhcp struct */
 d0256b4:	e0bffb17 	ldw	r2,-20(fp)
 d0256b8:	10800417 	ldw	r2,16(r2)
 d0256bc:	e0bff915 	stw	r2,-28(fp)
   int      dhcptype =  0;    /* DHCP type - not valid if bootp */
 d0256c0:	e03ff815 	stw	zero,-32(fp)
   int      e;
   int      iface;
   u_char * opts;          /* scratch options pointer */

   if (data != DHCPDATA)
 d0256c4:	e0bffc17 	ldw	r2,-16(fp)
 d0256c8:	10bfff60 	cmpeqi	r2,r2,-3
 d0256cc:	1000041e 	bne	r2,zero,d0256e0 <dhc_upcall+0x48>
   {
      dtrap();
 d0256d0:	d0293e80 	call	d0293e8 <dtrap>
      return ENP_LOGIC;    /* internal logic error */
 d0256d4:	00bffd44 	movi	r2,-11
 d0256d8:	e0bffe15 	stw	r2,-8(fp)
 d0256dc:	0001f306 	br	d025eac <dhc_upcall+0x814>
   }

   /* punt if packet didn't come in a net we sent on */
   iface = net_num(pkt->net);
 d0256e0:	e0bffb17 	ldw	r2,-20(fp)
 d0256e4:	11000617 	ldw	r4,24(r2)
 d0256e8:	d0225980 	call	d022598 <if_netnumber>
 d0256ec:	e0bff615 	stw	r2,-40(fp)
   if (dhc_states[iface].state == DHCS_UNUSED)
 d0256f0:	e0bff617 	ldw	r2,-40(fp)
 d0256f4:	00c341b4 	movhi	r3,3334
 d0256f8:	18f2cb04 	addi	r3,r3,-13524
 d0256fc:	10800f24 	muli	r2,r2,60
 d025700:	10c5883a 	add	r2,r2,r3
 d025704:	10800017 	ldw	r2,0(r2)
 d025708:	1004c03a 	cmpne	r2,r2,zero
 d02570c:	1000031e 	bne	r2,zero,d02571c <dhc_upcall+0x84>
      return ENP_NOT_MINE;
 d025710:	00c00084 	movi	r3,2
 d025714:	e0fffe15 	stw	r3,-8(fp)
 d025718:	0001e406 	br	d025eac <dhc_upcall+0x814>

   bp = (struct bootp *)pkt->nb_prot;
 d02571c:	e0bffb17 	ldw	r2,-20(fp)
 d025720:	10800317 	ldw	r2,12(r2)
 d025724:	e0bffa15 	stw	r2,-24(fp)

   /*   Validate various fields   */
   if ((len < (sizeof(struct bootp)-BOOTP_OPTSIZE) ) || 
 d025728:	e0bff917 	ldw	r2,-28(fp)
 d02572c:	10803b30 	cmpltui	r2,r2,236
 d025730:	10000b1e 	bne	r2,zero,d025760 <dhc_upcall+0xc8>
 d025734:	e0bffa17 	ldw	r2,-24(fp)
 d025738:	10800003 	ldbu	r2,0(r2)
 d02573c:	10803fcc 	andi	r2,r2,255
 d025740:	10800098 	cmpnei	r2,r2,2
 d025744:	1000061e 	bne	r2,zero,d025760 <dhc_upcall+0xc8>
 d025748:	e0bffa17 	ldw	r2,-24(fp)
 d02574c:	10803b04 	addi	r2,r2,236
 d025750:	10c00017 	ldw	r3,0(r2)
 d025754:	0098d534 	movhi	r2,25428
 d025758:	10a098c4 	addi	r2,r2,-32157
 d02575c:	18800726 	beq	r3,r2,d02577c <dhc_upcall+0xe4>
       (bp->op != BOOTREPLY) ||
       (*(u_long*)(&bp->options) != RFC1084_MAGIC_COOKIE))
   {
      dtrap();
 d025760:	d0293e80 	call	d0293e8 <dtrap>
      dsc_errors++;
 d025764:	d0a09017 	ldw	r2,-32192(gp)
 d025768:	10800044 	addi	r2,r2,1
 d02576c:	d0a09015 	stw	r2,-32192(gp)
      return ENP_NOT_MINE;
 d025770:	01000084 	movi	r4,2
 d025774:	e13ffe15 	stw	r4,-8(fp)
 d025778:	0001cc06 	br	d025eac <dhc_upcall+0x814>
   }

   /* punt offers or replys which are not for me */
   if(MEMCMP(bp->chaddr, pkt->net->mib.ifPhysAddress, pkt->net->n_hal))
 d02577c:	e0bffa17 	ldw	r2,-24(fp)
 d025780:	11000704 	addi	r4,r2,28
 d025784:	e0bffb17 	ldw	r2,-20(fp)
 d025788:	10800617 	ldw	r2,24(r2)
 d02578c:	11401717 	ldw	r5,92(r2)
 d025790:	e0bffb17 	ldw	r2,-20(fp)
 d025794:	10800617 	ldw	r2,24(r2)
 d025798:	11801117 	ldw	r6,68(r2)
 d02579c:	d049ed40 	call	d049ed4 <memcmp>
 d0257a0:	1005003a 	cmpeq	r2,r2,zero
 d0257a4:	1000031e 	bne	r2,zero,d0257b4 <dhc_upcall+0x11c>
      return ENP_NOT_MINE;    /* not an error, just ignore it */
 d0257a8:	00800084 	movi	r2,2
 d0257ac:	e0bffe15 	stw	r2,-8(fp)
 d0257b0:	0001be06 	br	d025eac <dhc_upcall+0x814>

   /* see if it's full DHCP or plain bootp by looking for dhcp type option */
   opts = find_opt(DHOP_TYPE ,&bp->options[4]);
 d0257b4:	e0bffa17 	ldw	r2,-24(fp)
 d0257b8:	10803b04 	addi	r2,r2,236
 d0257bc:	11400104 	addi	r5,r2,4
 d0257c0:	01000d44 	movi	r4,53
 d0257c4:	d0284480 	call	d028448 <find_opt>
 d0257c8:	e0bff515 	stw	r2,-44(fp)
   if (opts && *opts == DHOP_TYPE)
 d0257cc:	e0bff517 	ldw	r2,-44(fp)
 d0257d0:	1005003a 	cmpeq	r2,r2,zero
 d0257d4:	1000101e 	bne	r2,zero,d025818 <dhc_upcall+0x180>
 d0257d8:	e0bff517 	ldw	r2,-44(fp)
 d0257dc:	10800003 	ldbu	r2,0(r2)
 d0257e0:	10803fcc 	andi	r2,r2,255
 d0257e4:	10800d58 	cmpnei	r2,r2,53
 d0257e8:	10000b1e 	bne	r2,zero,d025818 <dhc_upcall+0x180>
   {
      dhcptype = *(opts+2);
 d0257ec:	e0bff517 	ldw	r2,-44(fp)
 d0257f0:	10800084 	addi	r2,r2,2
 d0257f4:	10800003 	ldbu	r2,0(r2)
 d0257f8:	10803fcc 	andi	r2,r2,255
 d0257fc:	e0bff815 	stw	r2,-32(fp)
      bp->op |= ISDHCP;       /* tag packet for isdhcp() macro */
 d025800:	e0bffa17 	ldw	r2,-24(fp)
 d025804:	10800003 	ldbu	r2,0(r2)
 d025808:	10800114 	ori	r2,r2,4
 d02580c:	1007883a 	mov	r3,r2
 d025810:	e0bffa17 	ldw	r2,-24(fp)
 d025814:	10c00005 	stb	r3,0(r2)
   }

   if (isdhcp(bp))
 d025818:	e0bffa17 	ldw	r2,-24(fp)
 d02581c:	10800003 	ldbu	r2,0(r2)
 d025820:	10803fcc 	andi	r2,r2,255
 d025824:	1080010c 	andi	r2,r2,4
 d025828:	1005003a 	cmpeq	r2,r2,zero
 d02582c:	10017e1e 	bne	r2,zero,d025e28 <dhc_upcall+0x790>
   {
      switch (dhcptype)
 d025830:	e0fff817 	ldw	r3,-32(fp)
 d025834:	e0ffff15 	stw	r3,-4(fp)
 d025838:	e13fff17 	ldw	r4,-4(fp)
 d02583c:	20800148 	cmpgei	r2,r4,5
 d025840:	1000071e 	bne	r2,zero,d025860 <dhc_upcall+0x1c8>
 d025844:	e0ffff17 	ldw	r3,-4(fp)
 d025848:	188000c8 	cmpgei	r2,r3,3
 d02584c:	1000081e 	bne	r2,zero,d025870 <dhc_upcall+0x1d8>
 d025850:	e13fff17 	ldw	r4,-4(fp)
 d025854:	20800060 	cmpeqi	r2,r4,1
 d025858:	1000051e 	bne	r2,zero,d025870 <dhc_upcall+0x1d8>
 d02585c:	00000a06 	br	d025888 <dhc_upcall+0x1f0>
 d025860:	e0ffff17 	ldw	r3,-4(fp)
 d025864:	188001e0 	cmpeqi	r2,r3,7
 d025868:	1000011e 	bne	r2,zero,d025870 <dhc_upcall+0x1d8>
 d02586c:	00000606 	br	d025888 <dhc_upcall+0x1f0>
      {
      case DHCP_DISCOVER:
      case DHCP_REQUEST:
      case DHCP_DECLINE:
      case DHCP_RELEASE:
         dsc_errors++;     /* these should only be upcalled to a server */
 d025870:	d0a09017 	ldw	r2,-32192(gp)
 d025874:	10800044 	addi	r2,r2,1
 d025878:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 d02587c:	01000084 	movi	r4,2
 d025880:	e13ffe15 	stw	r4,-8(fp)
 d025884:	00018906 	br	d025eac <dhc_upcall+0x814>
      }

      switch (dhc_states[iface].state)
 d025888:	e0bff617 	ldw	r2,-40(fp)
 d02588c:	00c341b4 	movhi	r3,3334
 d025890:	18f2cb04 	addi	r3,r3,-13524
 d025894:	10800f24 	muli	r2,r2,60
 d025898:	10c5883a 	add	r2,r2,r3
 d02589c:	10800017 	ldw	r2,0(r2)
 d0258a0:	e0bffd15 	stw	r2,-12(fp)
 d0258a4:	e0fffd17 	ldw	r3,-12(fp)
 d0258a8:	18800268 	cmpgeui	r2,r3,9
 d0258ac:	1001541e 	bne	r2,zero,d025e00 <dhc_upcall+0x768>
 d0258b0:	e13ffd17 	ldw	r4,-12(fp)
 d0258b4:	e13ffd17 	ldw	r4,-12(fp)
 d0258b8:	2105883a 	add	r2,r4,r4
 d0258bc:	1087883a 	add	r3,r2,r2
 d0258c0:	008340b4 	movhi	r2,3330
 d0258c4:	10963504 	addi	r2,r2,22740
 d0258c8:	1885883a 	add	r2,r3,r2
 d0258cc:	10800017 	ldw	r2,0(r2)
 d0258d0:	1000683a 	jmp	r2
 d0258d4:	0d025e00 	call	d025e0 <OSCtxSw_SWITCH_PC+0xd025a0>
 d0258d8:	0d0258f8 	rdprs	r20,at,2403
 d0258dc:	0d0258f8 	rdprs	r20,at,2403
 d0258e0:	0d025b4c 	andi	r20,at,2413
 d0258e4:	0d025910 	cmplti	r20,at,2404
 d0258e8:	0d025a94 	ori	r20,at,2410
 d0258ec:	0d0258f8 	rdprs	r20,at,2403
 d0258f0:	0d025a94 	ori	r20,at,2410
 d0258f4:	0d025a94 	ori	r20,at,2410
      case DHCS_INITREBOOT:
         /* How can we receive any response when we never sent one */
      case DHCS_BOUND:
         /* If there are multiple DHCP Servers, and one of them is slow
            in responding, we might get OFFER pkts when are in BOUND state */
         dsc_errors++;     /* these should only be upcalled to a server */
 d0258f8:	d0a09017 	ldw	r2,-32192(gp)
 d0258fc:	10800044 	addi	r2,r2,1
 d025900:	d0a09015 	stw	r2,-32192(gp)
         return ENP_NOT_MINE;
 d025904:	00800084 	movi	r2,2
 d025908:	e0bffe15 	stw	r2,-8(fp)
 d02590c:	00016706 	br	d025eac <dhc_upcall+0x814>
      case DHCS_SELECTING:
         /* We will respond to the first offer packet that we receive ) */
         if ( dhcptype == DHCP_OFFER ) /* got offer back from server */
 d025910:	e0bff817 	ldw	r2,-32(fp)
 d025914:	10800098 	cmpnei	r2,r2,2
 d025918:	1000521e 	bne	r2,zero,d025a64 <dhc_upcall+0x3cc>
         {
            dsc_offers++;
 d02591c:	d0a09217 	ldw	r2,-32184(gp)
 d025920:	10800044 	addi	r2,r2,1
 d025924:	d0a09215 	stw	r2,-32184(gp)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]);
 d025928:	e43ff617 	ldw	r16,-40(fp)
 d02592c:	e0bffa17 	ldw	r2,-24(fp)
 d025930:	10803b04 	addi	r2,r2,236
 d025934:	11000104 	addi	r4,r2,4
 d025938:	d0255080 	call	d025508 <dhc_get_srv_ipaddr>
 d02593c:	1009883a 	mov	r4,r2
 d025940:	00c341b4 	movhi	r3,3334
 d025944:	18f2cb04 	addi	r3,r3,-13524
 d025948:	80800f24 	muli	r2,r16,60
 d02594c:	10c5883a 	add	r2,r2,r3
 d025950:	10800d04 	addi	r2,r2,52
 d025954:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 d025958:	e0bff617 	ldw	r2,-40(fp)
 d02595c:	00c341b4 	movhi	r3,3334
 d025960:	18f2cb04 	addi	r3,r3,-13524
 d025964:	10800f24 	muli	r2,r2,60
 d025968:	10c5883a 	add	r2,r2,r3
 d02596c:	10800d04 	addi	r2,r2,52
 d025970:	10800017 	ldw	r2,0(r2)
 d025974:	1004c03a 	cmpne	r2,r2,zero
 d025978:	10000d1e 	bne	r2,zero,d0259b0 <dhc_upcall+0x318>
            {
               dtrap(); /* didn't receive server-identifier option */
 d02597c:	d0293e80 	call	d0293e8 <dtrap>
               dsc_errors++;
 d025980:	d0a09017 	ldw	r2,-32192(gp)
 d025984:	10800044 	addi	r2,r2,1
 d025988:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 d02598c:	e13ff617 	ldw	r4,-40(fp)
 d025990:	e0bffb17 	ldw	r2,-20(fp)
 d025994:	11400717 	ldw	r5,28(r2)
 d025998:	00c341b4 	movhi	r3,3334
 d02599c:	18f2cb04 	addi	r3,r3,-13524
 d0259a0:	20800f24 	muli	r2,r4,60
 d0259a4:	10c5883a 	add	r2,r2,r3
 d0259a8:	10800d04 	addi	r2,r2,52
 d0259ac:	11400015 	stw	r5,0(r2)
            }

            if (bp->hops)
 d0259b0:	e0bffa17 	ldw	r2,-24(fp)
 d0259b4:	108000c3 	ldbu	r2,3(r2)
 d0259b8:	10803fcc 	andi	r2,r2,255
 d0259bc:	1005003a 	cmpeq	r2,r2,zero
 d0259c0:	10000a1e 	bne	r2,zero,d0259ec <dhc_upcall+0x354>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 d0259c4:	e13ff617 	ldw	r4,-40(fp)
 d0259c8:	e0bffb17 	ldw	r2,-20(fp)
 d0259cc:	11400717 	ldw	r5,28(r2)
 d0259d0:	00c341b4 	movhi	r3,3334
 d0259d4:	18f2cb04 	addi	r3,r3,-13524
 d0259d8:	20800f24 	muli	r2,r4,60
 d0259dc:	10c5883a 	add	r2,r2,r3
 d0259e0:	10800c04 	addi	r2,r2,48
 d0259e4:	11400015 	stw	r5,0(r2)
 d0259e8:	00000706 	br	d025a08 <dhc_upcall+0x370>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 d0259ec:	e0bff617 	ldw	r2,-40(fp)
 d0259f0:	00c341b4 	movhi	r3,3334
 d0259f4:	18f2cb04 	addi	r3,r3,-13524
 d0259f8:	10800f24 	muli	r2,r2,60
 d0259fc:	10c5883a 	add	r2,r2,r3
 d025a00:	10800c04 	addi	r2,r2,48
 d025a04:	10000015 	stw	zero,0(r2)

            e = dhc_rx_offer(iface,bp,pkt->nb_plen);     /* send request */
 d025a08:	e0bffb17 	ldw	r2,-20(fp)
 d025a0c:	11800417 	ldw	r6,16(r2)
 d025a10:	e13ff617 	ldw	r4,-40(fp)
 d025a14:	e17ffa17 	ldw	r5,-24(fp)
 d025a18:	d0265fc0 	call	d0265fc <dhc_rx_offer>
 d025a1c:	e0bff715 	stw	r2,-36(fp)
            if (e)
 d025a20:	e0bff717 	ldw	r2,-36(fp)
 d025a24:	1005003a 	cmpeq	r2,r2,zero
 d025a28:	10000a1e 	bne	r2,zero,d025a54 <dhc_upcall+0x3bc>
            {
               dsc_errors++;
 d025a2c:	d0a09017 	ldw	r2,-32192(gp)
 d025a30:	10800044 	addi	r2,r2,1
 d025a34:	d0a09015 	stw	r2,-32192(gp)
               dhc_set_state(iface,DHCS_INIT);
 d025a38:	e13ff617 	ldw	r4,-40(fp)
 d025a3c:	01400044 	movi	r5,1
 d025a40:	d0283980 	call	d028398 <dhc_set_state>
               dtrap();
 d025a44:	d0293e80 	call	d0293e8 <dtrap>
               return ENP_NOT_MINE;
 d025a48:	00c00084 	movi	r3,2
 d025a4c:	e0fffe15 	stw	r3,-8(fp)
 d025a50:	00011606 	br	d025eac <dhc_upcall+0x814>
            }
            else
               dhc_set_state(iface,DHCS_REQUESTING);
 d025a54:	e13ff617 	ldw	r4,-40(fp)
 d025a58:	01400144 	movi	r5,5
 d025a5c:	d0283980 	call	d028398 <dhc_set_state>
            dsc_errors++;
            if ( dhcptype == DHCP_NAK ) 
               dsc_naks++;
            return ENP_NOT_MINE;
         }
         break;
 d025a60:	00010f06 	br	d025ea0 <dhc_upcall+0x808>
             * Report an error and remain in SELECTING state, so that 
             * an OFFER packet from another DHCP server can be 
             * accepted. If we timeout waiting for a OFFER packet, 
             * then dhc_second() will transition to DHCS_INIT state. 
             */
            dsc_errors++;
 d025a64:	d0a09017 	ldw	r2,-32192(gp)
 d025a68:	10800044 	addi	r2,r2,1
 d025a6c:	d0a09015 	stw	r2,-32192(gp)
            if ( dhcptype == DHCP_NAK ) 
 d025a70:	e0bff817 	ldw	r2,-32(fp)
 d025a74:	10800198 	cmpnei	r2,r2,6
 d025a78:	1000031e 	bne	r2,zero,d025a88 <dhc_upcall+0x3f0>
               dsc_naks++;
 d025a7c:	d0a09817 	ldw	r2,-32160(gp)
 d025a80:	10800044 	addi	r2,r2,1
 d025a84:	d0a09815 	stw	r2,-32160(gp)
            return ENP_NOT_MINE;
 d025a88:	01000084 	movi	r4,2
 d025a8c:	e13ffe15 	stw	r4,-8(fp)
 d025a90:	00010606 	br	d025eac <dhc_upcall+0x814>
      case DHCS_RENEWING:
         /* If the ACK/NACK is not from the same server which sent 
          * the OFFER packet, then discard it. in DHCS_REBOOTING 
          * state, srv_ipaddr is 0. Hence don't check in that state 
          */
         if ( dhc_states[iface].srv_ipaddr != 
 d025a94:	e0bff617 	ldw	r2,-40(fp)
 d025a98:	00c341b4 	movhi	r3,3334
 d025a9c:	18f2cb04 	addi	r3,r3,-13524
 d025aa0:	10800f24 	muli	r2,r2,60
 d025aa4:	10c5883a 	add	r2,r2,r3
 d025aa8:	10800d04 	addi	r2,r2,52
 d025aac:	14000017 	ldw	r16,0(r2)
 d025ab0:	e0bffa17 	ldw	r2,-24(fp)
 d025ab4:	10803b04 	addi	r2,r2,236
 d025ab8:	11000104 	addi	r4,r2,4
 d025abc:	d0255080 	call	d025508 <dhc_get_srv_ipaddr>
 d025ac0:	80800626 	beq	r16,r2,d025adc <dhc_upcall+0x444>
             dhc_get_srv_ipaddr(&bp->options[4]) )
         {
            dsc_errors++;
 d025ac4:	d0a09017 	ldw	r2,-32192(gp)
 d025ac8:	10800044 	addi	r2,r2,1
 d025acc:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 d025ad0:	00800084 	movi	r2,2
 d025ad4:	e0bffe15 	stw	r2,-8(fp)
 d025ad8:	0000f406 	br	d025eac <dhc_upcall+0x814>
         }
         if (dhc_states[iface].rly_ipaddr &&
 d025adc:	e0bff617 	ldw	r2,-40(fp)
 d025ae0:	00c341b4 	movhi	r3,3334
 d025ae4:	18f2cb04 	addi	r3,r3,-13524
 d025ae8:	10800f24 	muli	r2,r2,60
 d025aec:	10c5883a 	add	r2,r2,r3
 d025af0:	10800c04 	addi	r2,r2,48
 d025af4:	10800017 	ldw	r2,0(r2)
 d025af8:	1005003a 	cmpeq	r2,r2,zero
 d025afc:	1000131e 	bne	r2,zero,d025b4c <dhc_upcall+0x4b4>
 d025b00:	e0bff617 	ldw	r2,-40(fp)
 d025b04:	00c341b4 	movhi	r3,3334
 d025b08:	18f2cb04 	addi	r3,r3,-13524
 d025b0c:	10800f24 	muli	r2,r2,60
 d025b10:	10c5883a 	add	r2,r2,r3
 d025b14:	10800c04 	addi	r2,r2,48
 d025b18:	10c00017 	ldw	r3,0(r2)
 d025b1c:	e0bffb17 	ldw	r2,-20(fp)
 d025b20:	10800717 	ldw	r2,28(r2)
 d025b24:	18800926 	beq	r3,r2,d025b4c <dhc_upcall+0x4b4>
            (dhc_states[iface].rly_ipaddr != pkt->fhost))
         {
            dsc_rlyerrs++;
 d025b28:	d0a09b17 	ldw	r2,-32148(gp)
 d025b2c:	10800044 	addi	r2,r2,1
 d025b30:	d0a09b15 	stw	r2,-32148(gp)
            dsc_errors++;
 d025b34:	d0a09017 	ldw	r2,-32192(gp)
 d025b38:	10800044 	addi	r2,r2,1
 d025b3c:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 d025b40:	00c00084 	movi	r3,2
 d025b44:	e0fffe15 	stw	r3,-8(fp)
 d025b48:	0000d806 	br	d025eac <dhc_upcall+0x814>
         }
      case DHCS_REBOOTING:
         if ( dhcptype == DHCP_ACK )   /* Server OKed our request */
 d025b4c:	e0bff817 	ldw	r2,-32(fp)
 d025b50:	10800158 	cmpnei	r2,r2,5
 d025b54:	1000891e 	bne	r2,zero,d025d7c <dhc_upcall+0x6e4>
         {
            dsc_acks++;
 d025b58:	d0a09417 	ldw	r2,-32176(gp)
 d025b5c:	10800044 	addi	r2,r2,1
 d025b60:	d0a09415 	stw	r2,-32176(gp)
            dhc_extract_opts(iface,&bp->options[4]);
 d025b64:	e0bffa17 	ldw	r2,-24(fp)
 d025b68:	10803b04 	addi	r2,r2,236
 d025b6c:	11400104 	addi	r5,r2,4
 d025b70:	e13ff617 	ldw	r4,-40(fp)
 d025b74:	d0277840 	call	d027784 <dhc_extract_opts>
            if ( dhc_states[iface].lease == DHC_INFINITY )
 d025b78:	e0bff617 	ldw	r2,-40(fp)
 d025b7c:	00c341b4 	movhi	r3,3334
 d025b80:	18f2cb04 	addi	r3,r3,-13524
 d025b84:	10800f24 	muli	r2,r2,60
 d025b88:	10c5883a 	add	r2,r2,r3
 d025b8c:	10800504 	addi	r2,r2,20
 d025b90:	10800017 	ldw	r2,0(r2)
 d025b94:	10bfffd8 	cmpnei	r2,r2,-1
 d025b98:	1000111e 	bne	r2,zero,d025be0 <dhc_upcall+0x548>
            {
               dhc_states[iface].t1 = DHC_INFINITY ;
 d025b9c:	e0bff617 	ldw	r2,-40(fp)
 d025ba0:	00c341b4 	movhi	r3,3334
 d025ba4:	18f2cb04 	addi	r3,r3,-13524
 d025ba8:	10800f24 	muli	r2,r2,60
 d025bac:	10c5883a 	add	r2,r2,r3
 d025bb0:	10c00604 	addi	r3,r2,24
 d025bb4:	00bfffc4 	movi	r2,-1
 d025bb8:	18800015 	stw	r2,0(r3)
               dhc_states[iface].t2 = DHC_INFINITY ;
 d025bbc:	e0bff617 	ldw	r2,-40(fp)
 d025bc0:	00c341b4 	movhi	r3,3334
 d025bc4:	18f2cb04 	addi	r3,r3,-13524
 d025bc8:	10800f24 	muli	r2,r2,60
 d025bcc:	10c5883a 	add	r2,r2,r3
 d025bd0:	10c00704 	addi	r3,r2,28
 d025bd4:	00bfffc4 	movi	r2,-1
 d025bd8:	18800015 	stw	r2,0(r3)
 d025bdc:	00001f06 	br	d025c5c <dhc_upcall+0x5c4>
            }
            else
            {
               dhc_states[iface].t1 = dhc_states[iface].lease/2     ;
 d025be0:	e17ff617 	ldw	r5,-40(fp)
 d025be4:	e0bff617 	ldw	r2,-40(fp)
 d025be8:	00c341b4 	movhi	r3,3334
 d025bec:	18f2cb04 	addi	r3,r3,-13524
 d025bf0:	10800f24 	muli	r2,r2,60
 d025bf4:	10c5883a 	add	r2,r2,r3
 d025bf8:	10800504 	addi	r2,r2,20
 d025bfc:	10800017 	ldw	r2,0(r2)
 d025c00:	1008d07a 	srli	r4,r2,1
 d025c04:	00c341b4 	movhi	r3,3334
 d025c08:	18f2cb04 	addi	r3,r3,-13524
 d025c0c:	28800f24 	muli	r2,r5,60
 d025c10:	10c5883a 	add	r2,r2,r3
 d025c14:	10800604 	addi	r2,r2,24
 d025c18:	11000015 	stw	r4,0(r2)
               dhc_states[iface].t2 = (dhc_states[iface].lease/8)*7 ;
 d025c1c:	e17ff617 	ldw	r5,-40(fp)
 d025c20:	e0bff617 	ldw	r2,-40(fp)
 d025c24:	00c341b4 	movhi	r3,3334
 d025c28:	18f2cb04 	addi	r3,r3,-13524
 d025c2c:	10800f24 	muli	r2,r2,60
 d025c30:	10c5883a 	add	r2,r2,r3
 d025c34:	10800504 	addi	r2,r2,20
 d025c38:	10800017 	ldw	r2,0(r2)
 d025c3c:	1004d0fa 	srli	r2,r2,3
 d025c40:	110001e4 	muli	r4,r2,7
 d025c44:	00c341b4 	movhi	r3,3334
 d025c48:	18f2cb04 	addi	r3,r3,-13524
 d025c4c:	28800f24 	muli	r2,r5,60
 d025c50:	10c5883a 	add	r2,r2,r3
 d025c54:	10800704 	addi	r2,r2,28
 d025c58:	11000015 	stw	r4,0(r2)
            }
            dhc_states[iface].lease_start = cticks;   /* to calc lease expiry */
 d025c5c:	e13ff617 	ldw	r4,-40(fp)
 d025c60:	00834174 	movhi	r2,3333
 d025c64:	108ac904 	addi	r2,r2,11044
 d025c68:	11400017 	ldw	r5,0(r2)
 d025c6c:	00c341b4 	movhi	r3,3334
 d025c70:	18f2cb04 	addi	r3,r3,-13524
 d025c74:	20800f24 	muli	r2,r4,60
 d025c78:	10c5883a 	add	r2,r2,r3
 d025c7c:	10800804 	addi	r2,r2,32
 d025c80:	11400015 	stw	r5,0(r2)
            dhc_states[iface].srv_ipaddr = dhc_get_srv_ipaddr(&bp->options[4]); 
 d025c84:	e43ff617 	ldw	r16,-40(fp)
 d025c88:	e0bffa17 	ldw	r2,-24(fp)
 d025c8c:	10803b04 	addi	r2,r2,236
 d025c90:	11000104 	addi	r4,r2,4
 d025c94:	d0255080 	call	d025508 <dhc_get_srv_ipaddr>
 d025c98:	1009883a 	mov	r4,r2
 d025c9c:	00c341b4 	movhi	r3,3334
 d025ca0:	18f2cb04 	addi	r3,r3,-13524
 d025ca4:	80800f24 	muli	r2,r16,60
 d025ca8:	10c5883a 	add	r2,r2,r3
 d025cac:	10800d04 	addi	r2,r2,52
 d025cb0:	11000015 	stw	r4,0(r2)
            if (dhc_states[iface].srv_ipaddr == 0 )
 d025cb4:	e0bff617 	ldw	r2,-40(fp)
 d025cb8:	00c341b4 	movhi	r3,3334
 d025cbc:	18f2cb04 	addi	r3,r3,-13524
 d025cc0:	10800f24 	muli	r2,r2,60
 d025cc4:	10c5883a 	add	r2,r2,r3
 d025cc8:	10800d04 	addi	r2,r2,52
 d025ccc:	10800017 	ldw	r2,0(r2)
 d025cd0:	1004c03a 	cmpne	r2,r2,zero
 d025cd4:	10000d1e 	bne	r2,zero,d025d0c <dhc_upcall+0x674>
            {
               dtrap(); /* didn't receive server-identifier option */
 d025cd8:	d0293e80 	call	d0293e8 <dtrap>
               dsc_errors++;
 d025cdc:	d0a09017 	ldw	r2,-32192(gp)
 d025ce0:	10800044 	addi	r2,r2,1
 d025ce4:	d0a09015 	stw	r2,-32192(gp)
               dhc_states[iface].srv_ipaddr = pkt->fhost;   /* Try using fhost */
 d025ce8:	e13ff617 	ldw	r4,-40(fp)
 d025cec:	e0bffb17 	ldw	r2,-20(fp)
 d025cf0:	11400717 	ldw	r5,28(r2)
 d025cf4:	00c341b4 	movhi	r3,3334
 d025cf8:	18f2cb04 	addi	r3,r3,-13524
 d025cfc:	20800f24 	muli	r2,r4,60
 d025d00:	10c5883a 	add	r2,r2,r3
 d025d04:	10800d04 	addi	r2,r2,52
 d025d08:	11400015 	stw	r5,0(r2)
            }
            if (bp->hops)
 d025d0c:	e0bffa17 	ldw	r2,-24(fp)
 d025d10:	108000c3 	ldbu	r2,3(r2)
 d025d14:	10803fcc 	andi	r2,r2,255
 d025d18:	1005003a 	cmpeq	r2,r2,zero
 d025d1c:	10000a1e 	bne	r2,zero,d025d48 <dhc_upcall+0x6b0>
            {
               /* OFFER is received via DHCP Relay Agent. Remember the
                * IP addr of DHCP Relay Agent, so that packets from other
                * DHCP Relay Agents can be discarded 
                */
               dhc_states[iface].rly_ipaddr = pkt->fhost;   /* Try using fhost */
 d025d20:	e13ff617 	ldw	r4,-40(fp)
 d025d24:	e0bffb17 	ldw	r2,-20(fp)
 d025d28:	11400717 	ldw	r5,28(r2)
 d025d2c:	00c341b4 	movhi	r3,3334
 d025d30:	18f2cb04 	addi	r3,r3,-13524
 d025d34:	20800f24 	muli	r2,r4,60
 d025d38:	10c5883a 	add	r2,r2,r3
 d025d3c:	10800c04 	addi	r2,r2,48
 d025d40:	11400015 	stw	r5,0(r2)
 d025d44:	00000706 	br	d025d64 <dhc_upcall+0x6cc>
            }
            else
               dhc_states[iface].rly_ipaddr = 0;
 d025d48:	e0bff617 	ldw	r2,-40(fp)
 d025d4c:	00c341b4 	movhi	r3,3334
 d025d50:	18f2cb04 	addi	r3,r3,-13524
 d025d54:	10800f24 	muli	r2,r2,60
 d025d58:	10c5883a 	add	r2,r2,r3
 d025d5c:	10800c04 	addi	r2,r2,48
 d025d60:	10000015 	stw	zero,0(r2)

            dhc_setip(iface);
 d025d64:	e13ff617 	ldw	r4,-40(fp)
 d025d68:	d02723c0 	call	d02723c <dhc_setip>
            dhc_set_state(iface,DHCS_BOUND);
 d025d6c:	e13ff617 	ldw	r4,-40(fp)
 d025d70:	01400184 	movi	r5,6
 d025d74:	d0283980 	call	d028398 <dhc_set_state>
 d025d78:	00004906 	br	d025ea0 <dhc_upcall+0x808>
         }
         else if ( dhcptype == DHCP_NAK ) /* Server denied our request */
 d025d7c:	e0bff817 	ldw	r2,-32(fp)
 d025d80:	10800198 	cmpnei	r2,r2,6
 d025d84:	1000071e 	bne	r2,zero,d025da4 <dhc_upcall+0x70c>
         {
            dhc_set_state(iface,DHCS_INIT);
 d025d88:	e13ff617 	ldw	r4,-40(fp)
 d025d8c:	01400044 	movi	r5,1
 d025d90:	d0283980 	call	d028398 <dhc_set_state>
            dsc_naks++;
 d025d94:	d0a09817 	ldw	r2,-32160(gp)
 d025d98:	10800044 	addi	r2,r2,1
 d025d9c:	d0a09815 	stw	r2,-32160(gp)
 d025da0:	00003f06 	br	d025ea0 <dhc_upcall+0x808>
         {
            /* In REQUESTING state, we might receive a retransmitted
             * OFFER, which we should discard, but it's not an error,
             * so we log it.
             */
            if ((dhc_states[iface].state == DHCS_REQUESTING) &&
 d025da4:	e0bff617 	ldw	r2,-40(fp)
 d025da8:	00c341b4 	movhi	r3,3334
 d025dac:	18f2cb04 	addi	r3,r3,-13524
 d025db0:	10800f24 	muli	r2,r2,60
 d025db4:	10c5883a 	add	r2,r2,r3
 d025db8:	10800017 	ldw	r2,0(r2)
 d025dbc:	10800158 	cmpnei	r2,r2,5
 d025dc0:	1000091e 	bne	r2,zero,d025de8 <dhc_upcall+0x750>
 d025dc4:	e0bff817 	ldw	r2,-32(fp)
 d025dc8:	10800098 	cmpnei	r2,r2,2
 d025dcc:	1000061e 	bne	r2,zero,d025de8 <dhc_upcall+0x750>
                (dhcptype == DHCP_OFFER))
            {
               dsc_offers++;
 d025dd0:	d0a09217 	ldw	r2,-32184(gp)
 d025dd4:	10800044 	addi	r2,r2,1
 d025dd8:	d0a09215 	stw	r2,-32184(gp)
               return ENP_NOT_MINE;
 d025ddc:	01000084 	movi	r4,2
 d025de0:	e13ffe15 	stw	r4,-8(fp)
 d025de4:	00003106 	br	d025eac <dhc_upcall+0x814>
             * only receive ACK or NAK, and in REQUESTING state we
             * should only receive ACK or NAK or OFFER; these are
             * accounted for above, so we log whatever this is as an
             * error and discard it with no change to our state.
             */
            dsc_errors++;
 d025de8:	d0a09017 	ldw	r2,-32192(gp)
 d025dec:	10800044 	addi	r2,r2,1
 d025df0:	d0a09015 	stw	r2,-32192(gp)
            return ENP_NOT_MINE;
 d025df4:	00800084 	movi	r2,2
 d025df8:	e0bffe15 	stw	r2,-8(fp)
 d025dfc:	00002b06 	br	d025eac <dhc_upcall+0x814>
         }
         break;
      default:    /* bad state */
         dtrap();
 d025e00:	d0293e80 	call	d0293e8 <dtrap>
         dhc_set_state(iface,DHCS_INIT);
 d025e04:	e13ff617 	ldw	r4,-40(fp)
 d025e08:	01400044 	movi	r5,1
 d025e0c:	d0283980 	call	d028398 <dhc_set_state>
         dsc_errors++;
 d025e10:	d0a09017 	ldw	r2,-32192(gp)
 d025e14:	10800044 	addi	r2,r2,1
 d025e18:	d0a09015 	stw	r2,-32192(gp)
         return -1;
 d025e1c:	00ffffc4 	movi	r3,-1
 d025e20:	e0fffe15 	stw	r3,-8(fp)
 d025e24:	00002106 	br	d025eac <dhc_upcall+0x814>
      }
   }
   else     /* plain bootp reply */
   {
      dsc_bpreplys++;
 d025e28:	d0a09517 	ldw	r2,-32172(gp)
 d025e2c:	10800044 	addi	r2,r2,1
 d025e30:	d0a09515 	stw	r2,-32172(gp)
      dhc_extract_opts(iface,&bp->options[4]);
 d025e34:	e0bffa17 	ldw	r2,-24(fp)
 d025e38:	10803b04 	addi	r2,r2,236
 d025e3c:	11400104 	addi	r5,r2,4
 d025e40:	e13ff617 	ldw	r4,-40(fp)
 d025e44:	d0277840 	call	d027784 <dhc_extract_opts>
      dhc_states[iface].ipaddr = bp->yiaddr;
 d025e48:	e13ff617 	ldw	r4,-40(fp)
 d025e4c:	e0bffa17 	ldw	r2,-24(fp)
 d025e50:	11400417 	ldw	r5,16(r2)
 d025e54:	00c341b4 	movhi	r3,3334
 d025e58:	18f2cb04 	addi	r3,r3,-13524
 d025e5c:	20800f24 	muli	r2,r4,60
 d025e60:	10c5883a 	add	r2,r2,r3
 d025e64:	10800904 	addi	r2,r2,36
 d025e68:	11400015 	stw	r5,0(r2)
      dhc_setip(iface);
 d025e6c:	e13ff617 	ldw	r4,-40(fp)
 d025e70:	d02723c0 	call	d02723c <dhc_setip>

      /* Set values so that DHCP State Machine remains happy */
      dhc_set_state(iface,DHCS_BOUND);
 d025e74:	e13ff617 	ldw	r4,-40(fp)
 d025e78:	01400184 	movi	r5,6
 d025e7c:	d0283980 	call	d028398 <dhc_set_state>
      dhc_states[iface].t1    = DHC_INFINITY ;
 d025e80:	e0bff617 	ldw	r2,-40(fp)
 d025e84:	00c341b4 	movhi	r3,3334
 d025e88:	18f2cb04 	addi	r3,r3,-13524
 d025e8c:	10800f24 	muli	r2,r2,60
 d025e90:	10c5883a 	add	r2,r2,r3
 d025e94:	10c00604 	addi	r3,r2,24
 d025e98:	00bfffc4 	movi	r2,-1
 d025e9c:	18800015 	stw	r2,0(r3)
   }

   udp_free(pkt);
 d025ea0:	e13ffb17 	ldw	r4,-20(fp)
 d025ea4:	d04368c0 	call	d04368c <udp_free>
   return 0;
 d025ea8:	e03ffe15 	stw	zero,-8(fp)
 d025eac:	e0bffe17 	ldw	r2,-8(fp)
}
 d025eb0:	e037883a 	mov	sp,fp
 d025eb4:	dfc00217 	ldw	ra,8(sp)
 d025eb8:	df000117 	ldw	fp,4(sp)
 d025ebc:	dc000017 	ldw	r16,0(sp)
 d025ec0:	dec00304 	addi	sp,sp,12
 d025ec4:	f800283a 	ret

0d025ec8 <dhc_buildheader>:
 * RETURNS: Returns 0 on success, else an ENP_ error code. 
 */

int
dhc_buildheader(int iface, struct bootp * outbp)
{
 d025ec8:	defff804 	addi	sp,sp,-32
 d025ecc:	dfc00715 	stw	ra,28(sp)
 d025ed0:	df000615 	stw	fp,24(sp)
 d025ed4:	df000604 	addi	fp,sp,24
 d025ed8:	e13ffb15 	stw	r4,-20(fp)
 d025edc:	e17ffc15 	stw	r5,-16(fp)
   int   addrlen;    /* length of hardware address */

   MEMSET(outbp, 0, sizeof(struct bootp));   /* most of this is 0 anyway */
 d025ee0:	e0bffc17 	ldw	r2,-16(fp)
 d025ee4:	1009883a 	mov	r4,r2
 d025ee8:	01804b04 	movi	r6,300
 d025eec:	000b883a 	mov	r5,zero
 d025ef0:	d0028800 	call	d002880 <memset>
   outbp->op = BOOTREQUEST;
 d025ef4:	e0fffc17 	ldw	r3,-16(fp)
 d025ef8:	00800044 	movi	r2,1
 d025efc:	18800005 	stb	r2,0(r3)

   /* map SNMPish hardware types into bootp types */
   switch (nets[iface]->n_mib->ifType)
 d025f00:	e0bffb17 	ldw	r2,-20(fp)
 d025f04:	00c341b4 	movhi	r3,3334
 d025f08:	18f2a504 	addi	r3,r3,-13676
 d025f0c:	1085883a 	add	r2,r2,r2
 d025f10:	1085883a 	add	r2,r2,r2
 d025f14:	10c5883a 	add	r2,r2,r3
 d025f18:	10800017 	ldw	r2,0(r2)
 d025f1c:	10802717 	ldw	r2,156(r2)
 d025f20:	10800217 	ldw	r2,8(r2)
 d025f24:	e0bfff15 	stw	r2,-4(fp)
 d025f28:	e0ffff17 	ldw	r3,-4(fp)
 d025f2c:	188005e0 	cmpeqi	r2,r3,23
 d025f30:	10000b1e 	bne	r2,zero,d025f60 <dhc_buildheader+0x98>
 d025f34:	e0ffff17 	ldw	r3,-4(fp)
 d025f38:	18800720 	cmpeqi	r2,r3,28
 d025f3c:	1000081e 	bne	r2,zero,d025f60 <dhc_buildheader+0x98>
 d025f40:	e0ffff17 	ldw	r3,-4(fp)
 d025f44:	188001a0 	cmpeqi	r2,r3,6
 d025f48:	1000011e 	bne	r2,zero,d025f50 <dhc_buildheader+0x88>
 d025f4c:	00000806 	br	d025f70 <dhc_buildheader+0xa8>
   {
   case ETHERNET:       /* ETHERNET defined in net.h */
      outbp->htype = ETHHWTYPE;  /* defined in dhcp.h */
 d025f50:	e0fffc17 	ldw	r3,-16(fp)
 d025f54:	00800044 	movi	r2,1
 d025f58:	18800045 	stb	r2,1(r3)
   break;
 d025f5c:	00000806 	br	d025f80 <dhc_buildheader+0xb8>
   case PPP:
   case SLIP:
      outbp->htype = LINEHWTYPE;    /* line type for PPP or SLIP */
 d025f60:	e0fffc17 	ldw	r3,-16(fp)
 d025f64:	00800504 	movi	r2,20
 d025f68:	18800045 	stb	r2,1(r3)
   break;
 d025f6c:	00000406 	br	d025f80 <dhc_buildheader+0xb8>
      default:
      dtrap();
 d025f70:	d0293e80 	call	d0293e8 <dtrap>
      return ENP_LOGIC;             /* this shouldn't happen */
 d025f74:	00bffd44 	movi	r2,-11
 d025f78:	e0bffe15 	stw	r2,-8(fp)
 d025f7c:	00005306 	br	d0260cc <dhc_buildheader+0x204>
   }

   addrlen = min(16, nets[iface]->n_hal);
 d025f80:	e0bffb17 	ldw	r2,-20(fp)
 d025f84:	00c341b4 	movhi	r3,3334
 d025f88:	18f2a504 	addi	r3,r3,-13676
 d025f8c:	1085883a 	add	r2,r2,r2
 d025f90:	1085883a 	add	r2,r2,r2
 d025f94:	10c5883a 	add	r2,r2,r3
 d025f98:	10800017 	ldw	r2,0(r2)
 d025f9c:	10801117 	ldw	r2,68(r2)
 d025fa0:	e0bffd15 	stw	r2,-12(fp)
 d025fa4:	e0fffd17 	ldw	r3,-12(fp)
 d025fa8:	18800470 	cmpltui	r2,r3,17
 d025fac:	1000021e 	bne	r2,zero,d025fb8 <dhc_buildheader+0xf0>
 d025fb0:	00800404 	movi	r2,16
 d025fb4:	e0bffd15 	stw	r2,-12(fp)
 d025fb8:	e0fffd17 	ldw	r3,-12(fp)
 d025fbc:	e0fffa15 	stw	r3,-24(fp)
   outbp->hlen = (u_char)addrlen;
 d025fc0:	e0bffa17 	ldw	r2,-24(fp)
 d025fc4:	1007883a 	mov	r3,r2
 d025fc8:	e0bffc17 	ldw	r2,-16(fp)
 d025fcc:	10c00085 	stb	r3,2(r2)
   outbp->hops = 0;
 d025fd0:	e0bffc17 	ldw	r2,-16(fp)
 d025fd4:	100000c5 	stb	zero,3(r2)
   if(dhc_states[iface].state == DHCS_RENEWING) 
 d025fd8:	e0bffb17 	ldw	r2,-20(fp)
 d025fdc:	00c341b4 	movhi	r3,3334
 d025fe0:	18f2cb04 	addi	r3,r3,-13524
 d025fe4:	10800f24 	muli	r2,r2,60
 d025fe8:	10c5883a 	add	r2,r2,r3
 d025fec:	10800017 	ldw	r2,0(r2)
 d025ff0:	108001d8 	cmpnei	r2,r2,7
 d025ff4:	1000031e 	bne	r2,zero,d026004 <dhc_buildheader+0x13c>
      outbp->flags = 0; /* Renewing needs unicast */
 d025ff8:	e0bffc17 	ldw	r2,-16(fp)
 d025ffc:	1000028d 	sth	zero,10(r2)
 d026000:	00000306 	br	d026010 <dhc_buildheader+0x148>
   else
      outbp->flags = htons(DHC_BCASTFLAG); /* Othwise broadcast */
 d026004:	e0fffc17 	ldw	r3,-16(fp)
 d026008:	00802004 	movi	r2,128
 d02600c:	1880028d 	sth	r2,10(r3)
   outbp->xid = dhc_states[iface].xid;
 d026010:	e0bffb17 	ldw	r2,-20(fp)
 d026014:	00c341b4 	movhi	r3,3334
 d026018:	18f2cb04 	addi	r3,r3,-13524
 d02601c:	10800f24 	muli	r2,r2,60
 d026020:	10c5883a 	add	r2,r2,r3
 d026024:	10800204 	addi	r2,r2,8
 d026028:	10c00017 	ldw	r3,0(r2)
 d02602c:	e0bffc17 	ldw	r2,-16(fp)
 d026030:	10c00115 	stw	r3,4(r2)
   outbp->secs = dhc_states[iface].secs;
 d026034:	e0bffb17 	ldw	r2,-20(fp)
 d026038:	00c341b4 	movhi	r3,3334
 d02603c:	18f2cb04 	addi	r3,r3,-13524
 d026040:	10800f24 	muli	r2,r2,60
 d026044:	10c5883a 	add	r2,r2,r3
 d026048:	10800304 	addi	r2,r2,12
 d02604c:	10c0000b 	ldhu	r3,0(r2)
 d026050:	e0bffc17 	ldw	r2,-16(fp)
 d026054:	10c0020d 	sth	r3,8(r2)
#ifdef NPDEBUG
   /* make sure net[] has a MAC address, even if length is zero */
   if(nets[iface]->mib.ifPhysAddress == NULL)
 d026058:	e0bffb17 	ldw	r2,-20(fp)
 d02605c:	00c341b4 	movhi	r3,3334
 d026060:	18f2a504 	addi	r3,r3,-13676
 d026064:	1085883a 	add	r2,r2,r2
 d026068:	1085883a 	add	r2,r2,r2
 d02606c:	10c5883a 	add	r2,r2,r3
 d026070:	10800017 	ldw	r2,0(r2)
 d026074:	10801717 	ldw	r2,92(r2)
 d026078:	1004c03a 	cmpne	r2,r2,zero
 d02607c:	1000041e 	bne	r2,zero,d026090 <dhc_buildheader+0x1c8>
   {
      dtrap();
 d026080:	d0293e80 	call	d0293e8 <dtrap>
      return ENP_LOGIC;
 d026084:	00bffd44 	movi	r2,-11
 d026088:	e0bffe15 	stw	r2,-8(fp)
 d02608c:	00000f06 	br	d0260cc <dhc_buildheader+0x204>
   }
#endif
   MEMCPY(outbp->chaddr, nets[iface]->mib.ifPhysAddress, addrlen);
 d026090:	e0bffc17 	ldw	r2,-16(fp)
 d026094:	11000704 	addi	r4,r2,28
 d026098:	e0bffb17 	ldw	r2,-20(fp)
 d02609c:	00c341b4 	movhi	r3,3334
 d0260a0:	18f2a504 	addi	r3,r3,-13676
 d0260a4:	1085883a 	add	r2,r2,r2
 d0260a8:	1085883a 	add	r2,r2,r2
 d0260ac:	10c5883a 	add	r2,r2,r3
 d0260b0:	10800017 	ldw	r2,0(r2)
 d0260b4:	10801717 	ldw	r2,92(r2)
 d0260b8:	e0fffa17 	ldw	r3,-24(fp)
 d0260bc:	100b883a 	mov	r5,r2
 d0260c0:	180d883a 	mov	r6,r3
 d0260c4:	d0027000 	call	d002700 <memcpy>

   /* return success */
   return 0;
 d0260c8:	e03ffe15 	stw	zero,-8(fp)
 d0260cc:	e0bffe17 	ldw	r2,-8(fp)
}
 d0260d0:	e037883a 	mov	sp,fp
 d0260d4:	dfc00117 	ldw	ra,4(sp)
 d0260d8:	df000017 	ldw	fp,0(sp)
 d0260dc:	dec00204 	addi	sp,sp,8
 d0260e0:	f800283a 	ret

0d0260e4 <dhc_discover>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_discover(int iface)
{
 d0260e4:	defff404 	addi	sp,sp,-48
 d0260e8:	dfc00b15 	stw	ra,44(sp)
 d0260ec:	df000a15 	stw	fp,40(sp)
 d0260f0:	dc000915 	stw	r16,36(sp)
 d0260f4:	df000904 	addi	fp,sp,36
 d0260f8:	e13ffe15 	stw	r4,-8(fp)
   u_char * opts;       /* scratch pointer to DHCP options field */
   long     leasetime;
   int      e;

   /* get a UDP packet buffer for DHCP sending */
   pkt = udp_alloc(sizeof(struct bootp), 0);
 d0260fc:	01004b04 	movi	r4,300
 d026100:	000b883a 	mov	r5,zero
 d026104:	d0435a00 	call	d0435a0 <udp_alloc>
 d026108:	e0bffb15 	stw	r2,-20(fp)
   if (!pkt) 
 d02610c:	e0bffb17 	ldw	r2,-20(fp)
 d026110:	1004c03a 	cmpne	r2,r2,zero
 d026114:	1000031e 	bne	r2,zero,d026124 <dhc_discover+0x40>
      return ENP_NOMEM;
 d026118:	00bffb04 	movi	r2,-20
 d02611c:	e0bfff15 	stw	r2,-4(fp)
 d026120:	00012f06 	br	d0265e0 <dhc_discover+0x4fc>
   pkt->nb_plen = sizeof(struct bootp);
 d026124:	e0fffb17 	ldw	r3,-20(fp)
 d026128:	00804b04 	movi	r2,300
 d02612c:	18800415 	stw	r2,16(r3)

   /* start a new DHCP transaction */
   dhc_states[iface].xid = xids++;
 d026130:	e0bffe17 	ldw	r2,-8(fp)
 d026134:	d1203317 	ldw	r4,-32564(gp)
 d026138:	200b883a 	mov	r5,r4
 d02613c:	00c341b4 	movhi	r3,3334
 d026140:	18f2cb04 	addi	r3,r3,-13524
 d026144:	10800f24 	muli	r2,r2,60
 d026148:	10c5883a 	add	r2,r2,r3
 d02614c:	10800204 	addi	r2,r2,8
 d026150:	11400015 	stw	r5,0(r2)
 d026154:	20800044 	addi	r2,r4,1
 d026158:	d0a03315 	stw	r2,-32564(gp)
   dhc_states[iface].secs = (unsigned short)(sysuptime()/100L);
 d02615c:	e43ffe17 	ldw	r16,-8(fp)
 d026160:	d03ac100 	call	d03ac10 <sysuptime>
 d026164:	1007883a 	mov	r3,r2
 d026168:	00801904 	movi	r2,100
 d02616c:	1885203a 	divu	r2,r3,r2
 d026170:	1009883a 	mov	r4,r2
 d026174:	00c341b4 	movhi	r3,3334
 d026178:	18f2cb04 	addi	r3,r3,-13524
 d02617c:	80800f24 	muli	r2,r16,60
 d026180:	10c5883a 	add	r2,r2,r3
 d026184:	10800304 	addi	r2,r2,12
 d026188:	1100000d 	sth	r4,0(r2)

   /* set up DHCP/BOOTP header in buffer */
   outbp = (struct bootp *)pkt->nb_prot;     /* overlay bootp struct on buffer */
 d02618c:	e0bffb17 	ldw	r2,-20(fp)
 d026190:	10800317 	ldw	r2,12(r2)
 d026194:	e0bffa15 	stw	r2,-24(fp)
   e = dhc_buildheader(iface,outbp);
 d026198:	e13ffe17 	ldw	r4,-8(fp)
 d02619c:	e17ffa17 	ldw	r5,-24(fp)
 d0261a0:	d025ec80 	call	d025ec8 <dhc_buildheader>
 d0261a4:	e0bff815 	stw	r2,-32(fp)
   if (e)
 d0261a8:	e0bff817 	ldw	r2,-32(fp)
 d0261ac:	1005003a 	cmpeq	r2,r2,zero
 d0261b0:	1000031e 	bne	r2,zero,d0261c0 <dhc_discover+0xdc>
      return e;
 d0261b4:	e0bff817 	ldw	r2,-32(fp)
 d0261b8:	e0bfff15 	stw	r2,-4(fp)
 d0261bc:	00010806 	br	d0265e0 <dhc_discover+0x4fc>

   /* and turn it into a DHCP DISCOVER packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 d0261c0:	e0bffa17 	ldw	r2,-24(fp)
 d0261c4:	10803b04 	addi	r2,r2,236
 d0261c8:	1007883a 	mov	r3,r2
 d0261cc:	0098d534 	movhi	r2,25428
 d0261d0:	10a098c4 	addi	r2,r2,-32157
 d0261d4:	18800015 	stw	r2,0(r3)
   opts = &outbp->options[4];    /* encode options after cookie */
 d0261d8:	e0bffa17 	ldw	r2,-24(fp)
 d0261dc:	10803b04 	addi	r2,r2,236
 d0261e0:	10800104 	addi	r2,r2,4
 d0261e4:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 d0261e8:	e0fff917 	ldw	r3,-28(fp)
 d0261ec:	00800d44 	movi	r2,53
 d0261f0:	18800005 	stb	r2,0(r3)
 d0261f4:	e0bff917 	ldw	r2,-28(fp)
 d0261f8:	10800044 	addi	r2,r2,1
 d0261fc:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 d026200:	e0fff917 	ldw	r3,-28(fp)
 d026204:	00800044 	movi	r2,1
 d026208:	18800005 	stb	r2,0(r3)
 d02620c:	e0bff917 	ldw	r2,-28(fp)
 d026210:	10800044 	addi	r2,r2,1
 d026214:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_DISCOVER;
 d026218:	e0fff917 	ldw	r3,-28(fp)
 d02621c:	00800044 	movi	r2,1
 d026220:	18800005 	stb	r2,0(r3)
 d026224:	e0bff917 	ldw	r2,-28(fp)
 d026228:	10800044 	addi	r2,r2,1
 d02622c:	e0bff915 	stw	r2,-28(fp)
   leasetime = -1L ;    /* ask for infinite lease */
 d026230:	00bfffc4 	movi	r2,-1
 d026234:	e0bffc15 	stw	r2,-16(fp)
   PUT_IP_OPT(opts, DHOP_LEASE, leasetime);
 d026238:	e0fff917 	ldw	r3,-28(fp)
 d02623c:	00800cc4 	movi	r2,51
 d026240:	18800005 	stb	r2,0(r3)
 d026244:	e0bff917 	ldw	r2,-28(fp)
 d026248:	10800044 	addi	r2,r2,1
 d02624c:	e0bff915 	stw	r2,-28(fp)
 d026250:	e0fff917 	ldw	r3,-28(fp)
 d026254:	00800104 	movi	r2,4
 d026258:	18800005 	stb	r2,0(r3)
 d02625c:	e0bff917 	ldw	r2,-28(fp)
 d026260:	10800044 	addi	r2,r2,1
 d026264:	e0bff915 	stw	r2,-28(fp)
 d026268:	e0bff917 	ldw	r2,-28(fp)
 d02626c:	10c000c4 	addi	r3,r2,3
 d026270:	e0bffc04 	addi	r2,fp,-16
 d026274:	10800003 	ldbu	r2,0(r2)
 d026278:	18800005 	stb	r2,0(r3)
 d02627c:	e0bff917 	ldw	r2,-28(fp)
 d026280:	10c00084 	addi	r3,r2,2
 d026284:	e0bffc04 	addi	r2,fp,-16
 d026288:	10800044 	addi	r2,r2,1
 d02628c:	10800003 	ldbu	r2,0(r2)
 d026290:	18800005 	stb	r2,0(r3)
 d026294:	e0bff917 	ldw	r2,-28(fp)
 d026298:	10c00044 	addi	r3,r2,1
 d02629c:	e0bffc04 	addi	r2,fp,-16
 d0262a0:	10800084 	addi	r2,r2,2
 d0262a4:	10800003 	ldbu	r2,0(r2)
 d0262a8:	18800005 	stb	r2,0(r3)
 d0262ac:	e0bffc04 	addi	r2,fp,-16
 d0262b0:	108000c4 	addi	r2,r2,3
 d0262b4:	10800003 	ldbu	r2,0(r2)
 d0262b8:	1007883a 	mov	r3,r2
 d0262bc:	e0bff917 	ldw	r2,-28(fp)
 d0262c0:	10c00005 	stb	r3,0(r2)
 d0262c4:	e0bff917 	ldw	r2,-28(fp)
 d0262c8:	10800104 	addi	r2,r2,4
 d0262cc:	e0bff915 	stw	r2,-28(fp)

   /* if we already have an IP address, try to get it from the server */
   if (nets[iface]->n_ipaddr != 0)
 d0262d0:	e0bffe17 	ldw	r2,-8(fp)
 d0262d4:	00c341b4 	movhi	r3,3334
 d0262d8:	18f2a504 	addi	r3,r3,-13676
 d0262dc:	1085883a 	add	r2,r2,r2
 d0262e0:	1085883a 	add	r2,r2,r2
 d0262e4:	10c5883a 	add	r2,r2,r3
 d0262e8:	10800017 	ldw	r2,0(r2)
 d0262ec:	10800a17 	ldw	r2,40(r2)
 d0262f0:	1005003a 	cmpeq	r2,r2,zero
 d0262f4:	1000521e 	bne	r2,zero,d026440 <dhc_discover+0x35c>
   {
      ip_addr my_ip = htonl(nets[iface]->n_ipaddr);
 d0262f8:	e0bffe17 	ldw	r2,-8(fp)
 d0262fc:	00c341b4 	movhi	r3,3334
 d026300:	18f2a504 	addi	r3,r3,-13676
 d026304:	1085883a 	add	r2,r2,r2
 d026308:	1085883a 	add	r2,r2,r2
 d02630c:	10c5883a 	add	r2,r2,r3
 d026310:	10800017 	ldw	r2,0(r2)
 d026314:	10800a17 	ldw	r2,40(r2)
 d026318:	1004d63a 	srli	r2,r2,24
 d02631c:	11003fcc 	andi	r4,r2,255
 d026320:	e0bffe17 	ldw	r2,-8(fp)
 d026324:	00c341b4 	movhi	r3,3334
 d026328:	18f2a504 	addi	r3,r3,-13676
 d02632c:	1085883a 	add	r2,r2,r2
 d026330:	1085883a 	add	r2,r2,r2
 d026334:	10c5883a 	add	r2,r2,r3
 d026338:	10800017 	ldw	r2,0(r2)
 d02633c:	10800a17 	ldw	r2,40(r2)
 d026340:	1004d23a 	srli	r2,r2,8
 d026344:	10bfc00c 	andi	r2,r2,65280
 d026348:	2088b03a 	or	r4,r4,r2
 d02634c:	e0bffe17 	ldw	r2,-8(fp)
 d026350:	00c341b4 	movhi	r3,3334
 d026354:	18f2a504 	addi	r3,r3,-13676
 d026358:	1085883a 	add	r2,r2,r2
 d02635c:	1085883a 	add	r2,r2,r2
 d026360:	10c5883a 	add	r2,r2,r3
 d026364:	10800017 	ldw	r2,0(r2)
 d026368:	10800a17 	ldw	r2,40(r2)
 d02636c:	10bfc00c 	andi	r2,r2,65280
 d026370:	1004923a 	slli	r2,r2,8
 d026374:	2088b03a 	or	r4,r4,r2
 d026378:	e0bffe17 	ldw	r2,-8(fp)
 d02637c:	00c341b4 	movhi	r3,3334
 d026380:	18f2a504 	addi	r3,r3,-13676
 d026384:	1085883a 	add	r2,r2,r2
 d026388:	1085883a 	add	r2,r2,r2
 d02638c:	10c5883a 	add	r2,r2,r3
 d026390:	10800017 	ldw	r2,0(r2)
 d026394:	10800a17 	ldw	r2,40(r2)
 d026398:	10803fcc 	andi	r2,r2,255
 d02639c:	1004963a 	slli	r2,r2,24
 d0263a0:	2084b03a 	or	r2,r4,r2
 d0263a4:	e0bffd15 	stw	r2,-12(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, my_ip);
 d0263a8:	e0fff917 	ldw	r3,-28(fp)
 d0263ac:	00800c84 	movi	r2,50
 d0263b0:	18800005 	stb	r2,0(r3)
 d0263b4:	e0bff917 	ldw	r2,-28(fp)
 d0263b8:	10800044 	addi	r2,r2,1
 d0263bc:	e0bff915 	stw	r2,-28(fp)
 d0263c0:	e0fff917 	ldw	r3,-28(fp)
 d0263c4:	00800104 	movi	r2,4
 d0263c8:	18800005 	stb	r2,0(r3)
 d0263cc:	e0bff917 	ldw	r2,-28(fp)
 d0263d0:	10800044 	addi	r2,r2,1
 d0263d4:	e0bff915 	stw	r2,-28(fp)
 d0263d8:	e0bff917 	ldw	r2,-28(fp)
 d0263dc:	10c000c4 	addi	r3,r2,3
 d0263e0:	e0bffd04 	addi	r2,fp,-12
 d0263e4:	10800003 	ldbu	r2,0(r2)
 d0263e8:	18800005 	stb	r2,0(r3)
 d0263ec:	e0bff917 	ldw	r2,-28(fp)
 d0263f0:	10c00084 	addi	r3,r2,2
 d0263f4:	e0bffd04 	addi	r2,fp,-12
 d0263f8:	10800044 	addi	r2,r2,1
 d0263fc:	10800003 	ldbu	r2,0(r2)
 d026400:	18800005 	stb	r2,0(r3)
 d026404:	e0bff917 	ldw	r2,-28(fp)
 d026408:	10c00044 	addi	r3,r2,1
 d02640c:	e0bffd04 	addi	r2,fp,-12
 d026410:	10800084 	addi	r2,r2,2
 d026414:	10800003 	ldbu	r2,0(r2)
 d026418:	18800005 	stb	r2,0(r3)
 d02641c:	e0bffd04 	addi	r2,fp,-12
 d026420:	108000c4 	addi	r2,r2,3
 d026424:	10800003 	ldbu	r2,0(r2)
 d026428:	1007883a 	mov	r3,r2
 d02642c:	e0bff917 	ldw	r2,-28(fp)
 d026430:	10c00005 	stb	r3,0(r2)
 d026434:	e0bff917 	ldw	r2,-28(fp)
 d026438:	10800104 	addi	r2,r2,4
 d02643c:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 d026440:	d0a03517 	ldw	r2,-32556(gp)
 d026444:	10800050 	cmplti	r2,r2,1
 d026448:	10001e1e 	bne	r2,zero,d0264c4 <dhc_discover+0x3e0>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 d02644c:	e0fff917 	ldw	r3,-28(fp)
 d026450:	00800dc4 	movi	r2,55
 d026454:	18800005 	stb	r2,0(r3)
 d026458:	e0bff917 	ldw	r2,-28(fp)
 d02645c:	10800044 	addi	r2,r2,1
 d026460:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 d026464:	d0a03517 	ldw	r2,-32556(gp)
 d026468:	1007883a 	mov	r3,r2
 d02646c:	e0bff917 	ldw	r2,-28(fp)
 d026470:	10c00005 	stb	r3,0(r2)
 d026474:	e0bff917 	ldw	r2,-28(fp)
 d026478:	10800044 	addi	r2,r2,1
 d02647c:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 d026480:	e03ff715 	stw	zero,-36(fp)
 d026484:	00000c06 	br	d0264b8 <dhc_discover+0x3d4>
         *opts++ = reqlist[i];
 d026488:	e0fff717 	ldw	r3,-36(fp)
 d02648c:	d0a03404 	addi	r2,gp,-32560
 d026490:	1885883a 	add	r2,r3,r2
 d026494:	10c00003 	ldbu	r3,0(r2)
 d026498:	e0bff917 	ldw	r2,-28(fp)
 d02649c:	10c00005 	stb	r3,0(r2)
 d0264a0:	e0bff917 	ldw	r2,-28(fp)
 d0264a4:	10800044 	addi	r2,r2,1
 d0264a8:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 d0264ac:	e0bff717 	ldw	r2,-36(fp)
 d0264b0:	10800044 	addi	r2,r2,1
 d0264b4:	e0bff715 	stw	r2,-36(fp)
 d0264b8:	d0e03517 	ldw	r3,-32556(gp)
 d0264bc:	e0bff717 	ldw	r2,-36(fp)
 d0264c0:	10fff116 	blt	r2,r3,d026488 <dhc_discover+0x3a4>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   *opts++ = DHOP_END;
 d0264c4:	e0fff917 	ldw	r3,-28(fp)
 d0264c8:	00bfffc4 	movi	r2,-1
 d0264cc:	18800005 	stb	r2,0(r3)
 d0264d0:	e0bff917 	ldw	r2,-28(fp)
 d0264d4:	10800044 	addi	r2,r2,1
 d0264d8:	e0bff915 	stw	r2,-28(fp)

   /* last_tick needs to be set in case we are doing a retry. It 
    * prevents dhc_second from calling us to do another retry while 
    * we are stuck 
    */
   dhc_states[iface].last_tick = cticks;
 d0264dc:	e13ffe17 	ldw	r4,-8(fp)
 d0264e0:	00834174 	movhi	r2,3333
 d0264e4:	108ac904 	addi	r2,r2,11044
 d0264e8:	11400017 	ldw	r5,0(r2)
 d0264ec:	00c341b4 	movhi	r3,3334
 d0264f0:	18f2cb04 	addi	r3,r3,-13524
 d0264f4:	20800f24 	muli	r2,r4,60
 d0264f8:	10c5883a 	add	r2,r2,r3
 d0264fc:	10800404 	addi	r2,r2,16
 d026500:	11400015 	stw	r5,0(r2)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast discovery request */
 d026504:	e0fffb17 	ldw	r3,-20(fp)
 d026508:	00bfffc4 	movi	r2,-1
 d02650c:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller spec'ed net */
 d026510:	e0bffe17 	ldw	r2,-8(fp)
 d026514:	00c341b4 	movhi	r3,3334
 d026518:	18f2a504 	addi	r3,r3,-13676
 d02651c:	1085883a 	add	r2,r2,r2
 d026520:	1085883a 	add	r2,r2,r2
 d026524:	10c5883a 	add	r2,r2,r3
 d026528:	10c00017 	ldw	r3,0(r2)
 d02652c:	e0bffb17 	ldw	r2,-20(fp)
 d026530:	10c00615 	stw	r3,24(r2)

   /* we need to change the DHCP state before sending to avoid a 
    * race condition with the expected reply 
    */
   if (dhc_states[iface].state != DHCS_SELECTING)
 d026534:	e0bffe17 	ldw	r2,-8(fp)
 d026538:	00c341b4 	movhi	r3,3334
 d02653c:	18f2cb04 	addi	r3,r3,-13524
 d026540:	10800f24 	muli	r2,r2,60
 d026544:	10c5883a 	add	r2,r2,r3
 d026548:	10800017 	ldw	r2,0(r2)
 d02654c:	10800120 	cmpeqi	r2,r2,4
 d026550:	1000031e 	bne	r2,zero,d026560 <dhc_discover+0x47c>
      dhc_set_state(iface, DHCS_SELECTING);
 d026554:	e13ffe17 	ldw	r4,-8(fp)
 d026558:	01400104 	movi	r5,4
 d02655c:	d0283980 	call	d028398 <dhc_set_state>

   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 d026560:	010010c4 	movi	r4,67
 d026564:	01401104 	movi	r5,68
 d026568:	e1bffb17 	ldw	r6,-20(fp)
 d02656c:	d0430e80 	call	d0430e8 <udp_send>
   dsc_discovers++;
 d026570:	d0a09117 	ldw	r2,-32188(gp)
 d026574:	10800044 	addi	r2,r2,1
 d026578:	d0a09115 	stw	r2,-32188(gp)

   /* state info is the same even if udp_send() failed */
   dhc_states[iface].last_tick = cticks;     /* set this again, post udp_send */
 d02657c:	e13ffe17 	ldw	r4,-8(fp)
 d026580:	00834174 	movhi	r2,3333
 d026584:	108ac904 	addi	r2,r2,11044
 d026588:	11400017 	ldw	r5,0(r2)
 d02658c:	00c341b4 	movhi	r3,3334
 d026590:	18f2cb04 	addi	r3,r3,-13524
 d026594:	20800f24 	muli	r2,r4,60
 d026598:	10c5883a 	add	r2,r2,r3
 d02659c:	10800404 	addi	r2,r2,16
 d0265a0:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 d0265a4:	e17ffe17 	ldw	r5,-8(fp)
 d0265a8:	00c341b4 	movhi	r3,3334
 d0265ac:	18f2cb04 	addi	r3,r3,-13524
 d0265b0:	28800f24 	muli	r2,r5,60
 d0265b4:	10c5883a 	add	r2,r2,r3
 d0265b8:	10800104 	addi	r2,r2,4
 d0265bc:	10800017 	ldw	r2,0(r2)
 d0265c0:	11000044 	addi	r4,r2,1
 d0265c4:	00c341b4 	movhi	r3,3334
 d0265c8:	18f2cb04 	addi	r3,r3,-13524
 d0265cc:	28800f24 	muli	r2,r5,60
 d0265d0:	10c5883a 	add	r2,r2,r3
 d0265d4:	10800104 	addi	r2,r2,4
 d0265d8:	11000015 	stw	r4,0(r2)

   return 0;
 d0265dc:	e03fff15 	stw	zero,-4(fp)
 d0265e0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0265e4:	e037883a 	mov	sp,fp
 d0265e8:	dfc00217 	ldw	ra,8(sp)
 d0265ec:	df000117 	ldw	fp,4(sp)
 d0265f0:	dc000017 	ldw	r16,0(sp)
 d0265f4:	dec00304 	addi	sp,sp,12
 d0265f8:	f800283a 	ret

0d0265fc <dhc_rx_offer>:
 * RETURNS: 0 if OK, else ENP_ error
 */

int
dhc_rx_offer(int iface, struct bootp * bp, unsigned bplen)
{
 d0265fc:	defff804 	addi	sp,sp,-32
 d026600:	dfc00715 	stw	ra,28(sp)
 d026604:	df000615 	stw	fp,24(sp)
 d026608:	df000604 	addi	fp,sp,24
 d02660c:	e13ffc15 	stw	r4,-16(fp)
 d026610:	e17ffd15 	stw	r5,-12(fp)
 d026614:	e1bffe15 	stw	r6,-8(fp)
   u_char * opts;
   int   e;

   if (dhc_states[iface].xid != bp->xid)
 d026618:	e0bffc17 	ldw	r2,-16(fp)
 d02661c:	00c341b4 	movhi	r3,3334
 d026620:	18f2cb04 	addi	r3,r3,-13524
 d026624:	10800f24 	muli	r2,r2,60
 d026628:	10c5883a 	add	r2,r2,r3
 d02662c:	10800204 	addi	r2,r2,8
 d026630:	10c00017 	ldw	r3,0(r2)
 d026634:	e0bffd17 	ldw	r2,-12(fp)
 d026638:	10800117 	ldw	r2,4(r2)
 d02663c:	18800326 	beq	r3,r2,d02664c <dhc_rx_offer+0x50>
      return ENP_NOT_MINE;
 d026640:	00800084 	movi	r2,2
 d026644:	e0bfff15 	stw	r2,-4(fp)
 d026648:	00002706 	br	d0266e8 <dhc_rx_offer+0xec>

   opts = &bp->options[4];    /* examine options after cookie */
 d02664c:	e0bffd17 	ldw	r2,-12(fp)
 d026650:	10803b04 	addi	r2,r2,236
 d026654:	10800104 	addi	r2,r2,4
 d026658:	e0bffb15 	stw	r2,-20(fp)
   e = dhc_extract_opts(iface,opts);
 d02665c:	e13ffc17 	ldw	r4,-16(fp)
 d026660:	e17ffb17 	ldw	r5,-20(fp)
 d026664:	d0277840 	call	d027784 <dhc_extract_opts>
 d026668:	e0bffa15 	stw	r2,-24(fp)
   if (e)   /* parse error? */
 d02666c:	e0bffa17 	ldw	r2,-24(fp)
 d026670:	1005003a 	cmpeq	r2,r2,zero
 d026674:	1000041e 	bne	r2,zero,d026688 <dhc_rx_offer+0x8c>
   {
      dtrap();
 d026678:	d0293e80 	call	d0293e8 <dtrap>
      return e;
 d02667c:	e0bffa17 	ldw	r2,-24(fp)
 d026680:	e0bfff15 	stw	r2,-4(fp)
 d026684:	00001806 	br	d0266e8 <dhc_rx_offer+0xec>
   }
   if (!bp->yiaddr)  /* require an IP address */
 d026688:	e0bffd17 	ldw	r2,-12(fp)
 d02668c:	10800417 	ldw	r2,16(r2)
 d026690:	1004c03a 	cmpne	r2,r2,zero
 d026694:	1000071e 	bne	r2,zero,d0266b4 <dhc_rx_offer+0xb8>
   {
      dhc_decline(iface,bp, bplen);
 d026698:	e13ffc17 	ldw	r4,-16(fp)
 d02669c:	e17ffd17 	ldw	r5,-12(fp)
 d0266a0:	e1bffe17 	ldw	r6,-8(fp)
 d0266a4:	d0275a00 	call	d0275a0 <dhc_decline>
      return ENP_NOT_MINE;
 d0266a8:	00800084 	movi	r2,2
 d0266ac:	e0bfff15 	stw	r2,-4(fp)
 d0266b0:	00000d06 	br	d0266e8 <dhc_rx_offer+0xec>
   }
   dhc_states[iface].ipaddr = bp->yiaddr;
 d0266b4:	e13ffc17 	ldw	r4,-16(fp)
 d0266b8:	e0bffd17 	ldw	r2,-12(fp)
 d0266bc:	11400417 	ldw	r5,16(r2)
 d0266c0:	00c341b4 	movhi	r3,3334
 d0266c4:	18f2cb04 	addi	r3,r3,-13524
 d0266c8:	20800f24 	muli	r2,r4,60
 d0266cc:	10c5883a 	add	r2,r2,r3
 d0266d0:	10800904 	addi	r2,r2,36
 d0266d4:	11400015 	stw	r5,0(r2)

   /* if we got here, we must like the offer -- send a DHCP REQUEST */
   return (dhc_request(iface,FALSE));
 d0266d8:	e13ffc17 	ldw	r4,-16(fp)
 d0266dc:	000b883a 	mov	r5,zero
 d0266e0:	d0267000 	call	d026700 <dhc_request>
 d0266e4:	e0bfff15 	stw	r2,-4(fp)
 d0266e8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0266ec:	e037883a 	mov	sp,fp
 d0266f0:	dfc00117 	ldw	ra,4(sp)
 d0266f4:	df000017 	ldw	fp,0(sp)
 d0266f8:	dec00204 	addi	sp,sp,8
 d0266fc:	f800283a 	ret

0d026700 <dhc_request>:
 * RETURNS:  Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_request(int iface,int xid_flag)
{
 d026700:	defff304 	addi	sp,sp,-52
 d026704:	dfc00c15 	stw	ra,48(sp)
 d026708:	df000b15 	stw	fp,44(sp)
 d02670c:	df000b04 	addi	fp,sp,44
 d026710:	e13ffd15 	stw	r4,-12(fp)
 d026714:	e17ffe15 	stw	r5,-8(fp)
   u_char  *   opts; /* scratch pointer to DHCP options field */
   ip_addr opt_ip;      /* IP address temporary */
   int      e;       /* error holder */

   /* get a UDP packet buffer for sending DHCP request */
   pkt = udp_alloc(sizeof(struct bootp) + DHCP_OPTSIZE - BOOTP_OPTSIZE, 0);
 d026718:	01008904 	movi	r4,548
 d02671c:	000b883a 	mov	r5,zero
 d026720:	d0435a00 	call	d0435a0 <udp_alloc>
 d026724:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 d026728:	e0bffa17 	ldw	r2,-24(fp)
 d02672c:	1004c03a 	cmpne	r2,r2,zero
 d026730:	1000031e 	bne	r2,zero,d026740 <dhc_request+0x40>
      return ENP_NOMEM;
 d026734:	00bffb04 	movi	r2,-20
 d026738:	e0bfff15 	stw	r2,-4(fp)
 d02673c:	0002b906 	br	d027224 <dhc_request+0xb24>
   pkt->nb_plen = sizeof(struct bootp) - BOOTP_OPTSIZE;
 d026740:	e0fffa17 	ldw	r3,-24(fp)
 d026744:	00803b04 	movi	r2,236
 d026748:	18800415 	stw	r2,16(r3)

   if ( xid_flag == TRUE )
 d02674c:	e0bffe17 	ldw	r2,-8(fp)
 d026750:	10800058 	cmpnei	r2,r2,1
 d026754:	1000121e 	bne	r2,zero,d0267a0 <dhc_request+0xa0>
   {
      dhc_states[iface].xid  = xids++;
 d026758:	e0bffd17 	ldw	r2,-12(fp)
 d02675c:	d1203317 	ldw	r4,-32564(gp)
 d026760:	200b883a 	mov	r5,r4
 d026764:	00c341b4 	movhi	r3,3334
 d026768:	18f2cb04 	addi	r3,r3,-13524
 d02676c:	10800f24 	muli	r2,r2,60
 d026770:	10c5883a 	add	r2,r2,r3
 d026774:	10800204 	addi	r2,r2,8
 d026778:	11400015 	stw	r5,0(r2)
 d02677c:	20800044 	addi	r2,r4,1
 d026780:	d0a03315 	stw	r2,-32564(gp)
      dhc_states[iface].secs = 0;
 d026784:	e0bffd17 	ldw	r2,-12(fp)
 d026788:	00c341b4 	movhi	r3,3334
 d02678c:	18f2cb04 	addi	r3,r3,-13524
 d026790:	10800f24 	muli	r2,r2,60
 d026794:	10c5883a 	add	r2,r2,r3
 d026798:	10800304 	addi	r2,r2,12
 d02679c:	1000000d 	sth	zero,0(r2)
   }

   /* build a BOOTP request header */
   outbp = (struct bootp *)pkt->nb_prot;
 d0267a0:	e0bffa17 	ldw	r2,-24(fp)
 d0267a4:	10800317 	ldw	r2,12(r2)
 d0267a8:	e0bffb15 	stw	r2,-20(fp)
   e     = dhc_buildheader(iface,outbp);
 d0267ac:	e13ffd17 	ldw	r4,-12(fp)
 d0267b0:	e17ffb17 	ldw	r5,-20(fp)
 d0267b4:	d025ec80 	call	d025ec8 <dhc_buildheader>
 d0267b8:	e0bff815 	stw	r2,-32(fp)
   if (e)
 d0267bc:	e0bff817 	ldw	r2,-32(fp)
 d0267c0:	1005003a 	cmpeq	r2,r2,zero
 d0267c4:	1000031e 	bne	r2,zero,d0267d4 <dhc_request+0xd4>
      return e;
 d0267c8:	e0bff817 	ldw	r2,-32(fp)
 d0267cc:	e0bfff15 	stw	r2,-4(fp)
 d0267d0:	00029406 	br	d027224 <dhc_request+0xb24>

   /* turn it into a DHCP REQUEST packet */
   *(long*)(&outbp->options) = RFC1084_MAGIC_COOKIE; 
 d0267d4:	e0bffb17 	ldw	r2,-20(fp)
 d0267d8:	10803b04 	addi	r2,r2,236
 d0267dc:	1007883a 	mov	r3,r2
 d0267e0:	0098d534 	movhi	r2,25428
 d0267e4:	10a098c4 	addi	r2,r2,-32157
 d0267e8:	18800015 	stw	r2,0(r3)
   opts    = &outbp->options[4];    /* encode options after cookie */
 d0267ec:	e0bffb17 	ldw	r2,-20(fp)
 d0267f0:	10803b04 	addi	r2,r2,236
 d0267f4:	10800104 	addi	r2,r2,4
 d0267f8:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHOP_TYPE;
 d0267fc:	e0fff917 	ldw	r3,-28(fp)
 d026800:	00800d44 	movi	r2,53
 d026804:	18800005 	stb	r2,0(r3)
 d026808:	e0bff917 	ldw	r2,-28(fp)
 d02680c:	10800044 	addi	r2,r2,1
 d026810:	e0bff915 	stw	r2,-28(fp)
   *opts++ = 1;   /* length of option field */
 d026814:	e0fff917 	ldw	r3,-28(fp)
 d026818:	00800044 	movi	r2,1
 d02681c:	18800005 	stb	r2,0(r3)
 d026820:	e0bff917 	ldw	r2,-28(fp)
 d026824:	10800044 	addi	r2,r2,1
 d026828:	e0bff915 	stw	r2,-28(fp)
   *opts++ = DHCP_REQUEST;
 d02682c:	e0fff917 	ldw	r3,-28(fp)
 d026830:	008000c4 	movi	r2,3
 d026834:	18800005 	stb	r2,0(r3)
 d026838:	e0bff917 	ldw	r2,-28(fp)
 d02683c:	10800044 	addi	r2,r2,1
 d026840:	e0bff915 	stw	r2,-28(fp)

   /* append the options that we want to request */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 d026844:	e0bffd17 	ldw	r2,-12(fp)
 d026848:	00c341b4 	movhi	r3,3334
 d02684c:	18f2cb04 	addi	r3,r3,-13524
 d026850:	10800f24 	muli	r2,r2,60
 d026854:	10c5883a 	add	r2,r2,r3
 d026858:	10800017 	ldw	r2,0(r2)
 d02685c:	10800120 	cmpeqi	r2,r2,4
 d026860:	1000181e 	bne	r2,zero,d0268c4 <dhc_request+0x1c4>
 d026864:	e0bffd17 	ldw	r2,-12(fp)
 d026868:	00c341b4 	movhi	r3,3334
 d02686c:	18f2cb04 	addi	r3,r3,-13524
 d026870:	10800f24 	muli	r2,r2,60
 d026874:	10c5883a 	add	r2,r2,r3
 d026878:	10800017 	ldw	r2,0(r2)
 d02687c:	10800160 	cmpeqi	r2,r2,5
 d026880:	1000101e 	bne	r2,zero,d0268c4 <dhc_request+0x1c4>
 d026884:	e0bffd17 	ldw	r2,-12(fp)
 d026888:	00c341b4 	movhi	r3,3334
 d02688c:	18f2cb04 	addi	r3,r3,-13524
 d026890:	10800f24 	muli	r2,r2,60
 d026894:	10c5883a 	add	r2,r2,r3
 d026898:	10800017 	ldw	r2,0(r2)
 d02689c:	108000e0 	cmpeqi	r2,r2,3
 d0268a0:	1000081e 	bne	r2,zero,d0268c4 <dhc_request+0x1c4>
 d0268a4:	e0bffd17 	ldw	r2,-12(fp)
 d0268a8:	00c341b4 	movhi	r3,3334
 d0268ac:	18f2cb04 	addi	r3,r3,-13524
 d0268b0:	10800f24 	muli	r2,r2,60
 d0268b4:	10c5883a 	add	r2,r2,r3
 d0268b8:	10800017 	ldw	r2,0(r2)
 d0268bc:	10800098 	cmpnei	r2,r2,2
 d0268c0:	10004e1e 	bne	r2,zero,d0269fc <dhc_request+0x2fc>
       (dhc_states[iface].state == DHCS_REQUESTING) ||
       (dhc_states[iface].state == DHCS_REBOOTING) ||
       (dhc_states[iface].state == DHCS_INITREBOOT))
   {
      opt_ip = ntohl(dhc_states[iface].ipaddr);
 d0268c4:	e0bffd17 	ldw	r2,-12(fp)
 d0268c8:	00c341b4 	movhi	r3,3334
 d0268cc:	18f2cb04 	addi	r3,r3,-13524
 d0268d0:	10800f24 	muli	r2,r2,60
 d0268d4:	10c5883a 	add	r2,r2,r3
 d0268d8:	10800904 	addi	r2,r2,36
 d0268dc:	10800017 	ldw	r2,0(r2)
 d0268e0:	1004d63a 	srli	r2,r2,24
 d0268e4:	11003fcc 	andi	r4,r2,255
 d0268e8:	e0bffd17 	ldw	r2,-12(fp)
 d0268ec:	00c341b4 	movhi	r3,3334
 d0268f0:	18f2cb04 	addi	r3,r3,-13524
 d0268f4:	10800f24 	muli	r2,r2,60
 d0268f8:	10c5883a 	add	r2,r2,r3
 d0268fc:	10800904 	addi	r2,r2,36
 d026900:	10800017 	ldw	r2,0(r2)
 d026904:	1004d23a 	srli	r2,r2,8
 d026908:	10bfc00c 	andi	r2,r2,65280
 d02690c:	2088b03a 	or	r4,r4,r2
 d026910:	e0bffd17 	ldw	r2,-12(fp)
 d026914:	00c341b4 	movhi	r3,3334
 d026918:	18f2cb04 	addi	r3,r3,-13524
 d02691c:	10800f24 	muli	r2,r2,60
 d026920:	10c5883a 	add	r2,r2,r3
 d026924:	10800904 	addi	r2,r2,36
 d026928:	10800017 	ldw	r2,0(r2)
 d02692c:	10bfc00c 	andi	r2,r2,65280
 d026930:	1004923a 	slli	r2,r2,8
 d026934:	2088b03a 	or	r4,r4,r2
 d026938:	e0bffd17 	ldw	r2,-12(fp)
 d02693c:	00c341b4 	movhi	r3,3334
 d026940:	18f2cb04 	addi	r3,r3,-13524
 d026944:	10800f24 	muli	r2,r2,60
 d026948:	10c5883a 	add	r2,r2,r3
 d02694c:	10800904 	addi	r2,r2,36
 d026950:	10800017 	ldw	r2,0(r2)
 d026954:	10803fcc 	andi	r2,r2,255
 d026958:	1004963a 	slli	r2,r2,24
 d02695c:	2084b03a 	or	r2,r4,r2
 d026960:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_CADDR, opt_ip);
 d026964:	e0fff917 	ldw	r3,-28(fp)
 d026968:	00800c84 	movi	r2,50
 d02696c:	18800005 	stb	r2,0(r3)
 d026970:	e0bff917 	ldw	r2,-28(fp)
 d026974:	10800044 	addi	r2,r2,1
 d026978:	e0bff915 	stw	r2,-28(fp)
 d02697c:	e0fff917 	ldw	r3,-28(fp)
 d026980:	00800104 	movi	r2,4
 d026984:	18800005 	stb	r2,0(r3)
 d026988:	e0bff917 	ldw	r2,-28(fp)
 d02698c:	10800044 	addi	r2,r2,1
 d026990:	e0bff915 	stw	r2,-28(fp)
 d026994:	e0bff917 	ldw	r2,-28(fp)
 d026998:	10c000c4 	addi	r3,r2,3
 d02699c:	e0bffc04 	addi	r2,fp,-16
 d0269a0:	10800003 	ldbu	r2,0(r2)
 d0269a4:	18800005 	stb	r2,0(r3)
 d0269a8:	e0bff917 	ldw	r2,-28(fp)
 d0269ac:	10c00084 	addi	r3,r2,2
 d0269b0:	e0bffc04 	addi	r2,fp,-16
 d0269b4:	10800044 	addi	r2,r2,1
 d0269b8:	10800003 	ldbu	r2,0(r2)
 d0269bc:	18800005 	stb	r2,0(r3)
 d0269c0:	e0bff917 	ldw	r2,-28(fp)
 d0269c4:	10c00044 	addi	r3,r2,1
 d0269c8:	e0bffc04 	addi	r2,fp,-16
 d0269cc:	10800084 	addi	r2,r2,2
 d0269d0:	10800003 	ldbu	r2,0(r2)
 d0269d4:	18800005 	stb	r2,0(r3)
 d0269d8:	e0bffc04 	addi	r2,fp,-16
 d0269dc:	108000c4 	addi	r2,r2,3
 d0269e0:	10800003 	ldbu	r2,0(r2)
 d0269e4:	1007883a 	mov	r3,r2
 d0269e8:	e0bff917 	ldw	r2,-28(fp)
 d0269ec:	10c00005 	stb	r3,0(r2)
 d0269f0:	e0bff917 	ldw	r2,-28(fp)
 d0269f4:	10800104 	addi	r2,r2,4
 d0269f8:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].snmask)
 d0269fc:	e0bffd17 	ldw	r2,-12(fp)
 d026a00:	00c341b4 	movhi	r3,3334
 d026a04:	18f2cb04 	addi	r3,r3,-13524
 d026a08:	10800f24 	muli	r2,r2,60
 d026a0c:	10c5883a 	add	r2,r2,r3
 d026a10:	10800a04 	addi	r2,r2,40
 d026a14:	10800017 	ldw	r2,0(r2)
 d026a18:	1005003a 	cmpeq	r2,r2,zero
 d026a1c:	10004e1e 	bne	r2,zero,d026b58 <dhc_request+0x458>
   {
      opt_ip = ntohl(dhc_states[iface].snmask);
 d026a20:	e0bffd17 	ldw	r2,-12(fp)
 d026a24:	00c341b4 	movhi	r3,3334
 d026a28:	18f2cb04 	addi	r3,r3,-13524
 d026a2c:	10800f24 	muli	r2,r2,60
 d026a30:	10c5883a 	add	r2,r2,r3
 d026a34:	10800a04 	addi	r2,r2,40
 d026a38:	10800017 	ldw	r2,0(r2)
 d026a3c:	1004d63a 	srli	r2,r2,24
 d026a40:	11003fcc 	andi	r4,r2,255
 d026a44:	e0bffd17 	ldw	r2,-12(fp)
 d026a48:	00c341b4 	movhi	r3,3334
 d026a4c:	18f2cb04 	addi	r3,r3,-13524
 d026a50:	10800f24 	muli	r2,r2,60
 d026a54:	10c5883a 	add	r2,r2,r3
 d026a58:	10800a04 	addi	r2,r2,40
 d026a5c:	10800017 	ldw	r2,0(r2)
 d026a60:	1004d23a 	srli	r2,r2,8
 d026a64:	10bfc00c 	andi	r2,r2,65280
 d026a68:	2088b03a 	or	r4,r4,r2
 d026a6c:	e0bffd17 	ldw	r2,-12(fp)
 d026a70:	00c341b4 	movhi	r3,3334
 d026a74:	18f2cb04 	addi	r3,r3,-13524
 d026a78:	10800f24 	muli	r2,r2,60
 d026a7c:	10c5883a 	add	r2,r2,r3
 d026a80:	10800a04 	addi	r2,r2,40
 d026a84:	10800017 	ldw	r2,0(r2)
 d026a88:	10bfc00c 	andi	r2,r2,65280
 d026a8c:	1004923a 	slli	r2,r2,8
 d026a90:	2088b03a 	or	r4,r4,r2
 d026a94:	e0bffd17 	ldw	r2,-12(fp)
 d026a98:	00c341b4 	movhi	r3,3334
 d026a9c:	18f2cb04 	addi	r3,r3,-13524
 d026aa0:	10800f24 	muli	r2,r2,60
 d026aa4:	10c5883a 	add	r2,r2,r3
 d026aa8:	10800a04 	addi	r2,r2,40
 d026aac:	10800017 	ldw	r2,0(r2)
 d026ab0:	10803fcc 	andi	r2,r2,255
 d026ab4:	1004963a 	slli	r2,r2,24
 d026ab8:	2084b03a 	or	r2,r4,r2
 d026abc:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SNMASK, opt_ip);
 d026ac0:	e0fff917 	ldw	r3,-28(fp)
 d026ac4:	00800044 	movi	r2,1
 d026ac8:	18800005 	stb	r2,0(r3)
 d026acc:	e0bff917 	ldw	r2,-28(fp)
 d026ad0:	10800044 	addi	r2,r2,1
 d026ad4:	e0bff915 	stw	r2,-28(fp)
 d026ad8:	e0fff917 	ldw	r3,-28(fp)
 d026adc:	00800104 	movi	r2,4
 d026ae0:	18800005 	stb	r2,0(r3)
 d026ae4:	e0bff917 	ldw	r2,-28(fp)
 d026ae8:	10800044 	addi	r2,r2,1
 d026aec:	e0bff915 	stw	r2,-28(fp)
 d026af0:	e0bff917 	ldw	r2,-28(fp)
 d026af4:	10c000c4 	addi	r3,r2,3
 d026af8:	e0bffc04 	addi	r2,fp,-16
 d026afc:	10800003 	ldbu	r2,0(r2)
 d026b00:	18800005 	stb	r2,0(r3)
 d026b04:	e0bff917 	ldw	r2,-28(fp)
 d026b08:	10c00084 	addi	r3,r2,2
 d026b0c:	e0bffc04 	addi	r2,fp,-16
 d026b10:	10800044 	addi	r2,r2,1
 d026b14:	10800003 	ldbu	r2,0(r2)
 d026b18:	18800005 	stb	r2,0(r3)
 d026b1c:	e0bff917 	ldw	r2,-28(fp)
 d026b20:	10c00044 	addi	r3,r2,1
 d026b24:	e0bffc04 	addi	r2,fp,-16
 d026b28:	10800084 	addi	r2,r2,2
 d026b2c:	10800003 	ldbu	r2,0(r2)
 d026b30:	18800005 	stb	r2,0(r3)
 d026b34:	e0bffc04 	addi	r2,fp,-16
 d026b38:	108000c4 	addi	r2,r2,3
 d026b3c:	10800003 	ldbu	r2,0(r2)
 d026b40:	1007883a 	mov	r3,r2
 d026b44:	e0bff917 	ldw	r2,-28(fp)
 d026b48:	10c00005 	stb	r3,0(r2)
 d026b4c:	e0bff917 	ldw	r2,-28(fp)
 d026b50:	10800104 	addi	r2,r2,4
 d026b54:	e0bff915 	stw	r2,-28(fp)
   }
   if (dhc_states[iface].defgw)
 d026b58:	e0bffd17 	ldw	r2,-12(fp)
 d026b5c:	00c341b4 	movhi	r3,3334
 d026b60:	18f2cb04 	addi	r3,r3,-13524
 d026b64:	10800f24 	muli	r2,r2,60
 d026b68:	10c5883a 	add	r2,r2,r3
 d026b6c:	10800b04 	addi	r2,r2,44
 d026b70:	10800017 	ldw	r2,0(r2)
 d026b74:	1005003a 	cmpeq	r2,r2,zero
 d026b78:	10004e1e 	bne	r2,zero,d026cb4 <dhc_request+0x5b4>
   {
      opt_ip = ntohl(dhc_states[iface].defgw);
 d026b7c:	e0bffd17 	ldw	r2,-12(fp)
 d026b80:	00c341b4 	movhi	r3,3334
 d026b84:	18f2cb04 	addi	r3,r3,-13524
 d026b88:	10800f24 	muli	r2,r2,60
 d026b8c:	10c5883a 	add	r2,r2,r3
 d026b90:	10800b04 	addi	r2,r2,44
 d026b94:	10800017 	ldw	r2,0(r2)
 d026b98:	1004d63a 	srli	r2,r2,24
 d026b9c:	11003fcc 	andi	r4,r2,255
 d026ba0:	e0bffd17 	ldw	r2,-12(fp)
 d026ba4:	00c341b4 	movhi	r3,3334
 d026ba8:	18f2cb04 	addi	r3,r3,-13524
 d026bac:	10800f24 	muli	r2,r2,60
 d026bb0:	10c5883a 	add	r2,r2,r3
 d026bb4:	10800b04 	addi	r2,r2,44
 d026bb8:	10800017 	ldw	r2,0(r2)
 d026bbc:	1004d23a 	srli	r2,r2,8
 d026bc0:	10bfc00c 	andi	r2,r2,65280
 d026bc4:	2088b03a 	or	r4,r4,r2
 d026bc8:	e0bffd17 	ldw	r2,-12(fp)
 d026bcc:	00c341b4 	movhi	r3,3334
 d026bd0:	18f2cb04 	addi	r3,r3,-13524
 d026bd4:	10800f24 	muli	r2,r2,60
 d026bd8:	10c5883a 	add	r2,r2,r3
 d026bdc:	10800b04 	addi	r2,r2,44
 d026be0:	10800017 	ldw	r2,0(r2)
 d026be4:	10bfc00c 	andi	r2,r2,65280
 d026be8:	1004923a 	slli	r2,r2,8
 d026bec:	2088b03a 	or	r4,r4,r2
 d026bf0:	e0bffd17 	ldw	r2,-12(fp)
 d026bf4:	00c341b4 	movhi	r3,3334
 d026bf8:	18f2cb04 	addi	r3,r3,-13524
 d026bfc:	10800f24 	muli	r2,r2,60
 d026c00:	10c5883a 	add	r2,r2,r3
 d026c04:	10800b04 	addi	r2,r2,44
 d026c08:	10800017 	ldw	r2,0(r2)
 d026c0c:	10803fcc 	andi	r2,r2,255
 d026c10:	1004963a 	slli	r2,r2,24
 d026c14:	2084b03a 	or	r2,r4,r2
 d026c18:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_ROUTER, opt_ip);
 d026c1c:	e0fff917 	ldw	r3,-28(fp)
 d026c20:	008000c4 	movi	r2,3
 d026c24:	18800005 	stb	r2,0(r3)
 d026c28:	e0bff917 	ldw	r2,-28(fp)
 d026c2c:	10800044 	addi	r2,r2,1
 d026c30:	e0bff915 	stw	r2,-28(fp)
 d026c34:	e0fff917 	ldw	r3,-28(fp)
 d026c38:	00800104 	movi	r2,4
 d026c3c:	18800005 	stb	r2,0(r3)
 d026c40:	e0bff917 	ldw	r2,-28(fp)
 d026c44:	10800044 	addi	r2,r2,1
 d026c48:	e0bff915 	stw	r2,-28(fp)
 d026c4c:	e0bff917 	ldw	r2,-28(fp)
 d026c50:	10c000c4 	addi	r3,r2,3
 d026c54:	e0bffc04 	addi	r2,fp,-16
 d026c58:	10800003 	ldbu	r2,0(r2)
 d026c5c:	18800005 	stb	r2,0(r3)
 d026c60:	e0bff917 	ldw	r2,-28(fp)
 d026c64:	10c00084 	addi	r3,r2,2
 d026c68:	e0bffc04 	addi	r2,fp,-16
 d026c6c:	10800044 	addi	r2,r2,1
 d026c70:	10800003 	ldbu	r2,0(r2)
 d026c74:	18800005 	stb	r2,0(r3)
 d026c78:	e0bff917 	ldw	r2,-28(fp)
 d026c7c:	10c00044 	addi	r3,r2,1
 d026c80:	e0bffc04 	addi	r2,fp,-16
 d026c84:	10800084 	addi	r2,r2,2
 d026c88:	10800003 	ldbu	r2,0(r2)
 d026c8c:	18800005 	stb	r2,0(r3)
 d026c90:	e0bffc04 	addi	r2,fp,-16
 d026c94:	108000c4 	addi	r2,r2,3
 d026c98:	10800003 	ldbu	r2,0(r2)
 d026c9c:	1007883a 	mov	r3,r2
 d026ca0:	e0bff917 	ldw	r2,-28(fp)
 d026ca4:	10c00005 	stb	r3,0(r2)
 d026ca8:	e0bff917 	ldw	r2,-28(fp)
 d026cac:	10800104 	addi	r2,r2,4
 d026cb0:	e0bff915 	stw	r2,-28(fp)
         }
      }
   }
#endif

   if (dhc_states[iface].lease)
 d026cb4:	e0bffd17 	ldw	r2,-12(fp)
 d026cb8:	00c341b4 	movhi	r3,3334
 d026cbc:	18f2cb04 	addi	r3,r3,-13524
 d026cc0:	10800f24 	muli	r2,r2,60
 d026cc4:	10c5883a 	add	r2,r2,r3
 d026cc8:	10800504 	addi	r2,r2,20
 d026ccc:	10800017 	ldw	r2,0(r2)
 d026cd0:	1005003a 	cmpeq	r2,r2,zero
 d026cd4:	10003a1e 	bne	r2,zero,d026dc0 <dhc_request+0x6c0>
   {
      PUT_IP_OPT(opts, DHOP_LEASE, dhc_states[iface].lease);
 d026cd8:	e0fff917 	ldw	r3,-28(fp)
 d026cdc:	00800cc4 	movi	r2,51
 d026ce0:	18800005 	stb	r2,0(r3)
 d026ce4:	e0bff917 	ldw	r2,-28(fp)
 d026ce8:	10800044 	addi	r2,r2,1
 d026cec:	e0bff915 	stw	r2,-28(fp)
 d026cf0:	e0fff917 	ldw	r3,-28(fp)
 d026cf4:	00800104 	movi	r2,4
 d026cf8:	18800005 	stb	r2,0(r3)
 d026cfc:	e0bff917 	ldw	r2,-28(fp)
 d026d00:	10800044 	addi	r2,r2,1
 d026d04:	e0bff915 	stw	r2,-28(fp)
 d026d08:	e0bff917 	ldw	r2,-28(fp)
 d026d0c:	110000c4 	addi	r4,r2,3
 d026d10:	e0bffd17 	ldw	r2,-12(fp)
 d026d14:	10800f24 	muli	r2,r2,60
 d026d18:	10c00504 	addi	r3,r2,20
 d026d1c:	008341b4 	movhi	r2,3334
 d026d20:	10b2cb04 	addi	r2,r2,-13524
 d026d24:	1885883a 	add	r2,r3,r2
 d026d28:	10800003 	ldbu	r2,0(r2)
 d026d2c:	20800005 	stb	r2,0(r4)
 d026d30:	e0bff917 	ldw	r2,-28(fp)
 d026d34:	11000084 	addi	r4,r2,2
 d026d38:	e0bffd17 	ldw	r2,-12(fp)
 d026d3c:	10800f24 	muli	r2,r2,60
 d026d40:	10c00504 	addi	r3,r2,20
 d026d44:	008341b4 	movhi	r2,3334
 d026d48:	10b2cb04 	addi	r2,r2,-13524
 d026d4c:	1885883a 	add	r2,r3,r2
 d026d50:	10800044 	addi	r2,r2,1
 d026d54:	10800003 	ldbu	r2,0(r2)
 d026d58:	20800005 	stb	r2,0(r4)
 d026d5c:	e0bff917 	ldw	r2,-28(fp)
 d026d60:	11000044 	addi	r4,r2,1
 d026d64:	e0bffd17 	ldw	r2,-12(fp)
 d026d68:	10800f24 	muli	r2,r2,60
 d026d6c:	10c00504 	addi	r3,r2,20
 d026d70:	008341b4 	movhi	r2,3334
 d026d74:	10b2cb04 	addi	r2,r2,-13524
 d026d78:	1885883a 	add	r2,r3,r2
 d026d7c:	10800084 	addi	r2,r2,2
 d026d80:	10800003 	ldbu	r2,0(r2)
 d026d84:	20800005 	stb	r2,0(r4)
 d026d88:	e0bffd17 	ldw	r2,-12(fp)
 d026d8c:	10800f24 	muli	r2,r2,60
 d026d90:	10c00504 	addi	r3,r2,20
 d026d94:	008341b4 	movhi	r2,3334
 d026d98:	10b2cb04 	addi	r2,r2,-13524
 d026d9c:	1885883a 	add	r2,r3,r2
 d026da0:	108000c4 	addi	r2,r2,3
 d026da4:	10800003 	ldbu	r2,0(r2)
 d026da8:	1007883a 	mov	r3,r2
 d026dac:	e0bff917 	ldw	r2,-28(fp)
 d026db0:	10c00005 	stb	r3,0(r2)
 d026db4:	e0bff917 	ldw	r2,-28(fp)
 d026db8:	10800104 	addi	r2,r2,4
 d026dbc:	e0bff915 	stw	r2,-28(fp)
   }

   /* If there is a list of options to be requested from server, include it*/
#ifdef DHCP_REQLIST
   if ( reqlist_len > 0 )
 d026dc0:	d0a03517 	ldw	r2,-32556(gp)
 d026dc4:	10800050 	cmplti	r2,r2,1
 d026dc8:	10001e1e 	bne	r2,zero,d026e44 <dhc_request+0x744>
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
 d026dcc:	e0fff917 	ldw	r3,-28(fp)
 d026dd0:	00800dc4 	movi	r2,55
 d026dd4:	18800005 	stb	r2,0(r3)
 d026dd8:	e0bff917 	ldw	r2,-28(fp)
 d026ddc:	10800044 	addi	r2,r2,1
 d026de0:	e0bff915 	stw	r2,-28(fp)
      *opts++ = (u_char)reqlist_len ;
 d026de4:	d0a03517 	ldw	r2,-32556(gp)
 d026de8:	1007883a 	mov	r3,r2
 d026dec:	e0bff917 	ldw	r2,-28(fp)
 d026df0:	10c00005 	stb	r3,0(r2)
 d026df4:	e0bff917 	ldw	r2,-28(fp)
 d026df8:	10800044 	addi	r2,r2,1
 d026dfc:	e0bff915 	stw	r2,-28(fp)

      for (i=0 ; i < reqlist_len ; i++ )
 d026e00:	e03ff715 	stw	zero,-36(fp)
 d026e04:	00000c06 	br	d026e38 <dhc_request+0x738>
         *opts++ = reqlist[i];
 d026e08:	e0fff717 	ldw	r3,-36(fp)
 d026e0c:	d0a03404 	addi	r2,gp,-32560
 d026e10:	1885883a 	add	r2,r3,r2
 d026e14:	10c00003 	ldbu	r3,0(r2)
 d026e18:	e0bff917 	ldw	r2,-28(fp)
 d026e1c:	10c00005 	stb	r3,0(r2)
 d026e20:	e0bff917 	ldw	r2,-28(fp)
 d026e24:	10800044 	addi	r2,r2,1
 d026e28:	e0bff915 	stw	r2,-28(fp)
   {
      int   i;
      *opts++ = DHOP_REQLIST ;
      *opts++ = (u_char)reqlist_len ;

      for (i=0 ; i < reqlist_len ; i++ )
 d026e2c:	e0bff717 	ldw	r2,-36(fp)
 d026e30:	10800044 	addi	r2,r2,1
 d026e34:	e0bff715 	stw	r2,-36(fp)
 d026e38:	d0e03517 	ldw	r3,-32556(gp)
 d026e3c:	e0bff717 	ldw	r2,-36(fp)
 d026e40:	10fff116 	blt	r2,r3,d026e08 <dhc_request+0x708>
         *opts++ = reqlist[i];
   }
#endif   /* DHCP_REQLIST */

   /* only set client IP address (ours) when renewing or rebinding */
   if ((dhc_states[iface].state == DHCS_RENEWING)
 d026e44:	e0bffd17 	ldw	r2,-12(fp)
 d026e48:	00c341b4 	movhi	r3,3334
 d026e4c:	18f2cb04 	addi	r3,r3,-13524
 d026e50:	10800f24 	muli	r2,r2,60
 d026e54:	10c5883a 	add	r2,r2,r3
 d026e58:	10800017 	ldw	r2,0(r2)
 d026e5c:	108001e0 	cmpeqi	r2,r2,7
 d026e60:	1000081e 	bne	r2,zero,d026e84 <dhc_request+0x784>
 d026e64:	e0bffd17 	ldw	r2,-12(fp)
 d026e68:	00c341b4 	movhi	r3,3334
 d026e6c:	18f2cb04 	addi	r3,r3,-13524
 d026e70:	10800f24 	muli	r2,r2,60
 d026e74:	10c5883a 	add	r2,r2,r3
 d026e78:	10800017 	ldw	r2,0(r2)
 d026e7c:	10800218 	cmpnei	r2,r2,8
 d026e80:	10000a1e 	bne	r2,zero,d026eac <dhc_request+0x7ac>
       || (dhc_states[iface].state == DHCS_REBINDING))
   {
      outbp->ciaddr = nets[iface]->n_ipaddr;
 d026e84:	e0bffd17 	ldw	r2,-12(fp)
 d026e88:	00c341b4 	movhi	r3,3334
 d026e8c:	18f2a504 	addi	r3,r3,-13676
 d026e90:	1085883a 	add	r2,r2,r2
 d026e94:	1085883a 	add	r2,r2,r2
 d026e98:	10c5883a 	add	r2,r2,r3
 d026e9c:	10800017 	ldw	r2,0(r2)
 d026ea0:	10c00a17 	ldw	r3,40(r2)
 d026ea4:	e0bffb17 	ldw	r2,-20(fp)
 d026ea8:	10c00315 	stw	r3,12(r2)
    * "Client inserts the address of the selected server in 'server 
    * identifier'. . . ." RFC 951, p. 4 definition of 'siaddr' is 
    * "server IP address; returned in bootreply by server." 
    */
   /* Only include server identifier option when selecting a server. */
   if ((dhc_states[iface].state == DHCS_SELECTING) ||
 d026eac:	e0bffd17 	ldw	r2,-12(fp)
 d026eb0:	00c341b4 	movhi	r3,3334
 d026eb4:	18f2cb04 	addi	r3,r3,-13524
 d026eb8:	10800f24 	muli	r2,r2,60
 d026ebc:	10c5883a 	add	r2,r2,r3
 d026ec0:	10800017 	ldw	r2,0(r2)
 d026ec4:	10800120 	cmpeqi	r2,r2,4
 d026ec8:	1000081e 	bne	r2,zero,d026eec <dhc_request+0x7ec>
 d026ecc:	e0bffd17 	ldw	r2,-12(fp)
 d026ed0:	00c341b4 	movhi	r3,3334
 d026ed4:	18f2cb04 	addi	r3,r3,-13524
 d026ed8:	10800f24 	muli	r2,r2,60
 d026edc:	10c5883a 	add	r2,r2,r3
 d026ee0:	10800017 	ldw	r2,0(r2)
 d026ee4:	10800158 	cmpnei	r2,r2,5
 d026ee8:	10004e1e 	bne	r2,zero,d027024 <dhc_request+0x924>
       (dhc_states[iface].state == DHCS_REQUESTING))
   {
      opt_ip = ntohl(dhc_states[iface].srv_ipaddr);
 d026eec:	e0bffd17 	ldw	r2,-12(fp)
 d026ef0:	00c341b4 	movhi	r3,3334
 d026ef4:	18f2cb04 	addi	r3,r3,-13524
 d026ef8:	10800f24 	muli	r2,r2,60
 d026efc:	10c5883a 	add	r2,r2,r3
 d026f00:	10800d04 	addi	r2,r2,52
 d026f04:	10800017 	ldw	r2,0(r2)
 d026f08:	1004d63a 	srli	r2,r2,24
 d026f0c:	11003fcc 	andi	r4,r2,255
 d026f10:	e0bffd17 	ldw	r2,-12(fp)
 d026f14:	00c341b4 	movhi	r3,3334
 d026f18:	18f2cb04 	addi	r3,r3,-13524
 d026f1c:	10800f24 	muli	r2,r2,60
 d026f20:	10c5883a 	add	r2,r2,r3
 d026f24:	10800d04 	addi	r2,r2,52
 d026f28:	10800017 	ldw	r2,0(r2)
 d026f2c:	1004d23a 	srli	r2,r2,8
 d026f30:	10bfc00c 	andi	r2,r2,65280
 d026f34:	2088b03a 	or	r4,r4,r2
 d026f38:	e0bffd17 	ldw	r2,-12(fp)
 d026f3c:	00c341b4 	movhi	r3,3334
 d026f40:	18f2cb04 	addi	r3,r3,-13524
 d026f44:	10800f24 	muli	r2,r2,60
 d026f48:	10c5883a 	add	r2,r2,r3
 d026f4c:	10800d04 	addi	r2,r2,52
 d026f50:	10800017 	ldw	r2,0(r2)
 d026f54:	10bfc00c 	andi	r2,r2,65280
 d026f58:	1004923a 	slli	r2,r2,8
 d026f5c:	2088b03a 	or	r4,r4,r2
 d026f60:	e0bffd17 	ldw	r2,-12(fp)
 d026f64:	00c341b4 	movhi	r3,3334
 d026f68:	18f2cb04 	addi	r3,r3,-13524
 d026f6c:	10800f24 	muli	r2,r2,60
 d026f70:	10c5883a 	add	r2,r2,r3
 d026f74:	10800d04 	addi	r2,r2,52
 d026f78:	10800017 	ldw	r2,0(r2)
 d026f7c:	10803fcc 	andi	r2,r2,255
 d026f80:	1004963a 	slli	r2,r2,24
 d026f84:	2084b03a 	or	r2,r4,r2
 d026f88:	e0bffc15 	stw	r2,-16(fp)
      PUT_IP_OPT(opts, DHOP_SERVER, opt_ip);
 d026f8c:	e0fff917 	ldw	r3,-28(fp)
 d026f90:	00800d84 	movi	r2,54
 d026f94:	18800005 	stb	r2,0(r3)
 d026f98:	e0bff917 	ldw	r2,-28(fp)
 d026f9c:	10800044 	addi	r2,r2,1
 d026fa0:	e0bff915 	stw	r2,-28(fp)
 d026fa4:	e0fff917 	ldw	r3,-28(fp)
 d026fa8:	00800104 	movi	r2,4
 d026fac:	18800005 	stb	r2,0(r3)
 d026fb0:	e0bff917 	ldw	r2,-28(fp)
 d026fb4:	10800044 	addi	r2,r2,1
 d026fb8:	e0bff915 	stw	r2,-28(fp)
 d026fbc:	e0bff917 	ldw	r2,-28(fp)
 d026fc0:	10c000c4 	addi	r3,r2,3
 d026fc4:	e0bffc04 	addi	r2,fp,-16
 d026fc8:	10800003 	ldbu	r2,0(r2)
 d026fcc:	18800005 	stb	r2,0(r3)
 d026fd0:	e0bff917 	ldw	r2,-28(fp)
 d026fd4:	10c00084 	addi	r3,r2,2
 d026fd8:	e0bffc04 	addi	r2,fp,-16
 d026fdc:	10800044 	addi	r2,r2,1
 d026fe0:	10800003 	ldbu	r2,0(r2)
 d026fe4:	18800005 	stb	r2,0(r3)
 d026fe8:	e0bff917 	ldw	r2,-28(fp)
 d026fec:	10c00044 	addi	r3,r2,1
 d026ff0:	e0bffc04 	addi	r2,fp,-16
 d026ff4:	10800084 	addi	r2,r2,2
 d026ff8:	10800003 	ldbu	r2,0(r2)
 d026ffc:	18800005 	stb	r2,0(r3)
 d027000:	e0bffc04 	addi	r2,fp,-16
 d027004:	108000c4 	addi	r2,r2,3
 d027008:	10800003 	ldbu	r2,0(r2)
 d02700c:	1007883a 	mov	r3,r2
 d027010:	e0bff917 	ldw	r2,-28(fp)
 d027014:	10c00005 	stb	r3,0(r2)
 d027018:	e0bff917 	ldw	r2,-28(fp)
 d02701c:	10800104 	addi	r2,r2,4
 d027020:	e0bff915 	stw	r2,-28(fp)
   /* add hostname (code 12) */
   PUT_STRING_OPT(opts, 12, dhc_hostname()); 
#endif /* USE_AUTOIP */

   /* Client Fully Qualified Domain Name */
   PUT_STRING_OPT(opts, 81, DC_DOMAINNAME); 
 d027024:	e0fff917 	ldw	r3,-28(fp)
 d027028:	00801444 	movi	r2,81
 d02702c:	18800005 	stb	r2,0(r3)
 d027030:	e0bff917 	ldw	r2,-28(fp)
 d027034:	10800044 	addi	r2,r2,1
 d027038:	e0bff915 	stw	r2,-28(fp)
 d02703c:	00800184 	movi	r2,6
 d027040:	e0bff615 	stw	r2,-40(fp)
 d027044:	e0bff617 	ldw	r2,-40(fp)
 d027048:	1007883a 	mov	r3,r2
 d02704c:	e0bff917 	ldw	r2,-28(fp)
 d027050:	10c00005 	stb	r3,0(r2)
 d027054:	e0bff917 	ldw	r2,-28(fp)
 d027058:	10800044 	addi	r2,r2,1
 d02705c:	e0bff915 	stw	r2,-28(fp)
 d027060:	e13ff917 	ldw	r4,-28(fp)
 d027064:	e1bff617 	ldw	r6,-40(fp)
 d027068:	01434174 	movhi	r5,3333
 d02706c:	297c8904 	addi	r5,r5,-3548
 d027070:	d04a0c40 	call	d04a0c4 <strncpy>
 d027074:	e0bff617 	ldw	r2,-40(fp)
 d027078:	1007883a 	mov	r3,r2
 d02707c:	e0bff917 	ldw	r2,-28(fp)
 d027080:	10c5883a 	add	r2,r2,r3
 d027084:	e0bff915 	stw	r2,-28(fp)
   /* Vendor Class Identifier */
   PUT_STRING_OPT(opts, 60, name); 
 d027088:	e0fff917 	ldw	r3,-28(fp)
 d02708c:	00800f04 	movi	r2,60
 d027090:	18800005 	stb	r2,0(r3)
 d027094:	e0bff917 	ldw	r2,-28(fp)
 d027098:	10800044 	addi	r2,r2,1
 d02709c:	e0bff915 	stw	r2,-28(fp)
 d0270a0:	00834174 	movhi	r2,3333
 d0270a4:	108a6c04 	addi	r2,r2,10672
 d0270a8:	11000017 	ldw	r4,0(r2)
 d0270ac:	d00355c0 	call	d00355c <strlen>
 d0270b0:	e0bff515 	stw	r2,-44(fp)
 d0270b4:	e0bff517 	ldw	r2,-44(fp)
 d0270b8:	1007883a 	mov	r3,r2
 d0270bc:	e0bff917 	ldw	r2,-28(fp)
 d0270c0:	10c00005 	stb	r3,0(r2)
 d0270c4:	e0bff917 	ldw	r2,-28(fp)
 d0270c8:	10800044 	addi	r2,r2,1
 d0270cc:	e0bff915 	stw	r2,-28(fp)
 d0270d0:	e13ff917 	ldw	r4,-28(fp)
 d0270d4:	00834174 	movhi	r2,3333
 d0270d8:	108a6c04 	addi	r2,r2,10672
 d0270dc:	11400017 	ldw	r5,0(r2)
 d0270e0:	e1bff517 	ldw	r6,-44(fp)
 d0270e4:	d04a0c40 	call	d04a0c4 <strncpy>
 d0270e8:	e0bff517 	ldw	r2,-44(fp)
 d0270ec:	1007883a 	mov	r3,r2
 d0270f0:	e0bff917 	ldw	r2,-28(fp)
 d0270f4:	10c5883a 	add	r2,r2,r3
 d0270f8:	e0bff915 	stw	r2,-28(fp)

   *opts++ = DHOP_END;  /* Mark the end of options */
 d0270fc:	e0fff917 	ldw	r3,-28(fp)
 d027100:	00bfffc4 	movi	r2,-1
 d027104:	18800005 	stb	r2,0(r3)
 d027108:	e0bff917 	ldw	r2,-28(fp)
 d02710c:	10800044 	addi	r2,r2,1
 d027110:	e0bff915 	stw	r2,-28(fp)

   /* figure out whether to send via unicast or broadcast */
   if (dhc_states[iface].state == DHCS_RENEWING)
 d027114:	e0bffd17 	ldw	r2,-12(fp)
 d027118:	00c341b4 	movhi	r3,3334
 d02711c:	18f2cb04 	addi	r3,r3,-13524
 d027120:	10800f24 	muli	r2,r2,60
 d027124:	10c5883a 	add	r2,r2,r3
 d027128:	10800017 	ldw	r2,0(r2)
 d02712c:	108001d8 	cmpnei	r2,r2,7
 d027130:	10000a1e 	bne	r2,zero,d02715c <dhc_request+0xa5c>
   {
      pkt->fhost = dhc_states[iface].srv_ipaddr;
 d027134:	e0bffd17 	ldw	r2,-12(fp)
 d027138:	00c341b4 	movhi	r3,3334
 d02713c:	18f2cb04 	addi	r3,r3,-13524
 d027140:	10800f24 	muli	r2,r2,60
 d027144:	10c5883a 	add	r2,r2,r3
 d027148:	10800d04 	addi	r2,r2,52
 d02714c:	10c00017 	ldw	r3,0(r2)
 d027150:	e0bffa17 	ldw	r2,-24(fp)
 d027154:	10c00715 	stw	r3,28(r2)
 d027158:	00000306 	br	d027168 <dhc_request+0xa68>
   }
   else
   {
      pkt->fhost = 0xFFFFFFFF;   /* broadcast request */
 d02715c:	e0fffa17 	ldw	r3,-24(fp)
 d027160:	00bfffc4 	movi	r2,-1
 d027164:	18800715 	stw	r2,28(r3)
   }

   pkt->net = nets[iface];    /* send out caller spec'ed net */
 d027168:	e0bffd17 	ldw	r2,-12(fp)
 d02716c:	00c341b4 	movhi	r3,3334
 d027170:	18f2a504 	addi	r3,r3,-13676
 d027174:	1085883a 	add	r2,r2,r2
 d027178:	1085883a 	add	r2,r2,r2
 d02717c:	10c5883a 	add	r2,r2,r3
 d027180:	10c00017 	ldw	r3,0(r2)
 d027184:	e0bffa17 	ldw	r2,-24(fp)
 d027188:	10c00615 	stw	r3,24(r2)
   pkt->nb_plen = (char *)opts - (char *)outbp;
 d02718c:	e0fff917 	ldw	r3,-28(fp)
 d027190:	e0bffb17 	ldw	r2,-20(fp)
 d027194:	1885c83a 	sub	r2,r3,r2
 d027198:	1007883a 	mov	r3,r2
 d02719c:	e0bffa17 	ldw	r2,-24(fp)
 d0271a0:	10c00415 	stw	r3,16(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 d0271a4:	010010c4 	movi	r4,67
 d0271a8:	01401104 	movi	r5,68
 d0271ac:	e1bffa17 	ldw	r6,-24(fp)
 d0271b0:	d0430e80 	call	d0430e8 <udp_send>
   dsc_requests++;
 d0271b4:	d0a09317 	ldw	r2,-32180(gp)
 d0271b8:	10800044 	addi	r2,r2,1
 d0271bc:	d0a09315 	stw	r2,-32180(gp)

   dhc_states[iface].last_tick = cticks;
 d0271c0:	e13ffd17 	ldw	r4,-12(fp)
 d0271c4:	00834174 	movhi	r2,3333
 d0271c8:	108ac904 	addi	r2,r2,11044
 d0271cc:	11400017 	ldw	r5,0(r2)
 d0271d0:	00c341b4 	movhi	r3,3334
 d0271d4:	18f2cb04 	addi	r3,r3,-13524
 d0271d8:	20800f24 	muli	r2,r4,60
 d0271dc:	10c5883a 	add	r2,r2,r3
 d0271e0:	10800404 	addi	r2,r2,16
 d0271e4:	11400015 	stw	r5,0(r2)
   dhc_states[iface].tries++;
 d0271e8:	e17ffd17 	ldw	r5,-12(fp)
 d0271ec:	00c341b4 	movhi	r3,3334
 d0271f0:	18f2cb04 	addi	r3,r3,-13524
 d0271f4:	28800f24 	muli	r2,r5,60
 d0271f8:	10c5883a 	add	r2,r2,r3
 d0271fc:	10800104 	addi	r2,r2,4
 d027200:	10800017 	ldw	r2,0(r2)
 d027204:	11000044 	addi	r4,r2,1
 d027208:	00c341b4 	movhi	r3,3334
 d02720c:	18f2cb04 	addi	r3,r3,-13524
 d027210:	28800f24 	muli	r2,r5,60
 d027214:	10c5883a 	add	r2,r2,r3
 d027218:	10800104 	addi	r2,r2,4
 d02721c:	11000015 	stw	r4,0(r2)

   return 0;   /* return OK code */
 d027220:	e03fff15 	stw	zero,-4(fp)
 d027224:	e0bfff17 	ldw	r2,-4(fp)
}
 d027228:	e037883a 	mov	sp,fp
 d02722c:	dfc00117 	ldw	ra,4(sp)
 d027230:	df000017 	ldw	fp,0(sp)
 d027234:	dec00204 	addi	sp,sp,8
 d027238:	f800283a 	ret

0d02723c <dhc_setip>:
 * RETURNS: Returns 0 if ok, else non-zero ENP error.
 */

int
dhc_setip(int iface)
{
 d02723c:	defffd04 	addi	sp,sp,-12
 d027240:	dfc00215 	stw	ra,8(sp)
 d027244:	df000115 	stw	fp,4(sp)
 d027248:	df000104 	addi	fp,sp,4
 d02724c:	e13fff15 	stw	r4,-4(fp)
   nets[iface]->n_ipaddr = dhc_states[iface].ipaddr;
 d027250:	e0bfff17 	ldw	r2,-4(fp)
 d027254:	00c341b4 	movhi	r3,3334
 d027258:	18f2a504 	addi	r3,r3,-13676
 d02725c:	1085883a 	add	r2,r2,r2
 d027260:	1085883a 	add	r2,r2,r2
 d027264:	10c5883a 	add	r2,r2,r3
 d027268:	11000017 	ldw	r4,0(r2)
 d02726c:	e0bfff17 	ldw	r2,-4(fp)
 d027270:	00c341b4 	movhi	r3,3334
 d027274:	18f2cb04 	addi	r3,r3,-13524
 d027278:	10800f24 	muli	r2,r2,60
 d02727c:	10c5883a 	add	r2,r2,r3
 d027280:	10800904 	addi	r2,r2,36
 d027284:	10800017 	ldw	r2,0(r2)
 d027288:	20800a15 	stw	r2,40(r4)
   nets[iface]->snmask   = dhc_states[iface].snmask;
 d02728c:	e0bfff17 	ldw	r2,-4(fp)
 d027290:	00c341b4 	movhi	r3,3334
 d027294:	18f2a504 	addi	r3,r3,-13676
 d027298:	1085883a 	add	r2,r2,r2
 d02729c:	1085883a 	add	r2,r2,r2
 d0272a0:	10c5883a 	add	r2,r2,r3
 d0272a4:	11000017 	ldw	r4,0(r2)
 d0272a8:	e0bfff17 	ldw	r2,-4(fp)
 d0272ac:	00c341b4 	movhi	r3,3334
 d0272b0:	18f2cb04 	addi	r3,r3,-13524
 d0272b4:	10800f24 	muli	r2,r2,60
 d0272b8:	10c5883a 	add	r2,r2,r3
 d0272bc:	10800a04 	addi	r2,r2,40
 d0272c0:	10800017 	ldw	r2,0(r2)
 d0272c4:	20800c15 	stw	r2,48(r4)
   nets[iface]->n_defgw  = dhc_states[iface].defgw;
 d0272c8:	e0bfff17 	ldw	r2,-4(fp)
 d0272cc:	00c341b4 	movhi	r3,3334
 d0272d0:	18f2a504 	addi	r3,r3,-13676
 d0272d4:	1085883a 	add	r2,r2,r2
 d0272d8:	1085883a 	add	r2,r2,r2
 d0272dc:	10c5883a 	add	r2,r2,r3
 d0272e0:	11000017 	ldw	r4,0(r2)
 d0272e4:	e0bfff17 	ldw	r2,-4(fp)
 d0272e8:	00c341b4 	movhi	r3,3334
 d0272ec:	18f2cb04 	addi	r3,r3,-13524
 d0272f0:	10800f24 	muli	r2,r2,60
 d0272f4:	10c5883a 	add	r2,r2,r3
 d0272f8:	10800b04 	addi	r2,r2,44
 d0272fc:	10800017 	ldw	r2,0(r2)
 d027300:	20800d15 	stw	r2,52(r4)

   if ( nets[iface]->snmask == 0 )
 d027304:	e0bfff17 	ldw	r2,-4(fp)
 d027308:	00c341b4 	movhi	r3,3334
 d02730c:	18f2a504 	addi	r3,r3,-13676
 d027310:	1085883a 	add	r2,r2,r2
 d027314:	1085883a 	add	r2,r2,r2
 d027318:	10c5883a 	add	r2,r2,r3
 d02731c:	10800017 	ldw	r2,0(r2)
 d027320:	10800c17 	ldw	r2,48(r2)
 d027324:	1004c03a 	cmpne	r2,r2,zero
 d027328:	1000111e 	bne	r2,zero,d027370 <dhc_setip+0x134>
   {
      fixup_subnet_mask(iface);
 d02732c:	e13fff17 	ldw	r4,-4(fp)
 d027330:	d0218e80 	call	d0218e8 <fixup_subnet_mask>
      dhc_states[iface].snmask = nets[iface]->snmask; 
 d027334:	e17fff17 	ldw	r5,-4(fp)
 d027338:	e0bfff17 	ldw	r2,-4(fp)
 d02733c:	00c341b4 	movhi	r3,3334
 d027340:	18f2a504 	addi	r3,r3,-13676
 d027344:	1085883a 	add	r2,r2,r2
 d027348:	1085883a 	add	r2,r2,r2
 d02734c:	10c5883a 	add	r2,r2,r3
 d027350:	10800017 	ldw	r2,0(r2)
 d027354:	11000c17 	ldw	r4,48(r2)
 d027358:	00c341b4 	movhi	r3,3334
 d02735c:	18f2cb04 	addi	r3,r3,-13524
 d027360:	28800f24 	muli	r2,r5,60
 d027364:	10c5883a 	add	r2,r2,r3
 d027368:	10800a04 	addi	r2,r2,40
 d02736c:	11000015 	stw	r4,0(r2)
   }

   /* fixup broadcast addresses */
   nets[iface]->n_netbr    = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 d027370:	e0bfff17 	ldw	r2,-4(fp)
 d027374:	00c341b4 	movhi	r3,3334
 d027378:	18f2a504 	addi	r3,r3,-13676
 d02737c:	1085883a 	add	r2,r2,r2
 d027380:	1085883a 	add	r2,r2,r2
 d027384:	10c5883a 	add	r2,r2,r3
 d027388:	11400017 	ldw	r5,0(r2)
 d02738c:	e0bfff17 	ldw	r2,-4(fp)
 d027390:	00c341b4 	movhi	r3,3334
 d027394:	18f2a504 	addi	r3,r3,-13676
 d027398:	1085883a 	add	r2,r2,r2
 d02739c:	1085883a 	add	r2,r2,r2
 d0273a0:	10c5883a 	add	r2,r2,r3
 d0273a4:	10800017 	ldw	r2,0(r2)
 d0273a8:	11000a17 	ldw	r4,40(r2)
 d0273ac:	e0bfff17 	ldw	r2,-4(fp)
 d0273b0:	00c341b4 	movhi	r3,3334
 d0273b4:	18f2a504 	addi	r3,r3,-13676
 d0273b8:	1085883a 	add	r2,r2,r2
 d0273bc:	1085883a 	add	r2,r2,r2
 d0273c0:	10c5883a 	add	r2,r2,r3
 d0273c4:	10800017 	ldw	r2,0(r2)
 d0273c8:	10800c17 	ldw	r2,48(r2)
 d0273cc:	0084303a 	nor	r2,zero,r2
 d0273d0:	2084b03a 	or	r2,r4,r2
 d0273d4:	28800e15 	stw	r2,56(r5)
   nets[iface]->n_netbr42  = nets[iface]->n_ipaddr &  nets[iface]->snmask;
 d0273d8:	e0bfff17 	ldw	r2,-4(fp)
 d0273dc:	00c341b4 	movhi	r3,3334
 d0273e0:	18f2a504 	addi	r3,r3,-13676
 d0273e4:	1085883a 	add	r2,r2,r2
 d0273e8:	1085883a 	add	r2,r2,r2
 d0273ec:	10c5883a 	add	r2,r2,r3
 d0273f0:	11400017 	ldw	r5,0(r2)
 d0273f4:	e0bfff17 	ldw	r2,-4(fp)
 d0273f8:	00c341b4 	movhi	r3,3334
 d0273fc:	18f2a504 	addi	r3,r3,-13676
 d027400:	1085883a 	add	r2,r2,r2
 d027404:	1085883a 	add	r2,r2,r2
 d027408:	10c5883a 	add	r2,r2,r3
 d02740c:	10800017 	ldw	r2,0(r2)
 d027410:	11000a17 	ldw	r4,40(r2)
 d027414:	e0bfff17 	ldw	r2,-4(fp)
 d027418:	00c341b4 	movhi	r3,3334
 d02741c:	18f2a504 	addi	r3,r3,-13676
 d027420:	1085883a 	add	r2,r2,r2
 d027424:	1085883a 	add	r2,r2,r2
 d027428:	10c5883a 	add	r2,r2,r3
 d02742c:	10800017 	ldw	r2,0(r2)
 d027430:	10800c17 	ldw	r2,48(r2)
 d027434:	2084703a 	and	r2,r4,r2
 d027438:	28800f15 	stw	r2,60(r5)
   nets[iface]->n_subnetbr = nets[iface]->n_ipaddr | ~nets[iface]->snmask;
 d02743c:	e0bfff17 	ldw	r2,-4(fp)
 d027440:	00c341b4 	movhi	r3,3334
 d027444:	18f2a504 	addi	r3,r3,-13676
 d027448:	1085883a 	add	r2,r2,r2
 d02744c:	1085883a 	add	r2,r2,r2
 d027450:	10c5883a 	add	r2,r2,r3
 d027454:	11400017 	ldw	r5,0(r2)
 d027458:	e0bfff17 	ldw	r2,-4(fp)
 d02745c:	00c341b4 	movhi	r3,3334
 d027460:	18f2a504 	addi	r3,r3,-13676
 d027464:	1085883a 	add	r2,r2,r2
 d027468:	1085883a 	add	r2,r2,r2
 d02746c:	10c5883a 	add	r2,r2,r3
 d027470:	10800017 	ldw	r2,0(r2)
 d027474:	11000a17 	ldw	r4,40(r2)
 d027478:	e0bfff17 	ldw	r2,-4(fp)
 d02747c:	00c341b4 	movhi	r3,3334
 d027480:	18f2a504 	addi	r3,r3,-13676
 d027484:	1085883a 	add	r2,r2,r2
 d027488:	1085883a 	add	r2,r2,r2
 d02748c:	10c5883a 	add	r2,r2,r3
 d027490:	10800017 	ldw	r2,0(r2)
 d027494:	10800c17 	ldw	r2,48(r2)
 d027498:	0084303a 	nor	r2,zero,r2
 d02749c:	2084b03a 	or	r2,r4,r2
 d0274a0:	28801015 	stw	r2,64(r5)

   return 0;   /* return OK code */
 d0274a4:	0005883a 	mov	r2,zero
}
 d0274a8:	e037883a 	mov	sp,fp
 d0274ac:	dfc00117 	ldw	ra,4(sp)
 d0274b0:	df000017 	ldw	fp,0(sp)
 d0274b4:	dec00204 	addi	sp,sp,8
 d0274b8:	f800283a 	ret

0d0274bc <dhc_resetip>:
 * RETURNS: Returns 0 if ok, else non-zero error. 
 */

int
dhc_resetip(int iface)
{
 d0274bc:	defffe04 	addi	sp,sp,-8
 d0274c0:	df000115 	stw	fp,4(sp)
 d0274c4:	df000104 	addi	fp,sp,4
 d0274c8:	e13fff15 	stw	r4,-4(fp)
   /* reset the ipaddress */
   nets[iface]->n_ipaddr = 0;
 d0274cc:	e0bfff17 	ldw	r2,-4(fp)
 d0274d0:	00c341b4 	movhi	r3,3334
 d0274d4:	18f2a504 	addi	r3,r3,-13676
 d0274d8:	1085883a 	add	r2,r2,r2
 d0274dc:	1085883a 	add	r2,r2,r2
 d0274e0:	10c5883a 	add	r2,r2,r3
 d0274e4:	10800017 	ldw	r2,0(r2)
 d0274e8:	10000a15 	stw	zero,40(r2)
   nets[iface]->snmask   = 0;
 d0274ec:	e0bfff17 	ldw	r2,-4(fp)
 d0274f0:	00c341b4 	movhi	r3,3334
 d0274f4:	18f2a504 	addi	r3,r3,-13676
 d0274f8:	1085883a 	add	r2,r2,r2
 d0274fc:	1085883a 	add	r2,r2,r2
 d027500:	10c5883a 	add	r2,r2,r3
 d027504:	10800017 	ldw	r2,0(r2)
 d027508:	10000c15 	stw	zero,48(r2)
   nets[iface]->n_defgw  = 0;
 d02750c:	e0bfff17 	ldw	r2,-4(fp)
 d027510:	00c341b4 	movhi	r3,3334
 d027514:	18f2a504 	addi	r3,r3,-13676
 d027518:	1085883a 	add	r2,r2,r2
 d02751c:	1085883a 	add	r2,r2,r2
 d027520:	10c5883a 	add	r2,r2,r3
 d027524:	10800017 	ldw	r2,0(r2)
 d027528:	10000d15 	stw	zero,52(r2)

   /* reset the broadcast addresses */
   nets[iface]->n_netbr    = 0;
 d02752c:	e0bfff17 	ldw	r2,-4(fp)
 d027530:	00c341b4 	movhi	r3,3334
 d027534:	18f2a504 	addi	r3,r3,-13676
 d027538:	1085883a 	add	r2,r2,r2
 d02753c:	1085883a 	add	r2,r2,r2
 d027540:	10c5883a 	add	r2,r2,r3
 d027544:	10800017 	ldw	r2,0(r2)
 d027548:	10000e15 	stw	zero,56(r2)
   nets[iface]->n_netbr42  = 0;
 d02754c:	e0bfff17 	ldw	r2,-4(fp)
 d027550:	00c341b4 	movhi	r3,3334
 d027554:	18f2a504 	addi	r3,r3,-13676
 d027558:	1085883a 	add	r2,r2,r2
 d02755c:	1085883a 	add	r2,r2,r2
 d027560:	10c5883a 	add	r2,r2,r3
 d027564:	10800017 	ldw	r2,0(r2)
 d027568:	10000f15 	stw	zero,60(r2)
   nets[iface]->n_subnetbr = 0;
 d02756c:	e0bfff17 	ldw	r2,-4(fp)
 d027570:	00c341b4 	movhi	r3,3334
 d027574:	18f2a504 	addi	r3,r3,-13676
 d027578:	1085883a 	add	r2,r2,r2
 d02757c:	1085883a 	add	r2,r2,r2
 d027580:	10c5883a 	add	r2,r2,r3
 d027584:	10800017 	ldw	r2,0(r2)
 d027588:	10001015 	stw	zero,64(r2)

   return 0;   /* return OK code */
 d02758c:	0005883a 	mov	r2,zero
}
 d027590:	e037883a 	mov	sp,fp
 d027594:	df000017 	ldw	fp,0(sp)
 d027598:	dec00104 	addi	sp,sp,4
 d02759c:	f800283a 	ret

0d0275a0 <dhc_decline>:
 * RETURNS: Returns 0 if ok, else non-zero ENP_ error. 
 */

int
dhc_decline(int iface,struct bootp * bp, unsigned bplen)
{
 d0275a0:	defff704 	addi	sp,sp,-36
 d0275a4:	dfc00815 	stw	ra,32(sp)
 d0275a8:	df000715 	stw	fp,28(sp)
 d0275ac:	df000704 	addi	fp,sp,28
 d0275b0:	e13ffc15 	stw	r4,-16(fp)
 d0275b4:	e17ffd15 	stw	r5,-12(fp)
 d0275b8:	e1bffe15 	stw	r6,-8(fp)
   struct bootp * outbp;
   PACKET pkt;
   u_char * opts;    /* scratch pointer to DHCP options field */

   /* get a UDP packet buffer for sending DHCP */
   pkt = udp_alloc(bplen, 0);
 d0275bc:	e13ffe17 	ldw	r4,-8(fp)
 d0275c0:	000b883a 	mov	r5,zero
 d0275c4:	d0435a00 	call	d0435a0 <udp_alloc>
 d0275c8:	e0bffa15 	stw	r2,-24(fp)
   if (!pkt) 
 d0275cc:	e0bffa17 	ldw	r2,-24(fp)
 d0275d0:	1004c03a 	cmpne	r2,r2,zero
 d0275d4:	1000031e 	bne	r2,zero,d0275e4 <dhc_decline+0x44>
      return ENP_NOMEM;
 d0275d8:	00bffb04 	movi	r2,-20
 d0275dc:	e0bfff15 	stw	r2,-4(fp)
 d0275e0:	00002f06 	br	d0276a0 <dhc_decline+0x100>
   pkt->nb_plen = bplen;
 d0275e4:	e0fffa17 	ldw	r3,-24(fp)
 d0275e8:	e0bffe17 	ldw	r2,-8(fp)
 d0275ec:	18800415 	stw	r2,16(r3)

   outbp = (struct bootp *)pkt->nb_prot;
 d0275f0:	e0bffa17 	ldw	r2,-24(fp)
 d0275f4:	10800317 	ldw	r2,12(r2)
 d0275f8:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(outbp, bp, bplen);
 d0275fc:	e0bffb17 	ldw	r2,-20(fp)
 d027600:	e0fffd17 	ldw	r3,-12(fp)
 d027604:	1009883a 	mov	r4,r2
 d027608:	180b883a 	mov	r5,r3
 d02760c:	e1bffe17 	ldw	r6,-8(fp)
 d027610:	d0027000 	call	d002700 <memcpy>
   outbp->op = BOOTREQUEST;
 d027614:	e0fffb17 	ldw	r3,-20(fp)
 d027618:	00800044 	movi	r2,1
 d02761c:	18800005 	stb	r2,0(r3)

   /* find DHCP TYPE option so we can overwrite it */   
   opts = find_opt(DHOP_TYPE, &outbp->options[4]);
 d027620:	e0bffb17 	ldw	r2,-20(fp)
 d027624:	10803b04 	addi	r2,r2,236
 d027628:	11400104 	addi	r5,r2,4
 d02762c:	01000d44 	movi	r4,53
 d027630:	d0284480 	call	d028448 <find_opt>
 d027634:	e0bff915 	stw	r2,-28(fp)
   opts += 2;     /* point to actual op code */
 d027638:	e0bff917 	ldw	r2,-28(fp)
 d02763c:	10800084 	addi	r2,r2,2
 d027640:	e0bff915 	stw	r2,-28(fp)
   *opts = DHCP_DECLINE;   /* overwrite op code */
 d027644:	e0fff917 	ldw	r3,-28(fp)
 d027648:	00800104 	movi	r2,4
 d02764c:	18800005 	stb	r2,0(r3)

   pkt->fhost = 0xFFFFFFFF;   /* broadcast decline pkt */
 d027650:	e0fffa17 	ldw	r3,-24(fp)
 d027654:	00bfffc4 	movi	r2,-1
 d027658:	18800715 	stw	r2,28(r3)
   pkt->net = nets[iface];    /* send out caller speced net */
 d02765c:	e0bffc17 	ldw	r2,-16(fp)
 d027660:	00c341b4 	movhi	r3,3334
 d027664:	18f2a504 	addi	r3,r3,-13676
 d027668:	1085883a 	add	r2,r2,r2
 d02766c:	1085883a 	add	r2,r2,r2
 d027670:	10c5883a 	add	r2,r2,r3
 d027674:	10c00017 	ldw	r3,0(r2)
 d027678:	e0bffa17 	ldw	r2,-24(fp)
 d02767c:	10c00615 	stw	r3,24(r2)
   udp_send(BOOTP_SERVER_PORT, BOOTP_CLIENT_PORT, pkt);
 d027680:	010010c4 	movi	r4,67
 d027684:	01401104 	movi	r5,68
 d027688:	e1bffa17 	ldw	r6,-24(fp)
 d02768c:	d0430e80 	call	d0430e8 <udp_send>
   dsc_declines++;   /* count declines sent */
 d027690:	d0a09617 	ldw	r2,-32168(gp)
 d027694:	10800044 	addi	r2,r2,1
 d027698:	d0a09615 	stw	r2,-32168(gp)
   return 0;
 d02769c:	e03fff15 	stw	zero,-4(fp)
 d0276a0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0276a4:	e037883a 	mov	sp,fp
 d0276a8:	dfc00117 	ldw	ra,4(sp)
 d0276ac:	df000017 	ldw	fp,0(sp)
 d0276b0:	dec00204 	addi	sp,sp,8
 d0276b4:	f800283a 	ret

0d0276b8 <dh_getlong>:
 *
 * RETURNS: the extracted 32 bit value
 */

static   long dh_getlong( u_char *ptr )
{
 d0276b8:	defffc04 	addi	sp,sp,-16
 d0276bc:	df000315 	stw	fp,12(sp)
 d0276c0:	df000304 	addi	fp,sp,12
 d0276c4:	e13fff15 	stw	r4,-4(fp)
     long  v;
     u_char * p2 =  (u_char *)&v;
 d0276c8:	e0bffe04 	addi	r2,fp,-8
 d0276cc:	e0bffd15 	stw	r2,-12(fp)

   *p2++ = *ptr++;
 d0276d0:	e0bfff17 	ldw	r2,-4(fp)
 d0276d4:	10c00003 	ldbu	r3,0(r2)
 d0276d8:	e0bffd17 	ldw	r2,-12(fp)
 d0276dc:	10c00005 	stb	r3,0(r2)
 d0276e0:	e0bffd17 	ldw	r2,-12(fp)
 d0276e4:	10800044 	addi	r2,r2,1
 d0276e8:	e0bffd15 	stw	r2,-12(fp)
 d0276ec:	e0bfff17 	ldw	r2,-4(fp)
 d0276f0:	10800044 	addi	r2,r2,1
 d0276f4:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 d0276f8:	e0bfff17 	ldw	r2,-4(fp)
 d0276fc:	10c00003 	ldbu	r3,0(r2)
 d027700:	e0bffd17 	ldw	r2,-12(fp)
 d027704:	10c00005 	stb	r3,0(r2)
 d027708:	e0bffd17 	ldw	r2,-12(fp)
 d02770c:	10800044 	addi	r2,r2,1
 d027710:	e0bffd15 	stw	r2,-12(fp)
 d027714:	e0bfff17 	ldw	r2,-4(fp)
 d027718:	10800044 	addi	r2,r2,1
 d02771c:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 d027720:	e0bfff17 	ldw	r2,-4(fp)
 d027724:	10c00003 	ldbu	r3,0(r2)
 d027728:	e0bffd17 	ldw	r2,-12(fp)
 d02772c:	10c00005 	stb	r3,0(r2)
 d027730:	e0bffd17 	ldw	r2,-12(fp)
 d027734:	10800044 	addi	r2,r2,1
 d027738:	e0bffd15 	stw	r2,-12(fp)
 d02773c:	e0bfff17 	ldw	r2,-4(fp)
 d027740:	10800044 	addi	r2,r2,1
 d027744:	e0bfff15 	stw	r2,-4(fp)
   *p2++ = *ptr++;
 d027748:	e0bfff17 	ldw	r2,-4(fp)
 d02774c:	10c00003 	ldbu	r3,0(r2)
 d027750:	e0bffd17 	ldw	r2,-12(fp)
 d027754:	10c00005 	stb	r3,0(r2)
 d027758:	e0bffd17 	ldw	r2,-12(fp)
 d02775c:	10800044 	addi	r2,r2,1
 d027760:	e0bffd15 	stw	r2,-12(fp)
 d027764:	e0bfff17 	ldw	r2,-4(fp)
 d027768:	10800044 	addi	r2,r2,1
 d02776c:	e0bfff15 	stw	r2,-4(fp)

   return v;
 d027770:	e0bffe17 	ldw	r2,-8(fp)
}
 d027774:	e037883a 	mov	sp,fp
 d027778:	df000017 	ldw	fp,0(sp)
 d02777c:	dec00104 	addi	sp,sp,4
 d027780:	f800283a 	ret

0d027784 <dhc_extract_opts>:
 * of the options passed were filled in with good values. 
 */

int
dhc_extract_opts(int iface, u_char *opts)
{
 d027784:	defff604 	addi	sp,sp,-40
 d027788:	dfc00915 	stw	ra,36(sp)
 d02778c:	df000815 	stw	fp,32(sp)
 d027790:	dc400715 	stw	r17,28(sp)
 d027794:	dc000615 	stw	r16,24(sp)
 d027798:	df000604 	addi	fp,sp,24
 d02779c:	e13ffc15 	stw	r4,-16(fp)
 d0277a0:	e17ffd15 	stw	r5,-12(fp)
   u_char *end = opts + DHCP_OPTSIZE;  /* limit scope of search */
 d0277a4:	e0bffd17 	ldw	r2,-12(fp)
 d0277a8:	10804e04 	addi	r2,r2,312
 d0277ac:	e0bffb15 	stw	r2,-20(fp)
   u_char optlen;

   /* first, clear the options */
   dhc_states[iface].snmask = 0; 
 d0277b0:	e0bffc17 	ldw	r2,-16(fp)
 d0277b4:	00c341b4 	movhi	r3,3334
 d0277b8:	18f2cb04 	addi	r3,r3,-13524
 d0277bc:	10800f24 	muli	r2,r2,60
 d0277c0:	10c5883a 	add	r2,r2,r3
 d0277c4:	10800a04 	addi	r2,r2,40
 d0277c8:	10000015 	stw	zero,0(r2)
   dhc_states[iface].defgw = 0; 
 d0277cc:	e0bffc17 	ldw	r2,-16(fp)
 d0277d0:	00c341b4 	movhi	r3,3334
 d0277d4:	18f2cb04 	addi	r3,r3,-13524
 d0277d8:	10800f24 	muli	r2,r2,60
 d0277dc:	10c5883a 	add	r2,r2,r3
 d0277e0:	10800b04 	addi	r2,r2,44
 d0277e4:	10000015 	stw	zero,0(r2)
   dhc_states[iface].lease = 0; 
 d0277e8:	e0bffc17 	ldw	r2,-16(fp)
 d0277ec:	00c341b4 	movhi	r3,3334
 d0277f0:	18f2cb04 	addi	r3,r3,-13524
 d0277f4:	10800f24 	muli	r2,r2,60
 d0277f8:	10c5883a 	add	r2,r2,r3
 d0277fc:	10800504 	addi	r2,r2,20
 d027800:	10000015 	stw	zero,0(r2)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 d027804:	00008006 	br	d027a08 <dhc_extract_opts+0x284>
   {
      switch (*opts++)
 d027808:	e0bffd17 	ldw	r2,-12(fp)
 d02780c:	10800003 	ldbu	r2,0(r2)
 d027810:	10803fcc 	andi	r2,r2,255
 d027814:	e0bfff15 	stw	r2,-4(fp)
 d027818:	e0bffd17 	ldw	r2,-12(fp)
 d02781c:	10800044 	addi	r2,r2,1
 d027820:	e0bffd15 	stw	r2,-12(fp)
 d027824:	e0ffff17 	ldw	r3,-4(fp)
 d027828:	188000e0 	cmpeqi	r2,r3,3
 d02782c:	1000271e 	bne	r2,zero,d0278cc <dhc_extract_opts+0x148>
 d027830:	e0ffff17 	ldw	r3,-4(fp)
 d027834:	18800108 	cmpgei	r2,r3,4
 d027838:	1000071e 	bne	r2,zero,d027858 <dhc_extract_opts+0xd4>
 d02783c:	e0ffff17 	ldw	r3,-4(fp)
 d027840:	1805003a 	cmpeq	r2,r3,zero
 d027844:	1000701e 	bne	r2,zero,d027a08 <dhc_extract_opts+0x284>
 d027848:	e0ffff17 	ldw	r3,-4(fp)
 d02784c:	18800060 	cmpeqi	r2,r3,1
 d027850:	10000d1e 	bne	r2,zero,d027888 <dhc_extract_opts+0x104>
 d027854:	00006406 	br	d0279e8 <dhc_extract_opts+0x264>
 d027858:	e0ffff17 	ldw	r3,-4(fp)
 d02785c:	18800ce0 	cmpeqi	r2,r3,51
 d027860:	1000331e 	bne	r2,zero,d027930 <dhc_extract_opts+0x1ac>
 d027864:	e0ffff17 	ldw	r3,-4(fp)
 d027868:	18803fe0 	cmpeqi	r2,r3,255
 d02786c:	1000041e 	bne	r2,zero,d027880 <dhc_extract_opts+0xfc>
 d027870:	e0ffff17 	ldw	r3,-4(fp)
 d027874:	188001a0 	cmpeqi	r2,r3,6
 d027878:	10004f1e 	bne	r2,zero,d0279b8 <dhc_extract_opts+0x234>
 d02787c:	00005a06 	br	d0279e8 <dhc_extract_opts+0x264>
      {
      case DHOP_PAD:
         break;
      case DHOP_END:
         return 0;   /* only good exit point */
 d027880:	e03ffe15 	stw	zero,-8(fp)
 d027884:	00006606 	br	d027a20 <dhc_extract_opts+0x29c>
      case DHOP_SNMASK:
         opts++;
 d027888:	e0bffd17 	ldw	r2,-12(fp)
 d02788c:	10800044 	addi	r2,r2,1
 d027890:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].snmask = dh_getlong(opts);
 d027894:	e43ffc17 	ldw	r16,-16(fp)
 d027898:	e13ffd17 	ldw	r4,-12(fp)
 d02789c:	d0276b80 	call	d0276b8 <dh_getlong>
 d0278a0:	1009883a 	mov	r4,r2
 d0278a4:	00c341b4 	movhi	r3,3334
 d0278a8:	18f2cb04 	addi	r3,r3,-13524
 d0278ac:	80800f24 	muli	r2,r16,60
 d0278b0:	10c5883a 	add	r2,r2,r3
 d0278b4:	10800a04 	addi	r2,r2,40
 d0278b8:	11000015 	stw	r4,0(r2)
         opts += 4;
 d0278bc:	e0bffd17 	ldw	r2,-12(fp)
 d0278c0:	10800104 	addi	r2,r2,4
 d0278c4:	e0bffd15 	stw	r2,-12(fp)
         break;
 d0278c8:	00004f06 	br	d027a08 <dhc_extract_opts+0x284>
      case DHOP_ROUTER:
         optlen = *opts++;
 d0278cc:	e0bffd17 	ldw	r2,-12(fp)
 d0278d0:	10800003 	ldbu	r2,0(r2)
 d0278d4:	e0bffa05 	stb	r2,-24(fp)
 d0278d8:	e0bffd17 	ldw	r2,-12(fp)
 d0278dc:	10800044 	addi	r2,r2,1
 d0278e0:	e0bffd15 	stw	r2,-12(fp)
         if (optlen >= 4)
 d0278e4:	e0bffa03 	ldbu	r2,-24(fp)
 d0278e8:	10800130 	cmpltui	r2,r2,4
 d0278ec:	10000a1e 	bne	r2,zero,d027918 <dhc_extract_opts+0x194>
            dhc_states[iface].defgw = dh_getlong(opts);
 d0278f0:	e43ffc17 	ldw	r16,-16(fp)
 d0278f4:	e13ffd17 	ldw	r4,-12(fp)
 d0278f8:	d0276b80 	call	d0276b8 <dh_getlong>
 d0278fc:	1009883a 	mov	r4,r2
 d027900:	00c341b4 	movhi	r3,3334
 d027904:	18f2cb04 	addi	r3,r3,-13524
 d027908:	80800f24 	muli	r2,r16,60
 d02790c:	10c5883a 	add	r2,r2,r3
 d027910:	10800b04 	addi	r2,r2,44
 d027914:	11000015 	stw	r4,0(r2)
         opts += optlen;
 d027918:	e0bffa03 	ldbu	r2,-24(fp)
 d02791c:	1007883a 	mov	r3,r2
 d027920:	e0bffd17 	ldw	r2,-12(fp)
 d027924:	10c5883a 	add	r2,r2,r3
 d027928:	e0bffd15 	stw	r2,-12(fp)
         break;
 d02792c:	00003606 	br	d027a08 <dhc_extract_opts+0x284>
      case DHOP_LEASE:
         opts++;
 d027930:	e0bffd17 	ldw	r2,-12(fp)
 d027934:	10800044 	addi	r2,r2,1
 d027938:	e0bffd15 	stw	r2,-12(fp)
         dhc_states[iface].lease = htonl(dh_getlong(opts));
 d02793c:	e47ffc17 	ldw	r17,-16(fp)
 d027940:	e13ffd17 	ldw	r4,-12(fp)
 d027944:	d0276b80 	call	d0276b8 <dh_getlong>
 d027948:	1005d63a 	srai	r2,r2,24
 d02794c:	14003fcc 	andi	r16,r2,255
 d027950:	e13ffd17 	ldw	r4,-12(fp)
 d027954:	d0276b80 	call	d0276b8 <dh_getlong>
 d027958:	1005d23a 	srai	r2,r2,8
 d02795c:	10bfc00c 	andi	r2,r2,65280
 d027960:	80a0b03a 	or	r16,r16,r2
 d027964:	e13ffd17 	ldw	r4,-12(fp)
 d027968:	d0276b80 	call	d0276b8 <dh_getlong>
 d02796c:	10bfc00c 	andi	r2,r2,65280
 d027970:	1004923a 	slli	r2,r2,8
 d027974:	80a0b03a 	or	r16,r16,r2
 d027978:	e13ffd17 	ldw	r4,-12(fp)
 d02797c:	d0276b80 	call	d0276b8 <dh_getlong>
 d027980:	10803fcc 	andi	r2,r2,255
 d027984:	1004963a 	slli	r2,r2,24
 d027988:	8084b03a 	or	r2,r16,r2
 d02798c:	1009883a 	mov	r4,r2
 d027990:	00c341b4 	movhi	r3,3334
 d027994:	18f2cb04 	addi	r3,r3,-13524
 d027998:	88800f24 	muli	r2,r17,60
 d02799c:	10c5883a 	add	r2,r2,r3
 d0279a0:	10800504 	addi	r2,r2,20
 d0279a4:	11000015 	stw	r4,0(r2)
         opts += 4;
 d0279a8:	e0bffd17 	ldw	r2,-12(fp)
 d0279ac:	10800104 	addi	r2,r2,4
 d0279b0:	e0bffd15 	stw	r2,-12(fp)
         break;
 d0279b4:	00001406 	br	d027a08 <dhc_extract_opts+0x284>
      case DHOP_DNSRV:
         optlen = *opts++;
 d0279b8:	e0bffd17 	ldw	r2,-12(fp)
 d0279bc:	10800003 	ldbu	r2,0(r2)
 d0279c0:	e0bffa05 	stb	r2,-24(fp)
 d0279c4:	e0bffd17 	ldw	r2,-12(fp)
 d0279c8:	10800044 	addi	r2,r2,1
 d0279cc:	e0bffd15 	stw	r2,-12(fp)
               opts += 4;
               i++;
            }
         }
#endif   /* DHC_MAXDNSRVS */
         opts += optlen;
 d0279d0:	e0bffa03 	ldbu	r2,-24(fp)
 d0279d4:	1007883a 	mov	r3,r2
 d0279d8:	e0bffd17 	ldw	r2,-12(fp)
 d0279dc:	10c5883a 	add	r2,r2,r3
 d0279e0:	e0bffd15 	stw	r2,-12(fp)
         break;
 d0279e4:	00000806 	br	d027a08 <dhc_extract_opts+0x284>
      default:
         opts += ((*opts) + 1);
 d0279e8:	e0bffd17 	ldw	r2,-12(fp)
 d0279ec:	10800003 	ldbu	r2,0(r2)
 d0279f0:	10803fcc 	andi	r2,r2,255
 d0279f4:	1007883a 	mov	r3,r2
 d0279f8:	e0bffd17 	ldw	r2,-12(fp)
 d0279fc:	1885883a 	add	r2,r3,r2
 d027a00:	10800044 	addi	r2,r2,1
 d027a04:	e0bffd15 	stw	r2,-12(fp)
#if defined(DHC_MAXDNSRVS) && (DHC_MAXDNSRVS > 0)
   MEMSET(dhc_states[iface].dnsrv, 0, sizeof(dhc_states[iface].dnsrv));
#endif   /* DHC_MAXDNSRVS */

   /* then fill them in from the DHCP data */
   while (opts <= end)
 d027a08:	e0fffd17 	ldw	r3,-12(fp)
 d027a0c:	e0bffb17 	ldw	r2,-20(fp)
 d027a10:	10ff7d2e 	bgeu	r2,r3,d027808 <dhc_extract_opts+0x84>
      default:
         opts += ((*opts) + 1);
         break;
      }
   }
   dtrap();
 d027a14:	d0293e80 	call	d0293e8 <dtrap>
   return -1;
 d027a18:	00bfffc4 	movi	r2,-1
 d027a1c:	e0bffe15 	stw	r2,-8(fp)
 d027a20:	e0bffe17 	ldw	r2,-8(fp)
}
 d027a24:	e037883a 	mov	sp,fp
 d027a28:	dfc00317 	ldw	ra,12(sp)
 d027a2c:	df000217 	ldw	fp,8(sp)
 d027a30:	dc400117 	ldw	r17,4(sp)
 d027a34:	dc000017 	ldw	r16,0(sp)
 d027a38:	dec00404 	addi	sp,sp,16
 d027a3c:	f800283a 	ret

0d027a40 <dhc_second>:
 * RETURNS: Returns 0 or ENP_ error code 
 */

int
dhc_second(void)
{
 d027a40:	defff704 	addi	sp,sp,-36
 d027a44:	dfc00815 	stw	ra,32(sp)
 d027a48:	df000715 	stw	fp,28(sp)
 d027a4c:	df000704 	addi	fp,sp,28
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 d027a50:	e03ffc15 	stw	zero,-16(fp)
 d027a54:	00015706 	br	d027fb4 <dhc_second+0x574>
   {
      switch (dhc_states[iface].state)
 d027a58:	e0bffc17 	ldw	r2,-16(fp)
 d027a5c:	00c341b4 	movhi	r3,3334
 d027a60:	18f2cb04 	addi	r3,r3,-13524
 d027a64:	10800f24 	muli	r2,r2,60
 d027a68:	10c5883a 	add	r2,r2,r3
 d027a6c:	10800017 	ldw	r2,0(r2)
 d027a70:	e0bfff15 	stw	r2,-4(fp)
 d027a74:	e0ffff17 	ldw	r3,-4(fp)
 d027a78:	18800268 	cmpgeui	r2,r3,9
 d027a7c:	10014a1e 	bne	r2,zero,d027fa8 <dhc_second+0x568>
 d027a80:	e13fff17 	ldw	r4,-4(fp)
 d027a84:	e13fff17 	ldw	r4,-4(fp)
 d027a88:	2105883a 	add	r2,r4,r4
 d027a8c:	1087883a 	add	r3,r2,r2
 d027a90:	008340b4 	movhi	r2,3330
 d027a94:	109ea904 	addi	r2,r2,31396
 d027a98:	1885883a 	add	r2,r3,r2
 d027a9c:	10800017 	ldw	r2,0(r2)
 d027aa0:	1000683a 	jmp	r2
 d027aa4:	0d027fa8 	cmpgeui	r20,at,2558
 d027aa8:	0d027ac8 	cmpgei	r20,at,2539
 d027aac:	0d027b00 	call	d027b0 <OSCtxSw_SWITCH_PC+0xd02770>
 d027ab0:	0d027b38 	rdprs	r20,at,2540
 d027ab4:	0d027b38 	rdprs	r20,at,2540
 d027ab8:	0d027b38 	rdprs	r20,at,2540
 d027abc:	0d027d9c 	xori	r20,at,2550
 d027ac0:	0d027e54 	ori	r20,at,2553
 d027ac4:	0d027c68 	cmpgeui	r20,at,2545
      {
      case DHCS_INIT:         /* Send a discover packet */
         e = dhc_discover(iface);
 d027ac8:	e13ffc17 	ldw	r4,-16(fp)
 d027acc:	d0260e40 	call	d0260e4 <dhc_discover>
 d027ad0:	e0bffa15 	stw	r2,-24(fp)
         /* Error while sending a discover packet */
         if (e)
 d027ad4:	e0bffa17 	ldw	r2,-24(fp)
 d027ad8:	1005003a 	cmpeq	r2,r2,zero
 d027adc:	1000041e 	bne	r2,zero,d027af0 <dhc_second+0xb0>
         {
            dtrap();
 d027ae0:	d0293e80 	call	d0293e8 <dtrap>
            return e;
 d027ae4:	e0bffa17 	ldw	r2,-24(fp)
 d027ae8:	e0bffe15 	stw	r2,-8(fp)
 d027aec:	00013506 	br	d027fc4 <dhc_second+0x584>
         }
         dhc_set_state(iface,DHCS_SELECTING);
 d027af0:	e13ffc17 	ldw	r4,-16(fp)
 d027af4:	01400104 	movi	r5,4
 d027af8:	d0283980 	call	d028398 <dhc_set_state>
         break;
 d027afc:	00012a06 	br	d027fa8 <dhc_second+0x568>
      case DHCS_INITREBOOT:   /* Send a request packet */
         e = dhc_reclaim(iface);
 d027b00:	e13ffc17 	ldw	r4,-16(fp)
 d027b04:	d0280640 	call	d028064 <dhc_reclaim>
 d027b08:	e0bffa15 	stw	r2,-24(fp)
         if (e)
 d027b0c:	e0bffa17 	ldw	r2,-24(fp)
 d027b10:	1005003a 	cmpeq	r2,r2,zero
 d027b14:	1000041e 	bne	r2,zero,d027b28 <dhc_second+0xe8>
         {
            dtrap();
 d027b18:	d0293e80 	call	d0293e8 <dtrap>
            return e;
 d027b1c:	e0fffa17 	ldw	r3,-24(fp)
 d027b20:	e0fffe15 	stw	r3,-8(fp)
 d027b24:	00012706 	br	d027fc4 <dhc_second+0x584>
         }
         dhc_set_state(iface,DHCS_REBOOTING);
 d027b28:	e13ffc17 	ldw	r4,-16(fp)
 d027b2c:	014000c4 	movi	r5,3
 d027b30:	d0283980 	call	d028398 <dhc_set_state>
         break;
 d027b34:	00011c06 	br	d027fa8 <dhc_second+0x568>
         /* Send discover packet on timeout */
      case DHCS_REBOOTING:
      case DHCS_REQUESTING:
         /* Discovery timeout = DHC_RETRY_TMO secs * (2 ** retries), max 64 */

         tries = dhc_states[iface].tries ;
 d027b38:	e0bffc17 	ldw	r2,-16(fp)
 d027b3c:	00c341b4 	movhi	r3,3334
 d027b40:	18f2cb04 	addi	r3,r3,-13524
 d027b44:	10800f24 	muli	r2,r2,60
 d027b48:	10c5883a 	add	r2,r2,r3
 d027b4c:	10800104 	addi	r2,r2,4
 d027b50:	10800017 	ldw	r2,0(r2)
 d027b54:	e0bffb15 	stw	r2,-20(fp)

         /* Set the exponential count */
         if ( tries >= DHC_MAX_TRIES) 
 d027b58:	e0bffb17 	ldw	r2,-20(fp)
 d027b5c:	10800110 	cmplti	r2,r2,4
 d027b60:	1000021e 	bne	r2,zero,d027b6c <dhc_second+0x12c>
            tries= DHC_MAX_TRIES;
 d027b64:	00800104 	movi	r2,4
 d027b68:	e0bffb15 	stw	r2,-20(fp)
         if ( cticks > (dhc_states[iface].last_tick + 
 d027b6c:	e0bffc17 	ldw	r2,-16(fp)
 d027b70:	00c341b4 	movhi	r3,3334
 d027b74:	18f2cb04 	addi	r3,r3,-13524
 d027b78:	10800f24 	muli	r2,r2,60
 d027b7c:	10c5883a 	add	r2,r2,r3
 d027b80:	10800404 	addi	r2,r2,16
 d027b84:	11000017 	ldw	r4,0(r2)
 d027b88:	00c06404 	movi	r3,400
 d027b8c:	e0bffb17 	ldw	r2,-20(fp)
 d027b90:	1884983a 	sll	r2,r3,r2
 d027b94:	2087883a 	add	r3,r4,r2
 d027b98:	00834174 	movhi	r2,3333
 d027b9c:	108ac904 	addi	r2,r2,11044
 d027ba0:	10800017 	ldw	r2,0(r2)
 d027ba4:	18801c2e 	bgeu	r3,r2,d027c18 <dhc_second+0x1d8>
             (((u_long) (DHC_RETRY_TMO*TPS)) << tries ) ) )
         {
            /* Timeout while waiting for a OFFER/ACK/NAK. Retransmit */
            switch(dhc_states[iface].state)
 d027ba8:	e0bffc17 	ldw	r2,-16(fp)
 d027bac:	00c341b4 	movhi	r3,3334
 d027bb0:	18f2cb04 	addi	r3,r3,-13524
 d027bb4:	10800f24 	muli	r2,r2,60
 d027bb8:	10c5883a 	add	r2,r2,r3
 d027bbc:	10800017 	ldw	r2,0(r2)
 d027bc0:	e0bffd15 	stw	r2,-12(fp)
 d027bc4:	e13ffd17 	ldw	r4,-12(fp)
 d027bc8:	20800120 	cmpeqi	r2,r4,4
 d027bcc:	1000071e 	bne	r2,zero,d027bec <dhc_second+0x1ac>
 d027bd0:	e0fffd17 	ldw	r3,-12(fp)
 d027bd4:	18800160 	cmpeqi	r2,r3,5
 d027bd8:	1000071e 	bne	r2,zero,d027bf8 <dhc_second+0x1b8>
 d027bdc:	e13ffd17 	ldw	r4,-12(fp)
 d027be0:	208000e0 	cmpeqi	r2,r4,3
 d027be4:	1000081e 	bne	r2,zero,d027c08 <dhc_second+0x1c8>
 d027be8:	00000a06 	br	d027c14 <dhc_second+0x1d4>
            {
            case DHCS_SELECTING:
               dhc_discover(iface);
 d027bec:	e13ffc17 	ldw	r4,-16(fp)
 d027bf0:	d0260e40 	call	d0260e4 <dhc_discover>
               break;
 d027bf4:	00000806 	br	d027c18 <dhc_second+0x1d8>
            case DHCS_REQUESTING:
               dhc_request(iface,FALSE);
 d027bf8:	e13ffc17 	ldw	r4,-16(fp)
 d027bfc:	000b883a 	mov	r5,zero
 d027c00:	d0267000 	call	d026700 <dhc_request>
               break;
 d027c04:	00000406 	br	d027c18 <dhc_second+0x1d8>
            case DHCS_REBOOTING:
               dhc_reclaim(iface);
 d027c08:	e13ffc17 	ldw	r4,-16(fp)
 d027c0c:	d0280640 	call	d028064 <dhc_reclaim>
               break;
 d027c10:	00000106 	br	d027c18 <dhc_second+0x1d8>
            default:
               dtrap(); /* bogus state */
 d027c14:	d0293e80 	call	d0293e8 <dtrap>
               break;
            }
         }
         if ( tries == DHC_MAX_TRIES && 
 d027c18:	e0bffb17 	ldw	r2,-20(fp)
 d027c1c:	10800118 	cmpnei	r2,r2,4
 d027c20:	1000e11e 	bne	r2,zero,d027fa8 <dhc_second+0x568>
 d027c24:	e0bffc17 	ldw	r2,-16(fp)
 d027c28:	00c341b4 	movhi	r3,3334
 d027c2c:	18f2cb04 	addi	r3,r3,-13524
 d027c30:	10800f24 	muli	r2,r2,60
 d027c34:	10c5883a 	add	r2,r2,r3
 d027c38:	10800017 	ldw	r2,0(r2)
 d027c3c:	10800120 	cmpeqi	r2,r2,4
 d027c40:	1000d91e 	bne	r2,zero,d027fa8 <dhc_second+0x568>
             (dhc_states[iface].state !=DHCS_SELECTING) )
         {
            /* We have tried enough. Restart from INIT state */
            dhc_set_state(iface,DHCS_RESTARTING);
 d027c44:	e13ffc17 	ldw	r4,-16(fp)
 d027c48:	01400244 	movi	r5,9
 d027c4c:	d0283980 	call	d028398 <dhc_set_state>
            dhc_resetip(iface);
 d027c50:	e13ffc17 	ldw	r4,-16(fp)
 d027c54:	d0274bc0 	call	d0274bc <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 d027c58:	e13ffc17 	ldw	r4,-16(fp)
 d027c5c:	01400044 	movi	r5,1
 d027c60:	d0283980 	call	d028398 <dhc_set_state>
         }
         break;
 d027c64:	0000d006 	br	d027fa8 <dhc_second+0x568>
      case DHCS_REBINDING:
         /* Check for timeout. Retry if we didn't get a ACK/NAK response. */

         if ( (dhc_states[iface].lease*TPS+dhc_states[iface].lease_start) > cticks )
 d027c68:	e0bffc17 	ldw	r2,-16(fp)
 d027c6c:	00c341b4 	movhi	r3,3334
 d027c70:	18f2cb04 	addi	r3,r3,-13524
 d027c74:	10800f24 	muli	r2,r2,60
 d027c78:	10c5883a 	add	r2,r2,r3
 d027c7c:	10800504 	addi	r2,r2,20
 d027c80:	10800017 	ldw	r2,0(r2)
 d027c84:	11001924 	muli	r4,r2,100
 d027c88:	e0bffc17 	ldw	r2,-16(fp)
 d027c8c:	00c341b4 	movhi	r3,3334
 d027c90:	18f2cb04 	addi	r3,r3,-13524
 d027c94:	10800f24 	muli	r2,r2,60
 d027c98:	10c5883a 	add	r2,r2,r3
 d027c9c:	10800804 	addi	r2,r2,32
 d027ca0:	10800017 	ldw	r2,0(r2)
 d027ca4:	2087883a 	add	r3,r4,r2
 d027ca8:	00834174 	movhi	r2,3333
 d027cac:	108ac904 	addi	r2,r2,11044
 d027cb0:	10800017 	ldw	r2,0(r2)
 d027cb4:	10c0302e 	bgeu	r2,r3,d027d78 <dhc_second+0x338>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and lease, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start + 
 d027cb8:	e0bffc17 	ldw	r2,-16(fp)
 d027cbc:	00c341b4 	movhi	r3,3334
 d027cc0:	18f2cb04 	addi	r3,r3,-13524
 d027cc4:	10800f24 	muli	r2,r2,60
 d027cc8:	10c5883a 	add	r2,r2,r3
 d027ccc:	10800804 	addi	r2,r2,32
 d027cd0:	11000017 	ldw	r4,0(r2)
 d027cd4:	e0bffc17 	ldw	r2,-16(fp)
 d027cd8:	00c341b4 	movhi	r3,3334
 d027cdc:	18f2cb04 	addi	r3,r3,-13524
 d027ce0:	10800f24 	muli	r2,r2,60
 d027ce4:	10c5883a 	add	r2,r2,r3
 d027ce8:	10800504 	addi	r2,r2,20
 d027cec:	10800017 	ldw	r2,0(r2)
 d027cf0:	10801924 	muli	r2,r2,100
 d027cf4:	2089883a 	add	r4,r4,r2
 d027cf8:	e0bffc17 	ldw	r2,-16(fp)
 d027cfc:	00c341b4 	movhi	r3,3334
 d027d00:	18f2cb04 	addi	r3,r3,-13524
 d027d04:	10800f24 	muli	r2,r2,60
 d027d08:	10c5883a 	add	r2,r2,r3
 d027d0c:	10800404 	addi	r2,r2,16
 d027d10:	10800017 	ldw	r2,0(r2)
 d027d14:	2085c83a 	sub	r2,r4,r2
 d027d18:	1004d07a 	srli	r2,r2,1
 d027d1c:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].lease*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 d027d20:	e0bff917 	ldw	r2,-28(fp)
 d027d24:	1085dc28 	cmpgeui	r2,r2,6000
 d027d28:	1000021e 	bne	r2,zero,d027d34 <dhc_second+0x2f4>
               half_time = 60*TPS;
 d027d2c:	0085dc04 	movi	r2,6000
 d027d30:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 d027d34:	e0bffc17 	ldw	r2,-16(fp)
 d027d38:	00c341b4 	movhi	r3,3334
 d027d3c:	18f2cb04 	addi	r3,r3,-13524
 d027d40:	10800f24 	muli	r2,r2,60
 d027d44:	10c5883a 	add	r2,r2,r3
 d027d48:	10800404 	addi	r2,r2,16
 d027d4c:	10c00017 	ldw	r3,0(r2)
 d027d50:	e0bff917 	ldw	r2,-28(fp)
 d027d54:	1887883a 	add	r3,r3,r2
 d027d58:	00834174 	movhi	r2,3333
 d027d5c:	108ac904 	addi	r2,r2,11044
 d027d60:	10800017 	ldw	r2,0(r2)
 d027d64:	1880902e 	bgeu	r3,r2,d027fa8 <dhc_second+0x568>
            {
               dhc_request(iface,FALSE);
 d027d68:	e13ffc17 	ldw	r4,-16(fp)
 d027d6c:	000b883a 	mov	r5,zero
 d027d70:	d0267000 	call	d026700 <dhc_request>
 d027d74:	00008c06 	br	d027fa8 <dhc_second+0x568>
            }
         }
         else
         {
            /* Lease has expired. We didn't receive a ACK/NAK. Hence restart*/
            dhc_set_state(iface,DHCS_RESTARTING);
 d027d78:	e13ffc17 	ldw	r4,-16(fp)
 d027d7c:	01400244 	movi	r5,9
 d027d80:	d0283980 	call	d028398 <dhc_set_state>
            dhc_resetip(iface);
 d027d84:	e13ffc17 	ldw	r4,-16(fp)
 d027d88:	d0274bc0 	call	d0274bc <dhc_resetip>
            dhc_set_state(iface,DHCS_INIT);
 d027d8c:	e13ffc17 	ldw	r4,-16(fp)
 d027d90:	01400044 	movi	r5,1
 d027d94:	d0283980 	call	d028398 <dhc_set_state>
         }
         break;
 d027d98:	00008306 	br	d027fa8 <dhc_second+0x568>

      case DHCS_BOUND:
         /* Test for lease expiry. The RENEW timer. */
         if ( (dhc_states[iface].t1 != DHC_INFINITY) &&
 d027d9c:	e0bffc17 	ldw	r2,-16(fp)
 d027da0:	00c341b4 	movhi	r3,3334
 d027da4:	18f2cb04 	addi	r3,r3,-13524
 d027da8:	10800f24 	muli	r2,r2,60
 d027dac:	10c5883a 	add	r2,r2,r3
 d027db0:	10800604 	addi	r2,r2,24
 d027db4:	10800017 	ldw	r2,0(r2)
 d027db8:	10bfffe0 	cmpeqi	r2,r2,-1
 d027dbc:	10007a1e 	bne	r2,zero,d027fa8 <dhc_second+0x568>
 d027dc0:	e0bffc17 	ldw	r2,-16(fp)
 d027dc4:	00c341b4 	movhi	r3,3334
 d027dc8:	18f2cb04 	addi	r3,r3,-13524
 d027dcc:	10800f24 	muli	r2,r2,60
 d027dd0:	10c5883a 	add	r2,r2,r3
 d027dd4:	10800604 	addi	r2,r2,24
 d027dd8:	10800017 	ldw	r2,0(r2)
 d027ddc:	11001924 	muli	r4,r2,100
 d027de0:	e0bffc17 	ldw	r2,-16(fp)
 d027de4:	00c341b4 	movhi	r3,3334
 d027de8:	18f2cb04 	addi	r3,r3,-13524
 d027dec:	10800f24 	muli	r2,r2,60
 d027df0:	10c5883a 	add	r2,r2,r3
 d027df4:	10800804 	addi	r2,r2,32
 d027df8:	10800017 	ldw	r2,0(r2)
 d027dfc:	2087883a 	add	r3,r4,r2
 d027e00:	00834174 	movhi	r2,3333
 d027e04:	108ac904 	addi	r2,r2,11044
 d027e08:	10800017 	ldw	r2,0(r2)
 d027e0c:	1880662e 	bgeu	r3,r2,d027fa8 <dhc_second+0x568>
             (((dhc_states[iface].t1*TPS)+dhc_states[iface].lease_start) < cticks ) )
         {
            /* Time to renew. Send a UNICAST to the DHCP server */
            dhc_set_state(iface,DHCS_RENEWING);
 d027e10:	e13ffc17 	ldw	r4,-16(fp)
 d027e14:	014001c4 	movi	r5,7
 d027e18:	d0283980 	call	d028398 <dhc_set_state>
            e = dhc_reclaim(iface); /* unicast */ 
 d027e1c:	e13ffc17 	ldw	r4,-16(fp)
 d027e20:	d0280640 	call	d028064 <dhc_reclaim>
 d027e24:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 d027e28:	e0bffa17 	ldw	r2,-24(fp)
 d027e2c:	1005003a 	cmpeq	r2,r2,zero
 d027e30:	1000041e 	bne	r2,zero,d027e44 <dhc_second+0x404>
            {
               dtrap();
 d027e34:	d0293e80 	call	d0293e8 <dtrap>
               return e;
 d027e38:	e0bffa17 	ldw	r2,-24(fp)
 d027e3c:	e0bffe15 	stw	r2,-8(fp)
 d027e40:	00006006 	br	d027fc4 <dhc_second+0x584>
            }
            dsc_renew++;
 d027e44:	d0a09917 	ldw	r2,-32156(gp)
 d027e48:	10800044 	addi	r2,r2,1
 d027e4c:	d0a09915 	stw	r2,-32156(gp)
         }
         break;
 d027e50:	00005506 	br	d027fa8 <dhc_second+0x568>
      case DHCS_RENEWING:
         /* Test for lease expiry. The REBIND timer. */
         if ( (dhc_states[iface].t2*TPS+dhc_states[iface].lease_start) > cticks )
 d027e54:	e0bffc17 	ldw	r2,-16(fp)
 d027e58:	00c341b4 	movhi	r3,3334
 d027e5c:	18f2cb04 	addi	r3,r3,-13524
 d027e60:	10800f24 	muli	r2,r2,60
 d027e64:	10c5883a 	add	r2,r2,r3
 d027e68:	10800704 	addi	r2,r2,28
 d027e6c:	10800017 	ldw	r2,0(r2)
 d027e70:	11001924 	muli	r4,r2,100
 d027e74:	e0bffc17 	ldw	r2,-16(fp)
 d027e78:	00c341b4 	movhi	r3,3334
 d027e7c:	18f2cb04 	addi	r3,r3,-13524
 d027e80:	10800f24 	muli	r2,r2,60
 d027e84:	10c5883a 	add	r2,r2,r3
 d027e88:	10800804 	addi	r2,r2,32
 d027e8c:	10800017 	ldw	r2,0(r2)
 d027e90:	2087883a 	add	r3,r4,r2
 d027e94:	00834174 	movhi	r2,3333
 d027e98:	108ac904 	addi	r2,r2,11044
 d027e9c:	10800017 	ldw	r2,0(r2)
 d027ea0:	10c0302e 	bgeu	r2,r3,d027f64 <dhc_second+0x524>
            /* See if we need to retransmit. If we have waiting for 
             * half the time between last transmit and t2, then we 
             * need to retransmit. Also the minimum retransmit 
             * interval is 60 secs. 
             */
            half_time = (dhc_states[iface].lease_start +
 d027ea4:	e0bffc17 	ldw	r2,-16(fp)
 d027ea8:	00c341b4 	movhi	r3,3334
 d027eac:	18f2cb04 	addi	r3,r3,-13524
 d027eb0:	10800f24 	muli	r2,r2,60
 d027eb4:	10c5883a 	add	r2,r2,r3
 d027eb8:	10800804 	addi	r2,r2,32
 d027ebc:	11000017 	ldw	r4,0(r2)
 d027ec0:	e0bffc17 	ldw	r2,-16(fp)
 d027ec4:	00c341b4 	movhi	r3,3334
 d027ec8:	18f2cb04 	addi	r3,r3,-13524
 d027ecc:	10800f24 	muli	r2,r2,60
 d027ed0:	10c5883a 	add	r2,r2,r3
 d027ed4:	10800704 	addi	r2,r2,28
 d027ed8:	10800017 	ldw	r2,0(r2)
 d027edc:	10801924 	muli	r2,r2,100
 d027ee0:	2089883a 	add	r4,r4,r2
 d027ee4:	e0bffc17 	ldw	r2,-16(fp)
 d027ee8:	00c341b4 	movhi	r3,3334
 d027eec:	18f2cb04 	addi	r3,r3,-13524
 d027ef0:	10800f24 	muli	r2,r2,60
 d027ef4:	10c5883a 	add	r2,r2,r3
 d027ef8:	10800404 	addi	r2,r2,16
 d027efc:	10800017 	ldw	r2,0(r2)
 d027f00:	2085c83a 	sub	r2,r4,r2
 d027f04:	1004d07a 	srli	r2,r2,1
 d027f08:	e0bff915 	stw	r2,-28(fp)
             dhc_states[iface].t2*TPS - 
             dhc_states[iface].last_tick)/2;

            if ( half_time < 60*TPS )
 d027f0c:	e0bff917 	ldw	r2,-28(fp)
 d027f10:	1085dc28 	cmpgeui	r2,r2,6000
 d027f14:	1000021e 	bne	r2,zero,d027f20 <dhc_second+0x4e0>
               half_time = 60*TPS;
 d027f18:	0085dc04 	movi	r2,6000
 d027f1c:	e0bff915 	stw	r2,-28(fp)
            if ( dhc_states[iface].last_tick + half_time < cticks )
 d027f20:	e0bffc17 	ldw	r2,-16(fp)
 d027f24:	00c341b4 	movhi	r3,3334
 d027f28:	18f2cb04 	addi	r3,r3,-13524
 d027f2c:	10800f24 	muli	r2,r2,60
 d027f30:	10c5883a 	add	r2,r2,r3
 d027f34:	10800404 	addi	r2,r2,16
 d027f38:	10c00017 	ldw	r3,0(r2)
 d027f3c:	e0bff917 	ldw	r2,-28(fp)
 d027f40:	1887883a 	add	r3,r3,r2
 d027f44:	00834174 	movhi	r2,3333
 d027f48:	108ac904 	addi	r2,r2,11044
 d027f4c:	10800017 	ldw	r2,0(r2)
 d027f50:	1880152e 	bgeu	r3,r2,d027fa8 <dhc_second+0x568>
            {
               dhc_request(iface,FALSE);
 d027f54:	e13ffc17 	ldw	r4,-16(fp)
 d027f58:	000b883a 	mov	r5,zero
 d027f5c:	d0267000 	call	d026700 <dhc_request>
 d027f60:	00001106 	br	d027fa8 <dhc_second+0x568>
         {
            /* No Response has come from the Server that assigned our 
             * IP. Hence send a broadcast packet to see if we can 
             * lease this IP from some other server 
             */
            dhc_set_state(iface,DHCS_REBINDING);
 d027f64:	e13ffc17 	ldw	r4,-16(fp)
 d027f68:	01400204 	movi	r5,8
 d027f6c:	d0283980 	call	d028398 <dhc_set_state>
            e = dhc_request(iface,TRUE);  /* broadcast */
 d027f70:	e13ffc17 	ldw	r4,-16(fp)
 d027f74:	01400044 	movi	r5,1
 d027f78:	d0267000 	call	d026700 <dhc_request>
 d027f7c:	e0bffa15 	stw	r2,-24(fp)
            if (e)
 d027f80:	e0bffa17 	ldw	r2,-24(fp)
 d027f84:	1005003a 	cmpeq	r2,r2,zero
 d027f88:	1000041e 	bne	r2,zero,d027f9c <dhc_second+0x55c>
            {
               dtrap();
 d027f8c:	d0293e80 	call	d0293e8 <dtrap>
               return e;
 d027f90:	e0fffa17 	ldw	r3,-24(fp)
 d027f94:	e0fffe15 	stw	r3,-8(fp)
 d027f98:	00000a06 	br	d027fc4 <dhc_second+0x584>
            }
            dsc_rebind++;
 d027f9c:	d0a09a17 	ldw	r2,-32152(gp)
 d027fa0:	10800044 	addi	r2,r2,1
 d027fa4:	d0a09a15 	stw	r2,-32152(gp)
   int   iface;
   int   tries;
   int   e;
   u_long   half_time;

   for (iface = 0; iface < MAXNETS; iface++)
 d027fa8:	e0bffc17 	ldw	r2,-16(fp)
 d027fac:	10800044 	addi	r2,r2,1
 d027fb0:	e0bffc15 	stw	r2,-16(fp)
 d027fb4:	e0bffc17 	ldw	r2,-16(fp)
 d027fb8:	10800110 	cmplti	r2,r2,4
 d027fbc:	103ea61e 	bne	r2,zero,d027a58 <dhc_second+0x18>
      case DHCS_UNUSED:
      default:
         continue;
      }
   }
   return 0;
 d027fc0:	e03ffe15 	stw	zero,-8(fp)
 d027fc4:	e0bffe17 	ldw	r2,-8(fp)
}
 d027fc8:	e037883a 	mov	sp,fp
 d027fcc:	dfc00117 	ldw	ra,4(sp)
 d027fd0:	df000017 	ldw	fp,0(sp)
 d027fd4:	dec00204 	addi	sp,sp,8
 d027fd8:	f800283a 	ret

0d027fdc <dhc_halt>:
 * RETURNS: void
 */

void
dhc_halt(int iface)
{
 d027fdc:	defffd04 	addi	sp,sp,-12
 d027fe0:	dfc00215 	stw	ra,8(sp)
 d027fe4:	df000115 	stw	fp,4(sp)
 d027fe8:	df000104 	addi	fp,sp,4
 d027fec:	e13fff15 	stw	r4,-4(fp)
   if (iface < 0 || iface > MAXNETS)
 d027ff0:	e0bfff17 	ldw	r2,-4(fp)
 d027ff4:	1004803a 	cmplt	r2,r2,zero
 d027ff8:	1000031e 	bne	r2,zero,d028008 <dhc_halt+0x2c>
 d027ffc:	e0bfff17 	ldw	r2,-4(fp)
 d028000:	10800150 	cmplti	r2,r2,5
 d028004:	1000021e 	bne	r2,zero,d028010 <dhc_halt+0x34>
   {
      dtrap();
 d028008:	d0293e80 	call	d0293e8 <dtrap>
      return;
 d02800c:	00001006 	br	d028050 <dhc_halt+0x74>
   }
   /* clear dhc_states entry - (kills retrys) */
   MEMSET(&dhc_states[iface], 0, sizeof(struct dhc_state));
 d028010:	e0bfff17 	ldw	r2,-4(fp)
 d028014:	10800f24 	muli	r2,r2,60
 d028018:	1007883a 	mov	r3,r2
 d02801c:	008341b4 	movhi	r2,3334
 d028020:	10b2cb04 	addi	r2,r2,-13524
 d028024:	1885883a 	add	r2,r3,r2
 d028028:	1009883a 	mov	r4,r2
 d02802c:	01800f04 	movi	r6,60
 d028030:	000b883a 	mov	r5,zero
 d028034:	d0028800 	call	d002880 <memset>
   dhc_states[iface].state = DHCS_UNUSED;
 d028038:	e0bfff17 	ldw	r2,-4(fp)
 d02803c:	00c341b4 	movhi	r3,3334
 d028040:	18f2cb04 	addi	r3,r3,-13524
 d028044:	10800f24 	muli	r2,r2,60
 d028048:	10c5883a 	add	r2,r2,r3
 d02804c:	10000015 	stw	zero,0(r2)
}
 d028050:	e037883a 	mov	sp,fp
 d028054:	dfc00117 	ldw	ra,4(sp)
 d028058:	df000017 	ldw	fp,0(sp)
 d02805c:	dec00204 	addi	sp,sp,8
 d028060:	f800283a 	ret

0d028064 <dhc_reclaim>:
 * RETURNS: Returns 0 if DHCP request was sent OK, else non-zero error. 
 */

int   
dhc_reclaim(int iface)
{
 d028064:	defffb04 	addi	sp,sp,-20
 d028068:	dfc00415 	stw	ra,16(sp)
 d02806c:	df000315 	stw	fp,12(sp)
 d028070:	df000304 	addi	fp,sp,12
 d028074:	e13ffe15 	stw	r4,-8(fp)
   /* punt if IP address is not set */
   if (nets[iface]->n_ipaddr == 0L)
 d028078:	e0bffe17 	ldw	r2,-8(fp)
 d02807c:	00c341b4 	movhi	r3,3334
 d028080:	18f2a504 	addi	r3,r3,-13676
 d028084:	1085883a 	add	r2,r2,r2
 d028088:	1085883a 	add	r2,r2,r2
 d02808c:	10c5883a 	add	r2,r2,r3
 d028090:	10800017 	ldw	r2,0(r2)
 d028094:	10800a17 	ldw	r2,40(r2)
 d028098:	1004c03a 	cmpne	r2,r2,zero
 d02809c:	1000041e 	bne	r2,zero,d0280b0 <dhc_reclaim+0x4c>
   {
      dtrap();    /* programming bug? */
 d0280a0:	d0293e80 	call	d0293e8 <dtrap>
      return ENP_LOGIC;
 d0280a4:	00bffd44 	movi	r2,-11
 d0280a8:	e0bfff15 	stw	r2,-4(fp)
 d0280ac:	00005b06 	br	d02821c <dhc_reclaim+0x1b8>
   }

   dhc_states[iface].ipaddr = nets[iface]->n_ipaddr;
 d0280b0:	e17ffe17 	ldw	r5,-8(fp)
 d0280b4:	e0bffe17 	ldw	r2,-8(fp)
 d0280b8:	00c341b4 	movhi	r3,3334
 d0280bc:	18f2a504 	addi	r3,r3,-13676
 d0280c0:	1085883a 	add	r2,r2,r2
 d0280c4:	1085883a 	add	r2,r2,r2
 d0280c8:	10c5883a 	add	r2,r2,r3
 d0280cc:	10800017 	ldw	r2,0(r2)
 d0280d0:	11000a17 	ldw	r4,40(r2)
 d0280d4:	00c341b4 	movhi	r3,3334
 d0280d8:	18f2cb04 	addi	r3,r3,-13524
 d0280dc:	28800f24 	muli	r2,r5,60
 d0280e0:	10c5883a 	add	r2,r2,r3
 d0280e4:	10800904 	addi	r2,r2,36
 d0280e8:	11000015 	stw	r4,0(r2)
   dhc_states[iface].snmask = nets[iface]->snmask;
 d0280ec:	e17ffe17 	ldw	r5,-8(fp)
 d0280f0:	e0bffe17 	ldw	r2,-8(fp)
 d0280f4:	00c341b4 	movhi	r3,3334
 d0280f8:	18f2a504 	addi	r3,r3,-13676
 d0280fc:	1085883a 	add	r2,r2,r2
 d028100:	1085883a 	add	r2,r2,r2
 d028104:	10c5883a 	add	r2,r2,r3
 d028108:	10800017 	ldw	r2,0(r2)
 d02810c:	11000c17 	ldw	r4,48(r2)
 d028110:	00c341b4 	movhi	r3,3334
 d028114:	18f2cb04 	addi	r3,r3,-13524
 d028118:	28800f24 	muli	r2,r5,60
 d02811c:	10c5883a 	add	r2,r2,r3
 d028120:	10800a04 	addi	r2,r2,40
 d028124:	11000015 	stw	r4,0(r2)
   dhc_states[iface].defgw  = nets[iface]->n_defgw;
 d028128:	e17ffe17 	ldw	r5,-8(fp)
 d02812c:	e0bffe17 	ldw	r2,-8(fp)
 d028130:	00c341b4 	movhi	r3,3334
 d028134:	18f2a504 	addi	r3,r3,-13676
 d028138:	1085883a 	add	r2,r2,r2
 d02813c:	1085883a 	add	r2,r2,r2
 d028140:	10c5883a 	add	r2,r2,r3
 d028144:	10800017 	ldw	r2,0(r2)
 d028148:	11000d17 	ldw	r4,52(r2)
 d02814c:	00c341b4 	movhi	r3,3334
 d028150:	18f2cb04 	addi	r3,r3,-13524
 d028154:	28800f24 	muli	r2,r5,60
 d028158:	10c5883a 	add	r2,r2,r3
 d02815c:	10800b04 	addi	r2,r2,44
 d028160:	11000015 	stw	r4,0(r2)

#ifdef IP_ROUTING
   /* If the DHCP Server is on other network, route the request
    * from the same DHCP relay agent. To do that, add a route.
    */
   if (dhc_states[iface].rly_ipaddr)
 d028164:	e0bffe17 	ldw	r2,-8(fp)
 d028168:	00c341b4 	movhi	r3,3334
 d02816c:	18f2cb04 	addi	r3,r3,-13524
 d028170:	10800f24 	muli	r2,r2,60
 d028174:	10c5883a 	add	r2,r2,r3
 d028178:	10800c04 	addi	r2,r2,48
 d02817c:	10800017 	ldw	r2,0(r2)
 d028180:	1005003a 	cmpeq	r2,r2,zero
 d028184:	1000211e 	bne	r2,zero,d02820c <dhc_reclaim+0x1a8>
   {
      if (dhc_states[iface].srv_ipaddr)
 d028188:	e0bffe17 	ldw	r2,-8(fp)
 d02818c:	00c341b4 	movhi	r3,3334
 d028190:	18f2cb04 	addi	r3,r3,-13524
 d028194:	10800f24 	muli	r2,r2,60
 d028198:	10c5883a 	add	r2,r2,r3
 d02819c:	10800d04 	addi	r2,r2,52
 d0281a0:	10800017 	ldw	r2,0(r2)
 d0281a4:	1005003a 	cmpeq	r2,r2,zero
 d0281a8:	1000171e 	bne	r2,zero,d028208 <dhc_reclaim+0x1a4>
      {
         /* yes, earlier negotiation was done via a relay agent */
         if ( !add_route(dhc_states[iface].srv_ipaddr, 0xFFFFFFFF,
 d0281ac:	e0bffe17 	ldw	r2,-8(fp)
 d0281b0:	00c341b4 	movhi	r3,3334
 d0281b4:	18f2cb04 	addi	r3,r3,-13524
 d0281b8:	10800f24 	muli	r2,r2,60
 d0281bc:	10c5883a 	add	r2,r2,r3
 d0281c0:	10800d04 	addi	r2,r2,52
 d0281c4:	11000017 	ldw	r4,0(r2)
 d0281c8:	e0bffe17 	ldw	r2,-8(fp)
 d0281cc:	00c341b4 	movhi	r3,3334
 d0281d0:	18f2cb04 	addi	r3,r3,-13524
 d0281d4:	10800f24 	muli	r2,r2,60
 d0281d8:	10c5883a 	add	r2,r2,r3
 d0281dc:	10800c04 	addi	r2,r2,48
 d0281e0:	11800017 	ldw	r6,0(r2)
 d0281e4:	00800084 	movi	r2,2
 d0281e8:	d8800015 	stw	r2,0(sp)
 d0281ec:	017fffc4 	movi	r5,-1
 d0281f0:	e1fffe17 	ldw	r7,-8(fp)
 d0281f4:	d0423240 	call	d042324 <add_route>
 d0281f8:	1004c03a 	cmpne	r2,r2,zero
 d0281fc:	1000031e 	bne	r2,zero,d02820c <dhc_reclaim+0x1a8>
             dhc_states[iface].rly_ipaddr, iface, IPRP_LOCAL))
         {
            /* route was not added. check this case */
            dtrap(); 
 d028200:	d0293e80 	call	d0293e8 <dtrap>
 d028204:	00000106 	br	d02820c <dhc_reclaim+0x1a8>
      else
      {
         /* DHCP relay IP address is set, but DHCP Server IP address is
          * not set ! How can this happen ?
          */
         dtrap();
 d028208:	d0293e80 	call	d0293e8 <dtrap>
      }
   }
#endif  /* IP_ROUTING */

   /* send the request */
   return(dhc_request(iface,TRUE));  
 d02820c:	e13ffe17 	ldw	r4,-8(fp)
 d028210:	01400044 	movi	r5,1
 d028214:	d0267000 	call	d026700 <dhc_request>
 d028218:	e0bfff15 	stw	r2,-4(fp)
 d02821c:	e0bfff17 	ldw	r2,-4(fp)
}
 d028220:	e037883a 	mov	sp,fp
 d028224:	dfc00117 	ldw	ra,4(sp)
 d028228:	df000017 	ldw	fp,0(sp)
 d02822c:	dec00204 	addi	sp,sp,8
 d028230:	f800283a 	ret

0d028234 <dhc_state_init>:
 * RETURNS: void
 */

void 
dhc_state_init(int iface, int init_flag)
{
 d028234:	defffa04 	addi	sp,sp,-24
 d028238:	dfc00515 	stw	ra,20(sp)
 d02823c:	df000415 	stw	fp,16(sp)
 d028240:	df000404 	addi	fp,sp,16
 d028244:	e13ffd15 	stw	r4,-12(fp)
 d028248:	e17ffe15 	stw	r5,-8(fp)
   int state = (init_flag == TRUE) ? DHCS_INIT : DHCS_INITREBOOT;
 d02824c:	e0bffe17 	ldw	r2,-8(fp)
 d028250:	10800058 	cmpnei	r2,r2,1
 d028254:	1000031e 	bne	r2,zero,d028264 <dhc_state_init+0x30>
 d028258:	00800044 	movi	r2,1
 d02825c:	e0bfff15 	stw	r2,-4(fp)
 d028260:	00000206 	br	d02826c <dhc_state_init+0x38>
 d028264:	00800084 	movi	r2,2
 d028268:	e0bfff15 	stw	r2,-4(fp)
 d02826c:	e0bfff17 	ldw	r2,-4(fp)
 d028270:	e0bffc15 	stw	r2,-16(fp)
   
   dhc_set_state(iface, state);
 d028274:	e13ffd17 	ldw	r4,-12(fp)
 d028278:	e17ffc17 	ldw	r5,-16(fp)
 d02827c:	d0283980 	call	d028398 <dhc_set_state>
}
 d028280:	e037883a 	mov	sp,fp
 d028284:	dfc00117 	ldw	ra,4(sp)
 d028288:	df000017 	ldw	fp,0(sp)
 d02828c:	dec00204 	addi	sp,sp,8
 d028290:	f800283a 	ret

0d028294 <dhc_alldone>:
 * otherwise. 
 */

int 
dhc_alldone(void)
{
 d028294:	defffd04 	addi	sp,sp,-12
 d028298:	df000215 	stw	fp,8(sp)
 d02829c:	df000204 	addi	fp,sp,8
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 d0282a0:	e03ffe15 	stw	zero,-8(fp)
 d0282a4:	00001506 	br	d0282fc <dhc_alldone+0x68>
   {
      if ( ( dhc_states[i].state == DHCS_UNUSED ) || 
 d0282a8:	e0bffe17 	ldw	r2,-8(fp)
 d0282ac:	00c341b4 	movhi	r3,3334
 d0282b0:	18f2cb04 	addi	r3,r3,-13524
 d0282b4:	10800f24 	muli	r2,r2,60
 d0282b8:	10c5883a 	add	r2,r2,r3
 d0282bc:	10800017 	ldw	r2,0(r2)
 d0282c0:	1005003a 	cmpeq	r2,r2,zero
 d0282c4:	10000a1e 	bne	r2,zero,d0282f0 <dhc_alldone+0x5c>
 d0282c8:	e0bffe17 	ldw	r2,-8(fp)
 d0282cc:	00c341b4 	movhi	r3,3334
 d0282d0:	18f2cb04 	addi	r3,r3,-13524
 d0282d4:	10800f24 	muli	r2,r2,60
 d0282d8:	10c5883a 	add	r2,r2,r3
 d0282dc:	10800017 	ldw	r2,0(r2)
 d0282e0:	108001a0 	cmpeqi	r2,r2,6
 d0282e4:	1000021e 	bne	r2,zero,d0282f0 <dhc_alldone+0x5c>
      {
         continue ;
      }
      else
      {
         return FALSE ;
 d0282e8:	e03fff15 	stw	zero,-4(fp)
 d0282ec:	00000806 	br	d028310 <dhc_alldone+0x7c>

int 
dhc_alldone(void)
{
   int   i;
   for ( i=0 ; i < MAXNETS ; i++ )
 d0282f0:	e0bffe17 	ldw	r2,-8(fp)
 d0282f4:	10800044 	addi	r2,r2,1
 d0282f8:	e0bffe15 	stw	r2,-8(fp)
 d0282fc:	e0bffe17 	ldw	r2,-8(fp)
 d028300:	10800110 	cmplti	r2,r2,4
 d028304:	103fe81e 	bne	r2,zero,d0282a8 <dhc_alldone+0x14>
      else
      {
         return FALSE ;
      }
   }
   return TRUE ;
 d028308:	00800044 	movi	r2,1
 d02830c:	e0bfff15 	stw	r2,-4(fp)
 d028310:	e0bfff17 	ldw	r2,-4(fp)
}
 d028314:	e037883a 	mov	sp,fp
 d028318:	df000017 	ldw	fp,0(sp)
 d02831c:	dec00104 	addi	sp,sp,4
 d028320:	f800283a 	ret

0d028324 <dhc_ifacedone>:
 * RETURNS: 
 */

int 
dhc_ifacedone(int iface)
{
 d028324:	defffd04 	addi	sp,sp,-12
 d028328:	df000215 	stw	fp,8(sp)
 d02832c:	df000204 	addi	fp,sp,8
 d028330:	e13ffe15 	stw	r4,-8(fp)
   if ( ( dhc_states[iface].state == DHCS_UNUSED ) || 
 d028334:	e0bffe17 	ldw	r2,-8(fp)
 d028338:	00c341b4 	movhi	r3,3334
 d02833c:	18f2cb04 	addi	r3,r3,-13524
 d028340:	10800f24 	muli	r2,r2,60
 d028344:	10c5883a 	add	r2,r2,r3
 d028348:	10800017 	ldw	r2,0(r2)
 d02834c:	1005003a 	cmpeq	r2,r2,zero
 d028350:	1000081e 	bne	r2,zero,d028374 <dhc_ifacedone+0x50>
 d028354:	e0bffe17 	ldw	r2,-8(fp)
 d028358:	00c341b4 	movhi	r3,3334
 d02835c:	18f2cb04 	addi	r3,r3,-13524
 d028360:	10800f24 	muli	r2,r2,60
 d028364:	10c5883a 	add	r2,r2,r3
 d028368:	10800017 	ldw	r2,0(r2)
 d02836c:	10800198 	cmpnei	r2,r2,6
 d028370:	1000031e 	bne	r2,zero,d028380 <dhc_ifacedone+0x5c>
       ( dhc_states[iface].state == DHCS_BOUND  )  )
   {
      return TRUE ;
 d028374:	00800044 	movi	r2,1
 d028378:	e0bfff15 	stw	r2,-4(fp)
 d02837c:	00000106 	br	d028384 <dhc_ifacedone+0x60>
   }
   else
   {
      return FALSE ;
 d028380:	e03fff15 	stw	zero,-4(fp)
 d028384:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d028388:	e037883a 	mov	sp,fp
 d02838c:	df000017 	ldw	fp,0(sp)
 d028390:	dec00104 	addi	sp,sp,4
 d028394:	f800283a 	ret

0d028398 <dhc_set_state>:
 *
 * RETURNS: 
 */

void dhc_set_state(int iface, int state)
{
 d028398:	defffc04 	addi	sp,sp,-16
 d02839c:	dfc00315 	stw	ra,12(sp)
 d0283a0:	df000215 	stw	fp,8(sp)
 d0283a4:	df000204 	addi	fp,sp,8
 d0283a8:	e13ffe15 	stw	r4,-8(fp)
 d0283ac:	e17fff15 	stw	r5,-4(fp)
   dhc_states[iface].state = state; /* Set the new state */
 d0283b0:	e0bffe17 	ldw	r2,-8(fp)
 d0283b4:	e13fff17 	ldw	r4,-4(fp)
 d0283b8:	00c341b4 	movhi	r3,3334
 d0283bc:	18f2cb04 	addi	r3,r3,-13524
 d0283c0:	10800f24 	muli	r2,r2,60
 d0283c4:	10c5883a 	add	r2,r2,r3
 d0283c8:	11000015 	stw	r4,0(r2)
   dhc_states[iface].tries = 0;     /* Reset the number of tries */
 d0283cc:	e0bffe17 	ldw	r2,-8(fp)
 d0283d0:	00c341b4 	movhi	r3,3334
 d0283d4:	18f2cb04 	addi	r3,r3,-13524
 d0283d8:	10800f24 	muli	r2,r2,60
 d0283dc:	10c5883a 	add	r2,r2,r3
 d0283e0:	10800104 	addi	r2,r2,4
 d0283e4:	10000015 	stw	zero,0(r2)

   /* If callback is set, call it */
   if (dhc_states[iface].callback)
 d0283e8:	e0bffe17 	ldw	r2,-8(fp)
 d0283ec:	00c341b4 	movhi	r3,3334
 d0283f0:	18f2cb04 	addi	r3,r3,-13524
 d0283f4:	10800f24 	muli	r2,r2,60
 d0283f8:	10c5883a 	add	r2,r2,r3
 d0283fc:	10800e04 	addi	r2,r2,56
 d028400:	10800017 	ldw	r2,0(r2)
 d028404:	1005003a 	cmpeq	r2,r2,zero
 d028408:	10000a1e 	bne	r2,zero,d028434 <dhc_set_state+0x9c>
      dhc_states[iface].callback(iface,state);
 d02840c:	e0bffe17 	ldw	r2,-8(fp)
 d028410:	00c341b4 	movhi	r3,3334
 d028414:	18f2cb04 	addi	r3,r3,-13524
 d028418:	10800f24 	muli	r2,r2,60
 d02841c:	10c5883a 	add	r2,r2,r3
 d028420:	10800e04 	addi	r2,r2,56
 d028424:	10800017 	ldw	r2,0(r2)
 d028428:	e13ffe17 	ldw	r4,-8(fp)
 d02842c:	e17fff17 	ldw	r5,-4(fp)
 d028430:	103ee83a 	callr	r2
}
 d028434:	e037883a 	mov	sp,fp
 d028438:	dfc00117 	ldw	ra,4(sp)
 d02843c:	df000017 	ldw	fp,0(sp)
 d028440:	dec00204 	addi	sp,sp,8
 d028444:	f800283a 	ret

0d028448 <find_opt>:
 * RETURNS:  Return pointer to that code if found, NULL if not found.
 */

u_char * 
find_opt(u_char opcode, u_char * opts)
{
 d028448:	defffb04 	addi	sp,sp,-20
 d02844c:	df000415 	stw	fp,16(sp)
 d028450:	df000404 	addi	fp,sp,16
 d028454:	e17ffe15 	stw	r5,-8(fp)
 d028458:	e13ffd05 	stb	r4,-12(fp)
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */
 d02845c:	e0bffe17 	ldw	r2,-8(fp)
 d028460:	10804e04 	addi	r2,r2,312
 d028464:	e0bffc15 	stw	r2,-16(fp)

   while (opts < end)
 d028468:	00002106 	br	d0284f0 <find_opt+0xa8>
   {
      if (*opts == opcode) /* found it */
 d02846c:	e0bffe17 	ldw	r2,-8(fp)
 d028470:	10800003 	ldbu	r2,0(r2)
 d028474:	10c03fcc 	andi	r3,r2,255
 d028478:	e0bffd03 	ldbu	r2,-12(fp)
 d02847c:	1880031e 	bne	r3,r2,d02848c <find_opt+0x44>
         return opts;
 d028480:	e0bffe17 	ldw	r2,-8(fp)
 d028484:	e0bfff15 	stw	r2,-4(fp)
 d028488:	00001d06 	br	d028500 <find_opt+0xb8>
      if (*opts == DHOP_END)  /* end of options; opcode not found */
 d02848c:	e0bffe17 	ldw	r2,-8(fp)
 d028490:	10800003 	ldbu	r2,0(r2)
 d028494:	10803fcc 	andi	r2,r2,255
 d028498:	10803fd8 	cmpnei	r2,r2,255
 d02849c:	1000021e 	bne	r2,zero,d0284a8 <find_opt+0x60>
         return NULL;
 d0284a0:	e03fff15 	stw	zero,-4(fp)
 d0284a4:	00001606 	br	d028500 <find_opt+0xb8>
      if (*opts == DHOP_PAD)  /* PAD has only 1 byte */
 d0284a8:	e0bffe17 	ldw	r2,-8(fp)
 d0284ac:	10800003 	ldbu	r2,0(r2)
 d0284b0:	10803fcc 	andi	r2,r2,255
 d0284b4:	1004c03a 	cmpne	r2,r2,zero
 d0284b8:	1000041e 	bne	r2,zero,d0284cc <find_opt+0x84>
         opts++;
 d0284bc:	e0bffe17 	ldw	r2,-8(fp)
 d0284c0:	10800044 	addi	r2,r2,1
 d0284c4:	e0bffe15 	stw	r2,-8(fp)
 d0284c8:	00000906 	br	d0284f0 <find_opt+0xa8>
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
 d0284cc:	e0bffe17 	ldw	r2,-8(fp)
 d0284d0:	10800044 	addi	r2,r2,1
 d0284d4:	10800003 	ldbu	r2,0(r2)
 d0284d8:	10803fcc 	andi	r2,r2,255
 d0284dc:	1007883a 	mov	r3,r2
 d0284e0:	e0bffe17 	ldw	r2,-8(fp)
 d0284e4:	1885883a 	add	r2,r3,r2
 d0284e8:	10800084 	addi	r2,r2,2
 d0284ec:	e0bffe15 	stw	r2,-8(fp)
u_char * 
find_opt(u_char opcode, u_char * opts)
{
   u_char * end   =  opts  +  DHCP_OPTSIZE;  /* limit scope of search */

   while (opts < end)
 d0284f0:	e0fffe17 	ldw	r3,-8(fp)
 d0284f4:	e0bffc17 	ldw	r2,-16(fp)
 d0284f8:	18bfdc36 	bltu	r3,r2,d02846c <find_opt+0x24>
         opts++;
      else     /* all other options should have a length field */
         opts += (*(opts+1))+2;
   }
   /* no DHOP_END option?? */
   return NULL;
 d0284fc:	e03fff15 	stw	zero,-4(fp)
 d028500:	e0bfff17 	ldw	r2,-4(fp)
}
 d028504:	e037883a 	mov	sp,fp
 d028508:	df000017 	ldw	fp,0(sp)
 d02850c:	dec00104 	addi	sp,sp,4
 d028510:	f800283a 	ret

0d028514 <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 d028514:	defff704 	addi	sp,sp,-36
 d028518:	dfc00815 	stw	ra,32(sp)
 d02851c:	df000715 	stw	fp,28(sp)
 d028520:	df000704 	addi	fp,sp,28
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 d028524:	d0a03817 	ldw	r2,-32544(gp)
 d028528:	d0e03617 	ldw	r3,-32552(gp)
 d02852c:	10c5883a 	add	r2,r2,r3
 d028530:	e0bffc15 	stw	r2,-16(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 d028534:	e03ffb05 	stb	zero,-20(fp)
#endif

   for (i = 0; i < numpkts; i++)
 d028538:	e03ffd15 	stw	zero,-12(fp)
 d02853c:	00007e06 	br	d028738 <pk_init+0x224>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 d028540:	01000d04 	movi	r4,52
 d028544:	d029e2c0 	call	d029e2c <npalloc>
 d028548:	e0bffe15 	stw	r2,-8(fp)
      if (packet == NULL)
 d02854c:	e0bffe17 	ldw	r2,-8(fp)
 d028550:	1005003a 	cmpeq	r2,r2,zero
 d028554:	1000871e 	bne	r2,zero,d028774 <pk_init+0x260>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 d028558:	e0bffd17 	ldw	r2,-12(fp)
 d02855c:	10800f30 	cmpltui	r2,r2,60
 d028560:	1000061e 	bne	r2,zero,d02857c <pk_init+0x68>
      {
         dprintf("pk_init: bad define\n");
 d028564:	01034174 	movhi	r4,3333
 d028568:	213c8b04 	addi	r4,r4,-3540
 d02856c:	d002cc00 	call	d002cc0 <puts>
         return -1;
 d028570:	00bfffc4 	movi	r2,-1
 d028574:	e0bfff15 	stw	r2,-4(fp)
 d028578:	00008406 	br	d02878c <pk_init+0x278>
      }
      pktlog[i] = packet;     /* save for debugging */
 d02857c:	e0bffd17 	ldw	r2,-12(fp)
 d028580:	00c341b4 	movhi	r3,3334
 d028584:	18f31004 	addi	r3,r3,-13248
 d028588:	1085883a 	add	r2,r2,r2
 d02858c:	1085883a 	add	r2,r2,r2
 d028590:	10c7883a 	add	r3,r2,r3
 d028594:	e0bffe17 	ldw	r2,-8(fp)
 d028598:	18800015 	stw	r2,0(r3)
#endif

      packet->nb_tstamp = 0L;
 d02859c:	e0bffe17 	ldw	r2,-8(fp)
 d0285a0:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 d0285a4:	d0e03817 	ldw	r3,-32544(gp)
 d0285a8:	e0bffd17 	ldw	r2,-12(fp)
 d0285ac:	10c0302e 	bgeu	r2,r3,d028670 <pk_init+0x15c>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 d0285b0:	d0a03917 	ldw	r2,-32540(gp)
 d0285b4:	11000144 	addi	r4,r2,5
 d0285b8:	d029fd80 	call	d029fd8 <ncpalloc>
 d0285bc:	1007883a 	mov	r3,r2
 d0285c0:	e0bffe17 	ldw	r2,-8(fp)
 d0285c4:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 d0285c8:	e0bffe17 	ldw	r2,-8(fp)
 d0285cc:	10800117 	ldw	r2,4(r2)
 d0285d0:	1005003a 	cmpeq	r2,r2,zero
 d0285d4:	1000671e 	bne	r2,zero,d028774 <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 d0285d8:	e03ffa15 	stw	zero,-24(fp)
 d0285dc:	00000906 	br	d028604 <pk_init+0xf0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 d0285e0:	e0bffe17 	ldw	r2,-8(fp)
 d0285e4:	10c00117 	ldw	r3,4(r2)
 d0285e8:	e0bffa17 	ldw	r2,-24(fp)
 d0285ec:	1887883a 	add	r3,r3,r2
 d0285f0:	00801344 	movi	r2,77
 d0285f4:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 d0285f8:	e0bffa17 	ldw	r2,-24(fp)
 d0285fc:	10800044 	addi	r2,r2,1
 d028600:	e0bffa15 	stw	r2,-24(fp)
 d028604:	e0bffa17 	ldw	r2,-24(fp)
 d028608:	10800110 	cmplti	r2,r2,4
 d02860c:	103ff41e 	bne	r2,zero,d0285e0 <pk_init+0xcc>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 d028610:	e0bffe17 	ldw	r2,-8(fp)
 d028614:	10c00117 	ldw	r3,4(r2)
 d028618:	d0a03917 	ldw	r2,-32540(gp)
 d02861c:	1885883a 	add	r2,r3,r2
 d028620:	10c00104 	addi	r3,r2,4
 d028624:	00801344 	movi	r2,77
 d028628:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 d02862c:	e0bffe17 	ldw	r2,-8(fp)
 d028630:	10800117 	ldw	r2,4(r2)
 d028634:	10c00104 	addi	r3,r2,4
 d028638:	e0bffe17 	ldw	r2,-8(fp)
 d02863c:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 d028640:	e0bffe17 	ldw	r2,-8(fp)
 d028644:	10800117 	ldw	r2,4(r2)
 d028648:	1005003a 	cmpeq	r2,r2,zero
 d02864c:	1000491e 	bne	r2,zero,d028774 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 d028650:	d0e03917 	ldw	r3,-32540(gp)
 d028654:	e0bffe17 	ldw	r2,-8(fp)
 d028658:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 d02865c:	010341b4 	movhi	r4,3334
 d028660:	21334c04 	addi	r4,r4,-13008
 d028664:	e17ffe17 	ldw	r5,-8(fp)
 d028668:	d028d780 	call	d028d78 <putq>
 d02866c:	00002f06 	br	d02872c <pk_init+0x218>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 d028670:	d0a03717 	ldw	r2,-32548(gp)
 d028674:	11000144 	addi	r4,r2,5
 d028678:	d029fd80 	call	d029fd8 <ncpalloc>
 d02867c:	1007883a 	mov	r3,r2
 d028680:	e0bffe17 	ldw	r2,-8(fp)
 d028684:	10c00115 	stw	r3,4(r2)
            if (!(packet->nb_buff))
 d028688:	e0bffe17 	ldw	r2,-8(fp)
 d02868c:	10800117 	ldw	r2,4(r2)
 d028690:	1005003a 	cmpeq	r2,r2,zero
 d028694:	1000371e 	bne	r2,zero,d028774 <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 d028698:	e03ff915 	stw	zero,-28(fp)
 d02869c:	00000906 	br	d0286c4 <pk_init+0x1b0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 d0286a0:	e0bffe17 	ldw	r2,-8(fp)
 d0286a4:	10c00117 	ldw	r3,4(r2)
 d0286a8:	e0bff917 	ldw	r2,-28(fp)
 d0286ac:	1887883a 	add	r3,r3,r2
 d0286b0:	00801344 	movi	r2,77
 d0286b4:	18800005 	stb	r2,0(r3)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 d0286b8:	e0bff917 	ldw	r2,-28(fp)
 d0286bc:	10800044 	addi	r2,r2,1
 d0286c0:	e0bff915 	stw	r2,-28(fp)
 d0286c4:	e0bff917 	ldw	r2,-28(fp)
 d0286c8:	10800110 	cmplti	r2,r2,4
 d0286cc:	103ff41e 	bne	r2,zero,d0286a0 <pk_init+0x18c>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 d0286d0:	e0bffe17 	ldw	r2,-8(fp)
 d0286d4:	10c00117 	ldw	r3,4(r2)
 d0286d8:	d0a03717 	ldw	r2,-32548(gp)
 d0286dc:	1885883a 	add	r2,r3,r2
 d0286e0:	10c00104 	addi	r3,r2,4
 d0286e4:	00801344 	movi	r2,77
 d0286e8:	18800005 	stb	r2,0(r3)
            packet->nb_buff += ALIGN_TYPE;
 d0286ec:	e0bffe17 	ldw	r2,-8(fp)
 d0286f0:	10800117 	ldw	r2,4(r2)
 d0286f4:	10c00104 	addi	r3,r2,4
 d0286f8:	e0bffe17 	ldw	r2,-8(fp)
 d0286fc:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 d028700:	e0bffe17 	ldw	r2,-8(fp)
 d028704:	10800117 	ldw	r2,4(r2)
 d028708:	1005003a 	cmpeq	r2,r2,zero
 d02870c:	1000191e 	bne	r2,zero,d028774 <pk_init+0x260>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 d028710:	d0e03717 	ldw	r3,-32548(gp)
 d028714:	e0bffe17 	ldw	r2,-8(fp)
 d028718:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 d02871c:	010341b4 	movhi	r4,3334
 d028720:	21330704 	addi	r4,r4,-13284
 d028724:	e17ffe17 	ldw	r5,-8(fp)
 d028728:	d028d780 	call	d028d78 <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 d02872c:	e0bffd17 	ldw	r2,-12(fp)
 d028730:	10800044 	addi	r2,r2,1
 d028734:	e0bffd15 	stw	r2,-12(fp)
 d028738:	e0fffd17 	ldw	r3,-12(fp)
 d02873c:	e0bffc17 	ldw	r2,-16(fp)
 d028740:	18bf7f36 	bltu	r3,r2,d028540 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 d028744:	d0a03817 	ldw	r2,-32544(gp)
 d028748:	1007883a 	mov	r3,r2
 d02874c:	008341b4 	movhi	r2,3334
 d028750:	10b34c04 	addi	r2,r2,-13008
 d028754:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 d028758:	d0a03617 	ldw	r2,-32552(gp)
 d02875c:	1007883a 	mov	r3,r2
 d028760:	008341b4 	movhi	r2,3334
 d028764:	10b30704 	addi	r2,r2,-13284
 d028768:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 d02876c:	e03fff15 	stw	zero,-4(fp)
 d028770:	00000606 	br	d02878c <pk_init+0x278>

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 d028774:	01034174 	movhi	r4,3333
 d028778:	213c9004 	addi	r4,r4,-3520
 d02877c:	e17ffd17 	ldw	r5,-12(fp)
 d028780:	d0029980 	call	d002998 <printf>
#endif
   return(-1);
 d028784:	00bfffc4 	movi	r2,-1
 d028788:	e0bfff15 	stw	r2,-4(fp)
 d02878c:	e0bfff17 	ldw	r2,-4(fp)
}
 d028790:	e037883a 	mov	sp,fp
 d028794:	dfc00117 	ldw	ra,4(sp)
 d028798:	df000017 	ldw	fp,0(sp)
 d02879c:	dec00204 	addi	sp,sp,8
 d0287a0:	f800283a 	ret

0d0287a4 <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 d0287a4:	defffb04 	addi	sp,sp,-20
 d0287a8:	dfc00415 	stw	ra,16(sp)
 d0287ac:	df000315 	stw	fp,12(sp)
 d0287b0:	df000304 	addi	fp,sp,12
 d0287b4:	e13ffe15 	stw	r4,-8(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 d0287b8:	d0e03917 	ldw	r3,-32540(gp)
 d0287bc:	e0bffe17 	ldw	r2,-8(fp)
 d0287c0:	1880022e 	bgeu	r3,r2,d0287cc <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 d0287c4:	e03fff15 	stw	zero,-4(fp)
 d0287c8:	00002706 	br	d028868 <pk_alloc+0xc4>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 d0287cc:	d0e03717 	ldw	r3,-32548(gp)
 d0287d0:	e0bffe17 	ldw	r2,-8(fp)
 d0287d4:	18800536 	bltu	r3,r2,d0287ec <pk_alloc+0x48>
 d0287d8:	008341b4 	movhi	r2,3334
 d0287dc:	10b30704 	addi	r2,r2,-13284
 d0287e0:	10800217 	ldw	r2,8(r2)
 d0287e4:	1004c03a 	cmpne	r2,r2,zero
 d0287e8:	1000051e 	bne	r2,zero,d028800 <pk_alloc+0x5c>
         p = (PACKET)getq(&bigfreeq);
 d0287ec:	010341b4 	movhi	r4,3334
 d0287f0:	21334c04 	addi	r4,r4,-13008
 d0287f4:	d028cb00 	call	d028cb0 <getq>
 d0287f8:	e0bffd15 	stw	r2,-12(fp)
      return(NULL);
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 d0287fc:	00000406 	br	d028810 <pk_alloc+0x6c>
         p = (PACKET)getq(&bigfreeq);
      else
         p = (PACKET)getq(&lilfreeq);
 d028800:	010341b4 	movhi	r4,3334
 d028804:	21330704 	addi	r4,r4,-13284
 d028808:	d028cb00 	call	d028cb0 <getq>
 d02880c:	e0bffd15 	stw	r2,-12(fp)

      if (!p)
 d028810:	e0bffd17 	ldw	r2,-12(fp)
 d028814:	1004c03a 	cmpne	r2,r2,zero
 d028818:	1000021e 	bne	r2,zero,d028824 <pk_alloc+0x80>
         return NULL;
 d02881c:	e03fff15 	stw	zero,-4(fp)
 d028820:	00001106 	br	d028868 <pk_alloc+0xc4>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 d028824:	e0bffd17 	ldw	r2,-12(fp)
 d028828:	10c00117 	ldw	r3,4(r2)
 d02882c:	00834174 	movhi	r2,3333
 d028830:	108aa204 	addi	r2,r2,10888
 d028834:	10800017 	ldw	r2,0(r2)
 d028838:	1887883a 	add	r3,r3,r2
 d02883c:	e0bffd17 	ldw	r2,-12(fp)
 d028840:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 d028844:	e0bffd17 	ldw	r2,-12(fp)
 d028848:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 d02884c:	e0bffd17 	ldw	r2,-12(fp)
 d028850:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 d028854:	e0fffd17 	ldw	r3,-12(fp)
 d028858:	00800044 	movi	r2,1
 d02885c:	18800915 	stw	r2,36(r3)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 d028860:	e0bffd17 	ldw	r2,-12(fp)
 d028864:	e0bfff15 	stw	r2,-4(fp)
 d028868:	e0bfff17 	ldw	r2,-4(fp)
}
 d02886c:	e037883a 	mov	sp,fp
 d028870:	dfc00117 	ldw	ra,4(sp)
 d028874:	df000017 	ldw	fp,0(sp)
 d028878:	dec00204 	addi	sp,sp,8
 d02887c:	f800283a 	ret

0d028880 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 d028880:	defffa04 	addi	sp,sp,-24
 d028884:	dfc00515 	stw	ra,20(sp)
 d028888:	df000415 	stw	fp,16(sp)
 d02888c:	df000404 	addi	fp,sp,16
 d028890:	e13ffe15 	stw	r4,-8(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 d028894:	e0bffe17 	ldw	r2,-8(fp)
 d028898:	10800017 	ldw	r2,0(r2)
 d02889c:	1005003a 	cmpeq	r2,r2,zero
 d0288a0:	1000101e 	bne	r2,zero,d0288e4 <pk_validate+0x64>
 d0288a4:	e0bffe17 	ldw	r2,-8(fp)
 d0288a8:	10800917 	ldw	r2,36(r2)
 d0288ac:	1005003a 	cmpeq	r2,r2,zero
 d0288b0:	10000c1e 	bne	r2,zero,d0288e4 <pk_validate+0x64>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 d0288b4:	d0295e80 	call	d0295e8 <irq_Mask>
 d0288b8:	008341b4 	movhi	r2,3334
 d0288bc:	10b30c04 	addi	r2,r2,-13264
 d0288c0:	10800317 	ldw	r2,12(r2)
 d0288c4:	10c00044 	addi	r3,r2,1
 d0288c8:	008341b4 	movhi	r2,3334
 d0288cc:	10b30c04 	addi	r2,r2,-13264
 d0288d0:	10c00315 	stw	r3,12(r2)
 d0288d4:	d0296440 	call	d029644 <irq_Unmask>
      return -1;
 d0288d8:	00bfffc4 	movi	r2,-1
 d0288dc:	e0bfff15 	stw	r2,-4(fp)
 d0288e0:	00008f06 	br	d028b20 <pk_validate+0x2a0>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 d0288e4:	e0bffe17 	ldw	r2,-8(fp)
 d0288e8:	10c00217 	ldw	r3,8(r2)
 d0288ec:	d0a03917 	ldw	r2,-32540(gp)
 d0288f0:	1880221e 	bne	r3,r2,d02897c <pk_validate+0xfc>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 d0288f4:	d0295e80 	call	d0295e8 <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 d0288f8:	008341b4 	movhi	r2,3334
 d0288fc:	10b34c04 	addi	r2,r2,-13008
 d028900:	10800017 	ldw	r2,0(r2)
 d028904:	e0bffd15 	stw	r2,-12(fp)
 d028908:	00001706 	br	d028968 <pk_validate+0xe8>
            if (p == pkt)
 d02890c:	e0fffd17 	ldw	r3,-12(fp)
 d028910:	e0bffe17 	ldw	r2,-8(fp)
 d028914:	1880111e 	bne	r3,r2,d02895c <pk_validate+0xdc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 d028918:	01034174 	movhi	r4,3333
 d02891c:	213c9b04 	addi	r4,r4,-3476
 d028920:	e17ffe17 	ldw	r5,-8(fp)
 d028924:	d0029980 	call	d002998 <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 d028928:	d0296440 	call	d029644 <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 d02892c:	d0295e80 	call	d0295e8 <irq_Mask>
 d028930:	008341b4 	movhi	r2,3334
 d028934:	10b30c04 	addi	r2,r2,-13264
 d028938:	10800217 	ldw	r2,8(r2)
 d02893c:	10c00044 	addi	r3,r2,1
 d028940:	008341b4 	movhi	r2,3334
 d028944:	10b30c04 	addi	r2,r2,-13264
 d028948:	10c00215 	stw	r3,8(r2)
 d02894c:	d0296440 	call	d029644 <irq_Unmask>
               return -1;
 d028950:	00bfffc4 	movi	r2,-1
 d028954:	e0bfff15 	stw	r2,-4(fp)
 d028958:	00007106 	br	d028b20 <pk_validate+0x2a0>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 d02895c:	e0bffd17 	ldw	r2,-12(fp)
 d028960:	10800017 	ldw	r2,0(r2)
 d028964:	e0bffd15 	stw	r2,-12(fp)
 d028968:	e0bffd17 	ldw	r2,-12(fp)
 d02896c:	1004c03a 	cmpne	r2,r2,zero
 d028970:	103fe61e 	bne	r2,zero,d02890c <pk_validate+0x8c>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 d028974:	d0296440 	call	d029644 <irq_Unmask>
 d028978:	00003206 	br	d028a44 <pk_validate+0x1c4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 d02897c:	e0bffe17 	ldw	r2,-8(fp)
 d028980:	10c00217 	ldw	r3,8(r2)
 d028984:	d0a03717 	ldw	r2,-32548(gp)
 d028988:	1880221e 	bne	r3,r2,d028a14 <pk_validate+0x194>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 d02898c:	d0295e80 	call	d0295e8 <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 d028990:	008341b4 	movhi	r2,3334
 d028994:	10b30704 	addi	r2,r2,-13284
 d028998:	10800017 	ldw	r2,0(r2)
 d02899c:	e0bffd15 	stw	r2,-12(fp)
 d0289a0:	00001706 	br	d028a00 <pk_validate+0x180>
            if (p == pkt)
 d0289a4:	e0fffd17 	ldw	r3,-12(fp)
 d0289a8:	e0bffe17 	ldw	r2,-8(fp)
 d0289ac:	1880111e 	bne	r3,r2,d0289f4 <pk_validate+0x174>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 d0289b0:	01034174 	movhi	r4,3333
 d0289b4:	213ca504 	addi	r4,r4,-3436
 d0289b8:	e17ffe17 	ldw	r5,-8(fp)
 d0289bc:	d0029980 	call	d002998 <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 d0289c0:	d0296440 	call	d029644 <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 d0289c4:	d0295e80 	call	d0295e8 <irq_Mask>
 d0289c8:	008341b4 	movhi	r2,3334
 d0289cc:	10b30c04 	addi	r2,r2,-13264
 d0289d0:	10800217 	ldw	r2,8(r2)
 d0289d4:	10c00044 	addi	r3,r2,1
 d0289d8:	008341b4 	movhi	r2,3334
 d0289dc:	10b30c04 	addi	r2,r2,-13264
 d0289e0:	10c00215 	stw	r3,8(r2)
 d0289e4:	d0296440 	call	d029644 <irq_Unmask>
            return -1;
 d0289e8:	00bfffc4 	movi	r2,-1
 d0289ec:	e0bfff15 	stw	r2,-4(fp)
 d0289f0:	00004b06 	br	d028b20 <pk_validate+0x2a0>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 d0289f4:	e0bffd17 	ldw	r2,-12(fp)
 d0289f8:	10800017 	ldw	r2,0(r2)
 d0289fc:	e0bffd15 	stw	r2,-12(fp)
 d028a00:	e0bffd17 	ldw	r2,-12(fp)
 d028a04:	1004c03a 	cmpne	r2,r2,zero
 d028a08:	103fe61e 	bne	r2,zero,d0289a4 <pk_validate+0x124>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 d028a0c:	d0296440 	call	d029644 <irq_Unmask>
 d028a10:	00000c06 	br	d028a44 <pk_validate+0x1c4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 d028a14:	d0295e80 	call	d0295e8 <irq_Mask>
 d028a18:	008341b4 	movhi	r2,3334
 d028a1c:	10b30c04 	addi	r2,r2,-13264
 d028a20:	10800017 	ldw	r2,0(r2)
 d028a24:	10c00044 	addi	r3,r2,1
 d028a28:	008341b4 	movhi	r2,3334
 d028a2c:	10b30c04 	addi	r2,r2,-13264
 d028a30:	10c00015 	stw	r3,0(r2)
 d028a34:	d0296440 	call	d029644 <irq_Unmask>
         return -1;
 d028a38:	00bfffc4 	movi	r2,-1
 d028a3c:	e0bfff15 	stw	r2,-4(fp)
 d028a40:	00003706 	br	d028b20 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 d028a44:	00800104 	movi	r2,4
 d028a48:	e0bffc15 	stw	r2,-16(fp)
 d028a4c:	00001906 	br	d028ab4 <pk_validate+0x234>
   {
      if (*(pkt->nb_buff - j) != 'M')
 d028a50:	e0bffe17 	ldw	r2,-8(fp)
 d028a54:	10c00117 	ldw	r3,4(r2)
 d028a58:	e0bffc17 	ldw	r2,-16(fp)
 d028a5c:	1885c83a 	sub	r2,r3,r2
 d028a60:	10800003 	ldbu	r2,0(r2)
 d028a64:	10803fcc 	andi	r2,r2,255
 d028a68:	1080201c 	xori	r2,r2,128
 d028a6c:	10bfe004 	addi	r2,r2,-128
 d028a70:	10801360 	cmpeqi	r2,r2,77
 d028a74:	10000c1e 	bne	r2,zero,d028aa8 <pk_validate+0x228>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 d028a78:	d0295e80 	call	d0295e8 <irq_Mask>
 d028a7c:	008341b4 	movhi	r2,3334
 d028a80:	10b30c04 	addi	r2,r2,-13264
 d028a84:	10800117 	ldw	r2,4(r2)
 d028a88:	10c00044 	addi	r3,r2,1
 d028a8c:	008341b4 	movhi	r2,3334
 d028a90:	10b30c04 	addi	r2,r2,-13264
 d028a94:	10c00115 	stw	r3,4(r2)
 d028a98:	d0296440 	call	d029644 <irq_Unmask>
         return -1;
 d028a9c:	00bfffc4 	movi	r2,-1
 d028aa0:	e0bfff15 	stw	r2,-4(fp)
 d028aa4:	00001e06 	br	d028b20 <pk_validate+0x2a0>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 d028aa8:	e0bffc17 	ldw	r2,-16(fp)
 d028aac:	10bfffc4 	addi	r2,r2,-1
 d028ab0:	e0bffc15 	stw	r2,-16(fp)
 d028ab4:	e0bffc17 	ldw	r2,-16(fp)
 d028ab8:	10800048 	cmpgei	r2,r2,1
 d028abc:	103fe41e 	bne	r2,zero,d028a50 <pk_validate+0x1d0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 d028ac0:	e0bffe17 	ldw	r2,-8(fp)
 d028ac4:	10c00117 	ldw	r3,4(r2)
 d028ac8:	e0bffe17 	ldw	r2,-8(fp)
 d028acc:	10800217 	ldw	r2,8(r2)
 d028ad0:	1885883a 	add	r2,r3,r2
 d028ad4:	10800003 	ldbu	r2,0(r2)
 d028ad8:	10803fcc 	andi	r2,r2,255
 d028adc:	1080201c 	xori	r2,r2,128
 d028ae0:	10bfe004 	addi	r2,r2,-128
 d028ae4:	10801360 	cmpeqi	r2,r2,77
 d028ae8:	10000c1e 	bne	r2,zero,d028b1c <pk_validate+0x29c>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 d028aec:	d0295e80 	call	d0295e8 <irq_Mask>
 d028af0:	008341b4 	movhi	r2,3334
 d028af4:	10b30c04 	addi	r2,r2,-13264
 d028af8:	10800117 	ldw	r2,4(r2)
 d028afc:	10c00044 	addi	r3,r2,1
 d028b00:	008341b4 	movhi	r2,3334
 d028b04:	10b30c04 	addi	r2,r2,-13264
 d028b08:	10c00115 	stw	r3,4(r2)
 d028b0c:	d0296440 	call	d029644 <irq_Unmask>
      return -1;
 d028b10:	00bfffc4 	movi	r2,-1
 d028b14:	e0bfff15 	stw	r2,-4(fp)
 d028b18:	00000106 	br	d028b20 <pk_validate+0x2a0>
   }
#endif /* NPDEBUG */

   return 0;
 d028b1c:	e03fff15 	stw	zero,-4(fp)
 d028b20:	e0bfff17 	ldw	r2,-4(fp)
}
 d028b24:	e037883a 	mov	sp,fp
 d028b28:	dfc00117 	ldw	ra,4(sp)
 d028b2c:	df000017 	ldw	fp,0(sp)
 d028b30:	dec00204 	addi	sp,sp,8
 d028b34:	f800283a 	ret

0d028b38 <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 d028b38:	defffc04 	addi	sp,sp,-16
 d028b3c:	dfc00315 	stw	ra,12(sp)
 d028b40:	df000215 	stw	fp,8(sp)
 d028b44:	df000204 	addi	fp,sp,8
 d028b48:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 d028b4c:	e13fff17 	ldw	r4,-4(fp)
 d028b50:	d0288800 	call	d028880 <pk_validate>
 d028b54:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 d028b58:	e0bffe17 	ldw	r2,-8(fp)
 d028b5c:	1004c03a 	cmpne	r2,r2,zero
 d028b60:	10001b1e 	bne	r2,zero,d028bd0 <pk_free+0x98>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 d028b64:	e0bfff17 	ldw	r2,-4(fp)
 d028b68:	10c00917 	ldw	r3,36(r2)
 d028b6c:	188000a8 	cmpgeui	r2,r3,2
 d028b70:	1009883a 	mov	r4,r2
 d028b74:	18ffffc4 	addi	r3,r3,-1
 d028b78:	e0bfff17 	ldw	r2,-4(fp)
 d028b7c:	10c00915 	stw	r3,36(r2)
 d028b80:	20803fcc 	andi	r2,r4,255
 d028b84:	1004c03a 	cmpne	r2,r2,zero
 d028b88:	1000111e 	bne	r2,zero,d028bd0 <pk_free+0x98>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 d028b8c:	e0bfff17 	ldw	r2,-4(fp)
 d028b90:	10c00217 	ldw	r3,8(r2)
 d028b94:	d0a03917 	ldw	r2,-32540(gp)
 d028b98:	1880051e 	bne	r3,r2,d028bb0 <pk_free+0x78>
            q_add(&bigfreeq, (qp)pkt);
 d028b9c:	e17fff17 	ldw	r5,-4(fp)
 d028ba0:	010341b4 	movhi	r4,3334
 d028ba4:	21334c04 	addi	r4,r4,-13008
 d028ba8:	d028d780 	call	d028d78 <putq>
 d028bac:	00000806 	br	d028bd0 <pk_free+0x98>
         else if (pkt->nb_blen == lilbufsiz)
 d028bb0:	e0bfff17 	ldw	r2,-4(fp)
 d028bb4:	10c00217 	ldw	r3,8(r2)
 d028bb8:	d0a03717 	ldw	r2,-32548(gp)
 d028bbc:	1880041e 	bne	r3,r2,d028bd0 <pk_free+0x98>
            q_add(&lilfreeq, (qp)pkt);
 d028bc0:	e17fff17 	ldw	r5,-4(fp)
 d028bc4:	010341b4 	movhi	r4,3334
 d028bc8:	21330704 	addi	r4,r4,-13284
 d028bcc:	d028d780 	call	d028d78 <putq>
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 d028bd0:	e037883a 	mov	sp,fp
 d028bd4:	dfc00117 	ldw	ra,4(sp)
 d028bd8:	df000017 	ldw	fp,0(sp)
 d028bdc:	dec00204 	addi	sp,sp,8
 d028be0:	f800283a 	ret

0d028be4 <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 d028be4:	deffff04 	addi	sp,sp,-4
 d028be8:	df000015 	stw	fp,0(sp)
 d028bec:	d839883a 	mov	fp,sp
   return bigbufsiz;
 d028bf0:	d0a03917 	ldw	r2,-32540(gp)
}
 d028bf4:	e037883a 	mov	sp,fp
 d028bf8:	df000017 	ldw	fp,0(sp)
 d028bfc:	dec00104 	addi	sp,sp,4
 d028c00:	f800283a 	ret

0d028c04 <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 d028c04:	defff904 	addi	sp,sp,-28
 d028c08:	dfc00615 	stw	ra,24(sp)
 d028c0c:	df000515 	stw	fp,20(sp)
 d028c10:	df000504 	addi	fp,sp,20
 d028c14:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 d028c18:	01000084 	movi	r4,2
 d028c1c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 d028c20:	d0295e80 	call	d0295e8 <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 d028c24:	00c341b4 	movhi	r3,3334
 d028c28:	18f30c04 	addi	r3,r3,-13264
 d028c2c:	18800017 	ldw	r2,0(r3)
 d028c30:	e0bffb15 	stw	r2,-20(fp)
 d028c34:	18800117 	ldw	r2,4(r3)
 d028c38:	e0bffc15 	stw	r2,-16(fp)
 d028c3c:	18800217 	ldw	r2,8(r3)
 d028c40:	e0bffd15 	stw	r2,-12(fp)
 d028c44:	18800317 	ldw	r2,12(r3)
 d028c48:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 d028c4c:	d0296440 	call	d029644 <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d028c50:	01000084 	movi	r4,2
 d028c54:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 d028c58:	e13fff17 	ldw	r4,-4(fp)
 d028c5c:	01434174 	movhi	r5,3333
 d028c60:	297caf04 	addi	r5,r5,-3396
 d028c64:	d02486c0 	call	d02486c <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 d028c68:	e1bffb17 	ldw	r6,-20(fp)
 d028c6c:	e1fffc17 	ldw	r7,-16(fp)
 d028c70:	e13fff17 	ldw	r4,-4(fp)
 d028c74:	01434174 	movhi	r5,3333
 d028c78:	297cb804 	addi	r5,r5,-3360
 d028c7c:	d02486c0 	call	d02486c <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 d028c80:	e1bffd17 	ldw	r6,-12(fp)
 d028c84:	e1fffe17 	ldw	r7,-8(fp)
 d028c88:	e13fff17 	ldw	r4,-4(fp)
 d028c8c:	01434174 	movhi	r5,3333
 d028c90:	297cc504 	addi	r5,r5,-3308
 d028c94:	d02486c0 	call	d02486c <ns_printf>

   return 0;
 d028c98:	0005883a 	mov	r2,zero
}
 d028c9c:	e037883a 	mov	sp,fp
 d028ca0:	dfc00117 	ldw	ra,4(sp)
 d028ca4:	df000017 	ldw	fp,0(sp)
 d028ca8:	dec00204 	addi	sp,sp,8
 d028cac:	f800283a 	ret

0d028cb0 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 d028cb0:	defffb04 	addi	sp,sp,-20
 d028cb4:	dfc00415 	stw	ra,16(sp)
 d028cb8:	df000315 	stw	fp,12(sp)
 d028cbc:	df000304 	addi	fp,sp,12
 d028cc0:	e13ffe15 	stw	r4,-8(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 d028cc4:	d0295e80 	call	d0295e8 <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 d028cc8:	e0bffe17 	ldw	r2,-8(fp)
 d028ccc:	10800017 	ldw	r2,0(r2)
 d028cd0:	e0bffd15 	stw	r2,-12(fp)
 d028cd4:	e0bffd17 	ldw	r2,-12(fp)
 d028cd8:	1004c03a 	cmpne	r2,r2,zero
 d028cdc:	1000031e 	bne	r2,zero,d028cec <getq+0x3c>
   {
      EXIT_CRIT_SECTION(q);
 d028ce0:	d0296440 	call	d029644 <irq_Unmask>
      return (0);             /* yes, show none */
 d028ce4:	e03fff15 	stw	zero,-4(fp)
 d028ce8:	00001d06 	br	d028d60 <getq+0xb0>
   }

   q->q_head = temp->qe_next; /* else unlink */
 d028cec:	e0bffd17 	ldw	r2,-12(fp)
 d028cf0:	10c00017 	ldw	r3,0(r2)
 d028cf4:	e0bffe17 	ldw	r2,-8(fp)
 d028cf8:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 d028cfc:	e0bffd17 	ldw	r2,-12(fp)
 d028d00:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 d028d04:	e0bffe17 	ldw	r2,-8(fp)
 d028d08:	10800017 	ldw	r2,0(r2)
 d028d0c:	1004c03a 	cmpne	r2,r2,zero
 d028d10:	1000021e 	bne	r2,zero,d028d1c <getq+0x6c>
      q->q_tail = 0;          /* yes, update tail pointer too */
 d028d14:	e0bffe17 	ldw	r2,-8(fp)
 d028d18:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 d028d1c:	e0bffe17 	ldw	r2,-8(fp)
 d028d20:	10800217 	ldw	r2,8(r2)
 d028d24:	10ffffc4 	addi	r3,r2,-1
 d028d28:	e0bffe17 	ldw	r2,-8(fp)
 d028d2c:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 d028d30:	e0bffe17 	ldw	r2,-8(fp)
 d028d34:	10c00217 	ldw	r3,8(r2)
 d028d38:	e0bffe17 	ldw	r2,-8(fp)
 d028d3c:	10800417 	ldw	r2,16(r2)
 d028d40:	1880040e 	bge	r3,r2,d028d54 <getq+0xa4>
      q->q_min = q->q_len;
 d028d44:	e0bffe17 	ldw	r2,-8(fp)
 d028d48:	10c00217 	ldw	r3,8(r2)
 d028d4c:	e0bffe17 	ldw	r2,-8(fp)
 d028d50:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 d028d54:	d0296440 	call	d029644 <irq_Unmask>

   return ((void*)temp);
 d028d58:	e0bffd17 	ldw	r2,-12(fp)
 d028d5c:	e0bfff15 	stw	r2,-4(fp)
 d028d60:	e0bfff17 	ldw	r2,-4(fp)
}
 d028d64:	e037883a 	mov	sp,fp
 d028d68:	dfc00117 	ldw	ra,4(sp)
 d028d6c:	df000017 	ldw	fp,0(sp)
 d028d70:	dec00204 	addi	sp,sp,8
 d028d74:	f800283a 	ret

0d028d78 <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 d028d78:	defffc04 	addi	sp,sp,-16
 d028d7c:	dfc00315 	stw	ra,12(sp)
 d028d80:	df000215 	stw	fp,8(sp)
 d028d84:	df000204 	addi	fp,sp,8
 d028d88:	e13ffe15 	stw	r4,-8(fp)
 d028d8c:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 d028d90:	d0295e80 	call	d0295e8 <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 d028d94:	e0bfff17 	ldw	r2,-4(fp)
 d028d98:	10000015 	stw	zero,0(r2)
 d028d9c:	e0bffe17 	ldw	r2,-8(fp)
 d028da0:	10800017 	ldw	r2,0(r2)
 d028da4:	1004c03a 	cmpne	r2,r2,zero
 d028da8:	1000041e 	bne	r2,zero,d028dbc <putq+0x44>
 d028dac:	e0ffff17 	ldw	r3,-4(fp)
 d028db0:	e0bffe17 	ldw	r2,-8(fp)
 d028db4:	10c00015 	stw	r3,0(r2)
 d028db8:	00000406 	br	d028dcc <putq+0x54>
 d028dbc:	e0bffe17 	ldw	r2,-8(fp)
 d028dc0:	10c00117 	ldw	r3,4(r2)
 d028dc4:	e0bfff17 	ldw	r2,-4(fp)
 d028dc8:	18800015 	stw	r2,0(r3)
 d028dcc:	e0ffff17 	ldw	r3,-4(fp)
 d028dd0:	e0bffe17 	ldw	r2,-8(fp)
 d028dd4:	10c00115 	stw	r3,4(r2)
 d028dd8:	e0bffe17 	ldw	r2,-8(fp)
 d028ddc:	10800217 	ldw	r2,8(r2)
 d028de0:	10c00044 	addi	r3,r2,1
 d028de4:	e0bffe17 	ldw	r2,-8(fp)
 d028de8:	10c00215 	stw	r3,8(r2)
 d028dec:	e0bffe17 	ldw	r2,-8(fp)
 d028df0:	10c00217 	ldw	r3,8(r2)
 d028df4:	e0bffe17 	ldw	r2,-8(fp)
 d028df8:	10800317 	ldw	r2,12(r2)
 d028dfc:	10c0040e 	bge	r2,r3,d028e10 <putq+0x98>
 d028e00:	e0bffe17 	ldw	r2,-8(fp)
 d028e04:	10c00217 	ldw	r3,8(r2)
 d028e08:	e0bffe17 	ldw	r2,-8(fp)
 d028e0c:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 d028e10:	d0296440 	call	d029644 <irq_Unmask>
}
 d028e14:	e037883a 	mov	sp,fp
 d028e18:	dfc00117 	ldw	ra,4(sp)
 d028e1c:	df000017 	ldw	fp,0(sp)
 d028e20:	dec00204 	addi	sp,sp,8
 d028e24:	f800283a 	ret

0d028e28 <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 d028e28:	defff904 	addi	sp,sp,-28
 d028e2c:	dfc00615 	stw	ra,24(sp)
 d028e30:	df000515 	stw	fp,20(sp)
 d028e34:	df000504 	addi	fp,sp,20
 d028e38:	e13ffd15 	stw	r4,-12(fp)
 d028e3c:	e17ffe15 	stw	r5,-8(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 d028e40:	d0295e80 	call	d0295e8 <irq_Mask>
   qptr = q->q_head;
 d028e44:	e0bffd17 	ldw	r2,-12(fp)
 d028e48:	10800017 	ldw	r2,0(r2)
 d028e4c:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 d028e50:	e03ffb15 	stw	zero,-20(fp)
   while (qptr)
 d028e54:	00002d06 	br	d028f0c <qdel+0xe4>
   {
      if (qptr == (qp)elt)
 d028e58:	e0fffe17 	ldw	r3,-8(fp)
 d028e5c:	e0bffc17 	ldw	r2,-16(fp)
 d028e60:	10c0251e 	bne	r2,r3,d028ef8 <qdel+0xd0>
      {
         /* found our item; dequeue it */
         if (qlast)
 d028e64:	e0bffb17 	ldw	r2,-20(fp)
 d028e68:	1005003a 	cmpeq	r2,r2,zero
 d028e6c:	1000051e 	bne	r2,zero,d028e84 <qdel+0x5c>
            qlast->qe_next = qptr->qe_next;
 d028e70:	e0bffc17 	ldw	r2,-16(fp)
 d028e74:	10c00017 	ldw	r3,0(r2)
 d028e78:	e0bffb17 	ldw	r2,-20(fp)
 d028e7c:	10c00015 	stw	r3,0(r2)
 d028e80:	00000406 	br	d028e94 <qdel+0x6c>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 d028e84:	e0bffc17 	ldw	r2,-16(fp)
 d028e88:	10c00017 	ldw	r3,0(r2)
 d028e8c:	e0bffd17 	ldw	r2,-12(fp)
 d028e90:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 d028e94:	e0bffd17 	ldw	r2,-12(fp)
 d028e98:	10c00117 	ldw	r3,4(r2)
 d028e9c:	e0bffe17 	ldw	r2,-8(fp)
 d028ea0:	1880031e 	bne	r3,r2,d028eb0 <qdel+0x88>
            q->q_tail = qlast;
 d028ea4:	e0fffd17 	ldw	r3,-12(fp)
 d028ea8:	e0bffb17 	ldw	r2,-20(fp)
 d028eac:	18800115 	stw	r2,4(r3)

         /* fix queue counters */
         q->q_len--;
 d028eb0:	e0bffd17 	ldw	r2,-12(fp)
 d028eb4:	10800217 	ldw	r2,8(r2)
 d028eb8:	10ffffc4 	addi	r3,r2,-1
 d028ebc:	e0bffd17 	ldw	r2,-12(fp)
 d028ec0:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 d028ec4:	e0bffd17 	ldw	r2,-12(fp)
 d028ec8:	10c00217 	ldw	r3,8(r2)
 d028ecc:	e0bffd17 	ldw	r2,-12(fp)
 d028ed0:	10800417 	ldw	r2,16(r2)
 d028ed4:	1880040e 	bge	r3,r2,d028ee8 <qdel+0xc0>
            q->q_min = q->q_len;
 d028ed8:	e0bffd17 	ldw	r2,-12(fp)
 d028edc:	10c00217 	ldw	r3,8(r2)
 d028ee0:	e0bffd17 	ldw	r2,-12(fp)
 d028ee4:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 d028ee8:	d0296440 	call	d029644 <irq_Unmask>
         return (qp)elt;   /* success exit point */
 d028eec:	e0bffe17 	ldw	r2,-8(fp)
 d028ef0:	e0bfff15 	stw	r2,-4(fp)
 d028ef4:	00000a06 	br	d028f20 <qdel+0xf8>
      }
      qlast = qptr;
 d028ef8:	e0bffc17 	ldw	r2,-16(fp)
 d028efc:	e0bffb15 	stw	r2,-20(fp)
      qptr = qptr->qe_next;
 d028f00:	e0bffc17 	ldw	r2,-16(fp)
 d028f04:	10800017 	ldw	r2,0(r2)
 d028f08:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 d028f0c:	e0bffc17 	ldw	r2,-16(fp)
 d028f10:	1004c03a 	cmpne	r2,r2,zero
 d028f14:	103fd01e 	bne	r2,zero,d028e58 <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 d028f18:	d0296440 	call	d029644 <irq_Unmask>
   return NULL;   /* item not found in queue */
 d028f1c:	e03fff15 	stw	zero,-4(fp)
 d028f20:	e0bfff17 	ldw	r2,-4(fp)
}
 d028f24:	e037883a 	mov	sp,fp
 d028f28:	dfc00117 	ldw	ra,4(sp)
 d028f2c:	df000017 	ldw	fp,0(sp)
 d028f30:	dec00204 	addi	sp,sp,8
 d028f34:	f800283a 	ret

0d028f38 <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 d028f38:	defff304 	addi	sp,sp,-52
 d028f3c:	dfc00c15 	stw	ra,48(sp)
 d028f40:	df000b15 	stw	fp,44(sp)
 d028f44:	df000b04 	addi	fp,sp,44
 d028f48:	e13ffb15 	stw	r4,-20(fp)
 d028f4c:	e1fffe15 	stw	r7,-8(fp)
 d028f50:	e17ffc0d 	sth	r5,-16(fp)
 d028f54:	e1bffd0d 	sth	r6,-12(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 d028f58:	00834174 	movhi	r2,3333
 d028f5c:	108aa404 	addi	r2,r2,10896
 d028f60:	10800017 	ldw	r2,0(r2)
 d028f64:	1080010c 	andi	r2,r2,4
 d028f68:	1005003a 	cmpeq	r2,r2,zero
 d028f6c:	1000171e 	bne	r2,zero,d028fcc <udp_open+0x94>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 d028f70:	e0bffb17 	ldw	r2,-20(fp)
 d028f74:	11803fcc 	andi	r6,r2,255
 d028f78:	e0bffb17 	ldw	r2,-20(fp)
 d028f7c:	1004d23a 	srli	r2,r2,8
 d028f80:	11c03fcc 	andi	r7,r2,255
 d028f84:	e0bffb17 	ldw	r2,-20(fp)
 d028f88:	1004d43a 	srli	r2,r2,16
 d028f8c:	12003fcc 	andi	r8,r2,255
 d028f90:	e0bffb17 	ldw	r2,-20(fp)
 d028f94:	1006d63a 	srli	r3,r2,24
 d028f98:	e13ffd0b 	ldhu	r4,-12(fp)
 d028f9c:	e17ffc0b 	ldhu	r5,-16(fp)
 d028fa0:	e0800217 	ldw	r2,8(fp)
 d028fa4:	d8c00015 	stw	r3,0(sp)
 d028fa8:	d9000115 	stw	r4,4(sp)
 d028fac:	d9400215 	stw	r5,8(sp)
 d028fb0:	d8800315 	stw	r2,12(sp)
 d028fb4:	01034174 	movhi	r4,3333
 d028fb8:	213cd104 	addi	r4,r4,-3260
 d028fbc:	300b883a 	mov	r5,r6
 d028fc0:	380d883a 	mov	r6,r7
 d028fc4:	400f883a 	mov	r7,r8
 d028fc8:	d0029980 	call	d002998 <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 d028fcc:	0009883a 	mov	r4,zero
 d028fd0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   ocon = NULL;
 d028fd4:	e03ff915 	stw	zero,-28(fp)
   for (con = firstudp; con; con = con->u_next)
 d028fd8:	d0a09c17 	ldw	r2,-32144(gp)
 d028fdc:	e0bffa15 	stw	r2,-24(fp)
 d028fe0:	00002406 	br	d029074 <udp_open+0x13c>
   {
      ocon = con;       /* remember last con in list */
 d028fe4:	e0bffa17 	ldw	r2,-24(fp)
 d028fe8:	e0bff915 	stw	r2,-28(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 d028fec:	e0bffa17 	ldw	r2,-24(fp)
 d028ff0:	1080018b 	ldhu	r2,6(r2)
 d028ff4:	10ffffcc 	andi	r3,r2,65535
 d028ff8:	e0bffd0b 	ldhu	r2,-12(fp)
 d028ffc:	18801a1e 	bne	r3,r2,d029068 <udp_open+0x130>
 d029000:	e0bffa17 	ldw	r2,-24(fp)
 d029004:	1080020b 	ldhu	r2,8(r2)
 d029008:	10ffffcc 	andi	r3,r2,65535
 d02900c:	e0bffc0b 	ldhu	r2,-16(fp)
 d029010:	1880151e 	bne	r3,r2,d029068 <udp_open+0x130>
 d029014:	e0bffa17 	ldw	r2,-24(fp)
 d029018:	10800317 	ldw	r2,12(r2)
 d02901c:	1004c03a 	cmpne	r2,r2,zero
 d029020:	1000111e 	bne	r2,zero,d029068 <udp_open+0x130>
 d029024:	e0bffa17 	ldw	r2,-24(fp)
 d029028:	10c00417 	ldw	r3,16(r2)
 d02902c:	e0bffb17 	ldw	r2,-20(fp)
 d029030:	18800d1e 	bne	r3,r2,d029068 <udp_open+0x130>
          con->u_lhost == 0 && con->u_fhost == fhost)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 d029034:	00834174 	movhi	r2,3333
 d029038:	108aa404 	addi	r2,r2,10896
 d02903c:	10800017 	ldw	r2,0(r2)
 d029040:	1080050c 	andi	r2,r2,20
 d029044:	1005003a 	cmpeq	r2,r2,zero
 d029048:	1000031e 	bne	r2,zero,d029058 <udp_open+0x120>
            dprintf("UDP: Connection already exists.\n");
 d02904c:	01034174 	movhi	r4,3333
 d029050:	213ce004 	addi	r4,r4,-3200
 d029054:	d002cc00 	call	d002cc0 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 d029058:	0009883a 	mov	r4,zero
 d02905c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         return(NULL);
 d029060:	e03fff15 	stw	zero,-4(fp)
 d029064:	00003c06 	br	d029158 <udp_open+0x220>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 d029068:	e0bffa17 	ldw	r2,-24(fp)
 d02906c:	10800017 	ldw	r2,0(r2)
 d029070:	e0bffa15 	stw	r2,-24(fp)
 d029074:	e0bffa17 	ldw	r2,-24(fp)
 d029078:	1004c03a 	cmpne	r2,r2,zero
 d02907c:	103fd91e 	bne	r2,zero,d028fe4 <udp_open+0xac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 d029080:	01000804 	movi	r4,32
 d029084:	d029e2c0 	call	d029e2c <npalloc>
 d029088:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 d02908c:	e0bffa17 	ldw	r2,-24(fp)
 d029090:	1004c03a 	cmpne	r2,r2,zero
 d029094:	10000d1e 	bne	r2,zero,d0290cc <udp_open+0x194>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 d029098:	00834174 	movhi	r2,3333
 d02909c:	108aa404 	addi	r2,r2,10896
 d0290a0:	10800017 	ldw	r2,0(r2)
 d0290a4:	1080010c 	andi	r2,r2,4
 d0290a8:	1005003a 	cmpeq	r2,r2,zero
 d0290ac:	1000031e 	bne	r2,zero,d0290bc <udp_open+0x184>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 d0290b0:	01034174 	movhi	r4,3333
 d0290b4:	213ce804 	addi	r4,r4,-3168
 d0290b8:	d002cc00 	call	d002cc0 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 d0290bc:	0009883a 	mov	r4,zero
 d0290c0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return(NULL);
 d0290c4:	e03fff15 	stw	zero,-4(fp)
 d0290c8:	00002306 	br	d029158 <udp_open+0x220>
   }

   if (ocon)   /* ocon is end of list */
 d0290cc:	e0bff917 	ldw	r2,-28(fp)
 d0290d0:	1005003a 	cmpeq	r2,r2,zero
 d0290d4:	1000041e 	bne	r2,zero,d0290e8 <udp_open+0x1b0>
      ocon->u_next = con;  /* add new connection to end */
 d0290d8:	e0fff917 	ldw	r3,-28(fp)
 d0290dc:	e0bffa17 	ldw	r2,-24(fp)
 d0290e0:	18800015 	stw	r2,0(r3)
 d0290e4:	00000206 	br	d0290f0 <udp_open+0x1b8>
   else  /* no list, start one */
      firstudp = con;
 d0290e8:	e0bffa17 	ldw	r2,-24(fp)
 d0290ec:	d0a09c15 	stw	r2,-32144(gp)

   con->u_next = 0;
 d0290f0:	e0bffa17 	ldw	r2,-24(fp)
 d0290f4:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 d0290f8:	e0fffa17 	ldw	r3,-24(fp)
 d0290fc:	e0bffd0b 	ldhu	r2,-12(fp)
 d029100:	1880018d 	sth	r2,6(r3)
   con->u_fport = fsock;
 d029104:	e0fffa17 	ldw	r3,-24(fp)
 d029108:	e0bffc0b 	ldhu	r2,-16(fp)
 d02910c:	1880020d 	sth	r2,8(r3)
   con->u_lhost = 0;
 d029110:	e0bffa17 	ldw	r2,-24(fp)
 d029114:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 d029118:	e0fffa17 	ldw	r3,-24(fp)
 d02911c:	e0bffb17 	ldw	r2,-20(fp)
 d029120:	18800415 	stw	r2,16(r3)
   con->u_rcv   = handler;
 d029124:	e0fffa17 	ldw	r3,-24(fp)
 d029128:	e0bffe17 	ldw	r2,-8(fp)
 d02912c:	18800515 	stw	r2,20(r3)
   con->u_data  = data;
 d029130:	e0fffa17 	ldw	r3,-24(fp)
 d029134:	e0800217 	ldw	r2,8(fp)
 d029138:	18800615 	stw	r2,24(r3)
   con->u_flags = UDPCF_V4;
 d02913c:	e0fffa17 	ldw	r3,-24(fp)
 d029140:	00800044 	movi	r2,1
 d029144:	1880010d 	sth	r2,4(r3)

   UNLOCK_NET_RESOURCE(NET_RESID);
 d029148:	0009883a 	mov	r4,zero
 d02914c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return(con);
 d029150:	e0bffa17 	ldw	r2,-24(fp)
 d029154:	e0bfff15 	stw	r2,-4(fp)
 d029158:	e0bfff17 	ldw	r2,-4(fp)
}
 d02915c:	e037883a 	mov	sp,fp
 d029160:	dfc00117 	ldw	ra,4(sp)
 d029164:	df000017 	ldw	fp,0(sp)
 d029168:	dec00204 	addi	sp,sp,8
 d02916c:	f800283a 	ret

0d029170 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 d029170:	defffb04 	addi	sp,sp,-20
 d029174:	dfc00415 	stw	ra,16(sp)
 d029178:	df000315 	stw	fp,12(sp)
 d02917c:	df000304 	addi	fp,sp,12
 d029180:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 d029184:	e0bfff17 	ldw	r2,-4(fp)
 d029188:	1005003a 	cmpeq	r2,r2,zero
 d02918c:	1000031e 	bne	r2,zero,d02919c <udp_close+0x2c>
 d029190:	d0a09c17 	ldw	r2,-32144(gp)
 d029194:	1004c03a 	cmpne	r2,r2,zero
 d029198:	1000021e 	bne	r2,zero,d0291a4 <udp_close+0x34>
   {
      dtrap(); /* bad programming! */
 d02919c:	d0293e80 	call	d0293e8 <dtrap>
      return;
 d0291a0:	00002706 	br	d029240 <udp_close+0xd0>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 d0291a4:	0009883a 	mov	r4,zero
 d0291a8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 d0291ac:	e03ffd15 	stw	zero,-12(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 d0291b0:	d0a09c17 	ldw	r2,-32144(gp)
 d0291b4:	e0bffe15 	stw	r2,-8(fp)
 d0291b8:	00000806 	br	d0291dc <udp_close+0x6c>
   {
      if (pcon == con)  /* found connection to delete */
 d0291bc:	e0fffe17 	ldw	r3,-8(fp)
 d0291c0:	e0bfff17 	ldw	r2,-4(fp)
 d0291c4:	18800826 	beq	r3,r2,d0291e8 <udp_close+0x78>
      break;
      lcon = pcon;   /* remember last connection */
 d0291c8:	e0bffe17 	ldw	r2,-8(fp)
 d0291cc:	e0bffd15 	stw	r2,-12(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 d0291d0:	e0bffe17 	ldw	r2,-8(fp)
 d0291d4:	10800017 	ldw	r2,0(r2)
 d0291d8:	e0bffe15 	stw	r2,-8(fp)
 d0291dc:	e0bffe17 	ldw	r2,-8(fp)
 d0291e0:	1004c03a 	cmpne	r2,r2,zero
 d0291e4:	103ff51e 	bne	r2,zero,d0291bc <udp_close+0x4c>
      if (pcon == con)  /* found connection to delete */
      break;
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 d0291e8:	e0bffe17 	ldw	r2,-8(fp)
 d0291ec:	1004c03a 	cmpne	r2,r2,zero
 d0291f0:	1000041e 	bne	r2,zero,d029204 <udp_close+0x94>
   {
      dtrap(); /* prog error - connenction not in list */
 d0291f4:	d0293e80 	call	d0293e8 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 d0291f8:	0009883a 	mov	r4,zero
 d0291fc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return;
 d029200:	00000f06 	br	d029240 <udp_close+0xd0>
   }

   if (lcon)   /* in con is not head of list */
 d029204:	e0bffd17 	ldw	r2,-12(fp)
 d029208:	1005003a 	cmpeq	r2,r2,zero
 d02920c:	1000051e 	bne	r2,zero,d029224 <udp_close+0xb4>
      lcon->u_next = con->u_next;   /* unlink */
 d029210:	e0bfff17 	ldw	r2,-4(fp)
 d029214:	10c00017 	ldw	r3,0(r2)
 d029218:	e0bffd17 	ldw	r2,-12(fp)
 d02921c:	10c00015 	stw	r3,0(r2)
 d029220:	00000306 	br	d029230 <udp_close+0xc0>
   else
      firstudp = con->u_next; /* remove from head */
 d029224:	e0bfff17 	ldw	r2,-4(fp)
 d029228:	10800017 	ldw	r2,0(r2)
 d02922c:	d0a09c15 	stw	r2,-32144(gp)

   UC_FREE(con);  /* free memory for structure */
 d029230:	e13fff17 	ldw	r4,-4(fp)
 d029234:	d029f200 	call	d029f20 <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 d029238:	0009883a 	mov	r4,zero
 d02923c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
}
 d029240:	e037883a 	mov	sp,fp
 d029244:	dfc00117 	ldw	ra,4(sp)
 d029248:	df000017 	ldw	fp,0(sp)
 d02924c:	dec00204 	addi	sp,sp,8
 d029250:	f800283a 	ret

0d029254 <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 d029254:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 d029258:	0140620e 	bge	zero,r5,d0293e4 <done>

      mov   r6, zero		       /* carry accumulator */
 d02925c:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 d029260:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 d029264:	18000326 	beq	r3,zero,d029274 <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 d029268:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 d02926c:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 d029270:	297fffc4 	addi	r5,r5,-1

0d029274 <asm1>:
 d029274:	02c340f4 	movhi	r11,3331
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 d029278:	5ae4e804 	addi	r11,r11,-27744
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 d02927c:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 d029280:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 d029284:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 d029288:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 d02928c:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 d029290:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 d029294:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 d029298:	5800683a 	jmp	r11

0d02929c <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 d02929c:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 d0292a0:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 d0292a4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0292a8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0292ac:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 d0292b0:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 d0292b4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0292b8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0292bc:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 d0292c0:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 d0292c4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0292c8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0292cc:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 d0292d0:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 d0292d4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0292d8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0292dc:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 d0292e0:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 d0292e4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0292e8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0292ec:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 d0292f0:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 d0292f4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0292f8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0292fc:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 d029300:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 d029304:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029308:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02930c:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 d029310:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 d029314:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029318:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02931c:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 d029320:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 d029324:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029328:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02932c:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 d029330:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 d029334:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029338:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02933c:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 d029340:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 d029344:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029348:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02934c:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 d029350:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 d029354:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029358:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02935c:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 d029360:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 d029364:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029368:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02936c:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 d029370:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 d029374:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029378:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02937c:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 d029380:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 d029384:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029388:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02938c:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 d029390:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 d029394:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d029398:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d02939c:	418d883a 	add	r6,r8,r6

0d0293a0 <loop0>:
loop0:
      subi  r5, r5, 16
 d0293a0:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 d0293a4:	283fbd0e 	bge	r5,zero,d02929c <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 d0293a8:	48000426 	beq	r9,zero,d0293bc <fold>
      ldhu  r7, 0(r4)
 d0293ac:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 d0293b0:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 d0293b4:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 d0293b8:	418d883a 	add	r6,r8,r6

0d0293bc <fold>:
      
fold:
      srli  r7, r2, 16
 d0293bc:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 d0293c0:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 d0293c4:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 d0293c8:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 d0293cc:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 d0293d0:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 d0293d4:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 d0293d8:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 d0293dc:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 d0293e0:	3885883a 	add	r2,r7,r2

0d0293e4 <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 d0293e4:	f800283a 	ret

0d0293e8 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 d0293e8:	defffe04 	addi	sp,sp,-8
 d0293ec:	dfc00115 	stw	ra,4(sp)
 d0293f0:	df000015 	stw	fp,0(sp)
 d0293f4:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 d0293f8:	01034174 	movhi	r4,3333
 d0293fc:	213cf204 	addi	r4,r4,-3128
 d029400:	d002cc00 	call	d002cc0 <puts>
}
 d029404:	e037883a 	mov	sp,fp
 d029408:	dfc00117 	ldw	ra,4(sp)
 d02940c:	df000017 	ldw	fp,0(sp)
 d029410:	dec00204 	addi	sp,sp,8
 d029414:	f800283a 	ret

0d029418 <kbhit>:

int
kbhit()
{
 d029418:	defffc04 	addi	sp,sp,-16
 d02941c:	dfc00315 	stw	ra,12(sp)
 d029420:	df000215 	stw	fp,8(sp)
 d029424:	df000204 	addi	fp,sp,8
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 d029428:	d0a09d17 	ldw	r2,-32140(gp)
 d02942c:	1004c03a 	cmpne	r2,r2,zero
 d029430:	10000c1e 	bne	r2,zero,d029464 <kbhit+0x4c>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 d029434:	0009883a 	mov	r4,zero
 d029438:	01400104 	movi	r5,4
 d02943c:	01900004 	movi	r6,16384
 d029440:	d03b21c0 	call	d03b21c <fcntl>
 d029444:	1005003a 	cmpeq	r2,r2,zero
 d029448:	1000041e 	bne	r2,zero,d02945c <kbhit+0x44>
      {
         printf("F_SETFL failed.\n");
 d02944c:	01034174 	movhi	r4,3333
 d029450:	213cf904 	addi	r4,r4,-3100
 d029454:	d002cc00 	call	d002cc0 <puts>
         dtrap();
 d029458:	d0293e80 	call	d0293e8 <dtrap>
      }
      kbd_init = 1; 
 d02945c:	00800044 	movi	r2,1
 d029460:	d0a09d15 	stw	r2,-32140(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 d029464:	d0a03a17 	ldw	r2,-32536(gp)
 d029468:	10bfffd8 	cmpnei	r2,r2,-1
 d02946c:	10000d1e 	bne	r2,zero,d0294a4 <kbhit+0x8c>
   {
      kb = getchar();
 d029470:	00834174 	movhi	r2,3333
 d029474:	108a2204 	addi	r2,r2,10376
 d029478:	10800017 	ldw	r2,0(r2)
 d02947c:	11000117 	ldw	r4,4(r2)
 d029480:	d0025d80 	call	d0025d8 <getc>
 d029484:	e0bffe15 	stw	r2,-8(fp)
      if (kb < 0)       /* any error means no character present */
 d029488:	e0bffe17 	ldw	r2,-8(fp)
 d02948c:	1004403a 	cmpge	r2,r2,zero
 d029490:	1000021e 	bne	r2,zero,d02949c <kbhit+0x84>
         return (FALSE);
 d029494:	e03fff15 	stw	zero,-4(fp)
 d029498:	00000406 	br	d0294ac <kbhit+0x94>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 d02949c:	e0bffe17 	ldw	r2,-8(fp)
 d0294a0:	d0a03a15 	stw	r2,-32536(gp)
   }

   return (TRUE);
 d0294a4:	00800044 	movi	r2,1
 d0294a8:	e0bfff15 	stw	r2,-4(fp)
 d0294ac:	e0bfff17 	ldw	r2,-4(fp)
}
 d0294b0:	e037883a 	mov	sp,fp
 d0294b4:	dfc00117 	ldw	ra,4(sp)
 d0294b8:	df000017 	ldw	fp,0(sp)
 d0294bc:	dec00204 	addi	sp,sp,8
 d0294c0:	f800283a 	ret

0d0294c4 <getch>:

int 
getch()
{
 d0294c4:	defffd04 	addi	sp,sp,-12
 d0294c8:	dfc00215 	stw	ra,8(sp)
 d0294cc:	df000115 	stw	fp,4(sp)
 d0294d0:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 d0294d4:	d0a03a17 	ldw	r2,-32536(gp)
 d0294d8:	10bfffe0 	cmpeqi	r2,r2,-1
 d0294dc:	1000051e 	bne	r2,zero,d0294f4 <getch+0x30>
   {
      chr = kb_last;
 d0294e0:	d0a03a17 	ldw	r2,-32536(gp)
 d0294e4:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 d0294e8:	00bfffc4 	movi	r2,-1
 d0294ec:	d0a03a15 	stw	r2,-32536(gp)
 d0294f0:	00000606 	br	d02950c <getch+0x48>
   }
   else
      chr = getchar();
 d0294f4:	00834174 	movhi	r2,3333
 d0294f8:	108a2204 	addi	r2,r2,10376
 d0294fc:	10800017 	ldw	r2,0(r2)
 d029500:	11000117 	ldw	r4,4(r2)
 d029504:	d0025d80 	call	d0025d8 <getc>
 d029508:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 d02950c:	e0bfff17 	ldw	r2,-4(fp)
}
 d029510:	e037883a 	mov	sp,fp
 d029514:	dfc00117 	ldw	ra,4(sp)
 d029518:	df000017 	ldw	fp,0(sp)
 d02951c:	dec00204 	addi	sp,sp,8
 d029520:	f800283a 	ret

0d029524 <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 d029524:	deffff04 	addi	sp,sp,-4
 d029528:	df000015 	stw	fp,0(sp)
 d02952c:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 d029530:	00801904 	movi	r2,100
 d029534:	d0a0a215 	stw	r2,-32120(gp)
   cticks_factor = 0;
 d029538:	d020a115 	stw	zero,-32124(gp)
   cticks = 0;
 d02953c:	00834174 	movhi	r2,3333
 d029540:	108ac904 	addi	r2,r2,11044
 d029544:	10000015 	stw	zero,0(r2)
   cticks_initialized = 1;
 d029548:	00800044 	movi	r2,1
 d02954c:	d0a09e15 	stw	r2,-32136(gp)
}
 d029550:	e037883a 	mov	sp,fp
 d029554:	df000017 	ldw	fp,0(sp)
 d029558:	dec00104 	addi	sp,sp,4
 d02955c:	f800283a 	ret

0d029560 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 d029560:	deffff04 	addi	sp,sp,-4
 d029564:	df000015 	stw	fp,0(sp)
 d029568:	d839883a 	mov	fp,sp
   /* null */ ;
}
 d02956c:	e037883a 	mov	sp,fp
 d029570:	df000017 	ldw	fp,0(sp)
 d029574:	dec00104 	addi	sp,sp,4
 d029578:	f800283a 	ret

0d02957c <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 d02957c:	deffff04 	addi	sp,sp,-4
 d029580:	df000015 	stw	fp,0(sp)
 d029584:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 d029588:	d0a09e17 	ldw	r2,-32136(gp)
 d02958c:	1005003a 	cmpeq	r2,r2,zero
 d029590:	1000111e 	bne	r2,zero,d0295d8 <cticks_hook+0x5c>
   {
      cticks_factor += TPS;
 d029594:	d0a0a117 	ldw	r2,-32124(gp)
 d029598:	10801904 	addi	r2,r2,100
 d02959c:	d0a0a115 	stw	r2,-32124(gp)
      if (cticks_factor >= OS_TPS)
 d0295a0:	d0e0a117 	ldw	r3,-32124(gp)
 d0295a4:	d0a0a217 	ldw	r2,-32120(gp)
 d0295a8:	18800b16 	blt	r3,r2,d0295d8 <cticks_hook+0x5c>
      {
         cticks++;
 d0295ac:	00834174 	movhi	r2,3333
 d0295b0:	108ac904 	addi	r2,r2,11044
 d0295b4:	10800017 	ldw	r2,0(r2)
 d0295b8:	10c00044 	addi	r3,r2,1
 d0295bc:	00834174 	movhi	r2,3333
 d0295c0:	108ac904 	addi	r2,r2,11044
 d0295c4:	10c00015 	stw	r3,0(r2)
         cticks_factor -= OS_TPS;
 d0295c8:	d0e0a117 	ldw	r3,-32124(gp)
 d0295cc:	d0a0a217 	ldw	r2,-32120(gp)
 d0295d0:	1885c83a 	sub	r2,r3,r2
 d0295d4:	d0a0a115 	stw	r2,-32124(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 d0295d8:	e037883a 	mov	sp,fp
 d0295dc:	df000017 	ldw	fp,0(sp)
 d0295e0:	dec00104 	addi	sp,sp,4
 d0295e4:	f800283a 	ret

0d0295e8 <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 d0295e8:	defffd04 	addi	sp,sp,-12
 d0295ec:	df000215 	stw	fp,8(sp)
 d0295f0:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0295f4:	0005303a 	rdctl	r2,status
 d0295f8:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0295fc:	e0fffe17 	ldw	r3,-8(fp)
 d029600:	00bfff84 	movi	r2,-2
 d029604:	1884703a 	and	r2,r3,r2
 d029608:	1001703a 	wrctl	status,r2
  
  return context;
 d02960c:	e0bffe17 	ldw	r2,-8(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 d029610:	e0bfff15 	stw	r2,-4(fp)
	
   if (++irq_level == 1)
 d029614:	d0a09f17 	ldw	r2,-32132(gp)
 d029618:	10800044 	addi	r2,r2,1
 d02961c:	d0a09f15 	stw	r2,-32132(gp)
 d029620:	d0a09f17 	ldw	r2,-32132(gp)
 d029624:	10800058 	cmpnei	r2,r2,1
 d029628:	1000021e 	bne	r2,zero,d029634 <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 d02962c:	e0bfff17 	ldw	r2,-4(fp)
 d029630:	d0a0a015 	stw	r2,-32128(gp)
   }
}
 d029634:	e037883a 	mov	sp,fp
 d029638:	df000017 	ldw	fp,0(sp)
 d02963c:	dec00104 	addi	sp,sp,4
 d029640:	f800283a 	ret

0d029644 <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 d029644:	defffe04 	addi	sp,sp,-8
 d029648:	df000115 	stw	fp,4(sp)
 d02964c:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 d029650:	d0a09f17 	ldw	r2,-32132(gp)
 d029654:	10bfffc4 	addi	r2,r2,-1
 d029658:	d0a09f15 	stw	r2,-32132(gp)
 d02965c:	d0a09f17 	ldw	r2,-32132(gp)
 d029660:	1004c03a 	cmpne	r2,r2,zero
 d029664:	1000041e 	bne	r2,zero,d029678 <irq_Unmask+0x34>
   {
      alt_irq_enable_all(cpu_statusreg);
 d029668:	d0a0a017 	ldw	r2,-32128(gp)
 d02966c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d029670:	e0bfff17 	ldw	r2,-4(fp)
 d029674:	1001703a 	wrctl	status,r2
   }
}
 d029678:	e037883a 	mov	sp,fp
 d02967c:	df000017 	ldw	fp,0(sp)
 d029680:	dec00104 	addi	sp,sp,4
 d029684:	f800283a 	ret

0d029688 <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 d029688:	defffb04 	addi	sp,sp,-20
 d02968c:	dfc00415 	stw	ra,16(sp)
 d029690:	df000315 	stw	fp,12(sp)
 d029694:	df000304 	addi	fp,sp,12
 d029698:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 d02969c:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 d0296a0:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 d0296a4:	e0bfff17 	ldw	r2,-4(fp)
 d0296a8:	1004803a 	cmplt	r2,r2,zero
 d0296ac:	1000201e 	bne	r2,zero,d029730 <LOCK_NET_RESOURCE+0xa8>
 d0296b0:	e0bfff17 	ldw	r2,-4(fp)
 d0296b4:	10800408 	cmpgei	r2,r2,16
 d0296b8:	10001d1e 	bne	r2,zero,d029730 <LOCK_NET_RESOURCE+0xa8>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 d0296bc:	e0bfff17 	ldw	r2,-4(fp)
 d0296c0:	00c341b4 	movhi	r3,3334
 d0296c4:	18f3cc04 	addi	r3,r3,-12496
 d0296c8:	1085883a 	add	r2,r2,r2
 d0296cc:	1085883a 	add	r2,r2,r2
 d0296d0:	10c5883a 	add	r2,r2,r3
 d0296d4:	11000017 	ldw	r4,0(r2)
 d0296d8:	e1bffe04 	addi	r6,fp,-8
 d0296dc:	000b883a 	mov	r5,zero
 d0296e0:	d0132540 	call	d013254 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 d0296e4:	e0bffe03 	ldbu	r2,-8(fp)
 d0296e8:	10803fcc 	andi	r2,r2,255
 d0296ec:	10800298 	cmpnei	r2,r2,10
 d0296f0:	10000a1e 	bne	r2,zero,d02971c <LOCK_NET_RESOURCE+0x94>
 d0296f4:	e0bffd17 	ldw	r2,-12(fp)
 d0296f8:	10800044 	addi	r2,r2,1
 d0296fc:	e0bffd15 	stw	r2,-12(fp)
 d029700:	e0bffd17 	ldw	r2,-12(fp)
 d029704:	1080fa50 	cmplti	r2,r2,1001
 d029708:	1000041e 	bne	r2,zero,d02971c <LOCK_NET_RESOURCE+0x94>
         {
            panic("lock NET");   /* fatal */
 d02970c:	01034174 	movhi	r4,3333
 d029710:	213cfd04 	addi	r4,r4,-3084
 d029714:	d0246440 	call	d024644 <panic>
            return;
 d029718:	00000606 	br	d029734 <LOCK_NET_RESOURCE+0xac>
         }
      } while (error == 10);
 d02971c:	e0bffe03 	ldbu	r2,-8(fp)
 d029720:	10803fcc 	andi	r2,r2,255
 d029724:	108002a0 	cmpeqi	r2,r2,10
 d029728:	103fe41e 	bne	r2,zero,d0296bc <LOCK_NET_RESOURCE+0x34>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 d02972c:	00000106 	br	d029734 <LOCK_NET_RESOURCE+0xac>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 d029730:	d0293e80 	call	d0293e8 <dtrap>
}
 d029734:	e037883a 	mov	sp,fp
 d029738:	dfc00117 	ldw	ra,4(sp)
 d02973c:	df000017 	ldw	fp,0(sp)
 d029740:	dec00204 	addi	sp,sp,8
 d029744:	f800283a 	ret

0d029748 <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 d029748:	defffc04 	addi	sp,sp,-16
 d02974c:	dfc00315 	stw	ra,12(sp)
 d029750:	df000215 	stw	fp,8(sp)
 d029754:	df000204 	addi	fp,sp,8
 d029758:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 d02975c:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 d029760:	e0bfff17 	ldw	r2,-4(fp)
 d029764:	1004803a 	cmplt	r2,r2,zero
 d029768:	1000131e 	bne	r2,zero,d0297b8 <UNLOCK_NET_RESOURCE+0x70>
 d02976c:	e0bfff17 	ldw	r2,-4(fp)
 d029770:	10800408 	cmpgei	r2,r2,16
 d029774:	1000101e 	bne	r2,zero,d0297b8 <UNLOCK_NET_RESOURCE+0x70>
   {
      error = OSSemPost(resid_semaphore[resid]);
 d029778:	e0bfff17 	ldw	r2,-4(fp)
 d02977c:	00c341b4 	movhi	r3,3334
 d029780:	18f3cc04 	addi	r3,r3,-12496
 d029784:	1085883a 	add	r2,r2,r2
 d029788:	1085883a 	add	r2,r2,r2
 d02978c:	10c5883a 	add	r2,r2,r3
 d029790:	11000017 	ldw	r4,0(r2)
 d029794:	d01364c0 	call	d01364c <OSSemPost>
 d029798:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 d02979c:	e0bffe03 	ldbu	r2,-8(fp)
 d0297a0:	1005003a 	cmpeq	r2,r2,zero
 d0297a4:	1000051e 	bne	r2,zero,d0297bc <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
 d0297a8:	01034174 	movhi	r4,3333
 d0297ac:	213d0004 	addi	r4,r4,-3072
 d0297b0:	d0246440 	call	d024644 <panic>
void
UNLOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 d0297b4:	00000106 	br	d0297bc <UNLOCK_NET_RESOURCE+0x74>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 d0297b8:	d0293e80 	call	d0293e8 <dtrap>
}
 d0297bc:	e037883a 	mov	sp,fp
 d0297c0:	dfc00117 	ldw	ra,4(sp)
 d0297c4:	df000017 	ldw	fp,0(sp)
 d0297c8:	dec00204 	addi	sp,sp,8
 d0297cc:	f800283a 	ret

0d0297d0 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 d0297d0:	deffed04 	addi	sp,sp,-76
 d0297d4:	dfc01215 	stw	ra,72(sp)
 d0297d8:	df001115 	stw	fp,68(sp)
 d0297dc:	df001104 	addi	fp,sp,68
 d0297e0:	e13ffe15 	stw	r4,-8(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 d0297e4:	e0bffe17 	ldw	r2,-8(fp)
 d0297e8:	10800417 	ldw	r2,16(r2)
 d0297ec:	1009883a 	mov	r4,r2
 d0297f0:	d029e2c0 	call	d029e2c <npalloc>
 d0297f4:	e0bff415 	stw	r2,-48(fp)
   if(!stack)
 d0297f8:	e0bff417 	ldw	r2,-48(fp)
 d0297fc:	1004c03a 	cmpne	r2,r2,zero
 d029800:	1000031e 	bne	r2,zero,d029810 <TK_NEWTASK+0x40>
      panic("stack alloc");
 d029804:	01034174 	movhi	r4,3333
 d029808:	213d0304 	addi	r4,r4,-3060
 d02980c:	d0246440 	call	d024644 <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 d029810:	e0bffe17 	ldw	r2,-8(fp)
 d029814:	11400217 	ldw	r5,8(r2)
 d029818:	e0bffe17 	ldw	r2,-8(fp)
 d02981c:	10800417 	ldw	r2,16(r2)
 d029820:	1004d0ba 	srli	r2,r2,2
 d029824:	1085883a 	add	r2,r2,r2
 d029828:	1085883a 	add	r2,r2,r2
 d02982c:	1007883a 	mov	r3,r2
 d029830:	e0bff417 	ldw	r2,-48(fp)
 d029834:	1885883a 	add	r2,r3,r2
 d029838:	11bfff04 	addi	r6,r2,-4
 d02983c:	e0bffe17 	ldw	r2,-8(fp)
 d029840:	10800317 	ldw	r2,12(r2)
 d029844:	11c03fcc 	andi	r7,r2,255
 d029848:	e0bffe17 	ldw	r2,-8(fp)
 d02984c:	10800317 	ldw	r2,12(r2)
 d029850:	10ffffcc 	andi	r3,r2,65535
 d029854:	e0bffe17 	ldw	r2,-8(fp)
 d029858:	10800417 	ldw	r2,16(r2)
 d02985c:	1008d0ba 	srli	r4,r2,2
 d029860:	d8c00015 	stw	r3,0(sp)
 d029864:	e0bff417 	ldw	r2,-48(fp)
 d029868:	d8800115 	stw	r2,4(sp)
 d02986c:	d9000215 	stw	r4,8(sp)
 d029870:	d8000315 	stw	zero,12(sp)
 d029874:	008000c4 	movi	r2,3
 d029878:	d8800415 	stw	r2,16(sp)
 d02987c:	2809883a 	mov	r4,r5
 d029880:	000b883a 	mov	r5,zero
 d029884:	d0140f00 	call	d0140f0 <OSTaskCreateExt>
 d029888:	e0bff505 	stb	r2,-44(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 d02988c:	e0bff503 	ldbu	r2,-44(fp)
 d029890:	10803fcc 	andi	r2,r2,255
 d029894:	10800a18 	cmpnei	r2,r2,40
 d029898:	1000161e 	bne	r2,zero,d0298f4 <TK_NEWTASK+0x124>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
 d02989c:	e0bffe17 	ldw	r2,-8(fp)
 d0298a0:	10800317 	ldw	r2,12(r2)
 d0298a4:	11003fcc 	andi	r4,r2,255
 d0298a8:	e17ff584 	addi	r5,fp,-42
 d0298ac:	e1bff544 	addi	r6,fp,-43
 d0298b0:	d01486c0 	call	d01486c <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 d0298b4:	e03ffd45 	stb	zero,-11(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 d0298b8:	e0bffe17 	ldw	r2,-8(fp)
 d0298bc:	11400117 	ldw	r5,4(r2)
 d0298c0:	e0bffe17 	ldw	r2,-8(fp)
 d0298c4:	11800317 	ldw	r6,12(r2)
 d0298c8:	e0bffe17 	ldw	r2,-8(fp)
 d0298cc:	10800317 	ldw	r2,12(r2)
 d0298d0:	e1fff584 	addi	r7,fp,-42
 d0298d4:	d8800015 	stw	r2,0(sp)
 d0298d8:	01034174 	movhi	r4,3333
 d0298dc:	213d0604 	addi	r4,r4,-3048
 d0298e0:	d0029980 	call	d002998 <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 d0298e4:	01034174 	movhi	r4,3333
 d0298e8:	213d1e04 	addi	r4,r4,-2952
 d0298ec:	d002cc00 	call	d002cc0 <puts>
 d0298f0:	00001e06 	br	d02996c <TK_NEWTASK+0x19c>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 d0298f4:	e0bff503 	ldbu	r2,-44(fp)
 d0298f8:	10803fcc 	andi	r2,r2,255
 d0298fc:	10800a98 	cmpnei	r2,r2,42
 d029900:	10000c1e 	bne	r2,zero,d029934 <TK_NEWTASK+0x164>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 d029904:	e0bffe17 	ldw	r2,-8(fp)
 d029908:	11400117 	ldw	r5,4(r2)
 d02990c:	e0bffe17 	ldw	r2,-8(fp)
 d029910:	11800317 	ldw	r6,12(r2)
 d029914:	01034174 	movhi	r4,3333
 d029918:	213d4604 	addi	r4,r4,-2792
 d02991c:	01c00504 	movi	r7,20
 d029920:	d0029980 	call	d002998 <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 d029924:	01034174 	movhi	r4,3333
 d029928:	213d6304 	addi	r4,r4,-2676
 d02992c:	d002cc00 	call	d002cc0 <puts>
 d029930:	00000e06 	br	d02996c <TK_NEWTASK+0x19c>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 d029934:	e0bff503 	ldbu	r2,-44(fp)
 d029938:	10803fcc 	andi	r2,r2,255
 d02993c:	1005003a 	cmpeq	r2,r2,zero
 d029940:	10000a1e 	bne	r2,zero,d02996c <TK_NEWTASK+0x19c>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 d029944:	e0bff503 	ldbu	r2,-44(fp)
 d029948:	11403fcc 	andi	r5,r2,255
 d02994c:	e0bffe17 	ldw	r2,-8(fp)
 d029950:	11800117 	ldw	r6,4(r2)
 d029954:	01034174 	movhi	r4,3333
 d029958:	213d8204 	addi	r4,r4,-2552
 d02995c:	d0029980 	call	d002998 <printf>
             error, nettask->name);
      return (-1);
 d029960:	00bfffc4 	movi	r2,-1
 d029964:	e0bfff15 	stw	r2,-4(fp)
 d029968:	00001806 	br	d0299cc <TK_NEWTASK+0x1fc>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, &nettask->name[0], &error);
 d02996c:	e0bffe17 	ldw	r2,-8(fp)
 d029970:	10800317 	ldw	r2,12(r2)
 d029974:	11003fcc 	andi	r4,r2,255
 d029978:	e0bffe17 	ldw	r2,-8(fp)
 d02997c:	10800117 	ldw	r2,4(r2)
 d029980:	100b883a 	mov	r5,r2
 d029984:	e1bff504 	addi	r6,fp,-44
 d029988:	d014a240 	call	d014a24 <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 d02998c:	e0fff417 	ldw	r3,-48(fp)
 d029990:	e0bffe17 	ldw	r2,-8(fp)
 d029994:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 d029998:	e0bffe17 	ldw	r2,-8(fp)
 d02999c:	10c00017 	ldw	r3,0(r2)
 d0299a0:	e0bffe17 	ldw	r2,-8(fp)
 d0299a4:	10800317 	ldw	r2,12(r2)
 d0299a8:	18800005 	stb	r2,0(r3)

   printf("Created \"%s\" task (Prio: %d)\n",
 d0299ac:	e0bffe17 	ldw	r2,-8(fp)
 d0299b0:	11400117 	ldw	r5,4(r2)
 d0299b4:	e0bffe17 	ldw	r2,-8(fp)
 d0299b8:	11800317 	ldw	r6,12(r2)
 d0299bc:	01034174 	movhi	r4,3333
 d0299c0:	213d9004 	addi	r4,r4,-2496
 d0299c4:	d0029980 	call	d002998 <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 d0299c8:	e03fff15 	stw	zero,-4(fp)
 d0299cc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0299d0:	e037883a 	mov	sp,fp
 d0299d4:	dfc00117 	ldw	ra,4(sp)
 d0299d8:	df000017 	ldw	fp,0(sp)
 d0299dc:	dec00204 	addi	sp,sp,8
 d0299e0:	f800283a 	ret

0d0299e4 <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 d0299e4:	defffb04 	addi	sp,sp,-20
 d0299e8:	dfc00415 	stw	ra,16(sp)
 d0299ec:	df000315 	stw	fp,12(sp)
 d0299f0:	df000304 	addi	fp,sp,12
 d0299f4:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 d0299f8:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 d0299fc:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 d029a00:	e0bfff17 	ldw	r2,-4(fp)
 d029a04:	108001a8 	cmpgeui	r2,r2,6
 d029a08:	10001d1e 	bne	r2,zero,d029a80 <wait_app_sem+0x9c>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 d029a0c:	e0bfff17 	ldw	r2,-4(fp)
 d029a10:	00c341b4 	movhi	r3,3334
 d029a14:	18f3dc04 	addi	r3,r3,-12432
 d029a18:	1085883a 	add	r2,r2,r2
 d029a1c:	1085883a 	add	r2,r2,r2
 d029a20:	10c5883a 	add	r2,r2,r3
 d029a24:	11000017 	ldw	r4,0(r2)
 d029a28:	e1bffe04 	addi	r6,fp,-8
 d029a2c:	000b883a 	mov	r5,zero
 d029a30:	d0132540 	call	d013254 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 d029a34:	e0bffe03 	ldbu	r2,-8(fp)
 d029a38:	10803fcc 	andi	r2,r2,255
 d029a3c:	10800298 	cmpnei	r2,r2,10
 d029a40:	10000a1e 	bne	r2,zero,d029a6c <wait_app_sem+0x88>
 d029a44:	e0bffd17 	ldw	r2,-12(fp)
 d029a48:	10800044 	addi	r2,r2,1
 d029a4c:	e0bffd15 	stw	r2,-12(fp)
 d029a50:	e0bffd17 	ldw	r2,-12(fp)
 d029a54:	1080fa50 	cmplti	r2,r2,1001
 d029a58:	1000041e 	bne	r2,zero,d029a6c <wait_app_sem+0x88>
         {
            panic("lock NET");   /* fatal */
 d029a5c:	01034174 	movhi	r4,3333
 d029a60:	213cfd04 	addi	r4,r4,-3084
 d029a64:	d0246440 	call	d024644 <panic>
            return;
 d029a68:	00000606 	br	d029a84 <wait_app_sem+0xa0>
         }
      } while (error == 10);
 d029a6c:	e0bffe03 	ldbu	r2,-8(fp)
 d029a70:	10803fcc 	andi	r2,r2,255
 d029a74:	108002a0 	cmpeqi	r2,r2,10
 d029a78:	103fe41e 	bne	r2,zero,d029a0c <wait_app_sem+0x28>
 d029a7c:	00000106 	br	d029a84 <wait_app_sem+0xa0>
   }
   else
      dtrap();
 d029a80:	d0293e80 	call	d0293e8 <dtrap>
}
 d029a84:	e037883a 	mov	sp,fp
 d029a88:	dfc00117 	ldw	ra,4(sp)
 d029a8c:	df000017 	ldw	fp,0(sp)
 d029a90:	dec00204 	addi	sp,sp,8
 d029a94:	f800283a 	ret

0d029a98 <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 d029a98:	defffc04 	addi	sp,sp,-16
 d029a9c:	dfc00315 	stw	ra,12(sp)
 d029aa0:	df000215 	stw	fp,8(sp)
 d029aa4:	df000204 	addi	fp,sp,8
 d029aa8:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 d029aac:	e0bfff17 	ldw	r2,-4(fp)
 d029ab0:	108001a8 	cmpgeui	r2,r2,6
 d029ab4:	1000101e 	bne	r2,zero,d029af8 <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 d029ab8:	e0bfff17 	ldw	r2,-4(fp)
 d029abc:	00c341b4 	movhi	r3,3334
 d029ac0:	18f3dc04 	addi	r3,r3,-12432
 d029ac4:	1085883a 	add	r2,r2,r2
 d029ac8:	1085883a 	add	r2,r2,r2
 d029acc:	10c5883a 	add	r2,r2,r3
 d029ad0:	11000017 	ldw	r4,0(r2)
 d029ad4:	d01364c0 	call	d01364c <OSSemPost>
 d029ad8:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 d029adc:	e0bffe03 	ldbu	r2,-8(fp)
 d029ae0:	1005003a 	cmpeq	r2,r2,zero
 d029ae4:	1000051e 	bne	r2,zero,d029afc <post_app_sem+0x64>
      {
         panic("unlock NET");
 d029ae8:	01034174 	movhi	r4,3333
 d029aec:	213d0004 	addi	r4,r4,-3072
 d029af0:	d0246440 	call	d024644 <panic>
 d029af4:	00000106 	br	d029afc <post_app_sem+0x64>
      }
   }
   else
      dtrap();
 d029af8:	d0293e80 	call	d0293e8 <dtrap>
}
 d029afc:	e037883a 	mov	sp,fp
 d029b00:	dfc00117 	ldw	ra,4(sp)
 d029b04:	df000017 	ldw	fp,0(sp)
 d029b08:	dec00204 	addi	sp,sp,8
 d029b0c:	f800283a 	ret

0d029b10 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 d029b10:	defffc04 	addi	sp,sp,-16
 d029b14:	dfc00315 	stw	ra,12(sp)
 d029b18:	df000215 	stw	fp,8(sp)
 d029b1c:	dc000115 	stw	r16,4(sp)
 d029b20:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 d029b24:	01000044 	movi	r4,1
 d029b28:	d012ea00 	call	d012ea0 <OSSemCreate>
 d029b2c:	d0a0aa15 	stw	r2,-32088(gp)
   if (!mheap_sem_ptr)
 d029b30:	d0a0aa17 	ldw	r2,-32088(gp)
 d029b34:	1004c03a 	cmpne	r2,r2,zero
 d029b38:	1000031e 	bne	r2,zero,d029b48 <alt_iniche_init+0x38>
      panic("mheap_sem_ptr create err"); 
 d029b3c:	01034174 	movhi	r4,3333
 d029b40:	213d9804 	addi	r4,r4,-2464
 d029b44:	d0246440 	call	d024644 <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 d029b48:	0009883a 	mov	r4,zero
 d029b4c:	d012ea00 	call	d012ea0 <OSSemCreate>
 d029b50:	d0a0ab15 	stw	r2,-32084(gp)
   if (!rcvdq_sem_ptr)
 d029b54:	d0a0ab17 	ldw	r2,-32084(gp)
 d029b58:	1004c03a 	cmpne	r2,r2,zero
 d029b5c:	1000031e 	bne	r2,zero,d029b6c <alt_iniche_init+0x5c>
      panic("rcvdq_sem_ptr create err"); 
 d029b60:	01034174 	movhi	r4,3333
 d029b64:	213d9f04 	addi	r4,r4,-2436
 d029b68:	d0246440 	call	d024644 <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 d029b6c:	e03fff15 	stw	zero,-4(fp)
 d029b70:	00001906 	br	d029bd8 <alt_iniche_init+0xc8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 d029b74:	e43fff17 	ldw	r16,-4(fp)
 d029b78:	01000044 	movi	r4,1
 d029b7c:	d012ea00 	call	d012ea0 <OSSemCreate>
 d029b80:	1009883a 	mov	r4,r2
 d029b84:	00c341b4 	movhi	r3,3334
 d029b88:	18f3cc04 	addi	r3,r3,-12496
 d029b8c:	8405883a 	add	r2,r16,r16
 d029b90:	1085883a 	add	r2,r2,r2
 d029b94:	10c5883a 	add	r2,r2,r3
 d029b98:	11000015 	stw	r4,0(r2)
      if (!resid_semaphore[i])
 d029b9c:	e0bfff17 	ldw	r2,-4(fp)
 d029ba0:	00c341b4 	movhi	r3,3334
 d029ba4:	18f3cc04 	addi	r3,r3,-12496
 d029ba8:	1085883a 	add	r2,r2,r2
 d029bac:	1085883a 	add	r2,r2,r2
 d029bb0:	10c5883a 	add	r2,r2,r3
 d029bb4:	10800017 	ldw	r2,0(r2)
 d029bb8:	1004c03a 	cmpne	r2,r2,zero
 d029bbc:	1000031e 	bne	r2,zero,d029bcc <alt_iniche_init+0xbc>
         panic("resid_semaphore create err");  
 d029bc0:	01034174 	movhi	r4,3333
 d029bc4:	213da604 	addi	r4,r4,-2408
 d029bc8:	d0246440 	call	d024644 <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 d029bcc:	e0bfff17 	ldw	r2,-4(fp)
 d029bd0:	10800044 	addi	r2,r2,1
 d029bd4:	e0bfff15 	stw	r2,-4(fp)
 d029bd8:	e0bfff17 	ldw	r2,-4(fp)
 d029bdc:	10800410 	cmplti	r2,r2,16
 d029be0:	103fe41e 	bne	r2,zero,d029b74 <alt_iniche_init+0x64>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 d029be4:	e03fff15 	stw	zero,-4(fp)
 d029be8:	00001906 	br	d029c50 <alt_iniche_init+0x140>
   {
      app_semaphore[i] = OSSemCreate(1);
 d029bec:	e43fff17 	ldw	r16,-4(fp)
 d029bf0:	01000044 	movi	r4,1
 d029bf4:	d012ea00 	call	d012ea0 <OSSemCreate>
 d029bf8:	1009883a 	mov	r4,r2
 d029bfc:	00c341b4 	movhi	r3,3334
 d029c00:	18f3dc04 	addi	r3,r3,-12432
 d029c04:	8405883a 	add	r2,r16,r16
 d029c08:	1085883a 	add	r2,r2,r2
 d029c0c:	10c5883a 	add	r2,r2,r3
 d029c10:	11000015 	stw	r4,0(r2)
      if (!app_semaphore[i])
 d029c14:	e0bfff17 	ldw	r2,-4(fp)
 d029c18:	00c341b4 	movhi	r3,3334
 d029c1c:	18f3dc04 	addi	r3,r3,-12432
 d029c20:	1085883a 	add	r2,r2,r2
 d029c24:	1085883a 	add	r2,r2,r2
 d029c28:	10c5883a 	add	r2,r2,r3
 d029c2c:	10800017 	ldw	r2,0(r2)
 d029c30:	1004c03a 	cmpne	r2,r2,zero
 d029c34:	1000031e 	bne	r2,zero,d029c44 <alt_iniche_init+0x134>
         panic("app_semaphore create err");  
 d029c38:	01034174 	movhi	r4,3333
 d029c3c:	213dad04 	addi	r4,r4,-2380
 d029c40:	d0246440 	call	d024644 <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 d029c44:	e0bfff17 	ldw	r2,-4(fp)
 d029c48:	10800044 	addi	r2,r2,1
 d029c4c:	e0bfff15 	stw	r2,-4(fp)
 d029c50:	e0bfff17 	ldw	r2,-4(fp)
 d029c54:	10800190 	cmplti	r2,r2,6
 d029c58:	103fe41e 	bne	r2,zero,d029bec <alt_iniche_init+0xdc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 d029c5c:	e03fff15 	stw	zero,-4(fp)
 d029c60:	00002606 	br	d029cfc <alt_iniche_init+0x1ec>
   {
      global_TCPwakeup_set[i].ctick = 0;
 d029c64:	e0bfff17 	ldw	r2,-4(fp)
 d029c68:	00c341b4 	movhi	r3,3334
 d029c6c:	18f39004 	addi	r3,r3,-12736
 d029c70:	10800324 	muli	r2,r2,12
 d029c74:	10c5883a 	add	r2,r2,r3
 d029c78:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 d029c7c:	e0bfff17 	ldw	r2,-4(fp)
 d029c80:	00c341b4 	movhi	r3,3334
 d029c84:	18f39004 	addi	r3,r3,-12736
 d029c88:	10800324 	muli	r2,r2,12
 d029c8c:	10c5883a 	add	r2,r2,r3
 d029c90:	10800104 	addi	r2,r2,4
 d029c94:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 d029c98:	e43fff17 	ldw	r16,-4(fp)
 d029c9c:	0009883a 	mov	r4,zero
 d029ca0:	d012ea00 	call	d012ea0 <OSSemCreate>
 d029ca4:	1009883a 	mov	r4,r2
 d029ca8:	00c341b4 	movhi	r3,3334
 d029cac:	18f39004 	addi	r3,r3,-12736
 d029cb0:	80800324 	muli	r2,r16,12
 d029cb4:	10c5883a 	add	r2,r2,r3
 d029cb8:	10800204 	addi	r2,r2,8
 d029cbc:	11000015 	stw	r4,0(r2)
      if (!global_TCPwakeup_set[i].semaphore)
 d029cc0:	e0bfff17 	ldw	r2,-4(fp)
 d029cc4:	00c341b4 	movhi	r3,3334
 d029cc8:	18f39004 	addi	r3,r3,-12736
 d029ccc:	10800324 	muli	r2,r2,12
 d029cd0:	10c5883a 	add	r2,r2,r3
 d029cd4:	10800204 	addi	r2,r2,8
 d029cd8:	10800017 	ldw	r2,0(r2)
 d029cdc:	1004c03a 	cmpne	r2,r2,zero
 d029ce0:	1000031e 	bne	r2,zero,d029cf0 <alt_iniche_init+0x1e0>
         panic("globwake_semaphore create err");  
 d029ce4:	01034174 	movhi	r4,3333
 d029ce8:	213db404 	addi	r4,r4,-2352
 d029cec:	d0246440 	call	d024644 <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 d029cf0:	e0bfff17 	ldw	r2,-4(fp)
 d029cf4:	10800044 	addi	r2,r2,1
 d029cf8:	e0bfff15 	stw	r2,-4(fp)
 d029cfc:	e0bfff17 	ldw	r2,-4(fp)
 d029d00:	10800510 	cmplti	r2,r2,20
 d029d04:	103fd71e 	bne	r2,zero,d029c64 <alt_iniche_init+0x154>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 d029d08:	00834174 	movhi	r2,3333
 d029d0c:	108ac804 	addi	r2,r2,11040
 d029d10:	10000015 	stw	zero,0(r2)
#endif  /* TCPWAKE_RTOS */
}
 d029d14:	e037883a 	mov	sp,fp
 d029d18:	dfc00217 	ldw	ra,8(sp)
 d029d1c:	df000117 	ldw	fp,4(sp)
 d029d20:	dc000017 	ldw	r16,0(sp)
 d029d24:	dec00304 	addi	sp,sp,12
 d029d28:	f800283a 	ret

0d029d2c <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 d029d2c:	deffff04 	addi	sp,sp,-4
 d029d30:	df000015 	stw	fp,0(sp)
 d029d34:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 d029d38:	00c34174 	movhi	r3,3333
 d029d3c:	18ca5904 	addi	r3,r3,10596
 d029d40:	00800784 	movi	r2,30
 d029d44:	18800015 	stw	r2,0(r3)
   lilbufs = MAXLILPKTS;
 d029d48:	00c34174 	movhi	r3,3333
 d029d4c:	18ca5704 	addi	r3,r3,10588
 d029d50:	00800784 	movi	r2,30
 d029d54:	18800015 	stw	r2,0(r3)
   bigbufsiz = BIGBUFSIZE;
 d029d58:	00c34174 	movhi	r3,3333
 d029d5c:	18ca5a04 	addi	r3,r3,10600
 d029d60:	00818004 	movi	r2,1536
 d029d64:	18800015 	stw	r2,0(r3)
   lilbufsiz = LILBUFSIZE;
 d029d68:	00c34174 	movhi	r3,3333
 d029d6c:	18ca5804 	addi	r3,r3,10592
 d029d70:	00802004 	movi	r2,128
 d029d74:	18800015 	stw	r2,0(r3)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 d029d78:	00c34174 	movhi	r3,3333
 d029d7c:	18caeb04 	addi	r3,r3,11180
 d029d80:	008340f4 	movhi	r2,3331
 d029d84:	10a77004 	addi	r2,r2,-25152
 d029d88:	18800015 	stw	r2,0(r3)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 d029d8c:	0005883a 	mov	r2,zero
}
 d029d90:	e037883a 	mov	sp,fp
 d029d94:	df000017 	ldw	fp,0(sp)
 d029d98:	dec00104 	addi	sp,sp,4
 d029d9c:	f800283a 	ret

0d029da0 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 d029da0:	deffff04 	addi	sp,sp,-4
 d029da4:	df000015 	stw	fp,0(sp)
 d029da8:	d839883a 	mov	fp,sp
   return NULL;
 d029dac:	0005883a 	mov	r2,zero
}
 d029db0:	e037883a 	mov	sp,fp
 d029db4:	df000017 	ldw	fp,0(sp)
 d029db8:	dec00104 	addi	sp,sp,4
 d029dbc:	f800283a 	ret

0d029dc0 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 d029dc0:	defffd04 	addi	sp,sp,-12
 d029dc4:	dfc00215 	stw	ra,8(sp)
 d029dc8:	df000115 	stw	fp,4(sp)
 d029dcc:	df000104 	addi	fp,sp,4
 d029dd0:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 d029dd4:	e13fff17 	ldw	r4,-4(fp)
 d029dd8:	d0210700 	call	d021070 <iniche_devices_init>
 d029ddc:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 d029de0:	e0bfff17 	ldw	r2,-4(fp)
}
 d029de4:	e037883a 	mov	sp,fp
 d029de8:	dfc00117 	ldw	ra,4(sp)
 d029dec:	df000017 	ldw	fp,0(sp)
 d029df0:	dec00204 	addi	sp,sp,8
 d029df4:	f800283a 	ret

0d029df8 <calloc2>:
 * There is already a function called calloc1() in memio.c,
 * hence use a different function name.
 */
char * 
calloc2(unsigned size)
{
 d029df8:	defffd04 	addi	sp,sp,-12
 d029dfc:	dfc00215 	stw	ra,8(sp)
 d029e00:	df000115 	stw	fp,4(sp)
 d029e04:	df000104 	addi	fp,sp,4
 d029e08:	e13fff15 	stw	r4,-4(fp)
   return (calloc(1,size));
 d029e0c:	01000044 	movi	r4,1
 d029e10:	e17fff17 	ldw	r5,-4(fp)
 d029e14:	d049e580 	call	d049e58 <calloc>
}
 d029e18:	e037883a 	mov	sp,fp
 d029e1c:	dfc00117 	ldw	ra,4(sp)
 d029e20:	df000017 	ldw	fp,0(sp)
 d029e24:	dec00204 	addi	sp,sp,8
 d029e28:	f800283a 	ret

0d029e2c <npalloc>:


char *
npalloc(unsigned size)
{
 d029e2c:	defff904 	addi	sp,sp,-28
 d029e30:	dfc00615 	stw	ra,24(sp)
 d029e34:	df000515 	stw	fp,20(sp)
 d029e38:	df000504 	addi	fp,sp,20
 d029e3c:	e13ffe15 	stw	r4,-8(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 d029e40:	d120aa17 	ldw	r4,-32088(gp)
 d029e44:	e1bffd04 	addi	r6,fp,-12
 d029e48:	000b883a 	mov	r5,zero
 d029e4c:	d0132540 	call	d013254 <OSSemPend>
   if(err)
 d029e50:	e0bffd03 	ldbu	r2,-12(fp)
 d029e54:	10803fcc 	andi	r2,r2,255
 d029e58:	1005003a 	cmpeq	r2,r2,zero
 d029e5c:	1000181e 	bne	r2,zero,d029ec0 <npalloc+0x94>
   {
      int errct = 0;
 d029e60:	e03ffb15 	stw	zero,-20(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 d029e64:	00001206 	br	d029eb0 <npalloc+0x84>
      {
         if(errct++ > 1000)
 d029e68:	e0bffb17 	ldw	r2,-20(fp)
 d029e6c:	1080fa48 	cmpgei	r2,r2,1001
 d029e70:	1007883a 	mov	r3,r2
 d029e74:	e0bffb17 	ldw	r2,-20(fp)
 d029e78:	10800044 	addi	r2,r2,1
 d029e7c:	e0bffb15 	stw	r2,-20(fp)
 d029e80:	18803fcc 	andi	r2,r3,255
 d029e84:	1005003a 	cmpeq	r2,r2,zero
 d029e88:	1000051e 	bne	r2,zero,d029ea0 <npalloc+0x74>
         {
            panic("npalloc");    /* fatal? */
 d029e8c:	01034174 	movhi	r4,3333
 d029e90:	213dbc04 	addi	r4,r4,-2320
 d029e94:	d0246440 	call	d024644 <panic>
            return NULL;
 d029e98:	e03fff15 	stw	zero,-4(fp)
 d029e9c:	00001a06 	br	d029f08 <npalloc+0xdc>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 d029ea0:	d120aa17 	ldw	r4,-32088(gp)
 d029ea4:	e1bffd04 	addi	r6,fp,-12
 d029ea8:	000b883a 	mov	r5,zero
 d029eac:	d0132540 	call	d013254 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 d029eb0:	e0bffd03 	ldbu	r2,-12(fp)
 d029eb4:	10803fcc 	andi	r2,r2,255
 d029eb8:	108002a0 	cmpeqi	r2,r2,10
 d029ebc:	103fea1e 	bne	r2,zero,d029e68 <npalloc+0x3c>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, calloc2);
#else
   ptr = calloc2(size);
 d029ec0:	e13ffe17 	ldw	r4,-8(fp)
 d029ec4:	d029df80 	call	d029df8 <calloc2>
 d029ec8:	e0bffc15 	stw	r2,-16(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 d029ecc:	d120aa17 	ldw	r4,-32088(gp)
 d029ed0:	d01364c0 	call	d01364c <OSSemPost>
 d029ed4:	e0bffd05 	stb	r2,-12(fp)
#endif
   
   if(!ptr)
 d029ed8:	e0bffc17 	ldw	r2,-16(fp)
 d029edc:	1004c03a 	cmpne	r2,r2,zero
 d029ee0:	1000021e 	bne	r2,zero,d029eec <npalloc+0xc0>
      return NULL;
 d029ee4:	e03fff15 	stw	zero,-4(fp)
 d029ee8:	00000706 	br	d029f08 <npalloc+0xdc>

   MEMSET(ptr, 0, size);
 d029eec:	e0bffc17 	ldw	r2,-16(fp)
 d029ef0:	1009883a 	mov	r4,r2
 d029ef4:	e1bffe17 	ldw	r6,-8(fp)
 d029ef8:	000b883a 	mov	r5,zero
 d029efc:	d0028800 	call	d002880 <memset>
   return ptr;      
 d029f00:	e0bffc17 	ldw	r2,-16(fp)
 d029f04:	e0bfff15 	stw	r2,-4(fp)
 d029f08:	e0bfff17 	ldw	r2,-4(fp)
}
 d029f0c:	e037883a 	mov	sp,fp
 d029f10:	dfc00117 	ldw	ra,4(sp)
 d029f14:	df000017 	ldw	fp,0(sp)
 d029f18:	dec00204 	addi	sp,sp,8
 d029f1c:	f800283a 	ret

0d029f20 <npfree>:

void
npfree(void * ptr)
{
 d029f20:	defffb04 	addi	sp,sp,-20
 d029f24:	dfc00415 	stw	ra,16(sp)
 d029f28:	df000315 	stw	fp,12(sp)
 d029f2c:	df000304 	addi	fp,sp,12
 d029f30:	e13fff15 	stw	r4,-4(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 d029f34:	d120aa17 	ldw	r4,-32088(gp)
 d029f38:	e1bffe04 	addi	r6,fp,-8
 d029f3c:	000b883a 	mov	r5,zero
 d029f40:	d0132540 	call	d013254 <OSSemPend>
   if (err)
 d029f44:	e0bffe03 	ldbu	r2,-8(fp)
 d029f48:	10803fcc 	andi	r2,r2,255
 d029f4c:	1005003a 	cmpeq	r2,r2,zero
 d029f50:	1000171e 	bne	r2,zero,d029fb0 <npfree+0x90>
   {
      int errct = 0;
 d029f54:	e03ffd15 	stw	zero,-12(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 d029f58:	00001106 	br	d029fa0 <npfree+0x80>
      {
         if (errct++ > 1000)
 d029f5c:	e0bffd17 	ldw	r2,-12(fp)
 d029f60:	1080fa48 	cmpgei	r2,r2,1001
 d029f64:	1007883a 	mov	r3,r2
 d029f68:	e0bffd17 	ldw	r2,-12(fp)
 d029f6c:	10800044 	addi	r2,r2,1
 d029f70:	e0bffd15 	stw	r2,-12(fp)
 d029f74:	18803fcc 	andi	r2,r3,255
 d029f78:	1005003a 	cmpeq	r2,r2,zero
 d029f7c:	1000041e 	bne	r2,zero,d029f90 <npfree+0x70>
         {
            panic("npfree");    /* fatal? */
 d029f80:	01034174 	movhi	r4,3333
 d029f84:	213dbe04 	addi	r4,r4,-2312
 d029f88:	d0246440 	call	d024644 <panic>
            return;
 d029f8c:	00000d06 	br	d029fc4 <npfree+0xa4>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 d029f90:	d120aa17 	ldw	r4,-32088(gp)
 d029f94:	e1bffe04 	addi	r6,fp,-8
 d029f98:	000b883a 	mov	r5,zero
 d029f9c:	d0132540 	call	d013254 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 d029fa0:	e0bffe03 	ldbu	r2,-8(fp)
 d029fa4:	10803fcc 	andi	r2,r2,255
 d029fa8:	108002a0 	cmpeqi	r2,r2,10
 d029fac:	103feb1e 	bne	r2,zero,d029f5c <npfree+0x3c>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free);
#else
   free(ptr);
 d029fb0:	e13fff17 	ldw	r4,-4(fp)
 d029fb4:	d049eac0 	call	d049eac <free>
#endif

   err = OSSemPost(mheap_sem_ptr);
 d029fb8:	d120aa17 	ldw	r4,-32088(gp)
 d029fbc:	d01364c0 	call	d01364c <OSSemPost>
 d029fc0:	e0bffe05 	stb	r2,-8(fp)
 */
   free(ptr);
#endif
#endif

}
 d029fc4:	e037883a 	mov	sp,fp
 d029fc8:	dfc00117 	ldw	ra,4(sp)
 d029fcc:	df000017 	ldw	fp,0(sp)
 d029fd0:	dec00204 	addi	sp,sp,8
 d029fd4:	f800283a 	ret

0d029fd8 <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 d029fd8:	defffc04 	addi	sp,sp,-16
 d029fdc:	dfc00315 	stw	ra,12(sp)
 d029fe0:	df000215 	stw	fp,8(sp)
 d029fe4:	df000204 	addi	fp,sp,8
 d029fe8:	e13fff15 	stw	r4,-4(fp)
   char *ptr = npalloc(size);
 d029fec:	e13fff17 	ldw	r4,-4(fp)
 d029ff0:	d029e2c0 	call	d029e2c <npalloc>
 d029ff4:	e0bffe15 	stw	r2,-8(fp)

   if(ptr) {
 d029ff8:	e0bffe17 	ldw	r2,-8(fp)
 d029ffc:	1005003a 	cmpeq	r2,r2,zero
 d02a000:	1000041e 	bne	r2,zero,d02a014 <ncpalloc+0x3c>
      ptr = (char *) alt_remap_uncached(ptr, size);
 d02a004:	e13ffe17 	ldw	r4,-8(fp)
 d02a008:	e17fff17 	ldw	r5,-4(fp)
 d02a00c:	d0396840 	call	d039684 <alt_remap_uncached>
 d02a010:	e0bffe15 	stw	r2,-8(fp)
   }

   return ptr;
 d02a014:	e0bffe17 	ldw	r2,-8(fp)
}
 d02a018:	e037883a 	mov	sp,fp
 d02a01c:	dfc00117 	ldw	ra,4(sp)
 d02a020:	df000017 	ldw	fp,0(sp)
 d02a024:	dec00204 	addi	sp,sp,8
 d02a028:	f800283a 	ret

0d02a02c <ncpfree>:

void ncpfree(void *ptr)
{
 d02a02c:	defffd04 	addi	sp,sp,-12
 d02a030:	dfc00215 	stw	ra,8(sp)
 d02a034:	df000115 	stw	fp,4(sp)
 d02a038:	df000104 	addi	fp,sp,4
 d02a03c:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 d02a040:	e0bfff17 	ldw	r2,-4(fp)
 d02a044:	1005003a 	cmpeq	r2,r2,zero
 d02a048:	1000061e 	bne	r2,zero,d02a064 <ncpfree+0x38>
      ptr = alt_remap_cached(ptr, sizeof(ptr));
 d02a04c:	e13fff17 	ldw	r4,-4(fp)
 d02a050:	01400104 	movi	r5,4
 d02a054:	d03964c0 	call	d03964c <alt_remap_cached>
 d02a058:	e0bfff15 	stw	r2,-4(fp)
      npfree(ptr);
 d02a05c:	e13fff17 	ldw	r4,-4(fp)
 d02a060:	d029f200 	call	d029f20 <npfree>
   }
}
 d02a064:	e037883a 	mov	sp,fp
 d02a068:	dfc00117 	ldw	ra,4(sp)
 d02a06c:	df000017 	ldw	fp,0(sp)
 d02a070:	dec00204 	addi	sp,sp,8
 d02a074:	f800283a 	ret

0d02a078 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 d02a078:	defffb04 	addi	sp,sp,-20
 d02a07c:	dfc00415 	stw	ra,16(sp)
 d02a080:	df000315 	stw	fp,12(sp)
 d02a084:	df000304 	addi	fp,sp,12
 d02a088:	e13ffd15 	stw	r4,-12(fp)
 d02a08c:	e17ffe15 	stw	r5,-8(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 d02a090:	e0bffd17 	ldw	r2,-12(fp)
 d02a094:	108000a0 	cmpeqi	r2,r2,2
 d02a098:	1000031e 	bne	r2,zero,d02a0a8 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 d02a09c:	d0293e80 	call	d0293e8 <dtrap>
         return NULL;
 d02a0a0:	e03fff15 	stw	zero,-4(fp)
 d02a0a4:	00001606 	br	d02a100 <pffindtype+0x88>
      }
   }

   if (type == SOCK_STREAM)
 d02a0a8:	e0bffe17 	ldw	r2,-8(fp)
 d02a0ac:	10800058 	cmpnei	r2,r2,1
 d02a0b0:	1000041e 	bne	r2,zero,d02a0c4 <pffindtype+0x4c>
      return &tcp_protosw;
 d02a0b4:	00834174 	movhi	r2,3333
 d02a0b8:	10893b04 	addi	r2,r2,9452
 d02a0bc:	e0bfff15 	stw	r2,-4(fp)
 d02a0c0:	00000f06 	br	d02a100 <pffindtype+0x88>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 d02a0c4:	e0bffe17 	ldw	r2,-8(fp)
 d02a0c8:	10800098 	cmpnei	r2,r2,2
 d02a0cc:	1000041e 	bne	r2,zero,d02a0e0 <pffindtype+0x68>
      return &udp_protosw;
 d02a0d0:	00834174 	movhi	r2,3333
 d02a0d4:	10894104 	addi	r2,r2,9476
 d02a0d8:	e0bfff15 	stw	r2,-4(fp)
 d02a0dc:	00000806 	br	d02a100 <pffindtype+0x88>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 d02a0e0:	e0bffe17 	ldw	r2,-8(fp)
 d02a0e4:	108000d8 	cmpnei	r2,r2,3
 d02a0e8:	1000041e 	bne	r2,zero,d02a0fc <pffindtype+0x84>
      return &rawip_protosw;
 d02a0ec:	00834174 	movhi	r2,3333
 d02a0f0:	10894704 	addi	r2,r2,9500
 d02a0f4:	e0bfff15 	stw	r2,-4(fp)
 d02a0f8:	00000106 	br	d02a100 <pffindtype+0x88>
#endif  /* IP_RAW */
   else
      return NULL;
 d02a0fc:	e03fff15 	stw	zero,-4(fp)
 d02a100:	e0bfff17 	ldw	r2,-4(fp)
}
 d02a104:	e037883a 	mov	sp,fp
 d02a108:	dfc00117 	ldw	ra,4(sp)
 d02a10c:	df000017 	ldw	fp,0(sp)
 d02a110:	dec00204 	addi	sp,sp,8
 d02a114:	f800283a 	ret

0d02a118 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 d02a118:	defff904 	addi	sp,sp,-28
 d02a11c:	dfc00615 	stw	ra,24(sp)
 d02a120:	df000515 	stw	fp,20(sp)
 d02a124:	df000504 	addi	fp,sp,20
 d02a128:	e13ffb15 	stw	r4,-20(fp)
 d02a12c:	e17ffc15 	stw	r5,-16(fp)
 d02a130:	e1bffd15 	stw	r6,-12(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 d02a134:	e0bffd17 	ldw	r2,-12(fp)
 d02a138:	108000d8 	cmpnei	r2,r2,3
 d02a13c:	1000051e 	bne	r2,zero,d02a154 <pffindproto+0x3c>
      return(pffindtype(domain, type));
 d02a140:	e13ffb17 	ldw	r4,-20(fp)
 d02a144:	e17ffd17 	ldw	r5,-12(fp)
 d02a148:	d02a0780 	call	d02a078 <pffindtype>
 d02a14c:	e0bffe15 	stw	r2,-8(fp)
 d02a150:	00001f06 	br	d02a1d0 <pffindproto+0xb8>
#endif

   switch (protocol)
 d02a154:	e0bffc17 	ldw	r2,-16(fp)
 d02a158:	e0bfff15 	stw	r2,-4(fp)
 d02a15c:	e0ffff17 	ldw	r3,-4(fp)
 d02a160:	188001a0 	cmpeqi	r2,r3,6
 d02a164:	1000071e 	bne	r2,zero,d02a184 <pffindproto+0x6c>
 d02a168:	e0ffff17 	ldw	r3,-4(fp)
 d02a16c:	18800460 	cmpeqi	r2,r3,17
 d02a170:	10000a1e 	bne	r2,zero,d02a19c <pffindproto+0x84>
 d02a174:	e0ffff17 	ldw	r3,-4(fp)
 d02a178:	1805003a 	cmpeq	r2,r3,zero
 d02a17c:	1000101e 	bne	r2,zero,d02a1c0 <pffindproto+0xa8>
 d02a180:	00000c06 	br	d02a1b4 <pffindproto+0x9c>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 d02a184:	e0bffd17 	ldw	r2,-12(fp)
 d02a188:	10800060 	cmpeqi	r2,r2,1
 d02a18c:	10000c1e 	bne	r2,zero,d02a1c0 <pffindproto+0xa8>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 d02a190:	d0293e80 	call	d0293e8 <dtrap>
      return NULL;
 d02a194:	e03ffe15 	stw	zero,-8(fp)
 d02a198:	00000d06 	br	d02a1d0 <pffindproto+0xb8>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 d02a19c:	e0bffd17 	ldw	r2,-12(fp)
 d02a1a0:	108000a0 	cmpeqi	r2,r2,2
 d02a1a4:	1000061e 	bne	r2,zero,d02a1c0 <pffindproto+0xa8>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 d02a1a8:	d0293e80 	call	d0293e8 <dtrap>
      return NULL;
 d02a1ac:	e03ffe15 	stw	zero,-8(fp)
 d02a1b0:	00000706 	br	d02a1d0 <pffindproto+0xb8>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 d02a1b4:	d0293e80 	call	d0293e8 <dtrap>
      return NULL;
 d02a1b8:	e03ffe15 	stw	zero,-8(fp)
 d02a1bc:	00000406 	br	d02a1d0 <pffindproto+0xb8>
   }
   return(pffindtype(domain, type));   /* map to findtype */
 d02a1c0:	e13ffb17 	ldw	r4,-20(fp)
 d02a1c4:	e17ffd17 	ldw	r5,-12(fp)
 d02a1c8:	d02a0780 	call	d02a078 <pffindtype>
 d02a1cc:	e0bffe15 	stw	r2,-8(fp)
 d02a1d0:	e0bffe17 	ldw	r2,-8(fp)
}
 d02a1d4:	e037883a 	mov	sp,fp
 d02a1d8:	dfc00117 	ldw	ra,4(sp)
 d02a1dc:	df000017 	ldw	fp,0(sp)
 d02a1e0:	dec00204 	addi	sp,sp,8
 d02a1e4:	f800283a 	ret

0d02a1e8 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 d02a1e8:	defff904 	addi	sp,sp,-28
 d02a1ec:	dfc00615 	stw	ra,24(sp)
 d02a1f0:	df000515 	stw	fp,20(sp)
 d02a1f4:	df000504 	addi	fp,sp,20
 d02a1f8:	e13ffd15 	stw	r4,-12(fp)
 d02a1fc:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 d02a200:	e03ffb15 	stw	zero,-20(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 d02a204:	e0bffd17 	ldw	r2,-12(fp)
 d02a208:	10800050 	cmplti	r2,r2,1
 d02a20c:	1000031e 	bne	r2,zero,d02a21c <m_getnbuf+0x34>
 d02a210:	e0bffd17 	ldw	r2,-12(fp)
 d02a214:	10800390 	cmplti	r2,r2,14
 d02a218:	1000011e 	bne	r2,zero,d02a220 <m_getnbuf+0x38>
   {
      dtrap(); /* is this OK? */
 d02a21c:	d0293e80 	call	d0293e8 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 d02a220:	e0bffe17 	ldw	r2,-8(fp)
 d02a224:	1005003a 	cmpeq	r2,r2,zero
 d02a228:	10000e1e 	bne	r2,zero,d02a264 <m_getnbuf+0x7c>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d02a22c:	01000084 	movi	r4,2
 d02a230:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 d02a234:	e0bffe17 	ldw	r2,-8(fp)
 d02a238:	10800e04 	addi	r2,r2,56
 d02a23c:	1009883a 	mov	r4,r2
 d02a240:	d0287a40 	call	d0287a4 <pk_alloc>
 d02a244:	e0bffb15 	stw	r2,-20(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02a248:	01000084 	movi	r4,2
 d02a24c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      if (!pkt)
 d02a250:	e0bffb17 	ldw	r2,-20(fp)
 d02a254:	1004c03a 	cmpne	r2,r2,zero
 d02a258:	1000021e 	bne	r2,zero,d02a264 <m_getnbuf+0x7c>
         return NULL;
 d02a25c:	e03fff15 	stw	zero,-4(fp)
 d02a260:	00004506 	br	d02a378 <m_getnbuf+0x190>
   }

   m = (struct mbuf *)getq(&mfreeq);
 d02a264:	010341b4 	movhi	r4,3334
 d02a268:	2133fb04 	addi	r4,r4,-12308
 d02a26c:	d028cb00 	call	d028cb0 <getq>
 d02a270:	e0bffc15 	stw	r2,-16(fp)
   if (!m)
 d02a274:	e0bffc17 	ldw	r2,-16(fp)
 d02a278:	1004c03a 	cmpne	r2,r2,zero
 d02a27c:	10000b1e 	bne	r2,zero,d02a2ac <m_getnbuf+0xc4>
   {
      if (pkt) 
 d02a280:	e0bffb17 	ldw	r2,-20(fp)
 d02a284:	1005003a 	cmpeq	r2,r2,zero
 d02a288:	1000061e 	bne	r2,zero,d02a2a4 <m_getnbuf+0xbc>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d02a28c:	01000084 	movi	r4,2
 d02a290:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 d02a294:	e13ffb17 	ldw	r4,-20(fp)
 d02a298:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02a29c:	01000084 	movi	r4,2
 d02a2a0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 d02a2a4:	e03fff15 	stw	zero,-4(fp)
 d02a2a8:	00003306 	br	d02a378 <m_getnbuf+0x190>
   }
   m->m_type = type;
 d02a2ac:	e0fffc17 	ldw	r3,-16(fp)
 d02a2b0:	e0bffd17 	ldw	r2,-12(fp)
 d02a2b4:	18800815 	stw	r2,32(r3)
   if (len == 0)
 d02a2b8:	e0bffe17 	ldw	r2,-8(fp)
 d02a2bc:	1004c03a 	cmpne	r2,r2,zero
 d02a2c0:	1000071e 	bne	r2,zero,d02a2e0 <m_getnbuf+0xf8>
   {
      m->pkt = NULL;
 d02a2c4:	e0bffc17 	ldw	r2,-16(fp)
 d02a2c8:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 d02a2cc:	e0bffc17 	ldw	r2,-16(fp)
 d02a2d0:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 d02a2d4:	e0bffc17 	ldw	r2,-16(fp)
 d02a2d8:	10000515 	stw	zero,20(r2)
 d02a2dc:	00001506 	br	d02a334 <m_getnbuf+0x14c>
   }
   else
   {
      m->pkt = pkt;
 d02a2e0:	e0fffc17 	ldw	r3,-16(fp)
 d02a2e4:	e0bffb17 	ldw	r2,-20(fp)
 d02a2e8:	18800115 	stw	r2,4(r3)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 d02a2ec:	e0bffb17 	ldw	r2,-20(fp)
 d02a2f0:	10800117 	ldw	r2,4(r2)
 d02a2f4:	10c00e04 	addi	r3,r2,56
 d02a2f8:	e0bffb17 	ldw	r2,-20(fp)
 d02a2fc:	10c00315 	stw	r3,12(r2)
 d02a300:	e0bffb17 	ldw	r2,-20(fp)
 d02a304:	10c00317 	ldw	r3,12(r2)
 d02a308:	e0bffc17 	ldw	r2,-16(fp)
 d02a30c:	10c00315 	stw	r3,12(r2)
 d02a310:	e0bffc17 	ldw	r2,-16(fp)
 d02a314:	10c00317 	ldw	r3,12(r2)
 d02a318:	e0bffc17 	ldw	r2,-16(fp)
 d02a31c:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 d02a320:	e0bffb17 	ldw	r2,-20(fp)
 d02a324:	10800217 	ldw	r2,8(r2)
 d02a328:	10fff204 	addi	r3,r2,-56
 d02a32c:	e0bffc17 	ldw	r2,-16(fp)
 d02a330:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 d02a334:	e0bffc17 	ldw	r2,-16(fp)
 d02a338:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 d02a33c:	e0bffc17 	ldw	r2,-16(fp)
 d02a340:	10000715 	stw	zero,28(r2)
 d02a344:	e0bffc17 	ldw	r2,-16(fp)
 d02a348:	10c00717 	ldw	r3,28(r2)
 d02a34c:	e0bffc17 	ldw	r2,-16(fp)
 d02a350:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 d02a354:	d0a0ae17 	ldw	r2,-32072(gp)
 d02a358:	10800044 	addi	r2,r2,1
 d02a35c:	d0a0ae15 	stw	r2,-32072(gp)
   putq(&mbufq, (qp)m);
 d02a360:	e17ffc17 	ldw	r5,-16(fp)
 d02a364:	010341b4 	movhi	r4,3334
 d02a368:	2133f604 	addi	r4,r4,-12328
 d02a36c:	d028d780 	call	d028d78 <putq>
   return m;
 d02a370:	e0bffc17 	ldw	r2,-16(fp)
 d02a374:	e0bfff15 	stw	r2,-4(fp)
 d02a378:	e0bfff17 	ldw	r2,-4(fp)
}
 d02a37c:	e037883a 	mov	sp,fp
 d02a380:	dfc00117 	ldw	ra,4(sp)
 d02a384:	df000017 	ldw	fp,0(sp)
 d02a388:	dec00204 	addi	sp,sp,8
 d02a38c:	f800283a 	ret

0d02a390 <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 d02a390:	defffb04 	addi	sp,sp,-20
 d02a394:	dfc00415 	stw	ra,16(sp)
 d02a398:	df000315 	stw	fp,12(sp)
 d02a39c:	df000304 	addi	fp,sp,12
 d02a3a0:	e13ffe15 	stw	r4,-8(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 d02a3a4:	008341b4 	movhi	r2,3334
 d02a3a8:	10b3f604 	addi	r2,r2,-12328
 d02a3ac:	10800217 	ldw	r2,8(r2)
 d02a3b0:	10800048 	cmpgei	r2,r2,1
 d02a3b4:	1000031e 	bne	r2,zero,d02a3c4 <m_free+0x34>
      panic("mfree: q_len");
 d02a3b8:	01034174 	movhi	r4,3333
 d02a3bc:	213dc004 	addi	r4,r4,-2304
 d02a3c0:	d0246440 	call	d024644 <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 d02a3c4:	e0bffe17 	ldw	r2,-8(fp)
 d02a3c8:	10800817 	ldw	r2,32(r2)
 d02a3cc:	10800050 	cmplti	r2,r2,1
 d02a3d0:	1000041e 	bne	r2,zero,d02a3e4 <m_free+0x54>
 d02a3d4:	e0bffe17 	ldw	r2,-8(fp)
 d02a3d8:	10800817 	ldw	r2,32(r2)
 d02a3dc:	10800390 	cmplti	r2,r2,14
 d02a3e0:	10000c1e 	bne	r2,zero,d02a414 <m_free+0x84>
   {
      if (m->m_type == MT_FREE)
 d02a3e4:	e0bffe17 	ldw	r2,-8(fp)
 d02a3e8:	10800817 	ldw	r2,32(r2)
 d02a3ec:	1004c03a 	cmpne	r2,r2,zero
 d02a3f0:	1000051e 	bne	r2,zero,d02a408 <m_free+0x78>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 d02a3f4:	d0293e80 	call	d0293e8 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 d02a3f8:	e0bffe17 	ldw	r2,-8(fp)
 d02a3fc:	10800617 	ldw	r2,24(r2)
 d02a400:	e0bfff15 	stw	r2,-4(fp)
 d02a404:	00002906 	br	d02a4ac <m_free+0x11c>
      }
      else
         panic("m_free: type");
 d02a408:	01034174 	movhi	r4,3333
 d02a40c:	213dc404 	addi	r4,r4,-2288
 d02a410:	d0246440 	call	d024644 <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 d02a414:	e0bffe17 	ldw	r2,-8(fp)
 d02a418:	10800617 	ldw	r2,24(r2)
 d02a41c:	e0bffd15 	stw	r2,-12(fp)

   if (qdel(&mbufq, m) == NULL)
 d02a420:	010341b4 	movhi	r4,3334
 d02a424:	2133f604 	addi	r4,r4,-12328
 d02a428:	e17ffe17 	ldw	r5,-8(fp)
 d02a42c:	d028e280 	call	d028e28 <qdel>
 d02a430:	1004c03a 	cmpne	r2,r2,zero
 d02a434:	1000031e 	bne	r2,zero,d02a444 <m_free+0xb4>
      panic("m_free: missing");
 d02a438:	01034174 	movhi	r4,3333
 d02a43c:	213dc804 	addi	r4,r4,-2272
 d02a440:	d0246440 	call	d024644 <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 d02a444:	e0bffe17 	ldw	r2,-8(fp)
 d02a448:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 d02a44c:	e0bffe17 	ldw	r2,-8(fp)
 d02a450:	10800117 	ldw	r2,4(r2)
 d02a454:	1005003a 	cmpeq	r2,r2,zero
 d02a458:	1000071e 	bne	r2,zero,d02a478 <m_free+0xe8>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d02a45c:	01000084 	movi	r4,2
 d02a460:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 d02a464:	e0bffe17 	ldw	r2,-8(fp)
 d02a468:	11000117 	ldw	r4,4(r2)
 d02a46c:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02a470:	01000084 	movi	r4,2
 d02a474:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 d02a478:	00834174 	movhi	r2,3333
 d02a47c:	108ad004 	addi	r2,r2,11072
 d02a480:	10800017 	ldw	r2,0(r2)
 d02a484:	10c00044 	addi	r3,r2,1
 d02a488:	00834174 	movhi	r2,3333
 d02a48c:	108ad004 	addi	r2,r2,11072
 d02a490:	10c00015 	stw	r3,0(r2)
   putq(&mfreeq, (qp)m);
 d02a494:	e17ffe17 	ldw	r5,-8(fp)
 d02a498:	010341b4 	movhi	r4,3334
 d02a49c:	2133fb04 	addi	r4,r4,-12308
 d02a4a0:	d028d780 	call	d028d78 <putq>
   return nextptr;
 d02a4a4:	e0bffd17 	ldw	r2,-12(fp)
 d02a4a8:	e0bfff15 	stw	r2,-4(fp)
 d02a4ac:	e0bfff17 	ldw	r2,-4(fp)
}
 d02a4b0:	e037883a 	mov	sp,fp
 d02a4b4:	dfc00117 	ldw	ra,4(sp)
 d02a4b8:	df000017 	ldw	fp,0(sp)
 d02a4bc:	dec00204 	addi	sp,sp,8
 d02a4c0:	f800283a 	ret

0d02a4c4 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 d02a4c4:	defffd04 	addi	sp,sp,-12
 d02a4c8:	dfc00215 	stw	ra,8(sp)
 d02a4cc:	df000115 	stw	fp,4(sp)
 d02a4d0:	df000104 	addi	fp,sp,4
 d02a4d4:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 d02a4d8:	00000306 	br	d02a4e8 <m_freem+0x24>
      m = m_free(m);
 d02a4dc:	e13fff17 	ldw	r4,-4(fp)
 d02a4e0:	d02a3900 	call	d02a390 <m_free>
 d02a4e4:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 d02a4e8:	e0bfff17 	ldw	r2,-4(fp)
 d02a4ec:	1004c03a 	cmpne	r2,r2,zero
 d02a4f0:	103ffa1e 	bne	r2,zero,d02a4dc <m_freem+0x18>
      m = m_free(m);
}
 d02a4f4:	e037883a 	mov	sp,fp
 d02a4f8:	dfc00117 	ldw	ra,4(sp)
 d02a4fc:	df000017 	ldw	fp,0(sp)
 d02a500:	dec00204 	addi	sp,sp,8
 d02a504:	f800283a 	ret

0d02a508 <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 d02a508:	defff404 	addi	sp,sp,-48
 d02a50c:	dfc00b15 	stw	ra,44(sp)
 d02a510:	df000a15 	stw	fp,40(sp)
 d02a514:	df000a04 	addi	fp,sp,40
 d02a518:	e13ffa15 	stw	r4,-24(fp)
 d02a51c:	e17ffb15 	stw	r5,-20(fp)
 d02a520:	e1bffc15 	stw	r6,-16(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 d02a524:	e0bffc17 	ldw	r2,-16(fp)
 d02a528:	1004c03a 	cmpne	r2,r2,zero
 d02a52c:	1000021e 	bne	r2,zero,d02a538 <m_copy+0x30>
      return NULL;
 d02a530:	e03ffd15 	stw	zero,-12(fp)
 d02a534:	0000b706 	br	d02a814 <m_copy+0x30c>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 d02a538:	e0bffb17 	ldw	r2,-20(fp)
 d02a53c:	1004803a 	cmplt	r2,r2,zero
 d02a540:	1000061e 	bne	r2,zero,d02a55c <m_copy+0x54>
 d02a544:	e0bffc17 	ldw	r2,-16(fp)
 d02a548:	1004403a 	cmpge	r2,r2,zero
 d02a54c:	1000191e 	bne	r2,zero,d02a5b4 <m_copy+0xac>
 d02a550:	e0bffc17 	ldw	r2,-16(fp)
 d02a554:	10bfffe0 	cmpeqi	r2,r2,-1
 d02a558:	1000161e 	bne	r2,zero,d02a5b4 <m_copy+0xac>
   {
      dtrap();
 d02a55c:	d0293e80 	call	d0293e8 <dtrap>
      return NULL;
 d02a560:	e03ffd15 	stw	zero,-12(fp)
 d02a564:	0000ab06 	br	d02a814 <m_copy+0x30c>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 d02a568:	e0bffa17 	ldw	r2,-24(fp)
 d02a56c:	1004c03a 	cmpne	r2,r2,zero
 d02a570:	1000031e 	bne	r2,zero,d02a580 <m_copy+0x78>
      {
         dtrap();
 d02a574:	d0293e80 	call	d0293e8 <dtrap>
         return NULL;
 d02a578:	e03ffd15 	stw	zero,-12(fp)
 d02a57c:	0000a506 	br	d02a814 <m_copy+0x30c>
      }
      if (off < (int)m->m_len)
 d02a580:	e0bffa17 	ldw	r2,-24(fp)
 d02a584:	10800217 	ldw	r2,8(r2)
 d02a588:	1007883a 	mov	r3,r2
 d02a58c:	e0bffb17 	ldw	r2,-20(fp)
 d02a590:	10c00b16 	blt	r2,r3,d02a5c0 <m_copy+0xb8>
         break;
      off -= m->m_len;
 d02a594:	e0fffb17 	ldw	r3,-20(fp)
 d02a598:	e0bffa17 	ldw	r2,-24(fp)
 d02a59c:	10800217 	ldw	r2,8(r2)
 d02a5a0:	1885c83a 	sub	r2,r3,r2
 d02a5a4:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 d02a5a8:	e0bffa17 	ldw	r2,-24(fp)
 d02a5ac:	10800617 	ldw	r2,24(r2)
 d02a5b0:	e0bffa15 	stw	r2,-24(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 d02a5b4:	e0bffb17 	ldw	r2,-20(fp)
 d02a5b8:	10800048 	cmpgei	r2,r2,1
 d02a5bc:	103fea1e 	bne	r2,zero,d02a568 <m_copy+0x60>
         break;
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 d02a5c0:	e03ff715 	stw	zero,-36(fp)
 d02a5c4:	e0bff717 	ldw	r2,-36(fp)
 d02a5c8:	e0bff815 	stw	r2,-32(fp)

   while (len > 0)
 d02a5cc:	00008806 	br	d02a7f0 <m_copy+0x2e8>
   {
      if (m == NULL) /* at end of queue? */
 d02a5d0:	e0bffa17 	ldw	r2,-24(fp)
 d02a5d4:	1004c03a 	cmpne	r2,r2,zero
 d02a5d8:	1000051e 	bne	r2,zero,d02a5f0 <m_copy+0xe8>
      {
         panic("m_copy: bad len");
 d02a5dc:	01034174 	movhi	r4,3333
 d02a5e0:	213dcc04 	addi	r4,r4,-2256
 d02a5e4:	d0246440 	call	d024644 <panic>
         return NULL;
 d02a5e8:	e03ffd15 	stw	zero,-12(fp)
 d02a5ec:	00008906 	br	d02a814 <m_copy+0x30c>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 d02a5f0:	e0bffa17 	ldw	r2,-24(fp)
 d02a5f4:	10c00217 	ldw	r3,8(r2)
 d02a5f8:	e0bffb17 	ldw	r2,-20(fp)
 d02a5fc:	1885c83a 	sub	r2,r3,r2
 d02a600:	e0fffc17 	ldw	r3,-16(fp)
 d02a604:	e0ffff15 	stw	r3,-4(fp)
 d02a608:	e0bffe15 	stw	r2,-8(fp)
 d02a60c:	e0bfff17 	ldw	r2,-4(fp)
 d02a610:	e0fffe17 	ldw	r3,-8(fp)
 d02a614:	10c0020e 	bge	r2,r3,d02a620 <m_copy+0x118>
 d02a618:	e0bfff17 	ldw	r2,-4(fp)
 d02a61c:	e0bffe15 	stw	r2,-8(fp)
 d02a620:	e0fffe17 	ldw	r3,-8(fp)
 d02a624:	e0fff615 	stw	r3,-40(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 d02a628:	e0bffb17 	ldw	r2,-20(fp)
 d02a62c:	108000cc 	andi	r2,r2,3
 d02a630:	1004c03a 	cmpne	r2,r2,zero
 d02a634:	1000051e 	bne	r2,zero,d02a64c <m_copy+0x144>
 d02a638:	e0bffa17 	ldw	r2,-24(fp)
 d02a63c:	10800117 	ldw	r2,4(r2)
 d02a640:	10800917 	ldw	r2,36(r2)
 d02a644:	10800060 	cmpeqi	r2,r2,1
 d02a648:	1000251e 	bne	r2,zero,d02a6e0 <m_copy+0x1d8>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 d02a64c:	e0bffa17 	ldw	r2,-24(fp)
 d02a650:	11000817 	ldw	r4,32(r2)
 d02a654:	e17ff617 	ldw	r5,-40(fp)
 d02a658:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02a65c:	e0bff915 	stw	r2,-28(fp)
 d02a660:	e0bff917 	ldw	r2,-28(fp)
 d02a664:	1005003a 	cmpeq	r2,r2,zero
 d02a668:	1000671e 	bne	r2,zero,d02a808 <m_copy+0x300>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 d02a66c:	e0bff917 	ldw	r2,-28(fp)
 d02a670:	11000317 	ldw	r4,12(r2)
 d02a674:	e0bffa17 	ldw	r2,-24(fp)
 d02a678:	10c00317 	ldw	r3,12(r2)
 d02a67c:	e0bffb17 	ldw	r2,-20(fp)
 d02a680:	1885883a 	add	r2,r3,r2
 d02a684:	e0fff617 	ldw	r3,-40(fp)
 d02a688:	100b883a 	mov	r5,r2
 d02a68c:	180d883a 	mov	r6,r3
 d02a690:	d0027000 	call	d002700 <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 d02a694:	e0fff617 	ldw	r3,-40(fp)
 d02a698:	e0bff917 	ldw	r2,-28(fp)
 d02a69c:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 d02a6a0:	008341b4 	movhi	r2,3334
 d02a6a4:	10b41504 	addi	r2,r2,-12204
 d02a6a8:	10802e17 	ldw	r2,184(r2)
 d02a6ac:	10c00044 	addi	r3,r2,1
 d02a6b0:	008341b4 	movhi	r2,3334
 d02a6b4:	10b41504 	addi	r2,r2,-12204
 d02a6b8:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 d02a6bc:	008341b4 	movhi	r2,3334
 d02a6c0:	10b41504 	addi	r2,r2,-12204
 d02a6c4:	10c03017 	ldw	r3,192(r2)
 d02a6c8:	e0bff617 	ldw	r2,-40(fp)
 d02a6cc:	1887883a 	add	r3,r3,r2
 d02a6d0:	008341b4 	movhi	r2,3334
 d02a6d4:	10b41504 	addi	r2,r2,-12204
 d02a6d8:	10c03015 	stw	r3,192(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 d02a6dc:	00003106 	br	d02a7a4 <m_copy+0x29c>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 d02a6e0:	e0bffa17 	ldw	r2,-24(fp)
 d02a6e4:	11000817 	ldw	r4,32(r2)
 d02a6e8:	000b883a 	mov	r5,zero
 d02a6ec:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02a6f0:	e0bff915 	stw	r2,-28(fp)
 d02a6f4:	e0bff917 	ldw	r2,-28(fp)
 d02a6f8:	1005003a 	cmpeq	r2,r2,zero
 d02a6fc:	1000421e 	bne	r2,zero,d02a808 <m_copy+0x300>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 d02a700:	e0bffa17 	ldw	r2,-24(fp)
 d02a704:	10c00117 	ldw	r3,4(r2)
 d02a708:	18800917 	ldw	r2,36(r3)
 d02a70c:	10800044 	addi	r2,r2,1
 d02a710:	18800915 	stw	r2,36(r3)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 d02a714:	e0bffa17 	ldw	r2,-24(fp)
 d02a718:	10c00117 	ldw	r3,4(r2)
 d02a71c:	e0bff917 	ldw	r2,-28(fp)
 d02a720:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 d02a724:	e0bffa17 	ldw	r2,-24(fp)
 d02a728:	10c00417 	ldw	r3,16(r2)
 d02a72c:	e0bff917 	ldw	r2,-28(fp)
 d02a730:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 d02a734:	e0bffa17 	ldw	r2,-24(fp)
 d02a738:	10c00517 	ldw	r3,20(r2)
 d02a73c:	e0bff917 	ldw	r2,-28(fp)
 d02a740:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 d02a744:	e0bffa17 	ldw	r2,-24(fp)
 d02a748:	10c00317 	ldw	r3,12(r2)
 d02a74c:	e0bffb17 	ldw	r2,-20(fp)
 d02a750:	1887883a 	add	r3,r3,r2
 d02a754:	e0bff917 	ldw	r2,-28(fp)
 d02a758:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 d02a75c:	e0fff617 	ldw	r3,-40(fp)
 d02a760:	e0bff917 	ldw	r2,-28(fp)
 d02a764:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 d02a768:	008341b4 	movhi	r2,3334
 d02a76c:	10b41504 	addi	r2,r2,-12204
 d02a770:	10802f17 	ldw	r2,188(r2)
 d02a774:	10c00044 	addi	r3,r2,1
 d02a778:	008341b4 	movhi	r2,3334
 d02a77c:	10b41504 	addi	r2,r2,-12204
 d02a780:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 d02a784:	008341b4 	movhi	r2,3334
 d02a788:	10b41504 	addi	r2,r2,-12204
 d02a78c:	10c03117 	ldw	r3,196(r2)
 d02a790:	e0bff617 	ldw	r2,-40(fp)
 d02a794:	1887883a 	add	r3,r3,r2
 d02a798:	008341b4 	movhi	r2,3334
 d02a79c:	10b41504 	addi	r2,r2,-12204
 d02a7a0:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 d02a7a4:	e0fffc17 	ldw	r3,-16(fp)
 d02a7a8:	e0bff617 	ldw	r2,-40(fp)
 d02a7ac:	1885c83a 	sub	r2,r3,r2
 d02a7b0:	e0bffc15 	stw	r2,-16(fp)
      off = 0;
 d02a7b4:	e03ffb15 	stw	zero,-20(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 d02a7b8:	e0bff717 	ldw	r2,-36(fp)
 d02a7bc:	1005003a 	cmpeq	r2,r2,zero
 d02a7c0:	1000041e 	bne	r2,zero,d02a7d4 <m_copy+0x2cc>
         tail->m_next = nb;
 d02a7c4:	e0fff717 	ldw	r3,-36(fp)
 d02a7c8:	e0bff917 	ldw	r2,-28(fp)
 d02a7cc:	18800615 	stw	r2,24(r3)
 d02a7d0:	00000206 	br	d02a7dc <m_copy+0x2d4>
      else
         head = nb;
 d02a7d4:	e0bff917 	ldw	r2,-28(fp)
 d02a7d8:	e0bff815 	stw	r2,-32(fp)
      tail = nb;     /* always make new mbuf the tail */
 d02a7dc:	e0bff917 	ldw	r2,-28(fp)
 d02a7e0:	e0bff715 	stw	r2,-36(fp)
      m = m->m_next;
 d02a7e4:	e0bffa17 	ldw	r2,-24(fp)
 d02a7e8:	10800617 	ldw	r2,24(r2)
 d02a7ec:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 d02a7f0:	e0bffc17 	ldw	r2,-16(fp)
 d02a7f4:	10800048 	cmpgei	r2,r2,1
 d02a7f8:	103f751e 	bne	r2,zero,d02a5d0 <m_copy+0xc8>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 d02a7fc:	e0bff817 	ldw	r2,-32(fp)
 d02a800:	e0bffd15 	stw	r2,-12(fp)
 d02a804:	00000306 	br	d02a814 <m_copy+0x30c>

nospace:
   m_freem (head);
 d02a808:	e13ff817 	ldw	r4,-32(fp)
 d02a80c:	d02a4c40 	call	d02a4c4 <m_freem>
   return NULL;
 d02a810:	e03ffd15 	stw	zero,-12(fp)
 d02a814:	e0bffd17 	ldw	r2,-12(fp)
}
 d02a818:	e037883a 	mov	sp,fp
 d02a81c:	dfc00117 	ldw	ra,4(sp)
 d02a820:	df000017 	ldw	fp,0(sp)
 d02a824:	dec00204 	addi	sp,sp,8
 d02a828:	f800283a 	ret

0d02a82c <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 d02a82c:	defffb04 	addi	sp,sp,-20
 d02a830:	df000415 	stw	fp,16(sp)
 d02a834:	df000404 	addi	fp,sp,16
 d02a838:	e13ffe15 	stw	r4,-8(fp)
 d02a83c:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 d02a840:	e0bffe17 	ldw	r2,-8(fp)
 d02a844:	e0bffd15 	stw	r2,-12(fp)
 d02a848:	e0bffd17 	ldw	r2,-12(fp)
 d02a84c:	1005003a 	cmpeq	r2,r2,zero
 d02a850:	1000661e 	bne	r2,zero,d02a9ec <m_adj+0x1c0>
      return;

   if (len >= 0) 
 d02a854:	e0bfff17 	ldw	r2,-4(fp)
 d02a858:	1004803a 	cmplt	r2,r2,zero
 d02a85c:	1000241e 	bne	r2,zero,d02a8f0 <m_adj+0xc4>
   {
      while (m != NULL && len > 0) 
 d02a860:	00001c06 	br	d02a8d4 <m_adj+0xa8>
      {
         if (m->m_len <= (unsigned)len)
 d02a864:	e0bffd17 	ldw	r2,-12(fp)
 d02a868:	10c00217 	ldw	r3,8(r2)
 d02a86c:	e0bfff17 	ldw	r2,-4(fp)
 d02a870:	10c00b36 	bltu	r2,r3,d02a8a0 <m_adj+0x74>
         {
            len -= m->m_len;
 d02a874:	e0ffff17 	ldw	r3,-4(fp)
 d02a878:	e0bffd17 	ldw	r2,-12(fp)
 d02a87c:	10800217 	ldw	r2,8(r2)
 d02a880:	1885c83a 	sub	r2,r3,r2
 d02a884:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 d02a888:	e0bffd17 	ldw	r2,-12(fp)
 d02a88c:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 d02a890:	e0bffd17 	ldw	r2,-12(fp)
 d02a894:	10800617 	ldw	r2,24(r2)
 d02a898:	e0bffd15 	stw	r2,-12(fp)
 d02a89c:	00000d06 	br	d02a8d4 <m_adj+0xa8>
         }
         else
         {
            m->m_len -= len;
 d02a8a0:	e0bffd17 	ldw	r2,-12(fp)
 d02a8a4:	10c00217 	ldw	r3,8(r2)
 d02a8a8:	e0bfff17 	ldw	r2,-4(fp)
 d02a8ac:	1887c83a 	sub	r3,r3,r2
 d02a8b0:	e0bffd17 	ldw	r2,-12(fp)
 d02a8b4:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 d02a8b8:	e0bffd17 	ldw	r2,-12(fp)
 d02a8bc:	10c00317 	ldw	r3,12(r2)
 d02a8c0:	e0bfff17 	ldw	r2,-4(fp)
 d02a8c4:	1887883a 	add	r3,r3,r2
 d02a8c8:	e0bffd17 	ldw	r2,-12(fp)
 d02a8cc:	10c00315 	stw	r3,12(r2)
            break;
 d02a8d0:	00004606 	br	d02a9ec <m_adj+0x1c0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 d02a8d4:	e0bffd17 	ldw	r2,-12(fp)
 d02a8d8:	1005003a 	cmpeq	r2,r2,zero
 d02a8dc:	1000431e 	bne	r2,zero,d02a9ec <m_adj+0x1c0>
 d02a8e0:	e0bfff17 	ldw	r2,-4(fp)
 d02a8e4:	10800048 	cmpgei	r2,r2,1
 d02a8e8:	103fde1e 	bne	r2,zero,d02a864 <m_adj+0x38>
 d02a8ec:	00003f06 	br	d02a9ec <m_adj+0x1c0>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 d02a8f0:	e0bfff17 	ldw	r2,-4(fp)
 d02a8f4:	0085c83a 	sub	r2,zero,r2
 d02a8f8:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 d02a8fc:	e03ffc15 	stw	zero,-16(fp)
      for (;;) 
      {
         count += m->m_len;
 d02a900:	e0bffd17 	ldw	r2,-12(fp)
 d02a904:	10c00217 	ldw	r3,8(r2)
 d02a908:	e0bffc17 	ldw	r2,-16(fp)
 d02a90c:	1885883a 	add	r2,r3,r2
 d02a910:	e0bffc15 	stw	r2,-16(fp)
         if (m->m_next == (struct mbuf *)0)
 d02a914:	e0bffd17 	ldw	r2,-12(fp)
 d02a918:	10800617 	ldw	r2,24(r2)
 d02a91c:	1005003a 	cmpeq	r2,r2,zero
 d02a920:	1000041e 	bne	r2,zero,d02a934 <m_adj+0x108>
            break;
         m = m->m_next;
 d02a924:	e0bffd17 	ldw	r2,-12(fp)
 d02a928:	10800617 	ldw	r2,24(r2)
 d02a92c:	e0bffd15 	stw	r2,-12(fp)
      }
 d02a930:	003ff306 	br	d02a900 <m_adj+0xd4>
      if (m->m_len >= (unsigned)len)
 d02a934:	e0bffd17 	ldw	r2,-12(fp)
 d02a938:	10c00217 	ldw	r3,8(r2)
 d02a93c:	e0bfff17 	ldw	r2,-4(fp)
 d02a940:	18800736 	bltu	r3,r2,d02a960 <m_adj+0x134>
      {
         m->m_len -= len;
 d02a944:	e0bffd17 	ldw	r2,-12(fp)
 d02a948:	10c00217 	ldw	r3,8(r2)
 d02a94c:	e0bfff17 	ldw	r2,-4(fp)
 d02a950:	1887c83a 	sub	r3,r3,r2
 d02a954:	e0bffd17 	ldw	r2,-12(fp)
 d02a958:	10c00215 	stw	r3,8(r2)
         return;
 d02a95c:	00002306 	br	d02a9ec <m_adj+0x1c0>
      }
      count -= len;
 d02a960:	e0fffc17 	ldw	r3,-16(fp)
 d02a964:	e0bfff17 	ldw	r2,-4(fp)
 d02a968:	1885c83a 	sub	r2,r3,r2
 d02a96c:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 d02a970:	e0bffe17 	ldw	r2,-8(fp)
 d02a974:	e0bffd15 	stw	r2,-12(fp)
 d02a978:	00001006 	br	d02a9bc <m_adj+0x190>
      {
         if (m->m_len >= (unsigned)count)
 d02a97c:	e0bffd17 	ldw	r2,-12(fp)
 d02a980:	10c00217 	ldw	r3,8(r2)
 d02a984:	e0bffc17 	ldw	r2,-16(fp)
 d02a988:	18800436 	bltu	r3,r2,d02a99c <m_adj+0x170>
         {
            m->m_len = count;
 d02a98c:	e0fffc17 	ldw	r3,-16(fp)
 d02a990:	e0bffd17 	ldw	r2,-12(fp)
 d02a994:	10c00215 	stw	r3,8(r2)
            break;
 d02a998:	00000e06 	br	d02a9d4 <m_adj+0x1a8>
         }
         count -= m->m_len;
 d02a99c:	e0fffc17 	ldw	r3,-16(fp)
 d02a9a0:	e0bffd17 	ldw	r2,-12(fp)
 d02a9a4:	10800217 	ldw	r2,8(r2)
 d02a9a8:	1885c83a 	sub	r2,r3,r2
 d02a9ac:	e0bffc15 	stw	r2,-16(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 d02a9b0:	e0bffd17 	ldw	r2,-12(fp)
 d02a9b4:	10800617 	ldw	r2,24(r2)
 d02a9b8:	e0bffd15 	stw	r2,-12(fp)
 d02a9bc:	e0bffd17 	ldw	r2,-12(fp)
 d02a9c0:	1004c03a 	cmpne	r2,r2,zero
 d02a9c4:	103fed1e 	bne	r2,zero,d02a97c <m_adj+0x150>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 d02a9c8:	00000206 	br	d02a9d4 <m_adj+0x1a8>
         m->m_len = 0;
 d02a9cc:	e0bffd17 	ldw	r2,-12(fp)
 d02a9d0:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 d02a9d4:	e0bffd17 	ldw	r2,-12(fp)
 d02a9d8:	10800617 	ldw	r2,24(r2)
 d02a9dc:	e0bffd15 	stw	r2,-12(fp)
 d02a9e0:	e0bffd17 	ldw	r2,-12(fp)
 d02a9e4:	1004c03a 	cmpne	r2,r2,zero
 d02a9e8:	103ff81e 	bne	r2,zero,d02a9cc <m_adj+0x1a0>
         m->m_len = 0;
   }
}
 d02a9ec:	e037883a 	mov	sp,fp
 d02a9f0:	df000017 	ldw	fp,0(sp)
 d02a9f4:	dec00104 	addi	sp,sp,4
 d02a9f8:	f800283a 	ret

0d02a9fc <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 d02a9fc:	defffd04 	addi	sp,sp,-12
 d02aa00:	df000215 	stw	fp,8(sp)
 d02aa04:	df000204 	addi	fp,sp,8
 d02aa08:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 d02aa0c:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 d02aa10:	00000806 	br	d02aa34 <mbuf_len+0x38>
   {
      len += m->m_len;
 d02aa14:	e0bfff17 	ldw	r2,-4(fp)
 d02aa18:	10c00217 	ldw	r3,8(r2)
 d02aa1c:	e0bffe17 	ldw	r2,-8(fp)
 d02aa20:	1885883a 	add	r2,r3,r2
 d02aa24:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 d02aa28:	e0bfff17 	ldw	r2,-4(fp)
 d02aa2c:	10800617 	ldw	r2,24(r2)
 d02aa30:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 d02aa34:	e0bfff17 	ldw	r2,-4(fp)
 d02aa38:	1004c03a 	cmpne	r2,r2,zero
 d02aa3c:	103ff51e 	bne	r2,zero,d02aa14 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 d02aa40:	e0bffe17 	ldw	r2,-8(fp)
}
 d02aa44:	e037883a 	mov	sp,fp
 d02aa48:	df000017 	ldw	fp,0(sp)
 d02aa4c:	dec00104 	addi	sp,sp,4
 d02aa50:	f800283a 	ret

0d02aa54 <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 d02aa54:	defffa04 	addi	sp,sp,-24
 d02aa58:	dfc00515 	stw	ra,20(sp)
 d02aa5c:	df000415 	stw	fp,16(sp)
 d02aa60:	df000404 	addi	fp,sp,16
 d02aa64:	e13ffe15 	stw	r4,-8(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 d02aa68:	008341b4 	movhi	r2,3334
 d02aa6c:	10b3f604 	addi	r2,r2,-12328
 d02aa70:	10800017 	ldw	r2,0(r2)
 d02aa74:	e0bffd15 	stw	r2,-12(fp)
 d02aa78:	00001306 	br	d02aac8 <dtom+0x74>
   {
      m = (struct mbuf *)qptr;
 d02aa7c:	e0bffd17 	ldw	r2,-12(fp)
 d02aa80:	e0bffc15 	stw	r2,-16(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 d02aa84:	e0bffc17 	ldw	r2,-16(fp)
 d02aa88:	10c00417 	ldw	r3,16(r2)
 d02aa8c:	e0bffe17 	ldw	r2,-8(fp)
 d02aa90:	10c00a36 	bltu	r2,r3,d02aabc <dtom+0x68>
 d02aa94:	e0bffc17 	ldw	r2,-16(fp)
 d02aa98:	10c00417 	ldw	r3,16(r2)
 d02aa9c:	e0bffc17 	ldw	r2,-16(fp)
 d02aaa0:	10800517 	ldw	r2,20(r2)
 d02aaa4:	1887883a 	add	r3,r3,r2
 d02aaa8:	e0bffe17 	ldw	r2,-8(fp)
 d02aaac:	10c0032e 	bgeu	r2,r3,d02aabc <dtom+0x68>
         return (struct mbuf *)qptr;
 d02aab0:	e0bffd17 	ldw	r2,-12(fp)
 d02aab4:	e0bfff15 	stw	r2,-4(fp)
 d02aab8:	00000a06 	br	d02aae4 <dtom+0x90>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 d02aabc:	e0bffd17 	ldw	r2,-12(fp)
 d02aac0:	10800017 	ldw	r2,0(r2)
 d02aac4:	e0bffd15 	stw	r2,-12(fp)
 d02aac8:	e0bffd17 	ldw	r2,-12(fp)
 d02aacc:	1004c03a 	cmpne	r2,r2,zero
 d02aad0:	103fea1e 	bne	r2,zero,d02aa7c <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 d02aad4:	01034174 	movhi	r4,3333
 d02aad8:	213dd004 	addi	r4,r4,-2240
 d02aadc:	d0246440 	call	d024644 <panic>
   return NULL;
 d02aae0:	e03fff15 	stw	zero,-4(fp)
 d02aae4:	e0bfff17 	ldw	r2,-4(fp)
}
 d02aae8:	e037883a 	mov	sp,fp
 d02aaec:	dfc00117 	ldw	ra,4(sp)
 d02aaf0:	df000017 	ldw	fp,0(sp)
 d02aaf4:	dec00204 	addi	sp,sp,8
 d02aaf8:	f800283a 	ret

0d02aafc <remque>:
};


void
remque (void * arg)
{
 d02aafc:	defffd04 	addi	sp,sp,-12
 d02ab00:	df000215 	stw	fp,8(sp)
 d02ab04:	df000204 	addi	fp,sp,8
 d02ab08:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 d02ab0c:	e0bfff17 	ldw	r2,-4(fp)
 d02ab10:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 d02ab14:	e0bffe17 	ldw	r2,-8(fp)
 d02ab18:	10800117 	ldw	r2,4(r2)
 d02ab1c:	1005003a 	cmpeq	r2,r2,zero
 d02ab20:	10000e1e 	bne	r2,zero,d02ab5c <remque+0x60>
      old->prev->next = old->next;
 d02ab24:	e0bffe17 	ldw	r2,-8(fp)
 d02ab28:	10c00117 	ldw	r3,4(r2)
 d02ab2c:	e0bffe17 	ldw	r2,-8(fp)
 d02ab30:	10800017 	ldw	r2,0(r2)
 d02ab34:	18800015 	stw	r2,0(r3)
   if (old->next)
 d02ab38:	e0bffe17 	ldw	r2,-8(fp)
 d02ab3c:	10800017 	ldw	r2,0(r2)
 d02ab40:	1005003a 	cmpeq	r2,r2,zero
 d02ab44:	1000051e 	bne	r2,zero,d02ab5c <remque+0x60>
      old->next->prev = old->prev;
 d02ab48:	e0bffe17 	ldw	r2,-8(fp)
 d02ab4c:	10c00017 	ldw	r3,0(r2)
 d02ab50:	e0bffe17 	ldw	r2,-8(fp)
 d02ab54:	10800117 	ldw	r2,4(r2)
 d02ab58:	18800115 	stw	r2,4(r3)
}
 d02ab5c:	e037883a 	mov	sp,fp
 d02ab60:	df000017 	ldw	fp,0(sp)
 d02ab64:	dec00104 	addi	sp,sp,4
 d02ab68:	f800283a 	ret

0d02ab6c <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 d02ab6c:	defffb04 	addi	sp,sp,-20
 d02ab70:	df000415 	stw	fp,16(sp)
 d02ab74:	df000404 	addi	fp,sp,16
 d02ab78:	e13ffe15 	stw	r4,-8(fp)
 d02ab7c:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 d02ab80:	e0bffe17 	ldw	r2,-8(fp)
 d02ab84:	e0bffd15 	stw	r2,-12(fp)
   prev = (struct bsdq *)p;
 d02ab88:	e0bfff17 	ldw	r2,-4(fp)
 d02ab8c:	e0bffc15 	stw	r2,-16(fp)
   newe->next = prev->next;
 d02ab90:	e0bffc17 	ldw	r2,-16(fp)
 d02ab94:	10c00017 	ldw	r3,0(r2)
 d02ab98:	e0bffd17 	ldw	r2,-12(fp)
 d02ab9c:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 d02aba0:	e0fffd17 	ldw	r3,-12(fp)
 d02aba4:	e0bffc17 	ldw	r2,-16(fp)
 d02aba8:	18800115 	stw	r2,4(r3)
   prev->next = newe;
 d02abac:	e0fffc17 	ldw	r3,-16(fp)
 d02abb0:	e0bffd17 	ldw	r2,-12(fp)
 d02abb4:	18800015 	stw	r2,0(r3)
   if (newe->next)
 d02abb8:	e0bffd17 	ldw	r2,-12(fp)
 d02abbc:	10800017 	ldw	r2,0(r2)
 d02abc0:	1005003a 	cmpeq	r2,r2,zero
 d02abc4:	1000041e 	bne	r2,zero,d02abd8 <insque+0x6c>
      newe->next->prev = newe;
 d02abc8:	e0bffd17 	ldw	r2,-12(fp)
 d02abcc:	10c00017 	ldw	r3,0(r2)
 d02abd0:	e0bffd17 	ldw	r2,-12(fp)
 d02abd4:	18800115 	stw	r2,4(r3)
}
 d02abd8:	e037883a 	mov	sp,fp
 d02abdc:	df000017 	ldw	fp,0(sp)
 d02abe0:	dec00104 	addi	sp,sp,4
 d02abe4:	f800283a 	ret

0d02abe8 <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 d02abe8:	defffb04 	addi	sp,sp,-20
 d02abec:	dfc00415 	stw	ra,16(sp)
 d02abf0:	df000315 	stw	fp,12(sp)
 d02abf4:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 d02abf8:	00834174 	movhi	r2,3333
 d02abfc:	108a5704 	addi	r2,r2,10588
 d02ac00:	10c00017 	ldw	r3,0(r2)
 d02ac04:	00834174 	movhi	r2,3333
 d02ac08:	108a5904 	addi	r2,r2,10596
 d02ac0c:	10800017 	ldw	r2,0(r2)
 d02ac10:	1885883a 	add	r2,r3,r2
 d02ac14:	1085883a 	add	r2,r2,r2
 d02ac18:	108000c4 	addi	r2,r2,3
 d02ac1c:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 d02ac20:	008341b4 	movhi	r2,3334
 d02ac24:	10b3e204 	addi	r2,r2,-12408
 d02ac28:	10000015 	stw	zero,0(r2)
 d02ac2c:	10000115 	stw	zero,4(r2)
 d02ac30:	10000215 	stw	zero,8(r2)
 d02ac34:	10000315 	stw	zero,12(r2)
 d02ac38:	10000415 	stw	zero,16(r2)
   MEMSET(&mbufq, 0, sizeof(mbufq));
 d02ac3c:	008341b4 	movhi	r2,3334
 d02ac40:	10b3f604 	addi	r2,r2,-12328
 d02ac44:	10000015 	stw	zero,0(r2)
 d02ac48:	10000115 	stw	zero,4(r2)
 d02ac4c:	10000215 	stw	zero,8(r2)
 d02ac50:	10000315 	stw	zero,12(r2)
 d02ac54:	10000415 	stw	zero,16(r2)
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 d02ac58:	008341b4 	movhi	r2,3334
 d02ac5c:	10b3fb04 	addi	r2,r2,-12308
 d02ac60:	10000015 	stw	zero,0(r2)
 d02ac64:	10000115 	stw	zero,4(r2)
 d02ac68:	10000215 	stw	zero,8(r2)
 d02ac6c:	10000315 	stw	zero,12(r2)
 d02ac70:	10000415 	stw	zero,16(r2)
   for (i = 0; i < (int)bufcount; i++)
 d02ac74:	e03fff15 	stw	zero,-4(fp)
 d02ac78:	00001606 	br	d02acd4 <nptcp_init+0xec>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 d02ac7c:	01000904 	movi	r4,36
 d02ac80:	d029e2c0 	call	d029e2c <npalloc>
 d02ac84:	e0bffd15 	stw	r2,-12(fp)
      if (!m)  /* malloc error, bail out */
 d02ac88:	e0bffd17 	ldw	r2,-12(fp)
 d02ac8c:	1004c03a 	cmpne	r2,r2,zero
 d02ac90:	1000031e 	bne	r2,zero,d02aca0 <nptcp_init+0xb8>
         panic("tcpinit");
 d02ac94:	01034174 	movhi	r4,3333
 d02ac98:	213dd204 	addi	r4,r4,-2232
 d02ac9c:	d0246440 	call	d024644 <panic>
      m->m_type = MT_FREE;
 d02aca0:	e0bffd17 	ldw	r2,-12(fp)
 d02aca4:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 d02aca8:	e0bffd17 	ldw	r2,-12(fp)
 d02acac:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 d02acb0:	e0bffd17 	ldw	r2,-12(fp)
 d02acb4:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 d02acb8:	e17ffd17 	ldw	r5,-12(fp)
 d02acbc:	010341b4 	movhi	r4,3334
 d02acc0:	2133fb04 	addi	r4,r4,-12308
 d02acc4:	d028d780 	call	d028d78 <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 d02acc8:	e0bfff17 	ldw	r2,-4(fp)
 d02accc:	10800044 	addi	r2,r2,1
 d02acd0:	e0bfff15 	stw	r2,-4(fp)
 d02acd4:	e0fffe17 	ldw	r3,-8(fp)
 d02acd8:	e0bfff17 	ldw	r2,-4(fp)
 d02acdc:	10ffe716 	blt	r2,r3,d02ac7c <nptcp_init+0x94>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 d02ace0:	e0fffe17 	ldw	r3,-8(fp)
 d02ace4:	008341b4 	movhi	r2,3334
 d02ace8:	10b3fb04 	addi	r2,r2,-12308
 d02acec:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 d02acf0:	d035f040 	call	d035f04 <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 d02acf4:	0005883a 	mov	r2,zero
}
 d02acf8:	e037883a 	mov	sp,fp
 d02acfc:	dfc00117 	ldw	ra,4(sp)
 d02ad00:	df000017 	ldw	fp,0(sp)
 d02ad04:	dec00204 	addi	sp,sp,8
 d02ad08:	f800283a 	ret

0d02ad0c <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 d02ad0c:	defff804 	addi	sp,sp,-32
 d02ad10:	dfc00715 	stw	ra,28(sp)
 d02ad14:	df000615 	stw	fp,24(sp)
 d02ad18:	df000604 	addi	fp,sp,24
 d02ad1c:	e13ffe15 	stw	r4,-8(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 d02ad20:	e0bffe17 	ldw	r2,-8(fp)
 d02ad24:	10800317 	ldw	r2,12(r2)
 d02ad28:	e0bffc15 	stw	r2,-16(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 d02ad2c:	e0bffc17 	ldw	r2,-16(fp)
 d02ad30:	1080008b 	ldhu	r2,2(r2)
 d02ad34:	10bfffcc 	andi	r2,r2,65535
 d02ad38:	1004d23a 	srli	r2,r2,8
 d02ad3c:	10803fcc 	andi	r2,r2,255
 d02ad40:	1009883a 	mov	r4,r2
 d02ad44:	e0bffc17 	ldw	r2,-16(fp)
 d02ad48:	1080008b 	ldhu	r2,2(r2)
 d02ad4c:	10bfffcc 	andi	r2,r2,65535
 d02ad50:	1004923a 	slli	r2,r2,8
 d02ad54:	1007883a 	mov	r3,r2
 d02ad58:	00bfc004 	movi	r2,-256
 d02ad5c:	1884703a 	and	r2,r3,r2
 d02ad60:	2084b03a 	or	r2,r4,r2
 d02ad64:	e0bffa0d 	sth	r2,-24(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 d02ad68:	e0bffc17 	ldw	r2,-16(fp)
 d02ad6c:	10800003 	ldbu	r2,0(r2)
 d02ad70:	10803fcc 	andi	r2,r2,255
 d02ad74:	108003cc 	andi	r2,r2,15
 d02ad78:	1085883a 	add	r2,r2,r2
 d02ad7c:	1085883a 	add	r2,r2,r2
 d02ad80:	1007883a 	mov	r3,r2
 d02ad84:	e0bffc17 	ldw	r2,-16(fp)
 d02ad88:	1885883a 	add	r2,r3,r2
 d02ad8c:	e0bffb15 	stw	r2,-20(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 d02ad90:	e13ffc17 	ldw	r4,-16(fp)
 d02ad94:	d0460c80 	call	d0460c8 <tcp_cksum>
 d02ad98:	1007883a 	mov	r3,r2
 d02ad9c:	e0bffb17 	ldw	r2,-20(fp)
 d02ada0:	1080040b 	ldhu	r2,16(r2)
 d02ada4:	18ffffcc 	andi	r3,r3,65535
 d02ada8:	10bfffcc 	andi	r2,r2,65535
 d02adac:	18801726 	beq	r3,r2,d02ae0c <tcp_rcv+0x100>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 d02adb0:	008341b4 	movhi	r2,3334
 d02adb4:	10b3e704 	addi	r2,r2,-12388
 d02adb8:	10800d17 	ldw	r2,52(r2)
 d02adbc:	10c00044 	addi	r3,r2,1
 d02adc0:	008341b4 	movhi	r2,3334
 d02adc4:	10b3e704 	addi	r2,r2,-12388
 d02adc8:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 d02adcc:	008341b4 	movhi	r2,3334
 d02add0:	10b41504 	addi	r2,r2,-12204
 d02add4:	10801c17 	ldw	r2,112(r2)
 d02add8:	10c00044 	addi	r3,r2,1
 d02addc:	008341b4 	movhi	r2,3334
 d02ade0:	10b41504 	addi	r2,r2,-12204
 d02ade4:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d02ade8:	01000084 	movi	r4,2
 d02adec:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 d02adf0:	e13ffe17 	ldw	r4,-8(fp)
 d02adf4:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02adf8:	01000084 	movi	r4,2
 d02adfc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 d02ae00:	00bff804 	movi	r2,-32
 d02ae04:	e0bfff15 	stw	r2,-4(fp)
 d02ae08:	00003506 	br	d02aee0 <tcp_rcv+0x1d4>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 d02ae0c:	01000044 	movi	r4,1
 d02ae10:	000b883a 	mov	r5,zero
 d02ae14:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02ae18:	e0bffd15 	stw	r2,-12(fp)
   if (!m_in){
 d02ae1c:	e0bffd17 	ldw	r2,-12(fp)
 d02ae20:	1004c03a 	cmpne	r2,r2,zero
 d02ae24:	1000091e 	bne	r2,zero,d02ae4c <tcp_rcv+0x140>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d02ae28:	01000084 	movi	r4,2
 d02ae2c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d02ae30:	e13ffe17 	ldw	r4,-8(fp)
 d02ae34:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02ae38:	01000084 	movi	r4,2
 d02ae3c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 d02ae40:	00bffa84 	movi	r2,-22
 d02ae44:	e0bfff15 	stw	r2,-4(fp)
 d02ae48:	00002506 	br	d02aee0 <tcp_rcv+0x1d4>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 d02ae4c:	e0bffc17 	ldw	r2,-16(fp)
 d02ae50:	10800003 	ldbu	r2,0(r2)
 d02ae54:	10803fcc 	andi	r2,r2,255
 d02ae58:	108003cc 	andi	r2,r2,15
 d02ae5c:	1085883a 	add	r2,r2,r2
 d02ae60:	1085883a 	add	r2,r2,r2
 d02ae64:	1007883a 	mov	r3,r2
 d02ae68:	e0bffa0b 	ldhu	r2,-24(fp)
 d02ae6c:	10c5c83a 	sub	r2,r2,r3
 d02ae70:	e0bffa0d 	sth	r2,-24(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 d02ae74:	e0fffc17 	ldw	r3,-16(fp)
 d02ae78:	e0bffa0b 	ldhu	r2,-24(fp)
 d02ae7c:	1880008d 	sth	r2,2(r3)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 d02ae80:	e0fffd17 	ldw	r3,-12(fp)
 d02ae84:	e0bffe17 	ldw	r2,-8(fp)
 d02ae88:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 d02ae8c:	e0bffe17 	ldw	r2,-8(fp)
 d02ae90:	10c00317 	ldw	r3,12(r2)
 d02ae94:	e0bffd17 	ldw	r2,-12(fp)
 d02ae98:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 d02ae9c:	e0bffe17 	ldw	r2,-8(fp)
 d02aea0:	10c00417 	ldw	r3,16(r2)
 d02aea4:	e0bffd17 	ldw	r2,-12(fp)
 d02aea8:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 d02aeac:	e0bffe17 	ldw	r2,-8(fp)
 d02aeb0:	10c00117 	ldw	r3,4(r2)
 d02aeb4:	e0bffd17 	ldw	r2,-12(fp)
 d02aeb8:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 d02aebc:	e0bffe17 	ldw	r2,-8(fp)
 d02aec0:	10c00217 	ldw	r3,8(r2)
 d02aec4:	e0bffd17 	ldw	r2,-12(fp)
 d02aec8:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 d02aecc:	e0bffe17 	ldw	r2,-8(fp)
 d02aed0:	11400617 	ldw	r5,24(r2)
 d02aed4:	e13ffd17 	ldw	r4,-12(fp)
 d02aed8:	d031fc40 	call	d031fc4 <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 d02aedc:	e03fff15 	stw	zero,-4(fp)
 d02aee0:	e0bfff17 	ldw	r2,-4(fp)
}
 d02aee4:	e037883a 	mov	sp,fp
 d02aee8:	dfc00117 	ldw	ra,4(sp)
 d02aeec:	df000017 	ldw	fp,0(sp)
 d02aef0:	dec00204 	addi	sp,sp,8
 d02aef4:	f800283a 	ret

0d02aef8 <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 d02aef8:	defff304 	addi	sp,sp,-52
 d02aefc:	dfc00c15 	stw	ra,48(sp)
 d02af00:	df000b15 	stw	fp,44(sp)
 d02af04:	df000b04 	addi	fp,sp,44
 d02af08:	e13ffd15 	stw	r4,-12(fp)
 d02af0c:	e17ffe15 	stw	r5,-8(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 d02af10:	e0bffd17 	ldw	r2,-12(fp)
 d02af14:	10800617 	ldw	r2,24(r2)
 d02af18:	1005003a 	cmpeq	r2,r2,zero
 d02af1c:	1001101e 	bne	r2,zero,d02b360 <ip_output+0x468>
   {
      m1 = data;
 d02af20:	e0bffd17 	ldw	r2,-12(fp)
 d02af24:	e0bff915 	stw	r2,-28(fp)
      m2 = data->m_next;
 d02af28:	e0bffd17 	ldw	r2,-12(fp)
 d02af2c:	10800617 	ldw	r2,24(r2)
 d02af30:	e0bff815 	stw	r2,-32(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 d02af34:	00003406 	br	d02b008 <ip_output+0x110>
      {
         pkt = m1->pkt;
 d02af38:	e0bff917 	ldw	r2,-28(fp)
 d02af3c:	10800117 	ldw	r2,4(r2)
 d02af40:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 d02af44:	e0bffa17 	ldw	r2,-24(fp)
 d02af48:	10c00117 	ldw	r3,4(r2)
 d02af4c:	e0bffa17 	ldw	r2,-24(fp)
 d02af50:	10800217 	ldw	r2,8(r2)
 d02af54:	1889883a 	add	r4,r3,r2
 d02af58:	e0bff917 	ldw	r2,-28(fp)
 d02af5c:	10c00317 	ldw	r3,12(r2)
 d02af60:	e0bff917 	ldw	r2,-28(fp)
 d02af64:	10800217 	ldw	r2,8(r2)
 d02af68:	1887883a 	add	r3,r3,r2
 d02af6c:	e0bff817 	ldw	r2,-32(fp)
 d02af70:	10800217 	ldw	r2,8(r2)
 d02af74:	1885883a 	add	r2,r3,r2
 d02af78:	1100822e 	bgeu	r2,r4,d02b184 <ip_output+0x28c>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 d02af7c:	e0bff917 	ldw	r2,-28(fp)
 d02af80:	10c00317 	ldw	r3,12(r2)
 d02af84:	e0bff917 	ldw	r2,-28(fp)
 d02af88:	10800217 	ldw	r2,8(r2)
 d02af8c:	1887883a 	add	r3,r3,r2
 d02af90:	e0bff817 	ldw	r2,-32(fp)
 d02af94:	11400317 	ldw	r5,12(r2)
 d02af98:	e0bff817 	ldw	r2,-32(fp)
 d02af9c:	10800217 	ldw	r2,8(r2)
 d02afa0:	1809883a 	mov	r4,r3
 d02afa4:	100d883a 	mov	r6,r2
 d02afa8:	d0027000 	call	d002700 <memcpy>
            m1->m_len += m2->m_len;
 d02afac:	e0bff917 	ldw	r2,-28(fp)
 d02afb0:	10c00217 	ldw	r3,8(r2)
 d02afb4:	e0bff817 	ldw	r2,-32(fp)
 d02afb8:	10800217 	ldw	r2,8(r2)
 d02afbc:	1887883a 	add	r3,r3,r2
 d02afc0:	e0bff917 	ldw	r2,-28(fp)
 d02afc4:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 d02afc8:	e0bff817 	ldw	r2,-32(fp)
 d02afcc:	10c00617 	ldw	r3,24(r2)
 d02afd0:	e0bff917 	ldw	r2,-28(fp)
 d02afd4:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 d02afd8:	e13ff817 	ldw	r4,-32(fp)
 d02afdc:	d02a3900 	call	d02a390 <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 d02afe0:	e0bff917 	ldw	r2,-28(fp)
 d02afe4:	10800617 	ldw	r2,24(r2)
 d02afe8:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oappends++;
 d02afec:	008341b4 	movhi	r2,3334
 d02aff0:	10b41504 	addi	r2,r2,-12204
 d02aff4:	10803317 	ldw	r2,204(r2)
 d02aff8:	10c00044 	addi	r3,r2,1
 d02affc:	008341b4 	movhi	r2,3334
 d02b000:	10b41504 	addi	r2,r2,-12204
 d02b004:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 d02b008:	e0bff817 	ldw	r2,-32(fp)
 d02b00c:	1005003a 	cmpeq	r2,r2,zero
 d02b010:	10005c1e 	bne	r2,zero,d02b184 <ip_output+0x28c>
 d02b014:	e0bff817 	ldw	r2,-32(fp)
 d02b018:	10800217 	ldw	r2,8(r2)
 d02b01c:	108002b0 	cmpltui	r2,r2,10
 d02b020:	103fc51e 	bne	r2,zero,d02af38 <ip_output+0x40>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 d02b024:	00005706 	br	d02b184 <ip_output+0x28c>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 d02b028:	e0bff817 	ldw	r2,-32(fp)
 d02b02c:	10800317 	ldw	r2,12(r2)
 d02b030:	1007883a 	mov	r3,r2
 d02b034:	e0bff817 	ldw	r2,-32(fp)
 d02b038:	10800117 	ldw	r2,4(r2)
 d02b03c:	10800117 	ldw	r2,4(r2)
 d02b040:	1885c83a 	sub	r2,r3,r2
 d02b044:	e0bff615 	stw	r2,-40(fp)
         if (e < MaxLnh)
 d02b048:	00834174 	movhi	r2,3333
 d02b04c:	108aa204 	addi	r2,r2,10888
 d02b050:	10c00017 	ldw	r3,0(r2)
 d02b054:	e0bff617 	ldw	r2,-40(fp)
 d02b058:	10c00a0e 	bge	r2,r3,d02b084 <ip_output+0x18c>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 d02b05c:	00834174 	movhi	r2,3333
 d02b060:	108aa204 	addi	r2,r2,10888
 d02b064:	11400017 	ldw	r5,0(r2)
 d02b068:	01034174 	movhi	r4,3333
 d02b06c:	213dd404 	addi	r4,r4,-2224
 d02b070:	e1bff617 	ldw	r6,-40(fp)
 d02b074:	d0029980 	call	d002998 <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 d02b078:	01034174 	movhi	r4,3333
 d02b07c:	213dda04 	addi	r4,r4,-2200
 d02b080:	d0246440 	call	d024644 <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 d02b084:	e0bff917 	ldw	r2,-28(fp)
 d02b088:	11000217 	ldw	r4,8(r2)
 d02b08c:	00834174 	movhi	r2,3333
 d02b090:	108aa204 	addi	r2,r2,10888
 d02b094:	10c00017 	ldw	r3,0(r2)
 d02b098:	e0bff617 	ldw	r2,-40(fp)
 d02b09c:	10c5c83a 	sub	r2,r2,r3
 d02b0a0:	20803b2e 	bgeu	r4,r2,d02b190 <ip_output+0x298>
 d02b0a4:	e0bff917 	ldw	r2,-28(fp)
 d02b0a8:	10800217 	ldw	r2,8(r2)
 d02b0ac:	108000cc 	andi	r2,r2,3
 d02b0b0:	1004c03a 	cmpne	r2,r2,zero
 d02b0b4:	1000361e 	bne	r2,zero,d02b190 <ip_output+0x298>
 d02b0b8:	e0bff817 	ldw	r2,-32(fp)
 d02b0bc:	10800317 	ldw	r2,12(r2)
 d02b0c0:	1007883a 	mov	r3,r2
 d02b0c4:	e0bff817 	ldw	r2,-32(fp)
 d02b0c8:	10800117 	ldw	r2,4(r2)
 d02b0cc:	10800117 	ldw	r2,4(r2)
 d02b0d0:	1885c83a 	sub	r2,r3,r2
 d02b0d4:	10800e18 	cmpnei	r2,r2,56
 d02b0d8:	10002d1e 	bne	r2,zero,d02b190 <ip_output+0x298>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 d02b0dc:	e0bff817 	ldw	r2,-32(fp)
 d02b0e0:	10c00317 	ldw	r3,12(r2)
 d02b0e4:	e0bff917 	ldw	r2,-28(fp)
 d02b0e8:	10800217 	ldw	r2,8(r2)
 d02b0ec:	1887c83a 	sub	r3,r3,r2
 d02b0f0:	e0bff917 	ldw	r2,-28(fp)
 d02b0f4:	11400317 	ldw	r5,12(r2)
 d02b0f8:	e0bff917 	ldw	r2,-28(fp)
 d02b0fc:	10800217 	ldw	r2,8(r2)
 d02b100:	1809883a 	mov	r4,r3
 d02b104:	100d883a 	mov	r6,r2
 d02b108:	d0027000 	call	d002700 <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 d02b10c:	e0bff817 	ldw	r2,-32(fp)
 d02b110:	10c00317 	ldw	r3,12(r2)
 d02b114:	e0bff917 	ldw	r2,-28(fp)
 d02b118:	10800217 	ldw	r2,8(r2)
 d02b11c:	1887c83a 	sub	r3,r3,r2
 d02b120:	e0bff817 	ldw	r2,-32(fp)
 d02b124:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 d02b128:	e0bff817 	ldw	r2,-32(fp)
 d02b12c:	10c00217 	ldw	r3,8(r2)
 d02b130:	e0bff917 	ldw	r2,-28(fp)
 d02b134:	10800217 	ldw	r2,8(r2)
 d02b138:	1887883a 	add	r3,r3,r2
 d02b13c:	e0bff817 	ldw	r2,-32(fp)
 d02b140:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 d02b144:	e13ff917 	ldw	r4,-28(fp)
 d02b148:	d02a3900 	call	d02a390 <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 d02b14c:	e0bff817 	ldw	r2,-32(fp)
 d02b150:	e0bff915 	stw	r2,-28(fp)
 d02b154:	e0bff917 	ldw	r2,-28(fp)
 d02b158:	e0bffd15 	stw	r2,-12(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 d02b15c:	e0bff817 	ldw	r2,-32(fp)
 d02b160:	10800617 	ldw	r2,24(r2)
 d02b164:	e0bff815 	stw	r2,-32(fp)
            tcpstat.tcps_oprepends++;
 d02b168:	008341b4 	movhi	r2,3334
 d02b16c:	10b41504 	addi	r2,r2,-12204
 d02b170:	10803217 	ldw	r2,200(r2)
 d02b174:	10c00044 	addi	r3,r2,1
 d02b178:	008341b4 	movhi	r2,3334
 d02b17c:	10b41504 	addi	r2,r2,-12204
 d02b180:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 d02b184:	e0bff817 	ldw	r2,-32(fp)
 d02b188:	1004c03a 	cmpne	r2,r2,zero
 d02b18c:	103fa61e 	bne	r2,zero,d02b028 <ip_output+0x130>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 d02b190:	e0bff817 	ldw	r2,-32(fp)
 d02b194:	1005003a 	cmpeq	r2,r2,zero
 d02b198:	1000711e 	bne	r2,zero,d02b360 <ip_output+0x468>
      {
         total = 0;
 d02b19c:	e03ff515 	stw	zero,-44(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 d02b1a0:	e0bff917 	ldw	r2,-28(fp)
 d02b1a4:	e0bff715 	stw	r2,-36(fp)
 d02b1a8:	00000806 	br	d02b1cc <ip_output+0x2d4>
            total += mtmp->m_len;
 d02b1ac:	e0bff717 	ldw	r2,-36(fp)
 d02b1b0:	10c00217 	ldw	r3,8(r2)
 d02b1b4:	e0bff517 	ldw	r2,-44(fp)
 d02b1b8:	1885883a 	add	r2,r3,r2
 d02b1bc:	e0bff515 	stw	r2,-44(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 d02b1c0:	e0bff717 	ldw	r2,-36(fp)
 d02b1c4:	10800617 	ldw	r2,24(r2)
 d02b1c8:	e0bff715 	stw	r2,-36(fp)
 d02b1cc:	e0bff717 	ldw	r2,-36(fp)
 d02b1d0:	1004c03a 	cmpne	r2,r2,zero
 d02b1d4:	103ff51e 	bne	r2,zero,d02b1ac <ip_output+0x2b4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d02b1d8:	01000084 	movi	r4,2
 d02b1dc:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 d02b1e0:	e0bff517 	ldw	r2,-44(fp)
 d02b1e4:	10800e04 	addi	r2,r2,56
 d02b1e8:	1009883a 	mov	r4,r2
 d02b1ec:	d0287a40 	call	d0287a4 <pk_alloc>
 d02b1f0:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02b1f4:	01000084 	movi	r4,2
 d02b1f8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         if (!pkt)
 d02b1fc:	e0bffa17 	ldw	r2,-24(fp)
 d02b200:	1004c03a 	cmpne	r2,r2,zero
 d02b204:	1000031e 	bne	r2,zero,d02b214 <ip_output+0x31c>
            return ENOBUFS;
 d02b208:	00801a44 	movi	r2,105
 d02b20c:	e0bfff15 	stw	r2,-4(fp)
 d02b210:	0000b106 	br	d02b4d8 <ip_output+0x5e0>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 d02b214:	e0bffa17 	ldw	r2,-24(fp)
 d02b218:	10c00117 	ldw	r3,4(r2)
 d02b21c:	00834174 	movhi	r2,3333
 d02b220:	108aa204 	addi	r2,r2,10888
 d02b224:	10800017 	ldw	r2,0(r2)
 d02b228:	1887883a 	add	r3,r3,r2
 d02b22c:	e0bffa17 	ldw	r2,-24(fp)
 d02b230:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 d02b234:	e0bff917 	ldw	r2,-28(fp)
 d02b238:	e0bff715 	stw	r2,-36(fp)
         while (mtmp)
 d02b23c:	00002806 	br	d02b2e0 <ip_output+0x3e8>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 d02b240:	e0bffa17 	ldw	r2,-24(fp)
 d02b244:	10c00317 	ldw	r3,12(r2)
 d02b248:	e0bff717 	ldw	r2,-36(fp)
 d02b24c:	11400317 	ldw	r5,12(r2)
 d02b250:	e0bff717 	ldw	r2,-36(fp)
 d02b254:	10800217 	ldw	r2,8(r2)
 d02b258:	1809883a 	mov	r4,r3
 d02b25c:	100d883a 	mov	r6,r2
 d02b260:	d0027000 	call	d002700 <memcpy>
            pkt->nb_prot += mtmp->m_len;
 d02b264:	e0bffa17 	ldw	r2,-24(fp)
 d02b268:	10c00317 	ldw	r3,12(r2)
 d02b26c:	e0bff717 	ldw	r2,-36(fp)
 d02b270:	10800217 	ldw	r2,8(r2)
 d02b274:	1887883a 	add	r3,r3,r2
 d02b278:	e0bffa17 	ldw	r2,-24(fp)
 d02b27c:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 d02b280:	e0bffa17 	ldw	r2,-24(fp)
 d02b284:	10c00417 	ldw	r3,16(r2)
 d02b288:	e0bff717 	ldw	r2,-36(fp)
 d02b28c:	10800217 	ldw	r2,8(r2)
 d02b290:	1887883a 	add	r3,r3,r2
 d02b294:	e0bffa17 	ldw	r2,-24(fp)
 d02b298:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 d02b29c:	e0bff717 	ldw	r2,-36(fp)
 d02b2a0:	e0bff815 	stw	r2,-32(fp)
            mtmp = mtmp->m_next;
 d02b2a4:	e0bff717 	ldw	r2,-36(fp)
 d02b2a8:	10800617 	ldw	r2,24(r2)
 d02b2ac:	e0bff715 	stw	r2,-36(fp)
            if (m2 != data)   /* save original head */
 d02b2b0:	e0fff817 	ldw	r3,-32(fp)
 d02b2b4:	e0bffd17 	ldw	r2,-12(fp)
 d02b2b8:	18800226 	beq	r3,r2,d02b2c4 <ip_output+0x3cc>
               m_free(m2);
 d02b2bc:	e13ff817 	ldw	r4,-32(fp)
 d02b2c0:	d02a3900 	call	d02a390 <m_free>
            tcpstat.tcps_ocopies++;
 d02b2c4:	008341b4 	movhi	r2,3334
 d02b2c8:	10b41504 	addi	r2,r2,-12204
 d02b2cc:	10803417 	ldw	r2,208(r2)
 d02b2d0:	10c00044 	addi	r3,r2,1
 d02b2d4:	008341b4 	movhi	r2,3334
 d02b2d8:	10b41504 	addi	r2,r2,-12204
 d02b2dc:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 d02b2e0:	e0bff717 	ldw	r2,-36(fp)
 d02b2e4:	1004c03a 	cmpne	r2,r2,zero
 d02b2e8:	103fd51e 	bne	r2,zero,d02b240 <ip_output+0x348>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 d02b2ec:	e0bffa17 	ldw	r2,-24(fp)
 d02b2f0:	10c00317 	ldw	r3,12(r2)
 d02b2f4:	e0bff517 	ldw	r2,-44(fp)
 d02b2f8:	1887c83a 	sub	r3,r3,r2
 d02b2fc:	e0bffa17 	ldw	r2,-24(fp)
 d02b300:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d02b304:	01000084 	movi	r4,2
 d02b308:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 d02b30c:	e0bffd17 	ldw	r2,-12(fp)
 d02b310:	11000117 	ldw	r4,4(r2)
 d02b314:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02b318:	01000084 	movi	r4,2
 d02b31c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 d02b320:	e0fffd17 	ldw	r3,-12(fp)
 d02b324:	e0bffa17 	ldw	r2,-24(fp)
 d02b328:	18800115 	stw	r2,4(r3)
         data->m_len = pkt->nb_plen;
 d02b32c:	e0bffa17 	ldw	r2,-24(fp)
 d02b330:	10c00417 	ldw	r3,16(r2)
 d02b334:	e0bffd17 	ldw	r2,-12(fp)
 d02b338:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 d02b33c:	e0bffd17 	ldw	r2,-12(fp)
 d02b340:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 d02b344:	e0bffa17 	ldw	r2,-24(fp)
 d02b348:	10c00317 	ldw	r3,12(r2)
 d02b34c:	e0bffd17 	ldw	r2,-12(fp)
 d02b350:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 d02b354:	e0fff517 	ldw	r3,-44(fp)
 d02b358:	e0bffd17 	ldw	r2,-12(fp)
 d02b35c:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 d02b360:	e0bffd17 	ldw	r2,-12(fp)
 d02b364:	11000317 	ldw	r4,12(r2)
 d02b368:	e0bffd17 	ldw	r2,-12(fp)
 d02b36c:	10800117 	ldw	r2,4(r2)
 d02b370:	10c00117 	ldw	r3,4(r2)
 d02b374:	00834174 	movhi	r2,3333
 d02b378:	108aa204 	addi	r2,r2,10888
 d02b37c:	10800017 	ldw	r2,0(r2)
 d02b380:	1885883a 	add	r2,r3,r2
 d02b384:	2080032e 	bgeu	r4,r2,d02b394 <ip_output+0x49c>
      panic("ip_output: overflow");
 d02b388:	01034174 	movhi	r4,3333
 d02b38c:	213ddf04 	addi	r4,r4,-2180
 d02b390:	d0246440 	call	d024644 <panic>

   pkt = data->pkt;
 d02b394:	e0bffd17 	ldw	r2,-12(fp)
 d02b398:	10800117 	ldw	r2,4(r2)
 d02b39c:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 d02b3a0:	e0bffe17 	ldw	r2,-8(fp)
 d02b3a4:	1005003a 	cmpeq	r2,r2,zero
 d02b3a8:	1000031e 	bne	r2,zero,d02b3b8 <ip_output+0x4c0>
	   pkt->soxopts = so_optsPack;   /* yup */
 d02b3ac:	e0fffa17 	ldw	r3,-24(fp)
 d02b3b0:	e0bffe17 	ldw	r2,-8(fp)
 d02b3b4:	18800c15 	stw	r2,48(r3)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 d02b3b8:	e0bffd17 	ldw	r2,-12(fp)
 d02b3bc:	10800317 	ldw	r2,12(r2)
 d02b3c0:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 d02b3c4:	e0bffc17 	ldw	r2,-16(fp)
 d02b3c8:	10c00417 	ldw	r3,16(r2)
 d02b3cc:	e0bffa17 	ldw	r2,-24(fp)
 d02b3d0:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 d02b3d4:	e0fffc17 	ldw	r3,-16(fp)
 d02b3d8:	00801144 	movi	r2,69
 d02b3dc:	18800005 	stb	r2,0(r3)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 d02b3e0:	e0bffc17 	ldw	r2,-16(fp)
 d02b3e4:	1080008b 	ldhu	r2,2(r2)
 d02b3e8:	10bfffcc 	andi	r2,r2,65535
 d02b3ec:	1004d23a 	srli	r2,r2,8
 d02b3f0:	10803fcc 	andi	r2,r2,255
 d02b3f4:	1009883a 	mov	r4,r2
 d02b3f8:	e0bffc17 	ldw	r2,-16(fp)
 d02b3fc:	1080008b 	ldhu	r2,2(r2)
 d02b400:	10bfffcc 	andi	r2,r2,65535
 d02b404:	1004923a 	slli	r2,r2,8
 d02b408:	1007883a 	mov	r3,r2
 d02b40c:	00bfc004 	movi	r2,-256
 d02b410:	1884703a 	and	r2,r3,r2
 d02b414:	2084b03a 	or	r2,r4,r2
 d02b418:	1007883a 	mov	r3,r2
 d02b41c:	e0bffc17 	ldw	r2,-16(fp)
 d02b420:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 d02b424:	e0bffc17 	ldw	r2,-16(fp)
 d02b428:	10800003 	ldbu	r2,0(r2)
 d02b42c:	10803fcc 	andi	r2,r2,255
 d02b430:	108003cc 	andi	r2,r2,15
 d02b434:	1085883a 	add	r2,r2,r2
 d02b438:	1085883a 	add	r2,r2,r2
 d02b43c:	1007883a 	mov	r3,r2
 d02b440:	e0bffc17 	ldw	r2,-16(fp)
 d02b444:	1885883a 	add	r2,r3,r2
 d02b448:	e0bffb15 	stw	r2,-20(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 d02b44c:	e13ffc17 	ldw	r4,-16(fp)
 d02b450:	d0460c80 	call	d0460c8 <tcp_cksum>
 d02b454:	1007883a 	mov	r3,r2
 d02b458:	e0bffb17 	ldw	r2,-20(fp)
 d02b45c:	10c0040d 	sth	r3,16(r2)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 d02b460:	e0bffc17 	ldw	r2,-16(fp)
 d02b464:	10800504 	addi	r2,r2,20
 d02b468:	1007883a 	mov	r3,r2
 d02b46c:	e0bffa17 	ldw	r2,-24(fp)
 d02b470:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 d02b474:	e0bffd17 	ldw	r2,-12(fp)
 d02b478:	10800217 	ldw	r2,8(r2)
 d02b47c:	10fffb04 	addi	r3,r2,-20
 d02b480:	e0bffa17 	ldw	r2,-24(fp)
 d02b484:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 d02b488:	01000184 	movi	r4,6
 d02b48c:	e17ffa17 	ldw	r5,-24(fp)
 d02b490:	d03d4240 	call	d03d424 <ip_write>
 d02b494:	e0bff615 	stw	r2,-40(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 d02b498:	e0bffd17 	ldw	r2,-12(fp)
 d02b49c:	10000115 	stw	zero,4(r2)
   m_freem(data);
 d02b4a0:	e13ffd17 	ldw	r4,-12(fp)
 d02b4a4:	d02a4c40 	call	d02a4c4 <m_freem>

   if (e < 0)
 d02b4a8:	e0bff617 	ldw	r2,-40(fp)
 d02b4ac:	1004403a 	cmpge	r2,r2,zero
 d02b4b0:	1000081e 	bne	r2,zero,d02b4d4 <ip_output+0x5dc>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 d02b4b4:	e0bff617 	ldw	r2,-40(fp)
 d02b4b8:	10bffa98 	cmpnei	r2,r2,-22
 d02b4bc:	1000021e 	bne	r2,zero,d02b4c8 <ip_output+0x5d0>
         return 0;
 d02b4c0:	e03fff15 	stw	zero,-4(fp)
 d02b4c4:	00000406 	br	d02b4d8 <ip_output+0x5e0>
      return e;
 d02b4c8:	e0bff617 	ldw	r2,-40(fp)
 d02b4cc:	e0bfff15 	stw	r2,-4(fp)
 d02b4d0:	00000106 	br	d02b4d8 <ip_output+0x5e0>
   }
   else
      return 0;
 d02b4d4:	e03fff15 	stw	zero,-4(fp)
 d02b4d8:	e0bfff17 	ldw	r2,-4(fp)
}
 d02b4dc:	e037883a 	mov	sp,fp
 d02b4e0:	dfc00117 	ldw	ra,4(sp)
 d02b4e4:	df000017 	ldw	fp,0(sp)
 d02b4e8:	dec00204 	addi	sp,sp,8
 d02b4ec:	f800283a 	ret

0d02b4f0 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 d02b4f0:	defffd04 	addi	sp,sp,-12
 d02b4f4:	df000215 	stw	fp,8(sp)
 d02b4f8:	df000204 	addi	fp,sp,8
 d02b4fc:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr == 0xffffffff)
 d02b500:	e0bffe17 	ldw	r2,-8(fp)
 d02b504:	10bfffd8 	cmpnei	r2,r2,-1
 d02b508:	1000031e 	bne	r2,zero,d02b518 <in_broadcast+0x28>
      return TRUE;
 d02b50c:	00800044 	movi	r2,1
 d02b510:	e0bfff15 	stw	r2,-4(fp)
 d02b514:	00000106 	br	d02b51c <in_broadcast+0x2c>

   return FALSE;
 d02b518:	e03fff15 	stw	zero,-4(fp)
 d02b51c:	e0bfff17 	ldw	r2,-4(fp)
}
 d02b520:	e037883a 	mov	sp,fp
 d02b524:	df000017 	ldw	fp,0(sp)
 d02b528:	dec00104 	addi	sp,sp,4
 d02b52c:	f800283a 	ret

0d02b530 <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 d02b530:	defffb04 	addi	sp,sp,-20
 d02b534:	dfc00415 	stw	ra,16(sp)
 d02b538:	df000315 	stw	fp,12(sp)
 d02b53c:	df000304 	addi	fp,sp,12
 d02b540:	e13ffe15 	stw	r4,-8(fp)
 d02b544:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 d02b548:	e0bffe17 	ldw	r2,-8(fp)
 d02b54c:	10800003 	ldbu	r2,0(r2)
 d02b550:	10803fcc 	andi	r2,r2,255
 d02b554:	108003cc 	andi	r2,r2,15
 d02b558:	1085883a 	add	r2,r2,r2
 d02b55c:	1085883a 	add	r2,r2,r2
 d02b560:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 d02b564:	e0bffd17 	ldw	r2,-12(fp)
 d02b568:	10800550 	cmplti	r2,r2,21
 d02b56c:	1000251e 	bne	r2,zero,d02b604 <np_stripoptions+0xd4>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 d02b570:	e0bffd17 	ldw	r2,-12(fp)
 d02b574:	10bffb04 	addi	r2,r2,-20
 d02b578:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 d02b57c:	e0bffe17 	ldw	r2,-8(fp)
 d02b580:	10c0008b 	ldhu	r3,2(r2)
 d02b584:	e0bffd17 	ldw	r2,-12(fp)
 d02b588:	1885c83a 	sub	r2,r3,r2
 d02b58c:	1007883a 	mov	r3,r2
 d02b590:	e0bffe17 	ldw	r2,-8(fp)
 d02b594:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 d02b598:	e0bffe17 	ldw	r2,-8(fp)
 d02b59c:	10800003 	ldbu	r2,0(r2)
 d02b5a0:	1007883a 	mov	r3,r2
 d02b5a4:	00bffc04 	movi	r2,-16
 d02b5a8:	1884703a 	and	r2,r3,r2
 d02b5ac:	10800154 	ori	r2,r2,5
 d02b5b0:	1007883a 	mov	r3,r2
 d02b5b4:	e0bffe17 	ldw	r2,-8(fp)
 d02b5b8:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 d02b5bc:	e0fffe17 	ldw	r3,-8(fp)
 d02b5c0:	e0bffd17 	ldw	r2,-12(fp)
 d02b5c4:	1889883a 	add	r4,r3,r2
 d02b5c8:	e17ffe17 	ldw	r5,-8(fp)
 d02b5cc:	01800504 	movi	r6,20
 d02b5d0:	d0027a00 	call	d0027a0 <memmove>
   m->m_len -= ihlen;
 d02b5d4:	e0bfff17 	ldw	r2,-4(fp)
 d02b5d8:	10c00217 	ldw	r3,8(r2)
 d02b5dc:	e0bffd17 	ldw	r2,-12(fp)
 d02b5e0:	1887c83a 	sub	r3,r3,r2
 d02b5e4:	e0bfff17 	ldw	r2,-4(fp)
 d02b5e8:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 d02b5ec:	e0bfff17 	ldw	r2,-4(fp)
 d02b5f0:	10c00317 	ldw	r3,12(r2)
 d02b5f4:	e0bffd17 	ldw	r2,-12(fp)
 d02b5f8:	1887883a 	add	r3,r3,r2
 d02b5fc:	e0bfff17 	ldw	r2,-4(fp)
 d02b600:	10c00315 	stw	r3,12(r2)
}
 d02b604:	e037883a 	mov	sp,fp
 d02b608:	dfc00117 	ldw	ra,4(sp)
 d02b60c:	df000017 	ldw	fp,0(sp)
 d02b610:	dec00204 	addi	sp,sp,8
 d02b614:	f800283a 	ret

0d02b618 <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 d02b618:	defff304 	addi	sp,sp,-52
 d02b61c:	dfc00c15 	stw	ra,48(sp)
 d02b620:	df000b15 	stw	fp,44(sp)
 d02b624:	df000b04 	addi	fp,sp,44
 d02b628:	e13ffe15 	stw	r4,-8(fp)
 d02b62c:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 d02b630:	e0bfff17 	ldw	r2,-4(fp)
 d02b634:	10800617 	ldw	r2,24(r2)
 d02b638:	1004d63a 	srli	r2,r2,24
 d02b63c:	10c03fcc 	andi	r3,r2,255
 d02b640:	e0bfff17 	ldw	r2,-4(fp)
 d02b644:	10800617 	ldw	r2,24(r2)
 d02b648:	1004d23a 	srli	r2,r2,8
 d02b64c:	10bfc00c 	andi	r2,r2,65280
 d02b650:	1886b03a 	or	r3,r3,r2
 d02b654:	e0bfff17 	ldw	r2,-4(fp)
 d02b658:	10800617 	ldw	r2,24(r2)
 d02b65c:	10bfc00c 	andi	r2,r2,65280
 d02b660:	1004923a 	slli	r2,r2,8
 d02b664:	1886b03a 	or	r3,r3,r2
 d02b668:	e0bfff17 	ldw	r2,-4(fp)
 d02b66c:	10800617 	ldw	r2,24(r2)
 d02b670:	10803fcc 	andi	r2,r2,255
 d02b674:	1004963a 	slli	r2,r2,24
 d02b678:	1884b03a 	or	r2,r3,r2
 d02b67c:	e0bffc15 	stw	r2,-16(fp)
   lhost = htonl(pdp->dip.ip_src);
 d02b680:	e0bfff17 	ldw	r2,-4(fp)
 d02b684:	10800517 	ldw	r2,20(r2)
 d02b688:	1004d63a 	srli	r2,r2,24
 d02b68c:	10c03fcc 	andi	r3,r2,255
 d02b690:	e0bfff17 	ldw	r2,-4(fp)
 d02b694:	10800517 	ldw	r2,20(r2)
 d02b698:	1004d23a 	srli	r2,r2,8
 d02b69c:	10bfc00c 	andi	r2,r2,65280
 d02b6a0:	1886b03a 	or	r3,r3,r2
 d02b6a4:	e0bfff17 	ldw	r2,-4(fp)
 d02b6a8:	10800517 	ldw	r2,20(r2)
 d02b6ac:	10bfc00c 	andi	r2,r2,65280
 d02b6b0:	1004923a 	slli	r2,r2,8
 d02b6b4:	1886b03a 	or	r3,r3,r2
 d02b6b8:	e0bfff17 	ldw	r2,-4(fp)
 d02b6bc:	10800517 	ldw	r2,20(r2)
 d02b6c0:	10803fcc 	andi	r2,r2,255
 d02b6c4:	1004963a 	slli	r2,r2,24
 d02b6c8:	1884b03a 	or	r2,r3,r2
 d02b6cc:	e0bffd15 	stw	r2,-12(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 d02b6d0:	e0bfff17 	ldw	r2,-4(fp)
 d02b6d4:	10800704 	addi	r2,r2,28
 d02b6d8:	1080000b 	ldhu	r2,0(r2)
 d02b6dc:	10bfffcc 	andi	r2,r2,65535
 d02b6e0:	1004d23a 	srli	r2,r2,8
 d02b6e4:	10803fcc 	andi	r2,r2,255
 d02b6e8:	1009883a 	mov	r4,r2
 d02b6ec:	e0bfff17 	ldw	r2,-4(fp)
 d02b6f0:	10800704 	addi	r2,r2,28
 d02b6f4:	1080000b 	ldhu	r2,0(r2)
 d02b6f8:	10bfffcc 	andi	r2,r2,65535
 d02b6fc:	1004923a 	slli	r2,r2,8
 d02b700:	1007883a 	mov	r3,r2
 d02b704:	00bfc004 	movi	r2,-256
 d02b708:	1884703a 	and	r2,r3,r2
 d02b70c:	2084b03a 	or	r2,r4,r2
 d02b710:	e0bffb0d 	sth	r2,-20(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 d02b714:	e0bfff17 	ldw	r2,-4(fp)
 d02b718:	10800704 	addi	r2,r2,28
 d02b71c:	10800084 	addi	r2,r2,2
 d02b720:	1080000b 	ldhu	r2,0(r2)
 d02b724:	10bfffcc 	andi	r2,r2,65535
 d02b728:	1004d23a 	srli	r2,r2,8
 d02b72c:	10803fcc 	andi	r2,r2,255
 d02b730:	1009883a 	mov	r4,r2
 d02b734:	e0bfff17 	ldw	r2,-4(fp)
 d02b738:	10800704 	addi	r2,r2,28
 d02b73c:	10800084 	addi	r2,r2,2
 d02b740:	1080000b 	ldhu	r2,0(r2)
 d02b744:	10bfffcc 	andi	r2,r2,65535
 d02b748:	1004923a 	slli	r2,r2,8
 d02b74c:	1007883a 	mov	r3,r2
 d02b750:	00bfc004 	movi	r2,-256
 d02b754:	1884703a 	and	r2,r3,r2
 d02b758:	2084b03a 	or	r2,r4,r2
 d02b75c:	e0bffb8d 	sth	r2,-18(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 d02b760:	e0bfff17 	ldw	r2,-4(fp)
 d02b764:	10800043 	ldbu	r2,1(r2)
 d02b768:	10803fcc 	andi	r2,r2,255
 d02b76c:	1080201c 	xori	r2,r2,128
 d02b770:	10bfe004 	addi	r2,r2,-128
 d02b774:	10800120 	cmpeqi	r2,r2,4
 d02b778:	1000721e 	bne	r2,zero,d02b944 <so_icmpdu+0x32c>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 d02b77c:	e0bfff17 	ldw	r2,-4(fp)
 d02b780:	10800443 	ldbu	r2,17(r2)
 d02b784:	10803fcc 	andi	r2,r2,255
 d02b788:	10800198 	cmpnei	r2,r2,6
 d02b78c:	1000241e 	bne	r2,zero,d02b820 <so_icmpdu+0x208>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 d02b790:	e1bffb8b 	ldhu	r6,-18(fp)
 d02b794:	e0bffb0b 	ldhu	r2,-20(fp)
 d02b798:	d8800015 	stw	r2,0(sp)
 d02b79c:	00800044 	movi	r2,1
 d02b7a0:	d8800115 	stw	r2,4(sp)
 d02b7a4:	010341b4 	movhi	r4,3334
 d02b7a8:	21340a04 	addi	r4,r4,-12248
 d02b7ac:	e17ffc17 	ldw	r5,-16(fp)
 d02b7b0:	e1fffd17 	ldw	r7,-12(fp)
 d02b7b4:	d0469380 	call	d046938 <in_pcblookup>
 d02b7b8:	e0bffa15 	stw	r2,-24(fp)
      if (inp == 0)
 d02b7bc:	e0bffa17 	ldw	r2,-24(fp)
 d02b7c0:	1005003a 	cmpeq	r2,r2,zero
 d02b7c4:	10005f1e 	bne	r2,zero,d02b944 <so_icmpdu+0x32c>
         goto done;
      so = inp->inp_socket;
 d02b7c8:	e0bffa17 	ldw	r2,-24(fp)
 d02b7cc:	10800817 	ldw	r2,32(r2)
 d02b7d0:	e0bff915 	stw	r2,-28(fp)
      if (so == 0)
 d02b7d4:	e0bff917 	ldw	r2,-28(fp)
 d02b7d8:	1005003a 	cmpeq	r2,r2,zero
 d02b7dc:	1000591e 	bne	r2,zero,d02b944 <so_icmpdu+0x32c>
         goto done;
      tp = intotcpcb(inp);
 d02b7e0:	e0bffa17 	ldw	r2,-24(fp)
 d02b7e4:	10800917 	ldw	r2,36(r2)
 d02b7e8:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 d02b7ec:	e0bff817 	ldw	r2,-32(fp)
 d02b7f0:	1005003a 	cmpeq	r2,r2,zero
 d02b7f4:	1000061e 	bne	r2,zero,d02b810 <so_icmpdu+0x1f8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 d02b7f8:	e0bff817 	ldw	r2,-32(fp)
 d02b7fc:	10800217 	ldw	r2,8(r2)
 d02b800:	10800090 	cmplti	r2,r2,2
 d02b804:	10004f1e 	bne	r2,zero,d02b944 <so_icmpdu+0x32c>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 d02b808:	e13ff817 	ldw	r4,-32(fp)
 d02b80c:	d0366c00 	call	d0366c0 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 d02b810:	e0fff917 	ldw	r3,-28(fp)
 d02b814:	00801bc4 	movi	r2,111
 d02b818:	18800615 	stw	r2,24(r3)
 d02b81c:	00004906 	br	d02b944 <so_icmpdu+0x32c>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 d02b820:	e0bfff17 	ldw	r2,-4(fp)
 d02b824:	10800443 	ldbu	r2,17(r2)
 d02b828:	10803fcc 	andi	r2,r2,255
 d02b82c:	10800458 	cmpnei	r2,r2,17
 d02b830:	1000441e 	bne	r2,zero,d02b944 <so_icmpdu+0x32c>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d02b834:	00834174 	movhi	r2,3333
 d02b838:	108abd04 	addi	r2,r2,10996
 d02b83c:	10800017 	ldw	r2,0(r2)
 d02b840:	e0bff715 	stw	r2,-36(fp)
 d02b844:	00002406 	br	d02b8d8 <so_icmpdu+0x2c0>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 d02b848:	e0bff717 	ldw	r2,-36(fp)
 d02b84c:	1080020b 	ldhu	r2,8(r2)
 d02b850:	10ffffcc 	andi	r3,r2,65535
 d02b854:	e0bffb8b 	ldhu	r2,-18(fp)
 d02b858:	18800526 	beq	r3,r2,d02b870 <so_icmpdu+0x258>
 d02b85c:	e0bff717 	ldw	r2,-36(fp)
 d02b860:	1080020b 	ldhu	r2,8(r2)
 d02b864:	10bfffcc 	andi	r2,r2,65535
 d02b868:	1004c03a 	cmpne	r2,r2,zero
 d02b86c:	1000171e 	bne	r2,zero,d02b8cc <so_icmpdu+0x2b4>
 d02b870:	e0bff717 	ldw	r2,-36(fp)
 d02b874:	11000417 	ldw	r4,16(r2)
 d02b878:	e0bffc17 	ldw	r2,-16(fp)
 d02b87c:	1004d63a 	srli	r2,r2,24
 d02b880:	10c03fcc 	andi	r3,r2,255
 d02b884:	e0bffc17 	ldw	r2,-16(fp)
 d02b888:	1004d23a 	srli	r2,r2,8
 d02b88c:	10bfc00c 	andi	r2,r2,65280
 d02b890:	1886b03a 	or	r3,r3,r2
 d02b894:	e0bffc17 	ldw	r2,-16(fp)
 d02b898:	10bfc00c 	andi	r2,r2,65280
 d02b89c:	1004923a 	slli	r2,r2,8
 d02b8a0:	1886b03a 	or	r3,r3,r2
 d02b8a4:	e0bffc17 	ldw	r2,-16(fp)
 d02b8a8:	10803fcc 	andi	r2,r2,255
 d02b8ac:	1004963a 	slli	r2,r2,24
 d02b8b0:	1884b03a 	or	r2,r3,r2
 d02b8b4:	2080051e 	bne	r4,r2,d02b8cc <so_icmpdu+0x2b4>
 d02b8b8:	e0bff717 	ldw	r2,-36(fp)
 d02b8bc:	1080018b 	ldhu	r2,6(r2)
 d02b8c0:	10ffffcc 	andi	r3,r2,65535
 d02b8c4:	e0bffb0b 	ldhu	r2,-20(fp)
 d02b8c8:	18800626 	beq	r3,r2,d02b8e4 <so_icmpdu+0x2cc>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d02b8cc:	e0bff717 	ldw	r2,-36(fp)
 d02b8d0:	10800017 	ldw	r2,0(r2)
 d02b8d4:	e0bff715 	stw	r2,-36(fp)
 d02b8d8:	e0bff717 	ldw	r2,-36(fp)
 d02b8dc:	1004c03a 	cmpne	r2,r2,zero
 d02b8e0:	103fd91e 	bne	r2,zero,d02b848 <so_icmpdu+0x230>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
 d02b8e4:	e0bff717 	ldw	r2,-36(fp)
 d02b8e8:	1005003a 	cmpeq	r2,r2,zero
 d02b8ec:	1000151e 	bne	r2,zero,d02b944 <so_icmpdu+0x32c>
         goto done;
      so = (struct socket *)tmp->u_data;
 d02b8f0:	e0bff717 	ldw	r2,-36(fp)
 d02b8f4:	10800617 	ldw	r2,24(r2)
 d02b8f8:	e0bff915 	stw	r2,-28(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 d02b8fc:	e0bff917 	ldw	r2,-28(fp)
 d02b900:	10800983 	ldbu	r2,38(r2)
 d02b904:	10803fcc 	andi	r2,r2,255
 d02b908:	1080201c 	xori	r2,r2,128
 d02b90c:	10bfe004 	addi	r2,r2,-128
 d02b910:	10800098 	cmpnei	r2,r2,2
 d02b914:	10000b1e 	bne	r2,zero,d02b944 <so_icmpdu+0x32c>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 d02b918:	e0fff917 	ldw	r3,-28(fp)
 d02b91c:	00801bc4 	movi	r2,111
 d02b920:	18800615 	stw	r2,24(r3)
      /* do a select() notify on socket here */
      sorwakeup(so);
 d02b924:	e0bff917 	ldw	r2,-28(fp)
 d02b928:	11400a04 	addi	r5,r2,40
 d02b92c:	e13ff917 	ldw	r4,-28(fp)
 d02b930:	d0307680 	call	d030768 <sbwakeup>
      sowwakeup(so);
 d02b934:	e0bff917 	ldw	r2,-28(fp)
 d02b938:	11401204 	addi	r5,r2,72
 d02b93c:	e13ff917 	ldw	r4,-28(fp)
 d02b940:	d0307680 	call	d030768 <sbwakeup>
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d02b944:	01000084 	movi	r4,2
 d02b948:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 d02b94c:	e13ffe17 	ldw	r4,-8(fp)
 d02b950:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d02b954:	01000084 	movi	r4,2
 d02b958:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return;
}
 d02b95c:	e037883a 	mov	sp,fp
 d02b960:	dfc00117 	ldw	ra,4(sp)
 d02b964:	df000017 	ldw	fp,0(sp)
 d02b968:	dec00204 	addi	sp,sp,8
 d02b96c:	f800283a 	ret

0d02b970 <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 d02b970:	defffe04 	addi	sp,sp,-8
 d02b974:	dfc00115 	stw	ra,4(sp)
 d02b978:	df000015 	stw	fp,0(sp)
 d02b97c:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 d02b980:	d0a0ad17 	ldw	r2,-32076(gp)
 d02b984:	1004c03a 	cmpne	r2,r2,zero
 d02b988:	1000151e 	bne	r2,zero,d02b9e0 <tcp_tick+0x70>
      return;
   in_tcptick++;
 d02b98c:	d0a0ad17 	ldw	r2,-32076(gp)
 d02b990:	10800044 	addi	r2,r2,1
 d02b994:	d0a0ad15 	stw	r2,-32076(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 d02b998:	0009883a 	mov	r4,zero
 d02b99c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 d02b9a0:	00834174 	movhi	r2,3333
 d02b9a4:	108ac904 	addi	r2,r2,11044
 d02b9a8:	10c00017 	ldw	r3,0(r2)
 d02b9ac:	d0a0ac17 	ldw	r2,-32080(gp)
 d02b9b0:	18800636 	bltu	r3,r2,d02b9cc <tcp_tick+0x5c>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 d02b9b4:	d0368ec0 	call	d0368ec <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 d02b9b8:	00834174 	movhi	r2,3333
 d02b9bc:	108ac904 	addi	r2,r2,11044
 d02b9c0:	10800017 	ldw	r2,0(r2)
 d02b9c4:	10800c84 	addi	r2,r2,50
 d02b9c8:	d0a0ac15 	stw	r2,-32080(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 d02b9cc:	0009883a 	mov	r4,zero
 d02b9d0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 d02b9d4:	d0a0ad17 	ldw	r2,-32076(gp)
 d02b9d8:	10bfffc4 	addi	r2,r2,-1
 d02b9dc:	d0a0ad15 	stw	r2,-32076(gp)
}
 d02b9e0:	e037883a 	mov	sp,fp
 d02b9e4:	dfc00117 	ldw	ra,4(sp)
 d02b9e8:	df000017 	ldw	fp,0(sp)
 d02b9ec:	dec00204 	addi	sp,sp,8
 d02b9f0:	f800283a 	ret

0d02b9f4 <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 d02b9f4:	defffc04 	addi	sp,sp,-16
 d02b9f8:	df000315 	stw	fp,12(sp)
 d02b9fc:	df000304 	addi	fp,sp,12
 d02ba00:	e13ffe15 	stw	r4,-8(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 d02ba04:	00834174 	movhi	r2,3333
 d02ba08:	108af004 	addi	r2,r2,11200
 d02ba0c:	10800017 	ldw	r2,0(r2)
 d02ba10:	e0bffd15 	stw	r2,-12(fp)
 d02ba14:	00000a06 	br	d02ba40 <rawip_lookup+0x4c>
      if (tmp->ipr_data == (void*)so)
 d02ba18:	e0bffd17 	ldw	r2,-12(fp)
 d02ba1c:	10c00417 	ldw	r3,16(r2)
 d02ba20:	e0bffe17 	ldw	r2,-8(fp)
 d02ba24:	1880031e 	bne	r3,r2,d02ba34 <rawip_lookup+0x40>
      return (tmp);
 d02ba28:	e0bffd17 	ldw	r2,-12(fp)
 d02ba2c:	e0bfff15 	stw	r2,-4(fp)
 d02ba30:	00000706 	br	d02ba50 <rawip_lookup+0x5c>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 d02ba34:	e0bffd17 	ldw	r2,-12(fp)
 d02ba38:	10800017 	ldw	r2,0(r2)
 d02ba3c:	e0bffd15 	stw	r2,-12(fp)
 d02ba40:	e0bffd17 	ldw	r2,-12(fp)
 d02ba44:	1004c03a 	cmpne	r2,r2,zero
 d02ba48:	103ff31e 	bne	r2,zero,d02ba18 <rawip_lookup+0x24>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 d02ba4c:	e03fff15 	stw	zero,-4(fp)
 d02ba50:	e0bfff17 	ldw	r2,-4(fp)
}
 d02ba54:	e037883a 	mov	sp,fp
 d02ba58:	df000017 	ldw	fp,0(sp)
 d02ba5c:	dec00104 	addi	sp,sp,4
 d02ba60:	f800283a 	ret

0d02ba64 <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 d02ba64:	defff404 	addi	sp,sp,-48
 d02ba68:	dfc00b15 	stw	ra,44(sp)
 d02ba6c:	df000a15 	stw	fp,40(sp)
 d02ba70:	df000a04 	addi	fp,sp,40
 d02ba74:	e13ffd15 	stw	r4,-12(fp)
 d02ba78:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 d02ba7c:	e0bffe17 	ldw	r2,-8(fp)
 d02ba80:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 d02ba84:	0009883a 	mov	r4,zero
 d02ba88:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 d02ba8c:	e0bff717 	ldw	r2,-36(fp)
 d02ba90:	10c00a17 	ldw	r3,40(r2)
 d02ba94:	e0bffd17 	ldw	r2,-12(fp)
 d02ba98:	10800417 	ldw	r2,16(r2)
 d02ba9c:	1887883a 	add	r3,r3,r2
 d02baa0:	e0bff717 	ldw	r2,-36(fp)
 d02baa4:	10800b17 	ldw	r2,44(r2)
 d02baa8:	18800536 	bltu	r3,r2,d02bac0 <rawip_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02baac:	0009883a 	mov	r4,zero
 d02bab0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d02bab4:	00801a44 	movi	r2,105
 d02bab8:	e0bfff15 	stw	r2,-4(fp)
 d02babc:	00005806 	br	d02bc20 <rawip_soinput+0x1bc>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 d02bac0:	01000044 	movi	r4,1
 d02bac4:	000b883a 	mov	r5,zero
 d02bac8:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02bacc:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 d02bad0:	e0bff817 	ldw	r2,-32(fp)
 d02bad4:	1004c03a 	cmpne	r2,r2,zero
 d02bad8:	1000051e 	bne	r2,zero,d02baf0 <rawip_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02badc:	0009883a 	mov	r4,zero
 d02bae0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d02bae4:	00801a44 	movi	r2,105
 d02bae8:	e0bfff15 	stw	r2,-4(fp)
 d02baec:	00004c06 	br	d02bc20 <rawip_soinput+0x1bc>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 d02baf0:	e0fff817 	ldw	r3,-32(fp)
 d02baf4:	e0bffd17 	ldw	r2,-12(fp)
 d02baf8:	18800115 	stw	r2,4(r3)
   m_in->m_base = pkt->nb_buff;
 d02bafc:	e0bffd17 	ldw	r2,-12(fp)
 d02bb00:	10c00117 	ldw	r3,4(r2)
 d02bb04:	e0bff817 	ldw	r2,-32(fp)
 d02bb08:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 d02bb0c:	e0bffd17 	ldw	r2,-12(fp)
 d02bb10:	10c00217 	ldw	r3,8(r2)
 d02bb14:	e0bff817 	ldw	r2,-32(fp)
 d02bb18:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 d02bb1c:	e0bffd17 	ldw	r2,-12(fp)
 d02bb20:	10c00317 	ldw	r3,12(r2)
 d02bb24:	e0bff817 	ldw	r2,-32(fp)
 d02bb28:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 d02bb2c:	e0bffd17 	ldw	r2,-12(fp)
 d02bb30:	10c00417 	ldw	r3,16(r2)
 d02bb34:	e0bff817 	ldw	r2,-32(fp)
 d02bb38:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 d02bb3c:	e0bff717 	ldw	r2,-36(fp)
 d02bb40:	10800417 	ldw	r2,16(r2)
 d02bb44:	1088000c 	andi	r2,r2,8192
 d02bb48:	1004c03a 	cmpne	r2,r2,zero
 d02bb4c:	1000141e 	bne	r2,zero,d02bba0 <rawip_soinput+0x13c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 d02bb50:	e0bffd17 	ldw	r2,-12(fp)
 d02bb54:	10800317 	ldw	r2,12(r2)
 d02bb58:	10800003 	ldbu	r2,0(r2)
 d02bb5c:	10803fcc 	andi	r2,r2,255
 d02bb60:	108003cc 	andi	r2,r2,15
 d02bb64:	1085883a 	add	r2,r2,r2
 d02bb68:	1085883a 	add	r2,r2,r2
 d02bb6c:	e0bff615 	stw	r2,-40(fp)
      m_in->m_data += ihl;
 d02bb70:	e0bff817 	ldw	r2,-32(fp)
 d02bb74:	10c00317 	ldw	r3,12(r2)
 d02bb78:	e0bff617 	ldw	r2,-40(fp)
 d02bb7c:	1887883a 	add	r3,r3,r2
 d02bb80:	e0bff817 	ldw	r2,-32(fp)
 d02bb84:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 d02bb88:	e0bff817 	ldw	r2,-32(fp)
 d02bb8c:	10c00217 	ldw	r3,8(r2)
 d02bb90:	e0bff617 	ldw	r2,-40(fp)
 d02bb94:	1887c83a 	sub	r3,r3,r2
 d02bb98:	e0bff817 	ldw	r2,-32(fp)
 d02bb9c:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 d02bba0:	e0bffd17 	ldw	r2,-12(fp)
 d02bba4:	10800717 	ldw	r2,28(r2)
 d02bba8:	e0bffa15 	stw	r2,-24(fp)
   sin.sin_port = 0;
 d02bbac:	e03ff98d 	sth	zero,-26(fp)
   sin.sin_family = AF_INET;
 d02bbb0:	00800084 	movi	r2,2
 d02bbb4:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 d02bbb8:	e0bff717 	ldw	r2,-36(fp)
 d02bbbc:	11000a04 	addi	r4,r2,40
 d02bbc0:	e17ff904 	addi	r5,fp,-28
 d02bbc4:	e1bff817 	ldw	r6,-32(fp)
 d02bbc8:	d030ab40 	call	d030ab4 <sbappendaddr>
 d02bbcc:	1004c03a 	cmpne	r2,r2,zero
 d02bbd0:	1000091e 	bne	r2,zero,d02bbf8 <rawip_soinput+0x194>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 d02bbd4:	e0bff817 	ldw	r2,-32(fp)
 d02bbd8:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 d02bbdc:	e13ff817 	ldw	r4,-32(fp)
 d02bbe0:	d02a3900 	call	d02a390 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02bbe4:	0009883a 	mov	r4,zero
 d02bbe8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d02bbec:	00801a44 	movi	r2,105
 d02bbf0:	e0bfff15 	stw	r2,-4(fp)
 d02bbf4:	00000a06 	br	d02bc20 <rawip_soinput+0x1bc>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 d02bbf8:	e0bff717 	ldw	r2,-36(fp)
 d02bbfc:	11000a04 	addi	r4,r2,40
 d02bc00:	d02515c0 	call	d02515c <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 d02bc04:	e0bff717 	ldw	r2,-36(fp)
 d02bc08:	11400a04 	addi	r5,r2,40
 d02bc0c:	e13ff717 	ldw	r4,-36(fp)
 d02bc10:	d0307680 	call	d030768 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 d02bc14:	0009883a 	mov	r4,zero
 d02bc18:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return 0;
 d02bc1c:	e03fff15 	stw	zero,-4(fp)
 d02bc20:	e0bfff17 	ldw	r2,-4(fp)
}
 d02bc24:	e037883a 	mov	sp,fp
 d02bc28:	dfc00117 	ldw	ra,4(sp)
 d02bc2c:	df000017 	ldw	fp,0(sp)
 d02bc30:	dec00204 	addi	sp,sp,8
 d02bc34:	f800283a 	ret

0d02bc38 <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 d02bc38:	deffee04 	addi	sp,sp,-72
 d02bc3c:	dfc01115 	stw	ra,68(sp)
 d02bc40:	df001015 	stw	fp,64(sp)
 d02bc44:	dc000f15 	stw	r16,60(sp)
 d02bc48:	df000f04 	addi	fp,sp,60
 d02bc4c:	e13ffc15 	stw	r4,-16(fp)
 d02bc50:	e17ffd15 	stw	r5,-12(fp)
 d02bc54:	e1bffe15 	stw	r6,-8(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 d02bc58:	e0bffc17 	ldw	r2,-16(fp)
 d02bc5c:	10800717 	ldw	r2,28(r2)
 d02bc60:	e0bff315 	stw	r2,-52(fp)

   switch (req) 
 d02bc64:	e0bff317 	ldw	r2,-52(fp)
 d02bc68:	10800468 	cmpgeui	r2,r2,17
 d02bc6c:	1001e31e 	bne	r2,zero,d02c3fc <rawip_usrreq+0x7c4>
 d02bc70:	e0bff317 	ldw	r2,-52(fp)
 d02bc74:	1085883a 	add	r2,r2,r2
 d02bc78:	1087883a 	add	r3,r2,r2
 d02bc7c:	008340f4 	movhi	r2,3331
 d02bc80:	10af2404 	addi	r2,r2,-17264
 d02bc84:	1885883a 	add	r2,r3,r2
 d02bc88:	10800017 	ldw	r2,0(r2)
 d02bc8c:	1000683a 	jmp	r2
 d02bc90:	0d02bcd4 	ori	r20,at,2803
 d02bc94:	0d02bd5c 	xori	r20,at,2805
 d02bc98:	0d02bda0 	cmpeqi	r20,at,2806
 d02bc9c:	0d02c3fc 	xorhi	r20,at,2831
 d02bca0:	0d02bda0 	cmpeqi	r20,at,2806
 d02bca4:	0d02c3fc 	xorhi	r20,at,2831
 d02bca8:	0d02c3f0 	cmpltui	r20,at,2831
 d02bcac:	0d02c3fc 	xorhi	r20,at,2831
 d02bcb0:	0d02c3f0 	cmpltui	r20,at,2831
 d02bcb4:	0d02bf54 	ori	r20,at,2813
 d02bcb8:	0d02c3fc 	xorhi	r20,at,2831
 d02bcbc:	0d02c3fc 	xorhi	r20,at,2831
 d02bcc0:	0d02c3fc 	xorhi	r20,at,2831
 d02bcc4:	0d02c3fc 	xorhi	r20,at,2831
 d02bcc8:	0d02c3fc 	xorhi	r20,at,2831
 d02bccc:	0d02c344 	addi	r20,at,2829
 d02bcd0:	0d02c344 	addi	r20,at,2829
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 d02bcd4:	e0bffc17 	ldw	r2,-16(fp)
 d02bcd8:	10800417 	ldw	r2,16(r2)
 d02bcdc:	1108000c 	andi	r4,r2,8192
 d02bce0:	d0421440 	call	d042144 <ip_raw_maxalloc>
 d02bce4:	1007883a 	mov	r3,r2
 d02bce8:	e0bffc17 	ldw	r2,-16(fp)
 d02bcec:	10c01315 	stw	r3,76(r2)
 d02bcf0:	e0bffc17 	ldw	r2,-16(fp)
 d02bcf4:	10c01317 	ldw	r3,76(r2)
 d02bcf8:	e0bffc17 	ldw	r2,-16(fp)
 d02bcfc:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 d02bd00:	e0bffe17 	ldw	r2,-8(fp)
 d02bd04:	e0bff505 	stb	r2,-44(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02bd08:	0009883a 	mov	r4,zero
 d02bd0c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 d02bd10:	e13ff503 	ldbu	r4,-44(fp)
 d02bd14:	e0bffc17 	ldw	r2,-16(fp)
 d02bd18:	d8800015 	stw	r2,0(sp)
 d02bd1c:	000b883a 	mov	r5,zero
 d02bd20:	000d883a 	mov	r6,zero
 d02bd24:	01c340f4 	movhi	r7,3331
 d02bd28:	39ee9904 	addi	r7,r7,-17820
 d02bd2c:	d041c500 	call	d041c50 <ip_raw_open>
 d02bd30:	e0bff815 	stw	r2,-32(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 d02bd34:	0009883a 	mov	r4,zero
 d02bd38:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      if (!ep)
 d02bd3c:	e0bff817 	ldw	r2,-32(fp)
 d02bd40:	1004c03a 	cmpne	r2,r2,zero
 d02bd44:	1000031e 	bne	r2,zero,d02bd54 <rawip_usrreq+0x11c>
         return(EINVAL);
 d02bd48:	00800584 	movi	r2,22
 d02bd4c:	e0bfff15 	stw	r2,-4(fp)
 d02bd50:	0001ac06 	br	d02c404 <rawip_usrreq+0x7cc>
      return 0;
 d02bd54:	e03fff15 	stw	zero,-4(fp)
 d02bd58:	0001aa06 	br	d02c404 <rawip_usrreq+0x7cc>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 d02bd5c:	e13ffc17 	ldw	r4,-16(fp)
 d02bd60:	d02b9f40 	call	d02b9f4 <rawip_lookup>
 d02bd64:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 d02bd68:	e0bff817 	ldw	r2,-32(fp)
 d02bd6c:	1004c03a 	cmpne	r2,r2,zero
 d02bd70:	1000031e 	bne	r2,zero,d02bd80 <rawip_usrreq+0x148>
         return(EINVAL);
 d02bd74:	00800584 	movi	r2,22
 d02bd78:	e0bfff15 	stw	r2,-4(fp)
 d02bd7c:	0001a106 	br	d02c404 <rawip_usrreq+0x7cc>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02bd80:	0009883a 	mov	r4,zero
 d02bd84:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 d02bd88:	e13ff817 	ldw	r4,-32(fp)
 d02bd8c:	d041d400 	call	d041d40 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 d02bd90:	0009883a 	mov	r4,zero
 d02bd94:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      return 0;
 d02bd98:	e03fff15 	stw	zero,-4(fp)
 d02bd9c:	00019906 	br	d02c404 <rawip_usrreq+0x7cc>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 d02bda0:	e0bffe17 	ldw	r2,-8(fp)
 d02bda4:	1004c03a 	cmpne	r2,r2,zero
 d02bda8:	1000031e 	bne	r2,zero,d02bdb8 <rawip_usrreq+0x180>
         return(EINVAL);
 d02bdac:	00800584 	movi	r2,22
 d02bdb0:	e0bfff15 	stw	r2,-4(fp)
 d02bdb4:	00019306 	br	d02c404 <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 d02bdb8:	e0bffe17 	ldw	r2,-8(fp)
 d02bdbc:	10800317 	ldw	r2,12(r2)
 d02bdc0:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 d02bdc4:	e0bff917 	ldw	r2,-28(fp)
 d02bdc8:	1004c03a 	cmpne	r2,r2,zero
 d02bdcc:	1000031e 	bne	r2,zero,d02bddc <rawip_usrreq+0x1a4>
         return(EINVAL);
 d02bdd0:	00800584 	movi	r2,22
 d02bdd4:	e0bfff15 	stw	r2,-4(fp)
 d02bdd8:	00018a06 	br	d02c404 <rawip_usrreq+0x7cc>
      if (nam->m_len != sizeof (*sin))
 d02bddc:	e0bffe17 	ldw	r2,-8(fp)
 d02bde0:	10800217 	ldw	r2,8(r2)
 d02bde4:	10800420 	cmpeqi	r2,r2,16
 d02bde8:	1000031e 	bne	r2,zero,d02bdf8 <rawip_usrreq+0x1c0>
         return(EINVAL);
 d02bdec:	00800584 	movi	r2,22
 d02bdf0:	e0bfff15 	stw	r2,-4(fp)
 d02bdf4:	00018306 	br	d02c404 <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 d02bdf8:	e13ffc17 	ldw	r4,-16(fp)
 d02bdfc:	d02b9f40 	call	d02b9f4 <rawip_lookup>
 d02be00:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 d02be04:	e0bff817 	ldw	r2,-32(fp)
 d02be08:	1004c03a 	cmpne	r2,r2,zero
 d02be0c:	1000031e 	bne	r2,zero,d02be1c <rawip_usrreq+0x1e4>
         return(EINVAL);
 d02be10:	00800584 	movi	r2,22
 d02be14:	e0bfff15 	stw	r2,-4(fp)
 d02be18:	00017a06 	br	d02c404 <rawip_usrreq+0x7cc>
      if (req == PRU_BIND)
 d02be1c:	e0bff317 	ldw	r2,-52(fp)
 d02be20:	10800098 	cmpnei	r2,r2,2
 d02be24:	1000221e 	bne	r2,zero,d02beb0 <rawip_usrreq+0x278>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 d02be28:	e0bff917 	ldw	r2,-28(fp)
 d02be2c:	10800117 	ldw	r2,4(r2)
 d02be30:	1004c03a 	cmpne	r2,r2,zero
 d02be34:	1000021e 	bne	r2,zero,d02be40 <rawip_usrreq+0x208>
         {
            lhost = 0L;
 d02be38:	e03ff615 	stw	zero,-40(fp)
 d02be3c:	00001806 	br	d02bea0 <rawip_usrreq+0x268>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 d02be40:	e0bff917 	ldw	r2,-28(fp)
 d02be44:	10800117 	ldw	r2,4(r2)
 d02be48:	e0bff615 	stw	r2,-40(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d02be4c:	008341b4 	movhi	r2,3334
 d02be50:	10b4e604 	addi	r2,r2,-11368
 d02be54:	10800017 	ldw	r2,0(r2)
 d02be58:	e0bff215 	stw	r2,-56(fp)
 d02be5c:	00000706 	br	d02be7c <rawip_usrreq+0x244>
               if (ifp->n_ipaddr == lhost)
 d02be60:	e0bff217 	ldw	r2,-56(fp)
 d02be64:	10c00a17 	ldw	r3,40(r2)
 d02be68:	e0bff617 	ldw	r2,-40(fp)
 d02be6c:	18800626 	beq	r3,r2,d02be88 <rawip_usrreq+0x250>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d02be70:	e0bff217 	ldw	r2,-56(fp)
 d02be74:	10800017 	ldw	r2,0(r2)
 d02be78:	e0bff215 	stw	r2,-56(fp)
 d02be7c:	e0bff217 	ldw	r2,-56(fp)
 d02be80:	1004c03a 	cmpne	r2,r2,zero
 d02be84:	103ff61e 	bne	r2,zero,d02be60 <rawip_usrreq+0x228>
               if (ifp->n_ipaddr == lhost)
                  break;
            if (ifp == NULL)
 d02be88:	e0bff217 	ldw	r2,-56(fp)
 d02be8c:	1004c03a 	cmpne	r2,r2,zero
 d02be90:	1000031e 	bne	r2,zero,d02bea0 <rawip_usrreq+0x268>
               return(EADDRNOTAVAIL);
 d02be94:	00801f44 	movi	r2,125
 d02be98:	e0bfff15 	stw	r2,-4(fp)
 d02be9c:	00015906 	br	d02c404 <rawip_usrreq+0x7cc>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 d02bea0:	e0fff817 	ldw	r3,-32(fp)
 d02bea4:	e0bff617 	ldw	r2,-40(fp)
 d02bea8:	18800115 	stw	r2,4(r3)
 d02beac:	00002706 	br	d02bf4c <rawip_usrreq+0x314>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 d02beb0:	e0bff917 	ldw	r2,-28(fp)
 d02beb4:	10800117 	ldw	r2,4(r2)
 d02beb8:	1004c03a 	cmpne	r2,r2,zero
 d02bebc:	1000021e 	bne	r2,zero,d02bec8 <rawip_usrreq+0x290>
            fhost = 0L;
 d02bec0:	e03ff715 	stw	zero,-36(fp)
 d02bec4:	00000306 	br	d02bed4 <rawip_usrreq+0x29c>
         else
            fhost = sin->sin_addr.s_addr;
 d02bec8:	e0bff917 	ldw	r2,-28(fp)
 d02becc:	10800117 	ldw	r2,4(r2)
 d02bed0:	e0bff715 	stw	r2,-36(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 d02bed4:	e0fff817 	ldw	r3,-32(fp)
 d02bed8:	e0bff717 	ldw	r2,-36(fp)
 d02bedc:	18800215 	stw	r2,8(r3)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 d02bee0:	e0bff717 	ldw	r2,-36(fp)
 d02bee4:	1005003a 	cmpeq	r2,r2,zero
 d02bee8:	10000e1e 	bne	r2,zero,d02bf24 <rawip_usrreq+0x2ec>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 d02beec:	e0bffc17 	ldw	r2,-16(fp)
 d02bef0:	10c0088b 	ldhu	r3,34(r2)
 d02bef4:	00bffcc4 	movi	r2,-13
 d02bef8:	1884703a 	and	r2,r3,r2
 d02befc:	1007883a 	mov	r3,r2
 d02bf00:	e0bffc17 	ldw	r2,-16(fp)
 d02bf04:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 d02bf08:	e0bffc17 	ldw	r2,-16(fp)
 d02bf0c:	1080088b 	ldhu	r2,34(r2)
 d02bf10:	10800094 	ori	r2,r2,2
 d02bf14:	1007883a 	mov	r3,r2
 d02bf18:	e0bffc17 	ldw	r2,-16(fp)
 d02bf1c:	10c0088d 	sth	r3,34(r2)
 d02bf20:	00000706 	br	d02bf40 <rawip_usrreq+0x308>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 d02bf24:	e0bffc17 	ldw	r2,-16(fp)
 d02bf28:	10c0088b 	ldhu	r3,34(r2)
 d02bf2c:	00bfff44 	movi	r2,-3
 d02bf30:	1884703a 	and	r2,r3,r2
 d02bf34:	1007883a 	mov	r3,r2
 d02bf38:	e0bffc17 	ldw	r2,-16(fp)
 d02bf3c:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 d02bf40:	e0bffc17 	ldw	r2,-16(fp)
 d02bf44:	11000a04 	addi	r4,r2,40
 d02bf48:	d030ea40 	call	d030ea4 <sbflush>
      }
      return 0;
 d02bf4c:	e03fff15 	stw	zero,-4(fp)
 d02bf50:	00012c06 	br	d02c404 <rawip_usrreq+0x7cc>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 d02bf54:	e0bffd17 	ldw	r2,-12(fp)
 d02bf58:	1004c03a 	cmpne	r2,r2,zero
 d02bf5c:	1000031e 	bne	r2,zero,d02bf6c <rawip_usrreq+0x334>
         return(EINVAL);
 d02bf60:	00800584 	movi	r2,22
 d02bf64:	e0bfff15 	stw	r2,-4(fp)
 d02bf68:	00012606 	br	d02c404 <rawip_usrreq+0x7cc>

      ep = rawip_lookup(so);
 d02bf6c:	e13ffc17 	ldw	r4,-16(fp)
 d02bf70:	d02b9f40 	call	d02b9f4 <rawip_lookup>
 d02bf74:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 d02bf78:	e0bff817 	ldw	r2,-32(fp)
 d02bf7c:	1004c03a 	cmpne	r2,r2,zero
 d02bf80:	1000051e 	bne	r2,zero,d02bf98 <rawip_usrreq+0x360>
      {
         m_free(m);
 d02bf84:	e13ffd17 	ldw	r4,-12(fp)
 d02bf88:	d02a3900 	call	d02a390 <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 d02bf8c:	00801bc4 	movi	r2,111
 d02bf90:	e0bfff15 	stw	r2,-4(fp)
 d02bf94:	00011b06 	br	d02c404 <rawip_usrreq+0x7cc>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 d02bf98:	e0bffe17 	ldw	r2,-8(fp)
 d02bf9c:	1004c03a 	cmpne	r2,r2,zero
 d02bfa0:	10000d1e 	bne	r2,zero,d02bfd8 <rawip_usrreq+0x3a0>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 d02bfa4:	e0bffc17 	ldw	r2,-16(fp)
 d02bfa8:	1080088b 	ldhu	r2,34(r2)
 d02bfac:	10bfffcc 	andi	r2,r2,65535
 d02bfb0:	1080008c 	andi	r2,r2,2
 d02bfb4:	1004c03a 	cmpne	r2,r2,zero
 d02bfb8:	1000031e 	bne	r2,zero,d02bfc8 <rawip_usrreq+0x390>
            return (ENOTCONN);
 d02bfbc:	00802004 	movi	r2,128
 d02bfc0:	e0bfff15 	stw	r2,-4(fp)
 d02bfc4:	00010f06 	br	d02c404 <rawip_usrreq+0x7cc>
         fhost = ep->ipr_faddr;
 d02bfc8:	e0bff817 	ldw	r2,-32(fp)
 d02bfcc:	10800217 	ldw	r2,8(r2)
 d02bfd0:	e0bff715 	stw	r2,-36(fp)
 d02bfd4:	00001706 	br	d02c034 <rawip_usrreq+0x3fc>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 d02bfd8:	e0bffc17 	ldw	r2,-16(fp)
 d02bfdc:	1080088b 	ldhu	r2,34(r2)
 d02bfe0:	10bfffcc 	andi	r2,r2,65535
 d02bfe4:	1080008c 	andi	r2,r2,2
 d02bfe8:	1005003a 	cmpeq	r2,r2,zero
 d02bfec:	1000031e 	bne	r2,zero,d02bffc <rawip_usrreq+0x3c4>
            return (EISCONN);
 d02bff0:	00801fc4 	movi	r2,127
 d02bff4:	e0bfff15 	stw	r2,-4(fp)
 d02bff8:	00010206 	br	d02c404 <rawip_usrreq+0x7cc>
         if (nam->m_len != sizeof (*sin))
 d02bffc:	e0bffe17 	ldw	r2,-8(fp)
 d02c000:	10800217 	ldw	r2,8(r2)
 d02c004:	10800420 	cmpeqi	r2,r2,16
 d02c008:	1000041e 	bne	r2,zero,d02c01c <rawip_usrreq+0x3e4>
         {
            dtrap();
 d02c00c:	d0293e80 	call	d0293e8 <dtrap>
            return (EINVAL);
 d02c010:	00800584 	movi	r2,22
 d02c014:	e0bfff15 	stw	r2,-4(fp)
 d02c018:	0000fa06 	br	d02c404 <rawip_usrreq+0x7cc>
         }
         sin = mtod(nam, struct sockaddr_in *);
 d02c01c:	e0bffe17 	ldw	r2,-8(fp)
 d02c020:	10800317 	ldw	r2,12(r2)
 d02c024:	e0bff915 	stw	r2,-28(fp)
         fhost = sin->sin_addr.s_addr;
 d02c028:	e0bff917 	ldw	r2,-28(fp)
 d02c02c:	10800117 	ldw	r2,4(r2)
 d02c030:	e0bff715 	stw	r2,-36(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 d02c034:	e0bffd17 	ldw	r2,-12(fp)
 d02c038:	14000217 	ldw	r16,8(r2)
 d02c03c:	e0bffc17 	ldw	r2,-16(fp)
 d02c040:	10800417 	ldw	r2,16(r2)
 d02c044:	1108000c 	andi	r4,r2,8192
 d02c048:	d0421440 	call	d042144 <ip_raw_maxalloc>
 d02c04c:	1400042e 	bgeu	r2,r16,d02c060 <rawip_usrreq+0x428>
      {
         dtrap(); /* should never happen */
 d02c050:	d0293e80 	call	d0293e8 <dtrap>
         return EMSGSIZE;  /* try to recover */
 d02c054:	00801e84 	movi	r2,122
 d02c058:	e0bfff15 	stw	r2,-4(fp)
 d02c05c:	0000e906 	br	d02c404 <rawip_usrreq+0x7cc>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 d02c060:	e0bffd17 	ldw	r2,-12(fp)
 d02c064:	10800217 	ldw	r2,8(r2)
 d02c068:	1009883a 	mov	r4,r2
 d02c06c:	e0bffc17 	ldw	r2,-16(fp)
 d02c070:	10800417 	ldw	r2,16(r2)
 d02c074:	1148000c 	andi	r5,r2,8192
 d02c078:	d0420380 	call	d042038 <ip_raw_alloc>
 d02c07c:	e0bffa15 	stw	r2,-24(fp)
      if (!pkt)
 d02c080:	e0bffa17 	ldw	r2,-24(fp)
 d02c084:	1004c03a 	cmpne	r2,r2,zero
 d02c088:	1000051e 	bne	r2,zero,d02c0a0 <rawip_usrreq+0x468>
      {
         m_free(m);
 d02c08c:	e13ffd17 	ldw	r4,-12(fp)
 d02c090:	d02a3900 	call	d02a390 <m_free>
         return ENOBUFS;   /* report buffer shortages */
 d02c094:	00801a44 	movi	r2,105
 d02c098:	e0bfff15 	stw	r2,-4(fp)
 d02c09c:	0000d906 	br	d02c404 <rawip_usrreq+0x7cc>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 d02c0a0:	e0bffa17 	ldw	r2,-24(fp)
 d02c0a4:	10c00317 	ldw	r3,12(r2)
 d02c0a8:	e0bffd17 	ldw	r2,-12(fp)
 d02c0ac:	11400317 	ldw	r5,12(r2)
 d02c0b0:	e0bffd17 	ldw	r2,-12(fp)
 d02c0b4:	10800217 	ldw	r2,8(r2)
 d02c0b8:	1809883a 	mov	r4,r3
 d02c0bc:	100d883a 	mov	r6,r2
 d02c0c0:	d0027000 	call	d002700 <memcpy>
      pkt->nb_plen = m->m_len;
 d02c0c4:	e0bffd17 	ldw	r2,-12(fp)
 d02c0c8:	10c00217 	ldw	r3,8(r2)
 d02c0cc:	e0bffa17 	ldw	r2,-24(fp)
 d02c0d0:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 d02c0d4:	e13ffd17 	ldw	r4,-12(fp)
 d02c0d8:	d02a3900 	call	d02a390 <m_free>
      pkt->fhost = fhost;
 d02c0dc:	e0fffa17 	ldw	r3,-24(fp)
 d02c0e0:	e0bff717 	ldw	r2,-36(fp)
 d02c0e4:	18800715 	stw	r2,28(r3)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 d02c0e8:	e0bff717 	ldw	r2,-36(fp)
 d02c0ec:	10bfffd8 	cmpnei	r2,r2,-1
 d02c0f0:	10004f1e 	bne	r2,zero,d02c230 <rawip_usrreq+0x5f8>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 d02c0f4:	e0bff817 	ldw	r2,-32(fp)
 d02c0f8:	10800117 	ldw	r2,4(r2)
 d02c0fc:	1005003a 	cmpeq	r2,r2,zero
 d02c100:	1000111e 	bne	r2,zero,d02c148 <rawip_usrreq+0x510>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d02c104:	008341b4 	movhi	r2,3334
 d02c108:	10b4e604 	addi	r2,r2,-11368
 d02c10c:	10800017 	ldw	r2,0(r2)
 d02c110:	e0bff215 	stw	r2,-56(fp)
 d02c114:	00000806 	br	d02c138 <rawip_usrreq+0x500>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 d02c118:	e0bff217 	ldw	r2,-56(fp)
 d02c11c:	10c00a17 	ldw	r3,40(r2)
 d02c120:	e0bff817 	ldw	r2,-32(fp)
 d02c124:	10800117 	ldw	r2,4(r2)
 d02c128:	18802126 	beq	r3,r2,d02c1b0 <rawip_usrreq+0x578>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d02c12c:	e0bff217 	ldw	r2,-56(fp)
 d02c130:	10800017 	ldw	r2,0(r2)
 d02c134:	e0bff215 	stw	r2,-56(fp)
 d02c138:	e0bff217 	ldw	r2,-56(fp)
 d02c13c:	1004c03a 	cmpne	r2,r2,zero
 d02c140:	103ff51e 	bne	r2,zero,d02c118 <rawip_usrreq+0x4e0>
 d02c144:	00001a06 	br	d02c1b0 <rawip_usrreq+0x578>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d02c148:	008341b4 	movhi	r2,3334
 d02c14c:	10b4e604 	addi	r2,r2,-11368
 d02c150:	10800017 	ldw	r2,0(r2)
 d02c154:	e0bff215 	stw	r2,-56(fp)
 d02c158:	00001206 	br	d02c1a4 <rawip_usrreq+0x56c>
               if ((ifp->n_flags & NF_BCAST) &&
 d02c15c:	e0bff217 	ldw	r2,-56(fp)
 d02c160:	10802a17 	ldw	r2,168(r2)
 d02c164:	1080004c 	andi	r2,r2,1
 d02c168:	10803fcc 	andi	r2,r2,255
 d02c16c:	1005003a 	cmpeq	r2,r2,zero
 d02c170:	1000091e 	bne	r2,zero,d02c198 <rawip_usrreq+0x560>
 d02c174:	e0bff217 	ldw	r2,-56(fp)
 d02c178:	10802717 	ldw	r2,156(r2)
 d02c17c:	1005003a 	cmpeq	r2,r2,zero
 d02c180:	1000051e 	bne	r2,zero,d02c198 <rawip_usrreq+0x560>
 d02c184:	e0bff217 	ldw	r2,-56(fp)
 d02c188:	10802717 	ldw	r2,156(r2)
 d02c18c:	10800617 	ldw	r2,24(r2)
 d02c190:	10800060 	cmpeqi	r2,r2,1
 d02c194:	1000061e 	bne	r2,zero,d02c1b0 <rawip_usrreq+0x578>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d02c198:	e0bff217 	ldw	r2,-56(fp)
 d02c19c:	10800017 	ldw	r2,0(r2)
 d02c1a0:	e0bff215 	stw	r2,-56(fp)
 d02c1a4:	e0bff217 	ldw	r2,-56(fp)
 d02c1a8:	1004c03a 	cmpne	r2,r2,zero
 d02c1ac:	103feb1e 	bne	r2,zero,d02c15c <rawip_usrreq+0x524>
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
 d02c1b0:	e0bff217 	ldw	r2,-56(fp)
 d02c1b4:	1004c03a 	cmpne	r2,r2,zero
 d02c1b8:	10001a1e 	bne	r2,zero,d02c224 <rawip_usrreq+0x5ec>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d02c1bc:	008341b4 	movhi	r2,3334
 d02c1c0:	10b4e604 	addi	r2,r2,-11368
 d02c1c4:	10800017 	ldw	r2,0(r2)
 d02c1c8:	e0bff215 	stw	r2,-56(fp)
 d02c1cc:	00000c06 	br	d02c200 <rawip_usrreq+0x5c8>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 d02c1d0:	e0bff217 	ldw	r2,-56(fp)
 d02c1d4:	10802717 	ldw	r2,156(r2)
 d02c1d8:	1005003a 	cmpeq	r2,r2,zero
 d02c1dc:	1000051e 	bne	r2,zero,d02c1f4 <rawip_usrreq+0x5bc>
 d02c1e0:	e0bff217 	ldw	r2,-56(fp)
 d02c1e4:	10802717 	ldw	r2,156(r2)
 d02c1e8:	10800617 	ldw	r2,24(r2)
 d02c1ec:	10800060 	cmpeqi	r2,r2,1
 d02c1f0:	1000061e 	bne	r2,zero,d02c20c <rawip_usrreq+0x5d4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d02c1f4:	e0bff217 	ldw	r2,-56(fp)
 d02c1f8:	10800017 	ldw	r2,0(r2)
 d02c1fc:	e0bff215 	stw	r2,-56(fp)
 d02c200:	e0bff217 	ldw	r2,-56(fp)
 d02c204:	1004c03a 	cmpne	r2,r2,zero
 d02c208:	103ff11e 	bne	r2,zero,d02c1d0 <rawip_usrreq+0x598>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
            if (ifp == NULL)
 d02c20c:	e0bff217 	ldw	r2,-56(fp)
 d02c210:	1004c03a 	cmpne	r2,r2,zero
 d02c214:	1000031e 	bne	r2,zero,d02c224 <rawip_usrreq+0x5ec>
               return(EADDRNOTAVAIL);
 d02c218:	00801f44 	movi	r2,125
 d02c21c:	e0bfff15 	stw	r2,-4(fp)
 d02c220:	00007806 	br	d02c404 <rawip_usrreq+0x7cc>
         }
         pkt->net = ifp;
 d02c224:	e0fffa17 	ldw	r3,-24(fp)
 d02c228:	e0bff217 	ldw	r2,-56(fp)
 d02c22c:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 d02c230:	e0bffc17 	ldw	r2,-16(fp)
 d02c234:	10800317 	ldw	r2,12(r2)
 d02c238:	1005003a 	cmpeq	r2,r2,zero
 d02c23c:	1000041e 	bne	r2,zero,d02c250 <rawip_usrreq+0x618>
         pkt->imo = so->inp_moptions;
 d02c240:	e0bffc17 	ldw	r2,-16(fp)
 d02c244:	10c00317 	ldw	r3,12(r2)
 d02c248:	e0bffa17 	ldw	r2,-24(fp)
 d02c24c:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 d02c250:	e0bffc17 	ldw	r2,-16(fp)
 d02c254:	10800417 	ldw	r2,16(r2)
 d02c258:	1088000c 	andi	r2,r2,8192
 d02c25c:	1005003a 	cmpeq	r2,r2,zero
 d02c260:	1000081e 	bne	r2,zero,d02c284 <rawip_usrreq+0x64c>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 d02c264:	0009883a 	mov	r4,zero
 d02c268:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 d02c26c:	e13ffa17 	ldw	r4,-24(fp)
 d02c270:	d03da1c0 	call	d03da1c <ip_raw_write>
 d02c274:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 d02c278:	0009883a 	mov	r4,zero
 d02c27c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
 d02c280:	00002806 	br	d02c324 <rawip_usrreq+0x6ec>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 d02c284:	e0bffa17 	ldw	r2,-24(fp)
 d02c288:	10800317 	ldw	r2,12(r2)
 d02c28c:	10bffb04 	addi	r2,r2,-20
 d02c290:	e0bff415 	stw	r2,-48(fp)
         if (ep->ipr_laddr)
 d02c294:	e0bff817 	ldw	r2,-32(fp)
 d02c298:	10800117 	ldw	r2,4(r2)
 d02c29c:	1005003a 	cmpeq	r2,r2,zero
 d02c2a0:	1000051e 	bne	r2,zero,d02c2b8 <rawip_usrreq+0x680>
            pip->ip_src = ep->ipr_laddr;
 d02c2a4:	e0bff817 	ldw	r2,-32(fp)
 d02c2a8:	10c00117 	ldw	r3,4(r2)
 d02c2ac:	e0bff417 	ldw	r2,-48(fp)
 d02c2b0:	10c00315 	stw	r3,12(r2)
 d02c2b4:	00000e06 	br	d02c2f0 <rawip_usrreq+0x6b8>
         else
         {
            if (fhost == 0xffffffff)
 d02c2b8:	e0bff717 	ldw	r2,-36(fp)
 d02c2bc:	10bfffd8 	cmpnei	r2,r2,-1
 d02c2c0:	1000061e 	bne	r2,zero,d02c2dc <rawip_usrreq+0x6a4>
               pip->ip_src = pkt->net->n_ipaddr;
 d02c2c4:	e0bffa17 	ldw	r2,-24(fp)
 d02c2c8:	10800617 	ldw	r2,24(r2)
 d02c2cc:	10c00a17 	ldw	r3,40(r2)
 d02c2d0:	e0bff417 	ldw	r2,-48(fp)
 d02c2d4:	10c00315 	stw	r3,12(r2)
 d02c2d8:	00000506 	br	d02c2f0 <rawip_usrreq+0x6b8>
            else
               pip->ip_src = ip_mymach(fhost);
 d02c2dc:	e13ff717 	ldw	r4,-36(fp)
 d02c2e0:	d03e5a80 	call	d03e5a8 <ip_mymach>
 d02c2e4:	1007883a 	mov	r3,r2
 d02c2e8:	e0bff417 	ldw	r2,-48(fp)
 d02c2ec:	10c00315 	stw	r3,12(r2)
         }
         pip->ip_dest = fhost;
 d02c2f0:	e0fff417 	ldw	r3,-48(fp)
 d02c2f4:	e0bff717 	ldw	r2,-36(fp)
 d02c2f8:	18800415 	stw	r2,16(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 d02c2fc:	0009883a 	mov	r4,zero
 d02c300:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 d02c304:	e0bff817 	ldw	r2,-32(fp)
 d02c308:	10800503 	ldbu	r2,20(r2)
 d02c30c:	11003fcc 	andi	r4,r2,255
 d02c310:	e17ffa17 	ldw	r5,-24(fp)
 d02c314:	d03d4240 	call	d03d424 <ip_write>
 d02c318:	e0bffb15 	stw	r2,-20(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 d02c31c:	0009883a 	mov	r4,zero
 d02c320:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 d02c324:	e0bffb17 	ldw	r2,-20(fp)
 d02c328:	1004403a 	cmpge	r2,r2,zero
 d02c32c:	1000031e 	bne	r2,zero,d02c33c <rawip_usrreq+0x704>
         return(e);
 d02c330:	e0bffb17 	ldw	r2,-20(fp)
 d02c334:	e0bfff15 	stw	r2,-4(fp)
 d02c338:	00003206 	br	d02c404 <rawip_usrreq+0x7cc>
      return 0;
 d02c33c:	e03fff15 	stw	zero,-4(fp)
 d02c340:	00003006 	br	d02c404 <rawip_usrreq+0x7cc>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 d02c344:	e0bffe17 	ldw	r2,-8(fp)
 d02c348:	1004c03a 	cmpne	r2,r2,zero
 d02c34c:	1000031e 	bne	r2,zero,d02c35c <rawip_usrreq+0x724>
         return(EINVAL);
 d02c350:	00800584 	movi	r2,22
 d02c354:	e0bfff15 	stw	r2,-4(fp)
 d02c358:	00002a06 	br	d02c404 <rawip_usrreq+0x7cc>
      sin = mtod(nam, struct sockaddr_in *);
 d02c35c:	e0bffe17 	ldw	r2,-8(fp)
 d02c360:	10800317 	ldw	r2,12(r2)
 d02c364:	e0bff915 	stw	r2,-28(fp)
      if (sin == NULL)
 d02c368:	e0bff917 	ldw	r2,-28(fp)
 d02c36c:	1004c03a 	cmpne	r2,r2,zero
 d02c370:	1000031e 	bne	r2,zero,d02c380 <rawip_usrreq+0x748>
         return(EINVAL);
 d02c374:	00800584 	movi	r2,22
 d02c378:	e0bfff15 	stw	r2,-4(fp)
 d02c37c:	00002106 	br	d02c404 <rawip_usrreq+0x7cc>
      ep = rawip_lookup(so);
 d02c380:	e13ffc17 	ldw	r4,-16(fp)
 d02c384:	d02b9f40 	call	d02b9f4 <rawip_lookup>
 d02c388:	e0bff815 	stw	r2,-32(fp)
      if (!ep)
 d02c38c:	e0bff817 	ldw	r2,-32(fp)
 d02c390:	1004c03a 	cmpne	r2,r2,zero
 d02c394:	1000031e 	bne	r2,zero,d02c3a4 <rawip_usrreq+0x76c>
         return(EINVAL);
 d02c398:	00800584 	movi	r2,22
 d02c39c:	e0bfff15 	stw	r2,-4(fp)
 d02c3a0:	00001806 	br	d02c404 <rawip_usrreq+0x7cc>
      sin->sin_port = 0;
 d02c3a4:	e0bff917 	ldw	r2,-28(fp)
 d02c3a8:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 d02c3ac:	e0fffe17 	ldw	r3,-8(fp)
 d02c3b0:	00800404 	movi	r2,16
 d02c3b4:	18800215 	stw	r2,8(r3)
      if (req == PRU_SOCKADDR)
 d02c3b8:	e0bff317 	ldw	r2,-52(fp)
 d02c3bc:	108003d8 	cmpnei	r2,r2,15
 d02c3c0:	1000051e 	bne	r2,zero,d02c3d8 <rawip_usrreq+0x7a0>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 d02c3c4:	e0bff817 	ldw	r2,-32(fp)
 d02c3c8:	10c00117 	ldw	r3,4(r2)
 d02c3cc:	e0bff917 	ldw	r2,-28(fp)
 d02c3d0:	10c00115 	stw	r3,4(r2)
 d02c3d4:	00000406 	br	d02c3e8 <rawip_usrreq+0x7b0>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 d02c3d8:	e0bff817 	ldw	r2,-32(fp)
 d02c3dc:	10c00217 	ldw	r3,8(r2)
 d02c3e0:	e0bff917 	ldw	r2,-28(fp)
 d02c3e4:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 d02c3e8:	e03fff15 	stw	zero,-4(fp)
 d02c3ec:	00000506 	br	d02c404 <rawip_usrreq+0x7cc>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 d02c3f0:	d0293e80 	call	d0293e8 <dtrap>
      return 0;
 d02c3f4:	e03fff15 	stw	zero,-4(fp)
 d02c3f8:	00000206 	br	d02c404 <rawip_usrreq+0x7cc>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 d02c3fc:	008017c4 	movi	r2,95
 d02c400:	e0bfff15 	stw	r2,-4(fp)
 d02c404:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d02c408:	e037883a 	mov	sp,fp
 d02c40c:	dfc00217 	ldw	ra,8(sp)
 d02c410:	df000117 	ldw	fp,4(sp)
 d02c414:	dc000017 	ldw	r16,0(sp)
 d02c418:	dec00304 	addi	sp,sp,12
 d02c41c:	f800283a 	ret

0d02c420 <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 d02c420:	defffc04 	addi	sp,sp,-16
 d02c424:	dfc00315 	stw	ra,12(sp)
 d02c428:	df000215 	stw	fp,8(sp)
 d02c42c:	df000204 	addi	fp,sp,8
 d02c430:	e13ffe15 	stw	r4,-8(fp)
 d02c434:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 d02c438:	e0bffe17 	ldw	r2,-8(fp)
 d02c43c:	10800517 	ldw	r2,20(r2)
 d02c440:	10800098 	cmpnei	r2,r2,2
 d02c444:	1000041e 	bne	r2,zero,d02c458 <DOMAIN_CHECK+0x38>
 d02c448:	e0bfff17 	ldw	r2,-4(fp)
 d02c44c:	10800428 	cmpgeui	r2,r2,16
 d02c450:	1000011e 	bne	r2,zero,d02c458 <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 d02c454:	d0293e80 	call	d0293e8 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 d02c458:	e037883a 	mov	sp,fp
 d02c45c:	dfc00117 	ldw	ra,4(sp)
 d02c460:	df000017 	ldw	fp,0(sp)
 d02c464:	dec00204 	addi	sp,sp,8
 d02c468:	f800283a 	ret

0d02c46c <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 d02c46c:	defff904 	addi	sp,sp,-28
 d02c470:	dfc00615 	stw	ra,24(sp)
 d02c474:	df000515 	stw	fp,20(sp)
 d02c478:	df000504 	addi	fp,sp,20
 d02c47c:	e13ffc15 	stw	r4,-16(fp)
 d02c480:	e17ffd15 	stw	r5,-12(fp)
 d02c484:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 d02c488:	0009883a 	mov	r4,zero
 d02c48c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 d02c490:	e13ffc17 	ldw	r4,-16(fp)
 d02c494:	e17ffd17 	ldw	r5,-12(fp)
 d02c498:	e1bffe17 	ldw	r6,-8(fp)
 d02c49c:	d02dc1c0 	call	d02dc1c <socreate>
 d02c4a0:	e0bffb15 	stw	r2,-20(fp)
 d02c4a4:	e0bffb17 	ldw	r2,-20(fp)
 d02c4a8:	1004c03a 	cmpne	r2,r2,zero
 d02c4ac:	1000051e 	bne	r2,zero,d02c4c4 <t_socket+0x58>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02c4b0:	0009883a 	mov	r4,zero
 d02c4b4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 d02c4b8:	00bfffc4 	movi	r2,-1
 d02c4bc:	e0bfff15 	stw	r2,-4(fp)
 d02c4c0:	00000806 	br	d02c4e4 <t_socket+0x78>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 d02c4c4:	e0bffb17 	ldw	r2,-20(fp)
 d02c4c8:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02c4cc:	0009883a 	mov	r4,zero
 d02c4d0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 d02c4d4:	e0bffb17 	ldw	r2,-20(fp)
 d02c4d8:	1004d0ba 	srli	r2,r2,2
 d02c4dc:	10800804 	addi	r2,r2,32
 d02c4e0:	e0bfff15 	stw	r2,-4(fp)
 d02c4e4:	e0bfff17 	ldw	r2,-4(fp)
}
 d02c4e8:	e037883a 	mov	sp,fp
 d02c4ec:	dfc00117 	ldw	ra,4(sp)
 d02c4f0:	df000017 	ldw	fp,0(sp)
 d02c4f4:	dec00204 	addi	sp,sp,8
 d02c4f8:	f800283a 	ret

0d02c4fc <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 d02c4fc:	defff104 	addi	sp,sp,-60
 d02c500:	dfc00e15 	stw	ra,56(sp)
 d02c504:	df000d15 	stw	fp,52(sp)
 d02c508:	df000d04 	addi	fp,sp,52
 d02c50c:	e13ffc15 	stw	r4,-16(fp)
 d02c510:	e17ffd15 	stw	r5,-12(fp)
 d02c514:	e1bffe15 	stw	r6,-8(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 d02c518:	e0bffc17 	ldw	r2,-16(fp)
 d02c51c:	10bff804 	addi	r2,r2,-32
 d02c520:	1085883a 	add	r2,r2,r2
 d02c524:	1085883a 	add	r2,r2,r2
 d02c528:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 d02c52c:	008341b4 	movhi	r2,3334
 d02c530:	10b3e204 	addi	r2,r2,-12408
 d02c534:	e0bff315 	stw	r2,-52(fp)
 d02c538:	00000606 	br	d02c554 <t_bind+0x58>
 d02c53c:	e0fff317 	ldw	r3,-52(fp)
 d02c540:	e0bff517 	ldw	r2,-44(fp)
 d02c544:	18800626 	beq	r3,r2,d02c560 <t_bind+0x64>
 d02c548:	e0bff317 	ldw	r2,-52(fp)
 d02c54c:	10800017 	ldw	r2,0(r2)
 d02c550:	e0bff315 	stw	r2,-52(fp)
 d02c554:	e0bff317 	ldw	r2,-52(fp)
 d02c558:	1004c03a 	cmpne	r2,r2,zero
 d02c55c:	103ff71e 	bne	r2,zero,d02c53c <t_bind+0x40>
 d02c560:	e0fff317 	ldw	r3,-52(fp)
 d02c564:	e0bff517 	ldw	r2,-44(fp)
 d02c568:	18800426 	beq	r3,r2,d02c57c <t_bind+0x80>
 d02c56c:	d0293e80 	call	d0293e8 <dtrap>
 d02c570:	00bfffc4 	movi	r2,-1
 d02c574:	e0bfff15 	stw	r2,-4(fp)
 d02c578:	00003906 	br	d02c660 <t_bind+0x164>
   DOMAIN_CHECK(so, addrlen);
 d02c57c:	e13ff517 	ldw	r4,-44(fp)
 d02c580:	e17ffe17 	ldw	r5,-8(fp)
 d02c584:	d02c4200 	call	d02c420 <DOMAIN_CHECK>

   so->so_error = 0;
 d02c588:	e0bff517 	ldw	r2,-44(fp)
 d02c58c:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 d02c590:	e0bffd17 	ldw	r2,-12(fp)
 d02c594:	1004c03a 	cmpne	r2,r2,zero
 d02c598:	10000d1e 	bne	r2,zero,d02c5d0 <t_bind+0xd4>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 d02c59c:	e0bff804 	addi	r2,fp,-32
 d02c5a0:	10000015 	stw	zero,0(r2)
 d02c5a4:	10000115 	stw	zero,4(r2)
 d02c5a8:	10000215 	stw	zero,8(r2)
 d02c5ac:	10000315 	stw	zero,12(r2)
      addrlen = sizeof(sa);
 d02c5b0:	00800404 	movi	r2,16
 d02c5b4:	e0bffe15 	stw	r2,-8(fp)
      sa.sa_family = so->so_domain;
 d02c5b8:	e0bff517 	ldw	r2,-44(fp)
 d02c5bc:	10800517 	ldw	r2,20(r2)
 d02c5c0:	e0bff80d 	sth	r2,-32(fp)
      sap = &sa;
 d02c5c4:	e0bff804 	addi	r2,fp,-32
 d02c5c8:	e0bff615 	stw	r2,-40(fp)
 d02c5cc:	00000206 	br	d02c5d8 <t_bind+0xdc>
   } else
      sap = addr;
 d02c5d0:	e0bffd17 	ldw	r2,-12(fp)
 d02c5d4:	e0bff615 	stw	r2,-40(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 d02c5d8:	e13ff617 	ldw	r4,-40(fp)
 d02c5dc:	e17ffe17 	ldw	r5,-8(fp)
 d02c5e0:	01800244 	movi	r6,9
 d02c5e4:	d02dae80 	call	d02dae8 <sockargs>
 d02c5e8:	e0bff715 	stw	r2,-36(fp)
 d02c5ec:	e0bff717 	ldw	r2,-36(fp)
 d02c5f0:	1004c03a 	cmpne	r2,r2,zero
 d02c5f4:	1000061e 	bne	r2,zero,d02c610 <t_bind+0x114>
   {
      so->so_error = ENOMEM;
 d02c5f8:	e0fff517 	ldw	r3,-44(fp)
 d02c5fc:	00800304 	movi	r2,12
 d02c600:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02c604:	00bfffc4 	movi	r2,-1
 d02c608:	e0bfff15 	stw	r2,-4(fp)
 d02c60c:	00001406 	br	d02c660 <t_bind+0x164>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 d02c610:	0009883a 	mov	r4,zero
 d02c614:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 d02c618:	e13ff517 	ldw	r4,-44(fp)
 d02c61c:	e17ff717 	ldw	r5,-36(fp)
 d02c620:	d02dde80 	call	d02dde8 <sobind>
 d02c624:	e0bff415 	stw	r2,-48(fp)
   m_freem(nam);
 d02c628:	e13ff717 	ldw	r4,-36(fp)
 d02c62c:	d02a4c40 	call	d02a4c4 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02c630:	0009883a 	mov	r4,zero
 d02c634:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   if (err) 
 d02c638:	e0bff417 	ldw	r2,-48(fp)
 d02c63c:	1005003a 	cmpeq	r2,r2,zero
 d02c640:	1000061e 	bne	r2,zero,d02c65c <t_bind+0x160>
   {
      so->so_error = err;
 d02c644:	e0fff517 	ldw	r3,-44(fp)
 d02c648:	e0bff417 	ldw	r2,-48(fp)
 d02c64c:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02c650:	00bfffc4 	movi	r2,-1
 d02c654:	e0bfff15 	stw	r2,-4(fp)
 d02c658:	00000106 	br	d02c660 <t_bind+0x164>
   }
   return 0;
 d02c65c:	e03fff15 	stw	zero,-4(fp)
 d02c660:	e0bfff17 	ldw	r2,-4(fp)
}
 d02c664:	e037883a 	mov	sp,fp
 d02c668:	dfc00117 	ldw	ra,4(sp)
 d02c66c:	df000017 	ldw	fp,0(sp)
 d02c670:	dec00204 	addi	sp,sp,8
 d02c674:	f800283a 	ret

0d02c678 <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 d02c678:	defff804 	addi	sp,sp,-32
 d02c67c:	dfc00715 	stw	ra,28(sp)
 d02c680:	df000615 	stw	fp,24(sp)
 d02c684:	df000604 	addi	fp,sp,24
 d02c688:	e13ffd15 	stw	r4,-12(fp)
 d02c68c:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 d02c690:	e0bffd17 	ldw	r2,-12(fp)
 d02c694:	10bff804 	addi	r2,r2,-32
 d02c698:	1085883a 	add	r2,r2,r2
 d02c69c:	1085883a 	add	r2,r2,r2
 d02c6a0:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 d02c6a4:	008341b4 	movhi	r2,3334
 d02c6a8:	10b3e204 	addi	r2,r2,-12408
 d02c6ac:	e0bffa15 	stw	r2,-24(fp)
 d02c6b0:	00000606 	br	d02c6cc <t_listen+0x54>
 d02c6b4:	e0fffa17 	ldw	r3,-24(fp)
 d02c6b8:	e0bffc17 	ldw	r2,-16(fp)
 d02c6bc:	18800626 	beq	r3,r2,d02c6d8 <t_listen+0x60>
 d02c6c0:	e0bffa17 	ldw	r2,-24(fp)
 d02c6c4:	10800017 	ldw	r2,0(r2)
 d02c6c8:	e0bffa15 	stw	r2,-24(fp)
 d02c6cc:	e0bffa17 	ldw	r2,-24(fp)
 d02c6d0:	1004c03a 	cmpne	r2,r2,zero
 d02c6d4:	103ff71e 	bne	r2,zero,d02c6b4 <t_listen+0x3c>
 d02c6d8:	e0fffa17 	ldw	r3,-24(fp)
 d02c6dc:	e0bffc17 	ldw	r2,-16(fp)
 d02c6e0:	18800426 	beq	r3,r2,d02c6f4 <t_listen+0x7c>
 d02c6e4:	d0293e80 	call	d0293e8 <dtrap>
 d02c6e8:	00bfffc4 	movi	r2,-1
 d02c6ec:	e0bfff15 	stw	r2,-4(fp)
 d02c6f0:	00001406 	br	d02c744 <t_listen+0xcc>
   so->so_error = 0;
 d02c6f4:	e0bffc17 	ldw	r2,-16(fp)
 d02c6f8:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 d02c6fc:	0009883a 	mov	r4,zero
 d02c700:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 d02c704:	e13ffc17 	ldw	r4,-16(fp)
 d02c708:	e17ffe17 	ldw	r5,-8(fp)
 d02c70c:	d02de440 	call	d02de44 <solisten>
 d02c710:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02c714:	0009883a 	mov	r4,zero
 d02c718:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 d02c71c:	e0bffb17 	ldw	r2,-20(fp)
 d02c720:	1005003a 	cmpeq	r2,r2,zero
 d02c724:	1000061e 	bne	r2,zero,d02c740 <t_listen+0xc8>
   {
      so->so_error = err;
 d02c728:	e0fffc17 	ldw	r3,-16(fp)
 d02c72c:	e0bffb17 	ldw	r2,-20(fp)
 d02c730:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02c734:	00bfffc4 	movi	r2,-1
 d02c738:	e0bfff15 	stw	r2,-4(fp)
 d02c73c:	00000106 	br	d02c744 <t_listen+0xcc>
   }
   return 0;
 d02c740:	e03fff15 	stw	zero,-4(fp)
 d02c744:	e0bfff17 	ldw	r2,-4(fp)
}
 d02c748:	e037883a 	mov	sp,fp
 d02c74c:	dfc00117 	ldw	ra,4(sp)
 d02c750:	df000017 	ldw	fp,0(sp)
 d02c754:	dec00204 	addi	sp,sp,8
 d02c758:	f800283a 	ret

0d02c75c <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 d02c75c:	defff604 	addi	sp,sp,-40
 d02c760:	dfc00915 	stw	ra,36(sp)
 d02c764:	df000815 	stw	fp,32(sp)
 d02c768:	df000804 	addi	fp,sp,32
 d02c76c:	e13ffc15 	stw	r4,-16(fp)
 d02c770:	e17ffd15 	stw	r5,-12(fp)
 d02c774:	e1bffe15 	stw	r6,-8(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 d02c778:	e0bffc17 	ldw	r2,-16(fp)
 d02c77c:	10bff804 	addi	r2,r2,-32
 d02c780:	1085883a 	add	r2,r2,r2
 d02c784:	1085883a 	add	r2,r2,r2
 d02c788:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 d02c78c:	008341b4 	movhi	r2,3334
 d02c790:	10b3e204 	addi	r2,r2,-12408
 d02c794:	e0bff915 	stw	r2,-28(fp)
 d02c798:	00000606 	br	d02c7b4 <t_accept+0x58>
 d02c79c:	e0fff917 	ldw	r3,-28(fp)
 d02c7a0:	e0bffb17 	ldw	r2,-20(fp)
 d02c7a4:	18800626 	beq	r3,r2,d02c7c0 <t_accept+0x64>
 d02c7a8:	e0bff917 	ldw	r2,-28(fp)
 d02c7ac:	10800017 	ldw	r2,0(r2)
 d02c7b0:	e0bff915 	stw	r2,-28(fp)
 d02c7b4:	e0bff917 	ldw	r2,-28(fp)
 d02c7b8:	1004c03a 	cmpne	r2,r2,zero
 d02c7bc:	103ff71e 	bne	r2,zero,d02c79c <t_accept+0x40>
 d02c7c0:	e0fff917 	ldw	r3,-28(fp)
 d02c7c4:	e0bffb17 	ldw	r2,-20(fp)
 d02c7c8:	18800426 	beq	r3,r2,d02c7dc <t_accept+0x80>
 d02c7cc:	d0293e80 	call	d0293e8 <dtrap>
 d02c7d0:	00bfffc4 	movi	r2,-1
 d02c7d4:	e0bfff15 	stw	r2,-4(fp)
 d02c7d8:	00008006 	br	d02c9dc <t_accept+0x280>
   DOMAIN_CHECK(so, *addrlen);
 d02c7dc:	e0bffe17 	ldw	r2,-8(fp)
 d02c7e0:	11400017 	ldw	r5,0(r2)
 d02c7e4:	e13ffb17 	ldw	r4,-20(fp)
 d02c7e8:	d02c4200 	call	d02c420 <DOMAIN_CHECK>

   so->so_error = 0;
 d02c7ec:	e0bffb17 	ldw	r2,-20(fp)
 d02c7f0:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 d02c7f4:	e0bffb17 	ldw	r2,-20(fp)
 d02c7f8:	10800417 	ldw	r2,16(r2)
 d02c7fc:	1080008c 	andi	r2,r2,2
 d02c800:	1004c03a 	cmpne	r2,r2,zero
 d02c804:	1000061e 	bne	r2,zero,d02c820 <t_accept+0xc4>
   {
      so->so_error = EINVAL;
 d02c808:	e0fffb17 	ldw	r3,-20(fp)
 d02c80c:	00800584 	movi	r2,22
 d02c810:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d02c814:	00bfffc4 	movi	r2,-1
 d02c818:	e0bfff15 	stw	r2,-4(fp)
 d02c81c:	00006f06 	br	d02c9dc <t_accept+0x280>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 d02c820:	e0bffb17 	ldw	r2,-20(fp)
 d02c824:	1080088b 	ldhu	r2,34(r2)
 d02c828:	10bfffcc 	andi	r2,r2,65535
 d02c82c:	1080400c 	andi	r2,r2,256
 d02c830:	1005003a 	cmpeq	r2,r2,zero
 d02c834:	10000d1e 	bne	r2,zero,d02c86c <t_accept+0x110>
 d02c838:	e0bffb17 	ldw	r2,-20(fp)
 d02c83c:	10801e43 	ldbu	r2,121(r2)
 d02c840:	10803fcc 	andi	r2,r2,255
 d02c844:	1080201c 	xori	r2,r2,128
 d02c848:	10bfe004 	addi	r2,r2,-128
 d02c84c:	1004c03a 	cmpne	r2,r2,zero
 d02c850:	1000061e 	bne	r2,zero,d02c86c <t_accept+0x110>
   {
      so->so_error = EWOULDBLOCK;
 d02c854:	e0fffb17 	ldw	r3,-20(fp)
 d02c858:	008002c4 	movi	r2,11
 d02c85c:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d02c860:	00bfffc4 	movi	r2,-1
 d02c864:	e0bfff15 	stw	r2,-4(fp)
 d02c868:	00005c06 	br	d02c9dc <t_accept+0x280>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 d02c86c:	0009883a 	mov	r4,zero
 d02c870:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 d02c874:	00001206 	br	d02c8c0 <t_accept+0x164>
   {
      if (so->so_state & SS_CANTRCVMORE)
 d02c878:	e0bffb17 	ldw	r2,-20(fp)
 d02c87c:	1080088b 	ldhu	r2,34(r2)
 d02c880:	10bfffcc 	andi	r2,r2,65535
 d02c884:	1080080c 	andi	r2,r2,32
 d02c888:	1005003a 	cmpeq	r2,r2,zero
 d02c88c:	1000081e 	bne	r2,zero,d02c8b0 <t_accept+0x154>
      {
         so->so_error = ECONNABORTED;
 d02c890:	e0fffb17 	ldw	r3,-20(fp)
 d02c894:	00801c44 	movi	r2,113
 d02c898:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE(NET_RESID);
 d02c89c:	0009883a 	mov	r4,zero
 d02c8a0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d02c8a4:	00bfffc4 	movi	r2,-1
 d02c8a8:	e0bfff15 	stw	r2,-4(fp)
 d02c8ac:	00004b06 	br	d02c9dc <t_accept+0x280>
      }
      tcp_sleep ((char *)&so->so_timeo);
 d02c8b0:	e0bffb17 	ldw	r2,-20(fp)
 d02c8b4:	10800904 	addi	r2,r2,36
 d02c8b8:	1009883a 	mov	r4,r2
 d02c8bc:	d024fbc0 	call	d024fbc <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 d02c8c0:	e0bffb17 	ldw	r2,-20(fp)
 d02c8c4:	10801e43 	ldbu	r2,121(r2)
 d02c8c8:	10803fcc 	andi	r2,r2,255
 d02c8cc:	1080201c 	xori	r2,r2,128
 d02c8d0:	10bfe004 	addi	r2,r2,-128
 d02c8d4:	1004c03a 	cmpne	r2,r2,zero
 d02c8d8:	1000041e 	bne	r2,zero,d02c8ec <t_accept+0x190>
 d02c8dc:	e0bffb17 	ldw	r2,-20(fp)
 d02c8e0:	10800617 	ldw	r2,24(r2)
 d02c8e4:	1005003a 	cmpeq	r2,r2,zero
 d02c8e8:	103fe31e 	bne	r2,zero,d02c878 <t_accept+0x11c>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 d02c8ec:	e0bffb17 	ldw	r2,-20(fp)
 d02c8f0:	10800617 	ldw	r2,24(r2)
 d02c8f4:	1005003a 	cmpeq	r2,r2,zero
 d02c8f8:	1000051e 	bne	r2,zero,d02c910 <t_accept+0x1b4>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02c8fc:	0009883a 	mov	r4,zero
 d02c900:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 d02c904:	00bfffc4 	movi	r2,-1
 d02c908:	e0bfff15 	stw	r2,-4(fp)
 d02c90c:	00003306 	br	d02c9dc <t_accept+0x280>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 d02c910:	01000244 	movi	r4,9
 d02c914:	01400404 	movi	r5,16
 d02c918:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02c91c:	e0bffa15 	stw	r2,-24(fp)
   if (nam == NULL) 
 d02c920:	e0bffa17 	ldw	r2,-24(fp)
 d02c924:	1004c03a 	cmpne	r2,r2,zero
 d02c928:	1000081e 	bne	r2,zero,d02c94c <t_accept+0x1f0>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02c92c:	0009883a 	mov	r4,zero
 d02c930:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 d02c934:	e0fffb17 	ldw	r3,-20(fp)
 d02c938:	00800304 	movi	r2,12
 d02c93c:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d02c940:	00bfffc4 	movi	r2,-1
 d02c944:	e0bfff15 	stw	r2,-4(fp)
 d02c948:	00002406 	br	d02c9dc <t_accept+0x280>
   }
   { 
      struct socket *aso = so->so_q;
 d02c94c:	e0bffb17 	ldw	r2,-20(fp)
 d02c950:	10801d17 	ldw	r2,116(r2)
 d02c954:	e0bff815 	stw	r2,-32(fp)
      if (soqremque (aso, 1) == 0)
 d02c958:	e13ff817 	ldw	r4,-32(fp)
 d02c95c:	01400044 	movi	r5,1
 d02c960:	d0305080 	call	d030508 <soqremque>
 d02c964:	1004c03a 	cmpne	r2,r2,zero
 d02c968:	1000031e 	bne	r2,zero,d02c978 <t_accept+0x21c>
         panic("accept");
 d02c96c:	01034174 	movhi	r4,3333
 d02c970:	213de404 	addi	r4,r4,-2160
 d02c974:	d0246440 	call	d024644 <panic>
      so = aso;
 d02c978:	e0bff817 	ldw	r2,-32(fp)
 d02c97c:	e0bffb15 	stw	r2,-20(fp)
   }
   (void)soaccept (so, nam);
 d02c980:	e13ffb17 	ldw	r4,-20(fp)
 d02c984:	e17ffa17 	ldw	r5,-24(fp)
 d02c988:	d02e3a80 	call	d02e3a8 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 d02c98c:	e0bffd17 	ldw	r2,-12(fp)
 d02c990:	1005003a 	cmpeq	r2,r2,zero
 d02c994:	1000091e 	bne	r2,zero,d02c9bc <t_accept+0x260>
      MEMCPY(addr, nam->m_data, *addrlen);
 d02c998:	e0bffa17 	ldw	r2,-24(fp)
 d02c99c:	11400317 	ldw	r5,12(r2)
 d02c9a0:	e0bffe17 	ldw	r2,-8(fp)
 d02c9a4:	10800017 	ldw	r2,0(r2)
 d02c9a8:	1007883a 	mov	r3,r2
 d02c9ac:	e0bffd17 	ldw	r2,-12(fp)
 d02c9b0:	1009883a 	mov	r4,r2
 d02c9b4:	180d883a 	mov	r6,r3
 d02c9b8:	d0027000 	call	d002700 <memcpy>
   m_freem (nam);
 d02c9bc:	e13ffa17 	ldw	r4,-24(fp)
 d02c9c0:	d02a4c40 	call	d02a4c4 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02c9c4:	0009883a 	mov	r4,zero
 d02c9c8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 d02c9cc:	e0bffb17 	ldw	r2,-20(fp)
 d02c9d0:	1004d0ba 	srli	r2,r2,2
 d02c9d4:	10800804 	addi	r2,r2,32
 d02c9d8:	e0bfff15 	stw	r2,-4(fp)
 d02c9dc:	e0bfff17 	ldw	r2,-4(fp)
}
 d02c9e0:	e037883a 	mov	sp,fp
 d02c9e4:	dfc00117 	ldw	ra,4(sp)
 d02c9e8:	df000017 	ldw	fp,0(sp)
 d02c9ec:	dec00204 	addi	sp,sp,8
 d02c9f0:	f800283a 	ret

0d02c9f4 <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 d02c9f4:	defff704 	addi	sp,sp,-36
 d02c9f8:	dfc00815 	stw	ra,32(sp)
 d02c9fc:	df000715 	stw	fp,28(sp)
 d02ca00:	df000704 	addi	fp,sp,28
 d02ca04:	e13ffc15 	stw	r4,-16(fp)
 d02ca08:	e17ffd15 	stw	r5,-12(fp)
 d02ca0c:	e1bffe15 	stw	r6,-8(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 d02ca10:	e0bffc17 	ldw	r2,-16(fp)
 d02ca14:	10bff804 	addi	r2,r2,-32
 d02ca18:	1085883a 	add	r2,r2,r2
 d02ca1c:	1085883a 	add	r2,r2,r2
 d02ca20:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 d02ca24:	008341b4 	movhi	r2,3334
 d02ca28:	10b3e204 	addi	r2,r2,-12408
 d02ca2c:	e0bff915 	stw	r2,-28(fp)
 d02ca30:	00000606 	br	d02ca4c <t_connect+0x58>
 d02ca34:	e0fff917 	ldw	r3,-28(fp)
 d02ca38:	e0bffb17 	ldw	r2,-20(fp)
 d02ca3c:	18800626 	beq	r3,r2,d02ca58 <t_connect+0x64>
 d02ca40:	e0bff917 	ldw	r2,-28(fp)
 d02ca44:	10800017 	ldw	r2,0(r2)
 d02ca48:	e0bff915 	stw	r2,-28(fp)
 d02ca4c:	e0bff917 	ldw	r2,-28(fp)
 d02ca50:	1004c03a 	cmpne	r2,r2,zero
 d02ca54:	103ff71e 	bne	r2,zero,d02ca34 <t_connect+0x40>
 d02ca58:	e0fff917 	ldw	r3,-28(fp)
 d02ca5c:	e0bffb17 	ldw	r2,-20(fp)
 d02ca60:	18800426 	beq	r3,r2,d02ca74 <t_connect+0x80>
 d02ca64:	d0293e80 	call	d0293e8 <dtrap>
 d02ca68:	00bfffc4 	movi	r2,-1
 d02ca6c:	e0bfff15 	stw	r2,-4(fp)
 d02ca70:	00008406 	br	d02cc84 <t_connect+0x290>
   DOMAIN_CHECK(so, addrlen);
 d02ca74:	e13ffb17 	ldw	r4,-20(fp)
 d02ca78:	e17ffe17 	ldw	r5,-8(fp)
 d02ca7c:	d02c4200 	call	d02c420 <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 d02ca80:	e0bffb17 	ldw	r2,-20(fp)
 d02ca84:	1080088b 	ldhu	r2,34(r2)
 d02ca88:	10bfffcc 	andi	r2,r2,65535
 d02ca8c:	1080400c 	andi	r2,r2,256
 d02ca90:	1005003a 	cmpeq	r2,r2,zero
 d02ca94:	10002a1e 	bne	r2,zero,d02cb40 <t_connect+0x14c>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 d02ca98:	e0bffb17 	ldw	r2,-20(fp)
 d02ca9c:	1080088b 	ldhu	r2,34(r2)
 d02caa0:	10bfffcc 	andi	r2,r2,65535
 d02caa4:	1080010c 	andi	r2,r2,4
 d02caa8:	1005003a 	cmpeq	r2,r2,zero
 d02caac:	1000061e 	bne	r2,zero,d02cac8 <t_connect+0xd4>
      {
         so->so_error = EINPROGRESS;
 d02cab0:	e0fffb17 	ldw	r3,-20(fp)
 d02cab4:	00801dc4 	movi	r2,119
 d02cab8:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 d02cabc:	00bfffc4 	movi	r2,-1
 d02cac0:	e0bfff15 	stw	r2,-4(fp)
 d02cac4:	00006f06 	br	d02cc84 <t_connect+0x290>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 d02cac8:	e0bffb17 	ldw	r2,-20(fp)
 d02cacc:	1080088b 	ldhu	r2,34(r2)
 d02cad0:	10bfffcc 	andi	r2,r2,65535
 d02cad4:	1080008c 	andi	r2,r2,2
 d02cad8:	1005003a 	cmpeq	r2,r2,zero
 d02cadc:	1000041e 	bne	r2,zero,d02caf0 <t_connect+0xfc>
      {
         so->so_error = 0;
 d02cae0:	e0bffb17 	ldw	r2,-20(fp)
 d02cae4:	10000615 	stw	zero,24(r2)
         return 0;
 d02cae8:	e03fff15 	stw	zero,-4(fp)
 d02caec:	00006506 	br	d02cc84 <t_connect+0x290>
      }
      if (so->so_state & SS_WASCONNECTING)
 d02caf0:	e0bffb17 	ldw	r2,-20(fp)
 d02caf4:	1080088b 	ldhu	r2,34(r2)
 d02caf8:	10bfffcc 	andi	r2,r2,65535
 d02cafc:	1088000c 	andi	r2,r2,8192
 d02cb00:	1005003a 	cmpeq	r2,r2,zero
 d02cb04:	10000e1e 	bne	r2,zero,d02cb40 <t_connect+0x14c>
      {
         so->so_state &= ~SS_WASCONNECTING;
 d02cb08:	e0bffb17 	ldw	r2,-20(fp)
 d02cb0c:	10c0088b 	ldhu	r3,34(r2)
 d02cb10:	00b7ffc4 	movi	r2,-8193
 d02cb14:	1884703a 	and	r2,r3,r2
 d02cb18:	1007883a 	mov	r3,r2
 d02cb1c:	e0bffb17 	ldw	r2,-20(fp)
 d02cb20:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 d02cb24:	e0bffb17 	ldw	r2,-20(fp)
 d02cb28:	10800617 	ldw	r2,24(r2)
 d02cb2c:	1005003a 	cmpeq	r2,r2,zero
 d02cb30:	1000031e 	bne	r2,zero,d02cb40 <t_connect+0x14c>
            return SOCKET_ERROR;
 d02cb34:	00bfffc4 	movi	r2,-1
 d02cb38:	e0bfff15 	stw	r2,-4(fp)
 d02cb3c:	00005106 	br	d02cc84 <t_connect+0x290>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 d02cb40:	e0bffb17 	ldw	r2,-20(fp)
 d02cb44:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 d02cb48:	e13ffd17 	ldw	r4,-12(fp)
 d02cb4c:	e17ffe17 	ldw	r5,-8(fp)
 d02cb50:	01800244 	movi	r6,9
 d02cb54:	d02dae80 	call	d02dae8 <sockargs>
 d02cb58:	e0bffa15 	stw	r2,-24(fp)
 d02cb5c:	e0bffa17 	ldw	r2,-24(fp)
 d02cb60:	1004c03a 	cmpne	r2,r2,zero
 d02cb64:	1000061e 	bne	r2,zero,d02cb80 <t_connect+0x18c>
       == NULL)
   {
      so->so_error = ENOMEM;
 d02cb68:	e0fffb17 	ldw	r3,-20(fp)
 d02cb6c:	00800304 	movi	r2,12
 d02cb70:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02cb74:	00bfffc4 	movi	r2,-1
 d02cb78:	e0bfff15 	stw	r2,-4(fp)
 d02cb7c:	00004106 	br	d02cc84 <t_connect+0x290>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 d02cb80:	0009883a 	mov	r4,zero
 d02cb84:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 d02cb88:	e13ffb17 	ldw	r4,-20(fp)
 d02cb8c:	e17ffa17 	ldw	r5,-24(fp)
 d02cb90:	d02e4440 	call	d02e444 <soconnect>
 d02cb94:	1007883a 	mov	r3,r2
 d02cb98:	e0bffb17 	ldw	r2,-20(fp)
 d02cb9c:	10c00615 	stw	r3,24(r2)
 d02cba0:	e0bffb17 	ldw	r2,-20(fp)
 d02cba4:	10800617 	ldw	r2,24(r2)
 d02cba8:	1004c03a 	cmpne	r2,r2,zero
 d02cbac:	10001e1e 	bne	r2,zero,d02cc28 <t_connect+0x234>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 d02cbb0:	e0bffb17 	ldw	r2,-20(fp)
 d02cbb4:	1080088b 	ldhu	r2,34(r2)
 d02cbb8:	10bfffcc 	andi	r2,r2,65535
 d02cbbc:	1080400c 	andi	r2,r2,256
 d02cbc0:	1005003a 	cmpeq	r2,r2,zero
 d02cbc4:	10000e1e 	bne	r2,zero,d02cc00 <t_connect+0x20c>
 d02cbc8:	e0bffb17 	ldw	r2,-20(fp)
 d02cbcc:	1080088b 	ldhu	r2,34(r2)
 d02cbd0:	10bfffcc 	andi	r2,r2,65535
 d02cbd4:	1080010c 	andi	r2,r2,4
 d02cbd8:	1005003a 	cmpeq	r2,r2,zero
 d02cbdc:	1000081e 	bne	r2,zero,d02cc00 <t_connect+0x20c>
   {
      so->so_error = EINPROGRESS;
 d02cbe0:	e0fffb17 	ldw	r3,-20(fp)
 d02cbe4:	00801dc4 	movi	r2,119
 d02cbe8:	18800615 	stw	r2,24(r3)
      goto bad;
 d02cbec:	00000e06 	br	d02cc28 <t_connect+0x234>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 d02cbf0:	e0bffb17 	ldw	r2,-20(fp)
 d02cbf4:	10800904 	addi	r2,r2,36
 d02cbf8:	1009883a 	mov	r4,r2
 d02cbfc:	d024fbc0 	call	d024fbc <tcp_sleep>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 d02cc00:	e0bffb17 	ldw	r2,-20(fp)
 d02cc04:	1080088b 	ldhu	r2,34(r2)
 d02cc08:	10bfffcc 	andi	r2,r2,65535
 d02cc0c:	1080010c 	andi	r2,r2,4
 d02cc10:	1005003a 	cmpeq	r2,r2,zero
 d02cc14:	1000041e 	bne	r2,zero,d02cc28 <t_connect+0x234>
 d02cc18:	e0bffb17 	ldw	r2,-20(fp)
 d02cc1c:	10800617 	ldw	r2,24(r2)
 d02cc20:	1005003a 	cmpeq	r2,r2,zero
 d02cc24:	103ff21e 	bne	r2,zero,d02cbf0 <t_connect+0x1fc>
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 d02cc28:	e0bffb17 	ldw	r2,-20(fp)
 d02cc2c:	10800617 	ldw	r2,24(r2)
 d02cc30:	10801de0 	cmpeqi	r2,r2,119
 d02cc34:	1000071e 	bne	r2,zero,d02cc54 <t_connect+0x260>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 d02cc38:	e0bffb17 	ldw	r2,-20(fp)
 d02cc3c:	10c0088b 	ldhu	r3,34(r2)
 d02cc40:	00b7fec4 	movi	r2,-8197
 d02cc44:	1884703a 	and	r2,r3,r2
 d02cc48:	1007883a 	mov	r3,r2
 d02cc4c:	e0bffb17 	ldw	r2,-20(fp)
 d02cc50:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 d02cc54:	e13ffa17 	ldw	r4,-24(fp)
 d02cc58:	d02a4c40 	call	d02a4c4 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 d02cc5c:	0009883a 	mov	r4,zero
 d02cc60:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 d02cc64:	e0bffb17 	ldw	r2,-20(fp)
 d02cc68:	10800617 	ldw	r2,24(r2)
 d02cc6c:	1005003a 	cmpeq	r2,r2,zero
 d02cc70:	1000031e 	bne	r2,zero,d02cc80 <t_connect+0x28c>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 d02cc74:	00bfffc4 	movi	r2,-1
 d02cc78:	e0bfff15 	stw	r2,-4(fp)
 d02cc7c:	00000106 	br	d02cc84 <t_connect+0x290>

   }
      return 0;
 d02cc80:	e03fff15 	stw	zero,-4(fp)
 d02cc84:	e0bfff17 	ldw	r2,-4(fp)
}
 d02cc88:	e037883a 	mov	sp,fp
 d02cc8c:	dfc00117 	ldw	ra,4(sp)
 d02cc90:	df000017 	ldw	fp,0(sp)
 d02cc94:	dec00204 	addi	sp,sp,8
 d02cc98:	f800283a 	ret

0d02cc9c <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 d02cc9c:	defffb04 	addi	sp,sp,-20
 d02cca0:	dfc00415 	stw	ra,16(sp)
 d02cca4:	df000315 	stw	fp,12(sp)
 d02cca8:	df000304 	addi	fp,sp,12
 d02ccac:	e13ffd15 	stw	r4,-12(fp)
 d02ccb0:	e17ffe15 	stw	r5,-8(fp)
 d02ccb4:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 d02ccb8:	e13ffd17 	ldw	r4,-12(fp)
 d02ccbc:	e17ffe17 	ldw	r5,-8(fp)
 d02ccc0:	e1bfff17 	ldw	r6,-4(fp)
 d02ccc4:	01c00404 	movi	r7,16
 d02ccc8:	d02cd240 	call	d02cd24 <t_getname>
}
 d02cccc:	e037883a 	mov	sp,fp
 d02ccd0:	dfc00117 	ldw	ra,4(sp)
 d02ccd4:	df000017 	ldw	fp,0(sp)
 d02ccd8:	dec00204 	addi	sp,sp,8
 d02ccdc:	f800283a 	ret

0d02cce0 <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 d02cce0:	defffb04 	addi	sp,sp,-20
 d02cce4:	dfc00415 	stw	ra,16(sp)
 d02cce8:	df000315 	stw	fp,12(sp)
 d02ccec:	df000304 	addi	fp,sp,12
 d02ccf0:	e13ffd15 	stw	r4,-12(fp)
 d02ccf4:	e17ffe15 	stw	r5,-8(fp)
 d02ccf8:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 d02ccfc:	e13ffd17 	ldw	r4,-12(fp)
 d02cd00:	e17ffe17 	ldw	r5,-8(fp)
 d02cd04:	e1bfff17 	ldw	r6,-4(fp)
 d02cd08:	01c003c4 	movi	r7,15
 d02cd0c:	d02cd240 	call	d02cd24 <t_getname>
}
 d02cd10:	e037883a 	mov	sp,fp
 d02cd14:	dfc00117 	ldw	ra,4(sp)
 d02cd18:	df000017 	ldw	fp,0(sp)
 d02cd1c:	dec00204 	addi	sp,sp,8
 d02cd20:	f800283a 	ret

0d02cd24 <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 d02cd24:	defff504 	addi	sp,sp,-44
 d02cd28:	dfc00a15 	stw	ra,40(sp)
 d02cd2c:	df000915 	stw	fp,36(sp)
 d02cd30:	df000904 	addi	fp,sp,36
 d02cd34:	e13ffb15 	stw	r4,-20(fp)
 d02cd38:	e17ffc15 	stw	r5,-16(fp)
 d02cd3c:	e1bffd15 	stw	r6,-12(fp)
 d02cd40:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 d02cd44:	e0bffb17 	ldw	r2,-20(fp)
 d02cd48:	10bff804 	addi	r2,r2,-32
 d02cd4c:	1085883a 	add	r2,r2,r2
 d02cd50:	1085883a 	add	r2,r2,r2
 d02cd54:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d02cd58:	008341b4 	movhi	r2,3334
 d02cd5c:	10b3e204 	addi	r2,r2,-12408
 d02cd60:	e0bff715 	stw	r2,-36(fp)
 d02cd64:	00000606 	br	d02cd80 <t_getname+0x5c>
 d02cd68:	e0fff717 	ldw	r3,-36(fp)
 d02cd6c:	e0bffa17 	ldw	r2,-24(fp)
 d02cd70:	18800626 	beq	r3,r2,d02cd8c <t_getname+0x68>
 d02cd74:	e0bff717 	ldw	r2,-36(fp)
 d02cd78:	10800017 	ldw	r2,0(r2)
 d02cd7c:	e0bff715 	stw	r2,-36(fp)
 d02cd80:	e0bff717 	ldw	r2,-36(fp)
 d02cd84:	1004c03a 	cmpne	r2,r2,zero
 d02cd88:	103ff71e 	bne	r2,zero,d02cd68 <t_getname+0x44>
 d02cd8c:	e0fff717 	ldw	r3,-36(fp)
 d02cd90:	e0bffa17 	ldw	r2,-24(fp)
 d02cd94:	18800426 	beq	r3,r2,d02cda8 <t_getname+0x84>
 d02cd98:	d0293e80 	call	d0293e8 <dtrap>
 d02cd9c:	00bfffc4 	movi	r2,-1
 d02cda0:	e0bfff15 	stw	r2,-4(fp)
 d02cda4:	00005806 	br	d02cf08 <t_getname+0x1e4>

   so->so_error = 0;
 d02cda8:	e0bffa17 	ldw	r2,-24(fp)
 d02cdac:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 d02cdb0:	e0bffe17 	ldw	r2,-8(fp)
 d02cdb4:	10800418 	cmpnei	r2,r2,16
 d02cdb8:	10000c1e 	bne	r2,zero,d02cdec <t_getname+0xc8>
 d02cdbc:	e0bffa17 	ldw	r2,-24(fp)
 d02cdc0:	1080088b 	ldhu	r2,34(r2)
 d02cdc4:	10bfffcc 	andi	r2,r2,65535
 d02cdc8:	1080008c 	andi	r2,r2,2
 d02cdcc:	1004c03a 	cmpne	r2,r2,zero
 d02cdd0:	1000061e 	bne	r2,zero,d02cdec <t_getname+0xc8>
   {
      so->so_error = ENOTCONN;
 d02cdd4:	e0fffa17 	ldw	r3,-24(fp)
 d02cdd8:	00802004 	movi	r2,128
 d02cddc:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02cde0:	00bfffc4 	movi	r2,-1
 d02cde4:	e0bfff15 	stw	r2,-4(fp)
 d02cde8:	00004706 	br	d02cf08 <t_getname+0x1e4>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 d02cdec:	0009883a 	mov	r4,zero
 d02cdf0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 d02cdf4:	01000244 	movi	r4,9
 d02cdf8:	01400404 	movi	r5,16
 d02cdfc:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02ce00:	e0bff915 	stw	r2,-28(fp)
   if (m == NULL) 
 d02ce04:	e0bff917 	ldw	r2,-28(fp)
 d02ce08:	1004c03a 	cmpne	r2,r2,zero
 d02ce0c:	1000081e 	bne	r2,zero,d02ce30 <t_getname+0x10c>
   {
      so->so_error = ENOMEM;
 d02ce10:	e0fffa17 	ldw	r3,-24(fp)
 d02ce14:	00800304 	movi	r2,12
 d02ce18:	18800615 	stw	r2,24(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02ce1c:	0009883a 	mov	r4,zero
 d02ce20:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 d02ce24:	00bfffc4 	movi	r2,-1
 d02ce28:	e0bfff15 	stw	r2,-4(fp)
 d02ce2c:	00003606 	br	d02cf08 <t_getname+0x1e4>
   }
   so->so_req = opcode;
 d02ce30:	e0fffa17 	ldw	r3,-24(fp)
 d02ce34:	e0bffe17 	ldw	r2,-8(fp)
 d02ce38:	18800715 	stw	r2,28(r3)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 d02ce3c:	e0bffa17 	ldw	r2,-24(fp)
 d02ce40:	10800217 	ldw	r2,8(r2)
 d02ce44:	10800317 	ldw	r2,12(r2)
 d02ce48:	e13ffa17 	ldw	r4,-24(fp)
 d02ce4c:	000b883a 	mov	r5,zero
 d02ce50:	e1bff917 	ldw	r6,-28(fp)
 d02ce54:	103ee83a 	callr	r2
 d02ce58:	e0bff815 	stw	r2,-32(fp)
 d02ce5c:	e0bff817 	ldw	r2,-32(fp)
 d02ce60:	1004c03a 	cmpne	r2,r2,zero
 d02ce64:	10001a1e 	bne	r2,zero,d02ced0 <t_getname+0x1ac>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 d02ce68:	e0bffa17 	ldw	r2,-24(fp)
 d02ce6c:	10800517 	ldw	r2,20(r2)
 d02ce70:	10800098 	cmpnei	r2,r2,2
 d02ce74:	1000161e 	bne	r2,zero,d02ced0 <t_getname+0x1ac>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 d02ce78:	e0bffd17 	ldw	r2,-12(fp)
 d02ce7c:	10800017 	ldw	r2,0(r2)
 d02ce80:	10800428 	cmpgeui	r2,r2,16
 d02ce84:	1000081e 	bne	r2,zero,d02cea8 <t_getname+0x184>
      {
         dtrap();    /* programming error */
 d02ce88:	d0293e80 	call	d0293e8 <dtrap>
         m_freem(m);
 d02ce8c:	e13ff917 	ldw	r4,-28(fp)
 d02ce90:	d02a4c40 	call	d02a4c4 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 d02ce94:	0009883a 	mov	r4,zero
 d02ce98:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         return EINVAL;
 d02ce9c:	00800584 	movi	r2,22
 d02cea0:	e0bfff15 	stw	r2,-4(fp)
 d02cea4:	00001806 	br	d02cf08 <t_getname+0x1e4>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 d02cea8:	e0bff917 	ldw	r2,-28(fp)
 d02ceac:	10c00317 	ldw	r3,12(r2)
 d02ceb0:	e0bffc17 	ldw	r2,-16(fp)
 d02ceb4:	1009883a 	mov	r4,r2
 d02ceb8:	180b883a 	mov	r5,r3
 d02cebc:	01800404 	movi	r6,16
 d02cec0:	d0027000 	call	d002700 <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 d02cec4:	e0fffd17 	ldw	r3,-12(fp)
 d02cec8:	00800404 	movi	r2,16
 d02cecc:	18800015 	stw	r2,0(r3)
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 d02ced0:	e13ff917 	ldw	r4,-28(fp)
 d02ced4:	d02a4c40 	call	d02a4c4 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02ced8:	0009883a 	mov	r4,zero
 d02cedc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   if (err) 
 d02cee0:	e0bff817 	ldw	r2,-32(fp)
 d02cee4:	1005003a 	cmpeq	r2,r2,zero
 d02cee8:	1000061e 	bne	r2,zero,d02cf04 <t_getname+0x1e0>
   {
      so->so_error = err;
 d02ceec:	e0fffa17 	ldw	r3,-24(fp)
 d02cef0:	e0bff817 	ldw	r2,-32(fp)
 d02cef4:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02cef8:	00bfffc4 	movi	r2,-1
 d02cefc:	e0bfff15 	stw	r2,-4(fp)
 d02cf00:	00000106 	br	d02cf08 <t_getname+0x1e4>
   }
   return 0;
 d02cf04:	e03fff15 	stw	zero,-4(fp)
 d02cf08:	e0bfff17 	ldw	r2,-4(fp)
}
 d02cf0c:	e037883a 	mov	sp,fp
 d02cf10:	dfc00117 	ldw	ra,4(sp)
 d02cf14:	df000017 	ldw	fp,0(sp)
 d02cf18:	dec00204 	addi	sp,sp,8
 d02cf1c:	f800283a 	ret

0d02cf20 <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 d02cf20:	defff604 	addi	sp,sp,-40
 d02cf24:	dfc00915 	stw	ra,36(sp)
 d02cf28:	df000815 	stw	fp,32(sp)
 d02cf2c:	df000804 	addi	fp,sp,32
 d02cf30:	e13ffb15 	stw	r4,-20(fp)
 d02cf34:	e17ffc15 	stw	r5,-16(fp)
 d02cf38:	e1bffd15 	stw	r6,-12(fp)
 d02cf3c:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 d02cf40:	e0bffb17 	ldw	r2,-20(fp)
 d02cf44:	10bff804 	addi	r2,r2,-32
 d02cf48:	1085883a 	add	r2,r2,r2
 d02cf4c:	1085883a 	add	r2,r2,r2
 d02cf50:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d02cf54:	008341b4 	movhi	r2,3334
 d02cf58:	10b3e204 	addi	r2,r2,-12408
 d02cf5c:	e0bff815 	stw	r2,-32(fp)
 d02cf60:	00000606 	br	d02cf7c <t_setsockopt+0x5c>
 d02cf64:	e0fff817 	ldw	r3,-32(fp)
 d02cf68:	e0bffa17 	ldw	r2,-24(fp)
 d02cf6c:	18800626 	beq	r3,r2,d02cf88 <t_setsockopt+0x68>
 d02cf70:	e0bff817 	ldw	r2,-32(fp)
 d02cf74:	10800017 	ldw	r2,0(r2)
 d02cf78:	e0bff815 	stw	r2,-32(fp)
 d02cf7c:	e0bff817 	ldw	r2,-32(fp)
 d02cf80:	1004c03a 	cmpne	r2,r2,zero
 d02cf84:	103ff71e 	bne	r2,zero,d02cf64 <t_setsockopt+0x44>
 d02cf88:	e0fff817 	ldw	r3,-32(fp)
 d02cf8c:	e0bffa17 	ldw	r2,-24(fp)
 d02cf90:	18800426 	beq	r3,r2,d02cfa4 <t_setsockopt+0x84>
 d02cf94:	d0293e80 	call	d0293e8 <dtrap>
 d02cf98:	00bfffc4 	movi	r2,-1
 d02cf9c:	e0bfff15 	stw	r2,-4(fp)
 d02cfa0:	00005006 	br	d02d0e4 <t_setsockopt+0x1c4>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 d02cfa4:	0009883a 	mov	r4,zero
 d02cfa8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   so->so_error = 0;
 d02cfac:	e0bffa17 	ldw	r2,-24(fp)
 d02cfb0:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 d02cfb4:	e0bffc17 	ldw	r2,-16(fp)
 d02cfb8:	10800060 	cmpeqi	r2,r2,1
 d02cfbc:	1000101e 	bne	r2,zero,d02d000 <t_setsockopt+0xe0>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 d02cfc0:	e13ffa17 	ldw	r4,-24(fp)
 d02cfc4:	e17ffd17 	ldw	r5,-12(fp)
 d02cfc8:	e1bffe17 	ldw	r6,-8(fp)
 d02cfcc:	d02f54c0 	call	d02f54c <sosetopt>
 d02cfd0:	e0bff915 	stw	r2,-28(fp)
 d02cfd4:	e0bff917 	ldw	r2,-28(fp)
 d02cfd8:	1005003a 	cmpeq	r2,r2,zero
 d02cfdc:	10003e1e 	bne	r2,zero,d02d0d8 <t_setsockopt+0x1b8>
      {
         so->so_error = err;
 d02cfe0:	e0fffa17 	ldw	r3,-24(fp)
 d02cfe4:	e0bff917 	ldw	r2,-28(fp)
 d02cfe8:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 d02cfec:	0009883a 	mov	r4,zero
 d02cff0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d02cff4:	00bfffc4 	movi	r2,-1
 d02cff8:	e0bfff15 	stw	r2,-4(fp)
 d02cffc:	00003906 	br	d02d0e4 <t_setsockopt+0x1c4>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 d02d000:	e0bffa17 	ldw	r2,-24(fp)
 d02d004:	10801f17 	ldw	r2,124(r2)
 d02d008:	1004c03a 	cmpne	r2,r2,zero
 d02d00c:	1000111e 	bne	r2,zero,d02d054 <t_setsockopt+0x134>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 d02d010:	01000104 	movi	r4,4
 d02d014:	d029e2c0 	call	d029e2c <npalloc>
 d02d018:	1007883a 	mov	r3,r2
 d02d01c:	e0bffa17 	ldw	r2,-24(fp)
 d02d020:	10c01f15 	stw	r3,124(r2)
         if (!so->so_optsPack) 
 d02d024:	e0bffa17 	ldw	r2,-24(fp)
 d02d028:	10801f17 	ldw	r2,124(r2)
 d02d02c:	1004c03a 	cmpne	r2,r2,zero
 d02d030:	1000081e 	bne	r2,zero,d02d054 <t_setsockopt+0x134>
         {
            so->so_error = ENOMEM;
 d02d034:	e0fffa17 	ldw	r3,-24(fp)
 d02d038:	00800304 	movi	r2,12
 d02d03c:	18800615 	stw	r2,24(r3)
            UNLOCK_NET_RESOURCE (NET_RESID);
 d02d040:	0009883a 	mov	r4,zero
 d02d044:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 d02d048:	00bfffc4 	movi	r2,-1
 d02d04c:	e0bfff15 	stw	r2,-4(fp)
 d02d050:	00002406 	br	d02d0e4 <t_setsockopt+0x1c4>
         }
      }
      
      if (name == IP_TTL_OPT)
 d02d054:	e0bffd17 	ldw	r2,-12(fp)
 d02d058:	10800118 	cmpnei	r2,r2,4
 d02d05c:	1000061e 	bne	r2,zero,d02d078 <t_setsockopt+0x158>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 d02d060:	e0bffa17 	ldw	r2,-24(fp)
 d02d064:	10c01f17 	ldw	r3,124(r2)
 d02d068:	e0bffe17 	ldw	r2,-8(fp)
 d02d06c:	10800017 	ldw	r2,0(r2)
 d02d070:	18800045 	stb	r2,1(r3)
 d02d074:	00001806 	br	d02d0d8 <t_setsockopt+0x1b8>
      else
      if (name == IP_TOS)
 d02d078:	e0bffd17 	ldw	r2,-12(fp)
 d02d07c:	108000d8 	cmpnei	r2,r2,3
 d02d080:	1000061e 	bne	r2,zero,d02d09c <t_setsockopt+0x17c>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 d02d084:	e0bffa17 	ldw	r2,-24(fp)
 d02d088:	10c01f17 	ldw	r3,124(r2)
 d02d08c:	e0bffe17 	ldw	r2,-8(fp)
 d02d090:	10800017 	ldw	r2,0(r2)
 d02d094:	18800005 	stb	r2,0(r3)
 d02d098:	00000f06 	br	d02d0d8 <t_setsockopt+0x1b8>
	   else
	   if (name == IP_SCOPEID)
 d02d09c:	e0bffd17 	ldw	r2,-12(fp)
 d02d0a0:	10800398 	cmpnei	r2,r2,14
 d02d0a4:	1000071e 	bne	r2,zero,d02d0c4 <t_setsockopt+0x1a4>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 d02d0a8:	e0bffa17 	ldw	r2,-24(fp)
 d02d0ac:	10c01f17 	ldw	r3,124(r2)
 d02d0b0:	e0bffe17 	ldw	r2,-8(fp)
 d02d0b4:	10800017 	ldw	r2,0(r2)
 d02d0b8:	10803fcc 	andi	r2,r2,255
 d02d0bc:	18800115 	stw	r2,4(r3)
 d02d0c0:	00000506 	br	d02d0d8 <t_setsockopt+0x1b8>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 d02d0c4:	0009883a 	mov	r4,zero
 d02d0c8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d02d0cc:	00bfffc4 	movi	r2,-1
 d02d0d0:	e0bfff15 	stw	r2,-4(fp)
 d02d0d4:	00000306 	br	d02d0e4 <t_setsockopt+0x1c4>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 d02d0d8:	0009883a 	mov	r4,zero
 d02d0dc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return 0;
 d02d0e0:	e03fff15 	stw	zero,-4(fp)
 d02d0e4:	e0bfff17 	ldw	r2,-4(fp)
}
 d02d0e8:	e037883a 	mov	sp,fp
 d02d0ec:	dfc00117 	ldw	ra,4(sp)
 d02d0f0:	df000017 	ldw	fp,0(sp)
 d02d0f4:	dec00204 	addi	sp,sp,8
 d02d0f8:	f800283a 	ret

0d02d0fc <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 d02d0fc:	defff604 	addi	sp,sp,-40
 d02d100:	dfc00915 	stw	ra,36(sp)
 d02d104:	df000815 	stw	fp,32(sp)
 d02d108:	df000804 	addi	fp,sp,32
 d02d10c:	e13ffb15 	stw	r4,-20(fp)
 d02d110:	e17ffc15 	stw	r5,-16(fp)
 d02d114:	e1bffd15 	stw	r6,-12(fp)
 d02d118:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 d02d11c:	e0bffb17 	ldw	r2,-20(fp)
 d02d120:	10bff804 	addi	r2,r2,-32
 d02d124:	1085883a 	add	r2,r2,r2
 d02d128:	1085883a 	add	r2,r2,r2
 d02d12c:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 d02d130:	008341b4 	movhi	r2,3334
 d02d134:	10b3e204 	addi	r2,r2,-12408
 d02d138:	e0bff815 	stw	r2,-32(fp)
 d02d13c:	00000606 	br	d02d158 <t_getsockopt+0x5c>
 d02d140:	e0fff817 	ldw	r3,-32(fp)
 d02d144:	e0bffa17 	ldw	r2,-24(fp)
 d02d148:	18800626 	beq	r3,r2,d02d164 <t_getsockopt+0x68>
 d02d14c:	e0bff817 	ldw	r2,-32(fp)
 d02d150:	10800017 	ldw	r2,0(r2)
 d02d154:	e0bff815 	stw	r2,-32(fp)
 d02d158:	e0bff817 	ldw	r2,-32(fp)
 d02d15c:	1004c03a 	cmpne	r2,r2,zero
 d02d160:	103ff71e 	bne	r2,zero,d02d140 <t_getsockopt+0x44>
 d02d164:	e0fff817 	ldw	r3,-32(fp)
 d02d168:	e0bffa17 	ldw	r2,-24(fp)
 d02d16c:	18800426 	beq	r3,r2,d02d180 <t_getsockopt+0x84>
 d02d170:	d0293e80 	call	d0293e8 <dtrap>
 d02d174:	00bfffc4 	movi	r2,-1
 d02d178:	e0bfff15 	stw	r2,-4(fp)
 d02d17c:	00004206 	br	d02d288 <t_getsockopt+0x18c>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 d02d180:	0009883a 	mov	r4,zero
 d02d184:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 d02d188:	e0bffc17 	ldw	r2,-16(fp)
 d02d18c:	10800060 	cmpeqi	r2,r2,1
 d02d190:	1000101e 	bne	r2,zero,d02d1d4 <t_getsockopt+0xd8>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 d02d194:	e13ffa17 	ldw	r4,-24(fp)
 d02d198:	e17ffd17 	ldw	r5,-12(fp)
 d02d19c:	e1bffe17 	ldw	r6,-8(fp)
 d02d1a0:	d02fa0c0 	call	d02fa0c <sogetopt>
 d02d1a4:	e0bff915 	stw	r2,-28(fp)
 d02d1a8:	e0bff917 	ldw	r2,-28(fp)
 d02d1ac:	1005003a 	cmpeq	r2,r2,zero
 d02d1b0:	1000301e 	bne	r2,zero,d02d274 <t_getsockopt+0x178>
      {
         so->so_error = err;
 d02d1b4:	e0fffa17 	ldw	r3,-24(fp)
 d02d1b8:	e0bff917 	ldw	r2,-28(fp)
 d02d1bc:	18800615 	stw	r2,24(r3)
         UNLOCK_NET_RESOURCE (NET_RESID);
 d02d1c0:	0009883a 	mov	r4,zero
 d02d1c4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d02d1c8:	00bfffc4 	movi	r2,-1
 d02d1cc:	e0bfff15 	stw	r2,-4(fp)
 d02d1d0:	00002d06 	br	d02d288 <t_getsockopt+0x18c>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 d02d1d4:	e0bffd17 	ldw	r2,-12(fp)
 d02d1d8:	10800118 	cmpnei	r2,r2,4
 d02d1dc:	10000f1e 	bne	r2,zero,d02d21c <t_getsockopt+0x120>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 d02d1e0:	e0bffa17 	ldw	r2,-24(fp)
 d02d1e4:	10801f17 	ldw	r2,124(r2)
 d02d1e8:	1004c03a 	cmpne	r2,r2,zero
 d02d1ec:	1000041e 	bne	r2,zero,d02d200 <t_getsockopt+0x104>
 d02d1f0:	e0fffe17 	ldw	r3,-8(fp)
 d02d1f4:	00801004 	movi	r2,64
 d02d1f8:	18800015 	stw	r2,0(r3)
 d02d1fc:	00001d06 	br	d02d274 <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 d02d200:	e0fffe17 	ldw	r3,-8(fp)
 d02d204:	e0bffa17 	ldw	r2,-24(fp)
 d02d208:	10801f17 	ldw	r2,124(r2)
 d02d20c:	10800043 	ldbu	r2,1(r2)
 d02d210:	10803fcc 	andi	r2,r2,255
 d02d214:	18800015 	stw	r2,0(r3)
 d02d218:	00001606 	br	d02d274 <t_getsockopt+0x178>
      }
      else if (name == IP_TOS)
 d02d21c:	e0bffd17 	ldw	r2,-12(fp)
 d02d220:	108000d8 	cmpnei	r2,r2,3
 d02d224:	10000e1e 	bne	r2,zero,d02d260 <t_getsockopt+0x164>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 d02d228:	e0bffa17 	ldw	r2,-24(fp)
 d02d22c:	10801f17 	ldw	r2,124(r2)
 d02d230:	1004c03a 	cmpne	r2,r2,zero
 d02d234:	1000031e 	bne	r2,zero,d02d244 <t_getsockopt+0x148>
 d02d238:	e0bffe17 	ldw	r2,-8(fp)
 d02d23c:	10000015 	stw	zero,0(r2)
 d02d240:	00000c06 	br	d02d274 <t_getsockopt+0x178>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 d02d244:	e0fffe17 	ldw	r3,-8(fp)
 d02d248:	e0bffa17 	ldw	r2,-24(fp)
 d02d24c:	10801f17 	ldw	r2,124(r2)
 d02d250:	10800003 	ldbu	r2,0(r2)
 d02d254:	10803fcc 	andi	r2,r2,255
 d02d258:	18800015 	stw	r2,0(r3)
 d02d25c:	00000506 	br	d02d274 <t_getsockopt+0x178>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 d02d260:	0009883a 	mov	r4,zero
 d02d264:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 d02d268:	00bfffc4 	movi	r2,-1
 d02d26c:	e0bfff15 	stw	r2,-4(fp)
 d02d270:	00000506 	br	d02d288 <t_getsockopt+0x18c>
      }
   }   
   so->so_error = 0;
 d02d274:	e0bffa17 	ldw	r2,-24(fp)
 d02d278:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 d02d27c:	0009883a 	mov	r4,zero
 d02d280:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return 0;
 d02d284:	e03fff15 	stw	zero,-4(fp)
 d02d288:	e0bfff17 	ldw	r2,-4(fp)
}
 d02d28c:	e037883a 	mov	sp,fp
 d02d290:	dfc00117 	ldw	ra,4(sp)
 d02d294:	df000017 	ldw	fp,0(sp)
 d02d298:	dec00204 	addi	sp,sp,8
 d02d29c:	f800283a 	ret

0d02d2a0 <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 d02d2a0:	defff504 	addi	sp,sp,-44
 d02d2a4:	dfc00a15 	stw	ra,40(sp)
 d02d2a8:	df000915 	stw	fp,36(sp)
 d02d2ac:	df000904 	addi	fp,sp,36
 d02d2b0:	e13ffb15 	stw	r4,-20(fp)
 d02d2b4:	e17ffc15 	stw	r5,-16(fp)
 d02d2b8:	e1bffd15 	stw	r6,-12(fp)
 d02d2bc:	e1fffe15 	stw	r7,-8(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 d02d2c0:	e0bffd17 	ldw	r2,-12(fp)
 d02d2c4:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 d02d2c8:	e0bffb17 	ldw	r2,-20(fp)
 d02d2cc:	10bff804 	addi	r2,r2,-32
 d02d2d0:	1085883a 	add	r2,r2,r2
 d02d2d4:	1085883a 	add	r2,r2,r2
 d02d2d8:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 d02d2dc:	e0bffa17 	ldw	r2,-24(fp)
 d02d2e0:	1080088b 	ldhu	r2,34(r2)
 d02d2e4:	10bfffcc 	andi	r2,r2,65535
 d02d2e8:	1080038c 	andi	r2,r2,14
 d02d2ec:	108000a0 	cmpeqi	r2,r2,2
 d02d2f0:	1000061e 	bne	r2,zero,d02d30c <t_recv+0x6c>
   {
      so->so_error = EPIPE;
 d02d2f4:	e0fffa17 	ldw	r3,-24(fp)
 d02d2f8:	00800804 	movi	r2,32
 d02d2fc:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d02d300:	00bfffc4 	movi	r2,-1
 d02d304:	e0bfff15 	stw	r2,-4(fp)
 d02d308:	00001b06 	br	d02d378 <t_recv+0xd8>
   }
   so->so_error = 0;
 d02d30c:	e0bffa17 	ldw	r2,-24(fp)
 d02d310:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 d02d314:	0009883a 	mov	r4,zero
 d02d318:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 d02d31c:	e1fffd04 	addi	r7,fp,-12
 d02d320:	e0bffe17 	ldw	r2,-8(fp)
 d02d324:	d8800015 	stw	r2,0(sp)
 d02d328:	e13ffa17 	ldw	r4,-24(fp)
 d02d32c:	000b883a 	mov	r5,zero
 d02d330:	e1bffc17 	ldw	r6,-16(fp)
 d02d334:	d02ebc00 	call	d02ebc0 <soreceive>
 d02d338:	e0bff915 	stw	r2,-28(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02d33c:	0009883a 	mov	r4,zero
 d02d340:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if(err)
 d02d344:	e0bff917 	ldw	r2,-28(fp)
 d02d348:	1005003a 	cmpeq	r2,r2,zero
 d02d34c:	1000061e 	bne	r2,zero,d02d368 <t_recv+0xc8>
   {
      so->so_error = err;
 d02d350:	e0fffa17 	ldw	r3,-24(fp)
 d02d354:	e0bff917 	ldw	r2,-28(fp)
 d02d358:	18800615 	stw	r2,24(r3)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 d02d35c:	00bfffc4 	movi	r2,-1
 d02d360:	e0bfff15 	stw	r2,-4(fp)
 d02d364:	00000406 	br	d02d378 <t_recv+0xd8>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 d02d368:	e0fffd17 	ldw	r3,-12(fp)
 d02d36c:	e0bff817 	ldw	r2,-32(fp)
 d02d370:	10c5c83a 	sub	r2,r2,r3
 d02d374:	e0bfff15 	stw	r2,-4(fp)
 d02d378:	e0bfff17 	ldw	r2,-4(fp)
}
 d02d37c:	e037883a 	mov	sp,fp
 d02d380:	dfc00117 	ldw	ra,4(sp)
 d02d384:	df000017 	ldw	fp,0(sp)
 d02d388:	dec00204 	addi	sp,sp,8
 d02d38c:	f800283a 	ret

0d02d390 <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 d02d390:	defff304 	addi	sp,sp,-52
 d02d394:	dfc00c15 	stw	ra,48(sp)
 d02d398:	df000b15 	stw	fp,44(sp)
 d02d39c:	df000b04 	addi	fp,sp,44
 d02d3a0:	e13ffb15 	stw	r4,-20(fp)
 d02d3a4:	e17ffc15 	stw	r5,-16(fp)
 d02d3a8:	e1bffd15 	stw	r6,-12(fp)
 d02d3ac:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 d02d3b0:	e03ffa15 	stw	zero,-24(fp)
   int   err;
   int   sendlen = len;
 d02d3b4:	e0bffd17 	ldw	r2,-12(fp)
 d02d3b8:	e0bff715 	stw	r2,-36(fp)

   so = LONG2SO(s);
 d02d3bc:	e0bffb17 	ldw	r2,-20(fp)
 d02d3c0:	10bff804 	addi	r2,r2,-32
 d02d3c4:	1085883a 	add	r2,r2,r2
 d02d3c8:	1085883a 	add	r2,r2,r2
 d02d3cc:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 d02d3d0:	008341b4 	movhi	r2,3334
 d02d3d4:	10b3e204 	addi	r2,r2,-12408
 d02d3d8:	e0bff615 	stw	r2,-40(fp)
 d02d3dc:	00000606 	br	d02d3f8 <t_recvfrom+0x68>
 d02d3e0:	e0fff617 	ldw	r3,-40(fp)
 d02d3e4:	e0bff917 	ldw	r2,-28(fp)
 d02d3e8:	18800626 	beq	r3,r2,d02d404 <t_recvfrom+0x74>
 d02d3ec:	e0bff617 	ldw	r2,-40(fp)
 d02d3f0:	10800017 	ldw	r2,0(r2)
 d02d3f4:	e0bff615 	stw	r2,-40(fp)
 d02d3f8:	e0bff617 	ldw	r2,-40(fp)
 d02d3fc:	1004c03a 	cmpne	r2,r2,zero
 d02d400:	103ff71e 	bne	r2,zero,d02d3e0 <t_recvfrom+0x50>
 d02d404:	e0fff617 	ldw	r3,-40(fp)
 d02d408:	e0bff917 	ldw	r2,-28(fp)
 d02d40c:	18800426 	beq	r3,r2,d02d420 <t_recvfrom+0x90>
 d02d410:	d0293e80 	call	d0293e8 <dtrap>
 d02d414:	00bfffc4 	movi	r2,-1
 d02d418:	e0bfff15 	stw	r2,-4(fp)
 d02d41c:	00002a06 	br	d02d4c8 <t_recvfrom+0x138>
   so->so_error = 0;
 d02d420:	e0bff917 	ldw	r2,-28(fp)
 d02d424:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 d02d428:	0009883a 	mov	r4,zero
 d02d42c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 d02d430:	e17ffa04 	addi	r5,fp,-24
 d02d434:	e1fffd04 	addi	r7,fp,-12
 d02d438:	e0bffe17 	ldw	r2,-8(fp)
 d02d43c:	d8800015 	stw	r2,0(sp)
 d02d440:	e13ff917 	ldw	r4,-28(fp)
 d02d444:	e1bffc17 	ldw	r6,-16(fp)
 d02d448:	d02ebc00 	call	d02ebc0 <soreceive>
 d02d44c:	e0bff815 	stw	r2,-32(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 d02d450:	e0bffa17 	ldw	r2,-24(fp)
 d02d454:	1005003a 	cmpeq	r2,r2,zero
 d02d458:	10000c1e 	bne	r2,zero,d02d48c <t_recvfrom+0xfc>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 d02d45c:	e0bffa17 	ldw	r2,-24(fp)
 d02d460:	10800317 	ldw	r2,12(r2)
 d02d464:	100b883a 	mov	r5,r2
 d02d468:	e0800317 	ldw	r2,12(fp)
 d02d46c:	10800017 	ldw	r2,0(r2)
 d02d470:	1007883a 	mov	r3,r2
 d02d474:	e0800217 	ldw	r2,8(fp)
 d02d478:	1009883a 	mov	r4,r2
 d02d47c:	180d883a 	mov	r6,r3
 d02d480:	d0027000 	call	d002700 <memcpy>
      m_freem (sender);
 d02d484:	e13ffa17 	ldw	r4,-24(fp)
 d02d488:	d02a4c40 	call	d02a4c4 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 d02d48c:	0009883a 	mov	r4,zero
 d02d490:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if(err)
 d02d494:	e0bff817 	ldw	r2,-32(fp)
 d02d498:	1005003a 	cmpeq	r2,r2,zero
 d02d49c:	1000061e 	bne	r2,zero,d02d4b8 <t_recvfrom+0x128>
   {
      so->so_error = err;
 d02d4a0:	e0fff917 	ldw	r3,-28(fp)
 d02d4a4:	e0bff817 	ldw	r2,-32(fp)
 d02d4a8:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02d4ac:	00bfffc4 	movi	r2,-1
 d02d4b0:	e0bfff15 	stw	r2,-4(fp)
 d02d4b4:	00000406 	br	d02d4c8 <t_recvfrom+0x138>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 d02d4b8:	e0fffd17 	ldw	r3,-12(fp)
 d02d4bc:	e0bff717 	ldw	r2,-36(fp)
 d02d4c0:	10c5c83a 	sub	r2,r2,r3
 d02d4c4:	e0bfff15 	stw	r2,-4(fp)
 d02d4c8:	e0bfff17 	ldw	r2,-4(fp)
}
 d02d4cc:	e037883a 	mov	sp,fp
 d02d4d0:	dfc00117 	ldw	ra,4(sp)
 d02d4d4:	df000017 	ldw	fp,0(sp)
 d02d4d8:	dec00204 	addi	sp,sp,8
 d02d4dc:	f800283a 	ret

0d02d4e0 <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 d02d4e0:	defff204 	addi	sp,sp,-56
 d02d4e4:	dfc00d15 	stw	ra,52(sp)
 d02d4e8:	df000c15 	stw	fp,48(sp)
 d02d4ec:	df000c04 	addi	fp,sp,48
 d02d4f0:	e13ffa15 	stw	r4,-24(fp)
 d02d4f4:	e17ffb15 	stw	r5,-20(fp)
 d02d4f8:	e1bffc15 	stw	r6,-16(fp)
 d02d4fc:	e1fffd15 	stw	r7,-12(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 d02d500:	e0bffa17 	ldw	r2,-24(fp)
 d02d504:	10bff804 	addi	r2,r2,-32
 d02d508:	1085883a 	add	r2,r2,r2
 d02d50c:	1085883a 	add	r2,r2,r2
 d02d510:	e0bff815 	stw	r2,-32(fp)
   SOC_CHECK(so);
 d02d514:	008341b4 	movhi	r2,3334
 d02d518:	10b3e204 	addi	r2,r2,-12408
 d02d51c:	e0bff515 	stw	r2,-44(fp)
 d02d520:	00000606 	br	d02d53c <t_sendto+0x5c>
 d02d524:	e0fff517 	ldw	r3,-44(fp)
 d02d528:	e0bff817 	ldw	r2,-32(fp)
 d02d52c:	18800626 	beq	r3,r2,d02d548 <t_sendto+0x68>
 d02d530:	e0bff517 	ldw	r2,-44(fp)
 d02d534:	10800017 	ldw	r2,0(r2)
 d02d538:	e0bff515 	stw	r2,-44(fp)
 d02d53c:	e0bff517 	ldw	r2,-44(fp)
 d02d540:	1004c03a 	cmpne	r2,r2,zero
 d02d544:	103ff71e 	bne	r2,zero,d02d524 <t_sendto+0x44>
 d02d548:	e0fff517 	ldw	r3,-44(fp)
 d02d54c:	e0bff817 	ldw	r2,-32(fp)
 d02d550:	18800426 	beq	r3,r2,d02d564 <t_sendto+0x84>
 d02d554:	d0293e80 	call	d0293e8 <dtrap>
 d02d558:	00bfffc4 	movi	r2,-1
 d02d55c:	e0bfff15 	stw	r2,-4(fp)
 d02d560:	00006406 	br	d02d6f4 <t_sendto+0x214>
   so->so_error = 0;
 d02d564:	e0bff817 	ldw	r2,-32(fp)
 d02d568:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 d02d56c:	e0bff817 	ldw	r2,-32(fp)
 d02d570:	10800983 	ldbu	r2,38(r2)
 d02d574:	10803fcc 	andi	r2,r2,255
 d02d578:	1080201c 	xori	r2,r2,128
 d02d57c:	10bfe004 	addi	r2,r2,-128
 d02d580:	e0bffe15 	stw	r2,-8(fp)
 d02d584:	e0fffe17 	ldw	r3,-8(fp)
 d02d588:	188000a0 	cmpeqi	r2,r3,2
 d02d58c:	10000e1e 	bne	r2,zero,d02d5c8 <t_sendto+0xe8>
 d02d590:	e0fffe17 	ldw	r3,-8(fp)
 d02d594:	188000e0 	cmpeqi	r2,r3,3
 d02d598:	10000e1e 	bne	r2,zero,d02d5d4 <t_sendto+0xf4>
 d02d59c:	e0fffe17 	ldw	r3,-8(fp)
 d02d5a0:	18800060 	cmpeqi	r2,r3,1
 d02d5a4:	1000011e 	bne	r2,zero,d02d5ac <t_sendto+0xcc>
 d02d5a8:	00001006 	br	d02d5ec <t_sendto+0x10c>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 d02d5ac:	e13ffa17 	ldw	r4,-24(fp)
 d02d5b0:	e17ffb17 	ldw	r5,-20(fp)
 d02d5b4:	e1bffc17 	ldw	r6,-16(fp)
 d02d5b8:	e1fffd17 	ldw	r7,-12(fp)
 d02d5bc:	d02d70c0 	call	d02d70c <t_send>
 d02d5c0:	e0bfff15 	stw	r2,-4(fp)
 d02d5c4:	00004b06 	br	d02d6f4 <t_sendto+0x214>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 d02d5c8:	d0436600 	call	d043660 <udp_maxalloc>
 d02d5cc:	e0bff915 	stw	r2,-28(fp)
      break;
 d02d5d0:	00000d06 	br	d02d608 <t_sendto+0x128>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 d02d5d4:	e0bff817 	ldw	r2,-32(fp)
 d02d5d8:	10800417 	ldw	r2,16(r2)
 d02d5dc:	1108000c 	andi	r4,r2,8192
 d02d5e0:	d0421440 	call	d042144 <ip_raw_maxalloc>
 d02d5e4:	e0bff915 	stw	r2,-28(fp)
      break;
 d02d5e8:	00000706 	br	d02d608 <t_sendto+0x128>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 d02d5ec:	d0293e80 	call	d0293e8 <dtrap>
      so->so_error = EFAULT;
 d02d5f0:	e0fff817 	ldw	r3,-32(fp)
 d02d5f4:	00800384 	movi	r2,14
 d02d5f8:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02d5fc:	00bfffc4 	movi	r2,-1
 d02d600:	e0bfff15 	stw	r2,-4(fp)
 d02d604:	00003b06 	br	d02d6f4 <t_sendto+0x214>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 d02d608:	e0fff917 	ldw	r3,-28(fp)
 d02d60c:	e0bffc17 	ldw	r2,-16(fp)
 d02d610:	1880060e 	bge	r3,r2,d02d62c <t_sendto+0x14c>
   {
      so->so_error = EMSGSIZE;
 d02d614:	e0fff817 	ldw	r3,-32(fp)
 d02d618:	00801e84 	movi	r2,122
 d02d61c:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02d620:	00ffffc4 	movi	r3,-1
 d02d624:	e0ffff15 	stw	r3,-4(fp)
 d02d628:	00003206 	br	d02d6f4 <t_sendto+0x214>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 d02d62c:	e0800217 	ldw	r2,8(fp)
 d02d630:	1005003a 	cmpeq	r2,r2,zero
 d02d634:	10000e1e 	bne	r2,zero,d02d670 <t_sendto+0x190>
   {
      name = sockargs(to, tolen, MT_SONAME);
 d02d638:	e1000217 	ldw	r4,8(fp)
 d02d63c:	e1400317 	ldw	r5,12(fp)
 d02d640:	01800244 	movi	r6,9
 d02d644:	d02dae80 	call	d02dae8 <sockargs>
 d02d648:	e0bff615 	stw	r2,-40(fp)
      if(name == NULL)
 d02d64c:	e0bff617 	ldw	r2,-40(fp)
 d02d650:	1004c03a 	cmpne	r2,r2,zero
 d02d654:	1000071e 	bne	r2,zero,d02d674 <t_sendto+0x194>
      {
         so->so_error = ENOMEM;
 d02d658:	e0fff817 	ldw	r3,-32(fp)
 d02d65c:	00800304 	movi	r2,12
 d02d660:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 d02d664:	00bfffc4 	movi	r2,-1
 d02d668:	e0bfff15 	stw	r2,-4(fp)
 d02d66c:	00002106 	br	d02d6f4 <t_sendto+0x214>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 d02d670:	e03ff615 	stw	zero,-40(fp)
   
   sendlen = len;
 d02d674:	e0bffc17 	ldw	r2,-16(fp)
 d02d678:	e0bff915 	stw	r2,-28(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 d02d67c:	0009883a 	mov	r4,zero
 d02d680:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 d02d684:	e1fff904 	addi	r7,fp,-28
 d02d688:	e0bffd17 	ldw	r2,-12(fp)
 d02d68c:	d8800015 	stw	r2,0(sp)
 d02d690:	e13ff817 	ldw	r4,-32(fp)
 d02d694:	e17ff617 	ldw	r5,-40(fp)
 d02d698:	e1bffb17 	ldw	r6,-20(fp)
 d02d69c:	d02e5b80 	call	d02e5b8 <sosend>
 d02d6a0:	e0bff715 	stw	r2,-36(fp)

   if (name)
 d02d6a4:	e0bff617 	ldw	r2,-40(fp)
 d02d6a8:	1005003a 	cmpeq	r2,r2,zero
 d02d6ac:	1000021e 	bne	r2,zero,d02d6b8 <t_sendto+0x1d8>
      m_freem(name);
 d02d6b0:	e13ff617 	ldw	r4,-40(fp)
 d02d6b4:	d02a4c40 	call	d02a4c4 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 d02d6b8:	0009883a 	mov	r4,zero
 d02d6bc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 d02d6c0:	e0bff717 	ldw	r2,-36(fp)
 d02d6c4:	1005003a 	cmpeq	r2,r2,zero
 d02d6c8:	1000061e 	bne	r2,zero,d02d6e4 <t_sendto+0x204>
   {
      so->so_error = err;
 d02d6cc:	e0fff817 	ldw	r3,-32(fp)
 d02d6d0:	e0bff717 	ldw	r2,-36(fp)
 d02d6d4:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02d6d8:	00ffffc4 	movi	r3,-1
 d02d6dc:	e0ffff15 	stw	r3,-4(fp)
 d02d6e0:	00000406 	br	d02d6f4 <t_sendto+0x214>
   }

   return (len - sendlen);
 d02d6e4:	e0fff917 	ldw	r3,-28(fp)
 d02d6e8:	e0bffc17 	ldw	r2,-16(fp)
 d02d6ec:	10c5c83a 	sub	r2,r2,r3
 d02d6f0:	e0bfff15 	stw	r2,-4(fp)
 d02d6f4:	e0bfff17 	ldw	r2,-4(fp)
}
 d02d6f8:	e037883a 	mov	sp,fp
 d02d6fc:	dfc00117 	ldw	ra,4(sp)
 d02d700:	df000017 	ldw	fp,0(sp)
 d02d704:	dec00204 	addi	sp,sp,8
 d02d708:	f800283a 	ret

0d02d70c <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 d02d70c:	defff004 	addi	sp,sp,-64
 d02d710:	dfc00f15 	stw	ra,60(sp)
 d02d714:	df000e15 	stw	fp,56(sp)
 d02d718:	df000e04 	addi	fp,sp,56
 d02d71c:	e13ffb15 	stw	r4,-20(fp)
 d02d720:	e17ffc15 	stw	r5,-16(fp)
 d02d724:	e1bffd15 	stw	r6,-12(fp)
 d02d728:	e1fffe15 	stw	r7,-8(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 d02d72c:	e03ff715 	stw	zero,-36(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 d02d730:	e0bffb17 	ldw	r2,-20(fp)
 d02d734:	10bff804 	addi	r2,r2,-32
 d02d738:	1085883a 	add	r2,r2,r2
 d02d73c:	1085883a 	add	r2,r2,r2
 d02d740:	e0bff915 	stw	r2,-28(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 d02d744:	e0bff917 	ldw	r2,-28(fp)
 d02d748:	1080088b 	ldhu	r2,34(r2)
 d02d74c:	10bfffcc 	andi	r2,r2,65535
 d02d750:	1080038c 	andi	r2,r2,14
 d02d754:	108000a0 	cmpeqi	r2,r2,2
 d02d758:	1000061e 	bne	r2,zero,d02d774 <t_send+0x68>
   {
      so->so_error = EPIPE;
 d02d75c:	e0fff917 	ldw	r3,-28(fp)
 d02d760:	00800804 	movi	r2,32
 d02d764:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02d768:	00bfffc4 	movi	r2,-1
 d02d76c:	e0bfff15 	stw	r2,-4(fp)
 d02d770:	00006a06 	br	d02d91c <t_send+0x210>
   }
   so->so_error = 0;
 d02d774:	e0bff917 	ldw	r2,-28(fp)
 d02d778:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 d02d77c:	e0bff917 	ldw	r2,-28(fp)
 d02d780:	10800983 	ldbu	r2,38(r2)
 d02d784:	10803fcc 	andi	r2,r2,255
 d02d788:	1080201c 	xori	r2,r2,128
 d02d78c:	10bfe004 	addi	r2,r2,-128
 d02d790:	10800060 	cmpeqi	r2,r2,1
 d02d794:	1000091e 	bne	r2,zero,d02d7bc <t_send+0xb0>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 d02d798:	d8000015 	stw	zero,0(sp)
 d02d79c:	d8000115 	stw	zero,4(sp)
 d02d7a0:	e13ffb17 	ldw	r4,-20(fp)
 d02d7a4:	e17ffc17 	ldw	r5,-16(fp)
 d02d7a8:	e1bffd17 	ldw	r6,-12(fp)
 d02d7ac:	e1fffe17 	ldw	r7,-8(fp)
 d02d7b0:	d02d4e00 	call	d02d4e0 <t_sendto>
 d02d7b4:	e0bfff15 	stw	r2,-4(fp)
 d02d7b8:	00005806 	br	d02d91c <t_send+0x210>

   maxpkt = TCP_MSS;
 d02d7bc:	00816d04 	movi	r2,1460
 d02d7c0:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 d02d7c4:	e0bff917 	ldw	r2,-28(fp)
 d02d7c8:	10800117 	ldw	r2,4(r2)
 d02d7cc:	1005003a 	cmpeq	r2,r2,zero
 d02d7d0:	10004d1e 	bne	r2,zero,d02d908 <t_send+0x1fc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 d02d7d4:	e0bff917 	ldw	r2,-28(fp)
 d02d7d8:	10800117 	ldw	r2,4(r2)
 d02d7dc:	10800917 	ldw	r2,36(r2)
 d02d7e0:	e0bff415 	stw	r2,-48(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 d02d7e4:	e0bff417 	ldw	r2,-48(fp)
 d02d7e8:	10800a0b 	ldhu	r2,40(r2)
 d02d7ec:	10bfffcc 	andi	r2,r2,65535
 d02d7f0:	1005003a 	cmpeq	r2,r2,zero
 d02d7f4:	1000441e 	bne	r2,zero,d02d908 <t_send+0x1fc>
         maxpkt = tp->t_maxseg;
 d02d7f8:	e0bff417 	ldw	r2,-48(fp)
 d02d7fc:	10800a0b 	ldhu	r2,40(r2)
 d02d800:	10bfffcc 	andi	r2,r2,65535
 d02d804:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 d02d808:	00003f06 	br	d02d908 <t_send+0x1fc>
   {
      if (len > maxpkt)
 d02d80c:	e0fffd17 	ldw	r3,-12(fp)
 d02d810:	e0bff617 	ldw	r2,-40(fp)
 d02d814:	10c0030e 	bge	r2,r3,d02d824 <t_send+0x118>
         sendlen = maxpkt;  /* take biggest block we can */
 d02d818:	e0bff617 	ldw	r2,-40(fp)
 d02d81c:	e0bffa15 	stw	r2,-24(fp)
 d02d820:	00000206 	br	d02d82c <t_send+0x120>
      else
         sendlen = len;
 d02d824:	e0bffd17 	ldw	r2,-12(fp)
 d02d828:	e0bffa15 	stw	r2,-24(fp)
      sent = sendlen;
 d02d82c:	e0bffa17 	ldw	r2,-24(fp)
 d02d830:	e0bff515 	stw	r2,-44(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 d02d834:	0009883a 	mov	r4,zero
 d02d838:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 d02d83c:	e1fffa04 	addi	r7,fp,-24
 d02d840:	e0bffe17 	ldw	r2,-8(fp)
 d02d844:	d8800015 	stw	r2,0(sp)
 d02d848:	e13ff917 	ldw	r4,-28(fp)
 d02d84c:	000b883a 	mov	r5,zero
 d02d850:	e1bffc17 	ldw	r6,-16(fp)
 d02d854:	d02e5b80 	call	d02e5b8 <sosend>
 d02d858:	e0bff815 	stw	r2,-32(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 d02d85c:	0009883a 	mov	r4,zero
 d02d860:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 d02d864:	e0bff817 	ldw	r2,-32(fp)
 d02d868:	1005003a 	cmpeq	r2,r2,zero
 d02d86c:	1000121e 	bne	r2,zero,d02d8b8 <t_send+0x1ac>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 d02d870:	e0bff817 	ldw	r2,-32(fp)
 d02d874:	10801a60 	cmpeqi	r2,r2,105
 d02d878:	1000031e 	bne	r2,zero,d02d888 <t_send+0x17c>
 d02d87c:	e0bff817 	ldw	r2,-32(fp)
 d02d880:	108002d8 	cmpnei	r2,r2,11
 d02d884:	1000061e 	bne	r2,zero,d02d8a0 <t_send+0x194>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 d02d888:	e0bff717 	ldw	r2,-36(fp)
 d02d88c:	1005003a 	cmpeq	r2,r2,zero
 d02d890:	1000031e 	bne	r2,zero,d02d8a0 <t_send+0x194>
            {
               so->so_error = 0;
 d02d894:	e0bff917 	ldw	r2,-28(fp)
 d02d898:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 d02d89c:	00001d06 	br	d02d914 <t_send+0x208>
            }
         }
         so->so_error = e;
 d02d8a0:	e0fff917 	ldw	r3,-28(fp)
 d02d8a4:	e0bff817 	ldw	r2,-32(fp)
 d02d8a8:	18800615 	stw	r2,24(r3)
         return SOCKET_ERROR;
 d02d8ac:	00bfffc4 	movi	r2,-1
 d02d8b0:	e0bfff15 	stw	r2,-4(fp)
 d02d8b4:	00001906 	br	d02d91c <t_send+0x210>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 d02d8b8:	e0bffa17 	ldw	r2,-24(fp)
 d02d8bc:	1004c03a 	cmpne	r2,r2,zero
 d02d8c0:	1000141e 	bne	r2,zero,d02d914 <t_send+0x208>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 d02d8c4:	e0fffa17 	ldw	r3,-24(fp)
 d02d8c8:	e0bff517 	ldw	r2,-44(fp)
 d02d8cc:	10c5c83a 	sub	r2,r2,r3
 d02d8d0:	e0bff515 	stw	r2,-44(fp)
      buf += sent;
 d02d8d4:	e0bff517 	ldw	r2,-44(fp)
 d02d8d8:	1007883a 	mov	r3,r2
 d02d8dc:	e0bffc17 	ldw	r2,-16(fp)
 d02d8e0:	10c5883a 	add	r2,r2,r3
 d02d8e4:	e0bffc15 	stw	r2,-16(fp)
      len -= sent;
 d02d8e8:	e0fffd17 	ldw	r3,-12(fp)
 d02d8ec:	e0bff517 	ldw	r2,-44(fp)
 d02d8f0:	1885c83a 	sub	r2,r3,r2
 d02d8f4:	e0bffd15 	stw	r2,-12(fp)
      total_sent += sent;
 d02d8f8:	e0fff717 	ldw	r3,-36(fp)
 d02d8fc:	e0bff517 	ldw	r2,-44(fp)
 d02d900:	1885883a 	add	r2,r3,r2
 d02d904:	e0bff715 	stw	r2,-36(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 d02d908:	e0bffd17 	ldw	r2,-12(fp)
 d02d90c:	1004c03a 	cmpne	r2,r2,zero
 d02d910:	103fbe1e 	bne	r2,zero,d02d80c <t_send+0x100>
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 d02d914:	e0bff717 	ldw	r2,-36(fp)
 d02d918:	e0bfff15 	stw	r2,-4(fp)
 d02d91c:	e0bfff17 	ldw	r2,-4(fp)
}
 d02d920:	e037883a 	mov	sp,fp
 d02d924:	dfc00117 	ldw	ra,4(sp)
 d02d928:	df000017 	ldw	fp,0(sp)
 d02d92c:	dec00204 	addi	sp,sp,8
 d02d930:	f800283a 	ret

0d02d934 <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 d02d934:	defff804 	addi	sp,sp,-32
 d02d938:	dfc00715 	stw	ra,28(sp)
 d02d93c:	df000615 	stw	fp,24(sp)
 d02d940:	df000604 	addi	fp,sp,24
 d02d944:	e13ffd15 	stw	r4,-12(fp)
 d02d948:	e17ffe15 	stw	r5,-8(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 d02d94c:	e0bffd17 	ldw	r2,-12(fp)
 d02d950:	10bff804 	addi	r2,r2,-32
 d02d954:	1085883a 	add	r2,r2,r2
 d02d958:	1085883a 	add	r2,r2,r2
 d02d95c:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 d02d960:	008341b4 	movhi	r2,3334
 d02d964:	10b3e204 	addi	r2,r2,-12408
 d02d968:	e0bffa15 	stw	r2,-24(fp)
 d02d96c:	00000606 	br	d02d988 <t_shutdown+0x54>
 d02d970:	e0fffa17 	ldw	r3,-24(fp)
 d02d974:	e0bffc17 	ldw	r2,-16(fp)
 d02d978:	18800626 	beq	r3,r2,d02d994 <t_shutdown+0x60>
 d02d97c:	e0bffa17 	ldw	r2,-24(fp)
 d02d980:	10800017 	ldw	r2,0(r2)
 d02d984:	e0bffa15 	stw	r2,-24(fp)
 d02d988:	e0bffa17 	ldw	r2,-24(fp)
 d02d98c:	1004c03a 	cmpne	r2,r2,zero
 d02d990:	103ff71e 	bne	r2,zero,d02d970 <t_shutdown+0x3c>
 d02d994:	e0fffa17 	ldw	r3,-24(fp)
 d02d998:	e0bffc17 	ldw	r2,-16(fp)
 d02d99c:	18800426 	beq	r3,r2,d02d9b0 <t_shutdown+0x7c>
 d02d9a0:	d0293e80 	call	d0293e8 <dtrap>
 d02d9a4:	00bfffc4 	movi	r2,-1
 d02d9a8:	e0bfff15 	stw	r2,-4(fp)
 d02d9ac:	00001406 	br	d02da00 <t_shutdown+0xcc>
   so->so_error = 0;
 d02d9b0:	e0bffc17 	ldw	r2,-16(fp)
 d02d9b4:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 d02d9b8:	0009883a 	mov	r4,zero
 d02d9bc:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 d02d9c0:	e13ffc17 	ldw	r4,-16(fp)
 d02d9c4:	e17ffe17 	ldw	r5,-8(fp)
 d02d9c8:	d02f3a40 	call	d02f3a4 <soshutdown>
 d02d9cc:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02d9d0:	0009883a 	mov	r4,zero
 d02d9d4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if (err != 0)
 d02d9d8:	e0bffb17 	ldw	r2,-20(fp)
 d02d9dc:	1005003a 	cmpeq	r2,r2,zero
 d02d9e0:	1000061e 	bne	r2,zero,d02d9fc <t_shutdown+0xc8>
   {
      so->so_error = err;
 d02d9e4:	e0fffc17 	ldw	r3,-16(fp)
 d02d9e8:	e0bffb17 	ldw	r2,-20(fp)
 d02d9ec:	18800615 	stw	r2,24(r3)
      return SOCKET_ERROR;
 d02d9f0:	00bfffc4 	movi	r2,-1
 d02d9f4:	e0bfff15 	stw	r2,-4(fp)
 d02d9f8:	00000106 	br	d02da00 <t_shutdown+0xcc>
   }
   return 0;
 d02d9fc:	e03fff15 	stw	zero,-4(fp)
 d02da00:	e0bfff17 	ldw	r2,-4(fp)
}
 d02da04:	e037883a 	mov	sp,fp
 d02da08:	dfc00117 	ldw	ra,4(sp)
 d02da0c:	df000017 	ldw	fp,0(sp)
 d02da10:	dec00204 	addi	sp,sp,8
 d02da14:	f800283a 	ret

0d02da18 <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 d02da18:	defff904 	addi	sp,sp,-28
 d02da1c:	dfc00615 	stw	ra,24(sp)
 d02da20:	df000515 	stw	fp,20(sp)
 d02da24:	df000504 	addi	fp,sp,20
 d02da28:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 d02da2c:	e0bffe17 	ldw	r2,-8(fp)
 d02da30:	10bff804 	addi	r2,r2,-32
 d02da34:	1085883a 	add	r2,r2,r2
 d02da38:	1085883a 	add	r2,r2,r2
 d02da3c:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 d02da40:	008341b4 	movhi	r2,3334
 d02da44:	10b3e204 	addi	r2,r2,-12408
 d02da48:	e0bffb15 	stw	r2,-20(fp)
 d02da4c:	00000606 	br	d02da68 <t_socketclose+0x50>
 d02da50:	e0fffb17 	ldw	r3,-20(fp)
 d02da54:	e0bffd17 	ldw	r2,-12(fp)
 d02da58:	18800626 	beq	r3,r2,d02da74 <t_socketclose+0x5c>
 d02da5c:	e0bffb17 	ldw	r2,-20(fp)
 d02da60:	10800017 	ldw	r2,0(r2)
 d02da64:	e0bffb15 	stw	r2,-20(fp)
 d02da68:	e0bffb17 	ldw	r2,-20(fp)
 d02da6c:	1004c03a 	cmpne	r2,r2,zero
 d02da70:	103ff71e 	bne	r2,zero,d02da50 <t_socketclose+0x38>
 d02da74:	e0fffb17 	ldw	r3,-20(fp)
 d02da78:	e0bffd17 	ldw	r2,-12(fp)
 d02da7c:	18800426 	beq	r3,r2,d02da90 <t_socketclose+0x78>
 d02da80:	d0293e80 	call	d0293e8 <dtrap>
 d02da84:	00bfffc4 	movi	r2,-1
 d02da88:	e0bfff15 	stw	r2,-4(fp)
 d02da8c:	00001006 	br	d02dad0 <t_socketclose+0xb8>
   so->so_error = 0;
 d02da90:	e0bffd17 	ldw	r2,-12(fp)
 d02da94:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 d02da98:	0009883a 	mov	r4,zero
 d02da9c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   err = soclose(so);
 d02daa0:	e13ffd17 	ldw	r4,-12(fp)
 d02daa4:	d02e0640 	call	d02e064 <soclose>
 d02daa8:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02daac:	0009883a 	mov	r4,zero
 d02dab0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 d02dab4:	e0bffc17 	ldw	r2,-16(fp)
 d02dab8:	1005003a 	cmpeq	r2,r2,zero
 d02dabc:	1000031e 	bne	r2,zero,d02dacc <t_socketclose+0xb4>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 d02dac0:	00bfffc4 	movi	r2,-1
 d02dac4:	e0bfff15 	stw	r2,-4(fp)
 d02dac8:	00000106 	br	d02dad0 <t_socketclose+0xb8>
   }
   return 0;
 d02dacc:	e03fff15 	stw	zero,-4(fp)
 d02dad0:	e0bfff17 	ldw	r2,-4(fp)
}
 d02dad4:	e037883a 	mov	sp,fp
 d02dad8:	dfc00117 	ldw	ra,4(sp)
 d02dadc:	df000017 	ldw	fp,0(sp)
 d02dae0:	dec00204 	addi	sp,sp,8
 d02dae4:	f800283a 	ret

0d02dae8 <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 d02dae8:	defff904 	addi	sp,sp,-28
 d02daec:	dfc00615 	stw	ra,24(sp)
 d02daf0:	df000515 	stw	fp,20(sp)
 d02daf4:	df000504 	addi	fp,sp,20
 d02daf8:	e13ffc15 	stw	r4,-16(fp)
 d02dafc:	e17ffd15 	stw	r5,-12(fp)
 d02db00:	e1bffe15 	stw	r6,-8(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 d02db04:	0009883a 	mov	r4,zero
 d02db08:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 d02db0c:	e13ffe17 	ldw	r4,-8(fp)
 d02db10:	e17ffd17 	ldw	r5,-12(fp)
 d02db14:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02db18:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d02db1c:	0009883a 	mov	r4,zero
 d02db20:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 d02db24:	e0bffb17 	ldw	r2,-20(fp)
 d02db28:	1004c03a 	cmpne	r2,r2,zero
 d02db2c:	1000021e 	bne	r2,zero,d02db38 <sockargs+0x50>
      return NULL;
 d02db30:	e03fff15 	stw	zero,-4(fp)
 d02db34:	00000c06 	br	d02db68 <sockargs+0x80>
   m->m_len = arglen;
 d02db38:	e0fffd17 	ldw	r3,-12(fp)
 d02db3c:	e0bffb17 	ldw	r2,-20(fp)
 d02db40:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 d02db44:	e0bffb17 	ldw	r2,-20(fp)
 d02db48:	10c00317 	ldw	r3,12(r2)
 d02db4c:	e1bffd17 	ldw	r6,-12(fp)
 d02db50:	e0bffc17 	ldw	r2,-16(fp)
 d02db54:	1809883a 	mov	r4,r3
 d02db58:	100b883a 	mov	r5,r2
 d02db5c:	d0027000 	call	d002700 <memcpy>
   return m;
 d02db60:	e0bffb17 	ldw	r2,-20(fp)
 d02db64:	e0bfff15 	stw	r2,-4(fp)
 d02db68:	e0bfff17 	ldw	r2,-4(fp)
}
 d02db6c:	e037883a 	mov	sp,fp
 d02db70:	dfc00117 	ldw	ra,4(sp)
 d02db74:	df000017 	ldw	fp,0(sp)
 d02db78:	dec00204 	addi	sp,sp,8
 d02db7c:	f800283a 	ret

0d02db80 <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 d02db80:	defffa04 	addi	sp,sp,-24
 d02db84:	dfc00515 	stw	ra,20(sp)
 d02db88:	df000415 	stw	fp,16(sp)
 d02db8c:	df000404 	addi	fp,sp,16
 d02db90:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 d02db94:	e0bfff17 	ldw	r2,-4(fp)
 d02db98:	10bff804 	addi	r2,r2,-32
 d02db9c:	1085883a 	add	r2,r2,r2
 d02dba0:	1085883a 	add	r2,r2,r2
 d02dba4:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 d02dba8:	00801b04 	movi	r2,108
 d02dbac:	e0bffc15 	stw	r2,-16(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 d02dbb0:	0009883a 	mov	r4,zero
 d02dbb4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 d02dbb8:	008341b4 	movhi	r2,3334
 d02dbbc:	10b3e204 	addi	r2,r2,-12408
 d02dbc0:	e0bffd15 	stw	r2,-12(fp)
 d02dbc4:	00000a06 	br	d02dbf0 <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 d02dbc8:	e0fffd17 	ldw	r3,-12(fp)
 d02dbcc:	e0bffe17 	ldw	r2,-8(fp)
 d02dbd0:	1880041e 	bne	r3,r2,d02dbe4 <t_errno+0x64>
      {
         errcode = so->so_error;
 d02dbd4:	e0bffe17 	ldw	r2,-8(fp)
 d02dbd8:	10800617 	ldw	r2,24(r2)
 d02dbdc:	e0bffc15 	stw	r2,-16(fp)
         break;
 d02dbe0:	00000606 	br	d02dbfc <t_errno+0x7c>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 d02dbe4:	e0bffd17 	ldw	r2,-12(fp)
 d02dbe8:	10800017 	ldw	r2,0(r2)
 d02dbec:	e0bffd15 	stw	r2,-12(fp)
 d02dbf0:	e0bffd17 	ldw	r2,-12(fp)
 d02dbf4:	1004c03a 	cmpne	r2,r2,zero
 d02dbf8:	103ff31e 	bne	r2,zero,d02dbc8 <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 d02dbfc:	0009883a 	mov	r4,zero
 d02dc00:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   return errcode;
 d02dc04:	e0bffc17 	ldw	r2,-16(fp)
}
 d02dc08:	e037883a 	mov	sp,fp
 d02dc0c:	dfc00117 	ldw	ra,4(sp)
 d02dc10:	df000017 	ldw	fp,0(sp)
 d02dc14:	dec00204 	addi	sp,sp,8
 d02dc18:	f800283a 	ret

0d02dc1c <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 d02dc1c:	defff604 	addi	sp,sp,-40
 d02dc20:	dfc00915 	stw	ra,36(sp)
 d02dc24:	df000815 	stw	fp,32(sp)
 d02dc28:	df000804 	addi	fp,sp,32
 d02dc2c:	e13ffc15 	stw	r4,-16(fp)
 d02dc30:	e17ffd15 	stw	r5,-12(fp)
 d02dc34:	e1bffe15 	stw	r6,-8(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 d02dc38:	e0bffe17 	ldw	r2,-8(fp)
 d02dc3c:	1005003a 	cmpeq	r2,r2,zero
 d02dc40:	1000061e 	bne	r2,zero,d02dc5c <socreate+0x40>
      prp = pffindproto(dom, proto, type);
 d02dc44:	e13ffc17 	ldw	r4,-16(fp)
 d02dc48:	e17ffe17 	ldw	r5,-8(fp)
 d02dc4c:	e1bffd17 	ldw	r6,-12(fp)
 d02dc50:	d02a1180 	call	d02a118 <pffindproto>
 d02dc54:	e0bffb15 	stw	r2,-20(fp)
 d02dc58:	00000406 	br	d02dc6c <socreate+0x50>
   else
      prp = pffindtype(dom, type);
 d02dc5c:	e13ffc17 	ldw	r4,-16(fp)
 d02dc60:	e17ffd17 	ldw	r5,-12(fp)
 d02dc64:	d02a0780 	call	d02a078 <pffindtype>
 d02dc68:	e0bffb15 	stw	r2,-20(fp)
   if (prp == 0)
 d02dc6c:	e0bffb17 	ldw	r2,-20(fp)
 d02dc70:	1004c03a 	cmpne	r2,r2,zero
 d02dc74:	1000021e 	bne	r2,zero,d02dc80 <socreate+0x64>
      return NULL;
 d02dc78:	e03fff15 	stw	zero,-4(fp)
 d02dc7c:	00005406 	br	d02ddd0 <socreate+0x1b4>
   if (prp->pr_type != type)
 d02dc80:	e0bffb17 	ldw	r2,-20(fp)
 d02dc84:	1080000b 	ldhu	r2,0(r2)
 d02dc88:	10ffffcc 	andi	r3,r2,65535
 d02dc8c:	18e0001c 	xori	r3,r3,32768
 d02dc90:	18e00004 	addi	r3,r3,-32768
 d02dc94:	e0bffd17 	ldw	r2,-12(fp)
 d02dc98:	18800226 	beq	r3,r2,d02dca4 <socreate+0x88>
      return NULL;
 d02dc9c:	e03fff15 	stw	zero,-4(fp)
 d02dca0:	00004b06 	br	d02ddd0 <socreate+0x1b4>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 d02dca4:	01002104 	movi	r4,132
 d02dca8:	d029e2c0 	call	d029e2c <npalloc>
 d02dcac:	e0bffa15 	stw	r2,-24(fp)
 d02dcb0:	e0bffa17 	ldw	r2,-24(fp)
 d02dcb4:	1004c03a 	cmpne	r2,r2,zero
 d02dcb8:	1000021e 	bne	r2,zero,d02dcc4 <socreate+0xa8>
      return NULL;
 d02dcbc:	e03fff15 	stw	zero,-4(fp)
 d02dcc0:	00004306 	br	d02ddd0 <socreate+0x1b4>
   so->next = NULL;
 d02dcc4:	e0bffa17 	ldw	r2,-24(fp)
 d02dcc8:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 d02dccc:	e17ffa17 	ldw	r5,-24(fp)
 d02dcd0:	010341b4 	movhi	r4,3334
 d02dcd4:	2133e204 	addi	r4,r4,-12408
 d02dcd8:	d028d780 	call	d028d78 <putq>

   so->so_options = socket_defaults;
 d02dcdc:	d0a03c0b 	ldhu	r2,-32528(gp)
 d02dce0:	10ffffcc 	andi	r3,r2,65535
 d02dce4:	e0bffa17 	ldw	r2,-24(fp)
 d02dce8:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 d02dcec:	e0fffa17 	ldw	r3,-24(fp)
 d02dcf0:	e0bffc17 	ldw	r2,-16(fp)
 d02dcf4:	18800515 	stw	r2,20(r3)
   so->so_state = 0;
 d02dcf8:	e0bffa17 	ldw	r2,-24(fp)
 d02dcfc:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 d02dd00:	e0bffd17 	ldw	r2,-12(fp)
 d02dd04:	1007883a 	mov	r3,r2
 d02dd08:	e0bffa17 	ldw	r2,-24(fp)
 d02dd0c:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 d02dd10:	e0fffa17 	ldw	r3,-24(fp)
 d02dd14:	e0bffb17 	ldw	r2,-20(fp)
 d02dd18:	18800215 	stw	r2,8(r3)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 d02dd1c:	e0bffa17 	ldw	r2,-24(fp)
 d02dd20:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 d02dd24:	e0bffa17 	ldw	r2,-24(fp)
 d02dd28:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 d02dd2c:	e0bffb17 	ldw	r2,-20(fp)
 d02dd30:	10800317 	ldw	r2,12(r2)
 d02dd34:	e1bffe17 	ldw	r6,-8(fp)
 d02dd38:	e13ffa17 	ldw	r4,-24(fp)
 d02dd3c:	000b883a 	mov	r5,zero
 d02dd40:	103ee83a 	callr	r2
 d02dd44:	e0bff915 	stw	r2,-28(fp)
   if (error) goto bad;
 d02dd48:	e0bff917 	ldw	r2,-28(fp)
 d02dd4c:	1004c03a 	cmpne	r2,r2,zero
 d02dd50:	10000f1e 	bne	r2,zero,d02dd90 <socreate+0x174>

   if (so_evtmap)
 d02dd54:	00834174 	movhi	r2,3333
 d02dd58:	108aef04 	addi	r2,r2,11196
 d02dd5c:	10800003 	ldbu	r2,0(r2)
 d02dd60:	10803fcc 	andi	r2,r2,255
 d02dd64:	1005003a 	cmpeq	r2,r2,zero
 d02dd68:	1000171e 	bne	r2,zero,d02ddc8 <socreate+0x1ac>
   {                       
      rc = (*so_evtmap_create) (so);
 d02dd6c:	00834174 	movhi	r2,3333
 d02dd70:	108aed04 	addi	r2,r2,11188
 d02dd74:	10800017 	ldw	r2,0(r2)
 d02dd78:	e13ffa17 	ldw	r4,-24(fp)
 d02dd7c:	103ee83a 	callr	r2
 d02dd80:	e0bff815 	stw	r2,-32(fp)
      if (rc != 0)
 d02dd84:	e0bff817 	ldw	r2,-32(fp)
 d02dd88:	1005003a 	cmpeq	r2,r2,zero
 d02dd8c:	10000a1e 	bne	r2,zero,d02ddb8 <socreate+0x19c>
      {
bad:   
         so->so_state |= SS_NOFDREF;
 d02dd90:	e0bffa17 	ldw	r2,-24(fp)
 d02dd94:	1080088b 	ldhu	r2,34(r2)
 d02dd98:	10800054 	ori	r2,r2,1
 d02dd9c:	1007883a 	mov	r3,r2
 d02dda0:	e0bffa17 	ldw	r2,-24(fp)
 d02dda4:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 d02dda8:	e13ffa17 	ldw	r4,-24(fp)
 d02ddac:	d02df340 	call	d02df34 <sofree>
         return NULL;   
 d02ddb0:	e03fff15 	stw	zero,-4(fp)
 d02ddb4:	00000606 	br	d02ddd0 <socreate+0x1b4>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 d02ddb8:	d0252600 	call	d025260 <TK_OSTaskQuery>
 d02ddbc:	1007883a 	mov	r3,r2
 d02ddc0:	e0bffa17 	ldw	r2,-24(fp)
 d02ddc4:	10c02005 	stb	r3,128(r2)
   }

   return so;
 d02ddc8:	e0bffa17 	ldw	r2,-24(fp)
 d02ddcc:	e0bfff15 	stw	r2,-4(fp)
 d02ddd0:	e0bfff17 	ldw	r2,-4(fp)
}
 d02ddd4:	e037883a 	mov	sp,fp
 d02ddd8:	dfc00117 	ldw	ra,4(sp)
 d02dddc:	df000017 	ldw	fp,0(sp)
 d02dde0:	dec00204 	addi	sp,sp,8
 d02dde4:	f800283a 	ret

0d02dde8 <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 d02dde8:	defffb04 	addi	sp,sp,-20
 d02ddec:	dfc00415 	stw	ra,16(sp)
 d02ddf0:	df000315 	stw	fp,12(sp)
 d02ddf4:	df000304 	addi	fp,sp,12
 d02ddf8:	e13ffe15 	stw	r4,-8(fp)
 d02ddfc:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 d02de00:	e0fffe17 	ldw	r3,-8(fp)
 d02de04:	00800084 	movi	r2,2
 d02de08:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 d02de0c:	e0bffe17 	ldw	r2,-8(fp)
 d02de10:	10800217 	ldw	r2,8(r2)
 d02de14:	10800317 	ldw	r2,12(r2)
 d02de18:	e13ffe17 	ldw	r4,-8(fp)
 d02de1c:	000b883a 	mov	r5,zero
 d02de20:	e1bfff17 	ldw	r6,-4(fp)
 d02de24:	103ee83a 	callr	r2
 d02de28:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 d02de2c:	e0bffd17 	ldw	r2,-12(fp)
}
 d02de30:	e037883a 	mov	sp,fp
 d02de34:	dfc00117 	ldw	ra,4(sp)
 d02de38:	df000017 	ldw	fp,0(sp)
 d02de3c:	dec00204 	addi	sp,sp,8
 d02de40:	f800283a 	ret

0d02de44 <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 d02de44:	defff904 	addi	sp,sp,-28
 d02de48:	dfc00615 	stw	ra,24(sp)
 d02de4c:	df000515 	stw	fp,20(sp)
 d02de50:	df000504 	addi	fp,sp,20
 d02de54:	e13ffc15 	stw	r4,-16(fp)
 d02de58:	e17ffd15 	stw	r5,-12(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 d02de5c:	e0fffc17 	ldw	r3,-16(fp)
 d02de60:	008000c4 	movi	r2,3
 d02de64:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so,
 d02de68:	e0bffc17 	ldw	r2,-16(fp)
 d02de6c:	10800217 	ldw	r2,8(r2)
 d02de70:	10800317 	ldw	r2,12(r2)
 d02de74:	e13ffc17 	ldw	r4,-16(fp)
 d02de78:	000b883a 	mov	r5,zero
 d02de7c:	000d883a 	mov	r6,zero
 d02de80:	103ee83a 	callr	r2
 d02de84:	e0bffb15 	stw	r2,-20(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 d02de88:	e0bffb17 	ldw	r2,-20(fp)
 d02de8c:	1005003a 	cmpeq	r2,r2,zero
 d02de90:	1000031e 	bne	r2,zero,d02dea0 <solisten+0x5c>
   {
      return (error);
 d02de94:	e0bffb17 	ldw	r2,-20(fp)
 d02de98:	e0bfff15 	stw	r2,-4(fp)
 d02de9c:	00001f06 	br	d02df1c <solisten+0xd8>
   }
   if (so->so_q == 0) 
 d02dea0:	e0bffc17 	ldw	r2,-16(fp)
 d02dea4:	10801d17 	ldw	r2,116(r2)
 d02dea8:	1004c03a 	cmpne	r2,r2,zero
 d02deac:	10000b1e 	bne	r2,zero,d02dedc <solisten+0x98>
   {
      so->so_q = so;
 d02deb0:	e0fffc17 	ldw	r3,-16(fp)
 d02deb4:	e0bffc17 	ldw	r2,-16(fp)
 d02deb8:	18801d15 	stw	r2,116(r3)
      so->so_q0 = so;
 d02debc:	e0fffc17 	ldw	r3,-16(fp)
 d02dec0:	e0bffc17 	ldw	r2,-16(fp)
 d02dec4:	18801c15 	stw	r2,112(r3)
      so->so_options |= SO_ACCEPTCONN;
 d02dec8:	e0bffc17 	ldw	r2,-16(fp)
 d02decc:	10800417 	ldw	r2,16(r2)
 d02ded0:	10c00094 	ori	r3,r2,2
 d02ded4:	e0bffc17 	ldw	r2,-16(fp)
 d02ded8:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 d02dedc:	e0bffd17 	ldw	r2,-12(fp)
 d02dee0:	1004403a 	cmpge	r2,r2,zero
 d02dee4:	1000011e 	bne	r2,zero,d02deec <solisten+0xa8>
      backlog = 0;
 d02dee8:	e03ffd15 	stw	zero,-12(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 d02deec:	e0fffd17 	ldw	r3,-12(fp)
 d02def0:	e0fffe15 	stw	r3,-8(fp)
 d02def4:	e0fffe17 	ldw	r3,-8(fp)
 d02def8:	18800190 	cmplti	r2,r3,6
 d02defc:	1000021e 	bne	r2,zero,d02df08 <solisten+0xc4>
 d02df00:	00800144 	movi	r2,5
 d02df04:	e0bffe15 	stw	r2,-8(fp)
 d02df08:	e0bffe17 	ldw	r2,-8(fp)
 d02df0c:	1007883a 	mov	r3,r2
 d02df10:	e0bffc17 	ldw	r2,-16(fp)
 d02df14:	10c01e85 	stb	r3,122(r2)
   return 0;
 d02df18:	e03fff15 	stw	zero,-4(fp)
 d02df1c:	e0bfff17 	ldw	r2,-4(fp)
}
 d02df20:	e037883a 	mov	sp,fp
 d02df24:	dfc00117 	ldw	ra,4(sp)
 d02df28:	df000017 	ldw	fp,0(sp)
 d02df2c:	dec00204 	addi	sp,sp,8
 d02df30:	f800283a 	ret

0d02df34 <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 d02df34:	defffd04 	addi	sp,sp,-12
 d02df38:	dfc00215 	stw	ra,8(sp)
 d02df3c:	df000115 	stw	fp,4(sp)
 d02df40:	df000104 	addi	fp,sp,4
 d02df44:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 d02df48:	e0bfff17 	ldw	r2,-4(fp)
 d02df4c:	10800117 	ldw	r2,4(r2)
 d02df50:	1004c03a 	cmpne	r2,r2,zero
 d02df54:	10003e1e 	bne	r2,zero,d02e050 <sofree+0x11c>
 d02df58:	e0bfff17 	ldw	r2,-4(fp)
 d02df5c:	1080088b 	ldhu	r2,34(r2)
 d02df60:	10bfffcc 	andi	r2,r2,65535
 d02df64:	1080004c 	andi	r2,r2,1
 d02df68:	1004c03a 	cmpne	r2,r2,zero
 d02df6c:	1000011e 	bne	r2,zero,d02df74 <sofree+0x40>
      return;
 d02df70:	00003706 	br	d02e050 <sofree+0x11c>
   if (so->so_head) 
 d02df74:	e0bfff17 	ldw	r2,-4(fp)
 d02df78:	10801b17 	ldw	r2,108(r2)
 d02df7c:	1005003a 	cmpeq	r2,r2,zero
 d02df80:	10000f1e 	bne	r2,zero,d02dfc0 <sofree+0x8c>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 d02df84:	e13fff17 	ldw	r4,-4(fp)
 d02df88:	000b883a 	mov	r5,zero
 d02df8c:	d0305080 	call	d030508 <soqremque>
 d02df90:	1004c03a 	cmpne	r2,r2,zero
 d02df94:	1000081e 	bne	r2,zero,d02dfb8 <sofree+0x84>
 d02df98:	e13fff17 	ldw	r4,-4(fp)
 d02df9c:	01400044 	movi	r5,1
 d02dfa0:	d0305080 	call	d030508 <soqremque>
 d02dfa4:	1004c03a 	cmpne	r2,r2,zero
 d02dfa8:	1000031e 	bne	r2,zero,d02dfb8 <sofree+0x84>
         panic("sofree");
 d02dfac:	01034174 	movhi	r4,3333
 d02dfb0:	213de604 	addi	r4,r4,-2152
 d02dfb4:	d0246440 	call	d024644 <panic>
      so->so_head = 0;
 d02dfb8:	e0bfff17 	ldw	r2,-4(fp)
 d02dfbc:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 d02dfc0:	e0bfff17 	ldw	r2,-4(fp)
 d02dfc4:	11001204 	addi	r4,r2,72
 d02dfc8:	d0308e40 	call	d0308e4 <sbrelease>
   sorflush(so);
 d02dfcc:	e13fff17 	ldw	r4,-4(fp)
 d02dfd0:	d02f44c0 	call	d02f44c <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 d02dfd4:	e0bfff17 	ldw	r2,-4(fp)
 d02dfd8:	10800317 	ldw	r2,12(r2)
 d02dfdc:	1005003a 	cmpeq	r2,r2,zero
 d02dfe0:	1000031e 	bne	r2,zero,d02dff0 <sofree+0xbc>
	   ip_freemoptions(so->inp_moptions);
 d02dfe4:	e0bfff17 	ldw	r2,-4(fp)
 d02dfe8:	11000317 	ldw	r4,12(r2)
 d02dfec:	d0449f40 	call	d0449f4 <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 d02dff0:	e0bfff17 	ldw	r2,-4(fp)
 d02dff4:	10801f17 	ldw	r2,124(r2)
 d02dff8:	1005003a 	cmpeq	r2,r2,zero
 d02dffc:	1000031e 	bne	r2,zero,d02e00c <sofree+0xd8>
      SOCOPT_FREE(so->so_optsPack);
 d02e000:	e0bfff17 	ldw	r2,-4(fp)
 d02e004:	11001f17 	ldw	r4,124(r2)
 d02e008:	d029f200 	call	d029f20 <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 d02e00c:	010341b4 	movhi	r4,3334
 d02e010:	2133e204 	addi	r4,r4,-12408
 d02e014:	e17fff17 	ldw	r5,-4(fp)
 d02e018:	d028e280 	call	d028e28 <qdel>
   
   if (so_evtmap)  
 d02e01c:	00834174 	movhi	r2,3333
 d02e020:	108aef04 	addi	r2,r2,11196
 d02e024:	10800003 	ldbu	r2,0(r2)
 d02e028:	10803fcc 	andi	r2,r2,255
 d02e02c:	1005003a 	cmpeq	r2,r2,zero
 d02e030:	1000051e 	bne	r2,zero,d02e048 <sofree+0x114>
      (*so_evtmap_delete) (so);
 d02e034:	00834174 	movhi	r2,3333
 d02e038:	108aee04 	addi	r2,r2,11192
 d02e03c:	10800017 	ldw	r2,0(r2)
 d02e040:	e13fff17 	ldw	r4,-4(fp)
 d02e044:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 d02e048:	e13fff17 	ldw	r4,-4(fp)
 d02e04c:	d029f200 	call	d029f20 <npfree>
}
 d02e050:	e037883a 	mov	sp,fp
 d02e054:	dfc00117 	ldw	ra,4(sp)
 d02e058:	df000017 	ldw	fp,0(sp)
 d02e05c:	dec00204 	addi	sp,sp,8
 d02e060:	f800283a 	ret

0d02e064 <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 d02e064:	defff804 	addi	sp,sp,-32
 d02e068:	dfc00715 	stw	ra,28(sp)
 d02e06c:	df000615 	stw	fp,24(sp)
 d02e070:	df000604 	addi	fp,sp,24
 d02e074:	e13ffe15 	stw	r4,-8(fp)
   int   error =  0;
 d02e078:	e03ffd15 	stw	zero,-12(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 d02e07c:	008341b4 	movhi	r2,3334
 d02e080:	10b3e204 	addi	r2,r2,-12408
 d02e084:	10800017 	ldw	r2,0(r2)
 d02e088:	e0bffc15 	stw	r2,-16(fp)
 d02e08c:	00000606 	br	d02e0a8 <soclose+0x44>
   {
      if (so == tmpso)
 d02e090:	e0fffe17 	ldw	r3,-8(fp)
 d02e094:	e0bffc17 	ldw	r2,-16(fp)
 d02e098:	18800626 	beq	r3,r2,d02e0b4 <soclose+0x50>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 d02e09c:	e0bffc17 	ldw	r2,-16(fp)
 d02e0a0:	10800017 	ldw	r2,0(r2)
 d02e0a4:	e0bffc15 	stw	r2,-16(fp)
 d02e0a8:	e0bffc17 	ldw	r2,-16(fp)
 d02e0ac:	1004c03a 	cmpne	r2,r2,zero
 d02e0b0:	103ff71e 	bne	r2,zero,d02e090 <soclose+0x2c>
   {
      if (so == tmpso)
         break;
   }
   if ( tmpso == NULL)
 d02e0b4:	e0bffc17 	ldw	r2,-16(fp)
 d02e0b8:	1004c03a 	cmpne	r2,r2,zero
 d02e0bc:	1000031e 	bne	r2,zero,d02e0cc <soclose+0x68>
      return EINVAL;
 d02e0c0:	00800584 	movi	r2,22
 d02e0c4:	e0bfff15 	stw	r2,-4(fp)
 d02e0c8:	00009d06 	br	d02e340 <soclose+0x2dc>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 d02e0cc:	e0bffe17 	ldw	r2,-8(fp)
 d02e0d0:	10800417 	ldw	r2,16(r2)
 d02e0d4:	1080008c 	andi	r2,r2,2
 d02e0d8:	1005003a 	cmpeq	r2,r2,zero
 d02e0dc:	1000101e 	bne	r2,zero,d02e120 <soclose+0xbc>
   {
      while (so->so_q0 != so)
 d02e0e0:	00000306 	br	d02e0f0 <soclose+0x8c>
         (void) soabort(so->so_q0);
 d02e0e4:	e0bffe17 	ldw	r2,-8(fp)
 d02e0e8:	11001c17 	ldw	r4,112(r2)
 d02e0ec:	d02e3580 	call	d02e358 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 d02e0f0:	e0bffe17 	ldw	r2,-8(fp)
 d02e0f4:	10c01c17 	ldw	r3,112(r2)
 d02e0f8:	e0bffe17 	ldw	r2,-8(fp)
 d02e0fc:	18bff91e 	bne	r3,r2,d02e0e4 <soclose+0x80>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 d02e100:	00000306 	br	d02e110 <soclose+0xac>
         (void) soabort(so->so_q);
 d02e104:	e0bffe17 	ldw	r2,-8(fp)
 d02e108:	11001d17 	ldw	r4,116(r2)
 d02e10c:	d02e3580 	call	d02e358 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 d02e110:	e0bffe17 	ldw	r2,-8(fp)
 d02e114:	10c01d17 	ldw	r3,116(r2)
 d02e118:	e0bffe17 	ldw	r2,-8(fp)
 d02e11c:	18bff91e 	bne	r3,r2,d02e104 <soclose+0xa0>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 d02e120:	e0bffe17 	ldw	r2,-8(fp)
 d02e124:	10800983 	ldbu	r2,38(r2)
 d02e128:	10803fcc 	andi	r2,r2,255
 d02e12c:	1080201c 	xori	r2,r2,128
 d02e130:	10bfe004 	addi	r2,r2,-128
 d02e134:	10800060 	cmpeqi	r2,r2,1
 d02e138:	10000c1e 	bne	r2,zero,d02e16c <soclose+0x108>
   { 
      so->so_req = PRU_DETACH;
 d02e13c:	e0fffe17 	ldw	r3,-8(fp)
 d02e140:	00800044 	movi	r2,1
 d02e144:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so,
 d02e148:	e0bffe17 	ldw	r2,-8(fp)
 d02e14c:	10800217 	ldw	r2,8(r2)
 d02e150:	10800317 	ldw	r2,12(r2)
 d02e154:	e13ffe17 	ldw	r4,-8(fp)
 d02e158:	000b883a 	mov	r5,zero
 d02e15c:	000d883a 	mov	r6,zero
 d02e160:	103ee83a 	callr	r2
 d02e164:	e0bffd15 	stw	r2,-12(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 d02e168:	00006306 	br	d02e2f8 <soclose+0x294>
   }

   if (so->so_pcb == 0)
 d02e16c:	e0bffe17 	ldw	r2,-8(fp)
 d02e170:	10800117 	ldw	r2,4(r2)
 d02e174:	1005003a 	cmpeq	r2,r2,zero
 d02e178:	10005f1e 	bne	r2,zero,d02e2f8 <soclose+0x294>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 d02e17c:	e0bffe17 	ldw	r2,-8(fp)
 d02e180:	1080088b 	ldhu	r2,34(r2)
 d02e184:	10bfffcc 	andi	r2,r2,65535
 d02e188:	1080008c 	andi	r2,r2,2
 d02e18c:	1005003a 	cmpeq	r2,r2,zero
 d02e190:	1000451e 	bne	r2,zero,d02e2a8 <soclose+0x244>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 d02e194:	e0bffe17 	ldw	r2,-8(fp)
 d02e198:	1080088b 	ldhu	r2,34(r2)
 d02e19c:	10bfffcc 	andi	r2,r2,65535
 d02e1a0:	1080020c 	andi	r2,r2,8
 d02e1a4:	1004c03a 	cmpne	r2,r2,zero
 d02e1a8:	1000061e 	bne	r2,zero,d02e1c4 <soclose+0x160>
      {
         error = sodisconnect(so);
 d02e1ac:	e13ffe17 	ldw	r4,-8(fp)
 d02e1b0:	d02e5180 	call	d02e518 <sodisconnect>
 d02e1b4:	e0bffd15 	stw	r2,-12(fp)
         if (error)
 d02e1b8:	e0bffd17 	ldw	r2,-12(fp)
 d02e1bc:	1004c03a 	cmpne	r2,r2,zero
 d02e1c0:	1000391e 	bne	r2,zero,d02e2a8 <soclose+0x244>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 d02e1c4:	e0bffe17 	ldw	r2,-8(fp)
 d02e1c8:	10800417 	ldw	r2,16(r2)
 d02e1cc:	1080200c 	andi	r2,r2,128
 d02e1d0:	1005003a 	cmpeq	r2,r2,zero
 d02e1d4:	1000281e 	bne	r2,zero,d02e278 <soclose+0x214>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 d02e1d8:	e0bffe17 	ldw	r2,-8(fp)
 d02e1dc:	1080088b 	ldhu	r2,34(r2)
 d02e1e0:	10bfffcc 	andi	r2,r2,65535
 d02e1e4:	1080020c 	andi	r2,r2,8
 d02e1e8:	1005003a 	cmpeq	r2,r2,zero
 d02e1ec:	1000061e 	bne	r2,zero,d02e208 <soclose+0x1a4>
 d02e1f0:	e0bffe17 	ldw	r2,-8(fp)
 d02e1f4:	1080088b 	ldhu	r2,34(r2)
 d02e1f8:	10bfffcc 	andi	r2,r2,65535
 d02e1fc:	1080400c 	andi	r2,r2,256
 d02e200:	1004c03a 	cmpne	r2,r2,zero
 d02e204:	1000281e 	bne	r2,zero,d02e2a8 <soclose+0x244>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 d02e208:	e0bffe17 	ldw	r2,-8(fp)
 d02e20c:	1080080b 	ldhu	r2,32(r2)
 d02e210:	10bfffcc 	andi	r2,r2,65535
 d02e214:	10a0001c 	xori	r2,r2,32768
 d02e218:	10a00004 	addi	r2,r2,-32768
 d02e21c:	10c01924 	muli	r3,r2,100
 d02e220:	00834174 	movhi	r2,3333
 d02e224:	108ac904 	addi	r2,r2,11044
 d02e228:	10800017 	ldw	r2,0(r2)
 d02e22c:	1885883a 	add	r2,r3,r2
 d02e230:	e0bffb15 	stw	r2,-20(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 d02e234:	00000406 	br	d02e248 <soclose+0x1e4>
         {
            tcp_sleep((char *)&so->so_timeo);
 d02e238:	e0bffe17 	ldw	r2,-8(fp)
 d02e23c:	10800904 	addi	r2,r2,36
 d02e240:	1009883a 	mov	r4,r2
 d02e244:	d024fbc0 	call	d024fbc <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 d02e248:	e0bffe17 	ldw	r2,-8(fp)
 d02e24c:	1080088b 	ldhu	r2,34(r2)
 d02e250:	10bfffcc 	andi	r2,r2,65535
 d02e254:	1080008c 	andi	r2,r2,2
 d02e258:	1005003a 	cmpeq	r2,r2,zero
 d02e25c:	1000121e 	bne	r2,zero,d02e2a8 <soclose+0x244>
 d02e260:	00834174 	movhi	r2,3333
 d02e264:	108ac904 	addi	r2,r2,11044
 d02e268:	10c00017 	ldw	r3,0(r2)
 d02e26c:	e0bffb17 	ldw	r2,-20(fp)
 d02e270:	18bff136 	bltu	r3,r2,d02e238 <soclose+0x1d4>
 d02e274:	00000c06 	br	d02e2a8 <soclose+0x244>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 d02e278:	e0bffe17 	ldw	r2,-8(fp)
 d02e27c:	10801217 	ldw	r2,72(r2)
 d02e280:	1005003a 	cmpeq	r2,r2,zero
 d02e284:	1000081e 	bne	r2,zero,d02e2a8 <soclose+0x244>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 d02e288:	e0bffe17 	ldw	r2,-8(fp)
 d02e28c:	1080088b 	ldhu	r2,34(r2)
 d02e290:	10800054 	ori	r2,r2,1
 d02e294:	1007883a 	mov	r3,r2
 d02e298:	e0bffe17 	ldw	r2,-8(fp)
 d02e29c:	10c0088d 	sth	r3,34(r2)
            return 0;
 d02e2a0:	e03fff15 	stw	zero,-4(fp)
 d02e2a4:	00002606 	br	d02e340 <soclose+0x2dc>
         }
      }
   }
drop:
   if (so->so_pcb) 
 d02e2a8:	e0bffe17 	ldw	r2,-8(fp)
 d02e2ac:	10800117 	ldw	r2,4(r2)
 d02e2b0:	1005003a 	cmpeq	r2,r2,zero
 d02e2b4:	1000101e 	bne	r2,zero,d02e2f8 <soclose+0x294>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 d02e2b8:	e0fffe17 	ldw	r3,-8(fp)
 d02e2bc:	00800044 	movi	r2,1
 d02e2c0:	18800715 	stw	r2,28(r3)
      error2 = (*so->so_proto->pr_usrreq)(so,
 d02e2c4:	e0bffe17 	ldw	r2,-8(fp)
 d02e2c8:	10800217 	ldw	r2,8(r2)
 d02e2cc:	10800317 	ldw	r2,12(r2)
 d02e2d0:	e13ffe17 	ldw	r4,-8(fp)
 d02e2d4:	000b883a 	mov	r5,zero
 d02e2d8:	000d883a 	mov	r6,zero
 d02e2dc:	103ee83a 	callr	r2
 d02e2e0:	e0bffa15 	stw	r2,-24(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 d02e2e4:	e0bffd17 	ldw	r2,-12(fp)
 d02e2e8:	1004c03a 	cmpne	r2,r2,zero
 d02e2ec:	1000021e 	bne	r2,zero,d02e2f8 <soclose+0x294>
         error = error2;
 d02e2f0:	e0bffa17 	ldw	r2,-24(fp)
 d02e2f4:	e0bffd15 	stw	r2,-12(fp)
   }
discard:
   if (so->so_state & SS_NOFDREF)
 d02e2f8:	e0bffe17 	ldw	r2,-8(fp)
 d02e2fc:	1080088b 	ldhu	r2,34(r2)
 d02e300:	10bfffcc 	andi	r2,r2,65535
 d02e304:	1080004c 	andi	r2,r2,1
 d02e308:	10803fcc 	andi	r2,r2,255
 d02e30c:	1005003a 	cmpeq	r2,r2,zero
 d02e310:	1000011e 	bne	r2,zero,d02e318 <soclose+0x2b4>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 d02e314:	d0293e80 	call	d0293e8 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 d02e318:	e0bffe17 	ldw	r2,-8(fp)
 d02e31c:	1080088b 	ldhu	r2,34(r2)
 d02e320:	10800054 	ori	r2,r2,1
 d02e324:	1007883a 	mov	r3,r2
 d02e328:	e0bffe17 	ldw	r2,-8(fp)
 d02e32c:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 d02e330:	e13ffe17 	ldw	r4,-8(fp)
 d02e334:	d02df340 	call	d02df34 <sofree>
   return (error);
 d02e338:	e0bffd17 	ldw	r2,-12(fp)
 d02e33c:	e0bfff15 	stw	r2,-4(fp)
 d02e340:	e0bfff17 	ldw	r2,-4(fp)
}
 d02e344:	e037883a 	mov	sp,fp
 d02e348:	dfc00117 	ldw	ra,4(sp)
 d02e34c:	df000017 	ldw	fp,0(sp)
 d02e350:	dec00204 	addi	sp,sp,8
 d02e354:	f800283a 	ret

0d02e358 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 d02e358:	defffd04 	addi	sp,sp,-12
 d02e35c:	dfc00215 	stw	ra,8(sp)
 d02e360:	df000115 	stw	fp,4(sp)
 d02e364:	df000104 	addi	fp,sp,4
 d02e368:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 d02e36c:	e0ffff17 	ldw	r3,-4(fp)
 d02e370:	00800284 	movi	r2,10
 d02e374:	18800715 	stw	r2,28(r3)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 d02e378:	e0bfff17 	ldw	r2,-4(fp)
 d02e37c:	10800217 	ldw	r2,8(r2)
 d02e380:	10800317 	ldw	r2,12(r2)
 d02e384:	e13fff17 	ldw	r4,-4(fp)
 d02e388:	000b883a 	mov	r5,zero
 d02e38c:	000d883a 	mov	r6,zero
 d02e390:	103ee83a 	callr	r2
}
 d02e394:	e037883a 	mov	sp,fp
 d02e398:	dfc00117 	ldw	ra,4(sp)
 d02e39c:	df000017 	ldw	fp,0(sp)
 d02e3a0:	dec00204 	addi	sp,sp,8
 d02e3a4:	f800283a 	ret

0d02e3a8 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 d02e3a8:	defffb04 	addi	sp,sp,-20
 d02e3ac:	dfc00415 	stw	ra,16(sp)
 d02e3b0:	df000315 	stw	fp,12(sp)
 d02e3b4:	df000304 	addi	fp,sp,12
 d02e3b8:	e13ffe15 	stw	r4,-8(fp)
 d02e3bc:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 d02e3c0:	e0bffe17 	ldw	r2,-8(fp)
 d02e3c4:	1080088b 	ldhu	r2,34(r2)
 d02e3c8:	10bfffcc 	andi	r2,r2,65535
 d02e3cc:	1080004c 	andi	r2,r2,1
 d02e3d0:	1004c03a 	cmpne	r2,r2,zero
 d02e3d4:	1000031e 	bne	r2,zero,d02e3e4 <soaccept+0x3c>
      panic("soaccept");
 d02e3d8:	01034174 	movhi	r4,3333
 d02e3dc:	213de804 	addi	r4,r4,-2144
 d02e3e0:	d0246440 	call	d024644 <panic>
   so->so_state &= ~SS_NOFDREF;
 d02e3e4:	e0bffe17 	ldw	r2,-8(fp)
 d02e3e8:	10c0088b 	ldhu	r3,34(r2)
 d02e3ec:	00bfff84 	movi	r2,-2
 d02e3f0:	1884703a 	and	r2,r3,r2
 d02e3f4:	1007883a 	mov	r3,r2
 d02e3f8:	e0bffe17 	ldw	r2,-8(fp)
 d02e3fc:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 d02e400:	e0fffe17 	ldw	r3,-8(fp)
 d02e404:	00800144 	movi	r2,5
 d02e408:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 d02e40c:	e0bffe17 	ldw	r2,-8(fp)
 d02e410:	10800217 	ldw	r2,8(r2)
 d02e414:	10800317 	ldw	r2,12(r2)
 d02e418:	e13ffe17 	ldw	r4,-8(fp)
 d02e41c:	000b883a 	mov	r5,zero
 d02e420:	e1bfff17 	ldw	r6,-4(fp)
 d02e424:	103ee83a 	callr	r2
 d02e428:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 d02e42c:	e0bffd17 	ldw	r2,-12(fp)
}
 d02e430:	e037883a 	mov	sp,fp
 d02e434:	dfc00117 	ldw	ra,4(sp)
 d02e438:	df000017 	ldw	fp,0(sp)
 d02e43c:	dec00204 	addi	sp,sp,8
 d02e440:	f800283a 	ret

0d02e444 <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 d02e444:	defffa04 	addi	sp,sp,-24
 d02e448:	dfc00515 	stw	ra,20(sp)
 d02e44c:	df000415 	stw	fp,16(sp)
 d02e450:	df000404 	addi	fp,sp,16
 d02e454:	e13ffd15 	stw	r4,-12(fp)
 d02e458:	e17ffe15 	stw	r5,-8(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 d02e45c:	e0bffd17 	ldw	r2,-12(fp)
 d02e460:	10800417 	ldw	r2,16(r2)
 d02e464:	1080008c 	andi	r2,r2,2
 d02e468:	1005003a 	cmpeq	r2,r2,zero
 d02e46c:	1000031e 	bne	r2,zero,d02e47c <soconnect+0x38>
      return (EOPNOTSUPP);
 d02e470:	008017c4 	movi	r2,95
 d02e474:	e0bfff15 	stw	r2,-4(fp)
 d02e478:	00002106 	br	d02e500 <soconnect+0xbc>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 d02e47c:	e0bffd17 	ldw	r2,-12(fp)
 d02e480:	1080088b 	ldhu	r2,34(r2)
 d02e484:	10bfffcc 	andi	r2,r2,65535
 d02e488:	1080018c 	andi	r2,r2,6
 d02e48c:	1005003a 	cmpeq	r2,r2,zero
 d02e490:	10000e1e 	bne	r2,zero,d02e4cc <soconnect+0x88>
 d02e494:	e0bffd17 	ldw	r2,-12(fp)
 d02e498:	10800217 	ldw	r2,8(r2)
 d02e49c:	1080010b 	ldhu	r2,4(r2)
 d02e4a0:	10bfffcc 	andi	r2,r2,65535
 d02e4a4:	1080010c 	andi	r2,r2,4
 d02e4a8:	1004c03a 	cmpne	r2,r2,zero
 d02e4ac:	1000041e 	bne	r2,zero,d02e4c0 <soconnect+0x7c>
 d02e4b0:	e13ffd17 	ldw	r4,-12(fp)
 d02e4b4:	d02e5180 	call	d02e518 <sodisconnect>
 d02e4b8:	1005003a 	cmpeq	r2,r2,zero
 d02e4bc:	1000031e 	bne	r2,zero,d02e4cc <soconnect+0x88>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 d02e4c0:	00801fc4 	movi	r2,127
 d02e4c4:	e0bffc15 	stw	r2,-16(fp)
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 d02e4c8:	00000b06 	br	d02e4f8 <soconnect+0xb4>
   {
      error = EISCONN;
   }
   else
   {
      so->so_req = PRU_CONNECT;
 d02e4cc:	e0fffd17 	ldw	r3,-12(fp)
 d02e4d0:	00800104 	movi	r2,4
 d02e4d4:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 d02e4d8:	e0bffd17 	ldw	r2,-12(fp)
 d02e4dc:	10800217 	ldw	r2,8(r2)
 d02e4e0:	10800317 	ldw	r2,12(r2)
 d02e4e4:	e13ffd17 	ldw	r4,-12(fp)
 d02e4e8:	000b883a 	mov	r5,zero
 d02e4ec:	e1bffe17 	ldw	r6,-8(fp)
 d02e4f0:	103ee83a 	callr	r2
 d02e4f4:	e0bffc15 	stw	r2,-16(fp)
   }
   return error;
 d02e4f8:	e0bffc17 	ldw	r2,-16(fp)
 d02e4fc:	e0bfff15 	stw	r2,-4(fp)
 d02e500:	e0bfff17 	ldw	r2,-4(fp)
}
 d02e504:	e037883a 	mov	sp,fp
 d02e508:	dfc00117 	ldw	ra,4(sp)
 d02e50c:	df000017 	ldw	fp,0(sp)
 d02e510:	dec00204 	addi	sp,sp,8
 d02e514:	f800283a 	ret

0d02e518 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 d02e518:	defffc04 	addi	sp,sp,-16
 d02e51c:	dfc00315 	stw	ra,12(sp)
 d02e520:	df000215 	stw	fp,8(sp)
 d02e524:	df000204 	addi	fp,sp,8
 d02e528:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 d02e52c:	e0bfff17 	ldw	r2,-4(fp)
 d02e530:	1080088b 	ldhu	r2,34(r2)
 d02e534:	10bfffcc 	andi	r2,r2,65535
 d02e538:	1080008c 	andi	r2,r2,2
 d02e53c:	1004c03a 	cmpne	r2,r2,zero
 d02e540:	1000031e 	bne	r2,zero,d02e550 <sodisconnect+0x38>
   {
      error = ENOTCONN;
 d02e544:	00802004 	movi	r2,128
 d02e548:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 d02e54c:	00001406 	br	d02e5a0 <sodisconnect+0x88>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 d02e550:	e0bfff17 	ldw	r2,-4(fp)
 d02e554:	1080088b 	ldhu	r2,34(r2)
 d02e558:	10bfffcc 	andi	r2,r2,65535
 d02e55c:	1080020c 	andi	r2,r2,8
 d02e560:	1005003a 	cmpeq	r2,r2,zero
 d02e564:	1000031e 	bne	r2,zero,d02e574 <sodisconnect+0x5c>
   {
      error = EALREADY;
 d02e568:	00801e04 	movi	r2,120
 d02e56c:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 d02e570:	00000b06 	br	d02e5a0 <sodisconnect+0x88>
   }
   so->so_req = PRU_DISCONNECT;
 d02e574:	e0ffff17 	ldw	r3,-4(fp)
 d02e578:	00800184 	movi	r2,6
 d02e57c:	18800715 	stw	r2,28(r3)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 d02e580:	e0bfff17 	ldw	r2,-4(fp)
 d02e584:	10800217 	ldw	r2,8(r2)
 d02e588:	10800317 	ldw	r2,12(r2)
 d02e58c:	e13fff17 	ldw	r4,-4(fp)
 d02e590:	000b883a 	mov	r5,zero
 d02e594:	000d883a 	mov	r6,zero
 d02e598:	103ee83a 	callr	r2
 d02e59c:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 d02e5a0:	e0bffe17 	ldw	r2,-8(fp)
}
 d02e5a4:	e037883a 	mov	sp,fp
 d02e5a8:	dfc00117 	ldw	ra,4(sp)
 d02e5ac:	df000017 	ldw	fp,0(sp)
 d02e5b0:	dec00204 	addi	sp,sp,8
 d02e5b4:	f800283a 	ret

0d02e5b8 <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 d02e5b8:	deffee04 	addi	sp,sp,-72
 d02e5bc:	dfc01115 	stw	ra,68(sp)
 d02e5c0:	df001015 	stw	fp,64(sp)
 d02e5c4:	df001004 	addi	fp,sp,64
 d02e5c8:	e13ff815 	stw	r4,-32(fp)
 d02e5cc:	e17ff915 	stw	r5,-28(fp)
 d02e5d0:	e1bffa15 	stw	r6,-24(fp)
 d02e5d4:	e1fffb15 	stw	r7,-20(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 d02e5d8:	e03ff715 	stw	zero,-36(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 d02e5dc:	e03ff215 	stw	zero,-56(fp)
   int   dontroute;
   int   first = 1;
 d02e5e0:	00800044 	movi	r2,1
 d02e5e4:	e0bff015 	stw	r2,-64(fp)

   resid = *data_length;
 d02e5e8:	e0bffb17 	ldw	r2,-20(fp)
 d02e5ec:	10800017 	ldw	r2,0(r2)
 d02e5f0:	e0bff415 	stw	r2,-48(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 d02e5f4:	e0bff417 	ldw	r2,-48(fp)
 d02e5f8:	1004403a 	cmpge	r2,r2,zero
 d02e5fc:	1000031e 	bne	r2,zero,d02e60c <sosend+0x54>
      return (EINVAL);
 d02e600:	00800584 	movi	r2,22
 d02e604:	e0bfff15 	stw	r2,-4(fp)
 d02e608:	00016706 	br	d02eba8 <sosend+0x5f0>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 d02e60c:	e0bff817 	ldw	r2,-32(fp)
 d02e610:	10800217 	ldw	r2,8(r2)
 d02e614:	1080010b 	ldhu	r2,4(r2)
 d02e618:	10bfffcc 	andi	r2,r2,65535
 d02e61c:	1080004c 	andi	r2,r2,1
 d02e620:	10803fcc 	andi	r2,r2,255
 d02e624:	1005003a 	cmpeq	r2,r2,zero
 d02e628:	1000081e 	bne	r2,zero,d02e64c <sosend+0x94>
 d02e62c:	e0bff817 	ldw	r2,-32(fp)
 d02e630:	10801317 	ldw	r2,76(r2)
 d02e634:	1007883a 	mov	r3,r2
 d02e638:	e0bff417 	ldw	r2,-48(fp)
 d02e63c:	1880030e 	bge	r3,r2,d02e64c <sosend+0x94>
      return (EMSGSIZE);
 d02e640:	00c01e84 	movi	r3,122
 d02e644:	e0ffff15 	stw	r3,-4(fp)
 d02e648:	00015706 	br	d02eba8 <sosend+0x5f0>

   dontroute = (flags & MSG_DONTROUTE) &&
 d02e64c:	e0800217 	ldw	r2,8(fp)
 d02e650:	1080010c 	andi	r2,r2,4
 d02e654:	1005003a 	cmpeq	r2,r2,zero
 d02e658:	1000111e 	bne	r2,zero,d02e6a0 <sosend+0xe8>
 d02e65c:	e0bff817 	ldw	r2,-32(fp)
 d02e660:	10800417 	ldw	r2,16(r2)
 d02e664:	1080040c 	andi	r2,r2,16
 d02e668:	1004c03a 	cmpne	r2,r2,zero
 d02e66c:	10000c1e 	bne	r2,zero,d02e6a0 <sosend+0xe8>
 d02e670:	e0bff817 	ldw	r2,-32(fp)
 d02e674:	10800217 	ldw	r2,8(r2)
 d02e678:	1080010b 	ldhu	r2,4(r2)
 d02e67c:	10bfffcc 	andi	r2,r2,65535
 d02e680:	1080004c 	andi	r2,r2,1
 d02e684:	1080005c 	xori	r2,r2,1
 d02e688:	10803fcc 	andi	r2,r2,255
 d02e68c:	1004c03a 	cmpne	r2,r2,zero
 d02e690:	1000031e 	bne	r2,zero,d02e6a0 <sosend+0xe8>
 d02e694:	00800044 	movi	r2,1
 d02e698:	e0bffe15 	stw	r2,-8(fp)
 d02e69c:	00000106 	br	d02e6a4 <sosend+0xec>
 d02e6a0:	e03ffe15 	stw	zero,-8(fp)
 d02e6a4:	e0fffe17 	ldw	r3,-8(fp)
 d02e6a8:	e0fff115 	stw	r3,-60(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 d02e6ac:	00000406 	br	d02e6c0 <sosend+0x108>
 d02e6b0:	e0bff817 	ldw	r2,-32(fp)
 d02e6b4:	10801904 	addi	r2,r2,100
 d02e6b8:	1009883a 	mov	r4,r2
 d02e6bc:	d024fbc0 	call	d024fbc <tcp_sleep>
 d02e6c0:	e0bff817 	ldw	r2,-32(fp)
 d02e6c4:	1080190b 	ldhu	r2,100(r2)
 d02e6c8:	10bfffcc 	andi	r2,r2,65535
 d02e6cc:	1080004c 	andi	r2,r2,1
 d02e6d0:	10803fcc 	andi	r2,r2,255
 d02e6d4:	1004c03a 	cmpne	r2,r2,zero
 d02e6d8:	103ff51e 	bne	r2,zero,d02e6b0 <sosend+0xf8>
 d02e6dc:	e0bff817 	ldw	r2,-32(fp)
 d02e6e0:	1080190b 	ldhu	r2,100(r2)
 d02e6e4:	10800054 	ori	r2,r2,1
 d02e6e8:	1007883a 	mov	r3,r2
 d02e6ec:	e0bff817 	ldw	r2,-32(fp)
 d02e6f0:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 d02e6f4:	e0bff817 	ldw	r2,-32(fp)
 d02e6f8:	10800617 	ldw	r2,24(r2)
 d02e6fc:	1005003a 	cmpeq	r2,r2,zero
 d02e700:	1000061e 	bne	r2,zero,d02e71c <sosend+0x164>
      {
         error = so->so_error;
 d02e704:	e0bff817 	ldw	r2,-32(fp)
 d02e708:	10800617 	ldw	r2,24(r2)
 d02e70c:	e0bff215 	stw	r2,-56(fp)
         so->so_error = 0;          /* ??? */
 d02e710:	e0bff817 	ldw	r2,-32(fp)
 d02e714:	10000615 	stw	zero,24(r2)
         goto release;
 d02e718:	00011106 	br	d02eb60 <sosend+0x5a8>
      }
      if (so->so_state & SS_CANTSENDMORE)
 d02e71c:	e0bff817 	ldw	r2,-32(fp)
 d02e720:	1080088b 	ldhu	r2,34(r2)
 d02e724:	10bfffcc 	andi	r2,r2,65535
 d02e728:	1080040c 	andi	r2,r2,16
 d02e72c:	1005003a 	cmpeq	r2,r2,zero
 d02e730:	1000031e 	bne	r2,zero,d02e740 <sosend+0x188>
         snderr(EPIPE);
 d02e734:	00800804 	movi	r2,32
 d02e738:	e0bff215 	stw	r2,-56(fp)
 d02e73c:	00010806 	br	d02eb60 <sosend+0x5a8>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 d02e740:	e0bff817 	ldw	r2,-32(fp)
 d02e744:	1080088b 	ldhu	r2,34(r2)
 d02e748:	10bfffcc 	andi	r2,r2,65535
 d02e74c:	1080008c 	andi	r2,r2,2
 d02e750:	1004c03a 	cmpne	r2,r2,zero
 d02e754:	1000101e 	bne	r2,zero,d02e798 <sosend+0x1e0>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 d02e758:	e0bff817 	ldw	r2,-32(fp)
 d02e75c:	10800217 	ldw	r2,8(r2)
 d02e760:	1080010b 	ldhu	r2,4(r2)
 d02e764:	10bfffcc 	andi	r2,r2,65535
 d02e768:	1080010c 	andi	r2,r2,4
 d02e76c:	1005003a 	cmpeq	r2,r2,zero
 d02e770:	1000031e 	bne	r2,zero,d02e780 <sosend+0x1c8>
            snderr(ENOTCONN);
 d02e774:	00802004 	movi	r2,128
 d02e778:	e0bff215 	stw	r2,-56(fp)
 d02e77c:	0000f806 	br	d02eb60 <sosend+0x5a8>
         if (nam == 0)
 d02e780:	e0bff917 	ldw	r2,-28(fp)
 d02e784:	1004c03a 	cmpne	r2,r2,zero
 d02e788:	1000031e 	bne	r2,zero,d02e798 <sosend+0x1e0>
            snderr(EDESTADDRREQ);
 d02e78c:	00801e44 	movi	r2,121
 d02e790:	e0bff215 	stw	r2,-56(fp)
 d02e794:	0000f206 	br	d02eb60 <sosend+0x5a8>
      }
      if (flags & MSG_OOB)
 d02e798:	e0800217 	ldw	r2,8(fp)
 d02e79c:	1080004c 	andi	r2,r2,1
 d02e7a0:	10803fcc 	andi	r2,r2,255
 d02e7a4:	1005003a 	cmpeq	r2,r2,zero
 d02e7a8:	1000031e 	bne	r2,zero,d02e7b8 <sosend+0x200>
         space = 1024;
 d02e7ac:	00810004 	movi	r2,1024
 d02e7b0:	e0bff515 	stw	r2,-44(fp)
 d02e7b4:	00005106 	br	d02e8fc <sosend+0x344>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 d02e7b8:	e0bff817 	ldw	r2,-32(fp)
 d02e7bc:	10801317 	ldw	r2,76(r2)
 d02e7c0:	1007883a 	mov	r3,r2
 d02e7c4:	e0bff817 	ldw	r2,-32(fp)
 d02e7c8:	10801217 	ldw	r2,72(r2)
 d02e7cc:	1885c83a 	sub	r2,r3,r2
 d02e7d0:	1004803a 	cmplt	r2,r2,zero
 d02e7d4:	1000071e 	bne	r2,zero,d02e7f4 <sosend+0x23c>
 d02e7d8:	e0bff817 	ldw	r2,-32(fp)
 d02e7dc:	10c01317 	ldw	r3,76(r2)
 d02e7e0:	e0bff817 	ldw	r2,-32(fp)
 d02e7e4:	10801217 	ldw	r2,72(r2)
 d02e7e8:	1885c83a 	sub	r2,r3,r2
 d02e7ec:	e0bffd15 	stw	r2,-12(fp)
 d02e7f0:	00000106 	br	d02e7f8 <sosend+0x240>
 d02e7f4:	e03ffd15 	stw	zero,-12(fp)
 d02e7f8:	e0bffd17 	ldw	r2,-12(fp)
 d02e7fc:	e0bff515 	stw	r2,-44(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 d02e800:	e0bff817 	ldw	r2,-32(fp)
 d02e804:	10800217 	ldw	r2,8(r2)
 d02e808:	1080010b 	ldhu	r2,4(r2)
 d02e80c:	10bfffcc 	andi	r2,r2,65535
 d02e810:	1080004c 	andi	r2,r2,1
 d02e814:	1080005c 	xori	r2,r2,1
 d02e818:	10803fcc 	andi	r2,r2,255
 d02e81c:	1004c03a 	cmpne	r2,r2,zero
 d02e820:	1000031e 	bne	r2,zero,d02e830 <sosend+0x278>
 d02e824:	e0fff517 	ldw	r3,-44(fp)
 d02e828:	e0bff417 	ldw	r2,-48(fp)
 d02e82c:	18801416 	blt	r3,r2,d02e880 <sosend+0x2c8>
 d02e830:	e0bff417 	ldw	r2,-48(fp)
 d02e834:	10815e10 	cmplti	r2,r2,1400
 d02e838:	1000301e 	bne	r2,zero,d02e8fc <sosend+0x344>
 d02e83c:	e0bff517 	ldw	r2,-44(fp)
 d02e840:	10815e08 	cmpgei	r2,r2,1400
 d02e844:	10002d1e 	bne	r2,zero,d02e8fc <sosend+0x344>
 d02e848:	e0bff817 	ldw	r2,-32(fp)
 d02e84c:	10801217 	ldw	r2,72(r2)
 d02e850:	10815e30 	cmpltui	r2,r2,1400
 d02e854:	1000291e 	bne	r2,zero,d02e8fc <sosend+0x344>
 d02e858:	e0bff817 	ldw	r2,-32(fp)
 d02e85c:	1080088b 	ldhu	r2,34(r2)
 d02e860:	10bfffcc 	andi	r2,r2,65535
 d02e864:	1080400c 	andi	r2,r2,256
 d02e868:	1004c03a 	cmpne	r2,r2,zero
 d02e86c:	1000231e 	bne	r2,zero,d02e8fc <sosend+0x344>
 d02e870:	e0800217 	ldw	r2,8(fp)
 d02e874:	1080080c 	andi	r2,r2,32
 d02e878:	1004c03a 	cmpne	r2,r2,zero
 d02e87c:	10001f1e 	bne	r2,zero,d02e8fc <sosend+0x344>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 d02e880:	e0bff817 	ldw	r2,-32(fp)
 d02e884:	1080088b 	ldhu	r2,34(r2)
 d02e888:	10bfffcc 	andi	r2,r2,65535
 d02e88c:	1080400c 	andi	r2,r2,256
 d02e890:	1004c03a 	cmpne	r2,r2,zero
 d02e894:	1000041e 	bne	r2,zero,d02e8a8 <sosend+0x2f0>
 d02e898:	e0800217 	ldw	r2,8(fp)
 d02e89c:	1080080c 	andi	r2,r2,32
 d02e8a0:	1005003a 	cmpeq	r2,r2,zero
 d02e8a4:	1000061e 	bne	r2,zero,d02e8c0 <sosend+0x308>
            {
               if (first)
 d02e8a8:	e0bff017 	ldw	r2,-64(fp)
 d02e8ac:	1005003a 	cmpeq	r2,r2,zero
 d02e8b0:	1000ab1e 	bne	r2,zero,d02eb60 <sosend+0x5a8>
                  error = EWOULDBLOCK;
 d02e8b4:	008002c4 	movi	r2,11
 d02e8b8:	e0bff215 	stw	r2,-56(fp)
               goto release;
 d02e8bc:	0000a806 	br	d02eb60 <sosend+0x5a8>
            }
            sbunlock(&so->so_snd);
 d02e8c0:	e0bff817 	ldw	r2,-32(fp)
 d02e8c4:	10c0190b 	ldhu	r3,100(r2)
 d02e8c8:	00bfff84 	movi	r2,-2
 d02e8cc:	1884703a 	and	r2,r3,r2
 d02e8d0:	1007883a 	mov	r3,r2
 d02e8d4:	e0bff817 	ldw	r2,-32(fp)
 d02e8d8:	10c0190d 	sth	r3,100(r2)
 d02e8dc:	e0bff817 	ldw	r2,-32(fp)
 d02e8e0:	10801904 	addi	r2,r2,100
 d02e8e4:	1009883a 	mov	r4,r2
 d02e8e8:	d02515c0 	call	d02515c <tcp_wakeup>
            sbwait(&so->so_snd);
 d02e8ec:	e0bff817 	ldw	r2,-32(fp)
 d02e8f0:	11001204 	addi	r4,r2,72
 d02e8f4:	d0307000 	call	d030700 <sbwait>
            goto restart;
 d02e8f8:	003f7106 	br	d02e6c0 <sosend+0x108>
         }
      }
      if ( space <= 0 ) 
 d02e8fc:	e0bff517 	ldw	r2,-44(fp)
 d02e900:	10800048 	cmpgei	r2,r2,1
 d02e904:	1000651e 	bne	r2,zero,d02ea9c <sosend+0x4e4>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 d02e908:	e0bff817 	ldw	r2,-32(fp)
 d02e90c:	1080088b 	ldhu	r2,34(r2)
 d02e910:	10bfffcc 	andi	r2,r2,65535
 d02e914:	1080400c 	andi	r2,r2,256
 d02e918:	1004c03a 	cmpne	r2,r2,zero
 d02e91c:	1000041e 	bne	r2,zero,d02e930 <sosend+0x378>
 d02e920:	e0800217 	ldw	r2,8(fp)
 d02e924:	1080080c 	andi	r2,r2,32
 d02e928:	1005003a 	cmpeq	r2,r2,zero
 d02e92c:	1000061e 	bne	r2,zero,d02e948 <sosend+0x390>
         {
            if (first)     /* report first error */
 d02e930:	e0bff017 	ldw	r2,-64(fp)
 d02e934:	1005003a 	cmpeq	r2,r2,zero
 d02e938:	1000891e 	bne	r2,zero,d02eb60 <sosend+0x5a8>
               error = EWOULDBLOCK;
 d02e93c:	008002c4 	movi	r2,11
 d02e940:	e0bff215 	stw	r2,-56(fp)
            goto release;
 d02e944:	00008606 	br	d02eb60 <sosend+0x5a8>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 d02e948:	e0bff817 	ldw	r2,-32(fp)
 d02e94c:	10c0190b 	ldhu	r3,100(r2)
 d02e950:	00bfff84 	movi	r2,-2
 d02e954:	1884703a 	and	r2,r3,r2
 d02e958:	1007883a 	mov	r3,r2
 d02e95c:	e0bff817 	ldw	r2,-32(fp)
 d02e960:	10c0190d 	sth	r3,100(r2)
 d02e964:	e0bff817 	ldw	r2,-32(fp)
 d02e968:	10801904 	addi	r2,r2,100
 d02e96c:	1009883a 	mov	r4,r2
 d02e970:	d02515c0 	call	d02515c <tcp_wakeup>
         sbwait(&so->so_snd);
 d02e974:	e0bff817 	ldw	r2,-32(fp)
 d02e978:	11001204 	addi	r4,r2,72
 d02e97c:	d0307000 	call	d030700 <sbwait>
         goto restart;
 d02e980:	003f4f06 	br	d02e6c0 <sosend+0x108>
      }

      while (space > 0) 
      {
         len = resid;
 d02e984:	e0bff417 	ldw	r2,-48(fp)
 d02e988:	e0bff315 	stw	r2,-52(fp)
         if ( so->so_type == SOCK_STREAM )
 d02e98c:	e0bff817 	ldw	r2,-32(fp)
 d02e990:	10800983 	ldbu	r2,38(r2)
 d02e994:	10803fcc 	andi	r2,r2,255
 d02e998:	1080201c 	xori	r2,r2,128
 d02e99c:	10bfe004 	addi	r2,r2,-128
 d02e9a0:	10800058 	cmpnei	r2,r2,1
 d02e9a4:	1000181e 	bne	r2,zero,d02ea08 <sosend+0x450>
         {
            m = m_getwithdata(MT_TXDATA, len);
 d02e9a8:	01000084 	movi	r4,2
 d02e9ac:	e17ff317 	ldw	r5,-52(fp)
 d02e9b0:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02e9b4:	e0bff615 	stw	r2,-40(fp)
            if (!m)   
 d02e9b8:	e0bff617 	ldw	r2,-40(fp)
 d02e9bc:	1004c03a 	cmpne	r2,r2,zero
 d02e9c0:	1000031e 	bne	r2,zero,d02e9d0 <sosend+0x418>
               snderr(ENOBUFS);
 d02e9c4:	00801a44 	movi	r2,105
 d02e9c8:	e0bff215 	stw	r2,-56(fp)
 d02e9cc:	00006406 	br	d02eb60 <sosend+0x5a8>
            MEMCPY(m->m_data, data, len);
 d02e9d0:	e0bff617 	ldw	r2,-40(fp)
 d02e9d4:	10c00317 	ldw	r3,12(r2)
 d02e9d8:	e1bff317 	ldw	r6,-52(fp)
 d02e9dc:	e0bffa17 	ldw	r2,-24(fp)
 d02e9e0:	1809883a 	mov	r4,r3
 d02e9e4:	100b883a 	mov	r5,r2
 d02e9e8:	d0027000 	call	d002700 <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 d02e9ec:	e0bff817 	ldw	r2,-32(fp)
 d02e9f0:	1080190b 	ldhu	r2,100(r2)
 d02e9f4:	10802014 	ori	r2,r2,128
 d02e9f8:	1007883a 	mov	r3,r2
 d02e9fc:	e0bff817 	ldw	r2,-32(fp)
 d02ea00:	10c0190d 	sth	r3,100(r2)
 d02ea04:	00000706 	br	d02ea24 <sosend+0x46c>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 d02ea08:	01000084 	movi	r4,2
 d02ea0c:	000b883a 	mov	r5,zero
 d02ea10:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02ea14:	e0bff615 	stw	r2,-40(fp)
            m->m_data = data;
 d02ea18:	e0fff617 	ldw	r3,-40(fp)
 d02ea1c:	e0bffa17 	ldw	r2,-24(fp)
 d02ea20:	18800315 	stw	r2,12(r3)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 d02ea24:	e0bffb17 	ldw	r2,-20(fp)
 d02ea28:	10c00017 	ldw	r3,0(r2)
 d02ea2c:	e0bff317 	ldw	r2,-52(fp)
 d02ea30:	1887c83a 	sub	r3,r3,r2
 d02ea34:	e0bffb17 	ldw	r2,-20(fp)
 d02ea38:	10c00015 	stw	r3,0(r2)
         resid -= len;
 d02ea3c:	e0fff417 	ldw	r3,-48(fp)
 d02ea40:	e0bff317 	ldw	r2,-52(fp)
 d02ea44:	1885c83a 	sub	r2,r3,r2
 d02ea48:	e0bff415 	stw	r2,-48(fp)
         data += len;
 d02ea4c:	e0bff317 	ldw	r2,-52(fp)
 d02ea50:	1007883a 	mov	r3,r2
 d02ea54:	e0bffa17 	ldw	r2,-24(fp)
 d02ea58:	10c5883a 	add	r2,r2,r3
 d02ea5c:	e0bffa15 	stw	r2,-24(fp)
         m->m_len = len;
 d02ea60:	e0fff317 	ldw	r3,-52(fp)
 d02ea64:	e0bff617 	ldw	r2,-40(fp)
 d02ea68:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 d02ea6c:	e0bff717 	ldw	r2,-36(fp)
 d02ea70:	1004c03a 	cmpne	r2,r2,zero
 d02ea74:	1000021e 	bne	r2,zero,d02ea80 <sosend+0x4c8>
            head = m;
 d02ea78:	e0bff617 	ldw	r2,-40(fp)
 d02ea7c:	e0bff715 	stw	r2,-36(fp)
         if (error)
 d02ea80:	e0bff217 	ldw	r2,-56(fp)
 d02ea84:	1004c03a 	cmpne	r2,r2,zero
 d02ea88:	1000351e 	bne	r2,zero,d02eb60 <sosend+0x5a8>
            goto release;
         if (*data_length <= 0)
 d02ea8c:	e0bffb17 	ldw	r2,-20(fp)
 d02ea90:	10800017 	ldw	r2,0(r2)
 d02ea94:	10800050 	cmplti	r2,r2,1
 d02ea98:	1000031e 	bne	r2,zero,d02eaa8 <sosend+0x4f0>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 d02ea9c:	e0bff517 	ldw	r2,-44(fp)
 d02eaa0:	10800048 	cmpgei	r2,r2,1
 d02eaa4:	103fb71e 	bne	r2,zero,d02e984 <sosend+0x3cc>
            goto release;
         if (*data_length <= 0)
            break;
      }

      if (dontroute)
 d02eaa8:	e0bff117 	ldw	r2,-60(fp)
 d02eaac:	1005003a 	cmpeq	r2,r2,zero
 d02eab0:	1000051e 	bne	r2,zero,d02eac8 <sosend+0x510>
         so->so_options |= SO_DONTROUTE;
 d02eab4:	e0bff817 	ldw	r2,-32(fp)
 d02eab8:	10800417 	ldw	r2,16(r2)
 d02eabc:	10c00414 	ori	r3,r2,16
 d02eac0:	e0bff817 	ldw	r2,-32(fp)
 d02eac4:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 d02eac8:	e0800217 	ldw	r2,8(fp)
 d02eacc:	1080004c 	andi	r2,r2,1
 d02ead0:	10803fcc 	andi	r2,r2,255
 d02ead4:	1005003a 	cmpeq	r2,r2,zero
 d02ead8:	1000031e 	bne	r2,zero,d02eae8 <sosend+0x530>
 d02eadc:	00c00384 	movi	r3,14
 d02eae0:	e0fffc15 	stw	r3,-16(fp)
 d02eae4:	00000206 	br	d02eaf0 <sosend+0x538>
 d02eae8:	00800244 	movi	r2,9
 d02eaec:	e0bffc15 	stw	r2,-16(fp)
 d02eaf0:	e0bff817 	ldw	r2,-32(fp)
 d02eaf4:	e0fffc17 	ldw	r3,-16(fp)
 d02eaf8:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 d02eafc:	e0bff817 	ldw	r2,-32(fp)
 d02eb00:	10800217 	ldw	r2,8(r2)
 d02eb04:	10800317 	ldw	r2,12(r2)
 d02eb08:	e13ff817 	ldw	r4,-32(fp)
 d02eb0c:	e17ff717 	ldw	r5,-36(fp)
 d02eb10:	e1bff917 	ldw	r6,-28(fp)
 d02eb14:	103ee83a 	callr	r2
 d02eb18:	e0bff215 	stw	r2,-56(fp)

      if (dontroute)
 d02eb1c:	e0bff117 	ldw	r2,-60(fp)
 d02eb20:	1005003a 	cmpeq	r2,r2,zero
 d02eb24:	1000061e 	bne	r2,zero,d02eb40 <sosend+0x588>
         so->so_options &= ~SO_DONTROUTE;
 d02eb28:	e0bff817 	ldw	r2,-32(fp)
 d02eb2c:	10c00417 	ldw	r3,16(r2)
 d02eb30:	00bffbc4 	movi	r2,-17
 d02eb34:	1886703a 	and	r3,r3,r2
 d02eb38:	e0bff817 	ldw	r2,-32(fp)
 d02eb3c:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 d02eb40:	e03ff715 	stw	zero,-36(fp)
      first = 0;
 d02eb44:	e03ff015 	stw	zero,-64(fp)
   } while ((resid != 0) && (error == 0));
 d02eb48:	e0bff417 	ldw	r2,-48(fp)
 d02eb4c:	1005003a 	cmpeq	r2,r2,zero
 d02eb50:	1000031e 	bne	r2,zero,d02eb60 <sosend+0x5a8>
 d02eb54:	e0bff217 	ldw	r2,-56(fp)
 d02eb58:	1005003a 	cmpeq	r2,r2,zero
 d02eb5c:	103ee51e 	bne	r2,zero,d02e6f4 <sosend+0x13c>

release:
   sbunlock(&so->so_snd);  
 d02eb60:	e0bff817 	ldw	r2,-32(fp)
 d02eb64:	10c0190b 	ldhu	r3,100(r2)
 d02eb68:	00bfff84 	movi	r2,-2
 d02eb6c:	1884703a 	and	r2,r3,r2
 d02eb70:	1007883a 	mov	r3,r2
 d02eb74:	e0bff817 	ldw	r2,-32(fp)
 d02eb78:	10c0190d 	sth	r3,100(r2)
 d02eb7c:	e0bff817 	ldw	r2,-32(fp)
 d02eb80:	10801904 	addi	r2,r2,100
 d02eb84:	1009883a 	mov	r4,r2
 d02eb88:	d02515c0 	call	d02515c <tcp_wakeup>
   if (head)
 d02eb8c:	e0bff717 	ldw	r2,-36(fp)
 d02eb90:	1005003a 	cmpeq	r2,r2,zero
 d02eb94:	1000021e 	bne	r2,zero,d02eba0 <sosend+0x5e8>
      m_freem(head);
 d02eb98:	e13ff717 	ldw	r4,-36(fp)
 d02eb9c:	d02a4c40 	call	d02a4c4 <m_freem>
   return error;
 d02eba0:	e0bff217 	ldw	r2,-56(fp)
 d02eba4:	e0bfff15 	stw	r2,-4(fp)
 d02eba8:	e0bfff17 	ldw	r2,-4(fp)
}
 d02ebac:	e037883a 	mov	sp,fp
 d02ebb0:	dfc00117 	ldw	ra,4(sp)
 d02ebb4:	df000017 	ldw	fp,0(sp)
 d02ebb8:	dec00204 	addi	sp,sp,8
 d02ebbc:	f800283a 	ret

0d02ebc0 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 d02ebc0:	defff104 	addi	sp,sp,-60
 d02ebc4:	dfc00e15 	stw	ra,56(sp)
 d02ebc8:	df000d15 	stw	fp,52(sp)
 d02ebcc:	df000d04 	addi	fp,sp,52
 d02ebd0:	e13ffb15 	stw	r4,-20(fp)
 d02ebd4:	e17ffc15 	stw	r5,-16(fp)
 d02ebd8:	e1bffd15 	stw	r6,-12(fp)
 d02ebdc:	e1fffe15 	stw	r7,-8(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 d02ebe0:	e03ff815 	stw	zero,-32(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 d02ebe4:	e0bffb17 	ldw	r2,-20(fp)
 d02ebe8:	10800217 	ldw	r2,8(r2)
 d02ebec:	e0bff615 	stw	r2,-40(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 d02ebf0:	e0bffc17 	ldw	r2,-16(fp)
 d02ebf4:	1005003a 	cmpeq	r2,r2,zero
 d02ebf8:	1000021e 	bne	r2,zero,d02ec04 <soreceive+0x44>
      *aname = 0;
 d02ebfc:	e0bffc17 	ldw	r2,-16(fp)
 d02ec00:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 d02ec04:	e0800217 	ldw	r2,8(fp)
 d02ec08:	1080004c 	andi	r2,r2,1
 d02ec0c:	10803fcc 	andi	r2,r2,255
 d02ec10:	1005003a 	cmpeq	r2,r2,zero
 d02ec14:	10004d1e 	bne	r2,zero,d02ed4c <soreceive+0x18c>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 d02ec18:	01000044 	movi	r4,1
 d02ec1c:	000b883a 	mov	r5,zero
 d02ec20:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d02ec24:	e0bffa15 	stw	r2,-24(fp)
      if (m == NULL)
 d02ec28:	e0bffa17 	ldw	r2,-24(fp)
 d02ec2c:	1004c03a 	cmpne	r2,r2,zero
 d02ec30:	1000031e 	bne	r2,zero,d02ec40 <soreceive+0x80>
         return ENOBUFS;
 d02ec34:	00801a44 	movi	r2,105
 d02ec38:	e0bfff15 	stw	r2,-4(fp)
 d02ec3c:	0001d306 	br	d02f38c <soreceive+0x7cc>
      lflags = flags & MSG_PEEK;
 d02ec40:	e0800217 	ldw	r2,8(fp)
 d02ec44:	1080008c 	andi	r2,r2,2
 d02ec48:	e0bff315 	stw	r2,-52(fp)

      so->so_req = PRU_RCVOOB;
 d02ec4c:	e0fffb17 	ldw	r3,-20(fp)
 d02ec50:	00800344 	movi	r2,13
 d02ec54:	18800715 	stw	r2,28(r3)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 d02ec58:	e0bff617 	ldw	r2,-40(fp)
 d02ec5c:	10800317 	ldw	r2,12(r2)
 d02ec60:	e1bff317 	ldw	r6,-52(fp)
 d02ec64:	e13ffb17 	ldw	r4,-20(fp)
 d02ec68:	e17ffa17 	ldw	r5,-24(fp)
 d02ec6c:	103ee83a 	callr	r2
 d02ec70:	e0bff815 	stw	r2,-32(fp)
      if (error == 0)
 d02ec74:	e0bff817 	ldw	r2,-32(fp)
 d02ec78:	1004c03a 	cmpne	r2,r2,zero
 d02ec7c:	1000271e 	bne	r2,zero,d02ed1c <soreceive+0x15c>
      {
         do 
         {
            len = *datalen;
 d02ec80:	e0bffe17 	ldw	r2,-8(fp)
 d02ec84:	10800017 	ldw	r2,0(r2)
 d02ec88:	e0bff915 	stw	r2,-28(fp)
            if (len > (int)m->m_len)
 d02ec8c:	e0bffa17 	ldw	r2,-24(fp)
 d02ec90:	10800217 	ldw	r2,8(r2)
 d02ec94:	1007883a 	mov	r3,r2
 d02ec98:	e0bff917 	ldw	r2,-28(fp)
 d02ec9c:	1880030e 	bge	r3,r2,d02ecac <soreceive+0xec>
               len = m->m_len;
 d02eca0:	e0bffa17 	ldw	r2,-24(fp)
 d02eca4:	10800217 	ldw	r2,8(r2)
 d02eca8:	e0bff915 	stw	r2,-28(fp)

            MEMCPY(data, mtod(m, char*), len);
 d02ecac:	e0bffa17 	ldw	r2,-24(fp)
 d02ecb0:	10c00317 	ldw	r3,12(r2)
 d02ecb4:	e1bff917 	ldw	r6,-28(fp)
 d02ecb8:	e0bffd17 	ldw	r2,-12(fp)
 d02ecbc:	1009883a 	mov	r4,r2
 d02ecc0:	180b883a 	mov	r5,r3
 d02ecc4:	d0027000 	call	d002700 <memcpy>
            data += len;
 d02ecc8:	e0bff917 	ldw	r2,-28(fp)
 d02eccc:	1007883a 	mov	r3,r2
 d02ecd0:	e0bffd17 	ldw	r2,-12(fp)
 d02ecd4:	10c5883a 	add	r2,r2,r3
 d02ecd8:	e0bffd15 	stw	r2,-12(fp)
            *datalen = len;
 d02ecdc:	e0fffe17 	ldw	r3,-8(fp)
 d02ece0:	e0bff917 	ldw	r2,-28(fp)
 d02ece4:	18800015 	stw	r2,0(r3)
            m = m_free(m);
 d02ece8:	e13ffa17 	ldw	r4,-24(fp)
 d02ecec:	d02a3900 	call	d02a390 <m_free>
 d02ecf0:	e0bffa15 	stw	r2,-24(fp)
         } while (*datalen && (error == 0) && m);
 d02ecf4:	e0bffe17 	ldw	r2,-8(fp)
 d02ecf8:	10800017 	ldw	r2,0(r2)
 d02ecfc:	1005003a 	cmpeq	r2,r2,zero
 d02ed00:	1000061e 	bne	r2,zero,d02ed1c <soreceive+0x15c>
 d02ed04:	e0bff817 	ldw	r2,-32(fp)
 d02ed08:	1004c03a 	cmpne	r2,r2,zero
 d02ed0c:	1000031e 	bne	r2,zero,d02ed1c <soreceive+0x15c>
 d02ed10:	e0bffa17 	ldw	r2,-24(fp)
 d02ed14:	1004c03a 	cmpne	r2,r2,zero
 d02ed18:	103fd91e 	bne	r2,zero,d02ec80 <soreceive+0xc0>
      }

      if (m)
 d02ed1c:	e0bffa17 	ldw	r2,-24(fp)
 d02ed20:	1005003a 	cmpeq	r2,r2,zero
 d02ed24:	1000021e 	bne	r2,zero,d02ed30 <soreceive+0x170>
         m_freem(m);
 d02ed28:	e13ffa17 	ldw	r4,-24(fp)
 d02ed2c:	d02a4c40 	call	d02a4c4 <m_freem>
      return (error);
 d02ed30:	e0bff817 	ldw	r2,-32(fp)
 d02ed34:	e0bfff15 	stw	r2,-4(fp)
 d02ed38:	00019406 	br	d02f38c <soreceive+0x7cc>
   }

restart:
   sblock (&so->so_rcv);
 d02ed3c:	e0bffb17 	ldw	r2,-20(fp)
 d02ed40:	10801104 	addi	r2,r2,68
 d02ed44:	1009883a 	mov	r4,r2
 d02ed48:	d024fbc0 	call	d024fbc <tcp_sleep>
 d02ed4c:	e0bffb17 	ldw	r2,-20(fp)
 d02ed50:	1080110b 	ldhu	r2,68(r2)
 d02ed54:	10bfffcc 	andi	r2,r2,65535
 d02ed58:	1080004c 	andi	r2,r2,1
 d02ed5c:	10803fcc 	andi	r2,r2,255
 d02ed60:	1004c03a 	cmpne	r2,r2,zero
 d02ed64:	103ff51e 	bne	r2,zero,d02ed3c <soreceive+0x17c>
 d02ed68:	e0bffb17 	ldw	r2,-20(fp)
 d02ed6c:	1080110b 	ldhu	r2,68(r2)
 d02ed70:	10800054 	ori	r2,r2,1
 d02ed74:	1007883a 	mov	r3,r2
 d02ed78:	e0bffb17 	ldw	r2,-20(fp)
 d02ed7c:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 d02ed80:	e0bffb17 	ldw	r2,-20(fp)
 d02ed84:	10800a17 	ldw	r2,40(r2)
 d02ed88:	1004c03a 	cmpne	r2,r2,zero
 d02ed8c:	1000401e 	bne	r2,zero,d02ee90 <soreceive+0x2d0>
   {
      if (so->so_error) 
 d02ed90:	e0bffb17 	ldw	r2,-20(fp)
 d02ed94:	10800617 	ldw	r2,24(r2)
 d02ed98:	1005003a 	cmpeq	r2,r2,zero
 d02ed9c:	1000061e 	bne	r2,zero,d02edb8 <soreceive+0x1f8>
      {
         error = so->so_error;
 d02eda0:	e0bffb17 	ldw	r2,-20(fp)
 d02eda4:	10800617 	ldw	r2,24(r2)
 d02eda8:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;
 d02edac:	e0bffb17 	ldw	r2,-20(fp)
 d02edb0:	10000615 	stw	zero,24(r2)
         goto release;
 d02edb4:	00016806 	br	d02f358 <soreceive+0x798>
      }
      if (so->so_state & SS_CANTRCVMORE)
 d02edb8:	e0bffb17 	ldw	r2,-20(fp)
 d02edbc:	1080088b 	ldhu	r2,34(r2)
 d02edc0:	10bfffcc 	andi	r2,r2,65535
 d02edc4:	1080080c 	andi	r2,r2,32
 d02edc8:	1004c03a 	cmpne	r2,r2,zero
 d02edcc:	1001621e 	bne	r2,zero,d02f358 <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 d02edd0:	e0bffb17 	ldw	r2,-20(fp)
 d02edd4:	1080088b 	ldhu	r2,34(r2)
 d02edd8:	10bfffcc 	andi	r2,r2,65535
 d02eddc:	1080008c 	andi	r2,r2,2
 d02ede0:	1004c03a 	cmpne	r2,r2,zero
 d02ede4:	10000a1e 	bne	r2,zero,d02ee10 <soreceive+0x250>
 d02ede8:	e0bffb17 	ldw	r2,-20(fp)
 d02edec:	10800217 	ldw	r2,8(r2)
 d02edf0:	1080010b 	ldhu	r2,4(r2)
 d02edf4:	10bfffcc 	andi	r2,r2,65535
 d02edf8:	1080010c 	andi	r2,r2,4
 d02edfc:	1005003a 	cmpeq	r2,r2,zero
 d02ee00:	1000031e 	bne	r2,zero,d02ee10 <soreceive+0x250>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 d02ee04:	00802004 	movi	r2,128
 d02ee08:	e0bff815 	stw	r2,-32(fp)
         goto release;
 d02ee0c:	00015206 	br	d02f358 <soreceive+0x798>
      }
      if (*datalen == 0)
 d02ee10:	e0bffe17 	ldw	r2,-8(fp)
 d02ee14:	10800017 	ldw	r2,0(r2)
 d02ee18:	1005003a 	cmpeq	r2,r2,zero
 d02ee1c:	10014e1e 	bne	r2,zero,d02f358 <soreceive+0x798>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 d02ee20:	e0bffb17 	ldw	r2,-20(fp)
 d02ee24:	1080088b 	ldhu	r2,34(r2)
 d02ee28:	10bfffcc 	andi	r2,r2,65535
 d02ee2c:	1080400c 	andi	r2,r2,256
 d02ee30:	1004c03a 	cmpne	r2,r2,zero
 d02ee34:	1000041e 	bne	r2,zero,d02ee48 <soreceive+0x288>
 d02ee38:	e0800217 	ldw	r2,8(fp)
 d02ee3c:	1080080c 	andi	r2,r2,32
 d02ee40:	1005003a 	cmpeq	r2,r2,zero
 d02ee44:	1000031e 	bne	r2,zero,d02ee54 <soreceive+0x294>
      {
         error = EWOULDBLOCK;
 d02ee48:	008002c4 	movi	r2,11
 d02ee4c:	e0bff815 	stw	r2,-32(fp)
         goto release;
 d02ee50:	00014106 	br	d02f358 <soreceive+0x798>
      }
      sbunlock(&so->so_rcv);
 d02ee54:	e0bffb17 	ldw	r2,-20(fp)
 d02ee58:	10c0110b 	ldhu	r3,68(r2)
 d02ee5c:	00bfff84 	movi	r2,-2
 d02ee60:	1884703a 	and	r2,r3,r2
 d02ee64:	1007883a 	mov	r3,r2
 d02ee68:	e0bffb17 	ldw	r2,-20(fp)
 d02ee6c:	10c0110d 	sth	r3,68(r2)
 d02ee70:	e0bffb17 	ldw	r2,-20(fp)
 d02ee74:	10801104 	addi	r2,r2,68
 d02ee78:	1009883a 	mov	r4,r2
 d02ee7c:	d02515c0 	call	d02515c <tcp_wakeup>
      sbwait(&so->so_rcv);
 d02ee80:	e0bffb17 	ldw	r2,-20(fp)
 d02ee84:	11000a04 	addi	r4,r2,40
 d02ee88:	d0307000 	call	d030700 <sbwait>
      goto restart;
 d02ee8c:	003faf06 	br	d02ed4c <soreceive+0x18c>
   }
   m = so->so_rcv.sb_mb;
 d02ee90:	e0bffb17 	ldw	r2,-20(fp)
 d02ee94:	10801017 	ldw	r2,64(r2)
 d02ee98:	e0bffa15 	stw	r2,-24(fp)
   if (m == 0)
 d02ee9c:	e0bffa17 	ldw	r2,-24(fp)
 d02eea0:	1004c03a 	cmpne	r2,r2,zero
 d02eea4:	1000031e 	bne	r2,zero,d02eeb4 <soreceive+0x2f4>
      panic("sorecv 1");
 d02eea8:	01034174 	movhi	r4,3333
 d02eeac:	213deb04 	addi	r4,r4,-2132
 d02eeb0:	d0246440 	call	d024644 <panic>
   nextrecord = m->m_act;
 d02eeb4:	e0bffa17 	ldw	r2,-24(fp)
 d02eeb8:	10800717 	ldw	r2,28(r2)
 d02eebc:	e0bff515 	stw	r2,-44(fp)
   if (pr->pr_flags & PR_ADDR) 
 d02eec0:	e0bff617 	ldw	r2,-40(fp)
 d02eec4:	1080010b 	ldhu	r2,4(r2)
 d02eec8:	10bfffcc 	andi	r2,r2,65535
 d02eecc:	1080008c 	andi	r2,r2,2
 d02eed0:	1005003a 	cmpeq	r2,r2,zero
 d02eed4:	1000451e 	bne	r2,zero,d02efec <soreceive+0x42c>
   {
      if (m->m_type != MT_SONAME) 
 d02eed8:	e0bffa17 	ldw	r2,-24(fp)
 d02eedc:	10800817 	ldw	r2,32(r2)
 d02eee0:	10800260 	cmpeqi	r2,r2,9
 d02eee4:	1000081e 	bne	r2,zero,d02ef08 <soreceive+0x348>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 d02eee8:	e0bffa17 	ldw	r2,-24(fp)
 d02eeec:	11400817 	ldw	r5,32(r2)
 d02eef0:	01034174 	movhi	r4,3333
 d02eef4:	213dee04 	addi	r4,r4,-2120
 d02eef8:	d0029980 	call	d002998 <printf>
         panic("sorecv 2");
 d02eefc:	01034174 	movhi	r4,3333
 d02ef00:	213df404 	addi	r4,r4,-2096
 d02ef04:	d0246440 	call	d024644 <panic>
      }
      if (flags & MSG_PEEK) 
 d02ef08:	e0800217 	ldw	r2,8(fp)
 d02ef0c:	1080008c 	andi	r2,r2,2
 d02ef10:	1005003a 	cmpeq	r2,r2,zero
 d02ef14:	1000101e 	bne	r2,zero,d02ef58 <soreceive+0x398>
      {
         if (aname)
 d02ef18:	e0bffc17 	ldw	r2,-16(fp)
 d02ef1c:	1005003a 	cmpeq	r2,r2,zero
 d02ef20:	1000091e 	bne	r2,zero,d02ef48 <soreceive+0x388>
            *aname = m_copy (m, 0, m->m_len);
 d02ef24:	e0bffa17 	ldw	r2,-24(fp)
 d02ef28:	10800217 	ldw	r2,8(r2)
 d02ef2c:	100d883a 	mov	r6,r2
 d02ef30:	e13ffa17 	ldw	r4,-24(fp)
 d02ef34:	000b883a 	mov	r5,zero
 d02ef38:	d02a5080 	call	d02a508 <m_copy>
 d02ef3c:	1007883a 	mov	r3,r2
 d02ef40:	e0bffc17 	ldw	r2,-16(fp)
 d02ef44:	10c00015 	stw	r3,0(r2)
         m = m->m_next;
 d02ef48:	e0bffa17 	ldw	r2,-24(fp)
 d02ef4c:	10800617 	ldw	r2,24(r2)
 d02ef50:	e0bffa15 	stw	r2,-24(fp)
 d02ef54:	00002506 	br	d02efec <soreceive+0x42c>
      } else 
      {
         sbfree (&so->so_rcv, m);
 d02ef58:	e0bffb17 	ldw	r2,-20(fp)
 d02ef5c:	10c00a17 	ldw	r3,40(r2)
 d02ef60:	e0bffa17 	ldw	r2,-24(fp)
 d02ef64:	10800217 	ldw	r2,8(r2)
 d02ef68:	1887c83a 	sub	r3,r3,r2
 d02ef6c:	e0bffb17 	ldw	r2,-20(fp)
 d02ef70:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 d02ef74:	e0bffc17 	ldw	r2,-16(fp)
 d02ef78:	1005003a 	cmpeq	r2,r2,zero
 d02ef7c:	10000d1e 	bne	r2,zero,d02efb4 <soreceive+0x3f4>
         {
            *aname = m;
 d02ef80:	e0fffc17 	ldw	r3,-16(fp)
 d02ef84:	e0bffa17 	ldw	r2,-24(fp)
 d02ef88:	18800015 	stw	r2,0(r3)
            m = m->m_next;
 d02ef8c:	e0bffa17 	ldw	r2,-24(fp)
 d02ef90:	10800617 	ldw	r2,24(r2)
 d02ef94:	e0bffa15 	stw	r2,-24(fp)
            (*aname)->m_next = 0;
 d02ef98:	e0bffc17 	ldw	r2,-16(fp)
 d02ef9c:	10800017 	ldw	r2,0(r2)
 d02efa0:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 d02efa4:	e0fffb17 	ldw	r3,-20(fp)
 d02efa8:	e0bffa17 	ldw	r2,-24(fp)
 d02efac:	18801015 	stw	r2,64(r3)
 d02efb0:	00000806 	br	d02efd4 <soreceive+0x414>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 d02efb4:	e13ffa17 	ldw	r4,-24(fp)
 d02efb8:	d02a3900 	call	d02a390 <m_free>
 d02efbc:	1007883a 	mov	r3,r2
 d02efc0:	e0bffb17 	ldw	r2,-20(fp)
 d02efc4:	10c01015 	stw	r3,64(r2)
            m = so->so_rcv.sb_mb;
 d02efc8:	e0bffb17 	ldw	r2,-20(fp)
 d02efcc:	10801017 	ldw	r2,64(r2)
 d02efd0:	e0bffa15 	stw	r2,-24(fp)
         }
         if (m)
 d02efd4:	e0bffa17 	ldw	r2,-24(fp)
 d02efd8:	1005003a 	cmpeq	r2,r2,zero
 d02efdc:	1000031e 	bne	r2,zero,d02efec <soreceive+0x42c>
            m->m_act = nextrecord;
 d02efe0:	e0fffa17 	ldw	r3,-24(fp)
 d02efe4:	e0bff517 	ldw	r2,-44(fp)
 d02efe8:	18800715 	stw	r2,28(r3)
      }
   }
   moff = 0;
 d02efec:	e03ff415 	stw	zero,-48(fp)
   offset = 0;
 d02eff0:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 d02eff4:	0000a606 	br	d02f290 <soreceive+0x6d0>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 d02eff8:	e0bffa17 	ldw	r2,-24(fp)
 d02effc:	10800817 	ldw	r2,32(r2)
 d02f000:	10800060 	cmpeqi	r2,r2,1
 d02f004:	1000071e 	bne	r2,zero,d02f024 <soreceive+0x464>
 d02f008:	e0bffa17 	ldw	r2,-24(fp)
 d02f00c:	10800817 	ldw	r2,32(r2)
 d02f010:	108000e0 	cmpeqi	r2,r2,3
 d02f014:	1000031e 	bne	r2,zero,d02f024 <soreceive+0x464>
         panic("sorecv 3");
 d02f018:	01034174 	movhi	r4,3333
 d02f01c:	213df704 	addi	r4,r4,-2084
 d02f020:	d0246440 	call	d024644 <panic>
      len = *datalen;
 d02f024:	e0bffe17 	ldw	r2,-8(fp)
 d02f028:	10800017 	ldw	r2,0(r2)
 d02f02c:	e0bff915 	stw	r2,-28(fp)
      so->so_state &= ~SS_RCVATMARK;
 d02f030:	e0bffb17 	ldw	r2,-20(fp)
 d02f034:	10c0088b 	ldhu	r3,34(r2)
 d02f038:	00bfefc4 	movi	r2,-65
 d02f03c:	1884703a 	and	r2,r3,r2
 d02f040:	1007883a 	mov	r3,r2
 d02f044:	e0bffb17 	ldw	r2,-20(fp)
 d02f048:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 d02f04c:	e0bffb17 	ldw	r2,-20(fp)
 d02f050:	10801a17 	ldw	r2,104(r2)
 d02f054:	1005003a 	cmpeq	r2,r2,zero
 d02f058:	10000c1e 	bne	r2,zero,d02f08c <soreceive+0x4cc>
 d02f05c:	e0bffb17 	ldw	r2,-20(fp)
 d02f060:	10c01a17 	ldw	r3,104(r2)
 d02f064:	e0bff717 	ldw	r2,-36(fp)
 d02f068:	1885c83a 	sub	r2,r3,r2
 d02f06c:	1007883a 	mov	r3,r2
 d02f070:	e0bff917 	ldw	r2,-28(fp)
 d02f074:	1880050e 	bge	r3,r2,d02f08c <soreceive+0x4cc>
         len = (int)(so->so_oobmark - offset);
 d02f078:	e0bffb17 	ldw	r2,-20(fp)
 d02f07c:	10c01a17 	ldw	r3,104(r2)
 d02f080:	e0bff717 	ldw	r2,-36(fp)
 d02f084:	1885c83a 	sub	r2,r3,r2
 d02f088:	e0bff915 	stw	r2,-28(fp)
      if (len > (int)(m->m_len - moff))
 d02f08c:	e0bffa17 	ldw	r2,-24(fp)
 d02f090:	10c00217 	ldw	r3,8(r2)
 d02f094:	e0bff417 	ldw	r2,-48(fp)
 d02f098:	1885c83a 	sub	r2,r3,r2
 d02f09c:	1007883a 	mov	r3,r2
 d02f0a0:	e0bff917 	ldw	r2,-28(fp)
 d02f0a4:	1880050e 	bge	r3,r2,d02f0bc <soreceive+0x4fc>
         len = m->m_len - moff;
 d02f0a8:	e0bffa17 	ldw	r2,-24(fp)
 d02f0ac:	10c00217 	ldw	r3,8(r2)
 d02f0b0:	e0bff417 	ldw	r2,-48(fp)
 d02f0b4:	1885c83a 	sub	r2,r3,r2
 d02f0b8:	e0bff915 	stw	r2,-28(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 d02f0bc:	e0bffa17 	ldw	r2,-24(fp)
 d02f0c0:	10c00317 	ldw	r3,12(r2)
 d02f0c4:	e0bff417 	ldw	r2,-48(fp)
 d02f0c8:	1887883a 	add	r3,r3,r2
 d02f0cc:	e1bff917 	ldw	r6,-28(fp)
 d02f0d0:	e0bffd17 	ldw	r2,-12(fp)
 d02f0d4:	1009883a 	mov	r4,r2
 d02f0d8:	180b883a 	mov	r5,r3
 d02f0dc:	d0027000 	call	d002700 <memcpy>
      data += len;
 d02f0e0:	e0bff917 	ldw	r2,-28(fp)
 d02f0e4:	1007883a 	mov	r3,r2
 d02f0e8:	e0bffd17 	ldw	r2,-12(fp)
 d02f0ec:	10c5883a 	add	r2,r2,r3
 d02f0f0:	e0bffd15 	stw	r2,-12(fp)
      *datalen -= len;
 d02f0f4:	e0bffe17 	ldw	r2,-8(fp)
 d02f0f8:	10c00017 	ldw	r3,0(r2)
 d02f0fc:	e0bff917 	ldw	r2,-28(fp)
 d02f100:	1887c83a 	sub	r3,r3,r2
 d02f104:	e0bffe17 	ldw	r2,-8(fp)
 d02f108:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 d02f10c:	e0bffa17 	ldw	r2,-24(fp)
 d02f110:	10c00217 	ldw	r3,8(r2)
 d02f114:	e0bff417 	ldw	r2,-48(fp)
 d02f118:	1885c83a 	sub	r2,r3,r2
 d02f11c:	1007883a 	mov	r3,r2
 d02f120:	e0bff917 	ldw	r2,-28(fp)
 d02f124:	1880221e 	bne	r3,r2,d02f1b0 <soreceive+0x5f0>
      {
         if (flags & MSG_PEEK) 
 d02f128:	e0800217 	ldw	r2,8(fp)
 d02f12c:	1080008c 	andi	r2,r2,2
 d02f130:	1005003a 	cmpeq	r2,r2,zero
 d02f134:	1000051e 	bne	r2,zero,d02f14c <soreceive+0x58c>
         {
            m = m->m_next;
 d02f138:	e0bffa17 	ldw	r2,-24(fp)
 d02f13c:	10800617 	ldw	r2,24(r2)
 d02f140:	e0bffa15 	stw	r2,-24(fp)
            moff = 0;
 d02f144:	e03ff415 	stw	zero,-48(fp)
 d02f148:	00003406 	br	d02f21c <soreceive+0x65c>
         } else 
         {
            nextrecord = m->m_act;
 d02f14c:	e0bffa17 	ldw	r2,-24(fp)
 d02f150:	10800717 	ldw	r2,28(r2)
 d02f154:	e0bff515 	stw	r2,-44(fp)
            sbfree(&so->so_rcv, m);
 d02f158:	e0bffb17 	ldw	r2,-20(fp)
 d02f15c:	10c00a17 	ldw	r3,40(r2)
 d02f160:	e0bffa17 	ldw	r2,-24(fp)
 d02f164:	10800217 	ldw	r2,8(r2)
 d02f168:	1887c83a 	sub	r3,r3,r2
 d02f16c:	e0bffb17 	ldw	r2,-20(fp)
 d02f170:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 d02f174:	e13ffa17 	ldw	r4,-24(fp)
 d02f178:	d02a3900 	call	d02a390 <m_free>
 d02f17c:	1007883a 	mov	r3,r2
 d02f180:	e0bffb17 	ldw	r2,-20(fp)
 d02f184:	10c01015 	stw	r3,64(r2)
               m = so->so_rcv.sb_mb;
 d02f188:	e0bffb17 	ldw	r2,-20(fp)
 d02f18c:	10801017 	ldw	r2,64(r2)
 d02f190:	e0bffa15 	stw	r2,-24(fp)
            }
            if (m)
 d02f194:	e0bffa17 	ldw	r2,-24(fp)
 d02f198:	1005003a 	cmpeq	r2,r2,zero
 d02f19c:	10001f1e 	bne	r2,zero,d02f21c <soreceive+0x65c>
               m->m_act = nextrecord;
 d02f1a0:	e0fffa17 	ldw	r3,-24(fp)
 d02f1a4:	e0bff517 	ldw	r2,-44(fp)
 d02f1a8:	18800715 	stw	r2,28(r3)
 d02f1ac:	00001b06 	br	d02f21c <soreceive+0x65c>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 d02f1b0:	e0800217 	ldw	r2,8(fp)
 d02f1b4:	1080008c 	andi	r2,r2,2
 d02f1b8:	1005003a 	cmpeq	r2,r2,zero
 d02f1bc:	1000051e 	bne	r2,zero,d02f1d4 <soreceive+0x614>
            moff += len;
 d02f1c0:	e0bff417 	ldw	r2,-48(fp)
 d02f1c4:	e0fff917 	ldw	r3,-28(fp)
 d02f1c8:	10c5883a 	add	r2,r2,r3
 d02f1cc:	e0bff415 	stw	r2,-48(fp)
 d02f1d0:	00001206 	br	d02f21c <soreceive+0x65c>
         else 
         {
            m->m_data += len;
 d02f1d4:	e0bffa17 	ldw	r2,-24(fp)
 d02f1d8:	10c00317 	ldw	r3,12(r2)
 d02f1dc:	e0bff917 	ldw	r2,-28(fp)
 d02f1e0:	1887883a 	add	r3,r3,r2
 d02f1e4:	e0bffa17 	ldw	r2,-24(fp)
 d02f1e8:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 d02f1ec:	e0bffa17 	ldw	r2,-24(fp)
 d02f1f0:	10c00217 	ldw	r3,8(r2)
 d02f1f4:	e0bff917 	ldw	r2,-28(fp)
 d02f1f8:	1887c83a 	sub	r3,r3,r2
 d02f1fc:	e0bffa17 	ldw	r2,-24(fp)
 d02f200:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 d02f204:	e0bffb17 	ldw	r2,-20(fp)
 d02f208:	10c00a17 	ldw	r3,40(r2)
 d02f20c:	e0bff917 	ldw	r2,-28(fp)
 d02f210:	1887c83a 	sub	r3,r3,r2
 d02f214:	e0bffb17 	ldw	r2,-20(fp)
 d02f218:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 d02f21c:	e0bffb17 	ldw	r2,-20(fp)
 d02f220:	10801a17 	ldw	r2,104(r2)
 d02f224:	1005003a 	cmpeq	r2,r2,zero
 d02f228:	1000191e 	bne	r2,zero,d02f290 <soreceive+0x6d0>
      {
         if ((flags & MSG_PEEK) == 0) 
 d02f22c:	e0800217 	ldw	r2,8(fp)
 d02f230:	1080008c 	andi	r2,r2,2
 d02f234:	1004c03a 	cmpne	r2,r2,zero
 d02f238:	1000111e 	bne	r2,zero,d02f280 <soreceive+0x6c0>
         {
            so->so_oobmark -= len;
 d02f23c:	e0bffb17 	ldw	r2,-20(fp)
 d02f240:	10c01a17 	ldw	r3,104(r2)
 d02f244:	e0bff917 	ldw	r2,-28(fp)
 d02f248:	1887c83a 	sub	r3,r3,r2
 d02f24c:	e0bffb17 	ldw	r2,-20(fp)
 d02f250:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 d02f254:	e0bffb17 	ldw	r2,-20(fp)
 d02f258:	10801a17 	ldw	r2,104(r2)
 d02f25c:	1004c03a 	cmpne	r2,r2,zero
 d02f260:	10000b1e 	bne	r2,zero,d02f290 <soreceive+0x6d0>
            {
               so->so_state |= SS_RCVATMARK;
 d02f264:	e0bffb17 	ldw	r2,-20(fp)
 d02f268:	1080088b 	ldhu	r2,34(r2)
 d02f26c:	10801014 	ori	r2,r2,64
 d02f270:	1007883a 	mov	r3,r2
 d02f274:	e0bffb17 	ldw	r2,-20(fp)
 d02f278:	10c0088d 	sth	r3,34(r2)
               break;
 d02f27c:	00000e06 	br	d02f2b8 <soreceive+0x6f8>
            }
         } else
            offset += len;
 d02f280:	e0bff717 	ldw	r2,-36(fp)
 d02f284:	e0fff917 	ldw	r3,-28(fp)
 d02f288:	10c5883a 	add	r2,r2,r3
 d02f28c:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 d02f290:	e0bffa17 	ldw	r2,-24(fp)
 d02f294:	1005003a 	cmpeq	r2,r2,zero
 d02f298:	1000071e 	bne	r2,zero,d02f2b8 <soreceive+0x6f8>
 d02f29c:	e0bffe17 	ldw	r2,-8(fp)
 d02f2a0:	10800017 	ldw	r2,0(r2)
 d02f2a4:	10800050 	cmplti	r2,r2,1
 d02f2a8:	1000031e 	bne	r2,zero,d02f2b8 <soreceive+0x6f8>
 d02f2ac:	e0bff817 	ldw	r2,-32(fp)
 d02f2b0:	1005003a 	cmpeq	r2,r2,zero
 d02f2b4:	103f501e 	bne	r2,zero,d02eff8 <soreceive+0x438>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 d02f2b8:	e0800217 	ldw	r2,8(fp)
 d02f2bc:	1080008c 	andi	r2,r2,2
 d02f2c0:	1004c03a 	cmpne	r2,r2,zero
 d02f2c4:	1000241e 	bne	r2,zero,d02f358 <soreceive+0x798>
   {
      if (m == 0)
 d02f2c8:	e0bffa17 	ldw	r2,-24(fp)
 d02f2cc:	1004c03a 	cmpne	r2,r2,zero
 d02f2d0:	1000041e 	bne	r2,zero,d02f2e4 <soreceive+0x724>
         so->so_rcv.sb_mb = nextrecord;
 d02f2d4:	e0fffb17 	ldw	r3,-20(fp)
 d02f2d8:	e0bff517 	ldw	r2,-44(fp)
 d02f2dc:	18801015 	stw	r2,64(r3)
 d02f2e0:	00000a06 	br	d02f30c <soreceive+0x74c>
      else if (pr->pr_flags & PR_ATOMIC)
 d02f2e4:	e0bff617 	ldw	r2,-40(fp)
 d02f2e8:	1080010b 	ldhu	r2,4(r2)
 d02f2ec:	10bfffcc 	andi	r2,r2,65535
 d02f2f0:	1080004c 	andi	r2,r2,1
 d02f2f4:	10803fcc 	andi	r2,r2,255
 d02f2f8:	1005003a 	cmpeq	r2,r2,zero
 d02f2fc:	1000031e 	bne	r2,zero,d02f30c <soreceive+0x74c>
         (void) sbdroprecord(&so->so_rcv);
 d02f300:	e0bffb17 	ldw	r2,-20(fp)
 d02f304:	11000a04 	addi	r4,r2,40
 d02f308:	d0312140 	call	d031214 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 d02f30c:	e0bff617 	ldw	r2,-40(fp)
 d02f310:	1080010b 	ldhu	r2,4(r2)
 d02f314:	10bfffcc 	andi	r2,r2,65535
 d02f318:	1080020c 	andi	r2,r2,8
 d02f31c:	1005003a 	cmpeq	r2,r2,zero
 d02f320:	10000d1e 	bne	r2,zero,d02f358 <soreceive+0x798>
 d02f324:	e0bffb17 	ldw	r2,-20(fp)
 d02f328:	10800117 	ldw	r2,4(r2)
 d02f32c:	1005003a 	cmpeq	r2,r2,zero
 d02f330:	1000091e 	bne	r2,zero,d02f358 <soreceive+0x798>
      {
         so->so_req = PRU_RCVD;
 d02f334:	e0fffb17 	ldw	r3,-20(fp)
 d02f338:	00800204 	movi	r2,8
 d02f33c:	18800715 	stw	r2,28(r3)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 d02f340:	e0bff617 	ldw	r2,-40(fp)
 d02f344:	10800317 	ldw	r2,12(r2)
 d02f348:	e13ffb17 	ldw	r4,-20(fp)
 d02f34c:	000b883a 	mov	r5,zero
 d02f350:	000d883a 	mov	r6,zero
 d02f354:	103ee83a 	callr	r2
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 d02f358:	e0bffb17 	ldw	r2,-20(fp)
 d02f35c:	10c0110b 	ldhu	r3,68(r2)
 d02f360:	00bfff84 	movi	r2,-2
 d02f364:	1884703a 	and	r2,r3,r2
 d02f368:	1007883a 	mov	r3,r2
 d02f36c:	e0bffb17 	ldw	r2,-20(fp)
 d02f370:	10c0110d 	sth	r3,68(r2)
 d02f374:	e0bffb17 	ldw	r2,-20(fp)
 d02f378:	10801104 	addi	r2,r2,68
 d02f37c:	1009883a 	mov	r4,r2
 d02f380:	d02515c0 	call	d02515c <tcp_wakeup>
   return (error);
 d02f384:	e0bff817 	ldw	r2,-32(fp)
 d02f388:	e0bfff15 	stw	r2,-4(fp)
 d02f38c:	e0bfff17 	ldw	r2,-4(fp)
}
 d02f390:	e037883a 	mov	sp,fp
 d02f394:	dfc00117 	ldw	ra,4(sp)
 d02f398:	df000017 	ldw	fp,0(sp)
 d02f39c:	dec00204 	addi	sp,sp,8
 d02f3a0:	f800283a 	ret

0d02f3a4 <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 d02f3a4:	defffb04 	addi	sp,sp,-20
 d02f3a8:	dfc00415 	stw	ra,16(sp)
 d02f3ac:	df000315 	stw	fp,12(sp)
 d02f3b0:	df000304 	addi	fp,sp,12
 d02f3b4:	e13ffd15 	stw	r4,-12(fp)
 d02f3b8:	e17ffe15 	stw	r5,-8(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 d02f3bc:	e0bffe17 	ldw	r2,-8(fp)
 d02f3c0:	10800044 	addi	r2,r2,1
 d02f3c4:	e0bffe15 	stw	r2,-8(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 d02f3c8:	e0bffe17 	ldw	r2,-8(fp)
 d02f3cc:	1080004c 	andi	r2,r2,1
 d02f3d0:	10803fcc 	andi	r2,r2,255
 d02f3d4:	1005003a 	cmpeq	r2,r2,zero
 d02f3d8:	1000021e 	bne	r2,zero,d02f3e4 <soshutdown+0x40>
      sorflush(so);
 d02f3dc:	e13ffd17 	ldw	r4,-12(fp)
 d02f3e0:	d02f44c0 	call	d02f44c <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 d02f3e4:	e0bffe17 	ldw	r2,-8(fp)
 d02f3e8:	1080008c 	andi	r2,r2,2
 d02f3ec:	1005003a 	cmpeq	r2,r2,zero
 d02f3f0:	10000f1e 	bne	r2,zero,d02f430 <soshutdown+0x8c>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 d02f3f4:	e0bffd17 	ldw	r2,-12(fp)
 d02f3f8:	11001204 	addi	r4,r2,72
 d02f3fc:	d030ea40 	call	d030ea4 <sbflush>
      so->so_req = PRU_SHUTDOWN;
 d02f400:	e0fffd17 	ldw	r3,-12(fp)
 d02f404:	008001c4 	movi	r2,7
 d02f408:	18800715 	stw	r2,28(r3)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 d02f40c:	e0bffd17 	ldw	r2,-12(fp)
 d02f410:	10800217 	ldw	r2,8(r2)
 d02f414:	10800317 	ldw	r2,12(r2)
 d02f418:	e13ffd17 	ldw	r4,-12(fp)
 d02f41c:	000b883a 	mov	r5,zero
 d02f420:	000d883a 	mov	r6,zero
 d02f424:	103ee83a 	callr	r2
 d02f428:	e0bfff15 	stw	r2,-4(fp)
 d02f42c:	00000106 	br	d02f434 <soshutdown+0x90>
   }

   return 0;
 d02f430:	e03fff15 	stw	zero,-4(fp)
 d02f434:	e0bfff17 	ldw	r2,-4(fp)
}
 d02f438:	e037883a 	mov	sp,fp
 d02f43c:	dfc00117 	ldw	ra,4(sp)
 d02f440:	df000017 	ldw	fp,0(sp)
 d02f444:	dec00204 	addi	sp,sp,8
 d02f448:	f800283a 	ret

0d02f44c <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 d02f44c:	defffb04 	addi	sp,sp,-20
 d02f450:	dfc00415 	stw	ra,16(sp)
 d02f454:	df000315 	stw	fp,12(sp)
 d02f458:	df000304 	addi	fp,sp,12
 d02f45c:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 d02f460:	e0bfff17 	ldw	r2,-4(fp)
 d02f464:	10800a04 	addi	r2,r2,40
 d02f468:	e0bffe15 	stw	r2,-8(fp)
   int   s;

   sblock(sb);
 d02f46c:	00000406 	br	d02f480 <sorflush+0x34>
 d02f470:	e0bffe17 	ldw	r2,-8(fp)
 d02f474:	10800704 	addi	r2,r2,28
 d02f478:	1009883a 	mov	r4,r2
 d02f47c:	d024fbc0 	call	d024fbc <tcp_sleep>
 d02f480:	e0bffe17 	ldw	r2,-8(fp)
 d02f484:	1080070b 	ldhu	r2,28(r2)
 d02f488:	10bfffcc 	andi	r2,r2,65535
 d02f48c:	1080004c 	andi	r2,r2,1
 d02f490:	10803fcc 	andi	r2,r2,255
 d02f494:	1004c03a 	cmpne	r2,r2,zero
 d02f498:	103ff51e 	bne	r2,zero,d02f470 <sorflush+0x24>
 d02f49c:	e0bffe17 	ldw	r2,-8(fp)
 d02f4a0:	1080070b 	ldhu	r2,28(r2)
 d02f4a4:	10800054 	ori	r2,r2,1
 d02f4a8:	1007883a 	mov	r3,r2
 d02f4ac:	e0bffe17 	ldw	r2,-8(fp)
 d02f4b0:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 d02f4b4:	e13fff17 	ldw	r4,-4(fp)
 d02f4b8:	d0306780 	call	d030678 <socantrcvmore>
   sbunlock(sb);
 d02f4bc:	e0bffe17 	ldw	r2,-8(fp)
 d02f4c0:	10c0070b 	ldhu	r3,28(r2)
 d02f4c4:	00bfff84 	movi	r2,-2
 d02f4c8:	1884703a 	and	r2,r3,r2
 d02f4cc:	1007883a 	mov	r3,r2
 d02f4d0:	e0bffe17 	ldw	r2,-8(fp)
 d02f4d4:	10c0070d 	sth	r3,28(r2)
 d02f4d8:	e0bffe17 	ldw	r2,-8(fp)
 d02f4dc:	10800704 	addi	r2,r2,28
 d02f4e0:	1009883a 	mov	r4,r2
 d02f4e4:	d02515c0 	call	d02515c <tcp_wakeup>
   sbrelease(sb);
 d02f4e8:	e13ffe17 	ldw	r4,-8(fp)
 d02f4ec:	d0308e40 	call	d0308e4 <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 d02f4f0:	e0bffe17 	ldw	r2,-8(fp)
 d02f4f4:	1009883a 	mov	r4,r2
 d02f4f8:	01800804 	movi	r6,32
 d02f4fc:	000b883a 	mov	r5,zero
 d02f500:	d0028800 	call	d002880 <memset>
   s = so->so_error;
 d02f504:	e0bfff17 	ldw	r2,-4(fp)
 d02f508:	10800617 	ldw	r2,24(r2)
 d02f50c:	e0bffd15 	stw	r2,-12(fp)
   so->so_error = ESHUTDOWN;
 d02f510:	e0ffff17 	ldw	r3,-4(fp)
 d02f514:	00801b84 	movi	r2,110
 d02f518:	18800615 	stw	r2,24(r3)
   sorwakeup(so);
 d02f51c:	e0bfff17 	ldw	r2,-4(fp)
 d02f520:	11400a04 	addi	r5,r2,40
 d02f524:	e13fff17 	ldw	r4,-4(fp)
 d02f528:	d0307680 	call	d030768 <sbwakeup>
   so->so_error = s;
 d02f52c:	e0ffff17 	ldw	r3,-4(fp)
 d02f530:	e0bffd17 	ldw	r2,-12(fp)
 d02f534:	18800615 	stw	r2,24(r3)
}
 d02f538:	e037883a 	mov	sp,fp
 d02f53c:	dfc00117 	ldw	ra,4(sp)
 d02f540:	df000017 	ldw	fp,0(sp)
 d02f544:	dec00204 	addi	sp,sp,8
 d02f548:	f800283a 	ret

0d02f54c <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 d02f54c:	defff404 	addi	sp,sp,-48
 d02f550:	dfc00b15 	stw	ra,44(sp)
 d02f554:	df000a15 	stw	fp,40(sp)
 d02f558:	df000a04 	addi	fp,sp,40
 d02f55c:	e13ffb15 	stw	r4,-20(fp)
 d02f560:	e17ffc15 	stw	r5,-16(fp)
 d02f564:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 d02f568:	e03ffa15 	stw	zero,-24(fp)

   switch (optname) 
 d02f56c:	e0bffc17 	ldw	r2,-16(fp)
 d02f570:	e0bfff15 	stw	r2,-4(fp)
 d02f574:	e0ffff17 	ldw	r3,-4(fp)
 d02f578:	18808020 	cmpeqi	r2,r3,512
 d02f57c:	1000521e 	bne	r2,zero,d02f6c8 <sosetopt+0x17c>
 d02f580:	e0ffff17 	ldw	r3,-4(fp)
 d02f584:	18808048 	cmpgei	r2,r3,513
 d02f588:	1000211e 	bne	r2,zero,d02f610 <sosetopt+0xc4>
 d02f58c:	e0ffff17 	ldw	r3,-4(fp)
 d02f590:	18800388 	cmpgei	r2,r3,14
 d02f594:	10000d1e 	bne	r2,zero,d02f5cc <sosetopt+0x80>
 d02f598:	e0ffff17 	ldw	r3,-4(fp)
 d02f59c:	18800248 	cmpgei	r2,r3,9
 d02f5a0:	10009d1e 	bne	r2,zero,d02f818 <sosetopt+0x2cc>
 d02f5a4:	e0ffff17 	ldw	r3,-4(fp)
 d02f5a8:	18800120 	cmpeqi	r2,r3,4
 d02f5ac:	1000461e 	bne	r2,zero,d02f6c8 <sosetopt+0x17c>
 d02f5b0:	e0ffff17 	ldw	r3,-4(fp)
 d02f5b4:	18800220 	cmpeqi	r2,r3,8
 d02f5b8:	1000431e 	bne	r2,zero,d02f6c8 <sosetopt+0x17c>
 d02f5bc:	e0ffff17 	ldw	r3,-4(fp)
 d02f5c0:	188000a0 	cmpeqi	r2,r3,2
 d02f5c4:	10009a1e 	bne	r2,zero,d02f830 <sosetopt+0x2e4>
 d02f5c8:	00010806 	br	d02f9ec <sosetopt+0x4a0>
 d02f5cc:	e0ffff17 	ldw	r3,-4(fp)
 d02f5d0:	18800820 	cmpeqi	r2,r3,32
 d02f5d4:	10003c1e 	bne	r2,zero,d02f6c8 <sosetopt+0x17c>
 d02f5d8:	e0ffff17 	ldw	r3,-4(fp)
 d02f5dc:	18800848 	cmpgei	r2,r3,33
 d02f5e0:	1000041e 	bne	r2,zero,d02f5f4 <sosetopt+0xa8>
 d02f5e4:	e0ffff17 	ldw	r3,-4(fp)
 d02f5e8:	18800420 	cmpeqi	r2,r3,16
 d02f5ec:	1000361e 	bne	r2,zero,d02f6c8 <sosetopt+0x17c>
 d02f5f0:	0000fe06 	br	d02f9ec <sosetopt+0x4a0>
 d02f5f4:	e0ffff17 	ldw	r3,-4(fp)
 d02f5f8:	18802020 	cmpeqi	r2,r3,128
 d02f5fc:	10002d1e 	bne	r2,zero,d02f6b4 <sosetopt+0x168>
 d02f600:	e0ffff17 	ldw	r3,-4(fp)
 d02f604:	18804020 	cmpeqi	r2,r3,256
 d02f608:	10002f1e 	bne	r2,zero,d02f6c8 <sosetopt+0x17c>
 d02f60c:	0000f706 	br	d02f9ec <sosetopt+0x4a0>
 d02f610:	e0ffff17 	ldw	r3,-4(fp)
 d02f614:	18840520 	cmpeqi	r2,r3,4116
 d02f618:	1000571e 	bne	r2,zero,d02f778 <sosetopt+0x22c>
 d02f61c:	e0ffff17 	ldw	r3,-4(fp)
 d02f620:	18840548 	cmpgei	r2,r3,4117
 d02f624:	10000f1e 	bne	r2,zero,d02f664 <sosetopt+0x118>
 d02f628:	e0ffff17 	ldw	r3,-4(fp)
 d02f62c:	188401a0 	cmpeqi	r2,r3,4102
 d02f630:	10004c1e 	bne	r2,zero,d02f764 <sosetopt+0x218>
 d02f634:	e0ffff17 	ldw	r3,-4(fp)
 d02f638:	188401c8 	cmpgei	r2,r3,4103
 d02f63c:	1000051e 	bne	r2,zero,d02f654 <sosetopt+0x108>
 d02f640:	e0ffff17 	ldw	r3,-4(fp)
 d02f644:	18bbffc4 	addi	r2,r3,-4097
 d02f648:	108000a8 	cmpgeui	r2,r2,2
 d02f64c:	1000e71e 	bne	r2,zero,d02f9ec <sosetopt+0x4a0>
 d02f650:	00003006 	br	d02f714 <sosetopt+0x1c8>
 d02f654:	e0ffff17 	ldw	r3,-4(fp)
 d02f658:	18840420 	cmpeqi	r2,r3,4112
 d02f65c:	1000ba1e 	bne	r2,zero,d02f948 <sosetopt+0x3fc>
 d02f660:	0000e206 	br	d02f9ec <sosetopt+0x4a0>
 d02f664:	e0ffff17 	ldw	r3,-4(fp)
 d02f668:	188800e0 	cmpeqi	r2,r3,8195
 d02f66c:	1000b61e 	bne	r2,zero,d02f948 <sosetopt+0x3fc>
 d02f670:	e0ffff17 	ldw	r3,-4(fp)
 d02f674:	18880108 	cmpgei	r2,r3,8196
 d02f678:	1000071e 	bne	r2,zero,d02f698 <sosetopt+0x14c>
 d02f67c:	e0ffff17 	ldw	r3,-4(fp)
 d02f680:	18840560 	cmpeqi	r2,r3,4117
 d02f684:	1000431e 	bne	r2,zero,d02f794 <sosetopt+0x248>
 d02f688:	e0ffff17 	ldw	r3,-4(fp)
 d02f68c:	188405a0 	cmpeqi	r2,r3,4118
 d02f690:	1000481e 	bne	r2,zero,d02f7b4 <sosetopt+0x268>
 d02f694:	0000d506 	br	d02f9ec <sosetopt+0x4a0>
 d02f698:	e0ffff17 	ldw	r3,-4(fp)
 d02f69c:	18880120 	cmpeqi	r2,r3,8196
 d02f6a0:	10007a1e 	bne	r2,zero,d02f88c <sosetopt+0x340>
 d02f6a4:	e0ffff17 	ldw	r3,-4(fp)
 d02f6a8:	18900020 	cmpeqi	r2,r3,16384
 d02f6ac:	1000061e 	bne	r2,zero,d02f6c8 <sosetopt+0x17c>
 d02f6b0:	0000ce06 	br	d02f9ec <sosetopt+0x4a0>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 d02f6b4:	e0bffd17 	ldw	r2,-12(fp)
 d02f6b8:	10800117 	ldw	r2,4(r2)
 d02f6bc:	1007883a 	mov	r3,r2
 d02f6c0:	e0bffb17 	ldw	r2,-20(fp)
 d02f6c4:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 d02f6c8:	e0bffd17 	ldw	r2,-12(fp)
 d02f6cc:	10800017 	ldw	r2,0(r2)
 d02f6d0:	1005003a 	cmpeq	r2,r2,zero
 d02f6d4:	1000071e 	bne	r2,zero,d02f6f4 <sosetopt+0x1a8>
         so->so_options |= optname;
 d02f6d8:	e0bffb17 	ldw	r2,-20(fp)
 d02f6dc:	10c00417 	ldw	r3,16(r2)
 d02f6e0:	e0bffc17 	ldw	r2,-16(fp)
 d02f6e4:	1886b03a 	or	r3,r3,r2
 d02f6e8:	e0bffb17 	ldw	r2,-20(fp)
 d02f6ec:	10c00415 	stw	r3,16(r2)
 d02f6f0:	0000c006 	br	d02f9f4 <sosetopt+0x4a8>
      else
         so->so_options &= ~optname;
 d02f6f4:	e0bffb17 	ldw	r2,-20(fp)
 d02f6f8:	10c00417 	ldw	r3,16(r2)
 d02f6fc:	e0bffc17 	ldw	r2,-16(fp)
 d02f700:	0084303a 	nor	r2,zero,r2
 d02f704:	1886703a 	and	r3,r3,r2
 d02f708:	e0bffb17 	ldw	r2,-20(fp)
 d02f70c:	10c00415 	stw	r3,16(r2)
      break;
 d02f710:	0000b806 	br	d02f9f4 <sosetopt+0x4a8>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 d02f714:	e0bffc17 	ldw	r2,-16(fp)
 d02f718:	10840058 	cmpnei	r2,r2,4097
 d02f71c:	1000041e 	bne	r2,zero,d02f730 <sosetopt+0x1e4>
 d02f720:	e0bffb17 	ldw	r2,-20(fp)
 d02f724:	10801204 	addi	r2,r2,72
 d02f728:	e0bffe15 	stw	r2,-8(fp)
 d02f72c:	00000306 	br	d02f73c <sosetopt+0x1f0>
 d02f730:	e0bffb17 	ldw	r2,-20(fp)
 d02f734:	10800a04 	addi	r2,r2,40
 d02f738:	e0bffe15 	stw	r2,-8(fp)
 d02f73c:	e0bffd17 	ldw	r2,-12(fp)
 d02f740:	10800017 	ldw	r2,0(r2)
 d02f744:	100b883a 	mov	r5,r2
 d02f748:	e13ffe17 	ldw	r4,-8(fp)
 d02f74c:	d0308840 	call	d030884 <sbreserve>
 d02f750:	1004c03a 	cmpne	r2,r2,zero
 d02f754:	1000a71e 	bne	r2,zero,d02f9f4 <sosetopt+0x4a8>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 d02f758:	00801a44 	movi	r2,105
 d02f75c:	e0bffa15 	stw	r2,-24(fp)
         goto bad;
 d02f760:	0000a406 	br	d02f9f4 <sosetopt+0x4a8>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 d02f764:	e0bffd17 	ldw	r2,-12(fp)
 d02f768:	10c0000b 	ldhu	r3,0(r2)
 d02f76c:	e0bffb17 	ldw	r2,-20(fp)
 d02f770:	10c0118d 	sth	r3,70(r2)
      break;
 d02f774:	00009f06 	br	d02f9f4 <sosetopt+0x4a8>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 d02f778:	e0bffb17 	ldw	r2,-20(fp)
 d02f77c:	1080088b 	ldhu	r2,34(r2)
 d02f780:	10804014 	ori	r2,r2,256
 d02f784:	1007883a 	mov	r3,r2
 d02f788:	e0bffb17 	ldw	r2,-20(fp)
 d02f78c:	10c0088d 	sth	r3,34(r2)
      break;
 d02f790:	00009806 	br	d02f9f4 <sosetopt+0x4a8>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 d02f794:	e0bffb17 	ldw	r2,-20(fp)
 d02f798:	10c0088b 	ldhu	r3,34(r2)
 d02f79c:	00bfbfc4 	movi	r2,-257
 d02f7a0:	1884703a 	and	r2,r3,r2
 d02f7a4:	1007883a 	mov	r3,r2
 d02f7a8:	e0bffb17 	ldw	r2,-20(fp)
 d02f7ac:	10c0088d 	sth	r3,34(r2)
      break;
 d02f7b0:	00009006 	br	d02f9f4 <sosetopt+0x4a8>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 d02f7b4:	e0bffd17 	ldw	r2,-12(fp)
 d02f7b8:	1004c03a 	cmpne	r2,r2,zero
 d02f7bc:	1000031e 	bne	r2,zero,d02f7cc <sosetopt+0x280>
      {
         error = ENP_PARAM;
 d02f7c0:	00bffd84 	movi	r2,-10
 d02f7c4:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02f7c8:	00008a06 	br	d02f9f4 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 d02f7cc:	e0bffd17 	ldw	r2,-12(fp)
 d02f7d0:	10800017 	ldw	r2,0(r2)
 d02f7d4:	1005003a 	cmpeq	r2,r2,zero
 d02f7d8:	1000071e 	bne	r2,zero,d02f7f8 <sosetopt+0x2ac>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 d02f7dc:	e0bffb17 	ldw	r2,-20(fp)
 d02f7e0:	1080088b 	ldhu	r2,34(r2)
 d02f7e4:	10804014 	ori	r2,r2,256
 d02f7e8:	1007883a 	mov	r3,r2
 d02f7ec:	e0bffb17 	ldw	r2,-20(fp)
 d02f7f0:	10c0088d 	sth	r3,34(r2)
 d02f7f4:	00007f06 	br	d02f9f4 <sosetopt+0x4a8>
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 d02f7f8:	e0bffb17 	ldw	r2,-20(fp)
 d02f7fc:	10c0088b 	ldhu	r3,34(r2)
 d02f800:	00bfbfc4 	movi	r2,-257
 d02f804:	1884703a 	and	r2,r3,r2
 d02f808:	1007883a 	mov	r3,r2
 d02f80c:	e0bffb17 	ldw	r2,-20(fp)
 d02f810:	10c0088d 	sth	r3,34(r2)
      break;
 d02f814:	00007706 	br	d02f9f4 <sosetopt+0x4a8>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 d02f818:	e13ffc17 	ldw	r4,-16(fp)
 d02f81c:	e17ffb17 	ldw	r5,-20(fp)
 d02f820:	e1bffd17 	ldw	r6,-12(fp)
 d02f824:	d0442c40 	call	d0442c4 <ip_setmoptions>
 d02f828:	e0bffa15 	stw	r2,-24(fp)
      break;
 d02f82c:	00007106 	br	d02f9f4 <sosetopt+0x4a8>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 d02f830:	e0bffd17 	ldw	r2,-12(fp)
 d02f834:	1004c03a 	cmpne	r2,r2,zero
 d02f838:	1000031e 	bne	r2,zero,d02f848 <sosetopt+0x2fc>
      {
         error = ENP_PARAM;
 d02f83c:	00bffd84 	movi	r2,-10
 d02f840:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02f844:	00006b06 	br	d02f9f4 <sosetopt+0x4a8>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 d02f848:	e0bffd17 	ldw	r2,-12(fp)
 d02f84c:	10800017 	ldw	r2,0(r2)
 d02f850:	1005003a 	cmpeq	r2,r2,zero
 d02f854:	1000061e 	bne	r2,zero,d02f870 <sosetopt+0x324>
         so->so_options |= SO_HDRINCL;
 d02f858:	e0bffb17 	ldw	r2,-20(fp)
 d02f85c:	10800417 	ldw	r2,16(r2)
 d02f860:	10c80014 	ori	r3,r2,8192
 d02f864:	e0bffb17 	ldw	r2,-20(fp)
 d02f868:	10c00415 	stw	r3,16(r2)
 d02f86c:	00006106 	br	d02f9f4 <sosetopt+0x4a8>
      else
         so->so_options &= ~SO_HDRINCL;
 d02f870:	e0bffb17 	ldw	r2,-20(fp)
 d02f874:	10c00417 	ldw	r3,16(r2)
 d02f878:	00b7ffc4 	movi	r2,-8193
 d02f87c:	1886703a 	and	r3,r3,r2
 d02f880:	e0bffb17 	ldw	r2,-20(fp)
 d02f884:	10c00415 	stw	r3,16(r2)
      break;
 d02f888:	00005a06 	br	d02f9f4 <sosetopt+0x4a8>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 d02f88c:	e0bffb17 	ldw	r2,-20(fp)
 d02f890:	10800983 	ldbu	r2,38(r2)
 d02f894:	10803fcc 	andi	r2,r2,255
 d02f898:	1080201c 	xori	r2,r2,128
 d02f89c:	10bfe004 	addi	r2,r2,-128
 d02f8a0:	10800060 	cmpeqi	r2,r2,1
 d02f8a4:	1000031e 	bne	r2,zero,d02f8b4 <sosetopt+0x368>
      {
         error = EINVAL;
 d02f8a8:	00800584 	movi	r2,22
 d02f8ac:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02f8b0:	00005006 	br	d02f9f4 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 d02f8b4:	e0bffb17 	ldw	r2,-20(fp)
 d02f8b8:	10800117 	ldw	r2,4(r2)
 d02f8bc:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 d02f8c0:	e0bff917 	ldw	r2,-28(fp)
 d02f8c4:	10800917 	ldw	r2,36(r2)
 d02f8c8:	e0bff815 	stw	r2,-32(fp)
      if(!tp)
 d02f8cc:	e0bff817 	ldw	r2,-32(fp)
 d02f8d0:	1004c03a 	cmpne	r2,r2,zero
 d02f8d4:	1000031e 	bne	r2,zero,d02f8e4 <sosetopt+0x398>
      {
         error = ENOTCONN;
 d02f8d8:	00802004 	movi	r2,128
 d02f8dc:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02f8e0:	00004406 	br	d02f9f4 <sosetopt+0x4a8>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 d02f8e4:	e0bffd17 	ldw	r2,-12(fp)
 d02f8e8:	1004c03a 	cmpne	r2,r2,zero
 d02f8ec:	1000031e 	bne	r2,zero,d02f8fc <sosetopt+0x3b0>
      {
         error = ENP_PARAM;
 d02f8f0:	00bffd84 	movi	r2,-10
 d02f8f4:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02f8f8:	00003e06 	br	d02f9f4 <sosetopt+0x4a8>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 d02f8fc:	e0bffd17 	ldw	r2,-12(fp)
 d02f900:	10800017 	ldw	r2,0(r2)
 d02f904:	1005003a 	cmpeq	r2,r2,zero
 d02f908:	1000071e 	bne	r2,zero,d02f928 <sosetopt+0x3dc>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 d02f90c:	e0bff817 	ldw	r2,-32(fp)
 d02f910:	10800b0b 	ldhu	r2,44(r2)
 d02f914:	10800114 	ori	r2,r2,4
 d02f918:	1007883a 	mov	r3,r2
 d02f91c:	e0bff817 	ldw	r2,-32(fp)
 d02f920:	10c00b0d 	sth	r3,44(r2)
 d02f924:	00003306 	br	d02f9f4 <sosetopt+0x4a8>
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 d02f928:	e0bff817 	ldw	r2,-32(fp)
 d02f92c:	10c00b0b 	ldhu	r3,44(r2)
 d02f930:	00bffec4 	movi	r2,-5
 d02f934:	1884703a 	and	r2,r3,r2
 d02f938:	1007883a 	mov	r3,r2
 d02f93c:	e0bff817 	ldw	r2,-32(fp)
 d02f940:	10c00b0d 	sth	r3,44(r2)

      break;
 d02f944:	00002b06 	br	d02f9f4 <sosetopt+0x4a8>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 d02f948:	e0bffb17 	ldw	r2,-20(fp)
 d02f94c:	10800983 	ldbu	r2,38(r2)
 d02f950:	10803fcc 	andi	r2,r2,255
 d02f954:	1080201c 	xori	r2,r2,128
 d02f958:	10bfe004 	addi	r2,r2,-128
 d02f95c:	10800060 	cmpeqi	r2,r2,1
 d02f960:	1000031e 	bne	r2,zero,d02f970 <sosetopt+0x424>
      {
         error = EINVAL;
 d02f964:	00800584 	movi	r2,22
 d02f968:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02f96c:	00002106 	br	d02f9f4 <sosetopt+0x4a8>
      }
      inp = (struct inpcb *)(so->so_pcb);
 d02f970:	e0bffb17 	ldw	r2,-20(fp)
 d02f974:	10800117 	ldw	r2,4(r2)
 d02f978:	e0bff715 	stw	r2,-36(fp)
      tp = intotcpcb(inp);
 d02f97c:	e0bff717 	ldw	r2,-36(fp)
 d02f980:	10800917 	ldw	r2,36(r2)
 d02f984:	e0bff615 	stw	r2,-40(fp)
      if(!tp)
 d02f988:	e0bff617 	ldw	r2,-40(fp)
 d02f98c:	1004c03a 	cmpne	r2,r2,zero
 d02f990:	1000031e 	bne	r2,zero,d02f9a0 <sosetopt+0x454>
      {
         error = ENOTCONN;
 d02f994:	00802004 	movi	r2,128
 d02f998:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02f99c:	00001506 	br	d02f9f4 <sosetopt+0x4a8>
      }
      if (tp->t_state != TCPS_CLOSED)
 d02f9a0:	e0bff617 	ldw	r2,-40(fp)
 d02f9a4:	10800217 	ldw	r2,8(r2)
 d02f9a8:	1005003a 	cmpeq	r2,r2,zero
 d02f9ac:	1000031e 	bne	r2,zero,d02f9bc <sosetopt+0x470>
      {
         error = EINVAL;
 d02f9b0:	00800584 	movi	r2,22
 d02f9b4:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02f9b8:	00000e06 	br	d02f9f4 <sosetopt+0x4a8>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 d02f9bc:	e0bffd17 	ldw	r2,-12(fp)
 d02f9c0:	10800017 	ldw	r2,0(r2)
 d02f9c4:	1007883a 	mov	r3,r2
 d02f9c8:	e0bff617 	ldw	r2,-40(fp)
 d02f9cc:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 d02f9d0:	e0bff617 	ldw	r2,-40(fp)
 d02f9d4:	10800b0b 	ldhu	r2,44(r2)
 d02f9d8:	10810014 	ori	r2,r2,1024
 d02f9dc:	1007883a 	mov	r3,r2
 d02f9e0:	e0bff617 	ldw	r2,-40(fp)
 d02f9e4:	10c00b0d 	sth	r3,44(r2)
      break;
 d02f9e8:	00000206 	br	d02f9f4 <sosetopt+0x4a8>
   }
   default:
      error = ENOPROTOOPT;
 d02f9ec:	00801b44 	movi	r2,109
 d02f9f0:	e0bffa15 	stw	r2,-24(fp)
      break;
   }
bad:
   return (error);
 d02f9f4:	e0bffa17 	ldw	r2,-24(fp)
}
 d02f9f8:	e037883a 	mov	sp,fp
 d02f9fc:	dfc00117 	ldw	ra,4(sp)
 d02fa00:	df000017 	ldw	fp,0(sp)
 d02fa04:	dec00204 	addi	sp,sp,8
 d02fa08:	f800283a 	ret

0d02fa0c <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 d02fa0c:	defff304 	addi	sp,sp,-52
 d02fa10:	dfc00c15 	stw	ra,48(sp)
 d02fa14:	df000b15 	stw	fp,44(sp)
 d02fa18:	df000b04 	addi	fp,sp,44
 d02fa1c:	e13ffb15 	stw	r4,-20(fp)
 d02fa20:	e17ffc15 	stw	r5,-16(fp)
 d02fa24:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 d02fa28:	e03ffa15 	stw	zero,-24(fp)

   /* sanity check the val parameter */
   if (!val)
 d02fa2c:	e0bffd17 	ldw	r2,-12(fp)
 d02fa30:	1004c03a 	cmpne	r2,r2,zero
 d02fa34:	1000031e 	bne	r2,zero,d02fa44 <sogetopt+0x38>
   {
      return ENP_PARAM;
 d02fa38:	00bffd84 	movi	r2,-10
 d02fa3c:	e0bffe15 	stw	r2,-8(fp)
 d02fa40:	00013c06 	br	d02ff34 <sogetopt+0x528>
   }

   switch (optname) 
 d02fa44:	e0fffc17 	ldw	r3,-16(fp)
 d02fa48:	e0ffff15 	stw	r3,-4(fp)
 d02fa4c:	e0ffff17 	ldw	r3,-4(fp)
 d02fa50:	188400e0 	cmpeqi	r2,r3,4099
 d02fa54:	10008f1e 	bne	r2,zero,d02fc94 <sogetopt+0x288>
 d02fa58:	e0ffff17 	ldw	r3,-4(fp)
 d02fa5c:	18840108 	cmpgei	r2,r3,4100
 d02fa60:	10002e1e 	bne	r2,zero,d02fb1c <sogetopt+0x110>
 d02fa64:	e0ffff17 	ldw	r3,-4(fp)
 d02fa68:	18800420 	cmpeqi	r2,r3,16
 d02fa6c:	1000821e 	bne	r2,zero,d02fc78 <sogetopt+0x26c>
 d02fa70:	e0ffff17 	ldw	r3,-4(fp)
 d02fa74:	18800448 	cmpgei	r2,r3,17
 d02fa78:	1000111e 	bne	r2,zero,d02fac0 <sogetopt+0xb4>
 d02fa7c:	e0ffff17 	ldw	r3,-4(fp)
 d02fa80:	18800220 	cmpeqi	r2,r3,8
 d02fa84:	10007c1e 	bne	r2,zero,d02fc78 <sogetopt+0x26c>
 d02fa88:	e0ffff17 	ldw	r3,-4(fp)
 d02fa8c:	18800248 	cmpgei	r2,r3,9
 d02fa90:	1000071e 	bne	r2,zero,d02fab0 <sogetopt+0xa4>
 d02fa94:	e0ffff17 	ldw	r3,-4(fp)
 d02fa98:	188000a0 	cmpeqi	r2,r3,2
 d02fa9c:	1000eb1e 	bne	r2,zero,d02fe4c <sogetopt+0x440>
 d02faa0:	e0ffff17 	ldw	r3,-4(fp)
 d02faa4:	18800120 	cmpeqi	r2,r3,4
 d02faa8:	1000731e 	bne	r2,zero,d02fc78 <sogetopt+0x26c>
 d02faac:	00011c06 	br	d02ff20 <sogetopt+0x514>
 d02fab0:	e0ffff17 	ldw	r3,-4(fp)
 d02fab4:	18800308 	cmpgei	r2,r3,12
 d02fab8:	1001191e 	bne	r2,zero,d02ff20 <sogetopt+0x514>
 d02fabc:	0000dd06 	br	d02fe34 <sogetopt+0x428>
 d02fac0:	e0ffff17 	ldw	r3,-4(fp)
 d02fac4:	18804020 	cmpeqi	r2,r3,256
 d02fac8:	10006b1e 	bne	r2,zero,d02fc78 <sogetopt+0x26c>
 d02facc:	e0ffff17 	ldw	r3,-4(fp)
 d02fad0:	18804048 	cmpgei	r2,r3,257
 d02fad4:	1000071e 	bne	r2,zero,d02faf4 <sogetopt+0xe8>
 d02fad8:	e0ffff17 	ldw	r3,-4(fp)
 d02fadc:	18800820 	cmpeqi	r2,r3,32
 d02fae0:	1000651e 	bne	r2,zero,d02fc78 <sogetopt+0x26c>
 d02fae4:	e0ffff17 	ldw	r3,-4(fp)
 d02fae8:	18802020 	cmpeqi	r2,r3,128
 d02faec:	1000531e 	bne	r2,zero,d02fc3c <sogetopt+0x230>
 d02faf0:	00010b06 	br	d02ff20 <sogetopt+0x514>
 d02faf4:	e0ffff17 	ldw	r3,-4(fp)
 d02faf8:	18840060 	cmpeqi	r2,r3,4097
 d02fafc:	10006f1e 	bne	r2,zero,d02fcbc <sogetopt+0x2b0>
 d02fb00:	e0ffff17 	ldw	r3,-4(fp)
 d02fb04:	18840088 	cmpgei	r2,r3,4098
 d02fb08:	1000711e 	bne	r2,zero,d02fcd0 <sogetopt+0x2c4>
 d02fb0c:	e0ffff17 	ldw	r3,-4(fp)
 d02fb10:	18808020 	cmpeqi	r2,r3,512
 d02fb14:	1000581e 	bne	r2,zero,d02fc78 <sogetopt+0x26c>
 d02fb18:	00010106 	br	d02ff20 <sogetopt+0x514>
 d02fb1c:	e0ffff17 	ldw	r3,-4(fp)
 d02fb20:	18840420 	cmpeqi	r2,r3,4112
 d02fb24:	1000881e 	bne	r2,zero,d02fd48 <sogetopt+0x33c>
 d02fb28:	e0ffff17 	ldw	r3,-4(fp)
 d02fb2c:	18840448 	cmpgei	r2,r3,4113
 d02fb30:	1000171e 	bne	r2,zero,d02fb90 <sogetopt+0x184>
 d02fb34:	e0ffff17 	ldw	r3,-4(fp)
 d02fb38:	188401a0 	cmpeqi	r2,r3,4102
 d02fb3c:	1000a31e 	bne	r2,zero,d02fdcc <sogetopt+0x3c0>
 d02fb40:	e0ffff17 	ldw	r3,-4(fp)
 d02fb44:	188401c8 	cmpgei	r2,r3,4103
 d02fb48:	1000071e 	bne	r2,zero,d02fb68 <sogetopt+0x15c>
 d02fb4c:	e0ffff17 	ldw	r3,-4(fp)
 d02fb50:	18840120 	cmpeqi	r2,r3,4100
 d02fb54:	1000541e 	bne	r2,zero,d02fca8 <sogetopt+0x29c>
 d02fb58:	e0ffff17 	ldw	r3,-4(fp)
 d02fb5c:	18840160 	cmpeqi	r2,r3,4101
 d02fb60:	1000951e 	bne	r2,zero,d02fdb8 <sogetopt+0x3ac>
 d02fb64:	0000ee06 	br	d02ff20 <sogetopt+0x514>
 d02fb68:	e0ffff17 	ldw	r3,-4(fp)
 d02fb6c:	18840220 	cmpeqi	r2,r3,4104
 d02fb70:	1000661e 	bne	r2,zero,d02fd0c <sogetopt+0x300>
 d02fb74:	e0ffff17 	ldw	r3,-4(fp)
 d02fb78:	18840210 	cmplti	r2,r3,4104
 d02fb7c:	10006b1e 	bne	r2,zero,d02fd2c <sogetopt+0x320>
 d02fb80:	e0ffff17 	ldw	r3,-4(fp)
 d02fb84:	18840260 	cmpeqi	r2,r3,4105
 d02fb88:	1000951e 	bne	r2,zero,d02fde0 <sogetopt+0x3d4>
 d02fb8c:	0000e406 	br	d02ff20 <sogetopt+0x514>
 d02fb90:	e0ffff17 	ldw	r3,-4(fp)
 d02fb94:	188404e0 	cmpeqi	r2,r3,4115
 d02fb98:	1000141e 	bne	r2,zero,d02fbec <sogetopt+0x1e0>
 d02fb9c:	e0ffff17 	ldw	r3,-4(fp)
 d02fba0:	18840508 	cmpgei	r2,r3,4116
 d02fba4:	1000071e 	bne	r2,zero,d02fbc4 <sogetopt+0x1b8>
 d02fba8:	e0ffff17 	ldw	r3,-4(fp)
 d02fbac:	18840460 	cmpeqi	r2,r3,4113
 d02fbb0:	10004c1e 	bne	r2,zero,d02fce4 <sogetopt+0x2d8>
 d02fbb4:	e0ffff17 	ldw	r3,-4(fp)
 d02fbb8:	188404a0 	cmpeqi	r2,r3,4114
 d02fbbc:	10004e1e 	bne	r2,zero,d02fcf8 <sogetopt+0x2ec>
 d02fbc0:	0000d706 	br	d02ff20 <sogetopt+0x514>
 d02fbc4:	e0ffff17 	ldw	r3,-4(fp)
 d02fbc8:	188800e0 	cmpeqi	r2,r3,8195
 d02fbcc:	10005e1e 	bne	r2,zero,d02fd48 <sogetopt+0x33c>
 d02fbd0:	e0ffff17 	ldw	r3,-4(fp)
 d02fbd4:	18880120 	cmpeqi	r2,r3,8196
 d02fbd8:	1000a81e 	bne	r2,zero,d02fe7c <sogetopt+0x470>
 d02fbdc:	e0ffff17 	ldw	r3,-4(fp)
 d02fbe0:	188405a0 	cmpeqi	r2,r3,4118
 d02fbe4:	1000861e 	bne	r2,zero,d02fe00 <sogetopt+0x3f4>
 d02fbe8:	0000cd06 	br	d02ff20 <sogetopt+0x514>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 d02fbec:	e0bffb17 	ldw	r2,-20(fp)
 d02fbf0:	1080088b 	ldhu	r2,34(r2)
 d02fbf4:	10bfffcc 	andi	r2,r2,65535
 d02fbf8:	1080008c 	andi	r2,r2,2
 d02fbfc:	1005003a 	cmpeq	r2,r2,zero
 d02fc00:	1000071e 	bne	r2,zero,d02fc20 <sogetopt+0x214>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 d02fc04:	e0fffd17 	ldw	r3,-12(fp)
 d02fc08:	e0bffb17 	ldw	r2,-20(fp)
 d02fc0c:	10800117 	ldw	r2,4(r2)
 d02fc10:	10800a17 	ldw	r2,40(r2)
 d02fc14:	10800a17 	ldw	r2,40(r2)
 d02fc18:	18800015 	stw	r2,0(r3)
 d02fc1c:	0000c306 	br	d02ff2c <sogetopt+0x520>
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 d02fc20:	e0fffd17 	ldw	r3,-12(fp)
 d02fc24:	008341b4 	movhi	r2,3334
 d02fc28:	10b2a504 	addi	r2,r2,-13676
 d02fc2c:	10800017 	ldw	r2,0(r2)
 d02fc30:	10800a17 	ldw	r2,40(r2)
 d02fc34:	18800015 	stw	r2,0(r3)
      break;
 d02fc38:	0000bc06 	br	d02ff2c <sogetopt+0x520>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 d02fc3c:	e0bffd17 	ldw	r2,-12(fp)
 d02fc40:	e0bff915 	stw	r2,-28(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 d02fc44:	e0bffb17 	ldw	r2,-20(fp)
 d02fc48:	10800417 	ldw	r2,16(r2)
 d02fc4c:	10c0200c 	andi	r3,r2,128
 d02fc50:	e0bff917 	ldw	r2,-28(fp)
 d02fc54:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 d02fc58:	e0bffb17 	ldw	r2,-20(fp)
 d02fc5c:	1080080b 	ldhu	r2,32(r2)
 d02fc60:	10ffffcc 	andi	r3,r2,65535
 d02fc64:	18e0001c 	xori	r3,r3,32768
 d02fc68:	18e00004 	addi	r3,r3,-32768
 d02fc6c:	e0bff917 	ldw	r2,-28(fp)
 d02fc70:	10c00115 	stw	r3,4(r2)
      }
      break;
 d02fc74:	0000ad06 	br	d02ff2c <sogetopt+0x520>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 d02fc78:	e13ffd17 	ldw	r4,-12(fp)
 d02fc7c:	e0bffb17 	ldw	r2,-20(fp)
 d02fc80:	10c00417 	ldw	r3,16(r2)
 d02fc84:	e0bffc17 	ldw	r2,-16(fp)
 d02fc88:	1884703a 	and	r2,r3,r2
 d02fc8c:	20800015 	stw	r2,0(r4)
      break;
 d02fc90:	0000a606 	br	d02ff2c <sogetopt+0x520>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 d02fc94:	e0fffd17 	ldw	r3,-12(fp)
 d02fc98:	e0bffb17 	ldw	r2,-20(fp)
 d02fc9c:	10801617 	ldw	r2,88(r2)
 d02fca0:	18800015 	stw	r2,0(r3)
      break;
 d02fca4:	0000a106 	br	d02ff2c <sogetopt+0x520>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 d02fca8:	e0fffd17 	ldw	r3,-12(fp)
 d02fcac:	e0bffb17 	ldw	r2,-20(fp)
 d02fcb0:	10800e17 	ldw	r2,56(r2)
 d02fcb4:	18800015 	stw	r2,0(r3)
      break;
 d02fcb8:	00009c06 	br	d02ff2c <sogetopt+0x520>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 d02fcbc:	e0fffd17 	ldw	r3,-12(fp)
 d02fcc0:	e0bffb17 	ldw	r2,-20(fp)
 d02fcc4:	10801317 	ldw	r2,76(r2)
 d02fcc8:	18800015 	stw	r2,0(r3)
      break;
 d02fccc:	00009706 	br	d02ff2c <sogetopt+0x520>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 d02fcd0:	e0fffd17 	ldw	r3,-12(fp)
 d02fcd4:	e0bffb17 	ldw	r2,-20(fp)
 d02fcd8:	10800b17 	ldw	r2,44(r2)
 d02fcdc:	18800015 	stw	r2,0(r3)
      break;
 d02fce0:	00009206 	br	d02ff2c <sogetopt+0x520>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 d02fce4:	e0fffd17 	ldw	r3,-12(fp)
 d02fce8:	e0bffb17 	ldw	r2,-20(fp)
 d02fcec:	10800a17 	ldw	r2,40(r2)
 d02fcf0:	18800015 	stw	r2,0(r3)
      break;
 d02fcf4:	00008d06 	br	d02ff2c <sogetopt+0x520>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 d02fcf8:	e0fffd17 	ldw	r3,-12(fp)
 d02fcfc:	e0bffb17 	ldw	r2,-20(fp)
 d02fd00:	10801217 	ldw	r2,72(r2)
 d02fd04:	18800015 	stw	r2,0(r3)
      break;
 d02fd08:	00008806 	br	d02ff2c <sogetopt+0x520>

   case SO_TYPE:
      *(int *)val = so->so_type;
 d02fd0c:	e0fffd17 	ldw	r3,-12(fp)
 d02fd10:	e0bffb17 	ldw	r2,-20(fp)
 d02fd14:	10800983 	ldbu	r2,38(r2)
 d02fd18:	10803fcc 	andi	r2,r2,255
 d02fd1c:	1080201c 	xori	r2,r2,128
 d02fd20:	10bfe004 	addi	r2,r2,-128
 d02fd24:	18800015 	stw	r2,0(r3)
      break;
 d02fd28:	00008006 	br	d02ff2c <sogetopt+0x520>

   case SO_ERROR:
      *(int *)val = so->so_error;
 d02fd2c:	e0fffd17 	ldw	r3,-12(fp)
 d02fd30:	e0bffb17 	ldw	r2,-20(fp)
 d02fd34:	10800617 	ldw	r2,24(r2)
 d02fd38:	18800015 	stw	r2,0(r3)
      so->so_error = 0;
 d02fd3c:	e0bffb17 	ldw	r2,-20(fp)
 d02fd40:	10000615 	stw	zero,24(r2)
      break;
 d02fd44:	00007906 	br	d02ff2c <sogetopt+0x520>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 d02fd48:	e0bffb17 	ldw	r2,-20(fp)
 d02fd4c:	10800983 	ldbu	r2,38(r2)
 d02fd50:	10803fcc 	andi	r2,r2,255
 d02fd54:	1080201c 	xori	r2,r2,128
 d02fd58:	10bfe004 	addi	r2,r2,-128
 d02fd5c:	10800060 	cmpeqi	r2,r2,1
 d02fd60:	1000031e 	bne	r2,zero,d02fd70 <sogetopt+0x364>
      {
         error = EINVAL;
 d02fd64:	00800584 	movi	r2,22
 d02fd68:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02fd6c:	00006f06 	br	d02ff2c <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 d02fd70:	e0bffb17 	ldw	r2,-20(fp)
 d02fd74:	10800117 	ldw	r2,4(r2)
 d02fd78:	e0bff815 	stw	r2,-32(fp)
      tp = intotcpcb(inp);
 d02fd7c:	e0bff817 	ldw	r2,-32(fp)
 d02fd80:	10800917 	ldw	r2,36(r2)
 d02fd84:	e0bff715 	stw	r2,-36(fp)
      if(!tp)
 d02fd88:	e0bff717 	ldw	r2,-36(fp)
 d02fd8c:	1004c03a 	cmpne	r2,r2,zero
 d02fd90:	1000031e 	bne	r2,zero,d02fda0 <sogetopt+0x394>
      {
         error = ENOTCONN;
 d02fd94:	00802004 	movi	r2,128
 d02fd98:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02fd9c:	00006306 	br	d02ff2c <sogetopt+0x520>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 d02fda0:	e0fffd17 	ldw	r3,-12(fp)
 d02fda4:	e0bff717 	ldw	r2,-36(fp)
 d02fda8:	10800a0b 	ldhu	r2,40(r2)
 d02fdac:	10bfffcc 	andi	r2,r2,65535
 d02fdb0:	18800015 	stw	r2,0(r3)
      break;
 d02fdb4:	00005d06 	br	d02ff2c <sogetopt+0x520>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 d02fdb8:	e0bffd17 	ldw	r2,-12(fp)
 d02fdbc:	e0fffb17 	ldw	r3,-20(fp)
 d02fdc0:	18c0198b 	ldhu	r3,102(r3)
 d02fdc4:	10c0000d 	sth	r3,0(r2)
      break;
 d02fdc8:	00005806 	br	d02ff2c <sogetopt+0x520>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 d02fdcc:	e0bffd17 	ldw	r2,-12(fp)
 d02fdd0:	e0fffb17 	ldw	r3,-20(fp)
 d02fdd4:	18c0118b 	ldhu	r3,70(r3)
 d02fdd8:	10c0000d 	sth	r3,0(r2)
      break;
 d02fddc:	00005306 	br	d02ff2c <sogetopt+0x520>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 d02fde0:	e0fffd17 	ldw	r3,-12(fp)
 d02fde4:	e0bffb17 	ldw	r2,-20(fp)
 d02fde8:	108009c3 	ldbu	r2,39(r2)
 d02fdec:	10803fcc 	andi	r2,r2,255
 d02fdf0:	1080201c 	xori	r2,r2,128
 d02fdf4:	10bfe004 	addi	r2,r2,-128
 d02fdf8:	18800015 	stw	r2,0(r3)
      break;
 d02fdfc:	00004b06 	br	d02ff2c <sogetopt+0x520>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 d02fe00:	e0bffb17 	ldw	r2,-20(fp)
 d02fe04:	1080088b 	ldhu	r2,34(r2)
 d02fe08:	10bfffcc 	andi	r2,r2,65535
 d02fe0c:	1080400c 	andi	r2,r2,256
 d02fe10:	1005003a 	cmpeq	r2,r2,zero
 d02fe14:	1000041e 	bne	r2,zero,d02fe28 <sogetopt+0x41c>
         *(int *)val = 1;   /* return 1 in val */
 d02fe18:	e0fffd17 	ldw	r3,-12(fp)
 d02fe1c:	00800044 	movi	r2,1
 d02fe20:	18800015 	stw	r2,0(r3)
 d02fe24:	00004106 	br	d02ff2c <sogetopt+0x520>
      else
         *(int *)val = 0;     /* return 0 in val */
 d02fe28:	e0bffd17 	ldw	r2,-12(fp)
 d02fe2c:	10000015 	stw	zero,0(r2)
      break;
 d02fe30:	00003e06 	br	d02ff2c <sogetopt+0x520>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 d02fe34:	e13ffc17 	ldw	r4,-16(fp)
 d02fe38:	e17ffb17 	ldw	r5,-20(fp)
 d02fe3c:	e1bffd17 	ldw	r6,-12(fp)
 d02fe40:	d0448b40 	call	d0448b4 <ip_getmoptions>
 d02fe44:	e0bffa15 	stw	r2,-24(fp)
      break;
 d02fe48:	00003806 	br	d02ff2c <sogetopt+0x520>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 d02fe4c:	e0bffb17 	ldw	r2,-20(fp)
 d02fe50:	10800417 	ldw	r2,16(r2)
 d02fe54:	1088000c 	andi	r2,r2,8192
 d02fe58:	1005003a 	cmpeq	r2,r2,zero
 d02fe5c:	1000041e 	bne	r2,zero,d02fe70 <sogetopt+0x464>
         *(int *)val = 1;
 d02fe60:	e0fffd17 	ldw	r3,-12(fp)
 d02fe64:	00800044 	movi	r2,1
 d02fe68:	18800015 	stw	r2,0(r3)
 d02fe6c:	00002f06 	br	d02ff2c <sogetopt+0x520>
      else
         *(int *)val = 0;
 d02fe70:	e0bffd17 	ldw	r2,-12(fp)
 d02fe74:	10000015 	stw	zero,0(r2)
      break;
 d02fe78:	00002c06 	br	d02ff2c <sogetopt+0x520>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 d02fe7c:	e0bffb17 	ldw	r2,-20(fp)
 d02fe80:	10800983 	ldbu	r2,38(r2)
 d02fe84:	10803fcc 	andi	r2,r2,255
 d02fe88:	1080201c 	xori	r2,r2,128
 d02fe8c:	10bfe004 	addi	r2,r2,-128
 d02fe90:	10800060 	cmpeqi	r2,r2,1
 d02fe94:	1000031e 	bne	r2,zero,d02fea4 <sogetopt+0x498>
      {
         error = EINVAL;
 d02fe98:	00800584 	movi	r2,22
 d02fe9c:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02fea0:	00002206 	br	d02ff2c <sogetopt+0x520>
      }
      inp = (struct inpcb *)(so->so_pcb);
 d02fea4:	e0bffb17 	ldw	r2,-20(fp)
 d02fea8:	10800117 	ldw	r2,4(r2)
 d02feac:	e0bff615 	stw	r2,-40(fp)
      tp = intotcpcb(inp);
 d02feb0:	e0bff617 	ldw	r2,-40(fp)
 d02feb4:	10800917 	ldw	r2,36(r2)
 d02feb8:	e0bff515 	stw	r2,-44(fp)
      if (!tp)
 d02febc:	e0bff517 	ldw	r2,-44(fp)
 d02fec0:	1004c03a 	cmpne	r2,r2,zero
 d02fec4:	1000031e 	bne	r2,zero,d02fed4 <sogetopt+0x4c8>
      {
         error = ENOTCONN;
 d02fec8:	00802004 	movi	r2,128
 d02fecc:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02fed0:	00001606 	br	d02ff2c <sogetopt+0x520>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 d02fed4:	e0bffd17 	ldw	r2,-12(fp)
 d02fed8:	1004c03a 	cmpne	r2,r2,zero
 d02fedc:	1000031e 	bne	r2,zero,d02feec <sogetopt+0x4e0>
      {
         error = ENP_PARAM;
 d02fee0:	00bffd84 	movi	r2,-10
 d02fee4:	e0bffa15 	stw	r2,-24(fp)
         break;
 d02fee8:	00001006 	br	d02ff2c <sogetopt+0x520>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 d02feec:	e0bff517 	ldw	r2,-44(fp)
 d02fef0:	10800b0b 	ldhu	r2,44(r2)
 d02fef4:	10bfffcc 	andi	r2,r2,65535
 d02fef8:	1080010c 	andi	r2,r2,4
 d02fefc:	1005003a 	cmpeq	r2,r2,zero
 d02ff00:	1000041e 	bne	r2,zero,d02ff14 <sogetopt+0x508>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 d02ff04:	e0fffd17 	ldw	r3,-12(fp)
 d02ff08:	00800044 	movi	r2,1
 d02ff0c:	18800015 	stw	r2,0(r3)
 d02ff10:	00000606 	br	d02ff2c <sogetopt+0x520>
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 d02ff14:	e0bffd17 	ldw	r2,-12(fp)
 d02ff18:	10000015 	stw	zero,0(r2)

      break;
 d02ff1c:	00000306 	br	d02ff2c <sogetopt+0x520>
   }

   default:
      return ENOPROTOOPT;
 d02ff20:	00801b44 	movi	r2,109
 d02ff24:	e0bffe15 	stw	r2,-8(fp)
 d02ff28:	00000206 	br	d02ff34 <sogetopt+0x528>
   }
   return error;     /* no error */
 d02ff2c:	e0fffa17 	ldw	r3,-24(fp)
 d02ff30:	e0fffe15 	stw	r3,-8(fp)
 d02ff34:	e0bffe17 	ldw	r2,-8(fp)
}
 d02ff38:	e037883a 	mov	sp,fp
 d02ff3c:	dfc00117 	ldw	ra,4(sp)
 d02ff40:	df000017 	ldw	fp,0(sp)
 d02ff44:	dec00204 	addi	sp,sp,8
 d02ff48:	f800283a 	ret

0d02ff4c <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 d02ff4c:	defffd04 	addi	sp,sp,-12
 d02ff50:	dfc00215 	stw	ra,8(sp)
 d02ff54:	df000115 	stw	fp,4(sp)
 d02ff58:	df000104 	addi	fp,sp,4
 d02ff5c:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 d02ff60:	e0ffff17 	ldw	r3,-4(fp)
 d02ff64:	00803644 	movi	r2,217
 d02ff68:	18800615 	stw	r2,24(r3)
   sorwakeup (so);
 d02ff6c:	e0bfff17 	ldw	r2,-4(fp)
 d02ff70:	11400a04 	addi	r5,r2,40
 d02ff74:	e13fff17 	ldw	r4,-4(fp)
 d02ff78:	d0307680 	call	d030768 <sbwakeup>
}
 d02ff7c:	e037883a 	mov	sp,fp
 d02ff80:	dfc00117 	ldw	ra,4(sp)
 d02ff84:	df000017 	ldw	fp,0(sp)
 d02ff88:	dec00204 	addi	sp,sp,8
 d02ff8c:	f800283a 	ret

0d02ff90 <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 d02ff90:	defffd04 	addi	sp,sp,-12
 d02ff94:	dfc00215 	stw	ra,8(sp)
 d02ff98:	df000115 	stw	fp,4(sp)
 d02ff9c:	df000104 	addi	fp,sp,4
 d02ffa0:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 d02ffa4:	e0bfff17 	ldw	r2,-4(fp)
 d02ffa8:	10c0088b 	ldhu	r3,34(r2)
 d02ffac:	00bffd44 	movi	r2,-11
 d02ffb0:	1884703a 	and	r2,r3,r2
 d02ffb4:	1007883a 	mov	r3,r2
 d02ffb8:	e0bfff17 	ldw	r2,-4(fp)
 d02ffbc:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 d02ffc0:	e0bfff17 	ldw	r2,-4(fp)
 d02ffc4:	1080088b 	ldhu	r2,34(r2)
 d02ffc8:	10800114 	ori	r2,r2,4
 d02ffcc:	1007883a 	mov	r3,r2
 d02ffd0:	e0bfff17 	ldw	r2,-4(fp)
 d02ffd4:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 d02ffd8:	e0bfff17 	ldw	r2,-4(fp)
 d02ffdc:	10800904 	addi	r2,r2,36
 d02ffe0:	1009883a 	mov	r4,r2
 d02ffe4:	d02515c0 	call	d02515c <tcp_wakeup>
}
 d02ffe8:	e037883a 	mov	sp,fp
 d02ffec:	dfc00117 	ldw	ra,4(sp)
 d02fff0:	df000017 	ldw	fp,0(sp)
 d02fff4:	dec00204 	addi	sp,sp,8
 d02fff8:	f800283a 	ret

0d02fffc <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 d02fffc:	defffc04 	addi	sp,sp,-16
 d030000:	dfc00315 	stw	ra,12(sp)
 d030004:	df000215 	stw	fp,8(sp)
 d030008:	df000204 	addi	fp,sp,8
 d03000c:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 d030010:	e0bfff17 	ldw	r2,-4(fp)
 d030014:	10801b17 	ldw	r2,108(r2)
 d030018:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 d03001c:	e0bffe17 	ldw	r2,-8(fp)
 d030020:	1005003a 	cmpeq	r2,r2,zero
 d030024:	1000141e 	bne	r2,zero,d030078 <soisconnected+0x7c>
   {
      if (soqremque(so, 0) == 0)
 d030028:	e13fff17 	ldw	r4,-4(fp)
 d03002c:	000b883a 	mov	r5,zero
 d030030:	d0305080 	call	d030508 <soqremque>
 d030034:	1004c03a 	cmpne	r2,r2,zero
 d030038:	1000031e 	bne	r2,zero,d030048 <soisconnected+0x4c>
         panic("soisconnected");
 d03003c:	01034174 	movhi	r4,3333
 d030040:	213dfa04 	addi	r4,r4,-2072
 d030044:	d0246440 	call	d024644 <panic>
      soqinsque(head, so, 1);
 d030048:	e13ffe17 	ldw	r4,-8(fp)
 d03004c:	e17fff17 	ldw	r5,-4(fp)
 d030050:	01800044 	movi	r6,1
 d030054:	d03045c0 	call	d03045c <soqinsque>
      sorwakeup(head);
 d030058:	e0bffe17 	ldw	r2,-8(fp)
 d03005c:	11400a04 	addi	r5,r2,40
 d030060:	e13ffe17 	ldw	r4,-8(fp)
 d030064:	d0307680 	call	d030768 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 d030068:	e0bffe17 	ldw	r2,-8(fp)
 d03006c:	10800904 	addi	r2,r2,36
 d030070:	1009883a 	mov	r4,r2
 d030074:	d02515c0 	call	d02515c <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 d030078:	e0bfff17 	ldw	r2,-4(fp)
 d03007c:	10c0088b 	ldhu	r3,34(r2)
 d030080:	00bffcc4 	movi	r2,-13
 d030084:	1884703a 	and	r2,r3,r2
 d030088:	1007883a 	mov	r3,r2
 d03008c:	e0bfff17 	ldw	r2,-4(fp)
 d030090:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 d030094:	e0bfff17 	ldw	r2,-4(fp)
 d030098:	1080088b 	ldhu	r2,34(r2)
 d03009c:	10800094 	ori	r2,r2,2
 d0300a0:	1007883a 	mov	r3,r2
 d0300a4:	e0bfff17 	ldw	r2,-4(fp)
 d0300a8:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 d0300ac:	e0bfff17 	ldw	r2,-4(fp)
 d0300b0:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 d0300b4:	e0bfff17 	ldw	r2,-4(fp)
 d0300b8:	10800904 	addi	r2,r2,36
 d0300bc:	1009883a 	mov	r4,r2
 d0300c0:	d02515c0 	call	d02515c <tcp_wakeup>
   sorwakeup (so);
 d0300c4:	e0bfff17 	ldw	r2,-4(fp)
 d0300c8:	11400a04 	addi	r5,r2,40
 d0300cc:	e13fff17 	ldw	r4,-4(fp)
 d0300d0:	d0307680 	call	d030768 <sbwakeup>
   sowwakeup (so);
 d0300d4:	e0bfff17 	ldw	r2,-4(fp)
 d0300d8:	11401204 	addi	r5,r2,72
 d0300dc:	e13fff17 	ldw	r4,-4(fp)
 d0300e0:	d0307680 	call	d030768 <sbwakeup>
}
 d0300e4:	e037883a 	mov	sp,fp
 d0300e8:	dfc00117 	ldw	ra,4(sp)
 d0300ec:	df000017 	ldw	fp,0(sp)
 d0300f0:	dec00204 	addi	sp,sp,8
 d0300f4:	f800283a 	ret

0d0300f8 <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 d0300f8:	defffd04 	addi	sp,sp,-12
 d0300fc:	dfc00215 	stw	ra,8(sp)
 d030100:	df000115 	stw	fp,4(sp)
 d030104:	df000104 	addi	fp,sp,4
 d030108:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 d03010c:	e0bfff17 	ldw	r2,-4(fp)
 d030110:	10c0088b 	ldhu	r3,34(r2)
 d030114:	00bffec4 	movi	r2,-5
 d030118:	1884703a 	and	r2,r3,r2
 d03011c:	1007883a 	mov	r3,r2
 d030120:	e0bfff17 	ldw	r2,-4(fp)
 d030124:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 d030128:	e0bfff17 	ldw	r2,-4(fp)
 d03012c:	1080088b 	ldhu	r2,34(r2)
 d030130:	10800e14 	ori	r2,r2,56
 d030134:	1007883a 	mov	r3,r2
 d030138:	e0bfff17 	ldw	r2,-4(fp)
 d03013c:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 d030140:	e0bfff17 	ldw	r2,-4(fp)
 d030144:	10800904 	addi	r2,r2,36
 d030148:	1009883a 	mov	r4,r2
 d03014c:	d02515c0 	call	d02515c <tcp_wakeup>
   sowwakeup (so);
 d030150:	e0bfff17 	ldw	r2,-4(fp)
 d030154:	11401204 	addi	r5,r2,72
 d030158:	e13fff17 	ldw	r4,-4(fp)
 d03015c:	d0307680 	call	d030768 <sbwakeup>
   sorwakeup (so);
 d030160:	e0bfff17 	ldw	r2,-4(fp)
 d030164:	11400a04 	addi	r5,r2,40
 d030168:	e13fff17 	ldw	r4,-4(fp)
 d03016c:	d0307680 	call	d030768 <sbwakeup>
}
 d030170:	e037883a 	mov	sp,fp
 d030174:	dfc00117 	ldw	ra,4(sp)
 d030178:	df000017 	ldw	fp,0(sp)
 d03017c:	dec00204 	addi	sp,sp,8
 d030180:	f800283a 	ret

0d030184 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 d030184:	defffd04 	addi	sp,sp,-12
 d030188:	dfc00215 	stw	ra,8(sp)
 d03018c:	df000115 	stw	fp,4(sp)
 d030190:	df000104 	addi	fp,sp,4
 d030194:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 d030198:	e0bfff17 	ldw	r2,-4(fp)
 d03019c:	1080088b 	ldhu	r2,34(r2)
 d0301a0:	10bfffcc 	andi	r2,r2,65535
 d0301a4:	1080010c 	andi	r2,r2,4
 d0301a8:	1005003a 	cmpeq	r2,r2,zero
 d0301ac:	1000061e 	bne	r2,zero,d0301c8 <soisdisconnected+0x44>
      so->so_state |= SS_WASCONNECTING;
 d0301b0:	e0bfff17 	ldw	r2,-4(fp)
 d0301b4:	1080088b 	ldhu	r2,34(r2)
 d0301b8:	10880014 	ori	r2,r2,8192
 d0301bc:	1007883a 	mov	r3,r2
 d0301c0:	e0bfff17 	ldw	r2,-4(fp)
 d0301c4:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 d0301c8:	e0bfff17 	ldw	r2,-4(fp)
 d0301cc:	10c0088b 	ldhu	r3,34(r2)
 d0301d0:	00bffc44 	movi	r2,-15
 d0301d4:	1884703a 	and	r2,r3,r2
 d0301d8:	1007883a 	mov	r3,r2
 d0301dc:	e0bfff17 	ldw	r2,-4(fp)
 d0301e0:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 d0301e4:	e0bfff17 	ldw	r2,-4(fp)
 d0301e8:	1080088b 	ldhu	r2,34(r2)
 d0301ec:	10800c14 	ori	r2,r2,48
 d0301f0:	1007883a 	mov	r3,r2
 d0301f4:	e0bfff17 	ldw	r2,-4(fp)
 d0301f8:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 d0301fc:	e0bfff17 	ldw	r2,-4(fp)
 d030200:	10800904 	addi	r2,r2,36
 d030204:	1009883a 	mov	r4,r2
 d030208:	d02515c0 	call	d02515c <tcp_wakeup>
   sowwakeup (so);
 d03020c:	e0bfff17 	ldw	r2,-4(fp)
 d030210:	11401204 	addi	r5,r2,72
 d030214:	e13fff17 	ldw	r4,-4(fp)
 d030218:	d0307680 	call	d030768 <sbwakeup>
   sorwakeup (so);
 d03021c:	e0bfff17 	ldw	r2,-4(fp)
 d030220:	11400a04 	addi	r5,r2,40
 d030224:	e13fff17 	ldw	r4,-4(fp)
 d030228:	d0307680 	call	d030768 <sbwakeup>
}
 d03022c:	e037883a 	mov	sp,fp
 d030230:	dfc00117 	ldw	ra,4(sp)
 d030234:	df000017 	ldw	fp,0(sp)
 d030238:	dec00204 	addi	sp,sp,8
 d03023c:	f800283a 	ret

0d030240 <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 d030240:	defffa04 	addi	sp,sp,-24
 d030244:	dfc00515 	stw	ra,20(sp)
 d030248:	df000415 	stw	fp,16(sp)
 d03024c:	df000404 	addi	fp,sp,16
 d030250:	e13ffe15 	stw	r4,-8(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 d030254:	e0bffe17 	ldw	r2,-8(fp)
 d030258:	10801e43 	ldbu	r2,121(r2)
 d03025c:	10c03fcc 	andi	r3,r2,255
 d030260:	18c0201c 	xori	r3,r3,128
 d030264:	18ffe004 	addi	r3,r3,-128
 d030268:	e0bffe17 	ldw	r2,-8(fp)
 d03026c:	10801e03 	ldbu	r2,120(r2)
 d030270:	10803fcc 	andi	r2,r2,255
 d030274:	1080201c 	xori	r2,r2,128
 d030278:	10bfe004 	addi	r2,r2,-128
 d03027c:	1889883a 	add	r4,r3,r2
 d030280:	e0bffe17 	ldw	r2,-8(fp)
 d030284:	10801e83 	ldbu	r2,122(r2)
 d030288:	10c03fcc 	andi	r3,r2,255
 d03028c:	18c0201c 	xori	r3,r3,128
 d030290:	18ffe004 	addi	r3,r3,-128
 d030294:	1805883a 	mov	r2,r3
 d030298:	1085883a 	add	r2,r2,r2
 d03029c:	10c7883a 	add	r3,r2,r3
 d0302a0:	1804d7fa 	srli	r2,r3,31
 d0302a4:	10c5883a 	add	r2,r2,r3
 d0302a8:	1005d07a 	srai	r2,r2,1
 d0302ac:	11006416 	blt	r2,r4,d030440 <sonewconn+0x200>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 d0302b0:	01002104 	movi	r4,132
 d0302b4:	d029e2c0 	call	d029e2c <npalloc>
 d0302b8:	e0bffd15 	stw	r2,-12(fp)
 d0302bc:	e0bffd17 	ldw	r2,-12(fp)
 d0302c0:	1005003a 	cmpeq	r2,r2,zero
 d0302c4:	10005e1e 	bne	r2,zero,d030440 <sonewconn+0x200>
      goto bad;
   so->next = NULL;
 d0302c8:	e0bffd17 	ldw	r2,-12(fp)
 d0302cc:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 d0302d0:	e17ffd17 	ldw	r5,-12(fp)
 d0302d4:	010341b4 	movhi	r4,3334
 d0302d8:	2133e204 	addi	r4,r4,-12408
 d0302dc:	d028d780 	call	d028d78 <putq>
   so->so_type = head->so_type;
 d0302e0:	e0bffe17 	ldw	r2,-8(fp)
 d0302e4:	10c00983 	ldbu	r3,38(r2)
 d0302e8:	e0bffd17 	ldw	r2,-12(fp)
 d0302ec:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 d0302f0:	e0bffe17 	ldw	r2,-8(fp)
 d0302f4:	10c00417 	ldw	r3,16(r2)
 d0302f8:	00bfff44 	movi	r2,-3
 d0302fc:	1886703a 	and	r3,r3,r2
 d030300:	e0bffd17 	ldw	r2,-12(fp)
 d030304:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 d030308:	e0bffe17 	ldw	r2,-8(fp)
 d03030c:	10c0080b 	ldhu	r3,32(r2)
 d030310:	e0bffd17 	ldw	r2,-12(fp)
 d030314:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 d030318:	e0bffe17 	ldw	r2,-8(fp)
 d03031c:	1080088b 	ldhu	r2,34(r2)
 d030320:	10800054 	ori	r2,r2,1
 d030324:	1007883a 	mov	r3,r2
 d030328:	e0bffd17 	ldw	r2,-12(fp)
 d03032c:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 d030330:	e0bffe17 	ldw	r2,-8(fp)
 d030334:	10c00217 	ldw	r3,8(r2)
 d030338:	e0bffd17 	ldw	r2,-12(fp)
 d03033c:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 d030340:	e0bffe17 	ldw	r2,-8(fp)
 d030344:	10c0090b 	ldhu	r3,36(r2)
 d030348:	e0bffd17 	ldw	r2,-12(fp)
 d03034c:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 d030350:	00834174 	movhi	r2,3333
 d030354:	108a6204 	addi	r2,r2,10632
 d030358:	10c00017 	ldw	r3,0(r2)
 d03035c:	e0bffd17 	ldw	r2,-12(fp)
 d030360:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 d030364:	00834174 	movhi	r2,3333
 d030368:	108a6104 	addi	r2,r2,10628
 d03036c:	10c00017 	ldw	r3,0(r2)
 d030370:	e0bffd17 	ldw	r2,-12(fp)
 d030374:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 d030378:	e13ffe17 	ldw	r4,-8(fp)
 d03037c:	e17ffd17 	ldw	r5,-12(fp)
 d030380:	000d883a 	mov	r6,zero
 d030384:	d03045c0 	call	d03045c <soqinsque>
   so->so_req = PRU_ATTACH;
 d030388:	e0bffd17 	ldw	r2,-12(fp)
 d03038c:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 d030390:	e0bffe17 	ldw	r2,-8(fp)
 d030394:	10c00517 	ldw	r3,20(r2)
 d030398:	e0bffd17 	ldw	r2,-12(fp)
 d03039c:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 d0303a0:	e0bffd17 	ldw	r2,-12(fp)
 d0303a4:	10800217 	ldw	r2,8(r2)
 d0303a8:	10800317 	ldw	r2,12(r2)
 d0303ac:	e13ffd17 	ldw	r4,-12(fp)
 d0303b0:	000b883a 	mov	r5,zero
 d0303b4:	000d883a 	mov	r6,zero
 d0303b8:	103ee83a 	callr	r2
 d0303bc:	1004c03a 	cmpne	r2,r2,zero
 d0303c0:	1000161e 	bne	r2,zero,d03041c <sonewconn+0x1dc>
      goto bad2;
   if (so_evtmap)
 d0303c4:	00834174 	movhi	r2,3333
 d0303c8:	108aef04 	addi	r2,r2,11196
 d0303cc:	10800003 	ldbu	r2,0(r2)
 d0303d0:	10803fcc 	andi	r2,r2,255
 d0303d4:	1005003a 	cmpeq	r2,r2,zero
 d0303d8:	10000d1e 	bne	r2,zero,d030410 <sonewconn+0x1d0>
   {
      rc = (*so_evtmap_create) (so);                       
 d0303dc:	00834174 	movhi	r2,3333
 d0303e0:	108aed04 	addi	r2,r2,11188
 d0303e4:	10800017 	ldw	r2,0(r2)
 d0303e8:	e13ffd17 	ldw	r4,-12(fp)
 d0303ec:	103ee83a 	callr	r2
 d0303f0:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0) goto bad2;
 d0303f4:	e0bffc17 	ldw	r2,-16(fp)
 d0303f8:	1004c03a 	cmpne	r2,r2,zero
 d0303fc:	1000071e 	bne	r2,zero,d03041c <sonewconn+0x1dc>
      so->owner = head->owner;
 d030400:	e0bffe17 	ldw	r2,-8(fp)
 d030404:	10c02003 	ldbu	r3,128(r2)
 d030408:	e0bffd17 	ldw	r2,-12(fp)
 d03040c:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 d030410:	e0bffd17 	ldw	r2,-12(fp)
 d030414:	e0bfff15 	stw	r2,-4(fp)
 d030418:	00000a06 	br	d030444 <sonewconn+0x204>
   
bad2:
   (void) soqremque (so, 0);
 d03041c:	e13ffd17 	ldw	r4,-12(fp)
 d030420:	000b883a 	mov	r5,zero
 d030424:	d0305080 	call	d030508 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 d030428:	010341b4 	movhi	r4,3334
 d03042c:	2133e204 	addi	r4,r4,-12408
 d030430:	e17ffd17 	ldw	r5,-12(fp)
 d030434:	d028e280 	call	d028e28 <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 d030438:	e13ffd17 	ldw	r4,-12(fp)
 d03043c:	d029f200 	call	d029f20 <npfree>
bad:
   return ((struct socket *)0);
 d030440:	e03fff15 	stw	zero,-4(fp)
 d030444:	e0bfff17 	ldw	r2,-4(fp)
}
 d030448:	e037883a 	mov	sp,fp
 d03044c:	dfc00117 	ldw	ra,4(sp)
 d030450:	df000017 	ldw	fp,0(sp)
 d030454:	dec00204 	addi	sp,sp,8
 d030458:	f800283a 	ret

0d03045c <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 d03045c:	defffc04 	addi	sp,sp,-16
 d030460:	df000315 	stw	fp,12(sp)
 d030464:	df000304 	addi	fp,sp,12
 d030468:	e13ffd15 	stw	r4,-12(fp)
 d03046c:	e17ffe15 	stw	r5,-8(fp)
 d030470:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 d030474:	e0fffe17 	ldw	r3,-8(fp)
 d030478:	e0bffd17 	ldw	r2,-12(fp)
 d03047c:	18801b15 	stw	r2,108(r3)
   if (q == 0) 
 d030480:	e0bfff17 	ldw	r2,-4(fp)
 d030484:	1004c03a 	cmpne	r2,r2,zero
 d030488:	10000e1e 	bne	r2,zero,d0304c4 <soqinsque+0x68>
   {
      head->so_q0len++;
 d03048c:	e0bffd17 	ldw	r2,-12(fp)
 d030490:	10801e03 	ldbu	r2,120(r2)
 d030494:	10800044 	addi	r2,r2,1
 d030498:	1007883a 	mov	r3,r2
 d03049c:	e0bffd17 	ldw	r2,-12(fp)
 d0304a0:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 d0304a4:	e0bffd17 	ldw	r2,-12(fp)
 d0304a8:	10c01c17 	ldw	r3,112(r2)
 d0304ac:	e0bffe17 	ldw	r2,-8(fp)
 d0304b0:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 d0304b4:	e0fffd17 	ldw	r3,-12(fp)
 d0304b8:	e0bffe17 	ldw	r2,-8(fp)
 d0304bc:	18801c15 	stw	r2,112(r3)
 d0304c0:	00000d06 	br	d0304f8 <soqinsque+0x9c>
   } else 
   {
      head->so_qlen++;
 d0304c4:	e0bffd17 	ldw	r2,-12(fp)
 d0304c8:	10801e43 	ldbu	r2,121(r2)
 d0304cc:	10800044 	addi	r2,r2,1
 d0304d0:	1007883a 	mov	r3,r2
 d0304d4:	e0bffd17 	ldw	r2,-12(fp)
 d0304d8:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 d0304dc:	e0bffd17 	ldw	r2,-12(fp)
 d0304e0:	10c01d17 	ldw	r3,116(r2)
 d0304e4:	e0bffe17 	ldw	r2,-8(fp)
 d0304e8:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 d0304ec:	e0fffd17 	ldw	r3,-12(fp)
 d0304f0:	e0bffe17 	ldw	r2,-8(fp)
 d0304f4:	18801d15 	stw	r2,116(r3)
   }
}
 d0304f8:	e037883a 	mov	sp,fp
 d0304fc:	df000017 	ldw	fp,0(sp)
 d030500:	dec00104 	addi	sp,sp,4
 d030504:	f800283a 	ret

0d030508 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 d030508:	defff804 	addi	sp,sp,-32
 d03050c:	df000715 	stw	fp,28(sp)
 d030510:	df000704 	addi	fp,sp,28
 d030514:	e13ffc15 	stw	r4,-16(fp)
 d030518:	e17ffd15 	stw	r5,-12(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 d03051c:	e0bffc17 	ldw	r2,-16(fp)
 d030520:	10801b17 	ldw	r2,108(r2)
 d030524:	e0bffb15 	stw	r2,-20(fp)
   prev = head;
 d030528:	e0bffb17 	ldw	r2,-20(fp)
 d03052c:	e0bffa15 	stw	r2,-24(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 d030530:	e0bffd17 	ldw	r2,-12(fp)
 d030534:	1005003a 	cmpeq	r2,r2,zero
 d030538:	1000041e 	bne	r2,zero,d03054c <soqremque+0x44>
 d03053c:	e0bffa17 	ldw	r2,-24(fp)
 d030540:	10801d17 	ldw	r2,116(r2)
 d030544:	e0bfff15 	stw	r2,-4(fp)
 d030548:	00000306 	br	d030558 <soqremque+0x50>
 d03054c:	e0bffa17 	ldw	r2,-24(fp)
 d030550:	10801c17 	ldw	r2,112(r2)
 d030554:	e0bfff15 	stw	r2,-4(fp)
 d030558:	e0bfff17 	ldw	r2,-4(fp)
 d03055c:	e0bff915 	stw	r2,-28(fp)
      if (next == so)
 d030560:	e0fff917 	ldw	r3,-28(fp)
 d030564:	e0bffc17 	ldw	r2,-16(fp)
 d030568:	18800826 	beq	r3,r2,d03058c <soqremque+0x84>
         break;
      if (next == head)
 d03056c:	e0fff917 	ldw	r3,-28(fp)
 d030570:	e0bffb17 	ldw	r2,-20(fp)
 d030574:	1880021e 	bne	r3,r2,d030580 <soqremque+0x78>
         return (0);
 d030578:	e03ffe15 	stw	zero,-8(fp)
 d03057c:	00002506 	br	d030614 <soqremque+0x10c>
      prev = next;
 d030580:	e0bff917 	ldw	r2,-28(fp)
 d030584:	e0bffa15 	stw	r2,-24(fp)
   }
 d030588:	003fe906 	br	d030530 <soqremque+0x28>
   if (q == 0) 
 d03058c:	e0bffd17 	ldw	r2,-12(fp)
 d030590:	1004c03a 	cmpne	r2,r2,zero
 d030594:	10000b1e 	bne	r2,zero,d0305c4 <soqremque+0xbc>
   {
      prev->so_q0 = next->so_q0;
 d030598:	e0bff917 	ldw	r2,-28(fp)
 d03059c:	10c01c17 	ldw	r3,112(r2)
 d0305a0:	e0bffa17 	ldw	r2,-24(fp)
 d0305a4:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 d0305a8:	e0bffb17 	ldw	r2,-20(fp)
 d0305ac:	10801e03 	ldbu	r2,120(r2)
 d0305b0:	10bfffc4 	addi	r2,r2,-1
 d0305b4:	1007883a 	mov	r3,r2
 d0305b8:	e0bffb17 	ldw	r2,-20(fp)
 d0305bc:	10c01e05 	stb	r3,120(r2)
 d0305c0:	00000a06 	br	d0305ec <soqremque+0xe4>
   } else 
   {
      prev->so_q = next->so_q;
 d0305c4:	e0bff917 	ldw	r2,-28(fp)
 d0305c8:	10c01d17 	ldw	r3,116(r2)
 d0305cc:	e0bffa17 	ldw	r2,-24(fp)
 d0305d0:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 d0305d4:	e0bffb17 	ldw	r2,-20(fp)
 d0305d8:	10801e43 	ldbu	r2,121(r2)
 d0305dc:	10bfffc4 	addi	r2,r2,-1
 d0305e0:	1007883a 	mov	r3,r2
 d0305e4:	e0bffb17 	ldw	r2,-20(fp)
 d0305e8:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 d0305ec:	e0bff917 	ldw	r2,-28(fp)
 d0305f0:	10001d15 	stw	zero,116(r2)
 d0305f4:	e0bff917 	ldw	r2,-28(fp)
 d0305f8:	10c01d17 	ldw	r3,116(r2)
 d0305fc:	e0bff917 	ldw	r2,-28(fp)
 d030600:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 d030604:	e0bff917 	ldw	r2,-28(fp)
 d030608:	10001b15 	stw	zero,108(r2)
   return 1;
 d03060c:	00800044 	movi	r2,1
 d030610:	e0bffe15 	stw	r2,-8(fp)
 d030614:	e0bffe17 	ldw	r2,-8(fp)
}
 d030618:	e037883a 	mov	sp,fp
 d03061c:	df000017 	ldw	fp,0(sp)
 d030620:	dec00104 	addi	sp,sp,4
 d030624:	f800283a 	ret

0d030628 <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 d030628:	defffd04 	addi	sp,sp,-12
 d03062c:	dfc00215 	stw	ra,8(sp)
 d030630:	df000115 	stw	fp,4(sp)
 d030634:	df000104 	addi	fp,sp,4
 d030638:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 d03063c:	e0bfff17 	ldw	r2,-4(fp)
 d030640:	1080088b 	ldhu	r2,34(r2)
 d030644:	10800414 	ori	r2,r2,16
 d030648:	1007883a 	mov	r3,r2
 d03064c:	e0bfff17 	ldw	r2,-4(fp)
 d030650:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 d030654:	e0bfff17 	ldw	r2,-4(fp)
 d030658:	11401204 	addi	r5,r2,72
 d03065c:	e13fff17 	ldw	r4,-4(fp)
 d030660:	d0307680 	call	d030768 <sbwakeup>
}
 d030664:	e037883a 	mov	sp,fp
 d030668:	dfc00117 	ldw	ra,4(sp)
 d03066c:	df000017 	ldw	fp,0(sp)
 d030670:	dec00204 	addi	sp,sp,8
 d030674:	f800283a 	ret

0d030678 <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 d030678:	defffd04 	addi	sp,sp,-12
 d03067c:	dfc00215 	stw	ra,8(sp)
 d030680:	df000115 	stw	fp,4(sp)
 d030684:	df000104 	addi	fp,sp,4
 d030688:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 d03068c:	e0bfff17 	ldw	r2,-4(fp)
 d030690:	1080088b 	ldhu	r2,34(r2)
 d030694:	10800814 	ori	r2,r2,32
 d030698:	1007883a 	mov	r3,r2
 d03069c:	e0bfff17 	ldw	r2,-4(fp)
 d0306a0:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 d0306a4:	e0bfff17 	ldw	r2,-4(fp)
 d0306a8:	11400a04 	addi	r5,r2,40
 d0306ac:	e13fff17 	ldw	r4,-4(fp)
 d0306b0:	d0307680 	call	d030768 <sbwakeup>
}
 d0306b4:	e037883a 	mov	sp,fp
 d0306b8:	dfc00117 	ldw	ra,4(sp)
 d0306bc:	df000017 	ldw	fp,0(sp)
 d0306c0:	dec00204 	addi	sp,sp,8
 d0306c4:	f800283a 	ret

0d0306c8 <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 d0306c8:	defffe04 	addi	sp,sp,-8
 d0306cc:	df000115 	stw	fp,4(sp)
 d0306d0:	df000104 	addi	fp,sp,4
 d0306d4:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 d0306d8:	e0bfff17 	ldw	r2,-4(fp)
 d0306dc:	1080070b 	ldhu	r2,28(r2)
 d0306e0:	10800214 	ori	r2,r2,8
 d0306e4:	1007883a 	mov	r3,r2
 d0306e8:	e0bfff17 	ldw	r2,-4(fp)
 d0306ec:	10c0070d 	sth	r3,28(r2)
}
 d0306f0:	e037883a 	mov	sp,fp
 d0306f4:	df000017 	ldw	fp,0(sp)
 d0306f8:	dec00104 	addi	sp,sp,4
 d0306fc:	f800283a 	ret

0d030700 <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 d030700:	defffd04 	addi	sp,sp,-12
 d030704:	dfc00215 	stw	ra,8(sp)
 d030708:	df000115 	stw	fp,4(sp)
 d03070c:	df000104 	addi	fp,sp,4
 d030710:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 d030714:	e0bfff17 	ldw	r2,-4(fp)
 d030718:	1080070b 	ldhu	r2,28(r2)
 d03071c:	10800114 	ori	r2,r2,4
 d030720:	1007883a 	mov	r3,r2
 d030724:	e0bfff17 	ldw	r2,-4(fp)
 d030728:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 d03072c:	e0bfff17 	ldw	r2,-4(fp)
 d030730:	1009883a 	mov	r4,r2
 d030734:	d024fbc0 	call	d024fbc <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 d030738:	e0bfff17 	ldw	r2,-4(fp)
 d03073c:	10c0070b 	ldhu	r3,28(r2)
 d030740:	00bffec4 	movi	r2,-5
 d030744:	1884703a 	and	r2,r3,r2
 d030748:	1007883a 	mov	r3,r2
 d03074c:	e0bfff17 	ldw	r2,-4(fp)
 d030750:	10c0070d 	sth	r3,28(r2)
}
 d030754:	e037883a 	mov	sp,fp
 d030758:	dfc00117 	ldw	ra,4(sp)
 d03075c:	df000017 	ldw	fp,0(sp)
 d030760:	dec00204 	addi	sp,sp,8
 d030764:	f800283a 	ret

0d030768 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 d030768:	defffc04 	addi	sp,sp,-16
 d03076c:	dfc00315 	stw	ra,12(sp)
 d030770:	df000215 	stw	fp,8(sp)
 d030774:	df000204 	addi	fp,sp,8
 d030778:	e13ffe15 	stw	r4,-8(fp)
 d03077c:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 d030780:	e0bfff17 	ldw	r2,-4(fp)
 d030784:	1080070b 	ldhu	r2,28(r2)
 d030788:	10bfffcc 	andi	r2,r2,65535
 d03078c:	1080020c 	andi	r2,r2,8
 d030790:	1005003a 	cmpeq	r2,r2,zero
 d030794:	10000d1e 	bne	r2,zero,d0307cc <sbwakeup+0x64>
   {
      select_wait = 0;
 d030798:	00834174 	movhi	r2,3333
 d03079c:	108ad104 	addi	r2,r2,11076
 d0307a0:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 d0307a4:	01034174 	movhi	r4,3333
 d0307a8:	210ad104 	addi	r4,r4,11076
 d0307ac:	d02515c0 	call	d02515c <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 d0307b0:	e0bfff17 	ldw	r2,-4(fp)
 d0307b4:	10c0070b 	ldhu	r3,28(r2)
 d0307b8:	00bffdc4 	movi	r2,-9
 d0307bc:	1884703a 	and	r2,r3,r2
 d0307c0:	1007883a 	mov	r3,r2
 d0307c4:	e0bfff17 	ldw	r2,-4(fp)
 d0307c8:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 d0307cc:	e0bfff17 	ldw	r2,-4(fp)
 d0307d0:	1080070b 	ldhu	r2,28(r2)
 d0307d4:	10bfffcc 	andi	r2,r2,65535
 d0307d8:	1080010c 	andi	r2,r2,4
 d0307dc:	1005003a 	cmpeq	r2,r2,zero
 d0307e0:	1000031e 	bne	r2,zero,d0307f0 <sbwakeup+0x88>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 d0307e4:	e0bfff17 	ldw	r2,-4(fp)
 d0307e8:	1009883a 	mov	r4,r2
 d0307ec:	d02515c0 	call	d02515c <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 d0307f0:	e037883a 	mov	sp,fp
 d0307f4:	dfc00117 	ldw	ra,4(sp)
 d0307f8:	df000017 	ldw	fp,0(sp)
 d0307fc:	dec00204 	addi	sp,sp,8
 d030800:	f800283a 	ret

0d030804 <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 d030804:	defffa04 	addi	sp,sp,-24
 d030808:	dfc00515 	stw	ra,20(sp)
 d03080c:	df000415 	stw	fp,16(sp)
 d030810:	df000404 	addi	fp,sp,16
 d030814:	e13ffc15 	stw	r4,-16(fp)
 d030818:	e17ffd15 	stw	r5,-12(fp)
 d03081c:	e1bffe15 	stw	r6,-8(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 d030820:	e0bffc17 	ldw	r2,-16(fp)
 d030824:	11001204 	addi	r4,r2,72
 d030828:	e17ffd17 	ldw	r5,-12(fp)
 d03082c:	d0308840 	call	d030884 <sbreserve>
 d030830:	1005003a 	cmpeq	r2,r2,zero
 d030834:	10000b1e 	bne	r2,zero,d030864 <soreserve+0x60>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 d030838:	e0bffc17 	ldw	r2,-16(fp)
 d03083c:	11000a04 	addi	r4,r2,40
 d030840:	e17ffe17 	ldw	r5,-8(fp)
 d030844:	d0308840 	call	d030884 <sbreserve>
 d030848:	1005003a 	cmpeq	r2,r2,zero
 d03084c:	1000021e 	bne	r2,zero,d030858 <soreserve+0x54>
      goto bad2;
   return (0);
 d030850:	e03fff15 	stw	zero,-4(fp)
 d030854:	00000506 	br	d03086c <soreserve+0x68>
bad2:
   sbrelease(&so->so_snd);
 d030858:	e0bffc17 	ldw	r2,-16(fp)
 d03085c:	11001204 	addi	r4,r2,72
 d030860:	d0308e40 	call	d0308e4 <sbrelease>
bad:
   return (ENOBUFS);
 d030864:	00801a44 	movi	r2,105
 d030868:	e0bfff15 	stw	r2,-4(fp)
 d03086c:	e0bfff17 	ldw	r2,-4(fp)
}
 d030870:	e037883a 	mov	sp,fp
 d030874:	dfc00117 	ldw	ra,4(sp)
 d030878:	df000017 	ldw	fp,0(sp)
 d03087c:	dec00204 	addi	sp,sp,8
 d030880:	f800283a 	ret

0d030884 <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 d030884:	defffc04 	addi	sp,sp,-16
 d030888:	df000315 	stw	fp,12(sp)
 d03088c:	df000304 	addi	fp,sp,12
 d030890:	e13ffd15 	stw	r4,-12(fp)
 d030894:	e17ffe15 	stw	r5,-8(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 d030898:	e0fffd17 	ldw	r3,-12(fp)
 d03089c:	e0bffe17 	ldw	r2,-8(fp)
 d0308a0:	18800115 	stw	r2,4(r3)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 d0308a4:	e0bffe17 	ldw	r2,-8(fp)
 d0308a8:	1085883a 	add	r2,r2,r2
 d0308ac:	e0bfff15 	stw	r2,-4(fp)
 d0308b0:	e0ffff17 	ldw	r3,-4(fp)
 d0308b4:	18900070 	cmpltui	r2,r3,16385
 d0308b8:	1000021e 	bne	r2,zero,d0308c4 <sbreserve+0x40>
 d0308bc:	00900004 	movi	r2,16384
 d0308c0:	e0bfff15 	stw	r2,-4(fp)
 d0308c4:	e0bffd17 	ldw	r2,-12(fp)
 d0308c8:	e0ffff17 	ldw	r3,-4(fp)
 d0308cc:	10c00315 	stw	r3,12(r2)
   return (1);
 d0308d0:	00800044 	movi	r2,1
}
 d0308d4:	e037883a 	mov	sp,fp
 d0308d8:	df000017 	ldw	fp,0(sp)
 d0308dc:	dec00104 	addi	sp,sp,4
 d0308e0:	f800283a 	ret

0d0308e4 <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 d0308e4:	defffd04 	addi	sp,sp,-12
 d0308e8:	dfc00215 	stw	ra,8(sp)
 d0308ec:	df000115 	stw	fp,4(sp)
 d0308f0:	df000104 	addi	fp,sp,4
 d0308f4:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 d0308f8:	e13fff17 	ldw	r4,-4(fp)
 d0308fc:	d030ea40 	call	d030ea4 <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 d030900:	e0bfff17 	ldw	r2,-4(fp)
 d030904:	10000315 	stw	zero,12(r2)
 d030908:	e0bfff17 	ldw	r2,-4(fp)
 d03090c:	10c00317 	ldw	r3,12(r2)
 d030910:	e0bfff17 	ldw	r2,-4(fp)
 d030914:	10c00115 	stw	r3,4(r2)
}
 d030918:	e037883a 	mov	sp,fp
 d03091c:	dfc00117 	ldw	ra,4(sp)
 d030920:	df000017 	ldw	fp,0(sp)
 d030924:	dec00204 	addi	sp,sp,8
 d030928:	f800283a 	ret

0d03092c <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 d03092c:	defffb04 	addi	sp,sp,-20
 d030930:	dfc00415 	stw	ra,16(sp)
 d030934:	df000315 	stw	fp,12(sp)
 d030938:	df000304 	addi	fp,sp,12
 d03093c:	e13ffe15 	stw	r4,-8(fp)
 d030940:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 d030944:	e0bfff17 	ldw	r2,-4(fp)
 d030948:	1005003a 	cmpeq	r2,r2,zero
 d03094c:	10001c1e 	bne	r2,zero,d0309c0 <sbappend+0x94>
      return;
   ENTER_CRIT_SECTION(sb);
 d030950:	d0295e80 	call	d0295e8 <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 d030954:	e0bffe17 	ldw	r2,-8(fp)
 d030958:	10800617 	ldw	r2,24(r2)
 d03095c:	e0bffd15 	stw	r2,-12(fp)
 d030960:	e0bffd17 	ldw	r2,-12(fp)
 d030964:	1005003a 	cmpeq	r2,r2,zero
 d030968:	1000101e 	bne	r2,zero,d0309ac <sbappend+0x80>
   {
      while (n->m_act)
 d03096c:	00000306 	br	d03097c <sbappend+0x50>
         n = n->m_act;
 d030970:	e0bffd17 	ldw	r2,-12(fp)
 d030974:	10800717 	ldw	r2,28(r2)
 d030978:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 d03097c:	e0bffd17 	ldw	r2,-12(fp)
 d030980:	10800717 	ldw	r2,28(r2)
 d030984:	1004c03a 	cmpne	r2,r2,zero
 d030988:	103ff91e 	bne	r2,zero,d030970 <sbappend+0x44>
         n = n->m_act;
      while (n->m_next)
 d03098c:	00000306 	br	d03099c <sbappend+0x70>
         n = n->m_next;
 d030990:	e0bffd17 	ldw	r2,-12(fp)
 d030994:	10800617 	ldw	r2,24(r2)
 d030998:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 d03099c:	e0bffd17 	ldw	r2,-12(fp)
 d0309a0:	10800617 	ldw	r2,24(r2)
 d0309a4:	1004c03a 	cmpne	r2,r2,zero
 d0309a8:	103ff91e 	bne	r2,zero,d030990 <sbappend+0x64>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 d0309ac:	e13ffe17 	ldw	r4,-8(fp)
 d0309b0:	e17fff17 	ldw	r5,-4(fp)
 d0309b4:	e1bffd17 	ldw	r6,-12(fp)
 d0309b8:	d030cbc0 	call	d030cbc <sbcompress>
   EXIT_CRIT_SECTION(sb);
 d0309bc:	d0296440 	call	d029644 <irq_Unmask>
}
 d0309c0:	e037883a 	mov	sp,fp
 d0309c4:	dfc00117 	ldw	ra,4(sp)
 d0309c8:	df000017 	ldw	fp,0(sp)
 d0309cc:	dec00204 	addi	sp,sp,8
 d0309d0:	f800283a 	ret

0d0309d4 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 d0309d4:	defffb04 	addi	sp,sp,-20
 d0309d8:	dfc00415 	stw	ra,16(sp)
 d0309dc:	df000315 	stw	fp,12(sp)
 d0309e0:	df000304 	addi	fp,sp,12
 d0309e4:	e13ffe15 	stw	r4,-8(fp)
 d0309e8:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 d0309ec:	e0bfff17 	ldw	r2,-4(fp)
 d0309f0:	1005003a 	cmpeq	r2,r2,zero
 d0309f4:	10002a1e 	bne	r2,zero,d030aa0 <sbappendrecord+0xcc>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 d0309f8:	d0295e80 	call	d0295e8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 d0309fc:	e0bffe17 	ldw	r2,-8(fp)
 d030a00:	10800617 	ldw	r2,24(r2)
 d030a04:	e0bffd15 	stw	r2,-12(fp)
 d030a08:	e0bffd17 	ldw	r2,-12(fp)
 d030a0c:	1005003a 	cmpeq	r2,r2,zero
 d030a10:	1000081e 	bne	r2,zero,d030a34 <sbappendrecord+0x60>
      while (m->m_act)
 d030a14:	00000306 	br	d030a24 <sbappendrecord+0x50>
      m = m->m_act;
 d030a18:	e0bffd17 	ldw	r2,-12(fp)
 d030a1c:	10800717 	ldw	r2,28(r2)
 d030a20:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 d030a24:	e0bffd17 	ldw	r2,-12(fp)
 d030a28:	10800717 	ldw	r2,28(r2)
 d030a2c:	1004c03a 	cmpne	r2,r2,zero
 d030a30:	103ff91e 	bne	r2,zero,d030a18 <sbappendrecord+0x44>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 d030a34:	e0bffe17 	ldw	r2,-8(fp)
 d030a38:	10c00017 	ldw	r3,0(r2)
 d030a3c:	e0bfff17 	ldw	r2,-4(fp)
 d030a40:	10800217 	ldw	r2,8(r2)
 d030a44:	1887883a 	add	r3,r3,r2
 d030a48:	e0bffe17 	ldw	r2,-8(fp)
 d030a4c:	10c00015 	stw	r3,0(r2)
   if (m)
 d030a50:	e0bffd17 	ldw	r2,-12(fp)
 d030a54:	1005003a 	cmpeq	r2,r2,zero
 d030a58:	1000041e 	bne	r2,zero,d030a6c <sbappendrecord+0x98>
      m->m_act = m0;
 d030a5c:	e0fffd17 	ldw	r3,-12(fp)
 d030a60:	e0bfff17 	ldw	r2,-4(fp)
 d030a64:	18800715 	stw	r2,28(r3)
 d030a68:	00000306 	br	d030a78 <sbappendrecord+0xa4>
   else
      sb->sb_mb = m0;
 d030a6c:	e0fffe17 	ldw	r3,-8(fp)
 d030a70:	e0bfff17 	ldw	r2,-4(fp)
 d030a74:	18800615 	stw	r2,24(r3)
   m = m0->m_next;
 d030a78:	e0bfff17 	ldw	r2,-4(fp)
 d030a7c:	10800617 	ldw	r2,24(r2)
 d030a80:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 d030a84:	e0bfff17 	ldw	r2,-4(fp)
 d030a88:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 d030a8c:	e13ffe17 	ldw	r4,-8(fp)
 d030a90:	e17ffd17 	ldw	r5,-12(fp)
 d030a94:	e1bfff17 	ldw	r6,-4(fp)
 d030a98:	d030cbc0 	call	d030cbc <sbcompress>
   EXIT_CRIT_SECTION(sb);
 d030a9c:	d0296440 	call	d029644 <irq_Unmask>
}
 d030aa0:	e037883a 	mov	sp,fp
 d030aa4:	dfc00117 	ldw	ra,4(sp)
 d030aa8:	df000017 	ldw	fp,0(sp)
 d030aac:	dec00204 	addi	sp,sp,8
 d030ab0:	f800283a 	ret

0d030ab4 <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 d030ab4:	defff604 	addi	sp,sp,-40
 d030ab8:	dfc00915 	stw	ra,36(sp)
 d030abc:	df000815 	stw	fp,32(sp)
 d030ac0:	df000804 	addi	fp,sp,32
 d030ac4:	e13ffb15 	stw	r4,-20(fp)
 d030ac8:	e17ffc15 	stw	r5,-16(fp)
 d030acc:	e1bffd15 	stw	r6,-12(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 d030ad0:	00800404 	movi	r2,16
 d030ad4:	e0bff815 	stw	r2,-32(fp)

   ENTER_CRIT_SECTION(sb);
 d030ad8:	d0295e80 	call	d0295e8 <irq_Mask>
   for (m = m0; m; m = m->m_next)
 d030adc:	e0bffd17 	ldw	r2,-12(fp)
 d030ae0:	e0bffa15 	stw	r2,-24(fp)
 d030ae4:	00000806 	br	d030b08 <sbappendaddr+0x54>
      space += m->m_len;
 d030ae8:	e0bffa17 	ldw	r2,-24(fp)
 d030aec:	10c00217 	ldw	r3,8(r2)
 d030af0:	e0bff817 	ldw	r2,-32(fp)
 d030af4:	1885883a 	add	r2,r3,r2
 d030af8:	e0bff815 	stw	r2,-32(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 d030afc:	e0bffa17 	ldw	r2,-24(fp)
 d030b00:	10800617 	ldw	r2,24(r2)
 d030b04:	e0bffa15 	stw	r2,-24(fp)
 d030b08:	e0bffa17 	ldw	r2,-24(fp)
 d030b0c:	1004c03a 	cmpne	r2,r2,zero
 d030b10:	103ff51e 	bne	r2,zero,d030ae8 <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 d030b14:	e0bffb17 	ldw	r2,-20(fp)
 d030b18:	10800117 	ldw	r2,4(r2)
 d030b1c:	1007883a 	mov	r3,r2
 d030b20:	e0bffb17 	ldw	r2,-20(fp)
 d030b24:	10800017 	ldw	r2,0(r2)
 d030b28:	1885c83a 	sub	r2,r3,r2
 d030b2c:	1004803a 	cmplt	r2,r2,zero
 d030b30:	1000071e 	bne	r2,zero,d030b50 <sbappendaddr+0x9c>
 d030b34:	e0bffb17 	ldw	r2,-20(fp)
 d030b38:	10c00117 	ldw	r3,4(r2)
 d030b3c:	e0bffb17 	ldw	r2,-20(fp)
 d030b40:	10800017 	ldw	r2,0(r2)
 d030b44:	1885c83a 	sub	r2,r3,r2
 d030b48:	e0bfff15 	stw	r2,-4(fp)
 d030b4c:	00000106 	br	d030b54 <sbappendaddr+0xa0>
 d030b50:	e03fff15 	stw	zero,-4(fp)
 d030b54:	e0bff817 	ldw	r2,-32(fp)
 d030b58:	e0ffff17 	ldw	r3,-4(fp)
 d030b5c:	1880030e 	bge	r3,r2,d030b6c <sbappendaddr+0xb8>
   {
      EXIT_CRIT_SECTION(sb);
 d030b60:	d0296440 	call	d029644 <irq_Unmask>
      return (0);
 d030b64:	e03ffe15 	stw	zero,-8(fp)
 d030b68:	00004e06 	br	d030ca4 <sbappendaddr+0x1f0>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 d030b6c:	01000244 	movi	r4,9
 d030b70:	01400404 	movi	r5,16
 d030b74:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d030b78:	e0bffa15 	stw	r2,-24(fp)
 d030b7c:	e0bffa17 	ldw	r2,-24(fp)
 d030b80:	1004c03a 	cmpne	r2,r2,zero
 d030b84:	1000031e 	bne	r2,zero,d030b94 <sbappendaddr+0xe0>
   {
      EXIT_CRIT_SECTION(sb);
 d030b88:	d0296440 	call	d029644 <irq_Unmask>
      return 0;
 d030b8c:	e03ffe15 	stw	zero,-8(fp)
 d030b90:	00004406 	br	d030ca4 <sbappendaddr+0x1f0>
   }
   *mtod(m, struct sockaddr *) = *asa;
 d030b94:	e0bffa17 	ldw	r2,-24(fp)
 d030b98:	10800317 	ldw	r2,12(r2)
 d030b9c:	1009883a 	mov	r4,r2
 d030ba0:	e0fffc17 	ldw	r3,-16(fp)
 d030ba4:	1880000b 	ldhu	r2,0(r3)
 d030ba8:	2080000d 	sth	r2,0(r4)
 d030bac:	1880008b 	ldhu	r2,2(r3)
 d030bb0:	2080008d 	sth	r2,2(r4)
 d030bb4:	1880010b 	ldhu	r2,4(r3)
 d030bb8:	2080010d 	sth	r2,4(r4)
 d030bbc:	1880018b 	ldhu	r2,6(r3)
 d030bc0:	2080018d 	sth	r2,6(r4)
 d030bc4:	1880020b 	ldhu	r2,8(r3)
 d030bc8:	2080020d 	sth	r2,8(r4)
 d030bcc:	1880028b 	ldhu	r2,10(r3)
 d030bd0:	2080028d 	sth	r2,10(r4)
 d030bd4:	1880030b 	ldhu	r2,12(r3)
 d030bd8:	2080030d 	sth	r2,12(r4)
 d030bdc:	1880038b 	ldhu	r2,14(r3)
 d030be0:	2080038d 	sth	r2,14(r4)
   m->m_len = sizeof (*asa);
 d030be4:	e0fffa17 	ldw	r3,-24(fp)
 d030be8:	00800404 	movi	r2,16
 d030bec:	18800215 	stw	r2,8(r3)
   sballoc (sb, m);
 d030bf0:	e0bffb17 	ldw	r2,-20(fp)
 d030bf4:	10c00017 	ldw	r3,0(r2)
 d030bf8:	e0bffa17 	ldw	r2,-24(fp)
 d030bfc:	10800217 	ldw	r2,8(r2)
 d030c00:	1887883a 	add	r3,r3,r2
 d030c04:	e0bffb17 	ldw	r2,-20(fp)
 d030c08:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 d030c0c:	e0bffb17 	ldw	r2,-20(fp)
 d030c10:	10800617 	ldw	r2,24(r2)
 d030c14:	e0bff915 	stw	r2,-28(fp)
 d030c18:	e0bff917 	ldw	r2,-28(fp)
 d030c1c:	1005003a 	cmpeq	r2,r2,zero
 d030c20:	10000c1e 	bne	r2,zero,d030c54 <sbappendaddr+0x1a0>
   {
      while (n->m_act)
 d030c24:	00000306 	br	d030c34 <sbappendaddr+0x180>
         n = n->m_act;
 d030c28:	e0bff917 	ldw	r2,-28(fp)
 d030c2c:	10800717 	ldw	r2,28(r2)
 d030c30:	e0bff915 	stw	r2,-28(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 d030c34:	e0bff917 	ldw	r2,-28(fp)
 d030c38:	10800717 	ldw	r2,28(r2)
 d030c3c:	1004c03a 	cmpne	r2,r2,zero
 d030c40:	103ff91e 	bne	r2,zero,d030c28 <sbappendaddr+0x174>
         n = n->m_act;
      n->m_act = m;
 d030c44:	e0fff917 	ldw	r3,-28(fp)
 d030c48:	e0bffa17 	ldw	r2,-24(fp)
 d030c4c:	18800715 	stw	r2,28(r3)
 d030c50:	00000306 	br	d030c60 <sbappendaddr+0x1ac>
   } else
      sb->sb_mb = m;
 d030c54:	e0fffb17 	ldw	r3,-20(fp)
 d030c58:	e0bffa17 	ldw	r2,-24(fp)
 d030c5c:	18800615 	stw	r2,24(r3)
   if (m->m_next)
 d030c60:	e0bffa17 	ldw	r2,-24(fp)
 d030c64:	10800617 	ldw	r2,24(r2)
 d030c68:	1005003a 	cmpeq	r2,r2,zero
 d030c6c:	1000031e 	bne	r2,zero,d030c7c <sbappendaddr+0x1c8>
      m = m->m_next;
 d030c70:	e0bffa17 	ldw	r2,-24(fp)
 d030c74:	10800617 	ldw	r2,24(r2)
 d030c78:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 d030c7c:	e0bffd17 	ldw	r2,-12(fp)
 d030c80:	1005003a 	cmpeq	r2,r2,zero
 d030c84:	1000041e 	bne	r2,zero,d030c98 <sbappendaddr+0x1e4>
      sbcompress(sb, m0, m);
 d030c88:	e13ffb17 	ldw	r4,-20(fp)
 d030c8c:	e17ffd17 	ldw	r5,-12(fp)
 d030c90:	e1bffa17 	ldw	r6,-24(fp)
 d030c94:	d030cbc0 	call	d030cbc <sbcompress>

   EXIT_CRIT_SECTION(sb);
 d030c98:	d0296440 	call	d029644 <irq_Unmask>
   return (1);
 d030c9c:	00800044 	movi	r2,1
 d030ca0:	e0bffe15 	stw	r2,-8(fp)
 d030ca4:	e0bffe17 	ldw	r2,-8(fp)
}
 d030ca8:	e037883a 	mov	sp,fp
 d030cac:	dfc00117 	ldw	ra,4(sp)
 d030cb0:	df000017 	ldw	fp,0(sp)
 d030cb4:	dec00204 	addi	sp,sp,8
 d030cb8:	f800283a 	ret

0d030cbc <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 d030cbc:	defffb04 	addi	sp,sp,-20
 d030cc0:	dfc00415 	stw	ra,16(sp)
 d030cc4:	df000315 	stw	fp,12(sp)
 d030cc8:	df000304 	addi	fp,sp,12
 d030ccc:	e13ffd15 	stw	r4,-12(fp)
 d030cd0:	e17ffe15 	stw	r5,-8(fp)
 d030cd4:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 d030cd8:	00006a06 	br	d030e84 <sbcompress+0x1c8>
   {
      if (m->m_len == 0) 
 d030cdc:	e0bffe17 	ldw	r2,-8(fp)
 d030ce0:	10800217 	ldw	r2,8(r2)
 d030ce4:	1004c03a 	cmpne	r2,r2,zero
 d030ce8:	1000041e 	bne	r2,zero,d030cfc <sbcompress+0x40>
      {
         m = m_free(m);
 d030cec:	e13ffe17 	ldw	r4,-8(fp)
 d030cf0:	d02a3900 	call	d02a390 <m_free>
 d030cf4:	e0bffe15 	stw	r2,-8(fp)
         continue;
 d030cf8:	00006206 	br	d030e84 <sbcompress+0x1c8>
      }
      if (m->m_type != MT_RXDATA && 
 d030cfc:	e0bffe17 	ldw	r2,-8(fp)
 d030d00:	10800817 	ldw	r2,32(r2)
 d030d04:	10800060 	cmpeqi	r2,r2,1
 d030d08:	1000101e 	bne	r2,zero,d030d4c <sbcompress+0x90>
 d030d0c:	e0bffe17 	ldw	r2,-8(fp)
 d030d10:	10800817 	ldw	r2,32(r2)
 d030d14:	108000a0 	cmpeqi	r2,r2,2
 d030d18:	10000c1e 	bne	r2,zero,d030d4c <sbcompress+0x90>
 d030d1c:	e0bffe17 	ldw	r2,-8(fp)
 d030d20:	10800817 	ldw	r2,32(r2)
 d030d24:	10800260 	cmpeqi	r2,r2,9
 d030d28:	1000081e 	bne	r2,zero,d030d4c <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 d030d2c:	e0bffe17 	ldw	r2,-8(fp)
 d030d30:	11400817 	ldw	r5,32(r2)
 d030d34:	01034174 	movhi	r4,3333
 d030d38:	213dfe04 	addi	r4,r4,-2056
 d030d3c:	d0029980 	call	d002998 <printf>
         panic ("sbcomp:bad");
 d030d40:	01034174 	movhi	r4,3333
 d030d44:	213e0304 	addi	r4,r4,-2036
 d030d48:	d0246440 	call	d024644 <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 d030d4c:	e0bfff17 	ldw	r2,-4(fp)
 d030d50:	1005003a 	cmpeq	r2,r2,zero
 d030d54:	1000331e 	bne	r2,zero,d030e24 <sbcompress+0x168>
 d030d58:	e0bffd17 	ldw	r2,-12(fp)
 d030d5c:	1080070b 	ldhu	r2,28(r2)
 d030d60:	10bfffcc 	andi	r2,r2,65535
 d030d64:	1080200c 	andi	r2,r2,128
 d030d68:	1005003a 	cmpeq	r2,r2,zero
 d030d6c:	10002d1e 	bne	r2,zero,d030e24 <sbcompress+0x168>
 d030d70:	e0bfff17 	ldw	r2,-4(fp)
 d030d74:	10c00217 	ldw	r3,8(r2)
 d030d78:	e0bffe17 	ldw	r2,-8(fp)
 d030d7c:	10800217 	ldw	r2,8(r2)
 d030d80:	188b883a 	add	r5,r3,r2
 d030d84:	e0bfff17 	ldw	r2,-4(fp)
 d030d88:	11000517 	ldw	r4,20(r2)
 d030d8c:	e0bfff17 	ldw	r2,-4(fp)
 d030d90:	10800317 	ldw	r2,12(r2)
 d030d94:	1007883a 	mov	r3,r2
 d030d98:	e0bfff17 	ldw	r2,-4(fp)
 d030d9c:	10800417 	ldw	r2,16(r2)
 d030da0:	1885c83a 	sub	r2,r3,r2
 d030da4:	2085c83a 	sub	r2,r4,r2
 d030da8:	28801e2e 	bgeu	r5,r2,d030e24 <sbcompress+0x168>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 d030dac:	e0bfff17 	ldw	r2,-4(fp)
 d030db0:	10c00317 	ldw	r3,12(r2)
 d030db4:	e0bfff17 	ldw	r2,-4(fp)
 d030db8:	10800217 	ldw	r2,8(r2)
 d030dbc:	1887883a 	add	r3,r3,r2
 d030dc0:	e0bffe17 	ldw	r2,-8(fp)
 d030dc4:	11400317 	ldw	r5,12(r2)
 d030dc8:	e0bffe17 	ldw	r2,-8(fp)
 d030dcc:	10800217 	ldw	r2,8(r2)
 d030dd0:	1809883a 	mov	r4,r3
 d030dd4:	100d883a 	mov	r6,r2
 d030dd8:	d0027000 	call	d002700 <memcpy>
         sballoc(sb, m);
 d030ddc:	e0bffd17 	ldw	r2,-12(fp)
 d030de0:	10c00017 	ldw	r3,0(r2)
 d030de4:	e0bffe17 	ldw	r2,-8(fp)
 d030de8:	10800217 	ldw	r2,8(r2)
 d030dec:	1887883a 	add	r3,r3,r2
 d030df0:	e0bffd17 	ldw	r2,-12(fp)
 d030df4:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 d030df8:	e0bfff17 	ldw	r2,-4(fp)
 d030dfc:	10c00217 	ldw	r3,8(r2)
 d030e00:	e0bffe17 	ldw	r2,-8(fp)
 d030e04:	10800217 	ldw	r2,8(r2)
 d030e08:	1887883a 	add	r3,r3,r2
 d030e0c:	e0bfff17 	ldw	r2,-4(fp)
 d030e10:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 d030e14:	e13ffe17 	ldw	r4,-8(fp)
 d030e18:	d02a3900 	call	d02a390 <m_free>
 d030e1c:	e0bffe15 	stw	r2,-8(fp)
         continue;
 d030e20:	00001806 	br	d030e84 <sbcompress+0x1c8>
      }
      sballoc(sb, m);
 d030e24:	e0bffd17 	ldw	r2,-12(fp)
 d030e28:	10c00017 	ldw	r3,0(r2)
 d030e2c:	e0bffe17 	ldw	r2,-8(fp)
 d030e30:	10800217 	ldw	r2,8(r2)
 d030e34:	1887883a 	add	r3,r3,r2
 d030e38:	e0bffd17 	ldw	r2,-12(fp)
 d030e3c:	10c00015 	stw	r3,0(r2)
      if (n)
 d030e40:	e0bfff17 	ldw	r2,-4(fp)
 d030e44:	1005003a 	cmpeq	r2,r2,zero
 d030e48:	1000041e 	bne	r2,zero,d030e5c <sbcompress+0x1a0>
         n->m_next = m;
 d030e4c:	e0ffff17 	ldw	r3,-4(fp)
 d030e50:	e0bffe17 	ldw	r2,-8(fp)
 d030e54:	18800615 	stw	r2,24(r3)
 d030e58:	00000306 	br	d030e68 <sbcompress+0x1ac>
      else
         sb->sb_mb = m;
 d030e5c:	e0fffd17 	ldw	r3,-12(fp)
 d030e60:	e0bffe17 	ldw	r2,-8(fp)
 d030e64:	18800615 	stw	r2,24(r3)
      n = m;
 d030e68:	e0bffe17 	ldw	r2,-8(fp)
 d030e6c:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 d030e70:	e0bffe17 	ldw	r2,-8(fp)
 d030e74:	10800617 	ldw	r2,24(r2)
 d030e78:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 d030e7c:	e0bfff17 	ldw	r2,-4(fp)
 d030e80:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 d030e84:	e0bffe17 	ldw	r2,-8(fp)
 d030e88:	1004c03a 	cmpne	r2,r2,zero
 d030e8c:	103f931e 	bne	r2,zero,d030cdc <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 d030e90:	e037883a 	mov	sp,fp
 d030e94:	dfc00117 	ldw	ra,4(sp)
 d030e98:	df000017 	ldw	fp,0(sp)
 d030e9c:	dec00204 	addi	sp,sp,8
 d030ea0:	f800283a 	ret

0d030ea4 <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 d030ea4:	defffd04 	addi	sp,sp,-12
 d030ea8:	dfc00215 	stw	ra,8(sp)
 d030eac:	df000115 	stw	fp,4(sp)
 d030eb0:	df000104 	addi	fp,sp,4
 d030eb4:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 d030eb8:	d0295e80 	call	d0295e8 <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 d030ebc:	e0bfff17 	ldw	r2,-4(fp)
 d030ec0:	1080070b 	ldhu	r2,28(r2)
 d030ec4:	10bfffcc 	andi	r2,r2,65535
 d030ec8:	1080004c 	andi	r2,r2,1
 d030ecc:	10803fcc 	andi	r2,r2,255
 d030ed0:	1005003a 	cmpeq	r2,r2,zero
 d030ed4:	1000091e 	bne	r2,zero,d030efc <sbflush+0x58>
      panic("sbflush");
 d030ed8:	01034174 	movhi	r4,3333
 d030edc:	213e0604 	addi	r4,r4,-2024
 d030ee0:	d0246440 	call	d024644 <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 d030ee4:	00000506 	br	d030efc <sbflush+0x58>
      sbdrop (sb, (int)sb->sb_cc);
 d030ee8:	e0bfff17 	ldw	r2,-4(fp)
 d030eec:	10800017 	ldw	r2,0(r2)
 d030ef0:	100b883a 	mov	r5,r2
 d030ef4:	e13fff17 	ldw	r4,-4(fp)
 d030ef8:	d030f340 	call	d030f34 <sbdrop>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 d030efc:	e0bfff17 	ldw	r2,-4(fp)
 d030f00:	10800217 	ldw	r2,8(r2)
 d030f04:	1004c03a 	cmpne	r2,r2,zero
 d030f08:	103ff71e 	bne	r2,zero,d030ee8 <sbflush+0x44>
 d030f0c:	e0bfff17 	ldw	r2,-4(fp)
 d030f10:	10800017 	ldw	r2,0(r2)
 d030f14:	1004c03a 	cmpne	r2,r2,zero
 d030f18:	103ff31e 	bne	r2,zero,d030ee8 <sbflush+0x44>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 d030f1c:	d0296440 	call	d029644 <irq_Unmask>
}
 d030f20:	e037883a 	mov	sp,fp
 d030f24:	dfc00117 	ldw	ra,4(sp)
 d030f28:	df000017 	ldw	fp,0(sp)
 d030f2c:	dec00204 	addi	sp,sp,8
 d030f30:	f800283a 	ret

0d030f34 <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 d030f34:	defff904 	addi	sp,sp,-28
 d030f38:	dfc00615 	stw	ra,24(sp)
 d030f3c:	df000515 	stw	fp,20(sp)
 d030f40:	df000504 	addi	fp,sp,20
 d030f44:	e13ffe15 	stw	r4,-8(fp)
 d030f48:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 d030f4c:	d0295e80 	call	d0295e8 <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 d030f50:	e0bffe17 	ldw	r2,-8(fp)
 d030f54:	10800617 	ldw	r2,24(r2)
 d030f58:	e0bffd15 	stw	r2,-12(fp)
 d030f5c:	e0bffd17 	ldw	r2,-12(fp)
 d030f60:	1005003a 	cmpeq	r2,r2,zero
 d030f64:	1000041e 	bne	r2,zero,d030f78 <sbdrop+0x44>
      next = m->m_act;
 d030f68:	e0bffd17 	ldw	r2,-12(fp)
 d030f6c:	10800717 	ldw	r2,28(r2)
 d030f70:	e0bffb15 	stw	r2,-20(fp)
 d030f74:	00003906 	br	d03105c <sbdrop+0x128>
   else
      next = NULL;
 d030f78:	e03ffb15 	stw	zero,-20(fp)
   while (len > 0) 
 d030f7c:	00003706 	br	d03105c <sbdrop+0x128>
   {
      if (m == 0) 
 d030f80:	e0bffd17 	ldw	r2,-12(fp)
 d030f84:	1004c03a 	cmpne	r2,r2,zero
 d030f88:	10000c1e 	bne	r2,zero,d030fbc <sbdrop+0x88>
      {
         if (next == 0)
 d030f8c:	e0bffb17 	ldw	r2,-20(fp)
 d030f90:	1004c03a 	cmpne	r2,r2,zero
 d030f94:	1000031e 	bne	r2,zero,d030fa4 <sbdrop+0x70>
            panic("sbdrop");
 d030f98:	01034174 	movhi	r4,3333
 d030f9c:	213e0804 	addi	r4,r4,-2016
 d030fa0:	d0246440 	call	d024644 <panic>
         m = next;
 d030fa4:	e0bffb17 	ldw	r2,-20(fp)
 d030fa8:	e0bffd15 	stw	r2,-12(fp)
         next = m->m_act;
 d030fac:	e0bffd17 	ldw	r2,-12(fp)
 d030fb0:	10800717 	ldw	r2,28(r2)
 d030fb4:	e0bffb15 	stw	r2,-20(fp)
         continue;
 d030fb8:	00002806 	br	d03105c <sbdrop+0x128>
      }
      if (m->m_len > (unsigned)len) 
 d030fbc:	e0bffd17 	ldw	r2,-12(fp)
 d030fc0:	10c00217 	ldw	r3,8(r2)
 d030fc4:	e0bfff17 	ldw	r2,-4(fp)
 d030fc8:	10c0132e 	bgeu	r2,r3,d031018 <sbdrop+0xe4>
      {
         m->m_len -= len;
 d030fcc:	e0bffd17 	ldw	r2,-12(fp)
 d030fd0:	10c00217 	ldw	r3,8(r2)
 d030fd4:	e0bfff17 	ldw	r2,-4(fp)
 d030fd8:	1887c83a 	sub	r3,r3,r2
 d030fdc:	e0bffd17 	ldw	r2,-12(fp)
 d030fe0:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 d030fe4:	e0bffd17 	ldw	r2,-12(fp)
 d030fe8:	10c00317 	ldw	r3,12(r2)
 d030fec:	e0bfff17 	ldw	r2,-4(fp)
 d030ff0:	1887883a 	add	r3,r3,r2
 d030ff4:	e0bffd17 	ldw	r2,-12(fp)
 d030ff8:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 d030ffc:	e0bffe17 	ldw	r2,-8(fp)
 d031000:	10c00017 	ldw	r3,0(r2)
 d031004:	e0bfff17 	ldw	r2,-4(fp)
 d031008:	1887c83a 	sub	r3,r3,r2
 d03100c:	e0bffe17 	ldw	r2,-8(fp)
 d031010:	10c00015 	stw	r3,0(r2)
         break;
 d031014:	00002106 	br	d03109c <sbdrop+0x168>
      }
      len -= m->m_len;
 d031018:	e0ffff17 	ldw	r3,-4(fp)
 d03101c:	e0bffd17 	ldw	r2,-12(fp)
 d031020:	10800217 	ldw	r2,8(r2)
 d031024:	1885c83a 	sub	r2,r3,r2
 d031028:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 d03102c:	e0bffe17 	ldw	r2,-8(fp)
 d031030:	10c00017 	ldw	r3,0(r2)
 d031034:	e0bffd17 	ldw	r2,-12(fp)
 d031038:	10800217 	ldw	r2,8(r2)
 d03103c:	1887c83a 	sub	r3,r3,r2
 d031040:	e0bffe17 	ldw	r2,-8(fp)
 d031044:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 d031048:	e13ffd17 	ldw	r4,-12(fp)
 d03104c:	d02a3900 	call	d02a390 <m_free>
 d031050:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 d031054:	e0bffc17 	ldw	r2,-16(fp)
 d031058:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 d03105c:	e0bfff17 	ldw	r2,-4(fp)
 d031060:	10800048 	cmpgei	r2,r2,1
 d031064:	103fc61e 	bne	r2,zero,d030f80 <sbdrop+0x4c>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 d031068:	00000c06 	br	d03109c <sbdrop+0x168>
   {
      sbfree(sb, m);
 d03106c:	e0bffe17 	ldw	r2,-8(fp)
 d031070:	10c00017 	ldw	r3,0(r2)
 d031074:	e0bffd17 	ldw	r2,-12(fp)
 d031078:	10800217 	ldw	r2,8(r2)
 d03107c:	1887c83a 	sub	r3,r3,r2
 d031080:	e0bffe17 	ldw	r2,-8(fp)
 d031084:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 d031088:	e13ffd17 	ldw	r4,-12(fp)
 d03108c:	d02a3900 	call	d02a390 <m_free>
 d031090:	e0bffc15 	stw	r2,-16(fp)
      m = mn;
 d031094:	e0bffc17 	ldw	r2,-16(fp)
 d031098:	e0bffd15 	stw	r2,-12(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 d03109c:	e0bffd17 	ldw	r2,-12(fp)
 d0310a0:	1005003a 	cmpeq	r2,r2,zero
 d0310a4:	1000041e 	bne	r2,zero,d0310b8 <sbdrop+0x184>
 d0310a8:	e0bffd17 	ldw	r2,-12(fp)
 d0310ac:	10800217 	ldw	r2,8(r2)
 d0310b0:	1005003a 	cmpeq	r2,r2,zero
 d0310b4:	103fed1e 	bne	r2,zero,d03106c <sbdrop+0x138>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 d0310b8:	e0bffd17 	ldw	r2,-12(fp)
 d0310bc:	1005003a 	cmpeq	r2,r2,zero
 d0310c0:	1000071e 	bne	r2,zero,d0310e0 <sbdrop+0x1ac>
   {
      sb->sb_mb = m;
 d0310c4:	e0fffe17 	ldw	r3,-8(fp)
 d0310c8:	e0bffd17 	ldw	r2,-12(fp)
 d0310cc:	18800615 	stw	r2,24(r3)
      m->m_act = next;
 d0310d0:	e0fffd17 	ldw	r3,-12(fp)
 d0310d4:	e0bffb17 	ldw	r2,-20(fp)
 d0310d8:	18800715 	stw	r2,28(r3)
 d0310dc:	00000306 	br	d0310ec <sbdrop+0x1b8>
   } else
      sb->sb_mb = next;
 d0310e0:	e0fffe17 	ldw	r3,-8(fp)
 d0310e4:	e0bffb17 	ldw	r2,-20(fp)
 d0310e8:	18800615 	stw	r2,24(r3)
   EXIT_CRIT_SECTION(sb);
 d0310ec:	d0296440 	call	d029644 <irq_Unmask>
}
 d0310f0:	e037883a 	mov	sp,fp
 d0310f4:	dfc00117 	ldw	ra,4(sp)
 d0310f8:	df000017 	ldw	fp,0(sp)
 d0310fc:	dec00204 	addi	sp,sp,8
 d031100:	f800283a 	ret

0d031104 <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 d031104:	defff904 	addi	sp,sp,-28
 d031108:	dfc00615 	stw	ra,24(sp)
 d03110c:	df000515 	stw	fp,20(sp)
 d031110:	df000504 	addi	fp,sp,20
 d031114:	e13ffe15 	stw	r4,-8(fp)
 d031118:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 d03111c:	d0295e80 	call	d0295e8 <irq_Mask>
   len = mbuf_len(m);
 d031120:	e13fff17 	ldw	r4,-4(fp)
 d031124:	d02a9fc0 	call	d02a9fc <mbuf_len>
 d031128:	e0bffb15 	stw	r2,-20(fp)
   if (len > 0)
 d03112c:	e0bffb17 	ldw	r2,-20(fp)
 d031130:	10800050 	cmplti	r2,r2,1
 d031134:	1000051e 	bne	r2,zero,d03114c <sbdropend+0x48>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 d031138:	e0bffe17 	ldw	r2,-8(fp)
 d03113c:	11000617 	ldw	r4,24(r2)
 d031140:	e0bffb17 	ldw	r2,-20(fp)
 d031144:	008bc83a 	sub	r5,zero,r2
 d031148:	d02a82c0 	call	d02a82c <m_adj>
   nmb = sb->sb_mb;
 d03114c:	e0bffe17 	ldw	r2,-8(fp)
 d031150:	10800617 	ldw	r2,24(r2)
 d031154:	e0bffd15 	stw	r2,-12(fp)
   pmb = NULL;
 d031158:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 d03115c:	e0bffe17 	ldw	r2,-8(fp)
 d031160:	10800617 	ldw	r2,24(r2)
 d031164:	10800217 	ldw	r2,8(r2)
 d031168:	1004c03a 	cmpne	r2,r2,zero
 d03116c:	1000081e 	bne	r2,zero,d031190 <sbdropend+0x8c>
      sb->sb_mb = NULL;
 d031170:	e0bffe17 	ldw	r2,-8(fp)
 d031174:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 d031178:	00000506 	br	d031190 <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 d03117c:	e0bffd17 	ldw	r2,-12(fp)
 d031180:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 d031184:	e0bffd17 	ldw	r2,-12(fp)
 d031188:	10800617 	ldw	r2,24(r2)
 d03118c:	e0bffd15 	stw	r2,-12(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 d031190:	e0bffd17 	ldw	r2,-12(fp)
 d031194:	1005003a 	cmpeq	r2,r2,zero
 d031198:	1000041e 	bne	r2,zero,d0311ac <sbdropend+0xa8>
 d03119c:	e0bffd17 	ldw	r2,-12(fp)
 d0311a0:	10800217 	ldw	r2,8(r2)
 d0311a4:	1004c03a 	cmpne	r2,r2,zero
 d0311a8:	103ff41e 	bne	r2,zero,d03117c <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 d0311ac:	e0bffd17 	ldw	r2,-12(fp)
 d0311b0:	1005003a 	cmpeq	r2,r2,zero
 d0311b4:	10000b1e 	bne	r2,zero,d0311e4 <sbdropend+0xe0>
 d0311b8:	e0bffd17 	ldw	r2,-12(fp)
 d0311bc:	10800217 	ldw	r2,8(r2)
 d0311c0:	1004c03a 	cmpne	r2,r2,zero
 d0311c4:	1000071e 	bne	r2,zero,d0311e4 <sbdropend+0xe0>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 d0311c8:	e0bffc17 	ldw	r2,-16(fp)
 d0311cc:	1005003a 	cmpeq	r2,r2,zero
 d0311d0:	1000021e 	bne	r2,zero,d0311dc <sbdropend+0xd8>
         pmb->m_next = NULL;
 d0311d4:	e0bffc17 	ldw	r2,-16(fp)
 d0311d8:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 d0311dc:	e13ffd17 	ldw	r4,-12(fp)
 d0311e0:	d02a4c40 	call	d02a4c4 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 d0311e4:	e0bffe17 	ldw	r2,-8(fp)
 d0311e8:	10c00017 	ldw	r3,0(r2)
 d0311ec:	e0bffb17 	ldw	r2,-20(fp)
 d0311f0:	1887c83a 	sub	r3,r3,r2
 d0311f4:	e0bffe17 	ldw	r2,-8(fp)
 d0311f8:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 d0311fc:	d0296440 	call	d029644 <irq_Unmask>
}
 d031200:	e037883a 	mov	sp,fp
 d031204:	dfc00117 	ldw	ra,4(sp)
 d031208:	df000017 	ldw	fp,0(sp)
 d03120c:	dec00204 	addi	sp,sp,8
 d031210:	f800283a 	ret

0d031214 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 d031214:	defffb04 	addi	sp,sp,-20
 d031218:	dfc00415 	stw	ra,16(sp)
 d03121c:	df000315 	stw	fp,12(sp)
 d031220:	df000304 	addi	fp,sp,12
 d031224:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 d031228:	d0295e80 	call	d0295e8 <irq_Mask>
   m = sb->sb_mb;
 d03122c:	e0bfff17 	ldw	r2,-4(fp)
 d031230:	10800617 	ldw	r2,24(r2)
 d031234:	e0bffe15 	stw	r2,-8(fp)
   if (m)
 d031238:	e0bffe17 	ldw	r2,-8(fp)
 d03123c:	1005003a 	cmpeq	r2,r2,zero
 d031240:	1000131e 	bne	r2,zero,d031290 <sbdroprecord+0x7c>
   {  sb->sb_mb = m->m_act;
 d031244:	e0bffe17 	ldw	r2,-8(fp)
 d031248:	10c00717 	ldw	r3,28(r2)
 d03124c:	e0bfff17 	ldw	r2,-4(fp)
 d031250:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 d031254:	e0bfff17 	ldw	r2,-4(fp)
 d031258:	10c00017 	ldw	r3,0(r2)
 d03125c:	e0bffe17 	ldw	r2,-8(fp)
 d031260:	10800217 	ldw	r2,8(r2)
 d031264:	1887c83a 	sub	r3,r3,r2
 d031268:	e0bfff17 	ldw	r2,-4(fp)
 d03126c:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 d031270:	e13ffe17 	ldw	r4,-8(fp)
 d031274:	d02a3900 	call	d02a390 <m_free>
 d031278:	e0bffd15 	stw	r2,-12(fp)
      } while ((m = mn) != NULL);
 d03127c:	e0bffd17 	ldw	r2,-12(fp)
 d031280:	e0bffe15 	stw	r2,-8(fp)
 d031284:	e0bffe17 	ldw	r2,-8(fp)
 d031288:	1004c03a 	cmpne	r2,r2,zero
 d03128c:	103ff11e 	bne	r2,zero,d031254 <sbdroprecord+0x40>
         }
   EXIT_CRIT_SECTION(sb);
 d031290:	d0296440 	call	d029644 <irq_Unmask>
}
 d031294:	e037883a 	mov	sp,fp
 d031298:	dfc00117 	ldw	ra,4(sp)
 d03129c:	df000017 	ldw	fp,0(sp)
 d0312a0:	dec00204 	addi	sp,sp,8
 d0312a4:	f800283a 	ret

0d0312a8 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 d0312a8:	defe7204 	addi	sp,sp,-1592
 d0312ac:	dfc18d15 	stw	ra,1588(sp)
 d0312b0:	df018c15 	stw	fp,1584(sp)
 d0312b4:	df018c04 	addi	fp,sp,1584
 d0312b8:	e13ffc15 	stw	r4,-16(fp)
 d0312bc:	e17ffd15 	stw	r5,-12(fp)
 d0312c0:	e1bffe15 	stw	r6,-8(fp)
 d0312c4:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 d0312c8:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 d0312cc:	e0be7604 	addi	r2,fp,-1576
 d0312d0:	1009883a 	mov	r4,r2
 d0312d4:	0180c304 	movi	r6,780
 d0312d8:	000b883a 	mov	r5,zero
 d0312dc:	d0028800 	call	d002880 <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 d0312e0:	e0bf3904 	addi	r2,fp,-796
 d0312e4:	1009883a 	mov	r4,r2
 d0312e8:	0180c304 	movi	r6,780
 d0312ec:	000b883a 	mov	r5,zero
 d0312f0:	d0028800 	call	d002880 <memset>

   if (in)
 d0312f4:	e0bffc17 	ldw	r2,-16(fp)
 d0312f8:	1005003a 	cmpeq	r2,r2,zero
 d0312fc:	1000061e 	bne	r2,zero,d031318 <t_select+0x70>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 d031300:	e0bf3904 	addi	r2,fp,-796
 d031304:	e0fffc17 	ldw	r3,-16(fp)
 d031308:	1009883a 	mov	r4,r2
 d03130c:	180b883a 	mov	r5,r3
 d031310:	01804104 	movi	r6,260
 d031314:	d0027000 	call	d002700 <memcpy>
   if (out)
 d031318:	e0bffd17 	ldw	r2,-12(fp)
 d03131c:	1005003a 	cmpeq	r2,r2,zero
 d031320:	1000071e 	bne	r2,zero,d031340 <t_select+0x98>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 d031324:	e0bf3904 	addi	r2,fp,-796
 d031328:	10804104 	addi	r2,r2,260
 d03132c:	e0fffd17 	ldw	r3,-12(fp)
 d031330:	1009883a 	mov	r4,r2
 d031334:	180b883a 	mov	r5,r3
 d031338:	01804104 	movi	r6,260
 d03133c:	d0027000 	call	d002700 <memcpy>
   if (ex)
 d031340:	e0bffe17 	ldw	r2,-8(fp)
 d031344:	1005003a 	cmpeq	r2,r2,zero
 d031348:	1000071e 	bne	r2,zero,d031368 <t_select+0xc0>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 d03134c:	e0bf3904 	addi	r2,fp,-796
 d031350:	10808204 	addi	r2,r2,520
 d031354:	e0fffe17 	ldw	r3,-8(fp)
 d031358:	1009883a 	mov	r4,r2
 d03135c:	180b883a 	mov	r5,r3
 d031360:	01804104 	movi	r6,260
 d031364:	d0027000 	call	d002700 <memcpy>
   tmo = cticks + tv;
 d031368:	00834174 	movhi	r2,3333
 d03136c:	108ac904 	addi	r2,r2,11044
 d031370:	10c00017 	ldw	r3,0(r2)
 d031374:	e0bfff17 	ldw	r2,-4(fp)
 d031378:	1885883a 	add	r2,r3,r2
 d03137c:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 d031380:	e0bf3917 	ldw	r2,-796(fp)
 d031384:	1004c03a 	cmpne	r2,r2,zero
 d031388:	10000e1e 	bne	r2,zero,d0313c4 <t_select+0x11c>
 d03138c:	e0bf7a17 	ldw	r2,-536(fp)
 d031390:	1004c03a 	cmpne	r2,r2,zero
 d031394:	10000b1e 	bne	r2,zero,d0313c4 <t_select+0x11c>
 d031398:	e0bfbb17 	ldw	r2,-276(fp)
 d03139c:	1004c03a 	cmpne	r2,r2,zero
 d0313a0:	1000081e 	bne	r2,zero,d0313c4 <t_select+0x11c>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 d0313a4:	e0bfff17 	ldw	r2,-4(fp)
 d0313a8:	10800050 	cmplti	r2,r2,1
 d0313ac:	1000201e 	bne	r2,zero,d031430 <t_select+0x188>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 d0313b0:	e0bfff17 	ldw	r2,-4(fp)
 d0313b4:	10800044 	addi	r2,r2,1
 d0313b8:	113fffcc 	andi	r4,r2,65535
 d0313bc:	d0153e80 	call	d0153e8 <OSTimeDly>
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 d0313c0:	00001b06 	br	d031430 <t_select+0x188>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 d0313c4:	0009883a 	mov	r4,zero
 d0313c8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 d0313cc:	00000f06 	br	d03140c <t_select+0x164>
      {
         if (tv != -1L) 
 d0313d0:	e0bfff17 	ldw	r2,-4(fp)
 d0313d4:	10bfffe0 	cmpeqi	r2,r2,-1
 d0313d8:	1000051e 	bne	r2,zero,d0313f0 <t_select+0x148>
         {
            if (tmo <= cticks)
 d0313dc:	00834174 	movhi	r2,3333
 d0313e0:	108ac904 	addi	r2,r2,11044
 d0313e4:	10c00017 	ldw	r3,0(r2)
 d0313e8:	e0be7517 	ldw	r2,-1580(fp)
 d0313ec:	18800e2e 	bgeu	r3,r2,d031428 <t_select+0x180>
               break;
         }
         select_wait = 1;
 d0313f0:	00c34174 	movhi	r3,3333
 d0313f4:	18cad104 	addi	r3,r3,11076
 d0313f8:	00800044 	movi	r2,1
 d0313fc:	1880000d 	sth	r2,0(r3)
         tcp_sleep (&select_wait);
 d031400:	01034174 	movhi	r4,3333
 d031404:	210ad104 	addi	r4,r4,11076
 d031408:	d024fbc0 	call	d024fbc <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 d03140c:	e13f3904 	addi	r4,fp,-796
 d031410:	e17e7604 	addi	r5,fp,-1576
 d031414:	d0314c80 	call	d0314c8 <sock_selscan>
 d031418:	e0be7415 	stw	r2,-1584(fp)
 d03141c:	e0be7417 	ldw	r2,-1584(fp)
 d031420:	1005003a 	cmpeq	r2,r2,zero
 d031424:	103fea1e 	bne	r2,zero,d0313d0 <t_select+0x128>
               break;
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 d031428:	0009883a 	mov	r4,zero
 d03142c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 d031430:	e0be7417 	ldw	r2,-1584(fp)
 d031434:	1004803a 	cmplt	r2,r2,zero
 d031438:	10001d1e 	bne	r2,zero,d0314b0 <t_select+0x208>
   {
      if (in)
 d03143c:	e0bffc17 	ldw	r2,-16(fp)
 d031440:	1005003a 	cmpeq	r2,r2,zero
 d031444:	1000061e 	bne	r2,zero,d031460 <t_select+0x1b8>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 d031448:	e0bffc17 	ldw	r2,-16(fp)
 d03144c:	e0fe7604 	addi	r3,fp,-1576
 d031450:	1009883a 	mov	r4,r2
 d031454:	180b883a 	mov	r5,r3
 d031458:	01804104 	movi	r6,260
 d03145c:	d0027000 	call	d002700 <memcpy>
      if (out)
 d031460:	e0bffd17 	ldw	r2,-12(fp)
 d031464:	1005003a 	cmpeq	r2,r2,zero
 d031468:	1000071e 	bne	r2,zero,d031488 <t_select+0x1e0>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 d03146c:	e0be7604 	addi	r2,fp,-1576
 d031470:	10c04104 	addi	r3,r2,260
 d031474:	e0bffd17 	ldw	r2,-12(fp)
 d031478:	1009883a 	mov	r4,r2
 d03147c:	180b883a 	mov	r5,r3
 d031480:	01804104 	movi	r6,260
 d031484:	d0027000 	call	d002700 <memcpy>
      if (ex)
 d031488:	e0bffe17 	ldw	r2,-8(fp)
 d03148c:	1005003a 	cmpeq	r2,r2,zero
 d031490:	1000071e 	bne	r2,zero,d0314b0 <t_select+0x208>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 d031494:	e0be7604 	addi	r2,fp,-1576
 d031498:	10c08204 	addi	r3,r2,520
 d03149c:	e0bffe17 	ldw	r2,-8(fp)
 d0314a0:	1009883a 	mov	r4,r2
 d0314a4:	180b883a 	mov	r5,r3
 d0314a8:	01804104 	movi	r6,260
 d0314ac:	d0027000 	call	d002700 <memcpy>
   }
   return retval;
 d0314b0:	e0be7417 	ldw	r2,-1584(fp)
}
 d0314b4:	e037883a 	mov	sp,fp
 d0314b8:	dfc00117 	ldw	ra,4(sp)
 d0314bc:	df000017 	ldw	fp,0(sp)
 d0314c0:	dec00204 	addi	sp,sp,8
 d0314c4:	f800283a 	ret

0d0314c8 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 d0314c8:	defff504 	addi	sp,sp,-44
 d0314cc:	dfc00a15 	stw	ra,40(sp)
 d0314d0:	df000915 	stw	fp,36(sp)
 d0314d4:	df000904 	addi	fp,sp,36
 d0314d8:	e13ffd15 	stw	r4,-12(fp)
 d0314dc:	e17ffe15 	stw	r5,-8(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 d0314e0:	e03ff815 	stw	zero,-32(fp)
   int   num_sel  =  0;
 d0314e4:	e03ff715 	stw	zero,-36(fp)

   for (which = 0; which < 3; which++)
 d0314e8:	e03ffa15 	stw	zero,-24(fp)
 d0314ec:	00004306 	br	d0315fc <sock_selscan+0x134>
   {
      switch (which)
 d0314f0:	e0bffa17 	ldw	r2,-24(fp)
 d0314f4:	e0bfff15 	stw	r2,-4(fp)
 d0314f8:	e0ffff17 	ldw	r3,-4(fp)
 d0314fc:	18800060 	cmpeqi	r2,r3,1
 d031500:	10000a1e 	bne	r2,zero,d03152c <sock_selscan+0x64>
 d031504:	e0ffff17 	ldw	r3,-4(fp)
 d031508:	188000a0 	cmpeqi	r2,r3,2
 d03150c:	10000a1e 	bne	r2,zero,d031538 <sock_selscan+0x70>
 d031510:	e0ffff17 	ldw	r3,-4(fp)
 d031514:	1805003a 	cmpeq	r2,r3,zero
 d031518:	1000011e 	bne	r2,zero,d031520 <sock_selscan+0x58>
 d03151c:	00000706 	br	d03153c <sock_selscan+0x74>
      {
      case 0:
         flag = SOREAD; break;
 d031520:	00800044 	movi	r2,1
 d031524:	e0bff815 	stw	r2,-32(fp)
 d031528:	00000406 	br	d03153c <sock_selscan+0x74>

      case 1:
         flag = SOWRITE; break;
 d03152c:	00800084 	movi	r2,2
 d031530:	e0bff815 	stw	r2,-32(fp)
 d031534:	00000106 	br	d03153c <sock_selscan+0x74>

      case 2:
         flag = 0; break;
 d031538:	e03ff815 	stw	zero,-32(fp)
      }
      in = &ibits [which];
 d03153c:	e0bffa17 	ldw	r2,-24(fp)
 d031540:	10804124 	muli	r2,r2,260
 d031544:	1007883a 	mov	r3,r2
 d031548:	e0bffd17 	ldw	r2,-12(fp)
 d03154c:	1885883a 	add	r2,r3,r2
 d031550:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 d031554:	e0bffa17 	ldw	r2,-24(fp)
 d031558:	10804124 	muli	r2,r2,260
 d03155c:	1007883a 	mov	r3,r2
 d031560:	e0bffe17 	ldw	r2,-8(fp)
 d031564:	1885883a 	add	r2,r3,r2
 d031568:	e0bffb15 	stw	r2,-20(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 d03156c:	e03ff915 	stw	zero,-28(fp)
 d031570:	00001a06 	br	d0315dc <sock_selscan+0x114>
      {
         if (sock_select (in->fd_array[sock], flag))
 d031574:	e0bff917 	ldw	r2,-28(fp)
 d031578:	e0fffc17 	ldw	r3,-16(fp)
 d03157c:	1085883a 	add	r2,r2,r2
 d031580:	1085883a 	add	r2,r2,r2
 d031584:	10c5883a 	add	r2,r2,r3
 d031588:	10800104 	addi	r2,r2,4
 d03158c:	11000017 	ldw	r4,0(r2)
 d031590:	e17ff817 	ldw	r5,-32(fp)
 d031594:	d0316200 	call	d031620 <sock_select>
 d031598:	1005003a 	cmpeq	r2,r2,zero
 d03159c:	10000c1e 	bne	r2,zero,d0315d0 <sock_selscan+0x108>
         {
            FD_SET(in->fd_array[sock], out);
 d0315a0:	e0bff917 	ldw	r2,-28(fp)
 d0315a4:	e0fffc17 	ldw	r3,-16(fp)
 d0315a8:	1085883a 	add	r2,r2,r2
 d0315ac:	1085883a 	add	r2,r2,r2
 d0315b0:	10c5883a 	add	r2,r2,r3
 d0315b4:	10800104 	addi	r2,r2,4
 d0315b8:	11000017 	ldw	r4,0(r2)
 d0315bc:	e17ffb17 	ldw	r5,-20(fp)
 d0315c0:	d031a580 	call	d031a58 <ifd_set>
            num_sel++;
 d0315c4:	e0bff717 	ldw	r2,-36(fp)
 d0315c8:	10800044 	addi	r2,r2,1
 d0315cc:	e0bff715 	stw	r2,-36(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 d0315d0:	e0bff917 	ldw	r2,-28(fp)
 d0315d4:	10800044 	addi	r2,r2,1
 d0315d8:	e0bff915 	stw	r2,-28(fp)
 d0315dc:	e0bffc17 	ldw	r2,-16(fp)
 d0315e0:	10800017 	ldw	r2,0(r2)
 d0315e4:	1007883a 	mov	r3,r2
 d0315e8:	e0bff917 	ldw	r2,-28(fp)
 d0315ec:	10ffe116 	blt	r2,r3,d031574 <sock_selscan+0xac>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 d0315f0:	e0bffa17 	ldw	r2,-24(fp)
 d0315f4:	10800044 	addi	r2,r2,1
 d0315f8:	e0bffa15 	stw	r2,-24(fp)
 d0315fc:	e0bffa17 	ldw	r2,-24(fp)
 d031600:	108000d0 	cmplti	r2,r2,3
 d031604:	103fba1e 	bne	r2,zero,d0314f0 <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 d031608:	e0bff717 	ldw	r2,-36(fp)
}
 d03160c:	e037883a 	mov	sp,fp
 d031610:	dfc00117 	ldw	ra,4(sp)
 d031614:	df000017 	ldw	fp,0(sp)
 d031618:	dec00204 	addi	sp,sp,8
 d03161c:	f800283a 	ret

0d031620 <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 d031620:	defff904 	addi	sp,sp,-28
 d031624:	dfc00615 	stw	ra,24(sp)
 d031628:	df000515 	stw	fp,20(sp)
 d03162c:	df000504 	addi	fp,sp,20
 d031630:	e13ffd15 	stw	r4,-12(fp)
 d031634:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so;
   int   ready =  0;
 d031638:	e03ffb15 	stw	zero,-20(fp)

   so = LONG2SO(sock);
 d03163c:	e0bffd17 	ldw	r2,-12(fp)
 d031640:	10bff804 	addi	r2,r2,-32
 d031644:	1085883a 	add	r2,r2,r2
 d031648:	1085883a 	add	r2,r2,r2
 d03164c:	e0bffc15 	stw	r2,-16(fp)

   switch (flag) 
 d031650:	e0bffe17 	ldw	r2,-8(fp)
 d031654:	e0bfff15 	stw	r2,-4(fp)
 d031658:	e0ffff17 	ldw	r3,-4(fp)
 d03165c:	18800060 	cmpeqi	r2,r3,1
 d031660:	1000071e 	bne	r2,zero,d031680 <sock_select+0x60>
 d031664:	e0ffff17 	ldw	r3,-4(fp)
 d031668:	188000a0 	cmpeqi	r2,r3,2
 d03166c:	1000251e 	bne	r2,zero,d031704 <sock_select+0xe4>
 d031670:	e0ffff17 	ldw	r3,-4(fp)
 d031674:	1805003a 	cmpeq	r2,r3,zero
 d031678:	1000491e 	bne	r2,zero,d0317a0 <sock_select+0x180>
 d03167c:	00006706 	br	d03181c <sock_select+0x1fc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 d031680:	e0bffc17 	ldw	r2,-16(fp)
 d031684:	10800a17 	ldw	r2,40(r2)
 d031688:	1005003a 	cmpeq	r2,r2,zero
 d03168c:	1000031e 	bne	r2,zero,d03169c <sock_select+0x7c>
      {
         ready = 1;
 d031690:	00800044 	movi	r2,1
 d031694:	e0bffb15 	stw	r2,-20(fp)
         break;
 d031698:	00006006 	br	d03181c <sock_select+0x1fc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 d03169c:	e0bffc17 	ldw	r2,-16(fp)
 d0316a0:	1080088b 	ldhu	r2,34(r2)
 d0316a4:	10bfffcc 	andi	r2,r2,65535
 d0316a8:	1080080c 	andi	r2,r2,32
 d0316ac:	1005003a 	cmpeq	r2,r2,zero
 d0316b0:	1000031e 	bne	r2,zero,d0316c0 <sock_select+0xa0>
      {  ready = 1;
 d0316b4:	00800044 	movi	r2,1
 d0316b8:	e0bffb15 	stw	r2,-20(fp)
         break;
 d0316bc:	00005706 	br	d03181c <sock_select+0x1fc>
      }
      if (so->so_qlen)  /* attach is ready */
 d0316c0:	e0bffc17 	ldw	r2,-16(fp)
 d0316c4:	10801e43 	ldbu	r2,121(r2)
 d0316c8:	10803fcc 	andi	r2,r2,255
 d0316cc:	1080201c 	xori	r2,r2,128
 d0316d0:	10bfe004 	addi	r2,r2,-128
 d0316d4:	1005003a 	cmpeq	r2,r2,zero
 d0316d8:	1000031e 	bne	r2,zero,d0316e8 <sock_select+0xc8>
      {
         ready = 1;
 d0316dc:	00800044 	movi	r2,1
 d0316e0:	e0bffb15 	stw	r2,-20(fp)
         break;
 d0316e4:	00004d06 	br	d03181c <sock_select+0x1fc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 d0316e8:	e0bffc17 	ldw	r2,-16(fp)
 d0316ec:	1080110b 	ldhu	r2,68(r2)
 d0316f0:	10800214 	ori	r2,r2,8
 d0316f4:	1007883a 	mov	r3,r2
 d0316f8:	e0bffc17 	ldw	r2,-16(fp)
 d0316fc:	10c0110d 	sth	r3,68(r2)
      break;
 d031700:	00004606 	br	d03181c <sock_select+0x1fc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 d031704:	e0bffc17 	ldw	r2,-16(fp)
 d031708:	10801317 	ldw	r2,76(r2)
 d03170c:	1007883a 	mov	r3,r2
 d031710:	e0bffc17 	ldw	r2,-16(fp)
 d031714:	10801217 	ldw	r2,72(r2)
 d031718:	1885c83a 	sub	r2,r3,r2
 d03171c:	1004803a 	cmplt	r2,r2,zero
 d031720:	10001b1e 	bne	r2,zero,d031790 <sock_select+0x170>
 d031724:	e0bffc17 	ldw	r2,-16(fp)
 d031728:	10c01317 	ldw	r3,76(r2)
 d03172c:	e0bffc17 	ldw	r2,-16(fp)
 d031730:	10801217 	ldw	r2,72(r2)
 d031734:	18801626 	beq	r3,r2,d031790 <sock_select+0x170>
 d031738:	e0bffc17 	ldw	r2,-16(fp)
 d03173c:	1080088b 	ldhu	r2,34(r2)
 d031740:	10bfffcc 	andi	r2,r2,65535
 d031744:	1080008c 	andi	r2,r2,2
 d031748:	1004c03a 	cmpne	r2,r2,zero
 d03174c:	10000d1e 	bne	r2,zero,d031784 <sock_select+0x164>
 d031750:	e0bffc17 	ldw	r2,-16(fp)
 d031754:	10800217 	ldw	r2,8(r2)
 d031758:	1080010b 	ldhu	r2,4(r2)
 d03175c:	10bfffcc 	andi	r2,r2,65535
 d031760:	1080010c 	andi	r2,r2,4
 d031764:	1005003a 	cmpeq	r2,r2,zero
 d031768:	1000061e 	bne	r2,zero,d031784 <sock_select+0x164>
 d03176c:	e0bffc17 	ldw	r2,-16(fp)
 d031770:	1080088b 	ldhu	r2,34(r2)
 d031774:	10bfffcc 	andi	r2,r2,65535
 d031778:	1080040c 	andi	r2,r2,16
 d03177c:	1005003a 	cmpeq	r2,r2,zero
 d031780:	1000031e 	bne	r2,zero,d031790 <sock_select+0x170>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 d031784:	00800044 	movi	r2,1
 d031788:	e0bffb15 	stw	r2,-20(fp)
         break;
 d03178c:	00002306 	br	d03181c <sock_select+0x1fc>
      }
      sbselqueue (&so->so_snd);
 d031790:	e0bffc17 	ldw	r2,-16(fp)
 d031794:	11001204 	addi	r4,r2,72
 d031798:	d0306c80 	call	d0306c8 <sbselqueue>
      break;
 d03179c:	00001f06 	br	d03181c <sock_select+0x1fc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 d0317a0:	e0bffc17 	ldw	r2,-16(fp)
 d0317a4:	10801a17 	ldw	r2,104(r2)
 d0317a8:	1004c03a 	cmpne	r2,r2,zero
 d0317ac:	1000061e 	bne	r2,zero,d0317c8 <sock_select+0x1a8>
 d0317b0:	e0bffc17 	ldw	r2,-16(fp)
 d0317b4:	1080088b 	ldhu	r2,34(r2)
 d0317b8:	10bfffcc 	andi	r2,r2,65535
 d0317bc:	1080100c 	andi	r2,r2,64
 d0317c0:	1005003a 	cmpeq	r2,r2,zero
 d0317c4:	1000031e 	bne	r2,zero,d0317d4 <sock_select+0x1b4>
      {
         ready = 1;
 d0317c8:	00800044 	movi	r2,1
 d0317cc:	e0bffb15 	stw	r2,-20(fp)
         break;
 d0317d0:	00001206 	br	d03181c <sock_select+0x1fc>
      }
      if (so->so_error &&
 d0317d4:	e0bffc17 	ldw	r2,-16(fp)
 d0317d8:	10800617 	ldw	r2,24(r2)
 d0317dc:	1005003a 	cmpeq	r2,r2,zero
 d0317e0:	10000b1e 	bne	r2,zero,d031810 <sock_select+0x1f0>
 d0317e4:	e0bffc17 	ldw	r2,-16(fp)
 d0317e8:	10800617 	ldw	r2,24(r2)
 d0317ec:	10801de0 	cmpeqi	r2,r2,119
 d0317f0:	1000071e 	bne	r2,zero,d031810 <sock_select+0x1f0>
 d0317f4:	e0bffc17 	ldw	r2,-16(fp)
 d0317f8:	10800617 	ldw	r2,24(r2)
 d0317fc:	108002e0 	cmpeqi	r2,r2,11
 d031800:	1000031e 	bne	r2,zero,d031810 <sock_select+0x1f0>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 d031804:	00800044 	movi	r2,1
 d031808:	e0bffb15 	stw	r2,-20(fp)
         break;
 d03180c:	00000306 	br	d03181c <sock_select+0x1fc>
      }
      sbselqueue(&so->so_rcv);
 d031810:	e0bffc17 	ldw	r2,-16(fp)
 d031814:	11000a04 	addi	r4,r2,40
 d031818:	d0306c80 	call	d0306c8 <sbselqueue>
      break;
   }

   return ready;
 d03181c:	e0bffb17 	ldw	r2,-20(fp)
}
 d031820:	e037883a 	mov	sp,fp
 d031824:	dfc00117 	ldw	ra,4(sp)
 d031828:	df000017 	ldw	fp,0(sp)
 d03182c:	dec00204 	addi	sp,sp,8
 d031830:	f800283a 	ret

0d031834 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 d031834:	defff804 	addi	sp,sp,-32
 d031838:	dfc00715 	stw	ra,28(sp)
 d03183c:	df000615 	stw	fp,24(sp)
 d031840:	df000604 	addi	fp,sp,24
 d031844:	e13ffc15 	stw	r4,-16(fp)
 d031848:	e17ffd15 	stw	r5,-12(fp)
 d03184c:	e1bffe15 	stw	r6,-8(fp)
 d031850:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 d031854:	e0bffc17 	ldw	r2,-16(fp)
 d031858:	10800017 	ldw	r2,0(r2)
 d03185c:	e0bffb15 	stw	r2,-20(fp)
 d031860:	00001f06 	br	d0318e0 <in_pcbnotify+0xac>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 d031864:	e0bffb17 	ldw	r2,-20(fp)
 d031868:	10c00317 	ldw	r3,12(r2)
 d03186c:	e0bffd17 	ldw	r2,-12(fp)
 d031870:	10800017 	ldw	r2,0(r2)
 d031874:	1880041e 	bne	r3,r2,d031888 <in_pcbnotify+0x54>
 d031878:	e0bffb17 	ldw	r2,-20(fp)
 d03187c:	10800817 	ldw	r2,32(r2)
 d031880:	1004c03a 	cmpne	r2,r2,zero
 d031884:	1000041e 	bne	r2,zero,d031898 <in_pcbnotify+0x64>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 d031888:	e0bffb17 	ldw	r2,-20(fp)
 d03188c:	10800017 	ldw	r2,0(r2)
 d031890:	e0bffb15 	stw	r2,-20(fp)
         continue;
 d031894:	00001206 	br	d0318e0 <in_pcbnotify+0xac>
      }
      if (errnum) 
 d031898:	e0bffe17 	ldw	r2,-8(fp)
 d03189c:	1005003a 	cmpeq	r2,r2,zero
 d0318a0:	1000041e 	bne	r2,zero,d0318b4 <in_pcbnotify+0x80>
         inp->inp_socket->so_error = errnum;
 d0318a4:	e0bffb17 	ldw	r2,-20(fp)
 d0318a8:	10c00817 	ldw	r3,32(r2)
 d0318ac:	e0bffe17 	ldw	r2,-8(fp)
 d0318b0:	18800615 	stw	r2,24(r3)
      oinp = inp;
 d0318b4:	e0bffb17 	ldw	r2,-20(fp)
 d0318b8:	e0bffa15 	stw	r2,-24(fp)
      inp = inp->inp_next;
 d0318bc:	e0bffb17 	ldw	r2,-20(fp)
 d0318c0:	10800017 	ldw	r2,0(r2)
 d0318c4:	e0bffb15 	stw	r2,-20(fp)
      if (notify)
 d0318c8:	e0bfff17 	ldw	r2,-4(fp)
 d0318cc:	1005003a 	cmpeq	r2,r2,zero
 d0318d0:	1000031e 	bne	r2,zero,d0318e0 <in_pcbnotify+0xac>
         (*notify)(oinp);
 d0318d4:	e0bfff17 	ldw	r2,-4(fp)
 d0318d8:	e13ffa17 	ldw	r4,-24(fp)
 d0318dc:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 d0318e0:	e0fffb17 	ldw	r3,-20(fp)
 d0318e4:	e0bffc17 	ldw	r2,-16(fp)
 d0318e8:	18bfde1e 	bne	r3,r2,d031864 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 d0318ec:	e037883a 	mov	sp,fp
 d0318f0:	dfc00117 	ldw	ra,4(sp)
 d0318f4:	df000017 	ldw	fp,0(sp)
 d0318f8:	dec00204 	addi	sp,sp,8
 d0318fc:	f800283a 	ret

0d031900 <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 d031900:	defffd04 	addi	sp,sp,-12
 d031904:	dfc00215 	stw	ra,8(sp)
 d031908:	df000115 	stw	fp,4(sp)
 d03190c:	df000104 	addi	fp,sp,4
 d031910:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 d031914:	e0bfff17 	ldw	r2,-4(fp)
 d031918:	10800817 	ldw	r2,32(r2)
 d03191c:	11000904 	addi	r4,r2,36
 d031920:	d02515c0 	call	d02515c <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 d031924:	e0bfff17 	ldw	r2,-4(fp)
 d031928:	11000817 	ldw	r4,32(r2)
 d03192c:	e0bfff17 	ldw	r2,-4(fp)
 d031930:	10800817 	ldw	r2,32(r2)
 d031934:	11400a04 	addi	r5,r2,40
 d031938:	d0307680 	call	d030768 <sbwakeup>
   sowwakeup(inp->inp_socket);
 d03193c:	e0bfff17 	ldw	r2,-4(fp)
 d031940:	11000817 	ldw	r4,32(r2)
 d031944:	e0bfff17 	ldw	r2,-4(fp)
 d031948:	10800817 	ldw	r2,32(r2)
 d03194c:	11401204 	addi	r5,r2,72
 d031950:	d0307680 	call	d030768 <sbwakeup>
}
 d031954:	e037883a 	mov	sp,fp
 d031958:	dfc00117 	ldw	ra,4(sp)
 d03195c:	df000017 	ldw	fp,0(sp)
 d031960:	dec00204 	addi	sp,sp,8
 d031964:	f800283a 	ret

0d031968 <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 d031968:	defffb04 	addi	sp,sp,-20
 d03196c:	dfc00415 	stw	ra,16(sp)
 d031970:	df000315 	stw	fp,12(sp)
 d031974:	df000304 	addi	fp,sp,12
 d031978:	e13ffe15 	stw	r4,-8(fp)
 d03197c:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 d031980:	e03ffd15 	stw	zero,-12(fp)
 d031984:	00002a06 	br	d031a30 <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 d031988:	e0bffd17 	ldw	r2,-12(fp)
 d03198c:	e0ffff17 	ldw	r3,-4(fp)
 d031990:	1085883a 	add	r2,r2,r2
 d031994:	1085883a 	add	r2,r2,r2
 d031998:	10c5883a 	add	r2,r2,r3
 d03199c:	10800104 	addi	r2,r2,4
 d0319a0:	10c00017 	ldw	r3,0(r2)
 d0319a4:	e0bffe17 	ldw	r2,-8(fp)
 d0319a8:	18801e1e 	bne	r3,r2,d031a24 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 d0319ac:	00001206 	br	d0319f8 <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 d0319b0:	e13ffd17 	ldw	r4,-12(fp)
 d0319b4:	e0bffd17 	ldw	r2,-12(fp)
 d0319b8:	10800044 	addi	r2,r2,1
 d0319bc:	e0ffff17 	ldw	r3,-4(fp)
 d0319c0:	1085883a 	add	r2,r2,r2
 d0319c4:	1085883a 	add	r2,r2,r2
 d0319c8:	10c5883a 	add	r2,r2,r3
 d0319cc:	10800104 	addi	r2,r2,4
 d0319d0:	11400017 	ldw	r5,0(r2)
 d0319d4:	e0ffff17 	ldw	r3,-4(fp)
 d0319d8:	2105883a 	add	r2,r4,r4
 d0319dc:	1085883a 	add	r2,r2,r2
 d0319e0:	10c5883a 	add	r2,r2,r3
 d0319e4:	10800104 	addi	r2,r2,4
 d0319e8:	11400015 	stw	r5,0(r2)
            i++;
 d0319ec:	e0bffd17 	ldw	r2,-12(fp)
 d0319f0:	10800044 	addi	r2,r2,1
 d0319f4:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 d0319f8:	e0bffd17 	ldw	r2,-12(fp)
 d0319fc:	10c00044 	addi	r3,r2,1
 d031a00:	e0bfff17 	ldw	r2,-4(fp)
 d031a04:	10800017 	ldw	r2,0(r2)
 d031a08:	18bfe936 	bltu	r3,r2,d0319b0 <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 d031a0c:	e0bfff17 	ldw	r2,-4(fp)
 d031a10:	10800017 	ldw	r2,0(r2)
 d031a14:	10ffffc4 	addi	r3,r2,-1
 d031a18:	e0bfff17 	ldw	r2,-4(fp)
 d031a1c:	10c00015 	stw	r3,0(r2)
         return;
 d031a20:	00000806 	br	d031a44 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 d031a24:	e0bffd17 	ldw	r2,-12(fp)
 d031a28:	10800044 	addi	r2,r2,1
 d031a2c:	e0bffd15 	stw	r2,-12(fp)
 d031a30:	e0bfff17 	ldw	r2,-4(fp)
 d031a34:	10c00017 	ldw	r3,0(r2)
 d031a38:	e0bffd17 	ldw	r2,-12(fp)
 d031a3c:	10ffd236 	bltu	r2,r3,d031988 <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 d031a40:	d0293e80 	call	d0293e8 <dtrap>
#endif
}
 d031a44:	e037883a 	mov	sp,fp
 d031a48:	dfc00117 	ldw	ra,4(sp)
 d031a4c:	df000017 	ldw	fp,0(sp)
 d031a50:	dec00204 	addi	sp,sp,8
 d031a54:	f800283a 	ret

0d031a58 <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 d031a58:	defffc04 	addi	sp,sp,-16
 d031a5c:	dfc00315 	stw	ra,12(sp)
 d031a60:	df000215 	stw	fp,8(sp)
 d031a64:	df000204 	addi	fp,sp,8
 d031a68:	e13ffe15 	stw	r4,-8(fp)
 d031a6c:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 d031a70:	e0bfff17 	ldw	r2,-4(fp)
 d031a74:	10800017 	ldw	r2,0(r2)
 d031a78:	10801028 	cmpgeui	r2,r2,64
 d031a7c:	10000d1e 	bne	r2,zero,d031ab4 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 d031a80:	e0bfff17 	ldw	r2,-4(fp)
 d031a84:	10c00017 	ldw	r3,0(r2)
 d031a88:	e13fff17 	ldw	r4,-4(fp)
 d031a8c:	18c5883a 	add	r2,r3,r3
 d031a90:	1085883a 	add	r2,r2,r2
 d031a94:	1105883a 	add	r2,r2,r4
 d031a98:	11000104 	addi	r4,r2,4
 d031a9c:	e0bffe17 	ldw	r2,-8(fp)
 d031aa0:	20800015 	stw	r2,0(r4)
 d031aa4:	18c00044 	addi	r3,r3,1
 d031aa8:	e0bfff17 	ldw	r2,-4(fp)
 d031aac:	10c00015 	stw	r3,0(r2)
 d031ab0:	00000106 	br	d031ab8 <ifd_set+0x60>
#ifdef NPDEBUG
   else
      dtrap();
 d031ab4:	d0293e80 	call	d0293e8 <dtrap>
#endif
}
 d031ab8:	e037883a 	mov	sp,fp
 d031abc:	dfc00117 	ldw	ra,4(sp)
 d031ac0:	df000017 	ldw	fp,0(sp)
 d031ac4:	dec00204 	addi	sp,sp,8
 d031ac8:	f800283a 	ret

0d031acc <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 d031acc:	defffb04 	addi	sp,sp,-20
 d031ad0:	df000415 	stw	fp,16(sp)
 d031ad4:	df000404 	addi	fp,sp,16
 d031ad8:	e13ffd15 	stw	r4,-12(fp)
 d031adc:	e17ffe15 	stw	r5,-8(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 d031ae0:	e03ffc15 	stw	zero,-16(fp)
 d031ae4:	00000f06 	br	d031b24 <ifd_isset+0x58>
   {
      if (set->fd_array[i] == sock)
 d031ae8:	e0bffc17 	ldw	r2,-16(fp)
 d031aec:	e0fffe17 	ldw	r3,-8(fp)
 d031af0:	1085883a 	add	r2,r2,r2
 d031af4:	1085883a 	add	r2,r2,r2
 d031af8:	10c5883a 	add	r2,r2,r3
 d031afc:	10800104 	addi	r2,r2,4
 d031b00:	10c00017 	ldw	r3,0(r2)
 d031b04:	e0bffd17 	ldw	r2,-12(fp)
 d031b08:	1880031e 	bne	r3,r2,d031b18 <ifd_isset+0x4c>
         return TRUE;
 d031b0c:	00800044 	movi	r2,1
 d031b10:	e0bfff15 	stw	r2,-4(fp)
 d031b14:	00000806 	br	d031b38 <ifd_isset+0x6c>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 d031b18:	e0bffc17 	ldw	r2,-16(fp)
 d031b1c:	10800044 	addi	r2,r2,1
 d031b20:	e0bffc15 	stw	r2,-16(fp)
 d031b24:	e0bffe17 	ldw	r2,-8(fp)
 d031b28:	10c00017 	ldw	r3,0(r2)
 d031b2c:	e0bffc17 	ldw	r2,-16(fp)
 d031b30:	10ffed36 	bltu	r2,r3,d031ae8 <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 d031b34:	e03fff15 	stw	zero,-4(fp)
 d031b38:	e0bfff17 	ldw	r2,-4(fp)
}
 d031b3c:	e037883a 	mov	sp,fp
 d031b40:	df000017 	ldw	fp,0(sp)
 d031b44:	dec00104 	addi	sp,sp,4
 d031b48:	f800283a 	ret

0d031b4c <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 d031b4c:	defffb04 	addi	sp,sp,-20
 d031b50:	dfc00415 	stw	ra,16(sp)
 d031b54:	df000315 	stw	fp,12(sp)
 d031b58:	df000304 	addi	fp,sp,12
 d031b5c:	e13ffd15 	stw	r4,-12(fp)
 d031b60:	e17ffe15 	stw	r5,-8(fp)
   if (i < set->fd_count)
 d031b64:	e0bffe17 	ldw	r2,-8(fp)
 d031b68:	10c00017 	ldw	r3,0(r2)
 d031b6c:	e0bffd17 	ldw	r2,-12(fp)
 d031b70:	10c0092e 	bgeu	r2,r3,d031b98 <ifd_get+0x4c>
      return set->fd_array[i];
 d031b74:	e0bffd17 	ldw	r2,-12(fp)
 d031b78:	e0fffe17 	ldw	r3,-8(fp)
 d031b7c:	1085883a 	add	r2,r2,r2
 d031b80:	1085883a 	add	r2,r2,r2
 d031b84:	10c5883a 	add	r2,r2,r3
 d031b88:	10800104 	addi	r2,r2,4
 d031b8c:	10800017 	ldw	r2,0(r2)
 d031b90:	e0bfff15 	stw	r2,-4(fp)
 d031b94:	00000306 	br	d031ba4 <ifd_get+0x58>
   else
   {
#ifdef NPDEBUG
      dtrap();
 d031b98:	d0293e80 	call	d0293e8 <dtrap>
#endif
      return INVALID_SOCKET;
 d031b9c:	00bfffc4 	movi	r2,-1
 d031ba0:	e0bfff15 	stw	r2,-4(fp)
 d031ba4:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d031ba8:	e037883a 	mov	sp,fp
 d031bac:	dfc00117 	ldw	ra,4(sp)
 d031bb0:	df000017 	ldw	fp,0(sp)
 d031bb4:	dec00204 	addi	sp,sp,8
 d031bb8:	f800283a 	ret

0d031bbc <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 d031bbc:	defff404 	addi	sp,sp,-48
 d031bc0:	dfc00b15 	stw	ra,44(sp)
 d031bc4:	df000a15 	stw	fp,40(sp)
 d031bc8:	df000a04 	addi	fp,sp,40
 d031bcc:	e13ffc15 	stw	r4,-16(fp)
 d031bd0:	e17ffd15 	stw	r5,-12(fp)
 d031bd4:	e1bffe15 	stw	r6,-8(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 d031bd8:	e0bffc17 	ldw	r2,-16(fp)
 d031bdc:	10800d17 	ldw	r2,52(r2)
 d031be0:	10800817 	ldw	r2,32(r2)
 d031be4:	e0bffa15 	stw	r2,-24(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 d031be8:	e0bffd17 	ldw	r2,-12(fp)
 d031bec:	1005003a 	cmpeq	r2,r2,zero
 d031bf0:	10009c1e 	bne	r2,zero,d031e64 <tcp_reass+0x2a8>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 d031bf4:	e0bffc17 	ldw	r2,-16(fp)
 d031bf8:	10800017 	ldw	r2,0(r2)
 d031bfc:	e0bffb15 	stw	r2,-20(fp)
 d031c00:	00000a06 	br	d031c2c <tcp_reass+0x70>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 d031c04:	e0bffb17 	ldw	r2,-20(fp)
 d031c08:	10c00617 	ldw	r3,24(r2)
 d031c0c:	e0bffd17 	ldw	r2,-12(fp)
 d031c10:	10800617 	ldw	r2,24(r2)
 d031c14:	1885c83a 	sub	r2,r3,r2
 d031c18:	10800048 	cmpgei	r2,r2,1
 d031c1c:	1000061e 	bne	r2,zero,d031c38 <tcp_reass+0x7c>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 d031c20:	e0bffb17 	ldw	r2,-20(fp)
 d031c24:	10800017 	ldw	r2,0(r2)
 d031c28:	e0bffb15 	stw	r2,-20(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 d031c2c:	e0fffc17 	ldw	r3,-16(fp)
 d031c30:	e0bffb17 	ldw	r2,-20(fp)
 d031c34:	10fff31e 	bne	r2,r3,d031c04 <tcp_reass+0x48>
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 d031c38:	e0bffb17 	ldw	r2,-20(fp)
 d031c3c:	10800117 	ldw	r2,4(r2)
 d031c40:	1007883a 	mov	r3,r2
 d031c44:	e0bffc17 	ldw	r2,-16(fp)
 d031c48:	18803c26 	beq	r3,r2,d031d3c <tcp_reass+0x180>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 d031c4c:	e0bffb17 	ldw	r2,-20(fp)
 d031c50:	10800117 	ldw	r2,4(r2)
 d031c54:	e0bffb15 	stw	r2,-20(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 d031c58:	e0bffb17 	ldw	r2,-20(fp)
 d031c5c:	10c00617 	ldw	r3,24(r2)
 d031c60:	e0bffb17 	ldw	r2,-20(fp)
 d031c64:	1080028b 	ldhu	r2,10(r2)
 d031c68:	10bfffcc 	andi	r2,r2,65535
 d031c6c:	1887883a 	add	r3,r3,r2
 d031c70:	e0bffd17 	ldw	r2,-12(fp)
 d031c74:	10800617 	ldw	r2,24(r2)
 d031c78:	1885c83a 	sub	r2,r3,r2
 d031c7c:	e0bff715 	stw	r2,-36(fp)
      if (i > 0) 
 d031c80:	e0bff717 	ldw	r2,-36(fp)
 d031c84:	10800050 	cmplti	r2,r2,1
 d031c88:	1000291e 	bne	r2,zero,d031d30 <tcp_reass+0x174>
      {
         if (i >= (long)ti->ti_len) 
 d031c8c:	e0bffd17 	ldw	r2,-12(fp)
 d031c90:	1080028b 	ldhu	r2,10(r2)
 d031c94:	10ffffcc 	andi	r3,r2,65535
 d031c98:	e0bff717 	ldw	r2,-36(fp)
 d031c9c:	10c01416 	blt	r2,r3,d031cf0 <tcp_reass+0x134>
         {
            tcpstat.tcps_rcvduppack++;
 d031ca0:	008341b4 	movhi	r2,3334
 d031ca4:	10b41504 	addi	r2,r2,-12204
 d031ca8:	10801f17 	ldw	r2,124(r2)
 d031cac:	10c00044 	addi	r3,r2,1
 d031cb0:	008341b4 	movhi	r2,3334
 d031cb4:	10b41504 	addi	r2,r2,-12204
 d031cb8:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 d031cbc:	008341b4 	movhi	r2,3334
 d031cc0:	10b41504 	addi	r2,r2,-12204
 d031cc4:	10c02017 	ldw	r3,128(r2)
 d031cc8:	e0bffd17 	ldw	r2,-12(fp)
 d031ccc:	1080028b 	ldhu	r2,10(r2)
 d031cd0:	10bfffcc 	andi	r2,r2,65535
 d031cd4:	1887883a 	add	r3,r3,r2
 d031cd8:	008341b4 	movhi	r2,3334
 d031cdc:	10b41504 	addi	r2,r2,-12204
 d031ce0:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 d031ce4:	008025c4 	movi	r2,151
 d031ce8:	d0a0b215 	stw	r2,-32056(gp)
 d031cec:	0000ac06 	br	d031fa0 <tcp_reass+0x3e4>
         }
         m_adj (ti_mbuf, (int)i);
 d031cf0:	e13ffe17 	ldw	r4,-8(fp)
 d031cf4:	e17ff717 	ldw	r5,-36(fp)
 d031cf8:	d02a82c0 	call	d02a82c <m_adj>
         ti->ti_len -= (short)i;
 d031cfc:	e0bffd17 	ldw	r2,-12(fp)
 d031d00:	10c0028b 	ldhu	r3,10(r2)
 d031d04:	e0bff717 	ldw	r2,-36(fp)
 d031d08:	1885c83a 	sub	r2,r3,r2
 d031d0c:	1007883a 	mov	r3,r2
 d031d10:	e0bffd17 	ldw	r2,-12(fp)
 d031d14:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 d031d18:	e0bffd17 	ldw	r2,-12(fp)
 d031d1c:	10c00617 	ldw	r3,24(r2)
 d031d20:	e0bff717 	ldw	r2,-36(fp)
 d031d24:	1887883a 	add	r3,r3,r2
 d031d28:	e0bffd17 	ldw	r2,-12(fp)
 d031d2c:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 d031d30:	e0bffb17 	ldw	r2,-20(fp)
 d031d34:	10800017 	ldw	r2,0(r2)
 d031d38:	e0bffb15 	stw	r2,-20(fp)
   }
   tcpstat.tcps_rcvoopack++;
 d031d3c:	008341b4 	movhi	r2,3334
 d031d40:	10b41504 	addi	r2,r2,-12204
 d031d44:	10802317 	ldw	r2,140(r2)
 d031d48:	10c00044 	addi	r3,r2,1
 d031d4c:	008341b4 	movhi	r2,3334
 d031d50:	10b41504 	addi	r2,r2,-12204
 d031d54:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 d031d58:	008341b4 	movhi	r2,3334
 d031d5c:	10b41504 	addi	r2,r2,-12204
 d031d60:	10c02417 	ldw	r3,144(r2)
 d031d64:	e0bffd17 	ldw	r2,-12(fp)
 d031d68:	1080028b 	ldhu	r2,10(r2)
 d031d6c:	10bfffcc 	andi	r2,r2,65535
 d031d70:	1887883a 	add	r3,r3,r2
 d031d74:	008341b4 	movhi	r2,3334
 d031d78:	10b41504 	addi	r2,r2,-12204
 d031d7c:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 d031d80:	00003106 	br	d031e48 <tcp_reass+0x28c>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 d031d84:	e0bffd17 	ldw	r2,-12(fp)
 d031d88:	10c00617 	ldw	r3,24(r2)
 d031d8c:	e0bffd17 	ldw	r2,-12(fp)
 d031d90:	1080028b 	ldhu	r2,10(r2)
 d031d94:	10bfffcc 	andi	r2,r2,65535
 d031d98:	1887883a 	add	r3,r3,r2
 d031d9c:	e0bffb17 	ldw	r2,-20(fp)
 d031da0:	10800617 	ldw	r2,24(r2)
 d031da4:	1885c83a 	sub	r2,r3,r2
 d031da8:	e0bff615 	stw	r2,-40(fp)
      if (i <= 0)
 d031dac:	e0bff617 	ldw	r2,-40(fp)
 d031db0:	10800050 	cmplti	r2,r2,1
 d031db4:	1000271e 	bne	r2,zero,d031e54 <tcp_reass+0x298>
         break;
      if (i < (int)(q->ti_len))
 d031db8:	e0bffb17 	ldw	r2,-20(fp)
 d031dbc:	1080028b 	ldhu	r2,10(r2)
 d031dc0:	10ffffcc 	andi	r3,r2,65535
 d031dc4:	e0bff617 	ldw	r2,-40(fp)
 d031dc8:	10c0130e 	bge	r2,r3,d031e18 <tcp_reass+0x25c>
      {
         q->ti_seq += i;
 d031dcc:	e0bffb17 	ldw	r2,-20(fp)
 d031dd0:	10c00617 	ldw	r3,24(r2)
 d031dd4:	e0bff617 	ldw	r2,-40(fp)
 d031dd8:	1887883a 	add	r3,r3,r2
 d031ddc:	e0bffb17 	ldw	r2,-20(fp)
 d031de0:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 d031de4:	e0bffb17 	ldw	r2,-20(fp)
 d031de8:	10c0028b 	ldhu	r3,10(r2)
 d031dec:	e0bff617 	ldw	r2,-40(fp)
 d031df0:	1885c83a 	sub	r2,r3,r2
 d031df4:	1007883a 	mov	r3,r2
 d031df8:	e0bffb17 	ldw	r2,-20(fp)
 d031dfc:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 d031e00:	e13ffb17 	ldw	r4,-20(fp)
 d031e04:	d02aa540 	call	d02aa54 <dtom>
 d031e08:	1009883a 	mov	r4,r2
 d031e0c:	e17ff617 	ldw	r5,-40(fp)
 d031e10:	d02a82c0 	call	d02a82c <m_adj>
         break;
 d031e14:	00000f06 	br	d031e54 <tcp_reass+0x298>
      }
      q = (struct tcpiphdr *)q->ti_next;
 d031e18:	e0bffb17 	ldw	r2,-20(fp)
 d031e1c:	10800017 	ldw	r2,0(r2)
 d031e20:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(q->ti_prev);
 d031e24:	e0bffb17 	ldw	r2,-20(fp)
 d031e28:	11000117 	ldw	r4,4(r2)
 d031e2c:	d02aa540 	call	d02aa54 <dtom>
 d031e30:	e0bff915 	stw	r2,-28(fp)
      remque (q->ti_prev);
 d031e34:	e0bffb17 	ldw	r2,-20(fp)
 d031e38:	11000117 	ldw	r4,4(r2)
 d031e3c:	d02aafc0 	call	d02aafc <remque>
      m_freem (m);
 d031e40:	e13ff917 	ldw	r4,-28(fp)
 d031e44:	d02a4c40 	call	d02a4c4 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 d031e48:	e0fffc17 	ldw	r3,-16(fp)
 d031e4c:	e0bffb17 	ldw	r2,-20(fp)
 d031e50:	10ffcc1e 	bne	r2,r3,d031d84 <tcp_reass+0x1c8>
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 d031e54:	e0bffb17 	ldw	r2,-20(fp)
 d031e58:	11400117 	ldw	r5,4(r2)
 d031e5c:	e13ffd17 	ldw	r4,-12(fp)
 d031e60:	d02ab6c0 	call	d02ab6c <insque>
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 d031e64:	e0bffc17 	ldw	r2,-16(fp)
 d031e68:	10800217 	ldw	r2,8(r2)
 d031e6c:	108000c8 	cmpgei	r2,r2,3
 d031e70:	1000021e 	bne	r2,zero,d031e7c <tcp_reass+0x2c0>
      return (0);
 d031e74:	e03fff15 	stw	zero,-4(fp)
 d031e78:	00004c06 	br	d031fac <tcp_reass+0x3f0>
   ti = tp->seg_next;
 d031e7c:	e0bffc17 	ldw	r2,-16(fp)
 d031e80:	10800017 	ldw	r2,0(r2)
 d031e84:	e0bffd15 	stw	r2,-12(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 d031e88:	e0fffc17 	ldw	r3,-16(fp)
 d031e8c:	e0bffd17 	ldw	r2,-12(fp)
 d031e90:	10c00526 	beq	r2,r3,d031ea8 <tcp_reass+0x2ec>
 d031e94:	e0bffd17 	ldw	r2,-12(fp)
 d031e98:	10c00617 	ldw	r3,24(r2)
 d031e9c:	e0bffc17 	ldw	r2,-16(fp)
 d031ea0:	10801617 	ldw	r2,88(r2)
 d031ea4:	18800226 	beq	r3,r2,d031eb0 <tcp_reass+0x2f4>
      return (0);
 d031ea8:	e03fff15 	stw	zero,-4(fp)
 d031eac:	00003f06 	br	d031fac <tcp_reass+0x3f0>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 d031eb0:	e0bffc17 	ldw	r2,-16(fp)
 d031eb4:	10800217 	ldw	r2,8(r2)
 d031eb8:	108000d8 	cmpnei	r2,r2,3
 d031ebc:	1000071e 	bne	r2,zero,d031edc <tcp_reass+0x320>
 d031ec0:	e0bffd17 	ldw	r2,-12(fp)
 d031ec4:	1080028b 	ldhu	r2,10(r2)
 d031ec8:	10bfffcc 	andi	r2,r2,65535
 d031ecc:	1005003a 	cmpeq	r2,r2,zero
 d031ed0:	1000021e 	bne	r2,zero,d031edc <tcp_reass+0x320>
      return (0);
 d031ed4:	e03fff15 	stw	zero,-4(fp)
 d031ed8:	00003406 	br	d031fac <tcp_reass+0x3f0>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 d031edc:	e0bffc17 	ldw	r2,-16(fp)
 d031ee0:	10c01617 	ldw	r3,88(r2)
 d031ee4:	e0bffd17 	ldw	r2,-12(fp)
 d031ee8:	1080028b 	ldhu	r2,10(r2)
 d031eec:	10bfffcc 	andi	r2,r2,65535
 d031ef0:	1887883a 	add	r3,r3,r2
 d031ef4:	e0bffc17 	ldw	r2,-16(fp)
 d031ef8:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 d031efc:	e0bffd17 	ldw	r2,-12(fp)
 d031f00:	10800843 	ldbu	r2,33(r2)
 d031f04:	10803fcc 	andi	r2,r2,255
 d031f08:	1080004c 	andi	r2,r2,1
 d031f0c:	e0bff815 	stw	r2,-32(fp)
      remque(ti);
 d031f10:	e13ffd17 	ldw	r4,-12(fp)
 d031f14:	d02aafc0 	call	d02aafc <remque>
      m = dtom(ti);
 d031f18:	e13ffd17 	ldw	r4,-12(fp)
 d031f1c:	d02aa540 	call	d02aa54 <dtom>
 d031f20:	e0bff915 	stw	r2,-28(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 d031f24:	e0bffd17 	ldw	r2,-12(fp)
 d031f28:	10800017 	ldw	r2,0(r2)
 d031f2c:	e0bffd15 	stw	r2,-12(fp)
      if (so->so_state & SS_CANTRCVMORE)
 d031f30:	e0bffa17 	ldw	r2,-24(fp)
 d031f34:	1080088b 	ldhu	r2,34(r2)
 d031f38:	10bfffcc 	andi	r2,r2,65535
 d031f3c:	1080080c 	andi	r2,r2,32
 d031f40:	1005003a 	cmpeq	r2,r2,zero
 d031f44:	1000031e 	bne	r2,zero,d031f54 <tcp_reass+0x398>
         m_freem (m);
 d031f48:	e13ff917 	ldw	r4,-28(fp)
 d031f4c:	d02a4c40 	call	d02a4c4 <m_freem>
 d031f50:	00000406 	br	d031f64 <tcp_reass+0x3a8>
      else
         sbappend (&so->so_rcv, m);
 d031f54:	e0bffa17 	ldw	r2,-24(fp)
 d031f58:	11000a04 	addi	r4,r2,40
 d031f5c:	e17ff917 	ldw	r5,-28(fp)
 d031f60:	d03092c0 	call	d03092c <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 d031f64:	e0fffc17 	ldw	r3,-16(fp)
 d031f68:	e0bffd17 	ldw	r2,-12(fp)
 d031f6c:	10c00526 	beq	r2,r3,d031f84 <tcp_reass+0x3c8>
 d031f70:	e0bffd17 	ldw	r2,-12(fp)
 d031f74:	10c00617 	ldw	r3,24(r2)
 d031f78:	e0bffc17 	ldw	r2,-16(fp)
 d031f7c:	10801617 	ldw	r2,88(r2)
 d031f80:	18bfd626 	beq	r3,r2,d031edc <tcp_reass+0x320>
      sorwakeup(so);
 d031f84:	e0bffa17 	ldw	r2,-24(fp)
 d031f88:	11400a04 	addi	r5,r2,40
 d031f8c:	e13ffa17 	ldw	r4,-24(fp)
 d031f90:	d0307680 	call	d030768 <sbwakeup>
   return (flags);
 d031f94:	e0bff817 	ldw	r2,-32(fp)
 d031f98:	e0bfff15 	stw	r2,-4(fp)
 d031f9c:	00000306 	br	d031fac <tcp_reass+0x3f0>
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 d031fa0:	e13ffe17 	ldw	r4,-8(fp)
 d031fa4:	d02a4c40 	call	d02a4c4 <m_freem>
   return (0);
 d031fa8:	e03fff15 	stw	zero,-4(fp)
 d031fac:	e0bfff17 	ldw	r2,-4(fp)
}
 d031fb0:	e037883a 	mov	sp,fp
 d031fb4:	dfc00117 	ldw	ra,4(sp)
 d031fb8:	df000017 	ldw	fp,0(sp)
 d031fbc:	dec00204 	addi	sp,sp,8
 d031fc0:	f800283a 	ret

0d031fc4 <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 d031fc4:	deffd004 	addi	sp,sp,-192
 d031fc8:	dfc02f15 	stw	ra,188(sp)
 d031fcc:	df002e15 	stw	fp,184(sp)
 d031fd0:	df002e04 	addi	fp,sp,184
 d031fd4:	e13ff015 	stw	r4,-64(fp)
 d031fd8:	e17ff115 	stw	r5,-60(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 d031fdc:	e03feb15 	stw	zero,-84(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 d031fe0:	e03fe715 	stw	zero,-100(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 d031fe4:	e03fe515 	stw	zero,-108(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 d031fe8:	e03fe115 	stw	zero,-124(fp)
   int   dropsocket  =  0;
 d031fec:	e03fe015 	stw	zero,-128(fp)
   long  iss   =  0;
 d031ff0:	e03fdf15 	stw	zero,-132(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 d031ff4:	008341b4 	movhi	r2,3334
 d031ff8:	10b41504 	addi	r2,r2,-12204
 d031ffc:	10801917 	ldw	r2,100(r2)
 d032000:	10c00044 	addi	r3,r2,1
 d032004:	008341b4 	movhi	r2,3334
 d032008:	10b41504 	addi	r2,r2,-12204
 d03200c:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 d032010:	008341b4 	movhi	r2,3334
 d032014:	10b3e704 	addi	r2,r2,-12388
 d032018:	10800917 	ldw	r2,36(r2)
 d03201c:	10c00044 	addi	r3,r2,1
 d032020:	008341b4 	movhi	r2,3334
 d032024:	10b3e704 	addi	r2,r2,-12388
 d032028:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 d03202c:	e0bff017 	ldw	r2,-64(fp)
 d032030:	10800317 	ldw	r2,12(r2)
 d032034:	e0bfee15 	stw	r2,-72(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 d032038:	e0bfee17 	ldw	r2,-72(fp)
 d03203c:	10800003 	ldbu	r2,0(r2)
 d032040:	10803fcc 	andi	r2,r2,255
 d032044:	108011b0 	cmpltui	r2,r2,70
 d032048:	1000061e 	bne	r2,zero,d032064 <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 d03204c:	e13fee17 	ldw	r4,-72(fp)
 d032050:	e17ff017 	ldw	r5,-64(fp)
 d032054:	d02b5300 	call	d02b530 <np_stripoptions>
         pip = mtod(m, struct ip *);
 d032058:	e0bff017 	ldw	r2,-64(fp)
 d03205c:	10800317 	ldw	r2,12(r2)
 d032060:	e0bfee15 	stw	r2,-72(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 d032064:	e0bff017 	ldw	r2,-64(fp)
 d032068:	10800217 	ldw	r2,8(r2)
 d03206c:	10800a28 	cmpgeui	r2,r2,40
 d032070:	1000081e 	bne	r2,zero,d032094 <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 d032074:	008341b4 	movhi	r2,3334
 d032078:	10b41504 	addi	r2,r2,-12204
 d03207c:	10801e17 	ldw	r2,120(r2)
 d032080:	10c00044 	addi	r3,r2,1
 d032084:	008341b4 	movhi	r2,3334
 d032088:	10b41504 	addi	r2,r2,-12204
 d03208c:	10c01e15 	stw	r3,120(r2)
         return;
 d032090:	00091c06 	br	d034504 <tcp_input+0x2540>
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 d032094:	e0bfee17 	ldw	r2,-72(fp)
 d032098:	1080008b 	ldhu	r2,2(r2)
 d03209c:	10bfffcc 	andi	r2,r2,65535
 d0320a0:	e0bfe915 	stw	r2,-92(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 d0320a4:	e0bff017 	ldw	r2,-64(fp)
 d0320a8:	10800317 	ldw	r2,12(r2)
 d0320ac:	e0bfed15 	stw	r2,-76(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 d0320b0:	e0bff017 	ldw	r2,-64(fp)
 d0320b4:	10800117 	ldw	r2,4(r2)
 d0320b8:	10c00117 	ldw	r3,4(r2)
 d0320bc:	e0bfed17 	ldw	r2,-76(fp)
 d0320c0:	10c0032e 	bgeu	r2,r3,d0320d0 <tcp_input+0x10c>
      {
         panic("tcp_input");
 d0320c4:	01034174 	movhi	r4,3333
 d0320c8:	213e0a04 	addi	r4,r4,-2008
 d0320cc:	d0246440 	call	d024644 <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 d0320d0:	e0bfed17 	ldw	r2,-76(fp)
 d0320d4:	10800803 	ldbu	r2,32(r2)
 d0320d8:	10803fcc 	andi	r2,r2,255
 d0320dc:	1004d13a 	srli	r2,r2,4
 d0320e0:	10803fcc 	andi	r2,r2,255
 d0320e4:	1085883a 	add	r2,r2,r2
 d0320e8:	1085883a 	add	r2,r2,r2
 d0320ec:	e0bfe815 	stw	r2,-96(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 d0320f0:	e0bfe817 	ldw	r2,-96(fp)
 d0320f4:	10800530 	cmpltui	r2,r2,20
 d0320f8:	1000031e 	bne	r2,zero,d032108 <tcp_input+0x144>
 d0320fc:	e0ffe817 	ldw	r3,-96(fp)
 d032100:	e0bfe917 	ldw	r2,-92(fp)
 d032104:	10c0110e 	bge	r2,r3,d03214c <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 d032108:	008341b4 	movhi	r2,3334
 d03210c:	10b41504 	addi	r2,r2,-12204
 d032110:	10801d17 	ldw	r2,116(r2)
 d032114:	10c00044 	addi	r3,r2,1
 d032118:	008341b4 	movhi	r2,3334
 d03211c:	10b41504 	addi	r2,r2,-12204
 d032120:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 d032124:	008341b4 	movhi	r2,3334
 d032128:	10b3e704 	addi	r2,r2,-12388
 d03212c:	10800d17 	ldw	r2,52(r2)
 d032130:	10c00044 	addi	r3,r2,1
 d032134:	008341b4 	movhi	r2,3334
 d032138:	10b3e704 	addi	r2,r2,-12388
 d03213c:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 d032140:	00805784 	movi	r2,350
 d032144:	d0a0b215 	stw	r2,-32056(gp)
 d032148:	0008e206 	br	d0344d4 <tcp_input+0x2510>
   }
   tlen -= (int)off;
 d03214c:	e0ffe917 	ldw	r3,-92(fp)
 d032150:	e0bfe817 	ldw	r2,-96(fp)
 d032154:	1885c83a 	sub	r2,r3,r2
 d032158:	e0bfe915 	stw	r2,-92(fp)
   ti->ti_len = (u_short)tlen;
 d03215c:	e0bfe917 	ldw	r2,-92(fp)
 d032160:	1007883a 	mov	r3,r2
 d032164:	e0bfed17 	ldw	r2,-76(fp)
 d032168:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 d03216c:	e0bfe817 	ldw	r2,-96(fp)
 d032170:	10800570 	cmpltui	r2,r2,21
 d032174:	1000341e 	bne	r2,zero,d032248 <tcp_input+0x284>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 d032178:	e0bfe817 	ldw	r2,-96(fp)
 d03217c:	10bffb04 	addi	r2,r2,-20
 d032180:	e0bfdd15 	stw	r2,-140(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 d032184:	01000044 	movi	r4,1
 d032188:	e17fdd17 	ldw	r5,-140(fp)
 d03218c:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d032190:	e0bfeb15 	stw	r2,-84(fp)
      if (om == 0)
 d032194:	e0bfeb17 	ldw	r2,-84(fp)
 d032198:	1004c03a 	cmpne	r2,r2,zero
 d03219c:	1000031e 	bne	r2,zero,d0321ac <tcp_input+0x1e8>
         GOTO_DROP;
 d0321a0:	00805a84 	movi	r2,362
 d0321a4:	d0a0b215 	stw	r2,-32056(gp)
 d0321a8:	0008ca06 	br	d0344d4 <tcp_input+0x2510>
      om->m_len = olen;       /* set mbuf length */
 d0321ac:	e0ffdd17 	ldw	r3,-140(fp)
 d0321b0:	e0bfeb17 	ldw	r2,-84(fp)
 d0321b4:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 d0321b8:	e0bff017 	ldw	r2,-64(fp)
 d0321bc:	10800117 	ldw	r2,4(r2)
 d0321c0:	1080080b 	ldhu	r2,32(r2)
 d0321c4:	10ffffcc 	andi	r3,r2,65535
 d0321c8:	00b76194 	movui	r2,56710
 d0321cc:	1880051e 	bne	r3,r2,d0321e4 <tcp_input+0x220>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 d0321d0:	e0bff017 	ldw	r2,-64(fp)
 d0321d4:	10800317 	ldw	r2,12(r2)
 d0321d8:	10800504 	addi	r2,r2,20
 d0321dc:	e0bfdc15 	stw	r2,-144(fp)
 d0321e0:	00000406 	br	d0321f4 <tcp_input+0x230>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 d0321e4:	e0bff017 	ldw	r2,-64(fp)
 d0321e8:	10800317 	ldw	r2,12(r2)
 d0321ec:	10800a04 	addi	r2,r2,40
 d0321f0:	e0bfdc15 	stw	r2,-144(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 d0321f4:	e0bfeb17 	ldw	r2,-84(fp)
 d0321f8:	10c00317 	ldw	r3,12(r2)
 d0321fc:	e1bfdd17 	ldw	r6,-140(fp)
 d032200:	e0bfdc17 	ldw	r2,-144(fp)
 d032204:	1809883a 	mov	r4,r3
 d032208:	100b883a 	mov	r5,r2
 d03220c:	d0027000 	call	d002700 <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 d032210:	e0bff017 	ldw	r2,-64(fp)
 d032214:	10c00317 	ldw	r3,12(r2)
 d032218:	e0bfeb17 	ldw	r2,-84(fp)
 d03221c:	10800217 	ldw	r2,8(r2)
 d032220:	1887883a 	add	r3,r3,r2
 d032224:	e0bff017 	ldw	r2,-64(fp)
 d032228:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 d03222c:	e0bff017 	ldw	r2,-64(fp)
 d032230:	10c00217 	ldw	r3,8(r2)
 d032234:	e0bfeb17 	ldw	r2,-84(fp)
 d032238:	10800217 	ldw	r2,8(r2)
 d03223c:	1887c83a 	sub	r3,r3,r2
 d032240:	e0bff017 	ldw	r2,-64(fp)
 d032244:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 d032248:	e0bfed17 	ldw	r2,-76(fp)
 d03224c:	10800843 	ldbu	r2,33(r2)
 d032250:	10803fcc 	andi	r2,r2,255
 d032254:	e0bfe615 	stw	r2,-104(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 d032258:	e0bfed17 	ldw	r2,-76(fp)
 d03225c:	10800617 	ldw	r2,24(r2)
 d032260:	1004d63a 	srli	r2,r2,24
 d032264:	10c03fcc 	andi	r3,r2,255
 d032268:	e0bfed17 	ldw	r2,-76(fp)
 d03226c:	10800617 	ldw	r2,24(r2)
 d032270:	1004d23a 	srli	r2,r2,8
 d032274:	10bfc00c 	andi	r2,r2,65280
 d032278:	1886b03a 	or	r3,r3,r2
 d03227c:	e0bfed17 	ldw	r2,-76(fp)
 d032280:	10800617 	ldw	r2,24(r2)
 d032284:	10bfc00c 	andi	r2,r2,65280
 d032288:	1004923a 	slli	r2,r2,8
 d03228c:	1886b03a 	or	r3,r3,r2
 d032290:	e0bfed17 	ldw	r2,-76(fp)
 d032294:	10800617 	ldw	r2,24(r2)
 d032298:	10803fcc 	andi	r2,r2,255
 d03229c:	1004963a 	slli	r2,r2,24
 d0322a0:	1886b03a 	or	r3,r3,r2
 d0322a4:	e0bfed17 	ldw	r2,-76(fp)
 d0322a8:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 d0322ac:	e0bfed17 	ldw	r2,-76(fp)
 d0322b0:	10800717 	ldw	r2,28(r2)
 d0322b4:	1004d63a 	srli	r2,r2,24
 d0322b8:	10c03fcc 	andi	r3,r2,255
 d0322bc:	e0bfed17 	ldw	r2,-76(fp)
 d0322c0:	10800717 	ldw	r2,28(r2)
 d0322c4:	1004d23a 	srli	r2,r2,8
 d0322c8:	10bfc00c 	andi	r2,r2,65280
 d0322cc:	1886b03a 	or	r3,r3,r2
 d0322d0:	e0bfed17 	ldw	r2,-76(fp)
 d0322d4:	10800717 	ldw	r2,28(r2)
 d0322d8:	10bfc00c 	andi	r2,r2,65280
 d0322dc:	1004923a 	slli	r2,r2,8
 d0322e0:	1886b03a 	or	r3,r3,r2
 d0322e4:	e0bfed17 	ldw	r2,-76(fp)
 d0322e8:	10800717 	ldw	r2,28(r2)
 d0322ec:	10803fcc 	andi	r2,r2,255
 d0322f0:	1004963a 	slli	r2,r2,24
 d0322f4:	1886b03a 	or	r3,r3,r2
 d0322f8:	e0bfed17 	ldw	r2,-76(fp)
 d0322fc:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 d032300:	e0bfed17 	ldw	r2,-76(fp)
 d032304:	1080098b 	ldhu	r2,38(r2)
 d032308:	10bfffcc 	andi	r2,r2,65535
 d03230c:	1004d23a 	srli	r2,r2,8
 d032310:	10803fcc 	andi	r2,r2,255
 d032314:	1009883a 	mov	r4,r2
 d032318:	e0bfed17 	ldw	r2,-76(fp)
 d03231c:	1080098b 	ldhu	r2,38(r2)
 d032320:	10bfffcc 	andi	r2,r2,65535
 d032324:	1004923a 	slli	r2,r2,8
 d032328:	1007883a 	mov	r3,r2
 d03232c:	00bfc004 	movi	r2,-256
 d032330:	1884703a 	and	r2,r3,r2
 d032334:	2084b03a 	or	r2,r4,r2
 d032338:	1007883a 	mov	r3,r2
 d03233c:	e0bfed17 	ldw	r2,-76(fp)
 d032340:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 d032344:	e0bff017 	ldw	r2,-64(fp)
 d032348:	10800117 	ldw	r2,4(r2)
 d03234c:	1080080b 	ldhu	r2,32(r2)
 d032350:	10bfffcc 	andi	r2,r2,65535
 d032354:	10800220 	cmpeqi	r2,r2,8
 d032358:	1000011e 	bne	r2,zero,d032360 <tcp_input+0x39c>
 d03235c:	00001f06 	br	d0323dc <tcp_input+0x418>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 d032360:	e0bff017 	ldw	r2,-64(fp)
 d032364:	10800317 	ldw	r2,12(r2)
 d032368:	10c00a04 	addi	r3,r2,40
 d03236c:	e0bff017 	ldw	r2,-64(fp)
 d032370:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 d032374:	e0bff017 	ldw	r2,-64(fp)
 d032378:	10800217 	ldw	r2,8(r2)
 d03237c:	10fff604 	addi	r3,r2,-40
 d032380:	e0bff017 	ldw	r2,-64(fp)
 d032384:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 d032388:	e0bfed17 	ldw	r2,-76(fp)
 d03238c:	11400317 	ldw	r5,12(r2)
 d032390:	e0bfed17 	ldw	r2,-76(fp)
 d032394:	1080050b 	ldhu	r2,20(r2)
 d032398:	11bfffcc 	andi	r6,r2,65535
 d03239c:	e0bfed17 	ldw	r2,-76(fp)
 d0323a0:	11c00417 	ldw	r7,16(r2)
 d0323a4:	e0bfed17 	ldw	r2,-76(fp)
 d0323a8:	1080058b 	ldhu	r2,22(r2)
 d0323ac:	10bfffcc 	andi	r2,r2,65535
 d0323b0:	d8800015 	stw	r2,0(sp)
 d0323b4:	00800044 	movi	r2,1
 d0323b8:	d8800115 	stw	r2,4(sp)
 d0323bc:	010341b4 	movhi	r4,3334
 d0323c0:	21340a04 	addi	r4,r4,-12248
 d0323c4:	d0469380 	call	d046938 <in_pcblookup>
 d0323c8:	e0bfec15 	stw	r2,-80(fp)
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 d0323cc:	e0bfec17 	ldw	r2,-80(fp)
 d0323d0:	1005003a 	cmpeq	r2,r2,zero
 d0323d4:	1000031e 	bne	r2,zero,d0323e4 <tcp_input+0x420>
 d0323d8:	00000506 	br	d0323f0 <tcp_input+0x42c>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 d0323dc:	d0293e80 	call	d0293e8 <dtrap>
      return;
 d0323e0:	00084806 	br	d034504 <tcp_input+0x2540>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 d0323e4:	00806b04 	movi	r2,428
 d0323e8:	d0a0b215 	stw	r2,-32056(gp)
 d0323ec:	0007f506 	br	d0343c4 <tcp_input+0x2400>
   tp = intotcpcb (inp);
 d0323f0:	e0bfec17 	ldw	r2,-80(fp)
 d0323f4:	10800917 	ldw	r2,36(r2)
 d0323f8:	e0bfe715 	stw	r2,-100(fp)
   if (tp == 0)
 d0323fc:	e0bfe717 	ldw	r2,-100(fp)
 d032400:	1004c03a 	cmpne	r2,r2,zero
 d032404:	1000031e 	bne	r2,zero,d032414 <tcp_input+0x450>
      GOTO_DROPWITHRESET;
 d032408:	00806bc4 	movi	r2,431
 d03240c:	d0a0b215 	stw	r2,-32056(gp)
 d032410:	0007ec06 	br	d0343c4 <tcp_input+0x2400>
   if (tp->t_state == TCPS_CLOSED)
 d032414:	e0bfe717 	ldw	r2,-100(fp)
 d032418:	10800217 	ldw	r2,8(r2)
 d03241c:	1004c03a 	cmpne	r2,r2,zero
 d032420:	1000031e 	bne	r2,zero,d032430 <tcp_input+0x46c>
      GOTO_DROP;
 d032424:	00806c44 	movi	r2,433
 d032428:	d0a0b215 	stw	r2,-32056(gp)
 d03242c:	00082906 	br	d0344d4 <tcp_input+0x2510>
   so = inp->inp_socket;
 d032430:	e0bfec17 	ldw	r2,-80(fp)
 d032434:	10800817 	ldw	r2,32(r2)
 d032438:	e0bfe515 	stw	r2,-108(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 d03243c:	e0bfed17 	ldw	r2,-76(fp)
 d032440:	1080088b 	ldhu	r2,34(r2)
 d032444:	10bfffcc 	andi	r2,r2,65535
 d032448:	1004d23a 	srli	r2,r2,8
 d03244c:	10bfffcc 	andi	r2,r2,65535
 d032450:	10c03fcc 	andi	r3,r2,255
 d032454:	e0bfed17 	ldw	r2,-76(fp)
 d032458:	1080088b 	ldhu	r2,34(r2)
 d03245c:	10bfffcc 	andi	r2,r2,65535
 d032460:	1004923a 	slli	r2,r2,8
 d032464:	10bfc00c 	andi	r2,r2,65280
 d032468:	1884b03a 	or	r2,r3,r2
 d03246c:	e0bfde15 	stw	r2,-136(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 d032470:	e0bfe517 	ldw	r2,-108(fp)
 d032474:	10800417 	ldw	r2,16(r2)
 d032478:	1080008c 	andi	r2,r2,2
 d03247c:	1005003a 	cmpeq	r2,r2,zero
 d032480:	10002d1e 	bne	r2,zero,d032538 <tcp_input+0x574>
   {
      so = sonewconn(so);
 d032484:	e13fe517 	ldw	r4,-108(fp)
 d032488:	d0302400 	call	d030240 <sonewconn>
 d03248c:	e0bfe515 	stw	r2,-108(fp)
      if (so == 0)
 d032490:	e0bfe517 	ldw	r2,-108(fp)
 d032494:	1004c03a 	cmpne	r2,r2,zero
 d032498:	1000031e 	bne	r2,zero,d0324a8 <tcp_input+0x4e4>
         GOTO_DROP;
 d03249c:	00807344 	movi	r2,461
 d0324a0:	d0a0b215 	stw	r2,-32056(gp)
 d0324a4:	00080b06 	br	d0344d4 <tcp_input+0x2510>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 d0324a8:	e0bfe017 	ldw	r2,-128(fp)
 d0324ac:	10800044 	addi	r2,r2,1
 d0324b0:	e0bfe015 	stw	r2,-128(fp)

      inp = (struct inpcb *)so->so_pcb;
 d0324b4:	e0bfe517 	ldw	r2,-108(fp)
 d0324b8:	10800117 	ldw	r2,4(r2)
 d0324bc:	e0bfec15 	stw	r2,-80(fp)
      inp->ifp = ifp;      /* save iface to peer */
 d0324c0:	e0ffec17 	ldw	r3,-80(fp)
 d0324c4:	e0bff117 	ldw	r2,-60(fp)
 d0324c8:	18800a15 	stw	r2,40(r3)

      switch(so->so_domain)
 d0324cc:	e0bfe517 	ldw	r2,-108(fp)
 d0324d0:	10800517 	ldw	r2,20(r2)
 d0324d4:	108000a0 	cmpeqi	r2,r2,2
 d0324d8:	1000011e 	bne	r2,zero,d0324e0 <tcp_input+0x51c>
 d0324dc:	00000c06 	br	d032510 <tcp_input+0x54c>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 d0324e0:	e0bfed17 	ldw	r2,-76(fp)
 d0324e4:	10c00417 	ldw	r3,16(r2)
 d0324e8:	e0bfec17 	ldw	r2,-80(fp)
 d0324ec:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 d0324f0:	e0bff117 	ldw	r2,-60(fp)
 d0324f4:	10c00917 	ldw	r3,36(r2)
 d0324f8:	e0bff117 	ldw	r2,-60(fp)
 d0324fc:	10800817 	ldw	r2,32(r2)
 d032500:	1885c83a 	sub	r2,r3,r2
 d032504:	10fff604 	addi	r3,r2,-40
 d032508:	e0bfec17 	ldw	r2,-80(fp)
 d03250c:	10c00615 	stw	r3,24(r2)
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 d032510:	e0bfed17 	ldw	r2,-76(fp)
 d032514:	10c0058b 	ldhu	r3,22(r2)
 d032518:	e0bfec17 	ldw	r2,-80(fp)
 d03251c:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 d032520:	e0bfec17 	ldw	r2,-80(fp)
 d032524:	10800917 	ldw	r2,36(r2)
 d032528:	e0bfe715 	stw	r2,-100(fp)
      tp->t_state = TCPS_LISTEN;
 d03252c:	e0ffe717 	ldw	r3,-100(fp)
 d032530:	00800044 	movi	r2,1
 d032534:	18800215 	stw	r2,8(r3)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 d032538:	e0bfe717 	ldw	r2,-100(fp)
 d03253c:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 d032540:	00834174 	movhi	r2,3333
 d032544:	108a5f04 	addi	r2,r2,10620
 d032548:	10c00017 	ldw	r3,0(r2)
 d03254c:	e0bfe717 	ldw	r2,-100(fp)
 d032550:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 d032554:	e0bfeb17 	ldw	r2,-84(fp)
 d032558:	1005003a 	cmpeq	r2,r2,zero
 d03255c:	1000091e 	bne	r2,zero,d032584 <tcp_input+0x5c0>
 d032560:	e0bfe717 	ldw	r2,-100(fp)
 d032564:	10800217 	ldw	r2,8(r2)
 d032568:	10800060 	cmpeqi	r2,r2,1
 d03256c:	1000051e 	bne	r2,zero,d032584 <tcp_input+0x5c0>
   {
      tcp_dooptions(tp, om, ti);
 d032570:	e13fe717 	ldw	r4,-100(fp)
 d032574:	e17feb17 	ldw	r5,-84(fp)
 d032578:	e1bfed17 	ldw	r6,-76(fp)
 d03257c:	d0345180 	call	d034518 <tcp_dooptions>
      om = 0;
 d032580:	e03feb15 	stw	zero,-84(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 d032584:	e0bfed17 	ldw	r2,-76(fp)
 d032588:	10c00717 	ldw	r3,28(r2)
 d03258c:	e0bfe717 	ldw	r2,-100(fp)
 d032590:	10800e17 	ldw	r2,56(r2)
 d032594:	1885c83a 	sub	r2,r3,r2
 d032598:	e0bfe315 	stw	r2,-116(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 d03259c:	e0bfe517 	ldw	r2,-108(fp)
 d0325a0:	10800b17 	ldw	r2,44(r2)
 d0325a4:	1007883a 	mov	r3,r2
 d0325a8:	e0bfe517 	ldw	r2,-108(fp)
 d0325ac:	10800a17 	ldw	r2,40(r2)
 d0325b0:	1885c83a 	sub	r2,r3,r2
 d0325b4:	1004803a 	cmplt	r2,r2,zero
 d0325b8:	1000071e 	bne	r2,zero,d0325d8 <tcp_input+0x614>
 d0325bc:	e0bfe517 	ldw	r2,-108(fp)
 d0325c0:	10c00b17 	ldw	r3,44(r2)
 d0325c4:	e0bfe517 	ldw	r2,-108(fp)
 d0325c8:	10800a17 	ldw	r2,40(r2)
 d0325cc:	1885c83a 	sub	r2,r3,r2
 d0325d0:	e0bffd15 	stw	r2,-12(fp)
 d0325d4:	00000106 	br	d0325dc <tcp_input+0x618>
 d0325d8:	e03ffd15 	stw	zero,-12(fp)
 d0325dc:	e0bffd17 	ldw	r2,-12(fp)
 d0325e0:	e0bfdb15 	stw	r2,-148(fp)
      if (win < 0)
 d0325e4:	e0bfdb17 	ldw	r2,-148(fp)
 d0325e8:	1004403a 	cmpge	r2,r2,zero
 d0325ec:	1000011e 	bne	r2,zero,d0325f4 <tcp_input+0x630>
         win = 0;
 d0325f0:	e03fdb15 	stw	zero,-148(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 d0325f4:	e0bfe717 	ldw	r2,-100(fp)
 d0325f8:	10c01917 	ldw	r3,100(r2)
 d0325fc:	e0bfe717 	ldw	r2,-100(fp)
 d032600:	10801617 	ldw	r2,88(r2)
 d032604:	1885c83a 	sub	r2,r3,r2
 d032608:	e0ffdb17 	ldw	r3,-148(fp)
 d03260c:	e0fffc15 	stw	r3,-16(fp)
 d032610:	e0bffb15 	stw	r2,-20(fp)
 d032614:	e13ffb17 	ldw	r4,-20(fp)
 d032618:	e0bffc17 	ldw	r2,-16(fp)
 d03261c:	2080022e 	bgeu	r4,r2,d032628 <tcp_input+0x664>
 d032620:	e0fffc17 	ldw	r3,-16(fp)
 d032624:	e0fffb15 	stw	r3,-20(fp)
 d032628:	e0bfe717 	ldw	r2,-100(fp)
 d03262c:	e13ffb17 	ldw	r4,-20(fp)
 d032630:	11001515 	stw	r4,84(r2)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 d032634:	e0bfe717 	ldw	r2,-100(fp)
 d032638:	10800217 	ldw	r2,8(r2)
 d03263c:	10800118 	cmpnei	r2,r2,4
 d032640:	10010f1e 	bne	r2,zero,d032a80 <tcp_input+0xabc>
 d032644:	e0bfe617 	ldw	r2,-104(fp)
 d032648:	10800dcc 	andi	r2,r2,55
 d03264c:	10800418 	cmpnei	r2,r2,16
 d032650:	10010b1e 	bne	r2,zero,d032a80 <tcp_input+0xabc>
 d032654:	e0bfed17 	ldw	r2,-76(fp)
 d032658:	10c00617 	ldw	r3,24(r2)
 d03265c:	e0bfe717 	ldw	r2,-100(fp)
 d032660:	10801617 	ldw	r2,88(r2)
 d032664:	1881061e 	bne	r3,r2,d032a80 <tcp_input+0xabc>
 d032668:	e0bfde17 	ldw	r2,-136(fp)
 d03266c:	1005003a 	cmpeq	r2,r2,zero
 d032670:	1001031e 	bne	r2,zero,d032a80 <tcp_input+0xabc>
 d032674:	e0bfe717 	ldw	r2,-100(fp)
 d032678:	10c01417 	ldw	r3,80(r2)
 d03267c:	e0bfde17 	ldw	r2,-136(fp)
 d032680:	1880ff1e 	bne	r3,r2,d032a80 <tcp_input+0xabc>
 d032684:	e0bfe717 	ldw	r2,-100(fp)
 d032688:	10c00f17 	ldw	r3,60(r2)
 d03268c:	e0bfe717 	ldw	r2,-100(fp)
 d032690:	10801a17 	ldw	r2,104(r2)
 d032694:	1880fa1e 	bne	r3,r2,d032a80 <tcp_input+0xabc>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 d032698:	e0bfed17 	ldw	r2,-76(fp)
 d03269c:	1080028b 	ldhu	r2,10(r2)
 d0326a0:	10bfffcc 	andi	r2,r2,65535
 d0326a4:	1004c03a 	cmpne	r2,r2,zero
 d0326a8:	1000651e 	bne	r2,zero,d032840 <tcp_input+0x87c>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 d0326ac:	e0bfed17 	ldw	r2,-76(fp)
 d0326b0:	10c00717 	ldw	r3,28(r2)
 d0326b4:	e0bfe717 	ldw	r2,-100(fp)
 d0326b8:	10800e17 	ldw	r2,56(r2)
 d0326bc:	1885c83a 	sub	r2,r3,r2
 d0326c0:	10800050 	cmplti	r2,r2,1
 d0326c4:	1000ee1e 	bne	r2,zero,d032a80 <tcp_input+0xabc>
 d0326c8:	e0bfed17 	ldw	r2,-76(fp)
 d0326cc:	10c00717 	ldw	r3,28(r2)
 d0326d0:	e0bfe717 	ldw	r2,-100(fp)
 d0326d4:	10801a17 	ldw	r2,104(r2)
 d0326d8:	1885c83a 	sub	r2,r3,r2
 d0326dc:	10800048 	cmpgei	r2,r2,1
 d0326e0:	1000e71e 	bne	r2,zero,d032a80 <tcp_input+0xabc>
 d0326e4:	e0bfe717 	ldw	r2,-100(fp)
 d0326e8:	10c01b17 	ldw	r3,108(r2)
 d0326ec:	e0bfe717 	ldw	r2,-100(fp)
 d0326f0:	10801417 	ldw	r2,80(r2)
 d0326f4:	1880e236 	bltu	r3,r2,d032a80 <tcp_input+0xabc>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 d0326f8:	008341b4 	movhi	r2,3334
 d0326fc:	10b41504 	addi	r2,r2,-12204
 d032700:	10803517 	ldw	r2,212(r2)
 d032704:	10c00044 	addi	r3,r2,1
 d032708:	008341b4 	movhi	r2,3334
 d03270c:	10b41504 	addi	r2,r2,-12204
 d032710:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 d032714:	e0bfe717 	ldw	r2,-100(fp)
 d032718:	10801e17 	ldw	r2,120(r2)
 d03271c:	1005003a 	cmpeq	r2,r2,zero
 d032720:	1000091e 	bne	r2,zero,d032748 <tcp_input+0x784>
 d032724:	e0bfed17 	ldw	r2,-76(fp)
 d032728:	10c00717 	ldw	r3,28(r2)
 d03272c:	e0bfe717 	ldw	r2,-100(fp)
 d032730:	10801f17 	ldw	r2,124(r2)
 d032734:	1885c83a 	sub	r2,r3,r2
 d032738:	10800050 	cmplti	r2,r2,1
 d03273c:	1000021e 	bne	r2,zero,d032748 <tcp_input+0x784>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 d032740:	e13fe717 	ldw	r4,-100(fp)
 d032744:	d0347d40 	call	d0347d4 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 d032748:	008341b4 	movhi	r2,3334
 d03274c:	10b41504 	addi	r2,r2,-12204
 d032750:	10802b17 	ldw	r2,172(r2)
 d032754:	10c00044 	addi	r3,r2,1
 d032758:	008341b4 	movhi	r2,3334
 d03275c:	10b41504 	addi	r2,r2,-12204
 d032760:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 d032764:	008341b4 	movhi	r2,3334
 d032768:	10b41504 	addi	r2,r2,-12204
 d03276c:	10c02c17 	ldw	r3,176(r2)
 d032770:	e0bfe317 	ldw	r2,-116(fp)
 d032774:	1887883a 	add	r3,r3,r2
 d032778:	008341b4 	movhi	r2,3334
 d03277c:	10b41504 	addi	r2,r2,-12204
 d032780:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 d032784:	e0bfe517 	ldw	r2,-108(fp)
 d032788:	11001204 	addi	r4,r2,72
 d03278c:	e17fe317 	ldw	r5,-116(fp)
 d032790:	d030f340 	call	d030f34 <sbdrop>
            tp->snd_una = ti->ti_ack;
 d032794:	e0bfed17 	ldw	r2,-76(fp)
 d032798:	10c00717 	ldw	r3,28(r2)
 d03279c:	e0bfe717 	ldw	r2,-100(fp)
 d0327a0:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 d0327a4:	e13ff017 	ldw	r4,-64(fp)
 d0327a8:	d02a4c40 	call	d02a4c4 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 d0327ac:	e0bfe717 	ldw	r2,-100(fp)
 d0327b0:	10c00e17 	ldw	r3,56(r2)
 d0327b4:	e0bfe717 	ldw	r2,-100(fp)
 d0327b8:	10801a17 	ldw	r2,104(r2)
 d0327bc:	1880031e 	bne	r3,r2,d0327cc <tcp_input+0x808>
               tp->t_timer[TCPT_REXMT] = 0;
 d0327c0:	e0bfe717 	ldw	r2,-100(fp)
 d0327c4:	10000315 	stw	zero,12(r2)
 d0327c8:	00000806 	br	d0327ec <tcp_input+0x828>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 d0327cc:	e0bfe717 	ldw	r2,-100(fp)
 d0327d0:	10800417 	ldw	r2,16(r2)
 d0327d4:	1004c03a 	cmpne	r2,r2,zero
 d0327d8:	1000041e 	bne	r2,zero,d0327ec <tcp_input+0x828>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 d0327dc:	e0bfe717 	ldw	r2,-100(fp)
 d0327e0:	10c00817 	ldw	r3,32(r2)
 d0327e4:	e0bfe717 	ldw	r2,-100(fp)
 d0327e8:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 d0327ec:	e0bfe517 	ldw	r2,-108(fp)
 d0327f0:	1080190b 	ldhu	r2,100(r2)
 d0327f4:	10bfffcc 	andi	r2,r2,65535
 d0327f8:	1080030c 	andi	r2,r2,12
 d0327fc:	1005003a 	cmpeq	r2,r2,zero
 d032800:	1000041e 	bne	r2,zero,d032814 <tcp_input+0x850>
               sowwakeup(so);
 d032804:	e0bfe517 	ldw	r2,-108(fp)
 d032808:	11401204 	addi	r5,r2,72
 d03280c:	e13fe517 	ldw	r4,-108(fp)
 d032810:	d0307680 	call	d030768 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 d032814:	e0bfe517 	ldw	r2,-108(fp)
 d032818:	11001217 	ldw	r4,72(r2)
 d03281c:	e0bfe717 	ldw	r2,-100(fp)
 d032820:	10c00f17 	ldw	r3,60(r2)
 d032824:	e0bfe717 	ldw	r2,-100(fp)
 d032828:	10800e17 	ldw	r2,56(r2)
 d03282c:	1885c83a 	sub	r2,r3,r2
 d032830:	1107342e 	bgeu	r2,r4,d034504 <tcp_input+0x2540>
               (void) tcp_output(tp);
 d032834:	e13fe717 	ldw	r4,-100(fp)
 d032838:	d034ba40 	call	d034ba4 <tcp_output>
            return;
 d03283c:	00073106 	br	d034504 <tcp_input+0x2540>
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 d032840:	e0bfed17 	ldw	r2,-76(fp)
 d032844:	10c00717 	ldw	r3,28(r2)
 d032848:	e0bfe717 	ldw	r2,-100(fp)
 d03284c:	10800e17 	ldw	r2,56(r2)
 d032850:	18808b1e 	bne	r3,r2,d032a80 <tcp_input+0xabc>
 d032854:	e0bfe717 	ldw	r2,-100(fp)
 d032858:	10c00017 	ldw	r3,0(r2)
 d03285c:	e0bfe717 	ldw	r2,-100(fp)
 d032860:	1880871e 	bne	r3,r2,d032a80 <tcp_input+0xabc>
 d032864:	e0bfed17 	ldw	r2,-76(fp)
 d032868:	1080028b 	ldhu	r2,10(r2)
 d03286c:	10bfffcc 	andi	r2,r2,65535
 d032870:	e0bffa15 	stw	r2,-24(fp)
 d032874:	e0bfe517 	ldw	r2,-108(fp)
 d032878:	10800b17 	ldw	r2,44(r2)
 d03287c:	1007883a 	mov	r3,r2
 d032880:	e0bfe517 	ldw	r2,-108(fp)
 d032884:	10800a17 	ldw	r2,40(r2)
 d032888:	1885c83a 	sub	r2,r3,r2
 d03288c:	1004803a 	cmplt	r2,r2,zero
 d032890:	1000071e 	bne	r2,zero,d0328b0 <tcp_input+0x8ec>
 d032894:	e0bfe517 	ldw	r2,-108(fp)
 d032898:	10c00b17 	ldw	r3,44(r2)
 d03289c:	e0bfe517 	ldw	r2,-108(fp)
 d0328a0:	10800a17 	ldw	r2,40(r2)
 d0328a4:	1887c83a 	sub	r3,r3,r2
 d0328a8:	e0fff915 	stw	r3,-28(fp)
 d0328ac:	00000106 	br	d0328b4 <tcp_input+0x8f0>
 d0328b0:	e03ff915 	stw	zero,-28(fp)
 d0328b4:	e0bff917 	ldw	r2,-28(fp)
 d0328b8:	e0fffa17 	ldw	r3,-24(fp)
 d0328bc:	10c07036 	bltu	r2,r3,d032a80 <tcp_input+0xabc>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 d0328c0:	e0bfe717 	ldw	r2,-100(fp)
 d0328c4:	10801517 	ldw	r2,84(r2)
 d0328c8:	1004c03a 	cmpne	r2,r2,zero
 d0328cc:	10000c1e 	bne	r2,zero,d032900 <tcp_input+0x93c>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 d0328d0:	008341b4 	movhi	r2,3334
 d0328d4:	10b41504 	addi	r2,r2,-12204
 d0328d8:	10802817 	ldw	r2,160(r2)
 d0328dc:	10c00044 	addi	r3,r2,1
 d0328e0:	008341b4 	movhi	r2,3334
 d0328e4:	10b41504 	addi	r2,r2,-12204
 d0328e8:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 d0328ec:	e13ff017 	ldw	r4,-64(fp)
 d0328f0:	d02a4c40 	call	d02a4c4 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 d0328f4:	e13fe717 	ldw	r4,-100(fp)
 d0328f8:	d034ba40 	call	d034ba4 <tcp_output>
            return;
 d0328fc:	00070106 	br	d034504 <tcp_input+0x2540>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 d032900:	008341b4 	movhi	r2,3334
 d032904:	10b41504 	addi	r2,r2,-12204
 d032908:	10803617 	ldw	r2,216(r2)
 d03290c:	10c00044 	addi	r3,r2,1
 d032910:	008341b4 	movhi	r2,3334
 d032914:	10b41504 	addi	r2,r2,-12204
 d032918:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 d03291c:	e0bfe717 	ldw	r2,-100(fp)
 d032920:	10c01617 	ldw	r3,88(r2)
 d032924:	e0bfed17 	ldw	r2,-76(fp)
 d032928:	1080028b 	ldhu	r2,10(r2)
 d03292c:	10bfffcc 	andi	r2,r2,65535
 d032930:	1887883a 	add	r3,r3,r2
 d032934:	e0bfe717 	ldw	r2,-100(fp)
 d032938:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 d03293c:	008341b4 	movhi	r2,3334
 d032940:	10b41504 	addi	r2,r2,-12204
 d032944:	10801a17 	ldw	r2,104(r2)
 d032948:	10c00044 	addi	r3,r2,1
 d03294c:	008341b4 	movhi	r2,3334
 d032950:	10b41504 	addi	r2,r2,-12204
 d032954:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 d032958:	008341b4 	movhi	r2,3334
 d03295c:	10b41504 	addi	r2,r2,-12204
 d032960:	10c01b17 	ldw	r3,108(r2)
 d032964:	e0bfed17 	ldw	r2,-76(fp)
 d032968:	1080028b 	ldhu	r2,10(r2)
 d03296c:	10bfffcc 	andi	r2,r2,65535
 d032970:	1887883a 	add	r3,r3,r2
 d032974:	008341b4 	movhi	r2,3334
 d032978:	10b41504 	addi	r2,r2,-12204
 d03297c:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 d032980:	e0bfe517 	ldw	r2,-108(fp)
 d032984:	11000a04 	addi	r4,r2,40
 d032988:	e17ff017 	ldw	r5,-64(fp)
 d03298c:	d03092c0 	call	d03092c <sbappend>
         sorwakeup(so);
 d032990:	e0bfe517 	ldw	r2,-108(fp)
 d032994:	11400a04 	addi	r5,r2,40
 d032998:	e13fe517 	ldw	r4,-108(fp)
 d03299c:	d0307680 	call	d030768 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 d0329a0:	e0bfe617 	ldw	r2,-104(fp)
 d0329a4:	1080020c 	andi	r2,r2,8
 d0329a8:	1005003a 	cmpeq	r2,r2,zero
 d0329ac:	1000071e 	bne	r2,zero,d0329cc <tcp_input+0xa08>
            tp->t_flags |= TF_ACKNOW;
 d0329b0:	e0bfe717 	ldw	r2,-100(fp)
 d0329b4:	10800b0b 	ldhu	r2,44(r2)
 d0329b8:	10800054 	ori	r2,r2,1
 d0329bc:	1007883a 	mov	r3,r2
 d0329c0:	e0bfe717 	ldw	r2,-100(fp)
 d0329c4:	10c00b0d 	sth	r3,44(r2)
 d0329c8:	00000606 	br	d0329e4 <tcp_input+0xa20>
         else
            tp->t_flags |= TF_DELACK;
 d0329cc:	e0bfe717 	ldw	r2,-100(fp)
 d0329d0:	10800b0b 	ldhu	r2,44(r2)
 d0329d4:	10800094 	ori	r2,r2,2
 d0329d8:	1007883a 	mov	r3,r2
 d0329dc:	e0bfe717 	ldw	r2,-100(fp)
 d0329e0:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 d0329e4:	e0bfe717 	ldw	r2,-100(fp)
 d0329e8:	11001517 	ldw	r4,84(r2)
 d0329ec:	e0bfe717 	ldw	r2,-100(fp)
 d0329f0:	10c01917 	ldw	r3,100(r2)
 d0329f4:	e0bfe717 	ldw	r2,-100(fp)
 d0329f8:	10801617 	ldw	r2,88(r2)
 d0329fc:	1885c83a 	sub	r2,r3,r2
 d032a00:	2085c83a 	sub	r2,r4,r2
 d032a04:	e0bfda15 	stw	r2,-152(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 d032a08:	e0bfe717 	ldw	r2,-100(fp)
 d032a0c:	10800a0b 	ldhu	r2,40(r2)
 d032a10:	10bfffcc 	andi	r2,r2,65535
 d032a14:	1085883a 	add	r2,r2,r2
 d032a18:	1007883a 	mov	r3,r2
 d032a1c:	e0bfda17 	ldw	r2,-152(fp)
 d032a20:	10c0070e 	bge	r2,r3,d032a40 <tcp_input+0xa7c>
 d032a24:	e0bfe717 	ldw	r2,-100(fp)
 d032a28:	10800b0b 	ldhu	r2,44(r2)
 d032a2c:	10bfffcc 	andi	r2,r2,65535
 d032a30:	1080004c 	andi	r2,r2,1
 d032a34:	10803fcc 	andi	r2,r2,255
 d032a38:	1005003a 	cmpeq	r2,r2,zero
 d032a3c:	1006b11e 	bne	r2,zero,d034504 <tcp_input+0x2540>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 d032a40:	e0bfe717 	ldw	r2,-100(fp)
 d032a44:	10800b0b 	ldhu	r2,44(r2)
 d032a48:	10800054 	ori	r2,r2,1
 d032a4c:	1007883a 	mov	r3,r2
 d032a50:	e0bfe717 	ldw	r2,-100(fp)
 d032a54:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 d032a58:	e0bfe717 	ldw	r2,-100(fp)
 d032a5c:	10c00b0b 	ldhu	r3,44(r2)
 d032a60:	00bfff44 	movi	r2,-3
 d032a64:	1884703a 	and	r2,r3,r2
 d032a68:	1007883a 	mov	r3,r2
 d032a6c:	e0bfe717 	ldw	r2,-100(fp)
 d032a70:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 d032a74:	e13fe717 	ldw	r4,-100(fp)
 d032a78:	d034ba40 	call	d034ba4 <tcp_output>
         }

         return;
 d032a7c:	0006a106 	br	d034504 <tcp_input+0x2540>
      }
   }

   switch (tp->t_state) 
 d032a80:	e0bfe717 	ldw	r2,-100(fp)
 d032a84:	10800217 	ldw	r2,8(r2)
 d032a88:	e0bff815 	stw	r2,-32(fp)
 d032a8c:	e13ff817 	ldw	r4,-32(fp)
 d032a90:	20800060 	cmpeqi	r2,r4,1
 d032a94:	1000041e 	bne	r2,zero,d032aa8 <tcp_input+0xae4>
 d032a98:	e0fff817 	ldw	r3,-32(fp)
 d032a9c:	188000a0 	cmpeqi	r2,r3,2
 d032aa0:	1000b91e 	bne	r2,zero,d032d88 <tcp_input+0xdc4>
 d032aa4:	00019806 	br	d033108 <tcp_input+0x1144>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 d032aa8:	e0bfe617 	ldw	r2,-104(fp)
 d032aac:	1080010c 	andi	r2,r2,4
 d032ab0:	1005003a 	cmpeq	r2,r2,zero
 d032ab4:	1000031e 	bne	r2,zero,d032ac4 <tcp_input+0xb00>
            GOTO_DROP;
 d032ab8:	0080bec4 	movi	r2,763
 d032abc:	d0a0b215 	stw	r2,-32056(gp)
 d032ac0:	00068406 	br	d0344d4 <tcp_input+0x2510>
         if (tiflags & TH_ACK)
 d032ac4:	e0bfe617 	ldw	r2,-104(fp)
 d032ac8:	1080040c 	andi	r2,r2,16
 d032acc:	1005003a 	cmpeq	r2,r2,zero
 d032ad0:	1000031e 	bne	r2,zero,d032ae0 <tcp_input+0xb1c>
            GOTO_DROPWITHRESET;
 d032ad4:	0080bf44 	movi	r2,765
 d032ad8:	d0a0b215 	stw	r2,-32056(gp)
 d032adc:	00063906 	br	d0343c4 <tcp_input+0x2400>
         if ((tiflags & TH_SYN) == 0)
 d032ae0:	e0bfe617 	ldw	r2,-104(fp)
 d032ae4:	1080008c 	andi	r2,r2,2
 d032ae8:	1004c03a 	cmpne	r2,r2,zero
 d032aec:	1000031e 	bne	r2,zero,d032afc <tcp_input+0xb38>
            GOTO_DROP;
 d032af0:	0080bfc4 	movi	r2,767
 d032af4:	d0a0b215 	stw	r2,-32056(gp)
 d032af8:	00067606 	br	d0344d4 <tcp_input+0x2510>
         if(in_broadcast(ti->ti_dst.s_addr))
 d032afc:	e0bfed17 	ldw	r2,-76(fp)
 d032b00:	11000417 	ldw	r4,16(r2)
 d032b04:	d02b4f00 	call	d02b4f0 <in_broadcast>
 d032b08:	1005003a 	cmpeq	r2,r2,zero
 d032b0c:	1000031e 	bne	r2,zero,d032b1c <tcp_input+0xb58>
            GOTO_DROP;
 d032b10:	0080c044 	movi	r2,769
 d032b14:	d0a0b215 	stw	r2,-32056(gp)
 d032b18:	00066e06 	br	d0344d4 <tcp_input+0x2510>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 d032b1c:	01000244 	movi	r4,9
 d032b20:	01400404 	movi	r5,16
 d032b24:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d032b28:	e0bfd915 	stw	r2,-156(fp)
         if (am == NULL)
 d032b2c:	e0bfd917 	ldw	r2,-156(fp)
 d032b30:	1004c03a 	cmpne	r2,r2,zero
 d032b34:	1000031e 	bne	r2,zero,d032b44 <tcp_input+0xb80>
            GOTO_DROP;
 d032b38:	0080c104 	movi	r2,772
 d032b3c:	d0a0b215 	stw	r2,-32056(gp)
 d032b40:	00066406 	br	d0344d4 <tcp_input+0x2510>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 d032b44:	e0bfec17 	ldw	r2,-80(fp)
 d032b48:	10800817 	ldw	r2,32(r2)
 d032b4c:	10800517 	ldw	r2,20(r2)
 d032b50:	10800098 	cmpnei	r2,r2,2
 d032b54:	10002e1e 	bne	r2,zero,d032c10 <tcp_input+0xc4c>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 d032b58:	e0ffd917 	ldw	r3,-156(fp)
 d032b5c:	00800404 	movi	r2,16
 d032b60:	18800215 	stw	r2,8(r3)
         sin = mtod(am, struct sockaddr_in *);
 d032b64:	e0bfd917 	ldw	r2,-156(fp)
 d032b68:	10800317 	ldw	r2,12(r2)
 d032b6c:	e0bfd815 	stw	r2,-160(fp)
         sin->sin_family = AF_INET;
 d032b70:	e0ffd817 	ldw	r3,-160(fp)
 d032b74:	00800084 	movi	r2,2
 d032b78:	1880000d 	sth	r2,0(r3)
         sin->sin_addr = ti->ti_src;
 d032b7c:	e0bfed17 	ldw	r2,-76(fp)
 d032b80:	10c00317 	ldw	r3,12(r2)
 d032b84:	e0bfd817 	ldw	r2,-160(fp)
 d032b88:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 d032b8c:	e0bfed17 	ldw	r2,-76(fp)
 d032b90:	10c0050b 	ldhu	r3,20(r2)
 d032b94:	e0bfd817 	ldw	r2,-160(fp)
 d032b98:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 d032b9c:	e0bfec17 	ldw	r2,-80(fp)
 d032ba0:	10800417 	ldw	r2,16(r2)
 d032ba4:	e0bfef15 	stw	r2,-68(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 d032ba8:	e0bfec17 	ldw	r2,-80(fp)
 d032bac:	10800417 	ldw	r2,16(r2)
 d032bb0:	1004c03a 	cmpne	r2,r2,zero
 d032bb4:	1000041e 	bne	r2,zero,d032bc8 <tcp_input+0xc04>
            inp->inp_laddr = ti->ti_dst;
 d032bb8:	e0bfed17 	ldw	r2,-76(fp)
 d032bbc:	10c00417 	ldw	r3,16(r2)
 d032bc0:	e0bfec17 	ldw	r2,-80(fp)
 d032bc4:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 d032bc8:	e13fec17 	ldw	r4,-80(fp)
 d032bcc:	e17fd917 	ldw	r5,-156(fp)
 d032bd0:	d0465d00 	call	d0465d0 <in_pcbconnect>
 d032bd4:	1005003a 	cmpeq	r2,r2,zero
 d032bd8:	1000081e 	bne	r2,zero,d032bfc <tcp_input+0xc38>
         {
            inp->inp_laddr = laddr;
 d032bdc:	e0bfec17 	ldw	r2,-80(fp)
 d032be0:	e0ffef17 	ldw	r3,-68(fp)
 d032be4:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 d032be8:	e13fd917 	ldw	r4,-156(fp)
 d032bec:	d02a3900 	call	d02a390 <m_free>
            GOTO_DROP;
 d032bf0:	0080c684 	movi	r2,794
 d032bf4:	d0a0b215 	stw	r2,-32056(gp)
 d032bf8:	00063606 	br	d0344d4 <tcp_input+0x2510>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 d032bfc:	e0ffec17 	ldw	r3,-80(fp)
 d032c00:	e0bff117 	ldw	r2,-60(fp)
 d032c04:	18800a15 	stw	r2,40(r3)
         
         (void) m_free (am);
 d032c08:	e13fd917 	ldw	r4,-156(fp)
 d032c0c:	d02a3900 	call	d02a390 <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 d032c10:	e13fe717 	ldw	r4,-100(fp)
 d032c14:	d035f5c0 	call	d035f5c <tcp_template>
 d032c18:	1007883a 	mov	r3,r2
 d032c1c:	e0bfe717 	ldw	r2,-100(fp)
 d032c20:	10c00c15 	stw	r3,48(r2)
         if (tp->t_template == 0) 
 d032c24:	e0bfe717 	ldw	r2,-100(fp)
 d032c28:	10800c17 	ldw	r2,48(r2)
 d032c2c:	1004c03a 	cmpne	r2,r2,zero
 d032c30:	1000071e 	bne	r2,zero,d032c50 <tcp_input+0xc8c>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 d032c34:	e13fe717 	ldw	r4,-100(fp)
 d032c38:	01401a44 	movi	r5,105
 d032c3c:	d0366140 	call	d036614 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 d032c40:	e03fe015 	stw	zero,-128(fp)
            GOTO_DROP;
 d032c44:	0080d1c4 	movi	r2,839
 d032c48:	d0a0b215 	stw	r2,-32056(gp)
 d032c4c:	00062106 	br	d0344d4 <tcp_input+0x2510>
         }
         if (om) 
 d032c50:	e0bfeb17 	ldw	r2,-84(fp)
 d032c54:	1005003a 	cmpeq	r2,r2,zero
 d032c58:	1000051e 	bne	r2,zero,d032c70 <tcp_input+0xcac>
         {
            tcp_dooptions(tp, om, ti);
 d032c5c:	e13fe717 	ldw	r4,-100(fp)
 d032c60:	e17feb17 	ldw	r5,-84(fp)
 d032c64:	e1bfed17 	ldw	r6,-76(fp)
 d032c68:	d0345180 	call	d034518 <tcp_dooptions>
            om = 0;
 d032c6c:	e03feb15 	stw	zero,-84(fp)
         }
         if (iss)
 d032c70:	e0bfdf17 	ldw	r2,-132(fp)
 d032c74:	1005003a 	cmpeq	r2,r2,zero
 d032c78:	1000041e 	bne	r2,zero,d032c8c <tcp_input+0xcc8>
            tp->iss = iss;
 d032c7c:	e0ffdf17 	ldw	r3,-132(fp)
 d032c80:	e0bfe717 	ldw	r2,-100(fp)
 d032c84:	10c01315 	stw	r3,76(r2)
 d032c88:	00000506 	br	d032ca0 <tcp_input+0xcdc>
         else
            tp->iss = tcp_iss;
 d032c8c:	00834174 	movhi	r2,3333
 d032c90:	108ad604 	addi	r2,r2,11096
 d032c94:	10c00017 	ldw	r3,0(r2)
 d032c98:	e0bfe717 	ldw	r2,-100(fp)
 d032c9c:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 d032ca0:	00834174 	movhi	r2,3333
 d032ca4:	108ad604 	addi	r2,r2,11096
 d032ca8:	10c00017 	ldw	r3,0(r2)
 d032cac:	00be9fd4 	movui	r2,64127
 d032cb0:	1887883a 	add	r3,r3,r2
 d032cb4:	00834174 	movhi	r2,3333
 d032cb8:	108ad604 	addi	r2,r2,11096
 d032cbc:	10c00015 	stw	r3,0(r2)
         tp->irs = ti->ti_seq;
 d032cc0:	e0bfed17 	ldw	r2,-76(fp)
 d032cc4:	10c00617 	ldw	r3,24(r2)
 d032cc8:	e0bfe717 	ldw	r2,-100(fp)
 d032ccc:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 d032cd0:	e0bfe717 	ldw	r2,-100(fp)
 d032cd4:	10c01317 	ldw	r3,76(r2)
 d032cd8:	e0bfe717 	ldw	r2,-100(fp)
 d032cdc:	10c01015 	stw	r3,64(r2)
 d032ce0:	e0bfe717 	ldw	r2,-100(fp)
 d032ce4:	10c01017 	ldw	r3,64(r2)
 d032ce8:	e0bfe717 	ldw	r2,-100(fp)
 d032cec:	10c01a15 	stw	r3,104(r2)
 d032cf0:	e0bfe717 	ldw	r2,-100(fp)
 d032cf4:	10c01a17 	ldw	r3,104(r2)
 d032cf8:	e0bfe717 	ldw	r2,-100(fp)
 d032cfc:	10c00f15 	stw	r3,60(r2)
 d032d00:	e0bfe717 	ldw	r2,-100(fp)
 d032d04:	10c00f17 	ldw	r3,60(r2)
 d032d08:	e0bfe717 	ldw	r2,-100(fp)
 d032d0c:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 d032d10:	e0bfe717 	ldw	r2,-100(fp)
 d032d14:	10801817 	ldw	r2,96(r2)
 d032d18:	10c00044 	addi	r3,r2,1
 d032d1c:	e0bfe717 	ldw	r2,-100(fp)
 d032d20:	10c01615 	stw	r3,88(r2)
 d032d24:	e0bfe717 	ldw	r2,-100(fp)
 d032d28:	10c01617 	ldw	r3,88(r2)
 d032d2c:	e0bfe717 	ldw	r2,-100(fp)
 d032d30:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 d032d34:	e0bfe717 	ldw	r2,-100(fp)
 d032d38:	10800b0b 	ldhu	r2,44(r2)
 d032d3c:	10800054 	ori	r2,r2,1
 d032d40:	1007883a 	mov	r3,r2
 d032d44:	e0bfe717 	ldw	r2,-100(fp)
 d032d48:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 d032d4c:	e0ffe717 	ldw	r3,-100(fp)
 d032d50:	008000c4 	movi	r2,3
 d032d54:	18800215 	stw	r2,8(r3)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 d032d58:	e0ffe717 	ldw	r3,-100(fp)
 d032d5c:	00802584 	movi	r2,150
 d032d60:	18800515 	stw	r2,20(r3)
         dropsocket = 0;      /* committed to socket */
 d032d64:	e03fe015 	stw	zero,-128(fp)
         tcpstat.tcps_accepts++;
 d032d68:	008341b4 	movhi	r2,3334
 d032d6c:	10b41504 	addi	r2,r2,-12204
 d032d70:	10800117 	ldw	r2,4(r2)
 d032d74:	10c00044 	addi	r3,r2,1
 d032d78:	008341b4 	movhi	r2,3334
 d032d7c:	10b41504 	addi	r2,r2,-12204
 d032d80:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 d032d84:	00009d06 	br	d032ffc <tcp_input+0x1038>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 d032d88:	e0ffec17 	ldw	r3,-80(fp)
 d032d8c:	e0bff117 	ldw	r2,-60(fp)
 d032d90:	18800a15 	stw	r2,40(r3)
      if ((tiflags & TH_ACK) &&
 d032d94:	e0bfe617 	ldw	r2,-104(fp)
 d032d98:	1080040c 	andi	r2,r2,16
 d032d9c:	1005003a 	cmpeq	r2,r2,zero
 d032da0:	1000111e 	bne	r2,zero,d032de8 <tcp_input+0xe24>
 d032da4:	e0bfed17 	ldw	r2,-76(fp)
 d032da8:	10c00717 	ldw	r3,28(r2)
 d032dac:	e0bfe717 	ldw	r2,-100(fp)
 d032db0:	10801317 	ldw	r2,76(r2)
 d032db4:	1885c83a 	sub	r2,r3,r2
 d032db8:	10800050 	cmplti	r2,r2,1
 d032dbc:	1000071e 	bne	r2,zero,d032ddc <tcp_input+0xe18>
 d032dc0:	e0bfed17 	ldw	r2,-76(fp)
 d032dc4:	10c00717 	ldw	r3,28(r2)
 d032dc8:	e0bfe717 	ldw	r2,-100(fp)
 d032dcc:	10801a17 	ldw	r2,104(r2)
 d032dd0:	1885c83a 	sub	r2,r3,r2
 d032dd4:	10800050 	cmplti	r2,r2,1
 d032dd8:	1000031e 	bne	r2,zero,d032de8 <tcp_input+0xe24>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 d032ddc:	0080dc04 	movi	r2,880
 d032de0:	d0a0b215 	stw	r2,-32056(gp)
 d032de4:	00057706 	br	d0343c4 <tcp_input+0x2400>
      }
      if (tiflags & TH_RST) 
 d032de8:	e0bfe617 	ldw	r2,-104(fp)
 d032dec:	1080010c 	andi	r2,r2,4
 d032df0:	1005003a 	cmpeq	r2,r2,zero
 d032df4:	10000a1e 	bne	r2,zero,d032e20 <tcp_input+0xe5c>
      {
         if (tiflags & TH_ACK)
 d032df8:	e0bfe617 	ldw	r2,-104(fp)
 d032dfc:	1080040c 	andi	r2,r2,16
 d032e00:	1005003a 	cmpeq	r2,r2,zero
 d032e04:	1000031e 	bne	r2,zero,d032e14 <tcp_input+0xe50>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 d032e08:	e13fe717 	ldw	r4,-100(fp)
 d032e0c:	01401bc4 	movi	r5,111
 d032e10:	d0366140 	call	d036614 <tcp_drop>
         GOTO_DROP;
 d032e14:	0080dd84 	movi	r2,886
 d032e18:	d0a0b215 	stw	r2,-32056(gp)
 d032e1c:	0005ad06 	br	d0344d4 <tcp_input+0x2510>
      }
      if ((tiflags & TH_SYN) == 0)
 d032e20:	e0bfe617 	ldw	r2,-104(fp)
 d032e24:	1080008c 	andi	r2,r2,2
 d032e28:	1004c03a 	cmpne	r2,r2,zero
 d032e2c:	1000031e 	bne	r2,zero,d032e3c <tcp_input+0xe78>
         GOTO_DROP;
 d032e30:	0080de44 	movi	r2,889
 d032e34:	d0a0b215 	stw	r2,-32056(gp)
 d032e38:	0005a606 	br	d0344d4 <tcp_input+0x2510>
      if (tiflags & TH_ACK) 
 d032e3c:	e0bfe617 	ldw	r2,-104(fp)
 d032e40:	1080040c 	andi	r2,r2,16
 d032e44:	1005003a 	cmpeq	r2,r2,zero
 d032e48:	10000f1e 	bne	r2,zero,d032e88 <tcp_input+0xec4>
      {
         tp->snd_una = ti->ti_ack;
 d032e4c:	e0bfed17 	ldw	r2,-76(fp)
 d032e50:	10c00717 	ldw	r3,28(r2)
 d032e54:	e0bfe717 	ldw	r2,-100(fp)
 d032e58:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 d032e5c:	e0bfe717 	ldw	r2,-100(fp)
 d032e60:	10c00f17 	ldw	r3,60(r2)
 d032e64:	e0bfe717 	ldw	r2,-100(fp)
 d032e68:	10800e17 	ldw	r2,56(r2)
 d032e6c:	1885c83a 	sub	r2,r3,r2
 d032e70:	1004403a 	cmpge	r2,r2,zero
 d032e74:	1000041e 	bne	r2,zero,d032e88 <tcp_input+0xec4>
            tp->snd_nxt = tp->snd_una;
 d032e78:	e0bfe717 	ldw	r2,-100(fp)
 d032e7c:	10c00e17 	ldw	r3,56(r2)
 d032e80:	e0bfe717 	ldw	r2,-100(fp)
 d032e84:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 d032e88:	e0bfe717 	ldw	r2,-100(fp)
 d032e8c:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 d032e90:	e0bfed17 	ldw	r2,-76(fp)
 d032e94:	10c00617 	ldw	r3,24(r2)
 d032e98:	e0bfe717 	ldw	r2,-100(fp)
 d032e9c:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 d032ea0:	e0bfe717 	ldw	r2,-100(fp)
 d032ea4:	10801817 	ldw	r2,96(r2)
 d032ea8:	10c00044 	addi	r3,r2,1
 d032eac:	e0bfe717 	ldw	r2,-100(fp)
 d032eb0:	10c01615 	stw	r3,88(r2)
 d032eb4:	e0bfe717 	ldw	r2,-100(fp)
 d032eb8:	10c01617 	ldw	r3,88(r2)
 d032ebc:	e0bfe717 	ldw	r2,-100(fp)
 d032ec0:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 d032ec4:	e0bfec17 	ldw	r2,-80(fp)
 d032ec8:	10c00417 	ldw	r3,16(r2)
 d032ecc:	e0bfed17 	ldw	r2,-76(fp)
 d032ed0:	10800417 	ldw	r2,16(r2)
 d032ed4:	18801926 	beq	r3,r2,d032f3c <tcp_input+0xf78>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 d032ed8:	e0bff017 	ldw	r2,-64(fp)
 d032edc:	10800117 	ldw	r2,4(r2)
 d032ee0:	10800617 	ldw	r2,24(r2)
 d032ee4:	1005003a 	cmpeq	r2,r2,zero
 d032ee8:	1000141e 	bne	r2,zero,d032f3c <tcp_input+0xf78>
 d032eec:	e0bff017 	ldw	r2,-64(fp)
 d032ef0:	10800117 	ldw	r2,4(r2)
 d032ef4:	10800617 	ldw	r2,24(r2)
 d032ef8:	10c00a17 	ldw	r3,40(r2)
 d032efc:	e0bfed17 	ldw	r2,-76(fp)
 d032f00:	10800417 	ldw	r2,16(r2)
 d032f04:	18800d1e 	bne	r3,r2,d032f3c <tcp_input+0xf78>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 d032f08:	e0bfed17 	ldw	r2,-76(fp)
 d032f0c:	10c00417 	ldw	r3,16(r2)
 d032f10:	e0bfec17 	ldw	r2,-80(fp)
 d032f14:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 d032f18:	e0bfe717 	ldw	r2,-100(fp)
 d032f1c:	10800c17 	ldw	r2,48(r2)
 d032f20:	1005003a 	cmpeq	r2,r2,zero
 d032f24:	1000051e 	bne	r2,zero,d032f3c <tcp_input+0xf78>
               tp->t_template->ti_src = ti->ti_dst;
 d032f28:	e0bfe717 	ldw	r2,-100(fp)
 d032f2c:	10c00c17 	ldw	r3,48(r2)
 d032f30:	e0bfed17 	ldw	r2,-76(fp)
 d032f34:	10800417 	ldw	r2,16(r2)
 d032f38:	18800315 	stw	r2,12(r3)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 d032f3c:	e0bfe717 	ldw	r2,-100(fp)
 d032f40:	10800b0b 	ldhu	r2,44(r2)
 d032f44:	10800054 	ori	r2,r2,1
 d032f48:	1007883a 	mov	r3,r2
 d032f4c:	e0bfe717 	ldw	r2,-100(fp)
 d032f50:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 d032f54:	e0bfe617 	ldw	r2,-104(fp)
 d032f58:	1080040c 	andi	r2,r2,16
 d032f5c:	1005003a 	cmpeq	r2,r2,zero
 d032f60:	1000231e 	bne	r2,zero,d032ff0 <tcp_input+0x102c>
 d032f64:	e0bfe717 	ldw	r2,-100(fp)
 d032f68:	10c00e17 	ldw	r3,56(r2)
 d032f6c:	e0bfe717 	ldw	r2,-100(fp)
 d032f70:	10801317 	ldw	r2,76(r2)
 d032f74:	1885c83a 	sub	r2,r3,r2
 d032f78:	10800050 	cmplti	r2,r2,1
 d032f7c:	10001c1e 	bne	r2,zero,d032ff0 <tcp_input+0x102c>
      {
         tcpstat.tcps_connects++;
 d032f80:	008341b4 	movhi	r2,3334
 d032f84:	10b41504 	addi	r2,r2,-12204
 d032f88:	10800217 	ldw	r2,8(r2)
 d032f8c:	10c00044 	addi	r3,r2,1
 d032f90:	008341b4 	movhi	r2,3334
 d032f94:	10b41504 	addi	r2,r2,-12204
 d032f98:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 d032f9c:	e0ffe717 	ldw	r3,-100(fp)
 d032fa0:	00800104 	movi	r2,4
 d032fa4:	18800215 	stw	r2,8(r3)
         soisconnected (so);
 d032fa8:	e13fe517 	ldw	r4,-108(fp)
 d032fac:	d02fffc0 	call	d02fffc <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 d032fb0:	e13fe517 	ldw	r4,-108(fp)
 d032fb4:	d034a880 	call	d034a88 <tcp_mss>
 d032fb8:	1007883a 	mov	r3,r2
 d032fbc:	e0bfe717 	ldw	r2,-100(fp)
 d032fc0:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 d032fc4:	e13fe717 	ldw	r4,-100(fp)
 d032fc8:	000b883a 	mov	r5,zero
 d032fcc:	e1bff017 	ldw	r6,-64(fp)
 d032fd0:	d031bbc0 	call	d031bbc <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 d032fd4:	e0bfe717 	ldw	r2,-100(fp)
 d032fd8:	10801e17 	ldw	r2,120(r2)
 d032fdc:	1005003a 	cmpeq	r2,r2,zero
 d032fe0:	1000061e 	bne	r2,zero,d032ffc <tcp_input+0x1038>
         {
            tcp_xmit_timer(tp);
 d032fe4:	e13fe717 	ldw	r4,-100(fp)
 d032fe8:	d0347d40 	call	d0347d4 <tcp_xmit_timer>
            if (tp->t_template != NULL)
               tp->t_template->ti_src = ti->ti_dst;
         }
      }
      tp->t_flags |= TF_ACKNOW;
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 d032fec:	00000306 	br	d032ffc <tcp_input+0x1038>
         if (tp->t_rttick) 
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 d032ff0:	e0ffe717 	ldw	r3,-100(fp)
 d032ff4:	008000c4 	movi	r2,3
 d032ff8:	18800215 	stw	r2,8(r3)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 d032ffc:	e0bfed17 	ldw	r2,-76(fp)
 d033000:	10800617 	ldw	r2,24(r2)
 d033004:	10c00044 	addi	r3,r2,1
 d033008:	e0bfed17 	ldw	r2,-76(fp)
 d03300c:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 d033010:	e0bfed17 	ldw	r2,-76(fp)
 d033014:	1080028b 	ldhu	r2,10(r2)
 d033018:	10ffffcc 	andi	r3,r2,65535
 d03301c:	e0bfe717 	ldw	r2,-100(fp)
 d033020:	10801517 	ldw	r2,84(r2)
 d033024:	10c02e2e 	bgeu	r2,r3,d0330e0 <tcp_input+0x111c>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 d033028:	e0bfed17 	ldw	r2,-76(fp)
 d03302c:	1080028b 	ldhu	r2,10(r2)
 d033030:	10ffffcc 	andi	r3,r2,65535
 d033034:	e0bfe717 	ldw	r2,-100(fp)
 d033038:	10801517 	ldw	r2,84(r2)
 d03303c:	10bfffcc 	andi	r2,r2,65535
 d033040:	1885c83a 	sub	r2,r3,r2
 d033044:	e0bfe415 	stw	r2,-112(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 d033048:	e0bff017 	ldw	r2,-64(fp)
 d03304c:	10800217 	ldw	r2,8(r2)
 d033050:	1005003a 	cmpeq	r2,r2,zero
 d033054:	1000051e 	bne	r2,zero,d03306c <tcp_input+0x10a8>
         {
            m_adj(m, -todrop);
 d033058:	e0bfe417 	ldw	r2,-112(fp)
 d03305c:	008bc83a 	sub	r5,zero,r2
 d033060:	e13ff017 	ldw	r4,-64(fp)
 d033064:	d02a82c0 	call	d02a82c <m_adj>
 d033068:	00000506 	br	d033080 <tcp_input+0x10bc>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 d03306c:	e0bff017 	ldw	r2,-64(fp)
 d033070:	11000617 	ldw	r4,24(r2)
 d033074:	e0bfe417 	ldw	r2,-112(fp)
 d033078:	008bc83a 	sub	r5,zero,r2
 d03307c:	d02a82c0 	call	d02a82c <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 d033080:	e0bfe717 	ldw	r2,-100(fp)
 d033084:	10801517 	ldw	r2,84(r2)
 d033088:	1007883a 	mov	r3,r2
 d03308c:	e0bfed17 	ldw	r2,-76(fp)
 d033090:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 d033094:	e0ffe617 	ldw	r3,-104(fp)
 d033098:	00bfff84 	movi	r2,-2
 d03309c:	1884703a 	and	r2,r3,r2
 d0330a0:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpackafterwin++;
 d0330a4:	008341b4 	movhi	r2,3334
 d0330a8:	10b41504 	addi	r2,r2,-12204
 d0330ac:	10802517 	ldw	r2,148(r2)
 d0330b0:	10c00044 	addi	r3,r2,1
 d0330b4:	008341b4 	movhi	r2,3334
 d0330b8:	10b41504 	addi	r2,r2,-12204
 d0330bc:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 d0330c0:	008341b4 	movhi	r2,3334
 d0330c4:	10b41504 	addi	r2,r2,-12204
 d0330c8:	10c02617 	ldw	r3,152(r2)
 d0330cc:	e0bfe417 	ldw	r2,-112(fp)
 d0330d0:	1887883a 	add	r3,r3,r2
 d0330d4:	008341b4 	movhi	r2,3334
 d0330d8:	10b41504 	addi	r2,r2,-12204
 d0330dc:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 d0330e0:	e0bfed17 	ldw	r2,-76(fp)
 d0330e4:	10800617 	ldw	r2,24(r2)
 d0330e8:	10ffffc4 	addi	r3,r2,-1
 d0330ec:	e0bfe717 	ldw	r2,-100(fp)
 d0330f0:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 d0330f4:	e0bfed17 	ldw	r2,-76(fp)
 d0330f8:	10c00617 	ldw	r3,24(r2)
 d0330fc:	e0bfe717 	ldw	r2,-100(fp)
 d033100:	10c01715 	stw	r3,92(r2)
      goto step6;
 d033104:	00032406 	br	d033d98 <tcp_input+0x1dd4>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 d033108:	e0bfe717 	ldw	r2,-100(fp)
 d03310c:	10c01617 	ldw	r3,88(r2)
 d033110:	e0bfed17 	ldw	r2,-76(fp)
 d033114:	10800617 	ldw	r2,24(r2)
 d033118:	1885c83a 	sub	r2,r3,r2
 d03311c:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 d033120:	e0bfe417 	ldw	r2,-112(fp)
 d033124:	10800050 	cmplti	r2,r2,1
 d033128:	1000971e 	bne	r2,zero,d033388 <tcp_input+0x13c4>
   {
      if (tiflags & TH_SYN) 
 d03312c:	e0bfe617 	ldw	r2,-104(fp)
 d033130:	1080008c 	andi	r2,r2,2
 d033134:	1005003a 	cmpeq	r2,r2,zero
 d033138:	10001c1e 	bne	r2,zero,d0331ac <tcp_input+0x11e8>
      {
         tiflags &= ~TH_SYN;
 d03313c:	e0ffe617 	ldw	r3,-104(fp)
 d033140:	00bfff44 	movi	r2,-3
 d033144:	1884703a 	and	r2,r3,r2
 d033148:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_seq++;
 d03314c:	e0bfed17 	ldw	r2,-76(fp)
 d033150:	10800617 	ldw	r2,24(r2)
 d033154:	10c00044 	addi	r3,r2,1
 d033158:	e0bfed17 	ldw	r2,-76(fp)
 d03315c:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 d033160:	e0bfed17 	ldw	r2,-76(fp)
 d033164:	1080098b 	ldhu	r2,38(r2)
 d033168:	10bfffcc 	andi	r2,r2,65535
 d03316c:	108000b0 	cmpltui	r2,r2,2
 d033170:	1000071e 	bne	r2,zero,d033190 <tcp_input+0x11cc>
            ti->ti_urp--;
 d033174:	e0bfed17 	ldw	r2,-76(fp)
 d033178:	1080098b 	ldhu	r2,38(r2)
 d03317c:	10bfffc4 	addi	r2,r2,-1
 d033180:	1007883a 	mov	r3,r2
 d033184:	e0bfed17 	ldw	r2,-76(fp)
 d033188:	10c0098d 	sth	r3,38(r2)
 d03318c:	00000406 	br	d0331a0 <tcp_input+0x11dc>
         else
            tiflags &= ~TH_URG;
 d033190:	e0bfe617 	ldw	r2,-104(fp)
 d033194:	00fff7c4 	movi	r3,-33
 d033198:	10c4703a 	and	r2,r2,r3
 d03319c:	e0bfe615 	stw	r2,-104(fp)
         todrop--;
 d0331a0:	e0bfe417 	ldw	r2,-112(fp)
 d0331a4:	10bfffc4 	addi	r2,r2,-1
 d0331a8:	e0bfe415 	stw	r2,-112(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 d0331ac:	e0bfed17 	ldw	r2,-76(fp)
 d0331b0:	1080028b 	ldhu	r2,10(r2)
 d0331b4:	10ffffcc 	andi	r3,r2,65535
 d0331b8:	e0bfe417 	ldw	r2,-112(fp)
 d0331bc:	18800916 	blt	r3,r2,d0331e4 <tcp_input+0x1220>
 d0331c0:	e0bfed17 	ldw	r2,-76(fp)
 d0331c4:	1080028b 	ldhu	r2,10(r2)
 d0331c8:	10ffffcc 	andi	r3,r2,65535
 d0331cc:	e0bfe417 	ldw	r2,-112(fp)
 d0331d0:	18803a1e 	bne	r3,r2,d0332bc <tcp_input+0x12f8>
 d0331d4:	e0bfe617 	ldw	r2,-104(fp)
 d0331d8:	1080004c 	andi	r2,r2,1
 d0331dc:	1004c03a 	cmpne	r2,r2,zero
 d0331e0:	1000361e 	bne	r2,zero,d0332bc <tcp_input+0x12f8>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 d0331e4:	008341b4 	movhi	r2,3334
 d0331e8:	10b41504 	addi	r2,r2,-12204
 d0331ec:	10801f17 	ldw	r2,124(r2)
 d0331f0:	10c00044 	addi	r3,r2,1
 d0331f4:	008341b4 	movhi	r2,3334
 d0331f8:	10b41504 	addi	r2,r2,-12204
 d0331fc:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 d033200:	008341b4 	movhi	r2,3334
 d033204:	10b41504 	addi	r2,r2,-12204
 d033208:	10c02017 	ldw	r3,128(r2)
 d03320c:	e0bfed17 	ldw	r2,-76(fp)
 d033210:	1080028b 	ldhu	r2,10(r2)
 d033214:	10bfffcc 	andi	r2,r2,65535
 d033218:	1887883a 	add	r3,r3,r2
 d03321c:	008341b4 	movhi	r2,3334
 d033220:	10b41504 	addi	r2,r2,-12204
 d033224:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 d033228:	e0bfe617 	ldw	r2,-104(fp)
 d03322c:	1080004c 	andi	r2,r2,1
 d033230:	1080005c 	xori	r2,r2,1
 d033234:	10803fcc 	andi	r2,r2,255
 d033238:	1004c03a 	cmpne	r2,r2,zero
 d03323c:	1000061e 	bne	r2,zero,d033258 <tcp_input+0x1294>
 d033240:	e0bfed17 	ldw	r2,-76(fp)
 d033244:	1080028b 	ldhu	r2,10(r2)
 d033248:	10bfffcc 	andi	r2,r2,65535
 d03324c:	10c00044 	addi	r3,r2,1
 d033250:	e0bfe417 	ldw	r2,-112(fp)
 d033254:	18800a26 	beq	r3,r2,d033280 <tcp_input+0x12bc>
 d033258:	e0bfe617 	ldw	r2,-104(fp)
 d03325c:	1080010c 	andi	r2,r2,4
 d033260:	1005003a 	cmpeq	r2,r2,zero
 d033264:	1004451e 	bne	r2,zero,d03437c <tcp_input+0x23b8>
 d033268:	e0bfed17 	ldw	r2,-76(fp)
 d03326c:	10c00617 	ldw	r3,24(r2)
 d033270:	e0bfe717 	ldw	r2,-100(fp)
 d033274:	10801617 	ldw	r2,88(r2)
 d033278:	10bfffc4 	addi	r2,r2,-1
 d03327c:	18843f1e 	bne	r3,r2,d03437c <tcp_input+0x23b8>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
         {
            todrop = ti->ti_len;
 d033280:	e0bfed17 	ldw	r2,-76(fp)
 d033284:	1080028b 	ldhu	r2,10(r2)
 d033288:	10bfffcc 	andi	r2,r2,65535
 d03328c:	e0bfe415 	stw	r2,-112(fp)
            tiflags &= ~TH_FIN;
 d033290:	e0ffe617 	ldw	r3,-104(fp)
 d033294:	00bfff84 	movi	r2,-2
 d033298:	1884703a 	and	r2,r3,r2
 d03329c:	e0bfe615 	stw	r2,-104(fp)
            tp->t_flags |= TF_ACKNOW;
 d0332a0:	e0bfe717 	ldw	r2,-100(fp)
 d0332a4:	10800b0b 	ldhu	r2,44(r2)
 d0332a8:	10800054 	ori	r2,r2,1
 d0332ac:	1007883a 	mov	r3,r2
 d0332b0:	e0bfe717 	ldw	r2,-100(fp)
 d0332b4:	10c00b0d 	sth	r3,44(r2)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 d0332b8:	00000f06 	br	d0332f8 <tcp_input+0x1334>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 d0332bc:	008341b4 	movhi	r2,3334
 d0332c0:	10b41504 	addi	r2,r2,-12204
 d0332c4:	10802117 	ldw	r2,132(r2)
 d0332c8:	10c00044 	addi	r3,r2,1
 d0332cc:	008341b4 	movhi	r2,3334
 d0332d0:	10b41504 	addi	r2,r2,-12204
 d0332d4:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 d0332d8:	008341b4 	movhi	r2,3334
 d0332dc:	10b41504 	addi	r2,r2,-12204
 d0332e0:	10c02217 	ldw	r3,136(r2)
 d0332e4:	e0bfe417 	ldw	r2,-112(fp)
 d0332e8:	1887883a 	add	r3,r3,r2
 d0332ec:	008341b4 	movhi	r2,3334
 d0332f0:	10b41504 	addi	r2,r2,-12204
 d0332f4:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 d0332f8:	e13ff017 	ldw	r4,-64(fp)
 d0332fc:	e17fe417 	ldw	r5,-112(fp)
 d033300:	d02a82c0 	call	d02a82c <m_adj>
      ti->ti_seq += todrop;
 d033304:	e0bfed17 	ldw	r2,-76(fp)
 d033308:	10c00617 	ldw	r3,24(r2)
 d03330c:	e0bfe417 	ldw	r2,-112(fp)
 d033310:	1887883a 	add	r3,r3,r2
 d033314:	e0bfed17 	ldw	r2,-76(fp)
 d033318:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 d03331c:	e0bfed17 	ldw	r2,-76(fp)
 d033320:	10c0028b 	ldhu	r3,10(r2)
 d033324:	e0bfe417 	ldw	r2,-112(fp)
 d033328:	1885c83a 	sub	r2,r3,r2
 d03332c:	1007883a 	mov	r3,r2
 d033330:	e0bfed17 	ldw	r2,-76(fp)
 d033334:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 d033338:	e0bfed17 	ldw	r2,-76(fp)
 d03333c:	10c0098b 	ldhu	r3,38(r2)
 d033340:	e0bfe417 	ldw	r2,-112(fp)
 d033344:	18ffffcc 	andi	r3,r3,65535
 d033348:	10bfffcc 	andi	r2,r2,65535
 d03334c:	10c0082e 	bgeu	r2,r3,d033370 <tcp_input+0x13ac>
         ti->ti_urp -= (u_short)todrop;
 d033350:	e0bfed17 	ldw	r2,-76(fp)
 d033354:	10c0098b 	ldhu	r3,38(r2)
 d033358:	e0bfe417 	ldw	r2,-112(fp)
 d03335c:	1885c83a 	sub	r2,r3,r2
 d033360:	1007883a 	mov	r3,r2
 d033364:	e0bfed17 	ldw	r2,-76(fp)
 d033368:	10c0098d 	sth	r3,38(r2)
 d03336c:	00000606 	br	d033388 <tcp_input+0x13c4>
      else 
      {
         tiflags &= ~TH_URG;
 d033370:	e0ffe617 	ldw	r3,-104(fp)
 d033374:	00bff7c4 	movi	r2,-33
 d033378:	1884703a 	and	r2,r3,r2
 d03337c:	e0bfe615 	stw	r2,-104(fp)
         ti->ti_urp = 0;
 d033380:	e0bfed17 	ldw	r2,-76(fp)
 d033384:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 d033388:	e0bfe517 	ldw	r2,-108(fp)
 d03338c:	1080088b 	ldhu	r2,34(r2)
 d033390:	10bfffcc 	andi	r2,r2,65535
 d033394:	1080004c 	andi	r2,r2,1
 d033398:	10803fcc 	andi	r2,r2,255
 d03339c:	1005003a 	cmpeq	r2,r2,zero
 d0333a0:	1000161e 	bne	r2,zero,d0333fc <tcp_input+0x1438>
 d0333a4:	e0bfe717 	ldw	r2,-100(fp)
 d0333a8:	10800217 	ldw	r2,8(r2)
 d0333ac:	10800190 	cmplti	r2,r2,6
 d0333b0:	1000121e 	bne	r2,zero,d0333fc <tcp_input+0x1438>
 d0333b4:	e0bfed17 	ldw	r2,-76(fp)
 d0333b8:	1080028b 	ldhu	r2,10(r2)
 d0333bc:	10bfffcc 	andi	r2,r2,65535
 d0333c0:	1005003a 	cmpeq	r2,r2,zero
 d0333c4:	10000d1e 	bne	r2,zero,d0333fc <tcp_input+0x1438>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
   {
      tp = tcp_close(tp);
 d0333c8:	e13fe717 	ldw	r4,-100(fp)
 d0333cc:	d0366c00 	call	d0366c0 <tcp_close>
 d0333d0:	e0bfe715 	stw	r2,-100(fp)
      tcpstat.tcps_rcvafterclose++;
 d0333d4:	008341b4 	movhi	r2,3334
 d0333d8:	10b41504 	addi	r2,r2,-12204
 d0333dc:	10802717 	ldw	r2,156(r2)
 d0333e0:	10c00044 	addi	r3,r2,1
 d0333e4:	008341b4 	movhi	r2,3334
 d0333e8:	10b41504 	addi	r2,r2,-12204
 d0333ec:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 d0333f0:	00810444 	movi	r2,1041
 d0333f4:	d0a0b215 	stw	r2,-32056(gp)
 d0333f8:	0003f206 	br	d0343c4 <tcp_input+0x2400>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 d0333fc:	e0bfed17 	ldw	r2,-76(fp)
 d033400:	10c00617 	ldw	r3,24(r2)
 d033404:	e0bfed17 	ldw	r2,-76(fp)
 d033408:	1080028b 	ldhu	r2,10(r2)
 d03340c:	10bfffcc 	andi	r2,r2,65535
 d033410:	10a0001c 	xori	r2,r2,32768
 d033414:	10a00004 	addi	r2,r2,-32768
 d033418:	1889883a 	add	r4,r3,r2
 d03341c:	e0bfe717 	ldw	r2,-100(fp)
 d033420:	10c01617 	ldw	r3,88(r2)
 d033424:	e0bfe717 	ldw	r2,-100(fp)
 d033428:	10801517 	ldw	r2,84(r2)
 d03342c:	1885883a 	add	r2,r3,r2
 d033430:	2085c83a 	sub	r2,r4,r2
 d033434:	e0bfe415 	stw	r2,-112(fp)
   if (todrop > 0) 
 d033438:	e0bfe417 	ldw	r2,-112(fp)
 d03343c:	10800050 	cmplti	r2,r2,1
 d033440:	10006b1e 	bne	r2,zero,d0335f0 <tcp_input+0x162c>
   {
      tcpstat.tcps_rcvpackafterwin++;
 d033444:	008341b4 	movhi	r2,3334
 d033448:	10b41504 	addi	r2,r2,-12204
 d03344c:	10802517 	ldw	r2,148(r2)
 d033450:	10c00044 	addi	r3,r2,1
 d033454:	008341b4 	movhi	r2,3334
 d033458:	10b41504 	addi	r2,r2,-12204
 d03345c:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 d033460:	e0bfed17 	ldw	r2,-76(fp)
 d033464:	1080028b 	ldhu	r2,10(r2)
 d033468:	10ffffcc 	andi	r3,r2,65535
 d03346c:	e0bfe417 	ldw	r2,-112(fp)
 d033470:	10c03e16 	blt	r2,r3,d03356c <tcp_input+0x15a8>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 d033474:	008341b4 	movhi	r2,3334
 d033478:	10b41504 	addi	r2,r2,-12204
 d03347c:	10c02617 	ldw	r3,152(r2)
 d033480:	e0bfed17 	ldw	r2,-76(fp)
 d033484:	1080028b 	ldhu	r2,10(r2)
 d033488:	10bfffcc 	andi	r2,r2,65535
 d03348c:	1887883a 	add	r3,r3,r2
 d033490:	008341b4 	movhi	r2,3334
 d033494:	10b41504 	addi	r2,r2,-12204
 d033498:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 d03349c:	e0bfe617 	ldw	r2,-104(fp)
 d0334a0:	1080008c 	andi	r2,r2,2
 d0334a4:	1005003a 	cmpeq	r2,r2,zero
 d0334a8:	1000191e 	bne	r2,zero,d033510 <tcp_input+0x154c>
 d0334ac:	e0bfe717 	ldw	r2,-100(fp)
 d0334b0:	10800217 	ldw	r2,8(r2)
 d0334b4:	10800298 	cmpnei	r2,r2,10
 d0334b8:	1000151e 	bne	r2,zero,d033510 <tcp_input+0x154c>
 d0334bc:	e0bfed17 	ldw	r2,-76(fp)
 d0334c0:	10c00617 	ldw	r3,24(r2)
 d0334c4:	e0bfe717 	ldw	r2,-100(fp)
 d0334c8:	10801617 	ldw	r2,88(r2)
 d0334cc:	1885c83a 	sub	r2,r3,r2
 d0334d0:	10800050 	cmplti	r2,r2,1
 d0334d4:	10000e1e 	bne	r2,zero,d033510 <tcp_input+0x154c>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 d0334d8:	e0bfe717 	ldw	r2,-100(fp)
 d0334dc:	10c01617 	ldw	r3,88(r2)
 d0334e0:	008000b4 	movhi	r2,2
 d0334e4:	10bd3fc4 	addi	r2,r2,-2817
 d0334e8:	1885883a 	add	r2,r3,r2
 d0334ec:	e0bfdf15 	stw	r2,-132(fp)
            if (iss & 0xff000000)
 d0334f0:	e0bfdf17 	ldw	r2,-132(fp)
 d0334f4:	10bfc02c 	andhi	r2,r2,65280
 d0334f8:	1005003a 	cmpeq	r2,r2,zero
 d0334fc:	1000011e 	bne	r2,zero,d033504 <tcp_input+0x1540>
            {
               iss = 0L;
 d033500:	e03fdf15 	stw	zero,-132(fp)
            }
            (void) tcp_close(tp);
 d033504:	e13fe717 	ldw	r4,-100(fp)
 d033508:	d0366c00 	call	d0366c0 <tcp_close>
            goto findpcb;
 d03350c:	003b8d06 	br	d032344 <tcp_input+0x380>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 d033510:	e0bfe717 	ldw	r2,-100(fp)
 d033514:	10801517 	ldw	r2,84(r2)
 d033518:	1004c03a 	cmpne	r2,r2,zero
 d03351c:	1003971e 	bne	r2,zero,d03437c <tcp_input+0x23b8>
 d033520:	e0bfed17 	ldw	r2,-76(fp)
 d033524:	10c00617 	ldw	r3,24(r2)
 d033528:	e0bfe717 	ldw	r2,-100(fp)
 d03352c:	10801617 	ldw	r2,88(r2)
 d033530:	1883921e 	bne	r3,r2,d03437c <tcp_input+0x23b8>
         {
            tp->t_flags |= TF_ACKNOW;
 d033534:	e0bfe717 	ldw	r2,-100(fp)
 d033538:	10800b0b 	ldhu	r2,44(r2)
 d03353c:	10800054 	ori	r2,r2,1
 d033540:	1007883a 	mov	r3,r2
 d033544:	e0bfe717 	ldw	r2,-100(fp)
 d033548:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 d03354c:	008341b4 	movhi	r2,3334
 d033550:	10b41504 	addi	r2,r2,-12204
 d033554:	10802817 	ldw	r2,160(r2)
 d033558:	10c00044 	addi	r3,r2,1
 d03355c:	008341b4 	movhi	r2,3334
 d033560:	10b41504 	addi	r2,r2,-12204
 d033564:	10c02815 	stw	r3,160(r2)
 d033568:	00000806 	br	d03358c <tcp_input+0x15c8>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 d03356c:	008341b4 	movhi	r2,3334
 d033570:	10b41504 	addi	r2,r2,-12204
 d033574:	10c02617 	ldw	r3,152(r2)
 d033578:	e0bfe417 	ldw	r2,-112(fp)
 d03357c:	1887883a 	add	r3,r3,r2
 d033580:	008341b4 	movhi	r2,3334
 d033584:	10b41504 	addi	r2,r2,-12204
 d033588:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 d03358c:	e0bff017 	ldw	r2,-64(fp)
 d033590:	10800217 	ldw	r2,8(r2)
 d033594:	1005003a 	cmpeq	r2,r2,zero
 d033598:	1000051e 	bne	r2,zero,d0335b0 <tcp_input+0x15ec>
      {
         m_adj(m, -todrop);
 d03359c:	e0bfe417 	ldw	r2,-112(fp)
 d0335a0:	008bc83a 	sub	r5,zero,r2
 d0335a4:	e13ff017 	ldw	r4,-64(fp)
 d0335a8:	d02a82c0 	call	d02a82c <m_adj>
 d0335ac:	00000506 	br	d0335c4 <tcp_input+0x1600>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 d0335b0:	e0bff017 	ldw	r2,-64(fp)
 d0335b4:	11000617 	ldw	r4,24(r2)
 d0335b8:	e0bfe417 	ldw	r2,-112(fp)
 d0335bc:	008bc83a 	sub	r5,zero,r2
 d0335c0:	d02a82c0 	call	d02a82c <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 d0335c4:	e0bfed17 	ldw	r2,-76(fp)
 d0335c8:	10c0028b 	ldhu	r3,10(r2)
 d0335cc:	e0bfe417 	ldw	r2,-112(fp)
 d0335d0:	1885c83a 	sub	r2,r3,r2
 d0335d4:	1007883a 	mov	r3,r2
 d0335d8:	e0bfed17 	ldw	r2,-76(fp)
 d0335dc:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 d0335e0:	e0ffe617 	ldw	r3,-104(fp)
 d0335e4:	00bffd84 	movi	r2,-10
 d0335e8:	1884703a 	and	r2,r3,r2
 d0335ec:	e0bfe615 	stw	r2,-104(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 d0335f0:	e0bfe617 	ldw	r2,-104(fp)
 d0335f4:	1080010c 	andi	r2,r2,4
 d0335f8:	1005003a 	cmpeq	r2,r2,zero
 d0335fc:	1000391e 	bne	r2,zero,d0336e4 <tcp_input+0x1720>
   {
      switch (tp->t_state) 
 d033600:	e0bfe717 	ldw	r2,-100(fp)
 d033604:	10800217 	ldw	r2,8(r2)
 d033608:	10bfff44 	addi	r2,r2,-3
 d03360c:	e0bffe15 	stw	r2,-8(fp)
 d033610:	e13ffe17 	ldw	r4,-8(fp)
 d033614:	20800228 	cmpgeui	r2,r4,8
 d033618:	1000321e 	bne	r2,zero,d0336e4 <tcp_input+0x1720>
 d03361c:	e0fffe17 	ldw	r3,-8(fp)
 d033620:	e0fffe17 	ldw	r3,-8(fp)
 d033624:	18c5883a 	add	r2,r3,r3
 d033628:	1087883a 	add	r3,r2,r2
 d03362c:	008340f4 	movhi	r2,3331
 d033630:	108d9004 	addi	r2,r2,13888
 d033634:	1885883a 	add	r2,r3,r2
 d033638:	10800017 	ldw	r2,0(r2)
 d03363c:	1000683a 	jmp	r2
 d033640:	0d033660 	cmpeqi	r20,at,3289
 d033644:	0d033670 	cmpltui	r20,at,3289
 d033648:	0d03368c 	andi	r20,at,3290
 d03364c:	0d03368c 	andi	r20,at,3290
 d033650:	0d0336d0 	cmplti	r20,at,3291
 d033654:	0d0336d0 	cmplti	r20,at,3291
 d033658:	0d03368c 	andi	r20,at,3290
 d03365c:	0d0336d0 	cmplti	r20,at,3291
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 d033660:	e0ffe517 	ldw	r3,-108(fp)
 d033664:	00801bc4 	movi	r2,111
 d033668:	18800615 	stw	r2,24(r3)
         goto close;
 d03366c:	00000a06 	br	d033698 <tcp_input+0x16d4>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 d033670:	008341b4 	movhi	r2,3334
 d033674:	10b3e704 	addi	r2,r2,-12388
 d033678:	10800717 	ldw	r2,28(r2)
 d03367c:	10c00044 	addi	r3,r2,1
 d033680:	008341b4 	movhi	r2,3334
 d033684:	10b3e704 	addi	r2,r2,-12388
 d033688:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 d03368c:	e0ffe517 	ldw	r3,-108(fp)
 d033690:	00801a04 	movi	r2,104
 d033694:	18800615 	stw	r2,24(r3)
         close:
         tp->t_state = TCPS_CLOSED;
 d033698:	e0bfe717 	ldw	r2,-100(fp)
 d03369c:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 d0336a0:	008341b4 	movhi	r2,3334
 d0336a4:	10b41504 	addi	r2,r2,-12204
 d0336a8:	10800317 	ldw	r2,12(r2)
 d0336ac:	10c00044 	addi	r3,r2,1
 d0336b0:	008341b4 	movhi	r2,3334
 d0336b4:	10b41504 	addi	r2,r2,-12204
 d0336b8:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 d0336bc:	e13fe717 	ldw	r4,-100(fp)
 d0336c0:	d0366c00 	call	d0366c0 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 d0336c4:	00812204 	movi	r2,1160
 d0336c8:	d0a0b215 	stw	r2,-32056(gp)
 d0336cc:	00038106 	br	d0344d4 <tcp_input+0x2510>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 d0336d0:	e13fe717 	ldw	r4,-100(fp)
 d0336d4:	d0366c00 	call	d0366c0 <tcp_close>
         GOTO_DROP;
 d0336d8:	00812384 	movi	r2,1166
 d0336dc:	d0a0b215 	stw	r2,-32056(gp)
 d0336e0:	00037c06 	br	d0344d4 <tcp_input+0x2510>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 d0336e4:	e0bfe617 	ldw	r2,-104(fp)
 d0336e8:	1080008c 	andi	r2,r2,2
 d0336ec:	1005003a 	cmpeq	r2,r2,zero
 d0336f0:	1000071e 	bne	r2,zero,d033710 <tcp_input+0x174c>
   {
      tp = tcp_drop(tp, ECONNRESET);
 d0336f4:	e13fe717 	ldw	r4,-100(fp)
 d0336f8:	01401a04 	movi	r5,104
 d0336fc:	d0366140 	call	d036614 <tcp_drop>
 d033700:	e0bfe715 	stw	r2,-100(fp)
      GOTO_DROPWITHRESET;
 d033704:	00812b04 	movi	r2,1196
 d033708:	d0a0b215 	stw	r2,-32056(gp)
 d03370c:	00032d06 	br	d0343c4 <tcp_input+0x2400>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 d033710:	e0bfe617 	ldw	r2,-104(fp)
 d033714:	1080040c 	andi	r2,r2,16
 d033718:	1004c03a 	cmpne	r2,r2,zero
 d03371c:	1000031e 	bne	r2,zero,d03372c <tcp_input+0x1768>
      GOTO_DROP;
 d033720:	00812d04 	movi	r2,1204
 d033724:	d0a0b215 	stw	r2,-32056(gp)
 d033728:	00036a06 	br	d0344d4 <tcp_input+0x2510>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 d03372c:	e0bfe717 	ldw	r2,-100(fp)
 d033730:	10800217 	ldw	r2,8(r2)
 d033734:	e0bff715 	stw	r2,-36(fp)
 d033738:	e13ff717 	ldw	r4,-36(fp)
 d03373c:	208000e0 	cmpeqi	r2,r4,3
 d033740:	1000071e 	bne	r2,zero,d033760 <tcp_input+0x179c>
 d033744:	e0fff717 	ldw	r3,-36(fp)
 d033748:	188000d0 	cmplti	r2,r3,3
 d03374c:	1001921e 	bne	r2,zero,d033d98 <tcp_input+0x1dd4>
 d033750:	e13ff717 	ldw	r4,-36(fp)
 d033754:	208002c8 	cmpgei	r2,r4,11
 d033758:	10018f1e 	bne	r2,zero,d033d98 <tcp_input+0x1dd4>
 d03375c:	00003206 	br	d033828 <tcp_input+0x1864>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 d033760:	e0bfe717 	ldw	r2,-100(fp)
 d033764:	10c00e17 	ldw	r3,56(r2)
 d033768:	e0bfed17 	ldw	r2,-76(fp)
 d03376c:	10800717 	ldw	r2,28(r2)
 d033770:	1885c83a 	sub	r2,r3,r2
 d033774:	10800048 	cmpgei	r2,r2,1
 d033778:	1000071e 	bne	r2,zero,d033798 <tcp_input+0x17d4>
 d03377c:	e0bfed17 	ldw	r2,-76(fp)
 d033780:	10c00717 	ldw	r3,28(r2)
 d033784:	e0bfe717 	ldw	r2,-100(fp)
 d033788:	10801a17 	ldw	r2,104(r2)
 d03378c:	1885c83a 	sub	r2,r3,r2
 d033790:	10800050 	cmplti	r2,r2,1
 d033794:	10000a1e 	bne	r2,zero,d0337c0 <tcp_input+0x17fc>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 d033798:	008341b4 	movhi	r2,3334
 d03379c:	10b3e704 	addi	r2,r2,-12388
 d0337a0:	10800717 	ldw	r2,28(r2)
 d0337a4:	10c00044 	addi	r3,r2,1
 d0337a8:	008341b4 	movhi	r2,3334
 d0337ac:	10b3e704 	addi	r2,r2,-12388
 d0337b0:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 d0337b4:	00813184 	movi	r2,1222
 d0337b8:	d0a0b215 	stw	r2,-32056(gp)
 d0337bc:	00030106 	br	d0343c4 <tcp_input+0x2400>
      }
      tcpstat.tcps_connects++;
 d0337c0:	008341b4 	movhi	r2,3334
 d0337c4:	10b41504 	addi	r2,r2,-12204
 d0337c8:	10800217 	ldw	r2,8(r2)
 d0337cc:	10c00044 	addi	r3,r2,1
 d0337d0:	008341b4 	movhi	r2,3334
 d0337d4:	10b41504 	addi	r2,r2,-12204
 d0337d8:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 d0337dc:	e0ffe717 	ldw	r3,-100(fp)
 d0337e0:	00800104 	movi	r2,4
 d0337e4:	18800215 	stw	r2,8(r3)
      soisconnected(so);
 d0337e8:	e13fe517 	ldw	r4,-108(fp)
 d0337ec:	d02fffc0 	call	d02fffc <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 d0337f0:	e13fe517 	ldw	r4,-108(fp)
 d0337f4:	d034a880 	call	d034a88 <tcp_mss>
 d0337f8:	1007883a 	mov	r3,r2
 d0337fc:	e0bfe717 	ldw	r2,-100(fp)
 d033800:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 d033804:	e13fe717 	ldw	r4,-100(fp)
 d033808:	000b883a 	mov	r5,zero
 d03380c:	e1bff017 	ldw	r6,-64(fp)
 d033810:	d031bbc0 	call	d031bbc <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 d033814:	e0bfed17 	ldw	r2,-76(fp)
 d033818:	10800617 	ldw	r2,24(r2)
 d03381c:	10ffffc4 	addi	r3,r2,-1
 d033820:	e0bfe717 	ldw	r2,-100(fp)
 d033824:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 d033828:	e0bfed17 	ldw	r2,-76(fp)
 d03382c:	10c00717 	ldw	r3,28(r2)
 d033830:	e0bfe717 	ldw	r2,-100(fp)
 d033834:	10800e17 	ldw	r2,56(r2)
 d033838:	1885c83a 	sub	r2,r3,r2
 d03383c:	10800048 	cmpgei	r2,r2,1
 d033840:	1000671e 	bne	r2,zero,d0339e0 <tcp_input+0x1a1c>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 d033844:	e0bfed17 	ldw	r2,-76(fp)
 d033848:	1080028b 	ldhu	r2,10(r2)
 d03384c:	10bfffcc 	andi	r2,r2,65535
 d033850:	1004c03a 	cmpne	r2,r2,zero
 d033854:	10005f1e 	bne	r2,zero,d0339d4 <tcp_input+0x1a10>
 d033858:	e0bfe717 	ldw	r2,-100(fp)
 d03385c:	10c01417 	ldw	r3,80(r2)
 d033860:	e0bfde17 	ldw	r2,-136(fp)
 d033864:	18805b1e 	bne	r3,r2,d0339d4 <tcp_input+0x1a10>
         {
            tcpstat.tcps_rcvdupack++;
 d033868:	008341b4 	movhi	r2,3334
 d03386c:	10b41504 	addi	r2,r2,-12204
 d033870:	10802917 	ldw	r2,164(r2)
 d033874:	10c00044 	addi	r3,r2,1
 d033878:	008341b4 	movhi	r2,3334
 d03387c:	10b41504 	addi	r2,r2,-12204
 d033880:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 d033884:	e0bfe717 	ldw	r2,-100(fp)
 d033888:	10800317 	ldw	r2,12(r2)
 d03388c:	1005003a 	cmpeq	r2,r2,zero
 d033890:	1000051e 	bne	r2,zero,d0338a8 <tcp_input+0x18e4>
 d033894:	e0bfed17 	ldw	r2,-76(fp)
 d033898:	10c00717 	ldw	r3,28(r2)
 d03389c:	e0bfe717 	ldw	r2,-100(fp)
 d0338a0:	10800e17 	ldw	r2,56(r2)
 d0338a4:	18800326 	beq	r3,r2,d0338b4 <tcp_input+0x18f0>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 d0338a8:	e0bfe717 	ldw	r2,-100(fp)
 d0338ac:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 d0338b0:	00013906 	br	d033d98 <tcp_input+0x1dd4>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 d0338b4:	e0bfe717 	ldw	r2,-100(fp)
 d0338b8:	10800917 	ldw	r2,36(r2)
 d0338bc:	10c00044 	addi	r3,r2,1
 d0338c0:	e0bfe717 	ldw	r2,-100(fp)
 d0338c4:	10c00915 	stw	r3,36(r2)
 d0338c8:	e0bfe717 	ldw	r2,-100(fp)
 d0338cc:	10c00917 	ldw	r3,36(r2)
 d0338d0:	d0a03c83 	ldbu	r2,-32526(gp)
 d0338d4:	10803fcc 	andi	r2,r2,255
 d0338d8:	1080201c 	xori	r2,r2,128
 d0338dc:	10bfe004 	addi	r2,r2,-128
 d0338e0:	18812d1e 	bne	r3,r2,d033d98 <tcp_input+0x1dd4>
            {
               tcp_seq onxt = tp->snd_nxt;
 d0338e4:	e0bfe717 	ldw	r2,-100(fp)
 d0338e8:	10800f17 	ldw	r2,60(r2)
 d0338ec:	e0bfd715 	stw	r2,-164(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;
 d0338f0:	e0bfe717 	ldw	r2,-100(fp)
 d0338f4:	10c01417 	ldw	r3,80(r2)
 d0338f8:	e0bfe717 	ldw	r2,-100(fp)
 d0338fc:	10801b17 	ldw	r2,108(r2)
 d033900:	e0bff615 	stw	r2,-40(fp)
 d033904:	e0fff515 	stw	r3,-44(fp)
 d033908:	e0bff617 	ldw	r2,-40(fp)
 d03390c:	e0fff517 	ldw	r3,-44(fp)
 d033910:	10c0022e 	bgeu	r2,r3,d03391c <tcp_input+0x1958>
 d033914:	e13ff617 	ldw	r4,-40(fp)
 d033918:	e13ff515 	stw	r4,-44(fp)
 d03391c:	e0bff517 	ldw	r2,-44(fp)
 d033920:	1006d07a 	srli	r3,r2,1
 d033924:	e0bfe717 	ldw	r2,-100(fp)
 d033928:	10800a0b 	ldhu	r2,40(r2)
 d03392c:	10bfffcc 	andi	r2,r2,65535
 d033930:	1885203a 	divu	r2,r3,r2
 d033934:	e0bfd60d 	sth	r2,-168(fp)

               if (win < 2)
 d033938:	e0bfd60b 	ldhu	r2,-168(fp)
 d03393c:	108000a8 	cmpgeui	r2,r2,2
 d033940:	1000021e 	bne	r2,zero,d03394c <tcp_input+0x1988>
                  win = 2;
 d033944:	00800084 	movi	r2,2
 d033948:	e0bfd60d 	sth	r2,-168(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 d03394c:	e0bfe717 	ldw	r2,-100(fp)
 d033950:	10c00a0b 	ldhu	r3,40(r2)
 d033954:	e0bfd60b 	ldhu	r2,-168(fp)
 d033958:	1885383a 	mul	r2,r3,r2
 d03395c:	10ffffcc 	andi	r3,r2,65535
 d033960:	e0bfe717 	ldw	r2,-100(fp)
 d033964:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 d033968:	e0bfe717 	ldw	r2,-100(fp)
 d03396c:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 d033970:	e0bfe717 	ldw	r2,-100(fp)
 d033974:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 d033978:	e0bfed17 	ldw	r2,-76(fp)
 d03397c:	10c00717 	ldw	r3,28(r2)
 d033980:	e0bfe717 	ldw	r2,-100(fp)
 d033984:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 d033988:	e0bfe717 	ldw	r2,-100(fp)
 d03398c:	10800a0b 	ldhu	r2,40(r2)
 d033990:	10ffffcc 	andi	r3,r2,65535
 d033994:	e0bfe717 	ldw	r2,-100(fp)
 d033998:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 d03399c:	e13fe717 	ldw	r4,-100(fp)
 d0339a0:	d034ba40 	call	d034ba4 <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 d0339a4:	e0bfe717 	ldw	r2,-100(fp)
 d0339a8:	10c00f17 	ldw	r3,60(r2)
 d0339ac:	e0bfd717 	ldw	r2,-164(fp)
 d0339b0:	10c5c83a 	sub	r2,r2,r3
 d0339b4:	10800050 	cmplti	r2,r2,1
 d0339b8:	1000031e 	bne	r2,zero,d0339c8 <tcp_input+0x1a04>
                  tp->snd_nxt = onxt;
 d0339bc:	e0ffe717 	ldw	r3,-100(fp)
 d0339c0:	e0bfd717 	ldw	r2,-164(fp)
 d0339c4:	18800f15 	stw	r2,60(r3)
               GOTO_DROP;
 d0339c8:	00814544 	movi	r2,1301
 d0339cc:	d0a0b215 	stw	r2,-32056(gp)
 d0339d0:	0002c006 	br	d0344d4 <tcp_input+0x2510>
            }
         } else
            tp->t_dupacks = 0;
 d0339d4:	e0bfe717 	ldw	r2,-100(fp)
 d0339d8:	10000915 	stw	zero,36(r2)
         break;
 d0339dc:	0000ee06 	br	d033d98 <tcp_input+0x1dd4>
      }
      tp->t_dupacks = 0;
 d0339e0:	e0bfe717 	ldw	r2,-100(fp)
 d0339e4:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 d0339e8:	e0bfed17 	ldw	r2,-76(fp)
 d0339ec:	10c00717 	ldw	r3,28(r2)
 d0339f0:	e0bfe717 	ldw	r2,-100(fp)
 d0339f4:	10801a17 	ldw	r2,104(r2)
 d0339f8:	1885c83a 	sub	r2,r3,r2
 d0339fc:	10800050 	cmplti	r2,r2,1
 d033a00:	1000081e 	bne	r2,zero,d033a24 <tcp_input+0x1a60>
      {
         tcpstat.tcps_rcvacktoomuch++;
 d033a04:	008341b4 	movhi	r2,3334
 d033a08:	10b41504 	addi	r2,r2,-12204
 d033a0c:	10802a17 	ldw	r2,168(r2)
 d033a10:	10c00044 	addi	r3,r2,1
 d033a14:	008341b4 	movhi	r2,3334
 d033a18:	10b41504 	addi	r2,r2,-12204
 d033a1c:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 d033a20:	00025606 	br	d03437c <tcp_input+0x23b8>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 d033a24:	e0bfed17 	ldw	r2,-76(fp)
 d033a28:	10c00717 	ldw	r3,28(r2)
 d033a2c:	e0bfe717 	ldw	r2,-100(fp)
 d033a30:	10800e17 	ldw	r2,56(r2)
 d033a34:	1885c83a 	sub	r2,r3,r2
 d033a38:	e0bfe315 	stw	r2,-116(fp)
      tcpstat.tcps_rcvackpack++;
 d033a3c:	008341b4 	movhi	r2,3334
 d033a40:	10b41504 	addi	r2,r2,-12204
 d033a44:	10802b17 	ldw	r2,172(r2)
 d033a48:	10c00044 	addi	r3,r2,1
 d033a4c:	008341b4 	movhi	r2,3334
 d033a50:	10b41504 	addi	r2,r2,-12204
 d033a54:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 d033a58:	008341b4 	movhi	r2,3334
 d033a5c:	10b41504 	addi	r2,r2,-12204
 d033a60:	10c02c17 	ldw	r3,176(r2)
 d033a64:	e0bfe317 	ldw	r2,-116(fp)
 d033a68:	1887883a 	add	r3,r3,r2
 d033a6c:	008341b4 	movhi	r2,3334
 d033a70:	10b41504 	addi	r2,r2,-12204
 d033a74:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 d033a78:	e0bfe717 	ldw	r2,-100(fp)
 d033a7c:	10801e17 	ldw	r2,120(r2)
 d033a80:	1005003a 	cmpeq	r2,r2,zero
 d033a84:	1000091e 	bne	r2,zero,d033aac <tcp_input+0x1ae8>
 d033a88:	e0bfed17 	ldw	r2,-76(fp)
 d033a8c:	10c00717 	ldw	r3,28(r2)
 d033a90:	e0bfe717 	ldw	r2,-100(fp)
 d033a94:	10801f17 	ldw	r2,124(r2)
 d033a98:	1885c83a 	sub	r2,r3,r2
 d033a9c:	10800050 	cmplti	r2,r2,1
 d033aa0:	1000021e 	bne	r2,zero,d033aac <tcp_input+0x1ae8>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 d033aa4:	e13fe717 	ldw	r4,-100(fp)
 d033aa8:	d0347d40 	call	d0347d4 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 d033aac:	e0bfed17 	ldw	r2,-76(fp)
 d033ab0:	10c00717 	ldw	r3,28(r2)
 d033ab4:	e0bfe717 	ldw	r2,-100(fp)
 d033ab8:	10801a17 	ldw	r2,104(r2)
 d033abc:	1880051e 	bne	r3,r2,d033ad4 <tcp_input+0x1b10>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 d033ac0:	e0bfe717 	ldw	r2,-100(fp)
 d033ac4:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 d033ac8:	00800044 	movi	r2,1
 d033acc:	e0bfe115 	stw	r2,-124(fp)
 d033ad0:	00000806 	br	d033af4 <tcp_input+0x1b30>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 d033ad4:	e0bfe717 	ldw	r2,-100(fp)
 d033ad8:	10800417 	ldw	r2,16(r2)
 d033adc:	1004c03a 	cmpne	r2,r2,zero
 d033ae0:	1000041e 	bne	r2,zero,d033af4 <tcp_input+0x1b30>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 d033ae4:	e0bfe717 	ldw	r2,-100(fp)
 d033ae8:	10c00817 	ldw	r3,32(r2)
 d033aec:	e0bfe717 	ldw	r2,-100(fp)
 d033af0:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 d033af4:	e0bfe717 	ldw	r2,-100(fp)
 d033af8:	10801b17 	ldw	r2,108(r2)
 d033afc:	e0bfd515 	stw	r2,-172(fp)
         u_short  incr  =  tp->t_maxseg;
 d033b00:	e0bfe717 	ldw	r2,-100(fp)
 d033b04:	10800a0b 	ldhu	r2,40(r2)
 d033b08:	e0bfd40d 	sth	r2,-176(fp)

         if (cw > tp->snd_ssthresh)
 d033b0c:	e0bfe717 	ldw	r2,-100(fp)
 d033b10:	10c01c17 	ldw	r3,112(r2)
 d033b14:	e0bfd517 	ldw	r2,-172(fp)
 d033b18:	18800e2e 	bgeu	r3,r2,d033b54 <tcp_input+0x1b90>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 d033b1c:	e0ffd40b 	ldhu	r3,-176(fp)
 d033b20:	e0bfd40b 	ldhu	r2,-176(fp)
 d033b24:	1885383a 	mul	r2,r3,r2
 d033b28:	1007883a 	mov	r3,r2
 d033b2c:	e0bfd517 	ldw	r2,-172(fp)
 d033b30:	1885203a 	divu	r2,r3,r2
 d033b34:	e0bff415 	stw	r2,-48(fp)
 d033b38:	e0fff417 	ldw	r3,-48(fp)
 d033b3c:	18800428 	cmpgeui	r2,r3,16
 d033b40:	1000021e 	bne	r2,zero,d033b4c <tcp_input+0x1b88>
 d033b44:	01000404 	movi	r4,16
 d033b48:	e13ff415 	stw	r4,-48(fp)
 d033b4c:	e0bff417 	ldw	r2,-48(fp)
 d033b50:	e0bfd40d 	sth	r2,-176(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 d033b54:	e0ffd40b 	ldhu	r3,-176(fp)
 d033b58:	e0bfd517 	ldw	r2,-172(fp)
 d033b5c:	1885883a 	add	r2,r3,r2
 d033b60:	e0bff315 	stw	r2,-52(fp)
 d033b64:	e0fff317 	ldw	r3,-52(fp)
 d033b68:	18980070 	cmpltui	r2,r3,24577
 d033b6c:	1000021e 	bne	r2,zero,d033b78 <tcp_input+0x1bb4>
 d033b70:	01180004 	movi	r4,24576
 d033b74:	e13ff315 	stw	r4,-52(fp)
 d033b78:	e0bfe717 	ldw	r2,-100(fp)
 d033b7c:	e0fff317 	ldw	r3,-52(fp)
 d033b80:	10c01b15 	stw	r3,108(r2)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 d033b84:	e0bfe517 	ldw	r2,-108(fp)
 d033b88:	10801217 	ldw	r2,72(r2)
 d033b8c:	1007883a 	mov	r3,r2
 d033b90:	e0bfe317 	ldw	r2,-116(fp)
 d033b94:	1880110e 	bge	r3,r2,d033bdc <tcp_input+0x1c18>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 d033b98:	e0bfe717 	ldw	r2,-100(fp)
 d033b9c:	10c01417 	ldw	r3,80(r2)
 d033ba0:	e0bfe517 	ldw	r2,-108(fp)
 d033ba4:	10801217 	ldw	r2,72(r2)
 d033ba8:	10bfffcc 	andi	r2,r2,65535
 d033bac:	1887c83a 	sub	r3,r3,r2
 d033bb0:	e0bfe717 	ldw	r2,-100(fp)
 d033bb4:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 d033bb8:	e0bfe517 	ldw	r2,-108(fp)
 d033bbc:	11001204 	addi	r4,r2,72
 d033bc0:	e0bfe517 	ldw	r2,-108(fp)
 d033bc4:	10801217 	ldw	r2,72(r2)
 d033bc8:	100b883a 	mov	r5,r2
 d033bcc:	d030f340 	call	d030f34 <sbdrop>
         ourfinisacked = 1;
 d033bd0:	00800044 	movi	r2,1
 d033bd4:	e0bfe215 	stw	r2,-120(fp)
 d033bd8:	00000c06 	br	d033c0c <tcp_input+0x1c48>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 d033bdc:	e0bfe517 	ldw	r2,-108(fp)
 d033be0:	11001204 	addi	r4,r2,72
 d033be4:	e17fe317 	ldw	r5,-116(fp)
 d033be8:	d030f340 	call	d030f34 <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 d033bec:	e0bfe717 	ldw	r2,-100(fp)
 d033bf0:	10c01417 	ldw	r3,80(r2)
 d033bf4:	e0bfe317 	ldw	r2,-116(fp)
 d033bf8:	10bfffcc 	andi	r2,r2,65535
 d033bfc:	1887c83a 	sub	r3,r3,r2
 d033c00:	e0bfe717 	ldw	r2,-100(fp)
 d033c04:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 d033c08:	e03fe215 	stw	zero,-120(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 d033c0c:	e0bfe517 	ldw	r2,-108(fp)
 d033c10:	1080190b 	ldhu	r2,100(r2)
 d033c14:	10bfffcc 	andi	r2,r2,65535
 d033c18:	1080030c 	andi	r2,r2,12
 d033c1c:	1005003a 	cmpeq	r2,r2,zero
 d033c20:	1000041e 	bne	r2,zero,d033c34 <tcp_input+0x1c70>
         sowwakeup(so);
 d033c24:	e0bfe517 	ldw	r2,-108(fp)
 d033c28:	11401204 	addi	r5,r2,72
 d033c2c:	e13fe517 	ldw	r4,-108(fp)
 d033c30:	d0307680 	call	d030768 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 d033c34:	e0bfed17 	ldw	r2,-76(fp)
 d033c38:	10c00717 	ldw	r3,28(r2)
 d033c3c:	e0bfe717 	ldw	r2,-100(fp)
 d033c40:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 d033c44:	e0bfe717 	ldw	r2,-100(fp)
 d033c48:	10c00f17 	ldw	r3,60(r2)
 d033c4c:	e0bfe717 	ldw	r2,-100(fp)
 d033c50:	10800e17 	ldw	r2,56(r2)
 d033c54:	1885c83a 	sub	r2,r3,r2
 d033c58:	1004403a 	cmpge	r2,r2,zero
 d033c5c:	1000041e 	bne	r2,zero,d033c70 <tcp_input+0x1cac>
         tp->snd_nxt = tp->snd_una;
 d033c60:	e0bfe717 	ldw	r2,-100(fp)
 d033c64:	10c00e17 	ldw	r3,56(r2)
 d033c68:	e0bfe717 	ldw	r2,-100(fp)
 d033c6c:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 d033c70:	e0bfe717 	ldw	r2,-100(fp)
 d033c74:	10800217 	ldw	r2,8(r2)
 d033c78:	e0bff215 	stw	r2,-56(fp)
 d033c7c:	e13ff217 	ldw	r4,-56(fp)
 d033c80:	208001e0 	cmpeqi	r2,r4,7
 d033c84:	1000221e 	bne	r2,zero,d033d10 <tcp_input+0x1d4c>
 d033c88:	e0fff217 	ldw	r3,-56(fp)
 d033c8c:	18800208 	cmpgei	r2,r3,8
 d033c90:	1000041e 	bne	r2,zero,d033ca4 <tcp_input+0x1ce0>
 d033c94:	e13ff217 	ldw	r4,-56(fp)
 d033c98:	208001a0 	cmpeqi	r2,r4,6
 d033c9c:	1000081e 	bne	r2,zero,d033cc0 <tcp_input+0x1cfc>
 d033ca0:	00003d06 	br	d033d98 <tcp_input+0x1dd4>
 d033ca4:	e0fff217 	ldw	r3,-56(fp)
 d033ca8:	18800220 	cmpeqi	r2,r3,8
 d033cac:	10002a1e 	bne	r2,zero,d033d58 <tcp_input+0x1d94>
 d033cb0:	e13ff217 	ldw	r4,-56(fp)
 d033cb4:	208002a0 	cmpeqi	r2,r4,10
 d033cb8:	10002f1e 	bne	r2,zero,d033d78 <tcp_input+0x1db4>
 d033cbc:	00003606 	br	d033d98 <tcp_input+0x1dd4>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 d033cc0:	e0bfe217 	ldw	r2,-120(fp)
 d033cc4:	1005003a 	cmpeq	r2,r2,zero
 d033cc8:	1000331e 	bne	r2,zero,d033d98 <tcp_input+0x1dd4>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 d033ccc:	e0bfe517 	ldw	r2,-108(fp)
 d033cd0:	1080088b 	ldhu	r2,34(r2)
 d033cd4:	10bfffcc 	andi	r2,r2,65535
 d033cd8:	1080080c 	andi	r2,r2,32
 d033cdc:	1005003a 	cmpeq	r2,r2,zero
 d033ce0:	1000071e 	bne	r2,zero,d033d00 <tcp_input+0x1d3c>
            {
               soisdisconnected(so);
 d033ce4:	e13fe517 	ldw	r4,-108(fp)
 d033ce8:	d0301840 	call	d030184 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 d033cec:	00834174 	movhi	r2,3333
 d033cf0:	108ad504 	addi	r2,r2,11092
 d033cf4:	10c00017 	ldw	r3,0(r2)
 d033cf8:	e0bfe717 	ldw	r2,-100(fp)
 d033cfc:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 d033d00:	e0ffe717 	ldw	r3,-100(fp)
 d033d04:	00800244 	movi	r2,9
 d033d08:	18800215 	stw	r2,8(r3)
         }
         break;
 d033d0c:	00002206 	br	d033d98 <tcp_input+0x1dd4>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 d033d10:	e0bfe217 	ldw	r2,-120(fp)
 d033d14:	1005003a 	cmpeq	r2,r2,zero
 d033d18:	10001f1e 	bne	r2,zero,d033d98 <tcp_input+0x1dd4>
         {
            tp->t_state = TCPS_TIME_WAIT;
 d033d1c:	e0ffe717 	ldw	r3,-100(fp)
 d033d20:	00800284 	movi	r2,10
 d033d24:	18800215 	stw	r2,8(r3)
            tcp_canceltimers(tp);
 d033d28:	e13fe717 	ldw	r4,-100(fp)
 d033d2c:	d036b8c0 	call	d036b8c <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 d033d30:	00834174 	movhi	r2,3333
 d033d34:	108a5c04 	addi	r2,r2,10608
 d033d38:	10800017 	ldw	r2,0(r2)
 d033d3c:	1085883a 	add	r2,r2,r2
 d033d40:	1007883a 	mov	r3,r2
 d033d44:	e0bfe717 	ldw	r2,-100(fp)
 d033d48:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 d033d4c:	e13fe517 	ldw	r4,-108(fp)
 d033d50:	d0301840 	call	d030184 <soisdisconnected>
         }
         break;
 d033d54:	00001006 	br	d033d98 <tcp_input+0x1dd4>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 d033d58:	e0bfe217 	ldw	r2,-120(fp)
 d033d5c:	1005003a 	cmpeq	r2,r2,zero
 d033d60:	10000d1e 	bne	r2,zero,d033d98 <tcp_input+0x1dd4>
         {
            SETTP(tp, tcp_close(tp));
 d033d64:	e13fe717 	ldw	r4,-100(fp)
 d033d68:	d0366c00 	call	d0366c0 <tcp_close>
            GOTO_DROP;
 d033d6c:	00816644 	movi	r2,1433
 d033d70:	d0a0b215 	stw	r2,-32056(gp)
 d033d74:	0001d706 	br	d0344d4 <tcp_input+0x2510>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 d033d78:	00834174 	movhi	r2,3333
 d033d7c:	108a5c04 	addi	r2,r2,10608
 d033d80:	10800017 	ldw	r2,0(r2)
 d033d84:	1085883a 	add	r2,r2,r2
 d033d88:	1007883a 	mov	r3,r2
 d033d8c:	e0bfe717 	ldw	r2,-100(fp)
 d033d90:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 d033d94:	00017906 	br	d03437c <tcp_input+0x23b8>
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 d033d98:	e0bfe617 	ldw	r2,-104(fp)
 d033d9c:	1080040c 	andi	r2,r2,16
 d033da0:	1005003a 	cmpeq	r2,r2,zero
 d033da4:	1000471e 	bne	r2,zero,d033ec4 <tcp_input+0x1f00>
 d033da8:	e0bfe717 	ldw	r2,-100(fp)
 d033dac:	10c01117 	ldw	r3,68(r2)
 d033db0:	e0bfed17 	ldw	r2,-76(fp)
 d033db4:	10800617 	ldw	r2,24(r2)
 d033db8:	1885c83a 	sub	r2,r3,r2
 d033dbc:	1004803a 	cmplt	r2,r2,zero
 d033dc0:	1000151e 	bne	r2,zero,d033e18 <tcp_input+0x1e54>
 d033dc4:	e0bfe717 	ldw	r2,-100(fp)
 d033dc8:	10c01117 	ldw	r3,68(r2)
 d033dcc:	e0bfed17 	ldw	r2,-76(fp)
 d033dd0:	10800617 	ldw	r2,24(r2)
 d033dd4:	18803b1e 	bne	r3,r2,d033ec4 <tcp_input+0x1f00>
 d033dd8:	e0bfe717 	ldw	r2,-100(fp)
 d033ddc:	10c01217 	ldw	r3,72(r2)
 d033de0:	e0bfed17 	ldw	r2,-76(fp)
 d033de4:	10800717 	ldw	r2,28(r2)
 d033de8:	1885c83a 	sub	r2,r3,r2
 d033dec:	1004803a 	cmplt	r2,r2,zero
 d033df0:	1000091e 	bne	r2,zero,d033e18 <tcp_input+0x1e54>
 d033df4:	e0bfe717 	ldw	r2,-100(fp)
 d033df8:	10c01217 	ldw	r3,72(r2)
 d033dfc:	e0bfed17 	ldw	r2,-76(fp)
 d033e00:	10800717 	ldw	r2,28(r2)
 d033e04:	18802f1e 	bne	r3,r2,d033ec4 <tcp_input+0x1f00>
 d033e08:	e0bfe717 	ldw	r2,-100(fp)
 d033e0c:	10c01417 	ldw	r3,80(r2)
 d033e10:	e0bfde17 	ldw	r2,-136(fp)
 d033e14:	18802b2e 	bgeu	r3,r2,d033ec4 <tcp_input+0x1f00>
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 d033e18:	e0bfed17 	ldw	r2,-76(fp)
 d033e1c:	1080028b 	ldhu	r2,10(r2)
 d033e20:	10bfffcc 	andi	r2,r2,65535
 d033e24:	1004c03a 	cmpne	r2,r2,zero
 d033e28:	1000101e 	bne	r2,zero,d033e6c <tcp_input+0x1ea8>
 d033e2c:	e0bfe717 	ldw	r2,-100(fp)
 d033e30:	10c01217 	ldw	r3,72(r2)
 d033e34:	e0bfed17 	ldw	r2,-76(fp)
 d033e38:	10800717 	ldw	r2,28(r2)
 d033e3c:	18800b1e 	bne	r3,r2,d033e6c <tcp_input+0x1ea8>
 d033e40:	e0bfe717 	ldw	r2,-100(fp)
 d033e44:	10c01417 	ldw	r3,80(r2)
 d033e48:	e0bfde17 	ldw	r2,-136(fp)
 d033e4c:	1880072e 	bgeu	r3,r2,d033e6c <tcp_input+0x1ea8>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 d033e50:	008341b4 	movhi	r2,3334
 d033e54:	10b41504 	addi	r2,r2,-12204
 d033e58:	10802d17 	ldw	r2,180(r2)
 d033e5c:	10c00044 	addi	r3,r2,1
 d033e60:	008341b4 	movhi	r2,3334
 d033e64:	10b41504 	addi	r2,r2,-12204
 d033e68:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 d033e6c:	e0ffe717 	ldw	r3,-100(fp)
 d033e70:	e0bfde17 	ldw	r2,-136(fp)
 d033e74:	18801415 	stw	r2,80(r3)
      tp->snd_wl1 = ti->ti_seq;
 d033e78:	e0bfed17 	ldw	r2,-76(fp)
 d033e7c:	10c00617 	ldw	r3,24(r2)
 d033e80:	e0bfe717 	ldw	r2,-100(fp)
 d033e84:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 d033e88:	e0bfed17 	ldw	r2,-76(fp)
 d033e8c:	10c00717 	ldw	r3,28(r2)
 d033e90:	e0bfe717 	ldw	r2,-100(fp)
 d033e94:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 d033e98:	e0bfe717 	ldw	r2,-100(fp)
 d033e9c:	10c01417 	ldw	r3,80(r2)
 d033ea0:	e0bfe717 	ldw	r2,-100(fp)
 d033ea4:	10802317 	ldw	r2,140(r2)
 d033ea8:	10c0042e 	bgeu	r2,r3,d033ebc <tcp_input+0x1ef8>
         tp->max_sndwnd = tp->snd_wnd;
 d033eac:	e0bfe717 	ldw	r2,-100(fp)
 d033eb0:	10c01417 	ldw	r3,80(r2)
 d033eb4:	e0bfe717 	ldw	r2,-100(fp)
 d033eb8:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 d033ebc:	00800044 	movi	r2,1
 d033ec0:	e0bfe115 	stw	r2,-124(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 d033ec4:	e0bfe617 	ldw	r2,-104(fp)
 d033ec8:	1080080c 	andi	r2,r2,32
 d033ecc:	1005003a 	cmpeq	r2,r2,zero
 d033ed0:	10005a1e 	bne	r2,zero,d03403c <tcp_input+0x2078>
 d033ed4:	e0bfed17 	ldw	r2,-76(fp)
 d033ed8:	1080098b 	ldhu	r2,38(r2)
 d033edc:	10bfffcc 	andi	r2,r2,65535
 d033ee0:	1005003a 	cmpeq	r2,r2,zero
 d033ee4:	1000551e 	bne	r2,zero,d03403c <tcp_input+0x2078>
 d033ee8:	e0bfe717 	ldw	r2,-100(fp)
 d033eec:	10800217 	ldw	r2,8(r2)
 d033ef0:	10800288 	cmpgei	r2,r2,10
 d033ef4:	1000511e 	bne	r2,zero,d03403c <tcp_input+0x2078>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 d033ef8:	e0bfed17 	ldw	r2,-76(fp)
 d033efc:	1080098b 	ldhu	r2,38(r2)
 d033f00:	10ffffcc 	andi	r3,r2,65535
 d033f04:	e0bfe517 	ldw	r2,-108(fp)
 d033f08:	10800a17 	ldw	r2,40(r2)
 d033f0c:	1885883a 	add	r2,r3,r2
 d033f10:	10900070 	cmpltui	r2,r2,16385
 d033f14:	1000071e 	bne	r2,zero,d033f34 <tcp_input+0x1f70>
      {
         ti->ti_urp = 0;         /* XXX */
 d033f18:	e0bfed17 	ldw	r2,-76(fp)
 d033f1c:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 d033f20:	e0ffe617 	ldw	r3,-104(fp)
 d033f24:	00bff7c4 	movi	r2,-33
 d033f28:	1884703a 	and	r2,r3,r2
 d033f2c:	e0bfe615 	stw	r2,-104(fp)
         goto dodata;         /* XXX */
 d033f30:	00004d06 	br	d034068 <tcp_input+0x20a4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 d033f34:	e0bfed17 	ldw	r2,-76(fp)
 d033f38:	10c00617 	ldw	r3,24(r2)
 d033f3c:	e0bfed17 	ldw	r2,-76(fp)
 d033f40:	1080098b 	ldhu	r2,38(r2)
 d033f44:	10bfffcc 	andi	r2,r2,65535
 d033f48:	1887883a 	add	r3,r3,r2
 d033f4c:	e0bfe717 	ldw	r2,-100(fp)
 d033f50:	10801717 	ldw	r2,92(r2)
 d033f54:	1885c83a 	sub	r2,r3,r2
 d033f58:	10800050 	cmplti	r2,r2,1
 d033f5c:	1000261e 	bne	r2,zero,d033ff8 <tcp_input+0x2034>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 d033f60:	e0bfed17 	ldw	r2,-76(fp)
 d033f64:	10c00617 	ldw	r3,24(r2)
 d033f68:	e0bfed17 	ldw	r2,-76(fp)
 d033f6c:	1080098b 	ldhu	r2,38(r2)
 d033f70:	10bfffcc 	andi	r2,r2,65535
 d033f74:	1887883a 	add	r3,r3,r2
 d033f78:	e0bfe717 	ldw	r2,-100(fp)
 d033f7c:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 d033f80:	e0bfe517 	ldw	r2,-108(fp)
 d033f84:	11000a17 	ldw	r4,40(r2)
 d033f88:	e0bfe717 	ldw	r2,-100(fp)
 d033f8c:	10c01717 	ldw	r3,92(r2)
 d033f90:	e0bfe717 	ldw	r2,-100(fp)
 d033f94:	10801617 	ldw	r2,88(r2)
 d033f98:	1885c83a 	sub	r2,r3,r2
 d033f9c:	2085883a 	add	r2,r4,r2
 d033fa0:	10ffffc4 	addi	r3,r2,-1
 d033fa4:	e0bfe517 	ldw	r2,-108(fp)
 d033fa8:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 d033fac:	e0bfe517 	ldw	r2,-108(fp)
 d033fb0:	10801a17 	ldw	r2,104(r2)
 d033fb4:	1004c03a 	cmpne	r2,r2,zero
 d033fb8:	1000061e 	bne	r2,zero,d033fd4 <tcp_input+0x2010>
            so->so_state |= SS_RCVATMARK;
 d033fbc:	e0bfe517 	ldw	r2,-108(fp)
 d033fc0:	1080088b 	ldhu	r2,34(r2)
 d033fc4:	10801014 	ori	r2,r2,64
 d033fc8:	1007883a 	mov	r3,r2
 d033fcc:	e0bfe517 	ldw	r2,-108(fp)
 d033fd0:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 d033fd4:	e13fe517 	ldw	r4,-108(fp)
 d033fd8:	d02ff4c0 	call	d02ff4c <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 d033fdc:	e0bfe717 	ldw	r2,-100(fp)
 d033fe0:	10c02403 	ldbu	r3,144(r2)
 d033fe4:	00bfff04 	movi	r2,-4
 d033fe8:	1884703a 	and	r2,r3,r2
 d033fec:	1007883a 	mov	r3,r2
 d033ff0:	e0bfe717 	ldw	r2,-100(fp)
 d033ff4:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 d033ff8:	e0bfed17 	ldw	r2,-76(fp)
 d033ffc:	10c0098b 	ldhu	r3,38(r2)
 d034000:	e0bfed17 	ldw	r2,-76(fp)
 d034004:	1080028b 	ldhu	r2,10(r2)
 d034008:	18ffffcc 	andi	r3,r3,65535
 d03400c:	10bfffcc 	andi	r2,r2,65535
 d034010:	10c01536 	bltu	r2,r3,d034068 <tcp_input+0x20a4>
 d034014:	e0bfe517 	ldw	r2,-108(fp)
 d034018:	10800417 	ldw	r2,16(r2)
 d03401c:	1080400c 	andi	r2,r2,256
 d034020:	1004c03a 	cmpne	r2,r2,zero
 d034024:	1000101e 	bne	r2,zero,d034068 <tcp_input+0x20a4>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 d034028:	e13fe517 	ldw	r4,-108(fp)
 d03402c:	e17fed17 	ldw	r5,-76(fp)
 d034030:	e1bff017 	ldw	r6,-64(fp)
 d034034:	d0346a80 	call	d0346a8 <tcp_pulloutofband>
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 d034038:	00000b06 	br	d034068 <tcp_input+0x20a4>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 d03403c:	e0bfe717 	ldw	r2,-100(fp)
 d034040:	10c01617 	ldw	r3,88(r2)
 d034044:	e0bfe717 	ldw	r2,-100(fp)
 d034048:	10801717 	ldw	r2,92(r2)
 d03404c:	1885c83a 	sub	r2,r3,r2
 d034050:	10800050 	cmplti	r2,r2,1
 d034054:	1000041e 	bne	r2,zero,d034068 <tcp_input+0x20a4>
      tp->rcv_up = tp->rcv_nxt;
 d034058:	e0bfe717 	ldw	r2,-100(fp)
 d03405c:	10c01617 	ldw	r3,88(r2)
 d034060:	e0bfe717 	ldw	r2,-100(fp)
 d034064:	10c01715 	stw	r3,92(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 d034068:	e0bfed17 	ldw	r2,-76(fp)
 d03406c:	1080028b 	ldhu	r2,10(r2)
 d034070:	10bfffcc 	andi	r2,r2,65535
 d034074:	1004c03a 	cmpne	r2,r2,zero
 d034078:	1000051e 	bne	r2,zero,d034090 <tcp_input+0x20cc>
 d03407c:	e0bfe617 	ldw	r2,-104(fp)
 d034080:	1080004c 	andi	r2,r2,1
 d034084:	10803fcc 	andi	r2,r2,255
 d034088:	1005003a 	cmpeq	r2,r2,zero
 d03408c:	10005c1e 	bne	r2,zero,d034200 <tcp_input+0x223c>
 d034090:	e0bfe717 	ldw	r2,-100(fp)
 d034094:	10800217 	ldw	r2,8(r2)
 d034098:	10800288 	cmpgei	r2,r2,10
 d03409c:	1000581e 	bne	r2,zero,d034200 <tcp_input+0x223c>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 d0340a0:	e0bfed17 	ldw	r2,-76(fp)
 d0340a4:	10c00617 	ldw	r3,24(r2)
 d0340a8:	e0bfe717 	ldw	r2,-100(fp)
 d0340ac:	10801617 	ldw	r2,88(r2)
 d0340b0:	1880351e 	bne	r3,r2,d034188 <tcp_input+0x21c4>
 d0340b4:	e0bfe717 	ldw	r2,-100(fp)
 d0340b8:	10c00017 	ldw	r3,0(r2)
 d0340bc:	e0bfe717 	ldw	r2,-100(fp)
 d0340c0:	1880311e 	bne	r3,r2,d034188 <tcp_input+0x21c4>
 d0340c4:	e0bfe717 	ldw	r2,-100(fp)
 d0340c8:	10800217 	ldw	r2,8(r2)
 d0340cc:	10800118 	cmpnei	r2,r2,4
 d0340d0:	10002d1e 	bne	r2,zero,d034188 <tcp_input+0x21c4>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 d0340d4:	e0bfe717 	ldw	r2,-100(fp)
 d0340d8:	10800b0b 	ldhu	r2,44(r2)
 d0340dc:	10800054 	ori	r2,r2,1
 d0340e0:	1007883a 	mov	r3,r2
 d0340e4:	e0bfe717 	ldw	r2,-100(fp)
 d0340e8:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 d0340ec:	e0bfe717 	ldw	r2,-100(fp)
 d0340f0:	10c01617 	ldw	r3,88(r2)
 d0340f4:	e0bfed17 	ldw	r2,-76(fp)
 d0340f8:	1080028b 	ldhu	r2,10(r2)
 d0340fc:	10bfffcc 	andi	r2,r2,65535
 d034100:	1887883a 	add	r3,r3,r2
 d034104:	e0bfe717 	ldw	r2,-100(fp)
 d034108:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 d03410c:	e0bfed17 	ldw	r2,-76(fp)
 d034110:	10800843 	ldbu	r2,33(r2)
 d034114:	10803fcc 	andi	r2,r2,255
 d034118:	1080004c 	andi	r2,r2,1
 d03411c:	e0bfe615 	stw	r2,-104(fp)
         tcpstat.tcps_rcvpack++;
 d034120:	008341b4 	movhi	r2,3334
 d034124:	10b41504 	addi	r2,r2,-12204
 d034128:	10801a17 	ldw	r2,104(r2)
 d03412c:	10c00044 	addi	r3,r2,1
 d034130:	008341b4 	movhi	r2,3334
 d034134:	10b41504 	addi	r2,r2,-12204
 d034138:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 d03413c:	008341b4 	movhi	r2,3334
 d034140:	10b41504 	addi	r2,r2,-12204
 d034144:	10c01b17 	ldw	r3,108(r2)
 d034148:	e0bfed17 	ldw	r2,-76(fp)
 d03414c:	1080028b 	ldhu	r2,10(r2)
 d034150:	10bfffcc 	andi	r2,r2,65535
 d034154:	1887883a 	add	r3,r3,r2
 d034158:	008341b4 	movhi	r2,3334
 d03415c:	10b41504 	addi	r2,r2,-12204
 d034160:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 d034164:	e0bfe517 	ldw	r2,-108(fp)
 d034168:	11000a04 	addi	r4,r2,40
 d03416c:	e17ff017 	ldw	r5,-64(fp)
 d034170:	d03092c0 	call	d03092c <sbappend>
         sorwakeup(so);
 d034174:	e0bfe517 	ldw	r2,-108(fp)
 d034178:	11400a04 	addi	r5,r2,40
 d03417c:	e13fe517 	ldw	r4,-108(fp)
 d034180:	d0307680 	call	d030768 <sbwakeup>
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 d034184:	00000b06 	br	d0341b4 <tcp_input+0x21f0>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 d034188:	e13fe717 	ldw	r4,-100(fp)
 d03418c:	e17fed17 	ldw	r5,-76(fp)
 d034190:	e1bff017 	ldw	r6,-64(fp)
 d034194:	d031bbc0 	call	d031bbc <tcp_reass>
 d034198:	e0bfe615 	stw	r2,-104(fp)
         tp->t_flags |= TF_ACKNOW;
 d03419c:	e0bfe717 	ldw	r2,-100(fp)
 d0341a0:	10800b0b 	ldhu	r2,44(r2)
 d0341a4:	10800054 	ori	r2,r2,1
 d0341a8:	1007883a 	mov	r3,r2
 d0341ac:	e0bfe717 	ldw	r2,-100(fp)
 d0341b0:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 d0341b4:	e0bfe517 	ldw	r2,-108(fp)
 d0341b8:	11000b17 	ldw	r4,44(r2)
 d0341bc:	e0bfe717 	ldw	r2,-100(fp)
 d0341c0:	10c01917 	ldw	r3,100(r2)
 d0341c4:	e0bfe717 	ldw	r2,-100(fp)
 d0341c8:	10801617 	ldw	r2,88(r2)
 d0341cc:	1885c83a 	sub	r2,r3,r2
 d0341d0:	2085c83a 	sub	r2,r4,r2
 d0341d4:	e0bfea15 	stw	r2,-88(fp)
      if (len > (int)tp->max_rcvd)
 d0341d8:	e0bfe717 	ldw	r2,-100(fp)
 d0341dc:	10802217 	ldw	r2,136(r2)
 d0341e0:	1007883a 	mov	r3,r2
 d0341e4:	e0bfea17 	ldw	r2,-88(fp)
 d0341e8:	18800b0e 	bge	r3,r2,d034218 <tcp_input+0x2254>
         tp->max_rcvd = (u_short)len;
 d0341ec:	e0bfea17 	ldw	r2,-88(fp)
 d0341f0:	10ffffcc 	andi	r3,r2,65535
 d0341f4:	e0bfe717 	ldw	r2,-100(fp)
 d0341f8:	10c02215 	stw	r3,136(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 d0341fc:	00000606 	br	d034218 <tcp_input+0x2254>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 d034200:	e13ff017 	ldw	r4,-64(fp)
 d034204:	d02a4c40 	call	d02a4c4 <m_freem>
      tiflags &= ~TH_FIN;
 d034208:	e0bfe617 	ldw	r2,-104(fp)
 d03420c:	00ffff84 	movi	r3,-2
 d034210:	10c4703a 	and	r2,r2,r3
 d034214:	e0bfe615 	stw	r2,-104(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 d034218:	e0bfe617 	ldw	r2,-104(fp)
 d03421c:	1080004c 	andi	r2,r2,1
 d034220:	10803fcc 	andi	r2,r2,255
 d034224:	1005003a 	cmpeq	r2,r2,zero
 d034228:	1000471e 	bne	r2,zero,d034348 <tcp_input+0x2384>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 d03422c:	e0bfe717 	ldw	r2,-100(fp)
 d034230:	10800217 	ldw	r2,8(r2)
 d034234:	10800288 	cmpgei	r2,r2,10
 d034238:	10000d1e 	bne	r2,zero,d034270 <tcp_input+0x22ac>
      {
         socantrcvmore(so);
 d03423c:	e13fe517 	ldw	r4,-108(fp)
 d034240:	d0306780 	call	d030678 <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 d034244:	e0bfe717 	ldw	r2,-100(fp)
 d034248:	10800b0b 	ldhu	r2,44(r2)
 d03424c:	10800054 	ori	r2,r2,1
 d034250:	1007883a 	mov	r3,r2
 d034254:	e0bfe717 	ldw	r2,-100(fp)
 d034258:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 d03425c:	e0bfe717 	ldw	r2,-100(fp)
 d034260:	10801617 	ldw	r2,88(r2)
 d034264:	10c00044 	addi	r3,r2,1
 d034268:	e0bfe717 	ldw	r2,-100(fp)
 d03426c:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 d034270:	e0bfe717 	ldw	r2,-100(fp)
 d034274:	10800217 	ldw	r2,8(r2)
 d034278:	10bfff44 	addi	r2,r2,-3
 d03427c:	e0bfff15 	stw	r2,-4(fp)
 d034280:	e0ffff17 	ldw	r3,-4(fp)
 d034284:	18800228 	cmpgeui	r2,r3,8
 d034288:	10002f1e 	bne	r2,zero,d034348 <tcp_input+0x2384>
 d03428c:	e13fff17 	ldw	r4,-4(fp)
 d034290:	e13fff17 	ldw	r4,-4(fp)
 d034294:	2105883a 	add	r2,r4,r4
 d034298:	1087883a 	add	r3,r2,r2
 d03429c:	008340f4 	movhi	r2,3331
 d0342a0:	1090ac04 	addi	r2,r2,17072
 d0342a4:	1885883a 	add	r2,r3,r2
 d0342a8:	10800017 	ldw	r2,0(r2)
 d0342ac:	1000683a 	jmp	r2
 d0342b0:	0d0342d0 	cmplti	r20,at,3339
 d0342b4:	0d0342d0 	cmplti	r20,at,3339
 d0342b8:	0d034348 	cmpgei	r20,at,3341
 d0342bc:	0d0342e0 	cmpeqi	r20,at,3339
 d0342c0:	0d034348 	cmpgei	r20,at,3341
 d0342c4:	0d034348 	cmpgei	r20,at,3341
 d0342c8:	0d0342f0 	cmpltui	r20,at,3339
 d0342cc:	0d03432c 	andhi	r20,at,3340
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 d0342d0:	e0ffe717 	ldw	r3,-100(fp)
 d0342d4:	00800144 	movi	r2,5
 d0342d8:	18800215 	stw	r2,8(r3)
         break;
 d0342dc:	00001a06 	br	d034348 <tcp_input+0x2384>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 d0342e0:	e0ffe717 	ldw	r3,-100(fp)
 d0342e4:	008001c4 	movi	r2,7
 d0342e8:	18800215 	stw	r2,8(r3)
         break;
 d0342ec:	00001606 	br	d034348 <tcp_input+0x2384>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 d0342f0:	e0ffe717 	ldw	r3,-100(fp)
 d0342f4:	00800284 	movi	r2,10
 d0342f8:	18800215 	stw	r2,8(r3)
         tcp_canceltimers(tp);
 d0342fc:	e13fe717 	ldw	r4,-100(fp)
 d034300:	d036b8c0 	call	d036b8c <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 d034304:	00834174 	movhi	r2,3333
 d034308:	108a5c04 	addi	r2,r2,10608
 d03430c:	10800017 	ldw	r2,0(r2)
 d034310:	1085883a 	add	r2,r2,r2
 d034314:	1007883a 	mov	r3,r2
 d034318:	e0bfe717 	ldw	r2,-100(fp)
 d03431c:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 d034320:	e13fe517 	ldw	r4,-108(fp)
 d034324:	d0301840 	call	d030184 <soisdisconnected>
         break;
 d034328:	00000706 	br	d034348 <tcp_input+0x2384>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 d03432c:	00834174 	movhi	r2,3333
 d034330:	108a5c04 	addi	r2,r2,10608
 d034334:	10800017 	ldw	r2,0(r2)
 d034338:	1085883a 	add	r2,r2,r2
 d03433c:	1007883a 	mov	r3,r2
 d034340:	e0bfe717 	ldw	r2,-100(fp)
 d034344:	10c00615 	stw	r3,24(r2)
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 d034348:	e0bfe117 	ldw	r2,-124(fp)
 d03434c:	1004c03a 	cmpne	r2,r2,zero
 d034350:	1000071e 	bne	r2,zero,d034370 <tcp_input+0x23ac>
 d034354:	e0bfe717 	ldw	r2,-100(fp)
 d034358:	10800b0b 	ldhu	r2,44(r2)
 d03435c:	10bfffcc 	andi	r2,r2,65535
 d034360:	1080004c 	andi	r2,r2,1
 d034364:	10803fcc 	andi	r2,r2,255
 d034368:	1005003a 	cmpeq	r2,r2,zero
 d03436c:	1000651e 	bne	r2,zero,d034504 <tcp_input+0x2540>
      (void) tcp_output(tp);
 d034370:	e13fe717 	ldw	r4,-100(fp)
 d034374:	d034ba40 	call	d034ba4 <tcp_output>
   return;
 d034378:	00006206 	br	d034504 <tcp_input+0x2540>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 d03437c:	e0bfe617 	ldw	r2,-104(fp)
 d034380:	1080010c 	andi	r2,r2,4
 d034384:	1005003a 	cmpeq	r2,r2,zero
 d034388:	1000031e 	bne	r2,zero,d034398 <tcp_input+0x23d4>
      GOTO_DROP;
 d03438c:	0081a904 	movi	r2,1700
 d034390:	d0a0b215 	stw	r2,-32056(gp)
 d034394:	00004f06 	br	d0344d4 <tcp_input+0x2510>
   m_freem (m);
 d034398:	e13ff017 	ldw	r4,-64(fp)
 d03439c:	d02a4c40 	call	d02a4c4 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 d0343a0:	e0bfe717 	ldw	r2,-100(fp)
 d0343a4:	10800b0b 	ldhu	r2,44(r2)
 d0343a8:	10800054 	ori	r2,r2,1
 d0343ac:	1007883a 	mov	r3,r2
 d0343b0:	e0bfe717 	ldw	r2,-100(fp)
 d0343b4:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 d0343b8:	e13fe717 	ldw	r4,-100(fp)
 d0343bc:	d034ba40 	call	d034ba4 <tcp_output>
   return;
 d0343c0:	00005006 	br	d034504 <tcp_input+0x2540>

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 d0343c4:	008341b4 	movhi	r2,3334
 d0343c8:	10b3e704 	addi	r2,r2,-12388
 d0343cc:	10800d17 	ldw	r2,52(r2)
 d0343d0:	10c00044 	addi	r3,r2,1
 d0343d4:	008341b4 	movhi	r2,3334
 d0343d8:	10b3e704 	addi	r2,r2,-12388
 d0343dc:	10c00d15 	stw	r3,52(r2)
   if (om) 
 d0343e0:	e0bfeb17 	ldw	r2,-84(fp)
 d0343e4:	1005003a 	cmpeq	r2,r2,zero
 d0343e8:	1000031e 	bne	r2,zero,d0343f8 <tcp_input+0x2434>
   {
      (void) m_free(om);
 d0343ec:	e13feb17 	ldw	r4,-84(fp)
 d0343f0:	d02a3900 	call	d02a390 <m_free>
      om = 0;
 d0343f4:	e03feb15 	stw	zero,-84(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 d0343f8:	e0bfe617 	ldw	r2,-104(fp)
 d0343fc:	1080010c 	andi	r2,r2,4
 d034400:	1005003a 	cmpeq	r2,r2,zero
 d034404:	1000031e 	bne	r2,zero,d034414 <tcp_input+0x2450>
      GOTO_DROP;
 d034408:	0081ad04 	movi	r2,1716
 d03440c:	d0a0b215 	stw	r2,-32056(gp)
 d034410:	00003006 	br	d0344d4 <tcp_input+0x2510>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 d034414:	e0bfed17 	ldw	r2,-76(fp)
 d034418:	11000417 	ldw	r4,16(r2)
 d03441c:	d02b4f00 	call	d02b4f0 <in_broadcast>
 d034420:	1005003a 	cmpeq	r2,r2,zero
 d034424:	1000031e 	bne	r2,zero,d034434 <tcp_input+0x2470>
      GOTO_DROP;
 d034428:	0081af44 	movi	r2,1725
 d03442c:	d0a0b215 	stw	r2,-32056(gp)
 d034430:	00002806 	br	d0344d4 <tcp_input+0x2510>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 d034434:	e0bfe617 	ldw	r2,-104(fp)
 d034438:	1080040c 	andi	r2,r2,16
 d03443c:	1005003a 	cmpeq	r2,r2,zero
 d034440:	10000b1e 	bne	r2,zero,d034470 <tcp_input+0x24ac>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 d034444:	e0bfed17 	ldw	r2,-76(fp)
 d034448:	11c00717 	ldw	r7,28(r2)
 d03444c:	00800104 	movi	r2,4
 d034450:	d8800015 	stw	r2,0(sp)
 d034454:	e0bff017 	ldw	r2,-64(fp)
 d034458:	d8800115 	stw	r2,4(sp)
 d03445c:	e13fe717 	ldw	r4,-100(fp)
 d034460:	e17fed17 	ldw	r5,-76(fp)
 d034464:	000d883a 	mov	r6,zero
 d034468:	d0360740 	call	d036074 <tcp_respond>
 d03446c:	00001306 	br	d0344bc <tcp_input+0x24f8>
   else
   {
      if (tiflags & TH_SYN)
 d034470:	e0bfe617 	ldw	r2,-104(fp)
 d034474:	1080008c 	andi	r2,r2,2
 d034478:	1005003a 	cmpeq	r2,r2,zero
 d03447c:	1000051e 	bne	r2,zero,d034494 <tcp_input+0x24d0>
         ti->ti_seq++;
 d034480:	e0bfed17 	ldw	r2,-76(fp)
 d034484:	10800617 	ldw	r2,24(r2)
 d034488:	10c00044 	addi	r3,r2,1
 d03448c:	e0bfed17 	ldw	r2,-76(fp)
 d034490:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 d034494:	e0bfed17 	ldw	r2,-76(fp)
 d034498:	11800617 	ldw	r6,24(r2)
 d03449c:	00800504 	movi	r2,20
 d0344a0:	d8800015 	stw	r2,0(sp)
 d0344a4:	e0bff017 	ldw	r2,-64(fp)
 d0344a8:	d8800115 	stw	r2,4(sp)
 d0344ac:	e13fe717 	ldw	r4,-100(fp)
 d0344b0:	e17fed17 	ldw	r5,-76(fp)
 d0344b4:	000f883a 	mov	r7,zero
 d0344b8:	d0360740 	call	d036074 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 d0344bc:	e0bfe017 	ldw	r2,-128(fp)
 d0344c0:	1005003a 	cmpeq	r2,r2,zero
 d0344c4:	10000f1e 	bne	r2,zero,d034504 <tcp_input+0x2540>
      (void) soabort(so);
 d0344c8:	e13fe517 	ldw	r4,-108(fp)
 d0344cc:	d02e3580 	call	d02e358 <soabort>
   return;
 d0344d0:	00000c06 	br	d034504 <tcp_input+0x2540>

drop:
   if (om)
 d0344d4:	e0bfeb17 	ldw	r2,-84(fp)
 d0344d8:	1005003a 	cmpeq	r2,r2,zero
 d0344dc:	1000021e 	bne	r2,zero,d0344e8 <tcp_input+0x2524>
      (void) m_free(om);
 d0344e0:	e13feb17 	ldw	r4,-84(fp)
 d0344e4:	d02a3900 	call	d02a390 <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 d0344e8:	e13ff017 	ldw	r4,-64(fp)
 d0344ec:	d02a4c40 	call	d02a4c4 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 d0344f0:	e0bfe017 	ldw	r2,-128(fp)
 d0344f4:	1005003a 	cmpeq	r2,r2,zero
 d0344f8:	1000021e 	bne	r2,zero,d034504 <tcp_input+0x2540>
      (void) soabort(so);
 d0344fc:	e13fe517 	ldw	r4,-108(fp)
 d034500:	d02e3580 	call	d02e358 <soabort>
   return;
}
 d034504:	e037883a 	mov	sp,fp
 d034508:	dfc00117 	ldw	ra,4(sp)
 d03450c:	df000017 	ldw	fp,0(sp)
 d034510:	dec00204 	addi	sp,sp,8
 d034514:	f800283a 	ret

0d034518 <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 d034518:	defff404 	addi	sp,sp,-48
 d03451c:	dfc00b15 	stw	ra,44(sp)
 d034520:	df000a15 	stw	fp,40(sp)
 d034524:	df000a04 	addi	fp,sp,40
 d034528:	e13ffc15 	stw	r4,-16(fp)
 d03452c:	e17ffd15 	stw	r5,-12(fp)
 d034530:	e1bffe15 	stw	r6,-8(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 d034534:	e0bffc17 	ldw	r2,-16(fp)
 d034538:	10800d17 	ldw	r2,52(r2)
 d03453c:	10800817 	ldw	r2,32(r2)
 d034540:	e0bff715 	stw	r2,-36(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 d034544:	e0bffd17 	ldw	r2,-12(fp)
 d034548:	10800317 	ldw	r2,12(r2)
 d03454c:	e0bffb15 	stw	r2,-20(fp)
   cnt = om->m_len;
 d034550:	e0bffd17 	ldw	r2,-12(fp)
 d034554:	10800217 	ldw	r2,8(r2)
 d034558:	e0bff815 	stw	r2,-32(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 d03455c:	00004806 	br	d034680 <tcp_dooptions+0x168>
   {
      opt = cp[0];
 d034560:	e0bffb17 	ldw	r2,-20(fp)
 d034564:	10800003 	ldbu	r2,0(r2)
 d034568:	10803fcc 	andi	r2,r2,255
 d03456c:	e0bffa15 	stw	r2,-24(fp)
      if (opt == TCPOPT_EOL)
 d034570:	e0bffa17 	ldw	r2,-24(fp)
 d034574:	1005003a 	cmpeq	r2,r2,zero
 d034578:	1000441e 	bne	r2,zero,d03468c <tcp_dooptions+0x174>
         break;
      if (opt == TCPOPT_NOP)
 d03457c:	e0bffa17 	ldw	r2,-24(fp)
 d034580:	10800058 	cmpnei	r2,r2,1
 d034584:	1000031e 	bne	r2,zero,d034594 <tcp_dooptions+0x7c>
         optlen = 1;
 d034588:	00800044 	movi	r2,1
 d03458c:	e0bff915 	stw	r2,-28(fp)
 d034590:	00000806 	br	d0345b4 <tcp_dooptions+0x9c>
      else 
      {
         optlen = cp[1];
 d034594:	e0bffb17 	ldw	r2,-20(fp)
 d034598:	10800044 	addi	r2,r2,1
 d03459c:	10800003 	ldbu	r2,0(r2)
 d0345a0:	10803fcc 	andi	r2,r2,255
 d0345a4:	e0bff915 	stw	r2,-28(fp)
         if (optlen <= 0)
 d0345a8:	e0bff917 	ldw	r2,-28(fp)
 d0345ac:	10800050 	cmplti	r2,r2,1
 d0345b0:	1000361e 	bne	r2,zero,d03468c <tcp_dooptions+0x174>
            break;
      }

      switch (opt) 
 d0345b4:	e0bffa17 	ldw	r2,-24(fp)
 d0345b8:	108000a0 	cmpeqi	r2,r2,2
 d0345bc:	1000011e 	bne	r2,zero,d0345c4 <tcp_dooptions+0xac>
 d0345c0:	00002606 	br	d03465c <tcp_dooptions+0x144>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 d0345c4:	e0bff917 	ldw	r2,-28(fp)
 d0345c8:	10800118 	cmpnei	r2,r2,4
 d0345cc:	1000231e 	bne	r2,zero,d03465c <tcp_dooptions+0x144>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 d0345d0:	e0bffe17 	ldw	r2,-8(fp)
 d0345d4:	10800843 	ldbu	r2,33(r2)
 d0345d8:	10803fcc 	andi	r2,r2,255
 d0345dc:	1080008c 	andi	r2,r2,2
 d0345e0:	1005003a 	cmpeq	r2,r2,zero
 d0345e4:	10001d1e 	bne	r2,zero,d03465c <tcp_dooptions+0x144>
            continue;
         mssval = *(u_short *)(cp + 2);
 d0345e8:	e0bffb17 	ldw	r2,-20(fp)
 d0345ec:	10800084 	addi	r2,r2,2
 d0345f0:	1080000b 	ldhu	r2,0(r2)
 d0345f4:	e0bff60d 	sth	r2,-40(fp)
         mssval = ntohs(mssval);
 d0345f8:	e0bff60b 	ldhu	r2,-40(fp)
 d0345fc:	1004d23a 	srli	r2,r2,8
 d034600:	10803fcc 	andi	r2,r2,255
 d034604:	1009883a 	mov	r4,r2
 d034608:	e0bff60b 	ldhu	r2,-40(fp)
 d03460c:	1004923a 	slli	r2,r2,8
 d034610:	1007883a 	mov	r3,r2
 d034614:	00bfc004 	movi	r2,-256
 d034618:	1884703a 	and	r2,r3,r2
 d03461c:	2084b03a 	or	r2,r4,r2
 d034620:	e0bff60d 	sth	r2,-40(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 d034624:	e13ff717 	ldw	r4,-36(fp)
 d034628:	d034a880 	call	d034a88 <tcp_mss>
 d03462c:	10ffffcc 	andi	r3,r2,65535
 d034630:	e0bff60b 	ldhu	r2,-40(fp)
 d034634:	1880042e 	bgeu	r3,r2,d034648 <tcp_dooptions+0x130>
 d034638:	e13ff717 	ldw	r4,-36(fp)
 d03463c:	d034a880 	call	d034a88 <tcp_mss>
 d034640:	e0bfff0d 	sth	r2,-4(fp)
 d034644:	00000206 	br	d034650 <tcp_dooptions+0x138>
 d034648:	e0bff60b 	ldhu	r2,-40(fp)
 d03464c:	e0bfff0d 	sth	r2,-4(fp)
 d034650:	e0bffc17 	ldw	r2,-16(fp)
 d034654:	e0ffff0b 	ldhu	r3,-4(fp)
 d034658:	10c00a0d 	sth	r3,40(r2)
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 d03465c:	e0fff817 	ldw	r3,-32(fp)
 d034660:	e0bff917 	ldw	r2,-28(fp)
 d034664:	1885c83a 	sub	r2,r3,r2
 d034668:	e0bff815 	stw	r2,-32(fp)
 d03466c:	e0bff917 	ldw	r2,-28(fp)
 d034670:	1007883a 	mov	r3,r2
 d034674:	e0bffb17 	ldw	r2,-20(fp)
 d034678:	10c5883a 	add	r2,r2,r3
 d03467c:	e0bffb15 	stw	r2,-20(fp)
 d034680:	e0bff817 	ldw	r2,-32(fp)
 d034684:	10800048 	cmpgei	r2,r2,1
 d034688:	103fb51e 	bne	r2,zero,d034560 <tcp_dooptions+0x48>

      default:
         break;
      }
   }
   (void) m_free(om);
 d03468c:	e13ffd17 	ldw	r4,-12(fp)
 d034690:	d02a3900 	call	d02a390 <m_free>
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
}
 d034694:	e037883a 	mov	sp,fp
 d034698:	dfc00117 	ldw	ra,4(sp)
 d03469c:	df000017 	ldw	fp,0(sp)
 d0346a0:	dec00204 	addi	sp,sp,8
 d0346a4:	f800283a 	ret

0d0346a8 <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 d0346a8:	defff804 	addi	sp,sp,-32
 d0346ac:	dfc00715 	stw	ra,28(sp)
 d0346b0:	df000615 	stw	fp,24(sp)
 d0346b4:	df000604 	addi	fp,sp,24
 d0346b8:	e13ffd15 	stw	r4,-12(fp)
 d0346bc:	e17ffe15 	stw	r5,-8(fp)
 d0346c0:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 d0346c4:	e0bffe17 	ldw	r2,-8(fp)
 d0346c8:	1080098b 	ldhu	r2,38(r2)
 d0346cc:	10bfffcc 	andi	r2,r2,65535
 d0346d0:	10bfffc4 	addi	r2,r2,-1
 d0346d4:	e0bffc15 	stw	r2,-16(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 d0346d8:	00003306 	br	d0347a8 <tcp_pulloutofband+0x100>
   {
      if (m->m_len > (unsigned)cnt) 
 d0346dc:	e0bfff17 	ldw	r2,-4(fp)
 d0346e0:	10c00217 	ldw	r3,8(r2)
 d0346e4:	e0bffc17 	ldw	r2,-16(fp)
 d0346e8:	10c0242e 	bgeu	r2,r3,d03477c <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 d0346ec:	e0bfff17 	ldw	r2,-4(fp)
 d0346f0:	10c00317 	ldw	r3,12(r2)
 d0346f4:	e0bffc17 	ldw	r2,-16(fp)
 d0346f8:	1885883a 	add	r2,r3,r2
 d0346fc:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 d034700:	e0bffd17 	ldw	r2,-12(fp)
 d034704:	10800117 	ldw	r2,4(r2)
 d034708:	10800917 	ldw	r2,36(r2)
 d03470c:	e0bffa15 	stw	r2,-24(fp)

         tp->t_iobc = *cp;
 d034710:	e0bffb17 	ldw	r2,-20(fp)
 d034714:	10c00003 	ldbu	r3,0(r2)
 d034718:	e0bffa17 	ldw	r2,-24(fp)
 d03471c:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 d034720:	e0bffa17 	ldw	r2,-24(fp)
 d034724:	10802403 	ldbu	r2,144(r2)
 d034728:	10800054 	ori	r2,r2,1
 d03472c:	1007883a 	mov	r3,r2
 d034730:	e0bffa17 	ldw	r2,-24(fp)
 d034734:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 d034738:	e0bffb17 	ldw	r2,-20(fp)
 d03473c:	11400044 	addi	r5,r2,1
 d034740:	e0bfff17 	ldw	r2,-4(fp)
 d034744:	10c00217 	ldw	r3,8(r2)
 d034748:	e0bffc17 	ldw	r2,-16(fp)
 d03474c:	1885c83a 	sub	r2,r3,r2
 d034750:	10ffffc4 	addi	r3,r2,-1
 d034754:	e0bffb17 	ldw	r2,-20(fp)
 d034758:	1009883a 	mov	r4,r2
 d03475c:	180d883a 	mov	r6,r3
 d034760:	d0027000 	call	d002700 <memcpy>
         m->m_len--;
 d034764:	e0bfff17 	ldw	r2,-4(fp)
 d034768:	10800217 	ldw	r2,8(r2)
 d03476c:	10ffffc4 	addi	r3,r2,-1
 d034770:	e0bfff17 	ldw	r2,-4(fp)
 d034774:	10c00215 	stw	r3,8(r2)
         return;
 d034778:	00001106 	br	d0347c0 <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 d03477c:	e0fffc17 	ldw	r3,-16(fp)
 d034780:	e0bfff17 	ldw	r2,-4(fp)
 d034784:	10800217 	ldw	r2,8(r2)
 d034788:	1885c83a 	sub	r2,r3,r2
 d03478c:	e0bffc15 	stw	r2,-16(fp)
      m = m->m_next;
 d034790:	e0bfff17 	ldw	r2,-4(fp)
 d034794:	10800617 	ldw	r2,24(r2)
 d034798:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 d03479c:	e0bfff17 	ldw	r2,-4(fp)
 d0347a0:	1005003a 	cmpeq	r2,r2,zero
 d0347a4:	1000031e 	bne	r2,zero,d0347b4 <tcp_pulloutofband+0x10c>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 d0347a8:	e0bffc17 	ldw	r2,-16(fp)
 d0347ac:	1004403a 	cmpge	r2,r2,zero
 d0347b0:	103fca1e 	bne	r2,zero,d0346dc <tcp_pulloutofband+0x34>
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
   }
   panic("tcp_pulloutofband");
 d0347b4:	01034174 	movhi	r4,3333
 d0347b8:	213e0d04 	addi	r4,r4,-1996
 d0347bc:	d0246440 	call	d024644 <panic>
}
 d0347c0:	e037883a 	mov	sp,fp
 d0347c4:	dfc00117 	ldw	ra,4(sp)
 d0347c8:	df000017 	ldw	fp,0(sp)
 d0347cc:	dec00204 	addi	sp,sp,8
 d0347d0:	f800283a 	ret

0d0347d4 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 d0347d4:	defffb04 	addi	sp,sp,-20
 d0347d8:	dfc00415 	stw	ra,16(sp)
 d0347dc:	df000315 	stw	fp,12(sp)
 d0347e0:	df000304 	addi	fp,sp,12
 d0347e4:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 d0347e8:	e0bfff17 	ldw	r2,-4(fp)
 d0347ec:	10801e17 	ldw	r2,120(r2)
 d0347f0:	1004c03a 	cmpne	r2,r2,zero
 d0347f4:	1000021e 	bne	r2,zero,d034800 <tcp_xmit_timer+0x2c>
 d0347f8:	d0293e80 	call	d0293e8 <dtrap>
 d0347fc:	00008b06 	br	d034a2c <tcp_xmit_timer+0x258>
#endif

   tcpstat.tcps_rttupdated++;
 d034800:	008341b4 	movhi	r2,3334
 d034804:	10b41504 	addi	r2,r2,-12204
 d034808:	10800717 	ldw	r2,28(r2)
 d03480c:	10c00044 	addi	r3,r2,1
 d034810:	008341b4 	movhi	r2,3334
 d034814:	10b41504 	addi	r2,r2,-12204
 d034818:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 d03481c:	00834174 	movhi	r2,3333
 d034820:	108ac904 	addi	r2,r2,11044
 d034824:	10c00017 	ldw	r3,0(r2)
 d034828:	e0bfff17 	ldw	r2,-4(fp)
 d03482c:	10801e17 	ldw	r2,120(r2)
 d034830:	1887c83a 	sub	r3,r3,r2
 d034834:	00800c84 	movi	r2,50
 d034838:	1885203a 	divu	r2,r3,r2
 d03483c:	e0bffd15 	stw	r2,-12(fp)
   if(tp->t_srtt != 0)
 d034840:	e0bfff17 	ldw	r2,-4(fp)
 d034844:	10802017 	ldw	r2,128(r2)
 d034848:	1005003a 	cmpeq	r2,r2,zero
 d03484c:	10004a1e 	bne	r2,zero,d034978 <tcp_xmit_timer+0x1a4>
   {
      if(rtt == 0)      /* fast path for small round trip */
 d034850:	e0bffd17 	ldw	r2,-12(fp)
 d034854:	1004c03a 	cmpne	r2,r2,zero
 d034858:	1000131e 	bne	r2,zero,d0348a8 <tcp_xmit_timer+0xd4>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 d03485c:	e0bfff17 	ldw	r2,-4(fp)
 d034860:	10802017 	ldw	r2,128(r2)
 d034864:	10800090 	cmplti	r2,r2,2
 d034868:	1000051e 	bne	r2,zero,d034880 <tcp_xmit_timer+0xac>
            tp->t_srtt--;
 d03486c:	e0bfff17 	ldw	r2,-4(fp)
 d034870:	10802017 	ldw	r2,128(r2)
 d034874:	10ffffc4 	addi	r3,r2,-1
 d034878:	e0bfff17 	ldw	r2,-4(fp)
 d03487c:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 d034880:	e0bfff17 	ldw	r2,-4(fp)
 d034884:	10802117 	ldw	r2,132(r2)
 d034888:	10800090 	cmplti	r2,r2,2
 d03488c:	1000481e 	bne	r2,zero,d0349b0 <tcp_xmit_timer+0x1dc>
            tp->t_rttvar--;
 d034890:	e0bfff17 	ldw	r2,-4(fp)
 d034894:	10802117 	ldw	r2,132(r2)
 d034898:	10ffffc4 	addi	r3,r2,-1
 d03489c:	e0bfff17 	ldw	r2,-4(fp)
 d0348a0:	10c02115 	stw	r3,132(r2)
 d0348a4:	00004206 	br	d0349b0 <tcp_xmit_timer+0x1dc>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 d0348a8:	e0bffd17 	ldw	r2,-12(fp)
 d0348ac:	10bfffc4 	addi	r2,r2,-1
 d0348b0:	1085883a 	add	r2,r2,r2
 d0348b4:	1085883a 	add	r2,r2,r2
 d0348b8:	1007883a 	mov	r3,r2
 d0348bc:	e0bfff17 	ldw	r2,-4(fp)
 d0348c0:	10802017 	ldw	r2,128(r2)
 d0348c4:	1005d0fa 	srai	r2,r2,3
 d0348c8:	1885c83a 	sub	r2,r3,r2
 d0348cc:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_srtt += delta) <= 0)
 d0348d0:	e0bfff17 	ldw	r2,-4(fp)
 d0348d4:	10c02017 	ldw	r3,128(r2)
 d0348d8:	e0bffe17 	ldw	r2,-8(fp)
 d0348dc:	1887883a 	add	r3,r3,r2
 d0348e0:	e0bfff17 	ldw	r2,-4(fp)
 d0348e4:	10c02015 	stw	r3,128(r2)
 d0348e8:	e0bfff17 	ldw	r2,-4(fp)
 d0348ec:	10802017 	ldw	r2,128(r2)
 d0348f0:	10800048 	cmpgei	r2,r2,1
 d0348f4:	1000031e 	bne	r2,zero,d034904 <tcp_xmit_timer+0x130>
         tp->t_srtt = 1;
 d0348f8:	e0ffff17 	ldw	r3,-4(fp)
 d0348fc:	00800044 	movi	r2,1
 d034900:	18802015 	stw	r2,128(r3)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 d034904:	e0bffe17 	ldw	r2,-8(fp)
 d034908:	1004403a 	cmpge	r2,r2,zero
 d03490c:	1000031e 	bne	r2,zero,d03491c <tcp_xmit_timer+0x148>
         delta = -delta;
 d034910:	e0bffe17 	ldw	r2,-8(fp)
 d034914:	0085c83a 	sub	r2,zero,r2
 d034918:	e0bffe15 	stw	r2,-8(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 d03491c:	e0bfff17 	ldw	r2,-4(fp)
 d034920:	10802117 	ldw	r2,132(r2)
 d034924:	1005d07a 	srai	r2,r2,1
 d034928:	10ffffcc 	andi	r3,r2,65535
 d03492c:	18e0001c 	xori	r3,r3,32768
 d034930:	18e00004 	addi	r3,r3,-32768
 d034934:	e0bffe17 	ldw	r2,-8(fp)
 d034938:	10c5c83a 	sub	r2,r2,r3
 d03493c:	e0bffe15 	stw	r2,-8(fp)
      if ((tp->t_rttvar += delta) <= 0)
 d034940:	e0bfff17 	ldw	r2,-4(fp)
 d034944:	10c02117 	ldw	r3,132(r2)
 d034948:	e0bffe17 	ldw	r2,-8(fp)
 d03494c:	1887883a 	add	r3,r3,r2
 d034950:	e0bfff17 	ldw	r2,-4(fp)
 d034954:	10c02115 	stw	r3,132(r2)
 d034958:	e0bfff17 	ldw	r2,-4(fp)
 d03495c:	10802117 	ldw	r2,132(r2)
 d034960:	10800048 	cmpgei	r2,r2,1
 d034964:	1000121e 	bne	r2,zero,d0349b0 <tcp_xmit_timer+0x1dc>
         tp->t_rttvar = 1;
 d034968:	e0ffff17 	ldw	r3,-4(fp)
 d03496c:	00800044 	movi	r2,1
 d034970:	18802115 	stw	r2,132(r3)
 d034974:	00000e06 	br	d0349b0 <tcp_xmit_timer+0x1dc>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 d034978:	e0bffd17 	ldw	r2,-12(fp)
 d03497c:	10800048 	cmpgei	r2,r2,1
 d034980:	1000021e 	bne	r2,zero,d03498c <tcp_xmit_timer+0x1b8>
         rtt = 1;
 d034984:	00800044 	movi	r2,1
 d034988:	e0bffd15 	stw	r2,-12(fp)
      tp->t_srtt = rtt << 3;
 d03498c:	e0bffd17 	ldw	r2,-12(fp)
 d034990:	100690fa 	slli	r3,r2,3
 d034994:	e0bfff17 	ldw	r2,-4(fp)
 d034998:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 d03499c:	e0bffd17 	ldw	r2,-12(fp)
 d0349a0:	1085883a 	add	r2,r2,r2
 d0349a4:	1007883a 	mov	r3,r2
 d0349a8:	e0bfff17 	ldw	r2,-4(fp)
 d0349ac:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 d0349b0:	e0bfff17 	ldw	r2,-4(fp)
 d0349b4:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 d0349b8:	e0bfff17 	ldw	r2,-4(fp)
 d0349bc:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 d0349c0:	e0bfff17 	ldw	r2,-4(fp)
 d0349c4:	10802017 	ldw	r2,128(r2)
 d0349c8:	1007d0ba 	srai	r3,r2,2
 d0349cc:	e0bfff17 	ldw	r2,-4(fp)
 d0349d0:	10802117 	ldw	r2,132(r2)
 d0349d4:	1885883a 	add	r2,r3,r2
 d0349d8:	1005d07a 	srai	r2,r2,1
 d0349dc:	10ffffcc 	andi	r3,r2,65535
 d0349e0:	18e0001c 	xori	r3,r3,32768
 d0349e4:	18e00004 	addi	r3,r3,-32768
 d0349e8:	e0bfff17 	ldw	r2,-4(fp)
 d0349ec:	10c00815 	stw	r3,32(r2)
 d0349f0:	e0bfff17 	ldw	r2,-4(fp)
 d0349f4:	10800817 	ldw	r2,32(r2)
 d0349f8:	10800088 	cmpgei	r2,r2,2
 d0349fc:	1000041e 	bne	r2,zero,d034a10 <tcp_xmit_timer+0x23c>
 d034a00:	e0ffff17 	ldw	r3,-4(fp)
 d034a04:	00800084 	movi	r2,2
 d034a08:	18800815 	stw	r2,32(r3)
 d034a0c:	00000706 	br	d034a2c <tcp_xmit_timer+0x258>
 d034a10:	e0bfff17 	ldw	r2,-4(fp)
 d034a14:	10800817 	ldw	r2,32(r2)
 d034a18:	10802050 	cmplti	r2,r2,129
 d034a1c:	1000031e 	bne	r2,zero,d034a2c <tcp_xmit_timer+0x258>
 d034a20:	e0ffff17 	ldw	r3,-4(fp)
 d034a24:	00802004 	movi	r2,128
 d034a28:	18800815 	stw	r2,32(r3)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 d034a2c:	e037883a 	mov	sp,fp
 d034a30:	dfc00117 	ldw	ra,4(sp)
 d034a34:	df000017 	ldw	fp,0(sp)
 d034a38:	dec00204 	addi	sp,sp,8
 d034a3c:	f800283a 	ret

0d034a40 <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 d034a40:	defffd04 	addi	sp,sp,-12
 d034a44:	df000215 	stw	fp,8(sp)
 d034a48:	df000204 	addi	fp,sp,8
 d034a4c:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 d034a50:	e0bfff17 	ldw	r2,-4(fp)
 d034a54:	10800117 	ldw	r2,4(r2)
 d034a58:	10800a17 	ldw	r2,40(r2)
 d034a5c:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 d034a60:	e0bffe17 	ldw	r2,-8(fp)
 d034a64:	10c00917 	ldw	r3,36(r2)
 d034a68:	e0bffe17 	ldw	r2,-8(fp)
 d034a6c:	10800817 	ldw	r2,32(r2)
 d034a70:	1885c83a 	sub	r2,r3,r2
 d034a74:	10bff604 	addi	r2,r2,-40
}
 d034a78:	e037883a 	mov	sp,fp
 d034a7c:	df000017 	ldw	fp,0(sp)
 d034a80:	dec00104 	addi	sp,sp,4
 d034a84:	f800283a 	ret

0d034a88 <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 d034a88:	defff904 	addi	sp,sp,-28
 d034a8c:	dfc00615 	stw	ra,24(sp)
 d034a90:	df000515 	stw	fp,20(sp)
 d034a94:	df000504 	addi	fp,sp,20
 d034a98:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 d034a9c:	e0bffe17 	ldw	r2,-8(fp)
 d034aa0:	1005003a 	cmpeq	r2,r2,zero
 d034aa4:	1000091e 	bne	r2,zero,d034acc <tcp_mss+0x44>
 d034aa8:	e0bffe17 	ldw	r2,-8(fp)
 d034aac:	10800117 	ldw	r2,4(r2)
 d034ab0:	1005003a 	cmpeq	r2,r2,zero
 d034ab4:	1000051e 	bne	r2,zero,d034acc <tcp_mss+0x44>
 d034ab8:	e0bffe17 	ldw	r2,-8(fp)
 d034abc:	10800117 	ldw	r2,4(r2)
 d034ac0:	10800a17 	ldw	r2,40(r2)
 d034ac4:	1004c03a 	cmpne	r2,r2,zero
 d034ac8:	1000071e 	bne	r2,zero,d034ae8 <tcp_mss+0x60>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 d034acc:	e0bffe17 	ldw	r2,-8(fp)
 d034ad0:	10800517 	ldw	r2,20(r2)
 d034ad4:	10800098 	cmpnei	r2,r2,2
 d034ad8:	1000031e 	bne	r2,zero,d034ae8 <tcp_mss+0x60>
         return TCP_MSS;            /* user defined */
 d034adc:	00816d04 	movi	r2,1460
 d034ae0:	e0bfff15 	stw	r2,-4(fp)
 d034ae4:	00002906 	br	d034b8c <tcp_mss+0x104>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 d034ae8:	e13ffe17 	ldw	r4,-8(fp)
 d034aec:	d034a400 	call	d034a40 <ip4_tcpmss>
 d034af0:	e0bffd15 	stw	r2,-12(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 d034af4:	e0bffd17 	ldw	r2,-12(fp)
 d034af8:	10816d50 	cmplti	r2,r2,1461
 d034afc:	1000021e 	bne	r2,zero,d034b08 <tcp_mss+0x80>
      mss = TCP_MSS;
 d034b00:	00816d04 	movi	r2,1460
 d034b04:	e0bffd15 	stw	r2,-12(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 d034b08:	e0bffe17 	ldw	r2,-8(fp)
 d034b0c:	10800117 	ldw	r2,4(r2)
 d034b10:	e0bffc15 	stw	r2,-16(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 d034b14:	e0bffc17 	ldw	r2,-16(fp)
 d034b18:	10800917 	ldw	r2,36(r2)
 d034b1c:	e0bffb15 	stw	r2,-20(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 d034b20:	e0bffb17 	ldw	r2,-20(fp)
 d034b24:	10800b0b 	ldhu	r2,44(r2)
 d034b28:	10bfffcc 	andi	r2,r2,65535
 d034b2c:	1081000c 	andi	r2,r2,1024
 d034b30:	1005003a 	cmpeq	r2,r2,zero
 d034b34:	1000051e 	bne	r2,zero,d034b4c <tcp_mss+0xc4>
      return tp->t_maxseg;    /* yup */
 d034b38:	e0bffb17 	ldw	r2,-20(fp)
 d034b3c:	10800a0b 	ldhu	r2,40(r2)
 d034b40:	10bfffcc 	andi	r2,r2,65535
 d034b44:	e0bfff15 	stw	r2,-4(fp)
 d034b48:	00001006 	br	d034b8c <tcp_mss+0x104>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 d034b4c:	e0bffb17 	ldw	r2,-20(fp)
 d034b50:	10800a0b 	ldhu	r2,40(r2)
 d034b54:	10bfffcc 	andi	r2,r2,65535
 d034b58:	1005003a 	cmpeq	r2,r2,zero
 d034b5c:	1000091e 	bne	r2,zero,d034b84 <tcp_mss+0xfc>
 d034b60:	e0bffb17 	ldw	r2,-20(fp)
 d034b64:	10800a0b 	ldhu	r2,40(r2)
 d034b68:	10ffffcc 	andi	r3,r2,65535
 d034b6c:	e0bffd17 	ldw	r2,-12(fp)
 d034b70:	1880040e 	bge	r3,r2,d034b84 <tcp_mss+0xfc>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 d034b74:	e0bffb17 	ldw	r2,-20(fp)
 d034b78:	10800a0b 	ldhu	r2,40(r2)
 d034b7c:	10bfffcc 	andi	r2,r2,65535
 d034b80:	e0bffd15 	stw	r2,-12(fp)
   }

   return mss;
 d034b84:	e0bffd17 	ldw	r2,-12(fp)
 d034b88:	e0bfff15 	stw	r2,-4(fp)
 d034b8c:	e0bfff17 	ldw	r2,-4(fp)
}
 d034b90:	e037883a 	mov	sp,fp
 d034b94:	dfc00117 	ldw	ra,4(sp)
 d034b98:	df000017 	ldw	fp,0(sp)
 d034b9c:	dec00204 	addi	sp,sp,8
 d034ba0:	f800283a 	ret

0d034ba4 <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 d034ba4:	deffe004 	addi	sp,sp,-128
 d034ba8:	dfc01f15 	stw	ra,124(sp)
 d034bac:	df001e15 	stw	fp,120(sp)
 d034bb0:	df001e04 	addi	fp,sp,120
 d034bb4:	e13ff715 	stw	r4,-36(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 d034bb8:	e0bff717 	ldw	r2,-36(fp)
 d034bbc:	10800d17 	ldw	r2,52(r2)
 d034bc0:	10800817 	ldw	r2,32(r2)
 d034bc4:	e0bff515 	stw	r2,-44(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 d034bc8:	e03fed15 	stw	zero,-76(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 d034bcc:	e0bff717 	ldw	r2,-36(fp)
 d034bd0:	10c01a17 	ldw	r3,104(r2)
 d034bd4:	e0bff717 	ldw	r2,-36(fp)
 d034bd8:	10800e17 	ldw	r2,56(r2)
 d034bdc:	1885003a 	cmpeq	r2,r3,r2
 d034be0:	e0bfec15 	stw	r2,-80(fp)

again:
   sendalot = 0;
 d034be4:	e03feb15 	stw	zero,-84(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 d034be8:	e0bff717 	ldw	r2,-36(fp)
 d034bec:	10c00f17 	ldw	r3,60(r2)
 d034bf0:	e0bff717 	ldw	r2,-36(fp)
 d034bf4:	10800e17 	ldw	r2,56(r2)
 d034bf8:	1885c83a 	sub	r2,r3,r2
 d034bfc:	e0bff215 	stw	r2,-56(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 d034c00:	e0bff717 	ldw	r2,-36(fp)
 d034c04:	10801417 	ldw	r2,80(r2)
 d034c08:	e0bff315 	stw	r2,-52(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 d034c0c:	e0bff717 	ldw	r2,-36(fp)
 d034c10:	10801b17 	ldw	r2,108(r2)
 d034c14:	1007883a 	mov	r3,r2
 d034c18:	e0bff317 	ldw	r2,-52(fp)
 d034c1c:	1880060e 	bge	r3,r2,d034c38 <tcp_output+0x94>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 d034c20:	e0bff717 	ldw	r2,-36(fp)
 d034c24:	10801b17 	ldw	r2,108(r2)
 d034c28:	1007883a 	mov	r3,r2
 d034c2c:	00bfff04 	movi	r2,-4
 d034c30:	1884703a 	and	r2,r3,r2
 d034c34:	e0bff315 	stw	r2,-52(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 d034c38:	e0bff717 	ldw	r2,-36(fp)
 d034c3c:	10800a83 	ldbu	r2,42(r2)
 d034c40:	10803fcc 	andi	r2,r2,255
 d034c44:	1080201c 	xori	r2,r2,128
 d034c48:	10bfe004 	addi	r2,r2,-128
 d034c4c:	1005003a 	cmpeq	r2,r2,zero
 d034c50:	10000a1e 	bne	r2,zero,d034c7c <tcp_output+0xd8>
   {
      if (win == 0)
 d034c54:	e0bff317 	ldw	r2,-52(fp)
 d034c58:	1004c03a 	cmpne	r2,r2,zero
 d034c5c:	1000031e 	bne	r2,zero,d034c6c <tcp_output+0xc8>
         win = 1;
 d034c60:	00800044 	movi	r2,1
 d034c64:	e0bff315 	stw	r2,-52(fp)
 d034c68:	00000406 	br	d034c7c <tcp_output+0xd8>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 d034c6c:	e0bff717 	ldw	r2,-36(fp)
 d034c70:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 d034c74:	e0bff717 	ldw	r2,-36(fp)
 d034c78:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 d034c7c:	e0bff517 	ldw	r2,-44(fp)
 d034c80:	10801217 	ldw	r2,72(r2)
 d034c84:	e0fff317 	ldw	r3,-52(fp)
 d034c88:	e0fffb15 	stw	r3,-20(fp)
 d034c8c:	e0bffa15 	stw	r2,-24(fp)
 d034c90:	e0bffb17 	ldw	r2,-20(fp)
 d034c94:	e0fffa17 	ldw	r3,-24(fp)
 d034c98:	10c0022e 	bgeu	r2,r3,d034ca4 <tcp_output+0x100>
 d034c9c:	e0bffb17 	ldw	r2,-20(fp)
 d034ca0:	e0bffa15 	stw	r2,-24(fp)
 d034ca4:	e0fffa17 	ldw	r3,-24(fp)
 d034ca8:	e0bff217 	ldw	r2,-56(fp)
 d034cac:	1885c83a 	sub	r2,r3,r2
 d034cb0:	e0bff415 	stw	r2,-48(fp)
   }

   flags = tcp_outflags[tp->t_state];
 d034cb4:	e0bff717 	ldw	r2,-36(fp)
 d034cb8:	10c00217 	ldw	r3,8(r2)
 d034cbc:	00834174 	movhi	r2,3333
 d034cc0:	10894d04 	addi	r2,r2,9524
 d034cc4:	10c5883a 	add	r2,r2,r3
 d034cc8:	10800003 	ldbu	r2,0(r2)
 d034ccc:	10803fcc 	andi	r2,r2,255
 d034cd0:	e0bff115 	stw	r2,-60(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 d034cd4:	e0bff117 	ldw	r2,-60(fp)
 d034cd8:	1080008c 	andi	r2,r2,2
 d034cdc:	1005003a 	cmpeq	r2,r2,zero
 d034ce0:	1000081e 	bne	r2,zero,d034d04 <tcp_output+0x160>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 d034ce4:	e0ffed17 	ldw	r3,-76(fp)
 d034ce8:	d0a0b304 	addi	r2,gp,-32052
 d034cec:	188b883a 	add	r5,r3,r2
 d034cf0:	e13ff717 	ldw	r4,-36(fp)
 d034cf4:	e1bff117 	ldw	r6,-60(fp)
 d034cf8:	e1fff517 	ldw	r7,-44(fp)
 d034cfc:	d035e1c0 	call	d035e1c <bld_options>
 d034d00:	e0bfed15 	stw	r2,-76(fp)
   }
#endif

   if (len < 0)
 d034d04:	e0bff417 	ldw	r2,-48(fp)
 d034d08:	1004403a 	cmpge	r2,r2,zero
 d034d0c:	10000a1e 	bne	r2,zero,d034d38 <tcp_output+0x194>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 d034d10:	e03ff415 	stw	zero,-48(fp)
      if (win == 0) 
 d034d14:	e0bff317 	ldw	r2,-52(fp)
 d034d18:	1004c03a 	cmpne	r2,r2,zero
 d034d1c:	1000061e 	bne	r2,zero,d034d38 <tcp_output+0x194>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 d034d20:	e0bff717 	ldw	r2,-36(fp)
 d034d24:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 d034d28:	e0bff717 	ldw	r2,-36(fp)
 d034d2c:	10c00e17 	ldw	r3,56(r2)
 d034d30:	e0bff717 	ldw	r2,-36(fp)
 d034d34:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 d034d38:	e0bff717 	ldw	r2,-36(fp)
 d034d3c:	10800a0b 	ldhu	r2,40(r2)
 d034d40:	10ffffcc 	andi	r3,r2,65535
 d034d44:	e0bff417 	ldw	r2,-48(fp)
 d034d48:	1880060e 	bge	r3,r2,d034d64 <tcp_output+0x1c0>
   {
      len = tp->t_maxseg;
 d034d4c:	e0bff717 	ldw	r2,-36(fp)
 d034d50:	10800a0b 	ldhu	r2,40(r2)
 d034d54:	10bfffcc 	andi	r2,r2,65535
 d034d58:	e0bff415 	stw	r2,-48(fp)
      sendalot = 1;
 d034d5c:	00800044 	movi	r2,1
 d034d60:	e0bfeb15 	stw	r2,-84(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 d034d64:	e0bff717 	ldw	r2,-36(fp)
 d034d68:	10c00f17 	ldw	r3,60(r2)
 d034d6c:	e0bff417 	ldw	r2,-48(fp)
 d034d70:	1889883a 	add	r4,r3,r2
 d034d74:	e0bff717 	ldw	r2,-36(fp)
 d034d78:	10c00e17 	ldw	r3,56(r2)
 d034d7c:	e0bff517 	ldw	r2,-44(fp)
 d034d80:	10801217 	ldw	r2,72(r2)
 d034d84:	1885883a 	add	r2,r3,r2
 d034d88:	2085c83a 	sub	r2,r4,r2
 d034d8c:	1004403a 	cmpge	r2,r2,zero
 d034d90:	1000041e 	bne	r2,zero,d034da4 <tcp_output+0x200>
      flags &= ~TH_FIN;
 d034d94:	e0bff117 	ldw	r2,-60(fp)
 d034d98:	00ffff84 	movi	r3,-2
 d034d9c:	10c4703a 	and	r2,r2,r3
 d034da0:	e0bff115 	stw	r2,-60(fp)
   win = (long)(sbspace(&so->so_rcv));
 d034da4:	e0bff517 	ldw	r2,-44(fp)
 d034da8:	10800b17 	ldw	r2,44(r2)
 d034dac:	1007883a 	mov	r3,r2
 d034db0:	e0bff517 	ldw	r2,-44(fp)
 d034db4:	10800a17 	ldw	r2,40(r2)
 d034db8:	1885c83a 	sub	r2,r3,r2
 d034dbc:	1004803a 	cmplt	r2,r2,zero
 d034dc0:	1000071e 	bne	r2,zero,d034de0 <tcp_output+0x23c>
 d034dc4:	e0bff517 	ldw	r2,-44(fp)
 d034dc8:	10c00b17 	ldw	r3,44(r2)
 d034dcc:	e0bff517 	ldw	r2,-44(fp)
 d034dd0:	10800a17 	ldw	r2,40(r2)
 d034dd4:	1885c83a 	sub	r2,r3,r2
 d034dd8:	e0bff915 	stw	r2,-28(fp)
 d034ddc:	00000106 	br	d034de4 <tcp_output+0x240>
 d034de0:	e03ff915 	stw	zero,-28(fp)
 d034de4:	e0fff917 	ldw	r3,-28(fp)
 d034de8:	e0fff315 	stw	r3,-52(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 d034dec:	e0bff117 	ldw	r2,-60(fp)
 d034df0:	1080004c 	andi	r2,r2,1
 d034df4:	10803fcc 	andi	r2,r2,255
 d034df8:	1005003a 	cmpeq	r2,r2,zero
 d034dfc:	10000f1e 	bne	r2,zero,d034e3c <tcp_output+0x298>
 d034e00:	e0bff517 	ldw	r2,-44(fp)
 d034e04:	10801217 	ldw	r2,72(r2)
 d034e08:	1004c03a 	cmpne	r2,r2,zero
 d034e0c:	10000b1e 	bne	r2,zero,d034e3c <tcp_output+0x298>
 d034e10:	e0bff717 	ldw	r2,-36(fp)
 d034e14:	10800b0b 	ldhu	r2,44(r2)
 d034e18:	10bfffcc 	andi	r2,r2,65535
 d034e1c:	1080040c 	andi	r2,r2,16
 d034e20:	1005003a 	cmpeq	r2,r2,zero
 d034e24:	1000721e 	bne	r2,zero,d034ff0 <tcp_output+0x44c>
 d034e28:	e0bff717 	ldw	r2,-36(fp)
 d034e2c:	10c00f17 	ldw	r3,60(r2)
 d034e30:	e0bff717 	ldw	r2,-36(fp)
 d034e34:	10800e17 	ldw	r2,56(r2)
 d034e38:	18806d26 	beq	r3,r2,d034ff0 <tcp_output+0x44c>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 d034e3c:	e0bff717 	ldw	r2,-36(fp)
 d034e40:	10800b0b 	ldhu	r2,44(r2)
 d034e44:	10bfffcc 	andi	r2,r2,65535
 d034e48:	1080004c 	andi	r2,r2,1
 d034e4c:	10803fcc 	andi	r2,r2,255
 d034e50:	1004c03a 	cmpne	r2,r2,zero
 d034e54:	1000661e 	bne	r2,zero,d034ff0 <tcp_output+0x44c>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 d034e58:	e0bff117 	ldw	r2,-60(fp)
 d034e5c:	1080018c 	andi	r2,r2,6
 d034e60:	1004c03a 	cmpne	r2,r2,zero
 d034e64:	1000621e 	bne	r2,zero,d034ff0 <tcp_output+0x44c>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 d034e68:	e0bff717 	ldw	r2,-36(fp)
 d034e6c:	10c01017 	ldw	r3,64(r2)
 d034e70:	e0bff717 	ldw	r2,-36(fp)
 d034e74:	10800e17 	ldw	r2,56(r2)
 d034e78:	1885c83a 	sub	r2,r3,r2
 d034e7c:	10800048 	cmpgei	r2,r2,1
 d034e80:	10005b1e 	bne	r2,zero,d034ff0 <tcp_output+0x44c>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 d034e84:	e0bff417 	ldw	r2,-48(fp)
 d034e88:	1005003a 	cmpeq	r2,r2,zero
 d034e8c:	1000281e 	bne	r2,zero,d034f30 <tcp_output+0x38c>
   {
      if (len == (int)tp->t_maxseg)
 d034e90:	e0bff717 	ldw	r2,-36(fp)
 d034e94:	10800a0b 	ldhu	r2,40(r2)
 d034e98:	10ffffcc 	andi	r3,r2,65535
 d034e9c:	e0bff417 	ldw	r2,-48(fp)
 d034ea0:	18805326 	beq	r3,r2,d034ff0 <tcp_output+0x44c>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 d034ea4:	e0bfec17 	ldw	r2,-80(fp)
 d034ea8:	1004c03a 	cmpne	r2,r2,zero
 d034eac:	1000061e 	bne	r2,zero,d034ec8 <tcp_output+0x324>
 d034eb0:	e0bff717 	ldw	r2,-36(fp)
 d034eb4:	10800b0b 	ldhu	r2,44(r2)
 d034eb8:	10bfffcc 	andi	r2,r2,65535
 d034ebc:	1080010c 	andi	r2,r2,4
 d034ec0:	1005003a 	cmpeq	r2,r2,zero
 d034ec4:	1000061e 	bne	r2,zero,d034ee0 <tcp_output+0x33c>
 d034ec8:	e0fff417 	ldw	r3,-48(fp)
 d034ecc:	e0bff217 	ldw	r2,-56(fp)
 d034ed0:	1887883a 	add	r3,r3,r2
 d034ed4:	e0bff517 	ldw	r2,-44(fp)
 d034ed8:	10801217 	ldw	r2,72(r2)
 d034edc:	1880440e 	bge	r3,r2,d034ff0 <tcp_output+0x44c>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 d034ee0:	e0bff717 	ldw	r2,-36(fp)
 d034ee4:	10800a83 	ldbu	r2,42(r2)
 d034ee8:	10803fcc 	andi	r2,r2,255
 d034eec:	1080201c 	xori	r2,r2,128
 d034ef0:	10bfe004 	addi	r2,r2,-128
 d034ef4:	1004c03a 	cmpne	r2,r2,zero
 d034ef8:	10003d1e 	bne	r2,zero,d034ff0 <tcp_output+0x44c>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 d034efc:	e0bff717 	ldw	r2,-36(fp)
 d034f00:	10802317 	ldw	r2,140(r2)
 d034f04:	1004d07a 	srli	r2,r2,1
 d034f08:	1007883a 	mov	r3,r2
 d034f0c:	e0bff417 	ldw	r2,-48(fp)
 d034f10:	10c0370e 	bge	r2,r3,d034ff0 <tcp_output+0x44c>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 d034f14:	e0bff717 	ldw	r2,-36(fp)
 d034f18:	10c00f17 	ldw	r3,60(r2)
 d034f1c:	e0bff717 	ldw	r2,-36(fp)
 d034f20:	10801a17 	ldw	r2,104(r2)
 d034f24:	1885c83a 	sub	r2,r3,r2
 d034f28:	1004803a 	cmplt	r2,r2,zero
 d034f2c:	1000301e 	bne	r2,zero,d034ff0 <tcp_output+0x44c>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 d034f30:	e0bff317 	ldw	r2,-52(fp)
 d034f34:	10800050 	cmplti	r2,r2,1
 d034f38:	10001b1e 	bne	r2,zero,d034fa8 <tcp_output+0x404>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 d034f3c:	e0bff717 	ldw	r2,-36(fp)
 d034f40:	10c01917 	ldw	r3,100(r2)
 d034f44:	e0bff717 	ldw	r2,-36(fp)
 d034f48:	10801617 	ldw	r2,88(r2)
 d034f4c:	1885c83a 	sub	r2,r3,r2
 d034f50:	1007883a 	mov	r3,r2
 d034f54:	e0bff317 	ldw	r2,-52(fp)
 d034f58:	10c5c83a 	sub	r2,r2,r3
 d034f5c:	e0bfe715 	stw	r2,-100(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 d034f60:	e0bff517 	ldw	r2,-44(fp)
 d034f64:	10800a17 	ldw	r2,40(r2)
 d034f68:	1004c03a 	cmpne	r2,r2,zero
 d034f6c:	1000071e 	bne	r2,zero,d034f8c <tcp_output+0x3e8>
 d034f70:	e0bff717 	ldw	r2,-36(fp)
 d034f74:	10800a0b 	ldhu	r2,40(r2)
 d034f78:	10bfffcc 	andi	r2,r2,65535
 d034f7c:	1085883a 	add	r2,r2,r2
 d034f80:	1007883a 	mov	r3,r2
 d034f84:	e0bfe717 	ldw	r2,-100(fp)
 d034f88:	10c0190e 	bge	r2,r3,d034ff0 <tcp_output+0x44c>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 d034f8c:	e0bfe717 	ldw	r2,-100(fp)
 d034f90:	10c01924 	muli	r3,r2,100
 d034f94:	e0bff517 	ldw	r2,-44(fp)
 d034f98:	10800b17 	ldw	r2,44(r2)
 d034f9c:	1885203a 	divu	r2,r3,r2
 d034fa0:	108008e8 	cmpgeui	r2,r2,35
 d034fa4:	1000121e 	bne	r2,zero,d034ff0 <tcp_output+0x44c>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 d034fa8:	e0bff517 	ldw	r2,-44(fp)
 d034fac:	10801217 	ldw	r2,72(r2)
 d034fb0:	1005003a 	cmpeq	r2,r2,zero
 d034fb4:	10000c1e 	bne	r2,zero,d034fe8 <tcp_output+0x444>
 d034fb8:	e0bff717 	ldw	r2,-36(fp)
 d034fbc:	10800317 	ldw	r2,12(r2)
 d034fc0:	1004c03a 	cmpne	r2,r2,zero
 d034fc4:	1000081e 	bne	r2,zero,d034fe8 <tcp_output+0x444>
 d034fc8:	e0bff717 	ldw	r2,-36(fp)
 d034fcc:	10800417 	ldw	r2,16(r2)
 d034fd0:	1004c03a 	cmpne	r2,r2,zero
 d034fd4:	1000041e 	bne	r2,zero,d034fe8 <tcp_output+0x444>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 d034fd8:	e0bff717 	ldw	r2,-36(fp)
 d034fdc:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 d034fe0:	e13ff717 	ldw	r4,-36(fp)
 d034fe4:	d035d200 	call	d035d20 <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 d034fe8:	e03ff815 	stw	zero,-32(fp)
 d034fec:	00034606 	br	d035d08 <tcp_output+0x1164>

send:
   ENTER_CRIT_SECTION(tp);
 d034ff0:	d0295e80 	call	d0295e8 <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 d034ff4:	e0bff217 	ldw	r2,-56(fp)
 d034ff8:	e0bfe815 	stw	r2,-96(fp)
   sendm = so->so_snd.sb_mb;
 d034ffc:	e0bff517 	ldw	r2,-44(fp)
 d035000:	10801817 	ldw	r2,96(r2)
 d035004:	e0bfea15 	stw	r2,-88(fp)
   if (len)
 d035008:	e0bff417 	ldw	r2,-48(fp)
 d03500c:	1005003a 	cmpeq	r2,r2,zero
 d035010:	10006b1e 	bne	r2,zero,d0351c0 <tcp_output+0x61c>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 d035014:	00000b06 	br	d035044 <tcp_output+0x4a0>
      {
         bufoff -= sendm->m_len;
 d035018:	e0ffe817 	ldw	r3,-96(fp)
 d03501c:	e0bfea17 	ldw	r2,-88(fp)
 d035020:	10800217 	ldw	r2,8(r2)
 d035024:	1885c83a 	sub	r2,r3,r2
 d035028:	e0bfe815 	stw	r2,-96(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 d03502c:	e0bfe817 	ldw	r2,-96(fp)
 d035030:	1004803a 	cmplt	r2,r2,zero
 d035034:	1000061e 	bne	r2,zero,d035050 <tcp_output+0x4ac>
            break;
         sendm = sendm->m_next;
 d035038:	e0bfea17 	ldw	r2,-88(fp)
 d03503c:	10800617 	ldw	r2,24(r2)
 d035040:	e0bfea15 	stw	r2,-88(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 d035044:	e0bfea17 	ldw	r2,-88(fp)
 d035048:	1004c03a 	cmpne	r2,r2,zero
 d03504c:	103ff21e 	bne	r2,zero,d035018 <tcp_output+0x474>
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 d035050:	e0bfea17 	ldw	r2,-88(fp)
 d035054:	1004c03a 	cmpne	r2,r2,zero
 d035058:	1000011e 	bne	r2,zero,d035060 <tcp_output+0x4bc>
 d03505c:	d0293e80 	call	d0293e8 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 d035060:	e0bfea17 	ldw	r2,-88(fp)
 d035064:	10c00217 	ldw	r3,8(r2)
 d035068:	e0bfe817 	ldw	r2,-96(fp)
 d03506c:	1885883a 	add	r2,r3,r2
 d035070:	e0bfe815 	stw	r2,-96(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 d035074:	e0bfea17 	ldw	r2,-88(fp)
 d035078:	10800617 	ldw	r2,24(r2)
 d03507c:	1005003a 	cmpeq	r2,r2,zero
 d035080:	10000b1e 	bne	r2,zero,d0350b0 <tcp_output+0x50c>
 d035084:	e0bfea17 	ldw	r2,-88(fp)
 d035088:	10800217 	ldw	r2,8(r2)
 d03508c:	1007883a 	mov	r3,r2
 d035090:	e0bff417 	ldw	r2,-48(fp)
 d035094:	1880060e 	bge	r3,r2,d0350b0 <tcp_output+0x50c>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 d035098:	e0fff117 	ldw	r3,-60(fp)
 d03509c:	00bfff84 	movi	r2,-2
 d0350a0:	1884703a 	and	r2,r3,r2
 d0350a4:	e0bff115 	stw	r2,-60(fp)
         sendalot = 1;     /* set to send more segments */
 d0350a8:	00800044 	movi	r2,1
 d0350ac:	e0bfeb15 	stw	r2,-84(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 d0350b0:	e0bff117 	ldw	r2,-60(fp)
 d0350b4:	1080004c 	andi	r2,r2,1
 d0350b8:	10803fcc 	andi	r2,r2,255
 d0350bc:	1005003a 	cmpeq	r2,r2,zero
 d0350c0:	1000081e 	bne	r2,zero,d0350e4 <tcp_output+0x540>
 d0350c4:	e0bff517 	ldw	r2,-44(fp)
 d0350c8:	10c01217 	ldw	r3,72(r2)
 d0350cc:	e0bff417 	ldw	r2,-48(fp)
 d0350d0:	10c0042e 	bgeu	r2,r3,d0350e4 <tcp_output+0x540>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 d0350d4:	e0bff117 	ldw	r2,-60(fp)
 d0350d8:	00ffff84 	movi	r3,-2
 d0350dc:	10c4703a 	and	r2,r2,r3
 d0350e0:	e0bff115 	stw	r2,-60(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 d0350e4:	e0bfea17 	ldw	r2,-88(fp)
 d0350e8:	10800217 	ldw	r2,8(r2)
 d0350ec:	e0fff417 	ldw	r3,-48(fp)
 d0350f0:	e0fffd15 	stw	r3,-12(fp)
 d0350f4:	e0bffc15 	stw	r2,-16(fp)
 d0350f8:	e0bffd17 	ldw	r2,-12(fp)
 d0350fc:	e0fffc17 	ldw	r3,-16(fp)
 d035100:	10c0020e 	bge	r2,r3,d03510c <tcp_output+0x568>
 d035104:	e0bffd17 	ldw	r2,-12(fp)
 d035108:	e0bffc15 	stw	r2,-16(fp)
 d03510c:	e0fffc17 	ldw	r3,-16(fp)
 d035110:	e0fff415 	stw	r3,-48(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 d035114:	e0bfe817 	ldw	r2,-96(fp)
 d035118:	1004c03a 	cmpne	r2,r2,zero
 d03511c:	1000091e 	bne	r2,zero,d035144 <tcp_output+0x5a0>
 d035120:	e0bfea17 	ldw	r2,-88(fp)
 d035124:	10800317 	ldw	r2,12(r2)
 d035128:	1007883a 	mov	r3,r2
 d03512c:	e0bfea17 	ldw	r2,-88(fp)
 d035130:	10800417 	ldw	r2,16(r2)
 d035134:	1885c83a 	sub	r2,r3,r2
 d035138:	108000cc 	andi	r2,r2,3
 d03513c:	1005003a 	cmpeq	r2,r2,zero
 d035140:	10001f1e 	bne	r2,zero,d0351c0 <tcp_output+0x61c>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 d035144:	e0bfea17 	ldw	r2,-88(fp)
 d035148:	10c00217 	ldw	r3,8(r2)
 d03514c:	e0bfe817 	ldw	r2,-96(fp)
 d035150:	1885c83a 	sub	r2,r3,r2
 d035154:	e0fff417 	ldw	r3,-48(fp)
 d035158:	e0ffff15 	stw	r3,-4(fp)
 d03515c:	e0bffe15 	stw	r2,-8(fp)
 d035160:	e0bfff17 	ldw	r2,-4(fp)
 d035164:	e0fffe17 	ldw	r3,-8(fp)
 d035168:	10c0020e 	bge	r2,r3,d035174 <tcp_output+0x5d0>
 d03516c:	e0bfff17 	ldw	r2,-4(fp)
 d035170:	e0bffe15 	stw	r2,-8(fp)
 d035174:	e0fffe17 	ldw	r3,-8(fp)
 d035178:	e0fff415 	stw	r3,-48(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 d03517c:	00834174 	movhi	r2,3333
 d035180:	108a5804 	addi	r2,r2,10592
 d035184:	10800017 	ldw	r2,0(r2)
 d035188:	10bff204 	addi	r2,r2,-56
 d03518c:	1007883a 	mov	r3,r2
 d035190:	e0bff417 	ldw	r2,-48(fp)
 d035194:	18800a0e 	bge	r3,r2,d0351c0 <tcp_output+0x61c>
 d035198:	008341b4 	movhi	r2,3334
 d03519c:	10b34c04 	addi	r2,r2,-13008
 d0351a0:	10800217 	ldw	r2,8(r2)
 d0351a4:	10800088 	cmpgei	r2,r2,2
 d0351a8:	1000051e 	bne	r2,zero,d0351c0 <tcp_output+0x61c>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 d0351ac:	00834174 	movhi	r2,3333
 d0351b0:	108a5804 	addi	r2,r2,10592
 d0351b4:	10800017 	ldw	r2,0(r2)
 d0351b8:	10bff204 	addi	r2,r2,-56
 d0351bc:	e0bff415 	stw	r2,-48(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 d0351c0:	e0bff417 	ldw	r2,-48(fp)
 d0351c4:	1005003a 	cmpeq	r2,r2,zero
 d0351c8:	10003b1e 	bne	r2,zero,d0352b8 <tcp_output+0x714>
 d0351cc:	e0bfe817 	ldw	r2,-96(fp)
 d0351d0:	1004c03a 	cmpne	r2,r2,zero
 d0351d4:	1000381e 	bne	r2,zero,d0352b8 <tcp_output+0x714>
 d0351d8:	e0bfea17 	ldw	r2,-88(fp)
 d0351dc:	10800117 	ldw	r2,4(r2)
 d0351e0:	10800917 	ldw	r2,36(r2)
 d0351e4:	10800058 	cmpnei	r2,r2,1
 d0351e8:	1000331e 	bne	r2,zero,d0352b8 <tcp_output+0x714>
 d0351ec:	e0bfea17 	ldw	r2,-88(fp)
 d0351f0:	10800317 	ldw	r2,12(r2)
 d0351f4:	1007883a 	mov	r3,r2
 d0351f8:	e0bfea17 	ldw	r2,-88(fp)
 d0351fc:	10800417 	ldw	r2,16(r2)
 d035200:	1885c83a 	sub	r2,r3,r2
 d035204:	108000cc 	andi	r2,r2,3
 d035208:	1004c03a 	cmpne	r2,r2,zero
 d03520c:	10002a1e 	bne	r2,zero,d0352b8 <tcp_output+0x714>
 d035210:	e0bfed17 	ldw	r2,-76(fp)
 d035214:	1004c03a 	cmpne	r2,r2,zero
 d035218:	1000271e 	bne	r2,zero,d0352b8 <tcp_output+0x714>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 d03521c:	01000084 	movi	r4,2
 d035220:	000b883a 	mov	r5,zero
 d035224:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d035228:	e0bfef15 	stw	r2,-68(fp)
      if (!m)
 d03522c:	e0bfef17 	ldw	r2,-68(fp)
 d035230:	1004c03a 	cmpne	r2,r2,zero
 d035234:	1000041e 	bne	r2,zero,d035248 <tcp_output+0x6a4>
      {
         EXIT_CRIT_SECTION(tp);
 d035238:	d0296440 	call	d029644 <irq_Unmask>
         return (ENOBUFS);
 d03523c:	00801a44 	movi	r2,105
 d035240:	e0bff815 	stw	r2,-32(fp)
 d035244:	0002b006 	br	d035d08 <tcp_output+0x1164>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 d035248:	e0bfea17 	ldw	r2,-88(fp)
 d03524c:	10c00117 	ldw	r3,4(r2)
 d035250:	e0bfef17 	ldw	r2,-68(fp)
 d035254:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 d035258:	e0bfef17 	ldw	r2,-68(fp)
 d03525c:	10c00117 	ldw	r3,4(r2)
 d035260:	18800917 	ldw	r2,36(r3)
 d035264:	10800044 	addi	r2,r2,1
 d035268:	18800915 	stw	r2,36(r3)
      m->m_base = sendm->m_base; /* clone mbuf members */
 d03526c:	e0bfea17 	ldw	r2,-88(fp)
 d035270:	10c00417 	ldw	r3,16(r2)
 d035274:	e0bfef17 	ldw	r2,-68(fp)
 d035278:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 d03527c:	e0bfea17 	ldw	r2,-88(fp)
 d035280:	10c00517 	ldw	r3,20(r2)
 d035284:	e0bfef17 	ldw	r2,-68(fp)
 d035288:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 d03528c:	e0bff417 	ldw	r2,-48(fp)
 d035290:	10800a04 	addi	r2,r2,40
 d035294:	1007883a 	mov	r3,r2
 d035298:	e0bfef17 	ldw	r2,-68(fp)
 d03529c:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 d0352a0:	e0bfea17 	ldw	r2,-88(fp)
 d0352a4:	10800317 	ldw	r2,12(r2)
 d0352a8:	10fff604 	addi	r3,r2,-40
 d0352ac:	e0bfef17 	ldw	r2,-68(fp)
 d0352b0:	10c00315 	stw	r3,12(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 d0352b4:	00002e06 	br	d035370 <tcp_output+0x7cc>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 d0352b8:	00834174 	movhi	r2,3333
 d0352bc:	108aa204 	addi	r2,r2,10888
 d0352c0:	10800017 	ldw	r2,0(r2)
 d0352c4:	11400a04 	addi	r5,r2,40
 d0352c8:	010000c4 	movi	r4,3
 d0352cc:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d0352d0:	e0bfef15 	stw	r2,-68(fp)
      if (m ==(struct mbuf *)NULL)
 d0352d4:	e0bfef17 	ldw	r2,-68(fp)
 d0352d8:	1004c03a 	cmpne	r2,r2,zero
 d0352dc:	1000041e 	bne	r2,zero,d0352f0 <tcp_output+0x74c>
      {
         EXIT_CRIT_SECTION(tp);
 d0352e0:	d0296440 	call	d029644 <irq_Unmask>
         return ENOBUFS;
 d0352e4:	00c01a44 	movi	r3,105
 d0352e8:	e0fff815 	stw	r3,-32(fp)
 d0352ec:	00028606 	br	d035d08 <tcp_output+0x1164>
      }

      m->m_len = TCPIPHDRSZ;
 d0352f0:	e0ffef17 	ldw	r3,-68(fp)
 d0352f4:	00800a04 	movi	r2,40
 d0352f8:	18800215 	stw	r2,8(r3)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 d0352fc:	e0bfef17 	ldw	r2,-68(fp)
 d035300:	10c00317 	ldw	r3,12(r2)
 d035304:	00834174 	movhi	r2,3333
 d035308:	108aa204 	addi	r2,r2,10888
 d03530c:	10800017 	ldw	r2,0(r2)
 d035310:	1887883a 	add	r3,r3,r2
 d035314:	e0bfef17 	ldw	r2,-68(fp)
 d035318:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 d03531c:	e0bff417 	ldw	r2,-48(fp)
 d035320:	1005003a 	cmpeq	r2,r2,zero
 d035324:	1000121e 	bne	r2,zero,d035370 <tcp_output+0x7cc>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 d035328:	e0bff517 	ldw	r2,-44(fp)
 d03532c:	11001817 	ldw	r4,96(r2)
 d035330:	e17ff217 	ldw	r5,-56(fp)
 d035334:	e1bff417 	ldw	r6,-48(fp)
 d035338:	d02a5080 	call	d02a508 <m_copy>
 d03533c:	1007883a 	mov	r3,r2
 d035340:	e0bfef17 	ldw	r2,-68(fp)
 d035344:	10c00615 	stw	r3,24(r2)
         if (m->m_next == 0)
 d035348:	e0bfef17 	ldw	r2,-68(fp)
 d03534c:	10800617 	ldw	r2,24(r2)
 d035350:	1004c03a 	cmpne	r2,r2,zero
 d035354:	1000061e 	bne	r2,zero,d035370 <tcp_output+0x7cc>
         {
            m_freem(m);
 d035358:	e13fef17 	ldw	r4,-68(fp)
 d03535c:	d02a4c40 	call	d02a4c4 <m_freem>
            EXIT_CRIT_SECTION(tp);
 d035360:	d0296440 	call	d029644 <irq_Unmask>
            return ENOBUFS;
 d035364:	00801a44 	movi	r2,105
 d035368:	e0bff815 	stw	r2,-32(fp)
 d03536c:	00026606 	br	d035d08 <tcp_output+0x1164>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 d035370:	d0296440 	call	d029644 <irq_Unmask>

   if (len) 
 d035374:	e0bff417 	ldw	r2,-48(fp)
 d035378:	1005003a 	cmpeq	r2,r2,zero
 d03537c:	1000391e 	bne	r2,zero,d035464 <tcp_output+0x8c0>
   {
      if (tp->t_force && len == 1)
 d035380:	e0bff717 	ldw	r2,-36(fp)
 d035384:	10800a83 	ldbu	r2,42(r2)
 d035388:	10803fcc 	andi	r2,r2,255
 d03538c:	1080201c 	xori	r2,r2,128
 d035390:	10bfe004 	addi	r2,r2,-128
 d035394:	1005003a 	cmpeq	r2,r2,zero
 d035398:	10000b1e 	bne	r2,zero,d0353c8 <tcp_output+0x824>
 d03539c:	e0bff417 	ldw	r2,-48(fp)
 d0353a0:	10800058 	cmpnei	r2,r2,1
 d0353a4:	1000081e 	bne	r2,zero,d0353c8 <tcp_output+0x824>
         tcpstat.tcps_sndprobe++;
 d0353a8:	008341b4 	movhi	r2,3334
 d0353ac:	10b41504 	addi	r2,r2,-12204
 d0353b0:	10801517 	ldw	r2,84(r2)
 d0353b4:	10c00044 	addi	r3,r2,1
 d0353b8:	008341b4 	movhi	r2,3334
 d0353bc:	10b41504 	addi	r2,r2,-12204
 d0353c0:	10c01515 	stw	r3,84(r2)
   }
   EXIT_CRIT_SECTION(tp);

   if (len) 
   {
      if (tp->t_force && len == 1)
 d0353c4:	00005806 	br	d035528 <tcp_output+0x984>
         tcpstat.tcps_sndprobe++;
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 d0353c8:	e0bff717 	ldw	r2,-36(fp)
 d0353cc:	10c00f17 	ldw	r3,60(r2)
 d0353d0:	e0bff717 	ldw	r2,-36(fp)
 d0353d4:	10801a17 	ldw	r2,104(r2)
 d0353d8:	1885c83a 	sub	r2,r3,r2
 d0353dc:	1004403a 	cmpge	r2,r2,zero
 d0353e0:	1000101e 	bne	r2,zero,d035424 <tcp_output+0x880>
      {
         tcpstat.tcps_sndrexmitpack++;
 d0353e4:	008341b4 	movhi	r2,3334
 d0353e8:	10b41504 	addi	r2,r2,-12204
 d0353ec:	10801217 	ldw	r2,72(r2)
 d0353f0:	10c00044 	addi	r3,r2,1
 d0353f4:	008341b4 	movhi	r2,3334
 d0353f8:	10b41504 	addi	r2,r2,-12204
 d0353fc:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 d035400:	008341b4 	movhi	r2,3334
 d035404:	10b41504 	addi	r2,r2,-12204
 d035408:	10c01317 	ldw	r3,76(r2)
 d03540c:	e0bff417 	ldw	r2,-48(fp)
 d035410:	1887883a 	add	r3,r3,r2
 d035414:	008341b4 	movhi	r2,3334
 d035418:	10b41504 	addi	r2,r2,-12204
 d03541c:	10c01315 	stw	r3,76(r2)
 d035420:	00004106 	br	d035528 <tcp_output+0x984>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 d035424:	008341b4 	movhi	r2,3334
 d035428:	10b41504 	addi	r2,r2,-12204
 d03542c:	10801017 	ldw	r2,64(r2)
 d035430:	10c00044 	addi	r3,r2,1
 d035434:	008341b4 	movhi	r2,3334
 d035438:	10b41504 	addi	r2,r2,-12204
 d03543c:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 d035440:	008341b4 	movhi	r2,3334
 d035444:	10b41504 	addi	r2,r2,-12204
 d035448:	10c01117 	ldw	r3,68(r2)
 d03544c:	e0bff417 	ldw	r2,-48(fp)
 d035450:	1887883a 	add	r3,r3,r2
 d035454:	008341b4 	movhi	r2,3334
 d035458:	10b41504 	addi	r2,r2,-12204
 d03545c:	10c01115 	stw	r3,68(r2)
 d035460:	00003106 	br	d035528 <tcp_output+0x984>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 d035464:	e0bff717 	ldw	r2,-36(fp)
 d035468:	10800b0b 	ldhu	r2,44(r2)
 d03546c:	10bfffcc 	andi	r2,r2,65535
 d035470:	1080004c 	andi	r2,r2,1
 d035474:	10803fcc 	andi	r2,r2,255
 d035478:	1005003a 	cmpeq	r2,r2,zero
 d03547c:	1000081e 	bne	r2,zero,d0354a0 <tcp_output+0x8fc>
   {
      tcpstat.tcps_sndacks++;
 d035480:	008341b4 	movhi	r2,3334
 d035484:	10b41504 	addi	r2,r2,-12204
 d035488:	10801417 	ldw	r2,80(r2)
 d03548c:	10c00044 	addi	r3,r2,1
 d035490:	008341b4 	movhi	r2,3334
 d035494:	10b41504 	addi	r2,r2,-12204
 d035498:	10c01415 	stw	r3,80(r2)
 d03549c:	00002206 	br	d035528 <tcp_output+0x984>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 d0354a0:	e0bff117 	ldw	r2,-60(fp)
 d0354a4:	108001cc 	andi	r2,r2,7
 d0354a8:	1005003a 	cmpeq	r2,r2,zero
 d0354ac:	1000081e 	bne	r2,zero,d0354d0 <tcp_output+0x92c>
      tcpstat.tcps_sndctrl++;
 d0354b0:	008341b4 	movhi	r2,3334
 d0354b4:	10b41504 	addi	r2,r2,-12204
 d0354b8:	10801817 	ldw	r2,96(r2)
 d0354bc:	10c00044 	addi	r3,r2,1
 d0354c0:	008341b4 	movhi	r2,3334
 d0354c4:	10b41504 	addi	r2,r2,-12204
 d0354c8:	10c01815 	stw	r3,96(r2)
 d0354cc:	00001606 	br	d035528 <tcp_output+0x984>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 d0354d0:	e0bff717 	ldw	r2,-36(fp)
 d0354d4:	10c01017 	ldw	r3,64(r2)
 d0354d8:	e0bff717 	ldw	r2,-36(fp)
 d0354dc:	10800e17 	ldw	r2,56(r2)
 d0354e0:	1885c83a 	sub	r2,r3,r2
 d0354e4:	10800050 	cmplti	r2,r2,1
 d0354e8:	1000081e 	bne	r2,zero,d03550c <tcp_output+0x968>
      tcpstat.tcps_sndurg++;
 d0354ec:	008341b4 	movhi	r2,3334
 d0354f0:	10b41504 	addi	r2,r2,-12204
 d0354f4:	10801617 	ldw	r2,88(r2)
 d0354f8:	10c00044 	addi	r3,r2,1
 d0354fc:	008341b4 	movhi	r2,3334
 d035500:	10b41504 	addi	r2,r2,-12204
 d035504:	10c01615 	stw	r3,88(r2)
 d035508:	00000706 	br	d035528 <tcp_output+0x984>
   else
      tcpstat.tcps_sndwinup++;
 d03550c:	008341b4 	movhi	r2,3334
 d035510:	10b41504 	addi	r2,r2,-12204
 d035514:	10801717 	ldw	r2,92(r2)
 d035518:	10c00044 	addi	r3,r2,1
 d03551c:	008341b4 	movhi	r2,3334
 d035520:	10b41504 	addi	r2,r2,-12204
 d035524:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 d035528:	e0bfef17 	ldw	r2,-68(fp)
 d03552c:	10800317 	ldw	r2,12(r2)
 d035530:	e0bfee15 	stw	r2,-72(fp)
   if ((char *)ti < m->pkt->nb_buff)
 d035534:	e0bfef17 	ldw	r2,-68(fp)
 d035538:	10800117 	ldw	r2,4(r2)
 d03553c:	10c00117 	ldw	r3,4(r2)
 d035540:	e0bfee17 	ldw	r2,-72(fp)
 d035544:	10c0032e 	bgeu	r2,r3,d035554 <tcp_output+0x9b0>
   {
      panic("tcp_out- packet ptr underflow\n");
 d035548:	01034174 	movhi	r4,3333
 d03554c:	213e1204 	addi	r4,r4,-1976
 d035550:	d0246440 	call	d024644 <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 d035554:	e0bfef17 	ldw	r2,-68(fp)
 d035558:	e0bfe915 	stw	r2,-92(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 d03555c:	e0bff717 	ldw	r2,-36(fp)
 d035560:	10800c17 	ldw	r2,48(r2)
 d035564:	1004c03a 	cmpne	r2,r2,zero
 d035568:	1000031e 	bne	r2,zero,d035578 <tcp_output+0x9d4>
      panic("tcp_output");
 d03556c:	01034174 	movhi	r4,3333
 d035570:	213e1a04 	addi	r4,r4,-1944
 d035574:	d0246440 	call	d024644 <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 d035578:	e0ffee17 	ldw	r3,-72(fp)
 d03557c:	e0bff717 	ldw	r2,-36(fp)
 d035580:	10800c17 	ldw	r2,48(r2)
 d035584:	1809883a 	mov	r4,r3
 d035588:	100b883a 	mov	r5,r2
 d03558c:	01800a04 	movi	r6,40
 d035590:	d0027000 	call	d002700 <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 d035594:	e0bff117 	ldw	r2,-60(fp)
 d035598:	1080004c 	andi	r2,r2,1
 d03559c:	10803fcc 	andi	r2,r2,255
 d0355a0:	1005003a 	cmpeq	r2,r2,zero
 d0355a4:	1000101e 	bne	r2,zero,d0355e8 <tcp_output+0xa44>
 d0355a8:	e0bff717 	ldw	r2,-36(fp)
 d0355ac:	10800b0b 	ldhu	r2,44(r2)
 d0355b0:	10bfffcc 	andi	r2,r2,65535
 d0355b4:	1080040c 	andi	r2,r2,16
 d0355b8:	1005003a 	cmpeq	r2,r2,zero
 d0355bc:	10000a1e 	bne	r2,zero,d0355e8 <tcp_output+0xa44>
 d0355c0:	e0bff717 	ldw	r2,-36(fp)
 d0355c4:	10c00f17 	ldw	r3,60(r2)
 d0355c8:	e0bff717 	ldw	r2,-36(fp)
 d0355cc:	10801a17 	ldw	r2,104(r2)
 d0355d0:	1880051e 	bne	r3,r2,d0355e8 <tcp_output+0xa44>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 d0355d4:	e0bff717 	ldw	r2,-36(fp)
 d0355d8:	10800f17 	ldw	r2,60(r2)
 d0355dc:	10ffffc4 	addi	r3,r2,-1
 d0355e0:	e0bff717 	ldw	r2,-36(fp)
 d0355e4:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 d0355e8:	e0bff717 	ldw	r2,-36(fp)
 d0355ec:	10800f17 	ldw	r2,60(r2)
 d0355f0:	1004d63a 	srli	r2,r2,24
 d0355f4:	10c03fcc 	andi	r3,r2,255
 d0355f8:	e0bff717 	ldw	r2,-36(fp)
 d0355fc:	10800f17 	ldw	r2,60(r2)
 d035600:	1004d23a 	srli	r2,r2,8
 d035604:	10bfc00c 	andi	r2,r2,65280
 d035608:	1886b03a 	or	r3,r3,r2
 d03560c:	e0bff717 	ldw	r2,-36(fp)
 d035610:	10800f17 	ldw	r2,60(r2)
 d035614:	10bfc00c 	andi	r2,r2,65280
 d035618:	1004923a 	slli	r2,r2,8
 d03561c:	1886b03a 	or	r3,r3,r2
 d035620:	e0bff717 	ldw	r2,-36(fp)
 d035624:	10800f17 	ldw	r2,60(r2)
 d035628:	10803fcc 	andi	r2,r2,255
 d03562c:	1004963a 	slli	r2,r2,24
 d035630:	1886b03a 	or	r3,r3,r2
 d035634:	e0bfee17 	ldw	r2,-72(fp)
 d035638:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 d03563c:	e0bff717 	ldw	r2,-36(fp)
 d035640:	10801617 	ldw	r2,88(r2)
 d035644:	1004d63a 	srli	r2,r2,24
 d035648:	10c03fcc 	andi	r3,r2,255
 d03564c:	e0bff717 	ldw	r2,-36(fp)
 d035650:	10801617 	ldw	r2,88(r2)
 d035654:	1004d23a 	srli	r2,r2,8
 d035658:	10bfc00c 	andi	r2,r2,65280
 d03565c:	1886b03a 	or	r3,r3,r2
 d035660:	e0bff717 	ldw	r2,-36(fp)
 d035664:	10801617 	ldw	r2,88(r2)
 d035668:	10bfc00c 	andi	r2,r2,65280
 d03566c:	1004923a 	slli	r2,r2,8
 d035670:	1886b03a 	or	r3,r3,r2
 d035674:	e0bff717 	ldw	r2,-36(fp)
 d035678:	10801617 	ldw	r2,88(r2)
 d03567c:	10803fcc 	andi	r2,r2,255
 d035680:	1004963a 	slli	r2,r2,24
 d035684:	1886b03a 	or	r3,r3,r2
 d035688:	e0bfee17 	ldw	r2,-72(fp)
 d03568c:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 d035690:	e0bff117 	ldw	r2,-60(fp)
 d035694:	1080008c 	andi	r2,r2,2
 d035698:	1005003a 	cmpeq	r2,r2,zero
 d03569c:	1000221e 	bne	r2,zero,d035728 <tcp_output+0xb84>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 d0356a0:	e0bff517 	ldw	r2,-44(fp)
 d0356a4:	10800117 	ldw	r2,4(r2)
 d0356a8:	e0bfe615 	stw	r2,-104(fp)

      switch(so->so_domain)
 d0356ac:	e0bff517 	ldw	r2,-44(fp)
 d0356b0:	10800517 	ldw	r2,20(r2)
 d0356b4:	108000a0 	cmpeqi	r2,r2,2
 d0356b8:	1000011e 	bne	r2,zero,d0356c0 <tcp_output+0xb1c>
 d0356bc:	00001906 	br	d035724 <tcp_output+0xb80>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 d0356c0:	e0bff117 	ldw	r2,-60(fp)
 d0356c4:	1080040c 	andi	r2,r2,16
 d0356c8:	1004c03a 	cmpne	r2,r2,zero
 d0356cc:	1000161e 	bne	r2,zero,d035728 <tcp_output+0xb84>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 d0356d0:	e0bfee17 	ldw	r2,-72(fp)
 d0356d4:	11000417 	ldw	r4,16(r2)
 d0356d8:	e17ff604 	addi	r5,fp,-40
 d0356dc:	d03e90c0 	call	d03e90c <iproute>
 d0356e0:	e0bfe515 	stw	r2,-108(fp)
               if(ifp)
 d0356e4:	e0bfe517 	ldw	r2,-108(fp)
 d0356e8:	1005003a 	cmpeq	r2,r2,zero
 d0356ec:	1000091e 	bne	r2,zero,d035714 <tcp_output+0xb70>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 d0356f0:	e0bfe517 	ldw	r2,-108(fp)
 d0356f4:	10c00917 	ldw	r3,36(r2)
 d0356f8:	e0bfe517 	ldw	r2,-108(fp)
 d0356fc:	10800817 	ldw	r2,32(r2)
 d035700:	1885c83a 	sub	r2,r3,r2
 d035704:	10fff604 	addi	r3,r2,-40
 d035708:	e0bfe617 	ldw	r2,-104(fp)
 d03570c:	10c00615 	stw	r3,24(r2)
 d035710:	00000506 	br	d035728 <tcp_output+0xb84>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 d035714:	e0ffe617 	ldw	r3,-104(fp)
 d035718:	00809104 	movi	r2,580
 d03571c:	18800615 	stw	r2,24(r3)
            }
#endif   /* IP_PMTU */
         }
         break;
 d035720:	00000106 	br	d035728 <tcp_output+0xb84>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 d035724:	d0293e80 	call	d0293e8 <dtrap>
      }
   }

   /* fill in options if any are set */
   if (optlen)
 d035728:	e0bfed17 	ldw	r2,-76(fp)
 d03572c:	1005003a 	cmpeq	r2,r2,zero
 d035730:	10002f1e 	bne	r2,zero,d0357f0 <tcp_output+0xc4c>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 d035734:	01000084 	movi	r4,2
 d035738:	01404004 	movi	r5,256
 d03573c:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d035740:	e0bfe415 	stw	r2,-112(fp)
      if (mopt == NULL) 
 d035744:	e0bfe417 	ldw	r2,-112(fp)
 d035748:	1004c03a 	cmpne	r2,r2,zero
 d03574c:	1000051e 	bne	r2,zero,d035764 <tcp_output+0xbc0>
      {
         m_freem(m);
 d035750:	e13fef17 	ldw	r4,-68(fp)
 d035754:	d02a4c40 	call	d02a4c4 <m_freem>
         return (ENOBUFS);
 d035758:	00c01a44 	movi	r3,105
 d03575c:	e0fff815 	stw	r3,-32(fp)
 d035760:	00016906 	br	d035d08 <tcp_output+0x1164>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 d035764:	e0bfe917 	ldw	r2,-92(fp)
 d035768:	10c00617 	ldw	r3,24(r2)
 d03576c:	e0bfe417 	ldw	r2,-112(fp)
 d035770:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 d035774:	e0ffe917 	ldw	r3,-92(fp)
 d035778:	e0bfe417 	ldw	r2,-112(fp)
 d03577c:	18800615 	stw	r2,24(r3)

      /* extend options to aligned address */
      while(optlen & 0x03)
 d035780:	00000706 	br	d0357a0 <tcp_output+0xbfc>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 d035784:	e0ffed17 	ldw	r3,-76(fp)
 d035788:	d0a0b304 	addi	r2,gp,-32052
 d03578c:	1885883a 	add	r2,r3,r2
 d035790:	10000005 	stb	zero,0(r2)
 d035794:	e0bfed17 	ldw	r2,-76(fp)
 d035798:	10800044 	addi	r2,r2,1
 d03579c:	e0bfed15 	stw	r2,-76(fp)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 d0357a0:	e0bfed17 	ldw	r2,-76(fp)
 d0357a4:	108000cc 	andi	r2,r2,3
 d0357a8:	1004c03a 	cmpne	r2,r2,zero
 d0357ac:	103ff51e 	bne	r2,zero,d035784 <tcp_output+0xbe0>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 d0357b0:	e0bfe417 	ldw	r2,-112(fp)
 d0357b4:	10800317 	ldw	r2,12(r2)
 d0357b8:	1009883a 	mov	r4,r2
 d0357bc:	d160b304 	addi	r5,gp,-32052
 d0357c0:	e1bfed17 	ldw	r6,-76(fp)
 d0357c4:	d0027000 	call	d002700 <memcpy>
      mopt->m_len = optlen;
 d0357c8:	e0ffe417 	ldw	r3,-112(fp)
 d0357cc:	e0bfed17 	ldw	r2,-76(fp)
 d0357d0:	18800215 	stw	r2,8(r3)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 d0357d4:	e0bfed17 	ldw	r2,-76(fp)
 d0357d8:	10800504 	addi	r2,r2,20
 d0357dc:	1004d0ba 	srli	r2,r2,2
 d0357e0:	1004913a 	slli	r2,r2,4
 d0357e4:	1007883a 	mov	r3,r2
 d0357e8:	e0bfee17 	ldw	r2,-72(fp)
 d0357ec:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 d0357f0:	e0bff117 	ldw	r2,-60(fp)
 d0357f4:	1007883a 	mov	r3,r2
 d0357f8:	e0bfee17 	ldw	r2,-72(fp)
 d0357fc:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 d035800:	e0bff517 	ldw	r2,-44(fp)
 d035804:	10800b17 	ldw	r2,44(r2)
 d035808:	1004d0ba 	srli	r2,r2,2
 d03580c:	1007883a 	mov	r3,r2
 d035810:	e0bff317 	ldw	r2,-52(fp)
 d035814:	10c0060e 	bge	r2,r3,d035830 <tcp_output+0xc8c>
 d035818:	e0bff717 	ldw	r2,-36(fp)
 d03581c:	10800a0b 	ldhu	r2,40(r2)
 d035820:	10ffffcc 	andi	r3,r2,65535
 d035824:	e0bff317 	ldw	r2,-52(fp)
 d035828:	10c0010e 	bge	r2,r3,d035830 <tcp_output+0xc8c>
      win = 0;
 d03582c:	e03ff315 	stw	zero,-52(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 d035830:	e0bff717 	ldw	r2,-36(fp)
 d035834:	10c01917 	ldw	r3,100(r2)
 d035838:	e0bff717 	ldw	r2,-36(fp)
 d03583c:	10801617 	ldw	r2,88(r2)
 d035840:	1885c83a 	sub	r2,r3,r2
 d035844:	1007883a 	mov	r3,r2
 d035848:	e0bff317 	ldw	r2,-52(fp)
 d03584c:	10c0060e 	bge	r2,r3,d035868 <tcp_output+0xcc4>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 d035850:	e0bff717 	ldw	r2,-36(fp)
 d035854:	10c01917 	ldw	r3,100(r2)
 d035858:	e0bff717 	ldw	r2,-36(fp)
 d03585c:	10801617 	ldw	r2,88(r2)
 d035860:	1885c83a 	sub	r2,r3,r2
 d035864:	e0bff315 	stw	r2,-52(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 d035868:	008341b4 	movhi	r2,3334
 d03586c:	10b34c04 	addi	r2,r2,-13008
 d035870:	10800217 	ldw	r2,8(r2)
 d035874:	1004c03a 	cmpne	r2,r2,zero
 d035878:	1000021e 	bne	r2,zero,d035884 <tcp_output+0xce0>
   {
      win = 0;
 d03587c:	e03ff315 	stw	zero,-52(fp)
 d035880:	00001406 	br	d0358d4 <tcp_output+0xd30>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 d035884:	008341b4 	movhi	r2,3334
 d035888:	10b34c04 	addi	r2,r2,-13008
 d03588c:	10800217 	ldw	r2,8(r2)
 d035890:	10ffffc4 	addi	r3,r2,-1
 d035894:	00834174 	movhi	r2,3333
 d035898:	108a5a04 	addi	r2,r2,10600
 d03589c:	10800017 	ldw	r2,0(r2)
 d0358a0:	1887383a 	mul	r3,r3,r2
 d0358a4:	e0bff317 	ldw	r2,-52(fp)
 d0358a8:	18800a0e 	bge	r3,r2,d0358d4 <tcp_output+0xd30>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 d0358ac:	008341b4 	movhi	r2,3334
 d0358b0:	10b34c04 	addi	r2,r2,-13008
 d0358b4:	10800217 	ldw	r2,8(r2)
 d0358b8:	10bfffc4 	addi	r2,r2,-1
 d0358bc:	1007883a 	mov	r3,r2
 d0358c0:	00834174 	movhi	r2,3333
 d0358c4:	108a5a04 	addi	r2,r2,10600
 d0358c8:	10800017 	ldw	r2,0(r2)
 d0358cc:	1885383a 	mul	r2,r3,r2
 d0358d0:	e0bff315 	stw	r2,-52(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 d0358d4:	e0bff317 	ldw	r2,-52(fp)
 d0358d8:	10bfffcc 	andi	r2,r2,65535
 d0358dc:	1004d23a 	srli	r2,r2,8
 d0358e0:	10803fcc 	andi	r2,r2,255
 d0358e4:	1009883a 	mov	r4,r2
 d0358e8:	e0bff317 	ldw	r2,-52(fp)
 d0358ec:	10bfffcc 	andi	r2,r2,65535
 d0358f0:	1004923a 	slli	r2,r2,8
 d0358f4:	1007883a 	mov	r3,r2
 d0358f8:	00bfc004 	movi	r2,-256
 d0358fc:	1884703a 	and	r2,r3,r2
 d035900:	2084b03a 	or	r2,r4,r2
 d035904:	1007883a 	mov	r3,r2
 d035908:	e0bfee17 	ldw	r2,-72(fp)
 d03590c:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 d035910:	e0bff717 	ldw	r2,-36(fp)
 d035914:	10c01017 	ldw	r3,64(r2)
 d035918:	e0bff717 	ldw	r2,-36(fp)
 d03591c:	10800f17 	ldw	r2,60(r2)
 d035920:	1885c83a 	sub	r2,r3,r2
 d035924:	10800050 	cmplti	r2,r2,1
 d035928:	1000201e 	bne	r2,zero,d0359ac <tcp_output+0xe08>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 d03592c:	e0bff717 	ldw	r2,-36(fp)
 d035930:	10801017 	ldw	r2,64(r2)
 d035934:	1007883a 	mov	r3,r2
 d035938:	e0bff717 	ldw	r2,-36(fp)
 d03593c:	10800f17 	ldw	r2,60(r2)
 d035940:	1885c83a 	sub	r2,r3,r2
 d035944:	10bfffcc 	andi	r2,r2,65535
 d035948:	1004d23a 	srli	r2,r2,8
 d03594c:	10803fcc 	andi	r2,r2,255
 d035950:	1009883a 	mov	r4,r2
 d035954:	e0bff717 	ldw	r2,-36(fp)
 d035958:	10801017 	ldw	r2,64(r2)
 d03595c:	1007883a 	mov	r3,r2
 d035960:	e0bff717 	ldw	r2,-36(fp)
 d035964:	10800f17 	ldw	r2,60(r2)
 d035968:	1885c83a 	sub	r2,r3,r2
 d03596c:	10bfffcc 	andi	r2,r2,65535
 d035970:	1004923a 	slli	r2,r2,8
 d035974:	1007883a 	mov	r3,r2
 d035978:	00bfc004 	movi	r2,-256
 d03597c:	1884703a 	and	r2,r3,r2
 d035980:	2084b03a 	or	r2,r4,r2
 d035984:	1007883a 	mov	r3,r2
 d035988:	e0bfee17 	ldw	r2,-72(fp)
 d03598c:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 d035990:	e0bfee17 	ldw	r2,-72(fp)
 d035994:	10800843 	ldbu	r2,33(r2)
 d035998:	10800814 	ori	r2,r2,32
 d03599c:	1007883a 	mov	r3,r2
 d0359a0:	e0bfee17 	ldw	r2,-72(fp)
 d0359a4:	10c00845 	stb	r3,33(r2)
 d0359a8:	00000406 	br	d0359bc <tcp_output+0xe18>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 d0359ac:	e0bff717 	ldw	r2,-36(fp)
 d0359b0:	10c00e17 	ldw	r3,56(r2)
 d0359b4:	e0bff717 	ldw	r2,-36(fp)
 d0359b8:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 d0359bc:	e0bff417 	ldw	r2,-48(fp)
 d0359c0:	1005003a 	cmpeq	r2,r2,zero
 d0359c4:	10000c1e 	bne	r2,zero,d0359f8 <tcp_output+0xe54>
 d0359c8:	e0fff217 	ldw	r3,-56(fp)
 d0359cc:	e0bff417 	ldw	r2,-48(fp)
 d0359d0:	1887883a 	add	r3,r3,r2
 d0359d4:	e0bff517 	ldw	r2,-44(fp)
 d0359d8:	10801217 	ldw	r2,72(r2)
 d0359dc:	1880061e 	bne	r3,r2,d0359f8 <tcp_output+0xe54>
      ti->ti_flags |= TH_PUSH;
 d0359e0:	e0bfee17 	ldw	r2,-72(fp)
 d0359e4:	10800843 	ldbu	r2,33(r2)
 d0359e8:	10800214 	ori	r2,r2,8
 d0359ec:	1007883a 	mov	r3,r2
 d0359f0:	e0bfee17 	ldw	r2,-72(fp)
 d0359f4:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 d0359f8:	e0bff717 	ldw	r2,-36(fp)
 d0359fc:	10800a83 	ldbu	r2,42(r2)
 d035a00:	10803fcc 	andi	r2,r2,255
 d035a04:	1080201c 	xori	r2,r2,128
 d035a08:	10bfe004 	addi	r2,r2,-128
 d035a0c:	1005003a 	cmpeq	r2,r2,zero
 d035a10:	1000041e 	bne	r2,zero,d035a24 <tcp_output+0xe80>
 d035a14:	e0bff717 	ldw	r2,-36(fp)
 d035a18:	10800417 	ldw	r2,16(r2)
 d035a1c:	1004c03a 	cmpne	r2,r2,zero
 d035a20:	1000561e 	bne	r2,zero,d035b7c <tcp_output+0xfd8>
   {
      tcp_seq startseq = tp->snd_nxt;
 d035a24:	e0bff717 	ldw	r2,-36(fp)
 d035a28:	10800f17 	ldw	r2,60(r2)
 d035a2c:	e0bfe315 	stw	r2,-116(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 d035a30:	e0bff117 	ldw	r2,-60(fp)
 d035a34:	1080008c 	andi	r2,r2,2
 d035a38:	1005003a 	cmpeq	r2,r2,zero
 d035a3c:	1000051e 	bne	r2,zero,d035a54 <tcp_output+0xeb0>
         tp->snd_nxt++;
 d035a40:	e0bff717 	ldw	r2,-36(fp)
 d035a44:	10800f17 	ldw	r2,60(r2)
 d035a48:	10c00044 	addi	r3,r2,1
 d035a4c:	e0bff717 	ldw	r2,-36(fp)
 d035a50:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 d035a54:	e0bff117 	ldw	r2,-60(fp)
 d035a58:	1080004c 	andi	r2,r2,1
 d035a5c:	10803fcc 	andi	r2,r2,255
 d035a60:	1005003a 	cmpeq	r2,r2,zero
 d035a64:	10000b1e 	bne	r2,zero,d035a94 <tcp_output+0xef0>
      {
         tp->snd_nxt++;
 d035a68:	e0bff717 	ldw	r2,-36(fp)
 d035a6c:	10800f17 	ldw	r2,60(r2)
 d035a70:	10c00044 	addi	r3,r2,1
 d035a74:	e0bff717 	ldw	r2,-36(fp)
 d035a78:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 d035a7c:	e0bff717 	ldw	r2,-36(fp)
 d035a80:	10800b0b 	ldhu	r2,44(r2)
 d035a84:	10800414 	ori	r2,r2,16
 d035a88:	1007883a 	mov	r3,r2
 d035a8c:	e0bff717 	ldw	r2,-36(fp)
 d035a90:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 d035a94:	e0bff717 	ldw	r2,-36(fp)
 d035a98:	10c00f17 	ldw	r3,60(r2)
 d035a9c:	e0bff417 	ldw	r2,-48(fp)
 d035aa0:	1887883a 	add	r3,r3,r2
 d035aa4:	e0bff717 	ldw	r2,-36(fp)
 d035aa8:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 d035aac:	e0bff717 	ldw	r2,-36(fp)
 d035ab0:	10c00f17 	ldw	r3,60(r2)
 d035ab4:	e0bff717 	ldw	r2,-36(fp)
 d035ab8:	10801a17 	ldw	r2,104(r2)
 d035abc:	1885c83a 	sub	r2,r3,r2
 d035ac0:	10800050 	cmplti	r2,r2,1
 d035ac4:	1000171e 	bne	r2,zero,d035b24 <tcp_output+0xf80>
      {
         tp->snd_max = tp->snd_nxt;
 d035ac8:	e0bff717 	ldw	r2,-36(fp)
 d035acc:	10c00f17 	ldw	r3,60(r2)
 d035ad0:	e0bff717 	ldw	r2,-36(fp)
 d035ad4:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 d035ad8:	e0bff717 	ldw	r2,-36(fp)
 d035adc:	10801e17 	ldw	r2,120(r2)
 d035ae0:	1004c03a 	cmpne	r2,r2,zero
 d035ae4:	10000f1e 	bne	r2,zero,d035b24 <tcp_output+0xf80>
         {
            tp->t_rttick = cticks;
 d035ae8:	00834174 	movhi	r2,3333
 d035aec:	108ac904 	addi	r2,r2,11044
 d035af0:	10c00017 	ldw	r3,0(r2)
 d035af4:	e0bff717 	ldw	r2,-36(fp)
 d035af8:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 d035afc:	e0fff717 	ldw	r3,-36(fp)
 d035b00:	e0bfe317 	ldw	r2,-116(fp)
 d035b04:	18801f15 	stw	r2,124(r3)
            tcpstat.tcps_segstimed++;
 d035b08:	008341b4 	movhi	r2,3334
 d035b0c:	10b41504 	addi	r2,r2,-12204
 d035b10:	10800617 	ldw	r2,24(r2)
 d035b14:	10c00044 	addi	r3,r2,1
 d035b18:	008341b4 	movhi	r2,3334
 d035b1c:	10b41504 	addi	r2,r2,-12204
 d035b20:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 d035b24:	e0bff717 	ldw	r2,-36(fp)
 d035b28:	10800317 	ldw	r2,12(r2)
 d035b2c:	1004c03a 	cmpne	r2,r2,zero
 d035b30:	1000211e 	bne	r2,zero,d035bb8 <tcp_output+0x1014>
 d035b34:	e0bff717 	ldw	r2,-36(fp)
 d035b38:	10c00f17 	ldw	r3,60(r2)
 d035b3c:	e0bff717 	ldw	r2,-36(fp)
 d035b40:	10800e17 	ldw	r2,56(r2)
 d035b44:	18801c26 	beq	r3,r2,d035bb8 <tcp_output+0x1014>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 d035b48:	e0bff717 	ldw	r2,-36(fp)
 d035b4c:	10c00817 	ldw	r3,32(r2)
 d035b50:	e0bff717 	ldw	r2,-36(fp)
 d035b54:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 d035b58:	e0bff717 	ldw	r2,-36(fp)
 d035b5c:	10800417 	ldw	r2,16(r2)
 d035b60:	1005003a 	cmpeq	r2,r2,zero
 d035b64:	1000141e 	bne	r2,zero,d035bb8 <tcp_output+0x1014>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 d035b68:	e0bff717 	ldw	r2,-36(fp)
 d035b6c:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 d035b70:	e0bff717 	ldw	r2,-36(fp)
 d035b74:	10000715 	stw	zero,28(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 d035b78:	00000f06 	br	d035bb8 <tcp_output+0x1014>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 d035b7c:	e0bff717 	ldw	r2,-36(fp)
 d035b80:	10c00f17 	ldw	r3,60(r2)
 d035b84:	e0bff417 	ldw	r2,-48(fp)
 d035b88:	1887883a 	add	r3,r3,r2
 d035b8c:	e0bff717 	ldw	r2,-36(fp)
 d035b90:	10801a17 	ldw	r2,104(r2)
 d035b94:	1885c83a 	sub	r2,r3,r2
 d035b98:	10800050 	cmplti	r2,r2,1
 d035b9c:	1000061e 	bne	r2,zero,d035bb8 <tcp_output+0x1014>
         tp->snd_max = tp->snd_nxt + len;
 d035ba0:	e0bff717 	ldw	r2,-36(fp)
 d035ba4:	10c00f17 	ldw	r3,60(r2)
 d035ba8:	e0bff417 	ldw	r2,-48(fp)
 d035bac:	1887883a 	add	r3,r3,r2
 d035bb0:	e0bff717 	ldw	r2,-36(fp)
 d035bb4:	10c01a15 	stw	r3,104(r2)
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 d035bb8:	e03ff015 	stw	zero,-64(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 d035bbc:	e0bfef17 	ldw	r2,-68(fp)
 d035bc0:	10800317 	ldw	r2,12(r2)
 d035bc4:	e0bfe215 	stw	r2,-120(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 d035bc8:	e0bfed17 	ldw	r2,-76(fp)
 d035bcc:	1007883a 	mov	r3,r2
 d035bd0:	e0bff417 	ldw	r2,-48(fp)
 d035bd4:	1885883a 	add	r2,r3,r2
 d035bd8:	10800a04 	addi	r2,r2,40
 d035bdc:	1007883a 	mov	r3,r2
 d035be0:	e0bfe217 	ldw	r2,-120(fp)
 d035be4:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 d035be8:	e0bff517 	ldw	r2,-44(fp)
 d035bec:	11401f17 	ldw	r5,124(r2)
 d035bf0:	e13fef17 	ldw	r4,-68(fp)
 d035bf4:	d02aef80 	call	d02aef8 <ip_output>
 d035bf8:	e0bff015 	stw	r2,-64(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 d035bfc:	e0bff017 	ldw	r2,-64(fp)
 d035c00:	1005003a 	cmpeq	r2,r2,zero
 d035c04:	1000151e 	bne	r2,zero,d035c5c <tcp_output+0x10b8>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 d035c08:	e0bff017 	ldw	r2,-64(fp)
 d035c0c:	10801a58 	cmpnei	r2,r2,105
 d035c10:	10000f1e 	bne	r2,zero,d035c50 <tcp_output+0x10ac>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 d035c14:	e0bfef17 	ldw	r2,-68(fp)
 d035c18:	10800817 	ldw	r2,32(r2)
 d035c1c:	1004c03a 	cmpne	r2,r2,zero
 d035c20:	1000031e 	bne	r2,zero,d035c30 <tcp_output+0x108c>
            m = m->m_next;
 d035c24:	e0bfef17 	ldw	r2,-68(fp)
 d035c28:	10800617 	ldw	r2,24(r2)
 d035c2c:	e0bfef15 	stw	r2,-68(fp)
         m_freem(m); /* free the mbuf chain */
 d035c30:	e13fef17 	ldw	r4,-68(fp)
 d035c34:	d02a4c40 	call	d02a4c4 <m_freem>
         tcp_quench(tp->t_inpcb);
 d035c38:	e0bff717 	ldw	r2,-36(fp)
 d035c3c:	11000d17 	ldw	r4,52(r2)
 d035c40:	d0367a80 	call	d0367a8 <tcp_quench>
         return (error);
 d035c44:	e0bff017 	ldw	r2,-64(fp)
 d035c48:	e0bff815 	stw	r2,-32(fp)
 d035c4c:	00002e06 	br	d035d08 <tcp_output+0x1164>
      }
      return (error);
 d035c50:	e0fff017 	ldw	r3,-64(fp)
 d035c54:	e0fff815 	stw	r3,-32(fp)
 d035c58:	00002b06 	br	d035d08 <tcp_output+0x1164>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 d035c5c:	008341b4 	movhi	r2,3334
 d035c60:	10b3e704 	addi	r2,r2,-12388
 d035c64:	10800a17 	ldw	r2,40(r2)
 d035c68:	10c00044 	addi	r3,r2,1
 d035c6c:	008341b4 	movhi	r2,3334
 d035c70:	10b3e704 	addi	r2,r2,-12388
 d035c74:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 d035c78:	008341b4 	movhi	r2,3334
 d035c7c:	10b41504 	addi	r2,r2,-12204
 d035c80:	10800f17 	ldw	r2,60(r2)
 d035c84:	10c00044 	addi	r3,r2,1
 d035c88:	008341b4 	movhi	r2,3334
 d035c8c:	10b41504 	addi	r2,r2,-12204
 d035c90:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 d035c94:	e0bff317 	ldw	r2,-52(fp)
 d035c98:	10800050 	cmplti	r2,r2,1
 d035c9c:	10000f1e 	bne	r2,zero,d035cdc <tcp_output+0x1138>
 d035ca0:	e0bff717 	ldw	r2,-36(fp)
 d035ca4:	10c01617 	ldw	r3,88(r2)
 d035ca8:	e0bff317 	ldw	r2,-52(fp)
 d035cac:	1887883a 	add	r3,r3,r2
 d035cb0:	e0bff717 	ldw	r2,-36(fp)
 d035cb4:	10801917 	ldw	r2,100(r2)
 d035cb8:	1885c83a 	sub	r2,r3,r2
 d035cbc:	10800050 	cmplti	r2,r2,1
 d035cc0:	1000061e 	bne	r2,zero,d035cdc <tcp_output+0x1138>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 d035cc4:	e0bff717 	ldw	r2,-36(fp)
 d035cc8:	10c01617 	ldw	r3,88(r2)
 d035ccc:	e0bff317 	ldw	r2,-52(fp)
 d035cd0:	1887883a 	add	r3,r3,r2
 d035cd4:	e0bff717 	ldw	r2,-36(fp)
 d035cd8:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 d035cdc:	e0bff717 	ldw	r2,-36(fp)
 d035ce0:	10c00b0b 	ldhu	r3,44(r2)
 d035ce4:	00bfef04 	movi	r2,-68
 d035ce8:	1884703a 	and	r2,r3,r2
 d035cec:	1007883a 	mov	r3,r2
 d035cf0:	e0bff717 	ldw	r2,-36(fp)
 d035cf4:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 d035cf8:	e0bfeb17 	ldw	r2,-84(fp)
 d035cfc:	1004c03a 	cmpne	r2,r2,zero
 d035d00:	103bb81e 	bne	r2,zero,d034be4 <tcp_output+0x40>
      goto again;
   return (0);
 d035d04:	e03ff815 	stw	zero,-32(fp)
 d035d08:	e0bff817 	ldw	r2,-32(fp)
}
 d035d0c:	e037883a 	mov	sp,fp
 d035d10:	dfc00117 	ldw	ra,4(sp)
 d035d14:	df000017 	ldw	fp,0(sp)
 d035d18:	dec00204 	addi	sp,sp,8
 d035d1c:	f800283a 	ret

0d035d20 <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 d035d20:	defffc04 	addi	sp,sp,-16
 d035d24:	dfc00315 	stw	ra,12(sp)
 d035d28:	df000215 	stw	fp,8(sp)
 d035d2c:	df000204 	addi	fp,sp,8
 d035d30:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 d035d34:	e0bfff17 	ldw	r2,-4(fp)
 d035d38:	10802017 	ldw	r2,128(r2)
 d035d3c:	1007d0ba 	srai	r3,r2,2
 d035d40:	e0bfff17 	ldw	r2,-4(fp)
 d035d44:	10802117 	ldw	r2,132(r2)
 d035d48:	1885883a 	add	r2,r3,r2
 d035d4c:	1005d07a 	srai	r2,r2,1
 d035d50:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 d035d54:	e0bfff17 	ldw	r2,-4(fp)
 d035d58:	10800317 	ldw	r2,12(r2)
 d035d5c:	1005003a 	cmpeq	r2,r2,zero
 d035d60:	1000031e 	bne	r2,zero,d035d70 <tcp_setpersist+0x50>
      panic("tcp_output REXMT");
 d035d64:	01034174 	movhi	r4,3333
 d035d68:	213e1d04 	addi	r4,r4,-1932
 d035d6c:	d0246440 	call	d024644 <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 d035d70:	e0bfff17 	ldw	r2,-4(fp)
 d035d74:	10c00717 	ldw	r3,28(r2)
 d035d78:	00834174 	movhi	r2,3333
 d035d7c:	10894fc4 	addi	r2,r2,9535
 d035d80:	10c5883a 	add	r2,r2,r3
 d035d84:	10800003 	ldbu	r2,0(r2)
 d035d88:	10c03fcc 	andi	r3,r2,255
 d035d8c:	e0bffe17 	ldw	r2,-8(fp)
 d035d90:	1885383a 	mul	r2,r3,r2
 d035d94:	10ffffcc 	andi	r3,r2,65535
 d035d98:	18e0001c 	xori	r3,r3,32768
 d035d9c:	18e00004 	addi	r3,r3,-32768
 d035da0:	e0bfff17 	ldw	r2,-4(fp)
 d035da4:	10c00415 	stw	r3,16(r2)
 d035da8:	e0bfff17 	ldw	r2,-4(fp)
 d035dac:	10800417 	ldw	r2,16(r2)
 d035db0:	10800288 	cmpgei	r2,r2,10
 d035db4:	1000041e 	bne	r2,zero,d035dc8 <tcp_setpersist+0xa8>
 d035db8:	e0ffff17 	ldw	r3,-4(fp)
 d035dbc:	00800284 	movi	r2,10
 d035dc0:	18800415 	stw	r2,16(r3)
 d035dc4:	00000706 	br	d035de4 <tcp_setpersist+0xc4>
 d035dc8:	e0bfff17 	ldw	r2,-4(fp)
 d035dcc:	10800417 	ldw	r2,16(r2)
 d035dd0:	10801e50 	cmplti	r2,r2,121
 d035dd4:	1000031e 	bne	r2,zero,d035de4 <tcp_setpersist+0xc4>
 d035dd8:	e0ffff17 	ldw	r3,-4(fp)
 d035ddc:	00801e04 	movi	r2,120
 d035de0:	18800415 	stw	r2,16(r3)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 d035de4:	e0bfff17 	ldw	r2,-4(fp)
 d035de8:	10800717 	ldw	r2,28(r2)
 d035dec:	10800308 	cmpgei	r2,r2,12
 d035df0:	1000051e 	bne	r2,zero,d035e08 <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 d035df4:	e0bfff17 	ldw	r2,-4(fp)
 d035df8:	10800717 	ldw	r2,28(r2)
 d035dfc:	10c00044 	addi	r3,r2,1
 d035e00:	e0bfff17 	ldw	r2,-4(fp)
 d035e04:	10c00715 	stw	r3,28(r2)

}
 d035e08:	e037883a 	mov	sp,fp
 d035e0c:	dfc00117 	ldw	ra,4(sp)
 d035e10:	df000017 	ldw	fp,0(sp)
 d035e14:	dec00204 	addi	sp,sp,8
 d035e18:	f800283a 	ret

0d035e1c <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 d035e1c:	defff704 	addi	sp,sp,-36
 d035e20:	dfc00815 	stw	ra,32(sp)
 d035e24:	df000715 	stw	fp,28(sp)
 d035e28:	df000704 	addi	fp,sp,28
 d035e2c:	e13ffb15 	stw	r4,-20(fp)
 d035e30:	e17ffc15 	stw	r5,-16(fp)
 d035e34:	e1bffd15 	stw	r6,-12(fp)
 d035e38:	e1fffe15 	stw	r7,-8(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 d035e3c:	e0bffb17 	ldw	r2,-20(fp)
 d035e40:	10800b0b 	ldhu	r2,44(r2)
 d035e44:	10bfffcc 	andi	r2,r2,65535
 d035e48:	1080020c 	andi	r2,r2,8
 d035e4c:	1005003a 	cmpeq	r2,r2,zero
 d035e50:	1000021e 	bne	r2,zero,d035e5c <bld_options+0x40>
      return 0;
 d035e54:	e03fff15 	stw	zero,-4(fp)
 d035e58:	00002406 	br	d035eec <bld_options+0xd0>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 d035e5c:	e0bffd17 	ldw	r2,-12(fp)
 d035e60:	1080008c 	andi	r2,r2,2
 d035e64:	1005003a 	cmpeq	r2,r2,zero
 d035e68:	10001d1e 	bne	r2,zero,d035ee0 <bld_options+0xc4>
   {
      mss   =  (u_short)tcp_mss(so);
 d035e6c:	e13ffe17 	ldw	r4,-8(fp)
 d035e70:	d034a880 	call	d034a88 <tcp_mss>
 d035e74:	e0bff90d 	sth	r2,-28(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 d035e78:	e0fffc17 	ldw	r3,-16(fp)
 d035e7c:	00800084 	movi	r2,2
 d035e80:	18800005 	stb	r2,0(r3)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 d035e84:	e0bffc17 	ldw	r2,-16(fp)
 d035e88:	10c00044 	addi	r3,r2,1
 d035e8c:	00800104 	movi	r2,4
 d035e90:	18800005 	stb	r2,0(r3)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 d035e94:	e0bffc17 	ldw	r2,-16(fp)
 d035e98:	10c00084 	addi	r3,r2,2
 d035e9c:	e0bff90b 	ldhu	r2,-28(fp)
 d035ea0:	10bfc00c 	andi	r2,r2,65280
 d035ea4:	1005d23a 	srai	r2,r2,8
 d035ea8:	18800005 	stb	r2,0(r3)
      *(cp + 3)  = (u_char) (mss & 0xff);
 d035eac:	e0bffc17 	ldw	r2,-16(fp)
 d035eb0:	110000c4 	addi	r4,r2,3
 d035eb4:	e0bff90b 	ldhu	r2,-28(fp)
 d035eb8:	1007883a 	mov	r3,r2
 d035ebc:	00bfffc4 	movi	r2,-1
 d035ec0:	1884703a 	and	r2,r3,r2
 d035ec4:	20800005 	stb	r2,0(r4)
      len = 4;
 d035ec8:	00800104 	movi	r2,4
 d035ecc:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 d035ed0:	e0bffc17 	ldw	r2,-16(fp)
 d035ed4:	10800104 	addi	r2,r2,4
 d035ed8:	e0bffc15 	stw	r2,-16(fp)
 d035edc:	00000106 	br	d035ee4 <bld_options+0xc8>
   }
   else
      len = 0;
 d035ee0:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 d035ee4:	e0bffa17 	ldw	r2,-24(fp)
 d035ee8:	e0bfff15 	stw	r2,-4(fp)
 d035eec:	e0bfff17 	ldw	r2,-4(fp)
}
 d035ef0:	e037883a 	mov	sp,fp
 d035ef4:	dfc00117 	ldw	ra,4(sp)
 d035ef8:	df000017 	ldw	fp,0(sp)
 d035efc:	dec00204 	addi	sp,sp,8
 d035f00:	f800283a 	ret

0d035f04 <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 d035f04:	deffff04 	addi	sp,sp,-4
 d035f08:	df000015 	stw	fp,0(sp)
 d035f0c:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 d035f10:	00c34174 	movhi	r3,3333
 d035f14:	18cad604 	addi	r3,r3,11096
 d035f18:	00800044 	movi	r2,1
 d035f1c:	18800015 	stw	r2,0(r3)
   tcb.inp_next = tcb.inp_prev = &tcb;
 d035f20:	00c341b4 	movhi	r3,3334
 d035f24:	18f40a04 	addi	r3,r3,-12248
 d035f28:	008341b4 	movhi	r2,3334
 d035f2c:	10b40a04 	addi	r2,r2,-12248
 d035f30:	18800115 	stw	r2,4(r3)
 d035f34:	008341b4 	movhi	r2,3334
 d035f38:	10b40a04 	addi	r2,r2,-12248
 d035f3c:	10c00117 	ldw	r3,4(r2)
 d035f40:	008341b4 	movhi	r2,3334
 d035f44:	10b40a04 	addi	r2,r2,-12248
 d035f48:	10c00015 	stw	r3,0(r2)
}
 d035f4c:	e037883a 	mov	sp,fp
 d035f50:	df000017 	ldw	fp,0(sp)
 d035f54:	dec00104 	addi	sp,sp,4
 d035f58:	f800283a 	ret

0d035f5c <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 d035f5c:	defffa04 	addi	sp,sp,-24
 d035f60:	dfc00515 	stw	ra,20(sp)
 d035f64:	df000415 	stw	fp,16(sp)
 d035f68:	df000404 	addi	fp,sp,16
 d035f6c:	e13ffe15 	stw	r4,-8(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 d035f70:	e0bffe17 	ldw	r2,-8(fp)
 d035f74:	10800d17 	ldw	r2,52(r2)
 d035f78:	e0bffd15 	stw	r2,-12(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 d035f7c:	e0bffe17 	ldw	r2,-8(fp)
 d035f80:	10800c17 	ldw	r2,48(r2)
 d035f84:	e0bffc15 	stw	r2,-16(fp)
 d035f88:	e0bffc17 	ldw	r2,-16(fp)
 d035f8c:	1004c03a 	cmpne	r2,r2,zero
 d035f90:	1000081e 	bne	r2,zero,d035fb4 <tcp_template+0x58>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 d035f94:	01000a04 	movi	r4,40
 d035f98:	d029e2c0 	call	d029e2c <npalloc>
 d035f9c:	e0bffc15 	stw	r2,-16(fp)
      if (n == NULL)
 d035fa0:	e0bffc17 	ldw	r2,-16(fp)
 d035fa4:	1004c03a 	cmpne	r2,r2,zero
 d035fa8:	1000021e 	bne	r2,zero,d035fb4 <tcp_template+0x58>
         return (0);
 d035fac:	e03fff15 	stw	zero,-4(fp)
 d035fb0:	00002a06 	br	d03605c <tcp_template+0x100>
   }
   n->ti_next = n->ti_prev = 0;
 d035fb4:	e0bffc17 	ldw	r2,-16(fp)
 d035fb8:	10000115 	stw	zero,4(r2)
 d035fbc:	e0bffc17 	ldw	r2,-16(fp)
 d035fc0:	10c00117 	ldw	r3,4(r2)
 d035fc4:	e0bffc17 	ldw	r2,-16(fp)
 d035fc8:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 d035fcc:	e0fffc17 	ldw	r3,-16(fp)
 d035fd0:	00850004 	movi	r2,5120
 d035fd4:	1880028d 	sth	r2,10(r3)
   n->ti_src = inp->inp_laddr;
 d035fd8:	e0bffd17 	ldw	r2,-12(fp)
 d035fdc:	10c00417 	ldw	r3,16(r2)
 d035fe0:	e0bffc17 	ldw	r2,-16(fp)
 d035fe4:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 d035fe8:	e0bffd17 	ldw	r2,-12(fp)
 d035fec:	10c00317 	ldw	r3,12(r2)
 d035ff0:	e0bffc17 	ldw	r2,-16(fp)
 d035ff4:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 d035ff8:	e0bffd17 	ldw	r2,-12(fp)
 d035ffc:	10c0078b 	ldhu	r3,30(r2)
 d036000:	e0bffc17 	ldw	r2,-16(fp)
 d036004:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 d036008:	e0bffd17 	ldw	r2,-12(fp)
 d03600c:	10c0070b 	ldhu	r3,28(r2)
 d036010:	e0bffc17 	ldw	r2,-16(fp)
 d036014:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 d036018:	e0bffc17 	ldw	r2,-16(fp)
 d03601c:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 d036020:	e0bffc17 	ldw	r2,-16(fp)
 d036024:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 d036028:	e0fffc17 	ldw	r3,-16(fp)
 d03602c:	00801404 	movi	r2,80
 d036030:	18800805 	stb	r2,32(r3)
   n->ti_flags = 0;
 d036034:	e0bffc17 	ldw	r2,-16(fp)
 d036038:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 d03603c:	e0bffc17 	ldw	r2,-16(fp)
 d036040:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 d036044:	e0bffc17 	ldw	r2,-16(fp)
 d036048:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 d03604c:	e0bffc17 	ldw	r2,-16(fp)
 d036050:	1000098d 	sth	zero,38(r2)
   return (n);
 d036054:	e0bffc17 	ldw	r2,-16(fp)
 d036058:	e0bfff15 	stw	r2,-4(fp)
 d03605c:	e0bfff17 	ldw	r2,-4(fp)
}
 d036060:	e037883a 	mov	sp,fp
 d036064:	dfc00117 	ldw	ra,4(sp)
 d036068:	df000017 	ldw	fp,0(sp)
 d03606c:	dec00204 	addi	sp,sp,8
 d036070:	f800283a 	ret

0d036074 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 d036074:	defff104 	addi	sp,sp,-60
 d036078:	dfc00e15 	stw	ra,56(sp)
 d03607c:	df000d15 	stw	fp,52(sp)
 d036080:	df000d04 	addi	fp,sp,52
 d036084:	e13ffb15 	stw	r4,-20(fp)
 d036088:	e17ffc15 	stw	r5,-16(fp)
 d03608c:	e1bffd15 	stw	r6,-12(fp)
 d036090:	e1fffe15 	stw	r7,-8(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 d036094:	e03ff815 	stw	zero,-32(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 d036098:	e0bffb17 	ldw	r2,-20(fp)
 d03609c:	1005003a 	cmpeq	r2,r2,zero
 d0360a0:	10001a1e 	bne	r2,zero,d03610c <tcp_respond+0x98>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 d0360a4:	e0bffb17 	ldw	r2,-20(fp)
 d0360a8:	10800d17 	ldw	r2,52(r2)
 d0360ac:	10800817 	ldw	r2,32(r2)
 d0360b0:	10800b17 	ldw	r2,44(r2)
 d0360b4:	1007883a 	mov	r3,r2
 d0360b8:	e0bffb17 	ldw	r2,-20(fp)
 d0360bc:	10800d17 	ldw	r2,52(r2)
 d0360c0:	10800817 	ldw	r2,32(r2)
 d0360c4:	10800a17 	ldw	r2,40(r2)
 d0360c8:	1885c83a 	sub	r2,r3,r2
 d0360cc:	1004803a 	cmplt	r2,r2,zero
 d0360d0:	10000b1e 	bne	r2,zero,d036100 <tcp_respond+0x8c>
 d0360d4:	e0bffb17 	ldw	r2,-20(fp)
 d0360d8:	10800d17 	ldw	r2,52(r2)
 d0360dc:	10800817 	ldw	r2,32(r2)
 d0360e0:	10c00b17 	ldw	r3,44(r2)
 d0360e4:	e0bffb17 	ldw	r2,-20(fp)
 d0360e8:	10800d17 	ldw	r2,52(r2)
 d0360ec:	10800817 	ldw	r2,32(r2)
 d0360f0:	10800a17 	ldw	r2,40(r2)
 d0360f4:	1885c83a 	sub	r2,r3,r2
 d0360f8:	e0bfff15 	stw	r2,-4(fp)
 d0360fc:	00000106 	br	d036104 <tcp_respond+0x90>
 d036100:	e03fff15 	stw	zero,-4(fp)
 d036104:	e0bfff17 	ldw	r2,-4(fp)
 d036108:	e0bff815 	stw	r2,-32(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 d03610c:	e0800217 	ldw	r2,8(fp)
 d036110:	1004c03a 	cmpne	r2,r2,zero
 d036114:	1000391e 	bne	r2,zero,d0361fc <tcp_respond+0x188>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 d036118:	010000c4 	movi	r4,3
 d03611c:	01401004 	movi	r5,64
 d036120:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d036124:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 d036128:	e0bff717 	ldw	r2,-36(fp)
 d03612c:	1005003a 	cmpeq	r2,r2,zero
 d036130:	1000ed1e 	bne	r2,zero,d0364e8 <tcp_respond+0x474>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 d036134:	00800044 	movi	r2,1
 d036138:	e0bffa15 	stw	r2,-24(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 d03613c:	e0bffa17 	ldw	r2,-24(fp)
 d036140:	10800a04 	addi	r2,r2,40
 d036144:	1007883a 	mov	r3,r2
 d036148:	e0bff717 	ldw	r2,-36(fp)
 d03614c:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 d036150:	e0bff717 	ldw	r2,-36(fp)
 d036154:	10800317 	ldw	r2,12(r2)
 d036158:	e0bff615 	stw	r2,-40(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 d03615c:	e0bff717 	ldw	r2,-36(fp)
 d036160:	10800117 	ldw	r2,4(r2)
 d036164:	10c00117 	ldw	r3,4(r2)
 d036168:	e0bff617 	ldw	r2,-40(fp)
 d03616c:	10c0032e 	bgeu	r2,r3,d03617c <tcp_respond+0x108>
      {
         panic("tcp_respond- packet ptr underflow\n");
 d036170:	01034174 	movhi	r4,3333
 d036174:	213e2204 	addi	r4,r4,-1912
 d036178:	d0246440 	call	d024644 <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 d03617c:	e13ff617 	ldw	r4,-40(fp)
 d036180:	e0fffc17 	ldw	r3,-16(fp)
 d036184:	18800017 	ldw	r2,0(r3)
 d036188:	20800015 	stw	r2,0(r4)
 d03618c:	18800117 	ldw	r2,4(r3)
 d036190:	20800115 	stw	r2,4(r4)
 d036194:	18800217 	ldw	r2,8(r3)
 d036198:	20800215 	stw	r2,8(r4)
 d03619c:	18800317 	ldw	r2,12(r3)
 d0361a0:	20800315 	stw	r2,12(r4)
 d0361a4:	18800417 	ldw	r2,16(r3)
 d0361a8:	20800415 	stw	r2,16(r4)
 d0361ac:	18800517 	ldw	r2,20(r3)
 d0361b0:	20800515 	stw	r2,20(r4)
 d0361b4:	18800617 	ldw	r2,24(r3)
 d0361b8:	20800615 	stw	r2,24(r4)
 d0361bc:	18800717 	ldw	r2,28(r3)
 d0361c0:	20800715 	stw	r2,28(r4)
 d0361c4:	18800817 	ldw	r2,32(r3)
 d0361c8:	20800815 	stw	r2,32(r4)
 d0361cc:	18800917 	ldw	r2,36(r3)
 d0361d0:	20800915 	stw	r2,36(r4)
      ti = tmp_thdr;
 d0361d4:	e0bff617 	ldw	r2,-40(fp)
 d0361d8:	e0bffc15 	stw	r2,-16(fp)
      flags = TH_ACK;
 d0361dc:	00800404 	movi	r2,16
 d0361e0:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 d0361e4:	e0bffb17 	ldw	r2,-20(fp)
 d0361e8:	10800d17 	ldw	r2,52(r2)
 d0361ec:	10800817 	ldw	r2,32(r2)
 d0361f0:	10800517 	ldw	r2,20(r2)
 d0361f4:	e0bff915 	stw	r2,-28(fp)
 d0361f8:	00003b06 	br	d0362e8 <tcp_respond+0x274>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 d0361fc:	e0800317 	ldw	r2,12(fp)
 d036200:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 d036204:	e0bff717 	ldw	r2,-36(fp)
 d036208:	10800117 	ldw	r2,4(r2)
 d03620c:	1080080b 	ldhu	r2,32(r2)
 d036210:	10bfffcc 	andi	r2,r2,65535
 d036214:	10800218 	cmpnei	r2,r2,8
 d036218:	1000031e 	bne	r2,zero,d036228 <tcp_respond+0x1b4>
         domain = AF_INET;
 d03621c:	00800084 	movi	r2,2
 d036220:	e0bff915 	stw	r2,-28(fp)
 d036224:	00000206 	br	d036230 <tcp_respond+0x1bc>
      else
         domain = AF_INET6;
 d036228:	008000c4 	movi	r2,3
 d03622c:	e0bff915 	stw	r2,-28(fp)

      m_freem(m->m_next);
 d036230:	e0bff717 	ldw	r2,-36(fp)
 d036234:	11000617 	ldw	r4,24(r2)
 d036238:	d02a4c40 	call	d02a4c4 <m_freem>
      m->m_next = 0;
 d03623c:	e0bff717 	ldw	r2,-36(fp)
 d036240:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 d036244:	e03ffa15 	stw	zero,-24(fp)
      m->m_len = TCPIPHDRSZ;
 d036248:	e0fff717 	ldw	r3,-36(fp)
 d03624c:	00800a04 	movi	r2,40
 d036250:	18800215 	stw	r2,8(r3)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 d036254:	e0bffc17 	ldw	r2,-16(fp)
 d036258:	1080058b 	ldhu	r2,22(r2)
 d03625c:	e0bff50d 	sth	r2,-44(fp)
 d036260:	e0bffc17 	ldw	r2,-16(fp)
 d036264:	10c0050b 	ldhu	r3,20(r2)
 d036268:	e0bffc17 	ldw	r2,-16(fp)
 d03626c:	10c0058d 	sth	r3,22(r2)
 d036270:	e0fffc17 	ldw	r3,-16(fp)
 d036274:	e0bff50b 	ldhu	r2,-44(fp)
 d036278:	1880050d 	sth	r2,20(r3)
      if(m->pkt->type == IPTP)
 d03627c:	e0bff717 	ldw	r2,-36(fp)
 d036280:	10800117 	ldw	r2,4(r2)
 d036284:	1080080b 	ldhu	r2,32(r2)
 d036288:	10bfffcc 	andi	r2,r2,65535
 d03628c:	10800218 	cmpnei	r2,r2,8
 d036290:	10000a1e 	bne	r2,zero,d0362bc <tcp_respond+0x248>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 d036294:	e0bffc17 	ldw	r2,-16(fp)
 d036298:	10800417 	ldw	r2,16(r2)
 d03629c:	e0bff415 	stw	r2,-48(fp)
 d0362a0:	e0bffc17 	ldw	r2,-16(fp)
 d0362a4:	10c00317 	ldw	r3,12(r2)
 d0362a8:	e0bffc17 	ldw	r2,-16(fp)
 d0362ac:	10c00415 	stw	r3,16(r2)
 d0362b0:	e0fffc17 	ldw	r3,-16(fp)
 d0362b4:	e0bff417 	ldw	r2,-48(fp)
 d0362b8:	18800315 	stw	r2,12(r3)
      if (flags & TH_RST)  /* count resets in MIB */
 d0362bc:	e0800217 	ldw	r2,8(fp)
 d0362c0:	1080010c 	andi	r2,r2,4
 d0362c4:	1005003a 	cmpeq	r2,r2,zero
 d0362c8:	1000071e 	bne	r2,zero,d0362e8 <tcp_respond+0x274>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 d0362cc:	008341b4 	movhi	r2,3334
 d0362d0:	10b3e704 	addi	r2,r2,-12388
 d0362d4:	10800e17 	ldw	r2,56(r2)
 d0362d8:	10c00044 	addi	r3,r2,1
 d0362dc:	008341b4 	movhi	r2,3334
 d0362e0:	10b3e704 	addi	r2,r2,-12388
 d0362e4:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 d0362e8:	e0bffe17 	ldw	r2,-8(fp)
 d0362ec:	1004d63a 	srli	r2,r2,24
 d0362f0:	10c03fcc 	andi	r3,r2,255
 d0362f4:	e0bffe17 	ldw	r2,-8(fp)
 d0362f8:	1004d23a 	srli	r2,r2,8
 d0362fc:	10bfc00c 	andi	r2,r2,65280
 d036300:	1886b03a 	or	r3,r3,r2
 d036304:	e0bffe17 	ldw	r2,-8(fp)
 d036308:	10bfc00c 	andi	r2,r2,65280
 d03630c:	1004923a 	slli	r2,r2,8
 d036310:	1886b03a 	or	r3,r3,r2
 d036314:	e0bffe17 	ldw	r2,-8(fp)
 d036318:	10803fcc 	andi	r2,r2,255
 d03631c:	1004963a 	slli	r2,r2,24
 d036320:	1886b03a 	or	r3,r3,r2
 d036324:	e0bffc17 	ldw	r2,-16(fp)
 d036328:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 d03632c:	e0bffd17 	ldw	r2,-12(fp)
 d036330:	1004d63a 	srli	r2,r2,24
 d036334:	10c03fcc 	andi	r3,r2,255
 d036338:	e0bffd17 	ldw	r2,-12(fp)
 d03633c:	1004d23a 	srli	r2,r2,8
 d036340:	10bfc00c 	andi	r2,r2,65280
 d036344:	1886b03a 	or	r3,r3,r2
 d036348:	e0bffd17 	ldw	r2,-12(fp)
 d03634c:	10bfc00c 	andi	r2,r2,65280
 d036350:	1004923a 	slli	r2,r2,8
 d036354:	1886b03a 	or	r3,r3,r2
 d036358:	e0bffd17 	ldw	r2,-12(fp)
 d03635c:	10803fcc 	andi	r2,r2,255
 d036360:	1004963a 	slli	r2,r2,24
 d036364:	1886b03a 	or	r3,r3,r2
 d036368:	e0bffc17 	ldw	r2,-16(fp)
 d03636c:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 d036370:	e0fffc17 	ldw	r3,-16(fp)
 d036374:	00801404 	movi	r2,80
 d036378:	18800805 	stb	r2,32(r3)
   ti->ti_flags = (u_char)flags;
 d03637c:	e0800217 	ldw	r2,8(fp)
 d036380:	1007883a 	mov	r3,r2
 d036384:	e0bffc17 	ldw	r2,-16(fp)
 d036388:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 d03638c:	e0bff817 	ldw	r2,-32(fp)
 d036390:	10bfffcc 	andi	r2,r2,65535
 d036394:	1004d23a 	srli	r2,r2,8
 d036398:	10803fcc 	andi	r2,r2,255
 d03639c:	1009883a 	mov	r4,r2
 d0363a0:	e0bff817 	ldw	r2,-32(fp)
 d0363a4:	10bfffcc 	andi	r2,r2,65535
 d0363a8:	1004923a 	slli	r2,r2,8
 d0363ac:	1007883a 	mov	r3,r2
 d0363b0:	00bfc004 	movi	r2,-256
 d0363b4:	1884703a 	and	r2,r3,r2
 d0363b8:	2084b03a 	or	r2,r4,r2
 d0363bc:	1007883a 	mov	r3,r2
 d0363c0:	e0bffc17 	ldw	r2,-16(fp)
 d0363c4:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 d0363c8:	e0bffc17 	ldw	r2,-16(fp)
 d0363cc:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 d0363d0:	e0bff917 	ldw	r2,-28(fp)
 d0363d4:	108000a0 	cmpeqi	r2,r2,2
 d0363d8:	1000011e 	bne	r2,zero,d0363e0 <tcp_respond+0x36c>
 d0363dc:	00004106 	br	d0364e4 <tcp_respond+0x470>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 d0363e0:	e0bffc17 	ldw	r2,-16(fp)
 d0363e4:	e0bff315 	stw	r2,-52(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 d0363e8:	e0bffa17 	ldw	r2,-24(fp)
 d0363ec:	10800a04 	addi	r2,r2,40
 d0363f0:	1007883a 	mov	r3,r2
 d0363f4:	e0bff317 	ldw	r2,-52(fp)
 d0363f8:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 d0363fc:	e0bff717 	ldw	r2,-36(fp)
 d036400:	10800117 	ldw	r2,4(r2)
 d036404:	10c00117 	ldw	r3,4(r2)
 d036408:	00834174 	movhi	r2,3333
 d03640c:	108aa204 	addi	r2,r2,10888
 d036410:	10800017 	ldw	r2,0(r2)
 d036414:	1885883a 	add	r2,r3,r2
 d036418:	1007883a 	mov	r3,r2
 d03641c:	e0bff317 	ldw	r2,-52(fp)
 d036420:	10c00436 	bltu	r2,r3,d036434 <tcp_respond+0x3c0>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 d036424:	e0fff317 	ldw	r3,-52(fp)
 d036428:	e0bff717 	ldw	r2,-36(fp)
 d03642c:	10c00315 	stw	r3,12(r2)
 d036430:	00001206 	br	d03647c <tcp_respond+0x408>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 d036434:	e0bff717 	ldw	r2,-36(fp)
 d036438:	11000117 	ldw	r4,4(r2)
 d03643c:	e0bff717 	ldw	r2,-36(fp)
 d036440:	10800117 	ldw	r2,4(r2)
 d036444:	10c00117 	ldw	r3,4(r2)
 d036448:	00834174 	movhi	r2,3333
 d03644c:	108aa204 	addi	r2,r2,10888
 d036450:	10800017 	ldw	r2,0(r2)
 d036454:	1885883a 	add	r2,r3,r2
 d036458:	20800315 	stw	r2,12(r4)
 d03645c:	20c00317 	ldw	r3,12(r4)
 d036460:	e0bff717 	ldw	r2,-36(fp)
 d036464:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 d036468:	e0bff717 	ldw	r2,-36(fp)
 d03646c:	11000317 	ldw	r4,12(r2)
 d036470:	e17ff317 	ldw	r5,-52(fp)
 d036474:	01800a04 	movi	r6,40
 d036478:	d0027a00 	call	d0027a0 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 d03647c:	e0bffb17 	ldw	r2,-20(fp)
 d036480:	1004c03a 	cmpne	r2,r2,zero
 d036484:	1000031e 	bne	r2,zero,d036494 <tcp_respond+0x420>
              m_freem(m);
 d036488:	e13ff717 	ldw	r4,-36(fp)
 d03648c:	d02a4c40 	call	d02a4c4 <m_freem>
 d036490:	00001506 	br	d0364e8 <tcp_respond+0x474>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 d036494:	e0bffb17 	ldw	r2,-20(fp)
 d036498:	10800d17 	ldw	r2,52(r2)
 d03649c:	1005003a 	cmpeq	r2,r2,zero
 d0364a0:	10000c1e 	bne	r2,zero,d0364d4 <tcp_respond+0x460>
 d0364a4:	e0bffb17 	ldw	r2,-20(fp)
 d0364a8:	10800d17 	ldw	r2,52(r2)
 d0364ac:	10800817 	ldw	r2,32(r2)
 d0364b0:	1005003a 	cmpeq	r2,r2,zero
 d0364b4:	1000071e 	bne	r2,zero,d0364d4 <tcp_respond+0x460>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 d0364b8:	e0bffb17 	ldw	r2,-20(fp)
 d0364bc:	10800d17 	ldw	r2,52(r2)
 d0364c0:	10800817 	ldw	r2,32(r2)
 d0364c4:	11401f17 	ldw	r5,124(r2)
 d0364c8:	e13ff717 	ldw	r4,-36(fp)
 d0364cc:	d02aef80 	call	d02aef8 <ip_output>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 d0364d0:	00000506 	br	d0364e8 <tcp_respond+0x474>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 d0364d4:	e13ff717 	ldw	r4,-36(fp)
 d0364d8:	000b883a 	mov	r5,zero
 d0364dc:	d02aef80 	call	d02aef8 <ip_output>
		 }

         break;
 d0364e0:	00000106 	br	d0364e8 <tcp_respond+0x474>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 d0364e4:	d0293e80 	call	d0293e8 <dtrap>
         break;
   }
   return;
}
 d0364e8:	e037883a 	mov	sp,fp
 d0364ec:	dfc00117 	ldw	ra,4(sp)
 d0364f0:	df000017 	ldw	fp,0(sp)
 d0364f4:	dec00204 	addi	sp,sp,8
 d0364f8:	f800283a 	ret

0d0364fc <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 d0364fc:	defffa04 	addi	sp,sp,-24
 d036500:	dfc00515 	stw	ra,20(sp)
 d036504:	df000415 	stw	fp,16(sp)
 d036508:	df000404 	addi	fp,sp,16
 d03650c:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 d036510:	01002504 	movi	r4,148
 d036514:	d029e2c0 	call	d029e2c <npalloc>
 d036518:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 d03651c:	e0bffd17 	ldw	r2,-12(fp)
 d036520:	1004c03a 	cmpne	r2,r2,zero
 d036524:	1000021e 	bne	r2,zero,d036530 <tcp_newtcpcb+0x34>
      return (struct tcpcb *)NULL;
 d036528:	e03fff15 	stw	zero,-4(fp)
 d03652c:	00003306 	br	d0365fc <tcp_newtcpcb+0x100>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 d036530:	e0fffd17 	ldw	r3,-12(fp)
 d036534:	e0bffd17 	ldw	r2,-12(fp)
 d036538:	10c00115 	stw	r3,4(r2)
 d03653c:	e0bffd17 	ldw	r2,-12(fp)
 d036540:	10c00117 	ldw	r3,4(r2)
 d036544:	e0bffd17 	ldw	r2,-12(fp)
 d036548:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 d03654c:	e0fffd17 	ldw	r3,-12(fp)
 d036550:	00816d04 	movi	r2,1460
 d036554:	18800a0d 	sth	r2,40(r3)
   tp->t_flags = 0;        /* sends options! */
 d036558:	e0bffd17 	ldw	r2,-12(fp)
 d03655c:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 d036560:	e0fffd17 	ldw	r3,-12(fp)
 d036564:	e0bffe17 	ldw	r2,-8(fp)
 d036568:	18800d15 	stw	r2,52(r3)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 d03656c:	e0bffd17 	ldw	r2,-12(fp)
 d036570:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 d036574:	e0fffd17 	ldw	r3,-12(fp)
 d036578:	00800604 	movi	r2,24
 d03657c:	18802115 	stw	r2,132(r3)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 d036580:	00800304 	movi	r2,12
 d036584:	e0bffc0d 	sth	r2,-16(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 d036588:	e0fffc0f 	ldh	r3,-16(fp)
 d03658c:	e0bffd17 	ldw	r2,-12(fp)
 d036590:	10c00815 	stw	r3,32(r2)
 d036594:	e0bffd17 	ldw	r2,-12(fp)
 d036598:	10800817 	ldw	r2,32(r2)
 d03659c:	10800088 	cmpgei	r2,r2,2
 d0365a0:	1000041e 	bne	r2,zero,d0365b4 <tcp_newtcpcb+0xb8>
 d0365a4:	e0fffd17 	ldw	r3,-12(fp)
 d0365a8:	00800084 	movi	r2,2
 d0365ac:	18800815 	stw	r2,32(r3)
 d0365b0:	00000706 	br	d0365d0 <tcp_newtcpcb+0xd4>
 d0365b4:	e0bffd17 	ldw	r2,-12(fp)
 d0365b8:	10800817 	ldw	r2,32(r2)
 d0365bc:	10802050 	cmplti	r2,r2,129
 d0365c0:	1000031e 	bne	r2,zero,d0365d0 <tcp_newtcpcb+0xd4>
 d0365c4:	e0fffd17 	ldw	r3,-12(fp)
 d0365c8:	00802004 	movi	r2,128
 d0365cc:	18800815 	stw	r2,32(r3)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 d0365d0:	e0fffd17 	ldw	r3,-12(fp)
 d0365d4:	0082da04 	movi	r2,2920
 d0365d8:	18801b15 	stw	r2,108(r3)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 d0365dc:	e0fffd17 	ldw	r3,-12(fp)
 d0365e0:	00bfffd4 	movui	r2,65535
 d0365e4:	18801c15 	stw	r2,112(r3)

   inp->inp_ppcb = (char *)tp;
 d0365e8:	e0fffd17 	ldw	r3,-12(fp)
 d0365ec:	e0bffe17 	ldw	r2,-8(fp)
 d0365f0:	10c00915 	stw	r3,36(r2)
   return (tp);
 d0365f4:	e0bffd17 	ldw	r2,-12(fp)
 d0365f8:	e0bfff15 	stw	r2,-4(fp)
 d0365fc:	e0bfff17 	ldw	r2,-4(fp)
}
 d036600:	e037883a 	mov	sp,fp
 d036604:	dfc00117 	ldw	ra,4(sp)
 d036608:	df000017 	ldw	fp,0(sp)
 d03660c:	dec00204 	addi	sp,sp,8
 d036610:	f800283a 	ret

0d036614 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 d036614:	defffb04 	addi	sp,sp,-20
 d036618:	dfc00415 	stw	ra,16(sp)
 d03661c:	df000315 	stw	fp,12(sp)
 d036620:	df000304 	addi	fp,sp,12
 d036624:	e13ffe15 	stw	r4,-8(fp)
 d036628:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 d03662c:	e0bffe17 	ldw	r2,-8(fp)
 d036630:	10800d17 	ldw	r2,52(r2)
 d036634:	10800817 	ldw	r2,32(r2)
 d036638:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 d03663c:	e0bffe17 	ldw	r2,-8(fp)
 d036640:	10800217 	ldw	r2,8(r2)
 d036644:	108000d0 	cmplti	r2,r2,3
 d036648:	10000c1e 	bne	r2,zero,d03667c <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 d03664c:	e0bffe17 	ldw	r2,-8(fp)
 d036650:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 d036654:	e13ffe17 	ldw	r4,-8(fp)
 d036658:	d034ba40 	call	d034ba4 <tcp_output>
      tcpstat.tcps_drops++;
 d03665c:	008341b4 	movhi	r2,3334
 d036660:	10b41504 	addi	r2,r2,-12204
 d036664:	10800317 	ldw	r2,12(r2)
 d036668:	10c00044 	addi	r3,r2,1
 d03666c:	008341b4 	movhi	r2,3334
 d036670:	10b41504 	addi	r2,r2,-12204
 d036674:	10c00315 	stw	r3,12(r2)
 d036678:	00000706 	br	d036698 <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 d03667c:	008341b4 	movhi	r2,3334
 d036680:	10b41504 	addi	r2,r2,-12204
 d036684:	10800417 	ldw	r2,16(r2)
 d036688:	10c00044 	addi	r3,r2,1
 d03668c:	008341b4 	movhi	r2,3334
 d036690:	10b41504 	addi	r2,r2,-12204
 d036694:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 d036698:	e0fffd17 	ldw	r3,-12(fp)
 d03669c:	e0bfff17 	ldw	r2,-4(fp)
 d0366a0:	18800615 	stw	r2,24(r3)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 d0366a4:	e13ffe17 	ldw	r4,-8(fp)
 d0366a8:	d0366c00 	call	d0366c0 <tcp_close>
}
 d0366ac:	e037883a 	mov	sp,fp
 d0366b0:	dfc00117 	ldw	ra,4(sp)
 d0366b4:	df000017 	ldw	fp,0(sp)
 d0366b8:	dec00204 	addi	sp,sp,8
 d0366bc:	f800283a 	ret

0d0366c0 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 d0366c0:	defff904 	addi	sp,sp,-28
 d0366c4:	dfc00615 	stw	ra,24(sp)
 d0366c8:	df000515 	stw	fp,20(sp)
 d0366cc:	df000504 	addi	fp,sp,20
 d0366d0:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 d0366d4:	e0bfff17 	ldw	r2,-4(fp)
 d0366d8:	10800d17 	ldw	r2,52(r2)
 d0366dc:	e0bffd15 	stw	r2,-12(fp)
   struct socket *   so =  inp->inp_socket;
 d0366e0:	e0bffd17 	ldw	r2,-12(fp)
 d0366e4:	10800817 	ldw	r2,32(r2)
 d0366e8:	e0bffc15 	stw	r2,-16(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 d0366ec:	e0bfff17 	ldw	r2,-4(fp)
 d0366f0:	10800017 	ldw	r2,0(r2)
 d0366f4:	e0bffe15 	stw	r2,-8(fp)
   while (t != (struct tcpiphdr *)tp) 
 d0366f8:	00000c06 	br	d03672c <tcp_close+0x6c>
   {
      t = (struct tcpiphdr *)t->ti_next;
 d0366fc:	e0bffe17 	ldw	r2,-8(fp)
 d036700:	10800017 	ldw	r2,0(r2)
 d036704:	e0bffe15 	stw	r2,-8(fp)
      m = dtom(t->ti_prev);
 d036708:	e0bffe17 	ldw	r2,-8(fp)
 d03670c:	11000117 	ldw	r4,4(r2)
 d036710:	d02aa540 	call	d02aa54 <dtom>
 d036714:	e0bffb15 	stw	r2,-20(fp)
      remque(t->ti_prev);
 d036718:	e0bffe17 	ldw	r2,-8(fp)
 d03671c:	11000117 	ldw	r4,4(r2)
 d036720:	d02aafc0 	call	d02aafc <remque>
      m_freem (m);
 d036724:	e13ffb17 	ldw	r4,-20(fp)
 d036728:	d02a4c40 	call	d02a4c4 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 d03672c:	e0ffff17 	ldw	r3,-4(fp)
 d036730:	e0bffe17 	ldw	r2,-8(fp)
 d036734:	10fff11e 	bne	r2,r3,d0366fc <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 d036738:	e0bfff17 	ldw	r2,-4(fp)
 d03673c:	10800c17 	ldw	r2,48(r2)
 d036740:	1005003a 	cmpeq	r2,r2,zero
 d036744:	1000031e 	bne	r2,zero,d036754 <tcp_close+0x94>
      TPH_FREE (tp->t_template);
 d036748:	e0bfff17 	ldw	r2,-4(fp)
 d03674c:	11000c17 	ldw	r4,48(r2)
 d036750:	d029f200 	call	d029f20 <npfree>
   TCB_FREE (tp);
 d036754:	e13fff17 	ldw	r4,-4(fp)
 d036758:	d029f200 	call	d029f20 <npfree>
   inp->inp_ppcb = 0;
 d03675c:	e0bffd17 	ldw	r2,-12(fp)
 d036760:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 d036764:	e13ffc17 	ldw	r4,-16(fp)
 d036768:	d0301840 	call	d030184 <soisdisconnected>
   in_pcbdetach(inp);
 d03676c:	e13ffd17 	ldw	r4,-12(fp)
 d036770:	d0463280 	call	d046328 <in_pcbdetach>
   tcpstat.tcps_closed++;
 d036774:	008341b4 	movhi	r2,3334
 d036778:	10b41504 	addi	r2,r2,-12204
 d03677c:	10800517 	ldw	r2,20(r2)
 d036780:	10c00044 	addi	r3,r2,1
 d036784:	008341b4 	movhi	r2,3334
 d036788:	10b41504 	addi	r2,r2,-12204
 d03678c:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 d036790:	0005883a 	mov	r2,zero
}
 d036794:	e037883a 	mov	sp,fp
 d036798:	dfc00117 	ldw	ra,4(sp)
 d03679c:	df000017 	ldw	fp,0(sp)
 d0367a0:	dec00204 	addi	sp,sp,8
 d0367a4:	f800283a 	ret

0d0367a8 <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 d0367a8:	defffd04 	addi	sp,sp,-12
 d0367ac:	df000215 	stw	fp,8(sp)
 d0367b0:	df000204 	addi	fp,sp,8
 d0367b4:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 d0367b8:	e0bfff17 	ldw	r2,-4(fp)
 d0367bc:	10800917 	ldw	r2,36(r2)
 d0367c0:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 d0367c4:	e0bffe17 	ldw	r2,-8(fp)
 d0367c8:	1005003a 	cmpeq	r2,r2,zero
 d0367cc:	1000051e 	bne	r2,zero,d0367e4 <tcp_quench+0x3c>
      tp->snd_cwnd = tp->t_maxseg;
 d0367d0:	e0bffe17 	ldw	r2,-8(fp)
 d0367d4:	10800a0b 	ldhu	r2,40(r2)
 d0367d8:	10ffffcc 	andi	r3,r2,65535
 d0367dc:	e0bffe17 	ldw	r2,-8(fp)
 d0367e0:	10c01b15 	stw	r3,108(r2)
}
 d0367e4:	e037883a 	mov	sp,fp
 d0367e8:	df000017 	ldw	fp,0(sp)
 d0367ec:	dec00104 	addi	sp,sp,4
 d0367f0:	f800283a 	ret

0d0367f4 <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 d0367f4:	defffc04 	addi	sp,sp,-16
 d0367f8:	df000315 	stw	fp,12(sp)
 d0367fc:	df000304 	addi	fp,sp,12
 d036800:	e13ffe15 	stw	r4,-8(fp)
 d036804:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 d036808:	e0bffe17 	ldw	r2,-8(fp)
 d03680c:	108000c4 	addi	r2,r2,3
 d036810:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 d036814:	e03ffd15 	stw	zero,-12(fp)
 d036818:	00000d06 	br	d036850 <tcp_putseq+0x5c>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 d03681c:	e0bfff17 	ldw	r2,-4(fp)
 d036820:	1007883a 	mov	r3,r2
 d036824:	e0bffe17 	ldw	r2,-8(fp)
 d036828:	10c00005 	stb	r3,0(r2)
 d03682c:	e0bffe17 	ldw	r2,-8(fp)
 d036830:	10bfffc4 	addi	r2,r2,-1
 d036834:	e0bffe15 	stw	r2,-8(fp)
      seq >>= 8;
 d036838:	e0bfff17 	ldw	r2,-4(fp)
 d03683c:	1004d23a 	srli	r2,r2,8
 d036840:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 d036844:	e0bffd17 	ldw	r2,-12(fp)
 d036848:	10800044 	addi	r2,r2,1
 d03684c:	e0bffd15 	stw	r2,-12(fp)
 d036850:	e0bffd17 	ldw	r2,-12(fp)
 d036854:	10800110 	cmplti	r2,r2,4
 d036858:	103ff01e 	bne	r2,zero,d03681c <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 d03685c:	e0bffe17 	ldw	r2,-8(fp)
 d036860:	10800144 	addi	r2,r2,5
}
 d036864:	e037883a 	mov	sp,fp
 d036868:	df000017 	ldw	fp,0(sp)
 d03686c:	dec00104 	addi	sp,sp,4
 d036870:	f800283a 	ret

0d036874 <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 d036874:	defffc04 	addi	sp,sp,-16
 d036878:	df000315 	stw	fp,12(sp)
 d03687c:	df000304 	addi	fp,sp,12
 d036880:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 d036884:	e03ffd15 	stw	zero,-12(fp)

   for(i = 0; i < 4; i++)
 d036888:	e03ffe15 	stw	zero,-8(fp)
 d03688c:	00000f06 	br	d0368cc <tcp_getseq+0x58>
   {
      seq <<= 8;
 d036890:	e0bffd17 	ldw	r2,-12(fp)
 d036894:	1004923a 	slli	r2,r2,8
 d036898:	e0bffd15 	stw	r2,-12(fp)
      seq += (u_long)*(cp++);
 d03689c:	e0bfff17 	ldw	r2,-4(fp)
 d0368a0:	10800003 	ldbu	r2,0(r2)
 d0368a4:	10c03fcc 	andi	r3,r2,255
 d0368a8:	e0bffd17 	ldw	r2,-12(fp)
 d0368ac:	10c5883a 	add	r2,r2,r3
 d0368b0:	e0bffd15 	stw	r2,-12(fp)
 d0368b4:	e0bfff17 	ldw	r2,-4(fp)
 d0368b8:	10800044 	addi	r2,r2,1
 d0368bc:	e0bfff15 	stw	r2,-4(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 d0368c0:	e0bffe17 	ldw	r2,-8(fp)
 d0368c4:	10800044 	addi	r2,r2,1
 d0368c8:	e0bffe15 	stw	r2,-8(fp)
 d0368cc:	e0bffe17 	ldw	r2,-8(fp)
 d0368d0:	10800110 	cmplti	r2,r2,4
 d0368d4:	103fee1e 	bne	r2,zero,d036890 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 d0368d8:	e0bffd17 	ldw	r2,-12(fp)
}
 d0368dc:	e037883a 	mov	sp,fp
 d0368e0:	df000017 	ldw	fp,0(sp)
 d0368e4:	dec00104 	addi	sp,sp,4
 d0368e8:	f800283a 	ret

0d0368ec <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 d0368ec:	defff704 	addi	sp,sp,-36
 d0368f0:	dfc00815 	stw	ra,32(sp)
 d0368f4:	df000715 	stw	fp,28(sp)
 d0368f8:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 d0368fc:	d0a03f17 	ldw	r2,-32516(gp)
 d036900:	100490fa 	slli	r2,r2,3
 d036904:	d0a0b415 	stw	r2,-32048(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 d036908:	008341b4 	movhi	r2,3334
 d03690c:	10b3e204 	addi	r2,r2,-12408
 d036910:	10800017 	ldw	r2,0(r2)
 d036914:	e0bffb15 	stw	r2,-20(fp)
 d036918:	00008306 	br	d036b28 <tcp_slowtimo+0x23c>
   {
      sonext = so->next;
 d03691c:	e0bffb17 	ldw	r2,-20(fp)
 d036920:	10800017 	ldw	r2,0(r2)
 d036924:	e0bffa15 	stw	r2,-24(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 d036928:	e0bffb17 	ldw	r2,-20(fp)
 d03692c:	10800983 	ldbu	r2,38(r2)
 d036930:	10803fcc 	andi	r2,r2,255
 d036934:	1080201c 	xori	r2,r2,128
 d036938:	10bfe004 	addi	r2,r2,-128
 d03693c:	10800058 	cmpnei	r2,r2,1
 d036940:	1000471e 	bne	r2,zero,d036a60 <tcp_slowtimo+0x174>
      {
         ip = so->so_pcb;
 d036944:	e0bffb17 	ldw	r2,-20(fp)
 d036948:	10800117 	ldw	r2,4(r2)
 d03694c:	e0bfff15 	stw	r2,-4(fp)
         if (!ip)
 d036950:	e0bfff17 	ldw	r2,-4(fp)
 d036954:	1005003a 	cmpeq	r2,r2,zero
 d036958:	1000711e 	bne	r2,zero,d036b20 <tcp_slowtimo+0x234>
            continue;
         ipnxt = ip->inp_next;
 d03695c:	e0bfff17 	ldw	r2,-4(fp)
 d036960:	10800017 	ldw	r2,0(r2)
 d036964:	e0bffe15 	stw	r2,-8(fp)

         tp = intotcpcb(so->so_pcb);
 d036968:	e0bffb17 	ldw	r2,-20(fp)
 d03696c:	10800117 	ldw	r2,4(r2)
 d036970:	10800917 	ldw	r2,36(r2)
 d036974:	e0bffd15 	stw	r2,-12(fp)
         if (!tp)
 d036978:	e0bffd17 	ldw	r2,-12(fp)
 d03697c:	1005003a 	cmpeq	r2,r2,zero
 d036980:	1000671e 	bne	r2,zero,d036b20 <tcp_slowtimo+0x234>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 d036984:	e03ffc15 	stw	zero,-16(fp)
 d036988:	00002d06 	br	d036a40 <tcp_slowtimo+0x154>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 d03698c:	e0bffc17 	ldw	r2,-16(fp)
 d036990:	e0fffd17 	ldw	r3,-12(fp)
 d036994:	1085883a 	add	r2,r2,r2
 d036998:	1085883a 	add	r2,r2,r2
 d03699c:	10c5883a 	add	r2,r2,r3
 d0369a0:	10800304 	addi	r2,r2,12
 d0369a4:	10800017 	ldw	r2,0(r2)
 d0369a8:	1005003a 	cmpeq	r2,r2,zero
 d0369ac:	1000211e 	bne	r2,zero,d036a34 <tcp_slowtimo+0x148>
 d0369b0:	e0fffc17 	ldw	r3,-16(fp)
 d0369b4:	e13ffd17 	ldw	r4,-12(fp)
 d0369b8:	18c5883a 	add	r2,r3,r3
 d0369bc:	1085883a 	add	r2,r2,r2
 d0369c0:	1105883a 	add	r2,r2,r4
 d0369c4:	10800304 	addi	r2,r2,12
 d0369c8:	10800017 	ldw	r2,0(r2)
 d0369cc:	117fffc4 	addi	r5,r2,-1
 d0369d0:	e13ffd17 	ldw	r4,-12(fp)
 d0369d4:	18c5883a 	add	r2,r3,r3
 d0369d8:	1085883a 	add	r2,r2,r2
 d0369dc:	1105883a 	add	r2,r2,r4
 d0369e0:	10800304 	addi	r2,r2,12
 d0369e4:	11400015 	stw	r5,0(r2)
 d0369e8:	e13ffd17 	ldw	r4,-12(fp)
 d0369ec:	18c5883a 	add	r2,r3,r3
 d0369f0:	1085883a 	add	r2,r2,r2
 d0369f4:	1105883a 	add	r2,r2,r4
 d0369f8:	10800304 	addi	r2,r2,12
 d0369fc:	10800017 	ldw	r2,0(r2)
 d036a00:	1004c03a 	cmpne	r2,r2,zero
 d036a04:	10000b1e 	bne	r2,zero,d036a34 <tcp_slowtimo+0x148>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 d036a08:	e0fffb17 	ldw	r3,-20(fp)
 d036a0c:	008004c4 	movi	r2,19
 d036a10:	18800715 	stw	r2,28(r3)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 d036a14:	e1bffc17 	ldw	r6,-16(fp)
 d036a18:	e13ffb17 	ldw	r4,-20(fp)
 d036a1c:	000b883a 	mov	r5,zero
 d036a20:	d0370840 	call	d037084 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 d036a24:	e0bffe17 	ldw	r2,-8(fp)
 d036a28:	10c00117 	ldw	r3,4(r2)
 d036a2c:	e0bfff17 	ldw	r2,-4(fp)
 d036a30:	18803b1e 	bne	r3,r2,d036b20 <tcp_slowtimo+0x234>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 d036a34:	e0bffc17 	ldw	r2,-16(fp)
 d036a38:	10800044 	addi	r2,r2,1
 d036a3c:	e0bffc15 	stw	r2,-16(fp)
 d036a40:	e0bffc17 	ldw	r2,-16(fp)
 d036a44:	10800110 	cmplti	r2,r2,4
 d036a48:	103fd01e 	bne	r2,zero,d03698c <tcp_slowtimo+0xa0>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 d036a4c:	e0bffd17 	ldw	r2,-12(fp)
 d036a50:	10801d17 	ldw	r2,116(r2)
 d036a54:	10c00044 	addi	r3,r2,1
 d036a58:	e0bffd17 	ldw	r2,-12(fp)
 d036a5c:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 d036a60:	e0bffb17 	ldw	r2,-20(fp)
 d036a64:	10800a04 	addi	r2,r2,40
 d036a68:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 d036a6c:	e0bff917 	ldw	r2,-28(fp)
 d036a70:	1080070b 	ldhu	r2,28(r2)
 d036a74:	10bfffcc 	andi	r2,r2,65535
 d036a78:	1080020c 	andi	r2,r2,8
 d036a7c:	1005003a 	cmpeq	r2,r2,zero
 d036a80:	10000d1e 	bne	r2,zero,d036ab8 <tcp_slowtimo+0x1cc>
      {
         select_wait = 0;
 d036a84:	00834174 	movhi	r2,3333
 d036a88:	108ad104 	addi	r2,r2,11076
 d036a8c:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 d036a90:	01034174 	movhi	r4,3333
 d036a94:	210ad104 	addi	r4,r4,11076
 d036a98:	d02515c0 	call	d02515c <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 d036a9c:	e0bff917 	ldw	r2,-28(fp)
 d036aa0:	10c0070b 	ldhu	r3,28(r2)
 d036aa4:	00bffdc4 	movi	r2,-9
 d036aa8:	1884703a 	and	r2,r3,r2
 d036aac:	1007883a 	mov	r3,r2
 d036ab0:	e0bff917 	ldw	r2,-28(fp)
 d036ab4:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 d036ab8:	e0bffb17 	ldw	r2,-20(fp)
 d036abc:	10801204 	addi	r2,r2,72
 d036ac0:	e0bff915 	stw	r2,-28(fp)
      if (sb->sb_flags & SB_SEL) 
 d036ac4:	e0bff917 	ldw	r2,-28(fp)
 d036ac8:	1080070b 	ldhu	r2,28(r2)
 d036acc:	10bfffcc 	andi	r2,r2,65535
 d036ad0:	1080020c 	andi	r2,r2,8
 d036ad4:	1005003a 	cmpeq	r2,r2,zero
 d036ad8:	10000d1e 	bne	r2,zero,d036b10 <tcp_slowtimo+0x224>
      {
         select_wait = 0;         
 d036adc:	00834174 	movhi	r2,3333
 d036ae0:	108ad104 	addi	r2,r2,11076
 d036ae4:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 d036ae8:	01034174 	movhi	r4,3333
 d036aec:	210ad104 	addi	r4,r4,11076
 d036af0:	d02515c0 	call	d02515c <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 d036af4:	e0bff917 	ldw	r2,-28(fp)
 d036af8:	10c0070b 	ldhu	r3,28(r2)
 d036afc:	00bffdc4 	movi	r2,-9
 d036b00:	1884703a 	and	r2,r3,r2
 d036b04:	1007883a 	mov	r3,r2
 d036b08:	e0bff917 	ldw	r2,-28(fp)
 d036b0c:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 d036b10:	e0bffb17 	ldw	r2,-20(fp)
 d036b14:	10800904 	addi	r2,r2,36
 d036b18:	1009883a 	mov	r4,r2
 d036b1c:	d02515c0 	call	d02515c <tcp_wakeup>
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 d036b20:	e0bffa17 	ldw	r2,-24(fp)
 d036b24:	e0bffb15 	stw	r2,-20(fp)
 d036b28:	e0bffb17 	ldw	r2,-20(fp)
 d036b2c:	1004c03a 	cmpne	r2,r2,zero
 d036b30:	103f7a1e 	bne	r2,zero,d03691c <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 d036b34:	00834174 	movhi	r2,3333
 d036b38:	108ad604 	addi	r2,r2,11096
 d036b3c:	10c00017 	ldw	r3,0(r2)
 d036b40:	00be9fd4 	movui	r2,64127
 d036b44:	1887883a 	add	r3,r3,r2
 d036b48:	00834174 	movhi	r2,3333
 d036b4c:	108ad604 	addi	r2,r2,11096
 d036b50:	10c00015 	stw	r3,0(r2)

   if (tcp_iss & 0xff000000)
 d036b54:	00834174 	movhi	r2,3333
 d036b58:	108ad604 	addi	r2,r2,11096
 d036b5c:	10800017 	ldw	r2,0(r2)
 d036b60:	10bfc02c 	andhi	r2,r2,65280
 d036b64:	1005003a 	cmpeq	r2,r2,zero
 d036b68:	1000031e 	bne	r2,zero,d036b78 <tcp_slowtimo+0x28c>
      tcp_iss = 0L;
 d036b6c:	00834174 	movhi	r2,3333
 d036b70:	108ad604 	addi	r2,r2,11096
 d036b74:	10000015 	stw	zero,0(r2)
}
 d036b78:	e037883a 	mov	sp,fp
 d036b7c:	dfc00117 	ldw	ra,4(sp)
 d036b80:	df000017 	ldw	fp,0(sp)
 d036b84:	dec00204 	addi	sp,sp,8
 d036b88:	f800283a 	ret

0d036b8c <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 d036b8c:	defffd04 	addi	sp,sp,-12
 d036b90:	df000215 	stw	fp,8(sp)
 d036b94:	df000204 	addi	fp,sp,8
 d036b98:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 d036b9c:	e03ffe15 	stw	zero,-8(fp)
 d036ba0:	00000a06 	br	d036bcc <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 d036ba4:	e0bffe17 	ldw	r2,-8(fp)
 d036ba8:	e0ffff17 	ldw	r3,-4(fp)
 d036bac:	1085883a 	add	r2,r2,r2
 d036bb0:	1085883a 	add	r2,r2,r2
 d036bb4:	10c5883a 	add	r2,r2,r3
 d036bb8:	10800304 	addi	r2,r2,12
 d036bbc:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 d036bc0:	e0bffe17 	ldw	r2,-8(fp)
 d036bc4:	10800044 	addi	r2,r2,1
 d036bc8:	e0bffe15 	stw	r2,-8(fp)
 d036bcc:	e0bffe17 	ldw	r2,-8(fp)
 d036bd0:	10800110 	cmplti	r2,r2,4
 d036bd4:	103ff31e 	bne	r2,zero,d036ba4 <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 d036bd8:	e037883a 	mov	sp,fp
 d036bdc:	df000017 	ldw	fp,0(sp)
 d036be0:	dec00104 	addi	sp,sp,4
 d036be4:	f800283a 	ret

0d036be8 <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 d036be8:	defff504 	addi	sp,sp,-44
 d036bec:	dfc00a15 	stw	ra,40(sp)
 d036bf0:	df000915 	stw	fp,36(sp)
 d036bf4:	df000904 	addi	fp,sp,36
 d036bf8:	e13ffb15 	stw	r4,-20(fp)
 d036bfc:	e17ffc15 	stw	r5,-16(fp)
   int   rexmt;

   switch (timer) 
 d036c00:	e0bffc17 	ldw	r2,-16(fp)
 d036c04:	e0bffe15 	stw	r2,-8(fp)
 d036c08:	e0fffe17 	ldw	r3,-8(fp)
 d036c0c:	18800060 	cmpeqi	r2,r3,1
 d036c10:	1000bd1e 	bne	r2,zero,d036f08 <tcp_timers+0x320>
 d036c14:	e0fffe17 	ldw	r3,-8(fp)
 d036c18:	18800088 	cmpgei	r2,r3,2
 d036c1c:	1000041e 	bne	r2,zero,d036c30 <tcp_timers+0x48>
 d036c20:	e0fffe17 	ldw	r3,-8(fp)
 d036c24:	1805003a 	cmpeq	r2,r3,zero
 d036c28:	10001b1e 	bne	r2,zero,d036c98 <tcp_timers+0xb0>
 d036c2c:	00010f06 	br	d03706c <tcp_timers+0x484>
 d036c30:	e0fffe17 	ldw	r3,-8(fp)
 d036c34:	188000a0 	cmpeqi	r2,r3,2
 d036c38:	1000c41e 	bne	r2,zero,d036f4c <tcp_timers+0x364>
 d036c3c:	e0fffe17 	ldw	r3,-8(fp)
 d036c40:	188000e0 	cmpeqi	r2,r3,3
 d036c44:	1000011e 	bne	r2,zero,d036c4c <tcp_timers+0x64>
 d036c48:	00010806 	br	d03706c <tcp_timers+0x484>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 d036c4c:	e0bffb17 	ldw	r2,-20(fp)
 d036c50:	10800217 	ldw	r2,8(r2)
 d036c54:	108002a0 	cmpeqi	r2,r2,10
 d036c58:	10000b1e 	bne	r2,zero,d036c88 <tcp_timers+0xa0>
 d036c5c:	e0bffb17 	ldw	r2,-20(fp)
 d036c60:	10c01d17 	ldw	r3,116(r2)
 d036c64:	d0a0b417 	ldw	r2,-32048(gp)
 d036c68:	10c00716 	blt	r2,r3,d036c88 <tcp_timers+0xa0>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 d036c6c:	d0a03f17 	ldw	r2,-32516(gp)
 d036c70:	10ffffcc 	andi	r3,r2,65535
 d036c74:	18e0001c 	xori	r3,r3,32768
 d036c78:	18e00004 	addi	r3,r3,-32768
 d036c7c:	e0bffb17 	ldw	r2,-20(fp)
 d036c80:	10c00615 	stw	r3,24(r2)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 d036c84:	0000f906 	br	d03706c <tcp_timers+0x484>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 d036c88:	e13ffb17 	ldw	r4,-20(fp)
 d036c8c:	d0366c00 	call	d0366c0 <tcp_close>
 d036c90:	e0bffb15 	stw	r2,-20(fp)
      break;
 d036c94:	0000f506 	br	d03706c <tcp_timers+0x484>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 d036c98:	008341b4 	movhi	r2,3334
 d036c9c:	10b3e704 	addi	r2,r2,-12388
 d036ca0:	10800b17 	ldw	r2,44(r2)
 d036ca4:	10c00044 	addi	r3,r2,1
 d036ca8:	008341b4 	movhi	r2,3334
 d036cac:	10b3e704 	addi	r2,r2,-12388
 d036cb0:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 d036cb4:	e0bffb17 	ldw	r2,-20(fp)
 d036cb8:	10800717 	ldw	r2,28(r2)
 d036cbc:	10c00044 	addi	r3,r2,1
 d036cc0:	e0bffb17 	ldw	r2,-20(fp)
 d036cc4:	10c00715 	stw	r3,28(r2)
 d036cc8:	e0bffb17 	ldw	r2,-20(fp)
 d036ccc:	10800717 	ldw	r2,28(r2)
 d036cd0:	10800350 	cmplti	r2,r2,13
 d036cd4:	10000f1e 	bne	r2,zero,d036d14 <tcp_timers+0x12c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 d036cd8:	e0fffb17 	ldw	r3,-20(fp)
 d036cdc:	00800304 	movi	r2,12
 d036ce0:	18800715 	stw	r2,28(r3)
         tcpstat.tcps_timeoutdrop++;
 d036ce4:	008341b4 	movhi	r2,3334
 d036ce8:	10b41504 	addi	r2,r2,-12204
 d036cec:	10800917 	ldw	r2,36(r2)
 d036cf0:	10c00044 	addi	r3,r2,1
 d036cf4:	008341b4 	movhi	r2,3334
 d036cf8:	10b41504 	addi	r2,r2,-12204
 d036cfc:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 d036d00:	e13ffb17 	ldw	r4,-20(fp)
 d036d04:	01401d04 	movi	r5,116
 d036d08:	d0366140 	call	d036614 <tcp_drop>
 d036d0c:	e0bffb15 	stw	r2,-20(fp)
         break;
 d036d10:	0000d606 	br	d03706c <tcp_timers+0x484>
      }
      tcpstat.tcps_rexmttimeo++;
 d036d14:	008341b4 	movhi	r2,3334
 d036d18:	10b41504 	addi	r2,r2,-12204
 d036d1c:	10800a17 	ldw	r2,40(r2)
 d036d20:	10c00044 	addi	r3,r2,1
 d036d24:	008341b4 	movhi	r2,3334
 d036d28:	10b41504 	addi	r2,r2,-12204
 d036d2c:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 d036d30:	e0bffb17 	ldw	r2,-20(fp)
 d036d34:	10802017 	ldw	r2,128(r2)
 d036d38:	1007d0ba 	srai	r3,r2,2
 d036d3c:	e0bffb17 	ldw	r2,-20(fp)
 d036d40:	10802117 	ldw	r2,132(r2)
 d036d44:	1885883a 	add	r2,r3,r2
 d036d48:	1005d07a 	srai	r2,r2,1
 d036d4c:	e0bffa15 	stw	r2,-24(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 d036d50:	e0bffb17 	ldw	r2,-20(fp)
 d036d54:	10c00717 	ldw	r3,28(r2)
 d036d58:	00834174 	movhi	r2,3333
 d036d5c:	10894fc4 	addi	r2,r2,9535
 d036d60:	10c5883a 	add	r2,r2,r3
 d036d64:	10800003 	ldbu	r2,0(r2)
 d036d68:	10c03fcc 	andi	r3,r2,255
 d036d6c:	e0bffa17 	ldw	r2,-24(fp)
 d036d70:	10c5383a 	mul	r2,r2,r3
 d036d74:	e0bffa15 	stw	r2,-24(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 d036d78:	e0bffa17 	ldw	r2,-24(fp)
 d036d7c:	10ffffcc 	andi	r3,r2,65535
 d036d80:	18e0001c 	xori	r3,r3,32768
 d036d84:	18e00004 	addi	r3,r3,-32768
 d036d88:	e0bffb17 	ldw	r2,-20(fp)
 d036d8c:	10c00815 	stw	r3,32(r2)
 d036d90:	e0bffb17 	ldw	r2,-20(fp)
 d036d94:	10800817 	ldw	r2,32(r2)
 d036d98:	10800088 	cmpgei	r2,r2,2
 d036d9c:	1000041e 	bne	r2,zero,d036db0 <tcp_timers+0x1c8>
 d036da0:	e0fffb17 	ldw	r3,-20(fp)
 d036da4:	00800084 	movi	r2,2
 d036da8:	18800815 	stw	r2,32(r3)
 d036dac:	00000706 	br	d036dcc <tcp_timers+0x1e4>
 d036db0:	e0bffb17 	ldw	r2,-20(fp)
 d036db4:	10800817 	ldw	r2,32(r2)
 d036db8:	10802050 	cmplti	r2,r2,129
 d036dbc:	1000031e 	bne	r2,zero,d036dcc <tcp_timers+0x1e4>
 d036dc0:	e0fffb17 	ldw	r3,-20(fp)
 d036dc4:	00802004 	movi	r2,128
 d036dc8:	18800815 	stw	r2,32(r3)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 d036dcc:	e0bffb17 	ldw	r2,-20(fp)
 d036dd0:	10c00817 	ldw	r3,32(r2)
 d036dd4:	e0bffb17 	ldw	r2,-20(fp)
 d036dd8:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 d036ddc:	e0bffb17 	ldw	r2,-20(fp)
 d036de0:	10800717 	ldw	r2,28(r2)
 d036de4:	10800110 	cmplti	r2,r2,4
 d036de8:	1000101e 	bne	r2,zero,d036e2c <tcp_timers+0x244>
 d036dec:	e0bffb17 	ldw	r2,-20(fp)
 d036df0:	10800b0b 	ldhu	r2,44(r2)
 d036df4:	10bfffcc 	andi	r2,r2,65535
 d036df8:	1080400c 	andi	r2,r2,256
 d036dfc:	1004c03a 	cmpne	r2,r2,zero
 d036e00:	10000a1e 	bne	r2,zero,d036e2c <tcp_timers+0x244>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 d036e04:	e0bffb17 	ldw	r2,-20(fp)
 d036e08:	10c02117 	ldw	r3,132(r2)
 d036e0c:	e0bffb17 	ldw	r2,-20(fp)
 d036e10:	10802017 	ldw	r2,128(r2)
 d036e14:	1005d0ba 	srai	r2,r2,2
 d036e18:	1887883a 	add	r3,r3,r2
 d036e1c:	e0bffb17 	ldw	r2,-20(fp)
 d036e20:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 d036e24:	e0bffb17 	ldw	r2,-20(fp)
 d036e28:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 d036e2c:	e0bffb17 	ldw	r2,-20(fp)
 d036e30:	10c00e17 	ldw	r3,56(r2)
 d036e34:	e0bffb17 	ldw	r2,-20(fp)
 d036e38:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 d036e3c:	e0bffb17 	ldw	r2,-20(fp)
 d036e40:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 d036e44:	e0bffb17 	ldw	r2,-20(fp)
 d036e48:	10800d17 	ldw	r2,52(r2)
 d036e4c:	10800817 	ldw	r2,32(r2)
 d036e50:	10800417 	ldw	r2,16(r2)
 d036e54:	1090000c 	andi	r2,r2,16384
 d036e58:	1004c03a 	cmpne	r2,r2,zero
 d036e5c:	1000271e 	bne	r2,zero,d036efc <tcp_timers+0x314>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 d036e60:	e0bffb17 	ldw	r2,-20(fp)
 d036e64:	10c01417 	ldw	r3,80(r2)
 d036e68:	e0bffb17 	ldw	r2,-20(fp)
 d036e6c:	10801b17 	ldw	r2,108(r2)
 d036e70:	e0bffd15 	stw	r2,-12(fp)
 d036e74:	e0ffff15 	stw	r3,-4(fp)
 d036e78:	e0bffd17 	ldw	r2,-12(fp)
 d036e7c:	e0ffff17 	ldw	r3,-4(fp)
 d036e80:	10c0022e 	bgeu	r2,r3,d036e8c <tcp_timers+0x2a4>
 d036e84:	e0bffd17 	ldw	r2,-12(fp)
 d036e88:	e0bfff15 	stw	r2,-4(fp)
 d036e8c:	e0ffff17 	ldw	r3,-4(fp)
 d036e90:	e0fff915 	stw	r3,-28(fp)
         win = win / 2 / tp->t_maxseg;
 d036e94:	e0bff917 	ldw	r2,-28(fp)
 d036e98:	1006d07a 	srli	r3,r2,1
 d036e9c:	e0bffb17 	ldw	r2,-20(fp)
 d036ea0:	10800a0b 	ldhu	r2,40(r2)
 d036ea4:	10bfffcc 	andi	r2,r2,65535
 d036ea8:	1885203a 	divu	r2,r3,r2
 d036eac:	e0bff915 	stw	r2,-28(fp)
         if (win < 2)
 d036eb0:	e0bff917 	ldw	r2,-28(fp)
 d036eb4:	108000a8 	cmpgeui	r2,r2,2
 d036eb8:	1000021e 	bne	r2,zero,d036ec4 <tcp_timers+0x2dc>
            win = 2;
 d036ebc:	00800084 	movi	r2,2
 d036ec0:	e0bff915 	stw	r2,-28(fp)
         tp->snd_cwnd = tp->t_maxseg;
 d036ec4:	e0bffb17 	ldw	r2,-20(fp)
 d036ec8:	10800a0b 	ldhu	r2,40(r2)
 d036ecc:	10ffffcc 	andi	r3,r2,65535
 d036ed0:	e0bffb17 	ldw	r2,-20(fp)
 d036ed4:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 d036ed8:	e0bff917 	ldw	r2,-28(fp)
 d036edc:	10ffffcc 	andi	r3,r2,65535
 d036ee0:	e0bffb17 	ldw	r2,-20(fp)
 d036ee4:	10800a0b 	ldhu	r2,40(r2)
 d036ee8:	10bfffcc 	andi	r2,r2,65535
 d036eec:	1885383a 	mul	r2,r3,r2
 d036ef0:	1007883a 	mov	r3,r2
 d036ef4:	e0bffb17 	ldw	r2,-20(fp)
 d036ef8:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 d036efc:	e13ffb17 	ldw	r4,-20(fp)
 d036f00:	d034ba40 	call	d034ba4 <tcp_output>
      break;
 d036f04:	00005906 	br	d03706c <tcp_timers+0x484>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 d036f08:	008341b4 	movhi	r2,3334
 d036f0c:	10b41504 	addi	r2,r2,-12204
 d036f10:	10800b17 	ldw	r2,44(r2)
 d036f14:	10c00044 	addi	r3,r2,1
 d036f18:	008341b4 	movhi	r2,3334
 d036f1c:	10b41504 	addi	r2,r2,-12204
 d036f20:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 d036f24:	e13ffb17 	ldw	r4,-20(fp)
 d036f28:	d035d200 	call	d035d20 <tcp_setpersist>
      tp->t_force = 1;
 d036f2c:	e0fffb17 	ldw	r3,-20(fp)
 d036f30:	00800044 	movi	r2,1
 d036f34:	18800a85 	stb	r2,42(r3)
      (void) tcp_output(tp);
 d036f38:	e13ffb17 	ldw	r4,-20(fp)
 d036f3c:	d034ba40 	call	d034ba4 <tcp_output>
      tp->t_force = 0;
 d036f40:	e0bffb17 	ldw	r2,-20(fp)
 d036f44:	10000a85 	stb	zero,42(r2)
      break;
 d036f48:	00004806 	br	d03706c <tcp_timers+0x484>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 d036f4c:	008341b4 	movhi	r2,3334
 d036f50:	10b41504 	addi	r2,r2,-12204
 d036f54:	10800c17 	ldw	r2,48(r2)
 d036f58:	10c00044 	addi	r3,r2,1
 d036f5c:	008341b4 	movhi	r2,3334
 d036f60:	10b41504 	addi	r2,r2,-12204
 d036f64:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 d036f68:	e0bffb17 	ldw	r2,-20(fp)
 d036f6c:	10800217 	ldw	r2,8(r2)
 d036f70:	10800110 	cmplti	r2,r2,4
 d036f74:	1000321e 	bne	r2,zero,d037040 <tcp_timers+0x458>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 d036f78:	e0bffb17 	ldw	r2,-20(fp)
 d036f7c:	10800d17 	ldw	r2,52(r2)
 d036f80:	10800817 	ldw	r2,32(r2)
 d036f84:	10800417 	ldw	r2,16(r2)
 d036f88:	1080020c 	andi	r2,r2,8
 d036f8c:	1005003a 	cmpeq	r2,r2,zero
 d036f90:	1000241e 	bne	r2,zero,d037024 <tcp_timers+0x43c>
 d036f94:	e0bffb17 	ldw	r2,-20(fp)
 d036f98:	10800217 	ldw	r2,8(r2)
 d036f9c:	10800188 	cmpgei	r2,r2,6
 d036fa0:	1000201e 	bne	r2,zero,d037024 <tcp_timers+0x43c>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 d036fa4:	e0bffb17 	ldw	r2,-20(fp)
 d036fa8:	11001d17 	ldw	r4,116(r2)
 d036fac:	d0e03e17 	ldw	r3,-32520(gp)
 d036fb0:	d0a0b417 	ldw	r2,-32048(gp)
 d036fb4:	1885883a 	add	r2,r3,r2
 d036fb8:	2080210e 	bge	r4,r2,d037040 <tcp_timers+0x458>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 d036fbc:	008341b4 	movhi	r2,3334
 d036fc0:	10b41504 	addi	r2,r2,-12204
 d036fc4:	10800d17 	ldw	r2,52(r2)
 d036fc8:	10c00044 	addi	r3,r2,1
 d036fcc:	008341b4 	movhi	r2,3334
 d036fd0:	10b41504 	addi	r2,r2,-12204
 d036fd4:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 d036fd8:	e0bffb17 	ldw	r2,-20(fp)
 d036fdc:	11400c17 	ldw	r5,48(r2)
 d036fe0:	e0bffb17 	ldw	r2,-20(fp)
 d036fe4:	10801617 	ldw	r2,88(r2)
 d036fe8:	11bfffc4 	addi	r6,r2,-1
 d036fec:	e0bffb17 	ldw	r2,-20(fp)
 d036ff0:	10800e17 	ldw	r2,56(r2)
 d036ff4:	11ffffc4 	addi	r7,r2,-1
 d036ff8:	d8000015 	stw	zero,0(sp)
 d036ffc:	d8000115 	stw	zero,4(sp)
 d037000:	e13ffb17 	ldw	r4,-20(fp)
 d037004:	d0360740 	call	d036074 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 d037008:	d0a03f17 	ldw	r2,-32516(gp)
 d03700c:	10ffffcc 	andi	r3,r2,65535
 d037010:	18e0001c 	xori	r3,r3,32768
 d037014:	18e00004 	addi	r3,r3,-32768
 d037018:	e0bffb17 	ldw	r2,-20(fp)
 d03701c:	10c00515 	stw	r3,20(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 d037020:	00001206 	br	d03706c <tcp_timers+0x484>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 d037024:	d0a03e17 	ldw	r2,-32520(gp)
 d037028:	10ffffcc 	andi	r3,r2,65535
 d03702c:	18e0001c 	xori	r3,r3,32768
 d037030:	18e00004 	addi	r3,r3,-32768
 d037034:	e0bffb17 	ldw	r2,-20(fp)
 d037038:	10c00515 	stw	r3,20(r2)
      break;
 d03703c:	00000b06 	br	d03706c <tcp_timers+0x484>
      dropit:
      tcpstat.tcps_keepdrops++;
 d037040:	008341b4 	movhi	r2,3334
 d037044:	10b41504 	addi	r2,r2,-12204
 d037048:	10800e17 	ldw	r2,56(r2)
 d03704c:	10c00044 	addi	r3,r2,1
 d037050:	008341b4 	movhi	r2,3334
 d037054:	10b41504 	addi	r2,r2,-12204
 d037058:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 d03705c:	e13ffb17 	ldw	r4,-20(fp)
 d037060:	01401d04 	movi	r5,116
 d037064:	d0366140 	call	d036614 <tcp_drop>
 d037068:	e0bffb15 	stw	r2,-20(fp)
      break;
   }
   return tp;
 d03706c:	e0bffb17 	ldw	r2,-20(fp)
}
 d037070:	e037883a 	mov	sp,fp
 d037074:	dfc00117 	ldw	ra,4(sp)
 d037078:	df000017 	ldw	fp,0(sp)
 d03707c:	dec00204 	addi	sp,sp,8
 d037080:	f800283a 	ret

0d037084 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 d037084:	defff504 	addi	sp,sp,-44
 d037088:	dfc00a15 	stw	ra,40(sp)
 d03708c:	df000915 	stw	fp,36(sp)
 d037090:	df000904 	addi	fp,sp,36
 d037094:	e13ffc15 	stw	r4,-16(fp)
 d037098:	e17ffd15 	stw	r5,-12(fp)
 d03709c:	e1bffe15 	stw	r6,-8(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 d0370a0:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 d0370a4:	e0bffc17 	ldw	r2,-16(fp)
 d0370a8:	10800717 	ldw	r2,28(r2)
 d0370ac:	e0bff815 	stw	r2,-32(fp)
   inp = sotoinpcb(so);
 d0370b0:	e0bffc17 	ldw	r2,-16(fp)
 d0370b4:	10800117 	ldw	r2,4(r2)
 d0370b8:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 d0370bc:	e0bffb17 	ldw	r2,-20(fp)
 d0370c0:	1004c03a 	cmpne	r2,r2,zero
 d0370c4:	1000061e 	bne	r2,zero,d0370e0 <tcp_usrreq+0x5c>
 d0370c8:	e0bff817 	ldw	r2,-32(fp)
 d0370cc:	1005003a 	cmpeq	r2,r2,zero
 d0370d0:	1000031e 	bne	r2,zero,d0370e0 <tcp_usrreq+0x5c>
   {
      return (EINVAL);
 d0370d4:	00800584 	movi	r2,22
 d0370d8:	e0bfff15 	stw	r2,-4(fp)
 d0370dc:	0001a406 	br	d037770 <tcp_usrreq+0x6ec>
   }

   if (inp)
 d0370e0:	e0bffb17 	ldw	r2,-20(fp)
 d0370e4:	1005003a 	cmpeq	r2,r2,zero
 d0370e8:	1000041e 	bne	r2,zero,d0370fc <tcp_usrreq+0x78>
      tp = intotcpcb(inp);
 d0370ec:	e0bffb17 	ldw	r2,-20(fp)
 d0370f0:	10800917 	ldw	r2,36(r2)
 d0370f4:	e0bffa15 	stw	r2,-24(fp)
 d0370f8:	00000906 	br	d037120 <tcp_usrreq+0x9c>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 d0370fc:	e0bff817 	ldw	r2,-32(fp)
 d037100:	1004c03a 	cmpne	r2,r2,zero
 d037104:	1000021e 	bne	r2,zero,d037110 <tcp_usrreq+0x8c>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 d037108:	e03ffa15 	stw	zero,-24(fp)
 d03710c:	00000406 	br	d037120 <tcp_usrreq+0x9c>
      else
      {
         dtrap(); /* programming error? */
 d037110:	d0293e80 	call	d0293e8 <dtrap>
         return EINVAL;
 d037114:	00800584 	movi	r2,22
 d037118:	e0bfff15 	stw	r2,-4(fp)
 d03711c:	00019406 	br	d037770 <tcp_usrreq+0x6ec>
      }
   }

   switch (req) 
 d037120:	e0bff817 	ldw	r2,-32(fp)
 d037124:	10800528 	cmpgeui	r2,r2,20
 d037128:	10018c1e 	bne	r2,zero,d03775c <tcp_usrreq+0x6d8>
 d03712c:	e0bff817 	ldw	r2,-32(fp)
 d037130:	1085883a 	add	r2,r2,r2
 d037134:	1087883a 	add	r3,r2,r2
 d037138:	008340f4 	movhi	r2,3331
 d03713c:	109c5304 	addi	r2,r2,29004
 d037140:	1885883a 	add	r2,r3,r2
 d037144:	10800017 	ldw	r2,0(r2)
 d037148:	1000683a 	jmp	r2
 d03714c:	0d03719c 	xori	r20,at,3526
 d037150:	0d03720c 	andi	r20,at,3528
 d037154:	0d037234 	orhi	r20,at,3528
 d037158:	0d03726c 	andhi	r20,at,3529
 d03715c:	0d0372ac 	andhi	r20,at,3530
 d037160:	0d037430 	cmpltui	r20,at,3536
 d037164:	0d037424 	muli	r20,at,3536
 d037168:	0d0374dc 	xori	r20,at,3539
 d03716c:	0d03750c 	andi	r20,at,3540
 d037170:	0d037518 	cmpnei	r20,at,3540
 d037174:	0d037570 	cmpltui	r20,at,3541
 d037178:	0d03775c 	xori	r20,at,3549
 d03717c:	0d037580 	call	d03758 <OSCtxSw_SWITCH_PC+0xd03718>
 d037180:	0d03758c 	andi	r20,at,3542
 d037184:	0d03765c 	xori	r20,at,3545
 d037188:	0d03772c 	andhi	r20,at,3548
 d03718c:	0d03773c 	xorhi	r20,at,3548
 d037190:	0d037418 	cmpnei	r20,at,3536
 d037194:	0d03775c 	xori	r20,at,3549
 d037198:	0d03774c 	andi	r20,at,3549
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 d03719c:	e0bffb17 	ldw	r2,-20(fp)
 d0371a0:	1005003a 	cmpeq	r2,r2,zero
 d0371a4:	1000031e 	bne	r2,zero,d0371b4 <tcp_usrreq+0x130>
      {
         error = EISCONN;
 d0371a8:	00801fc4 	movi	r2,127
 d0371ac:	e0bff915 	stw	r2,-28(fp)
         break;
 d0371b0:	00016d06 	br	d037768 <tcp_usrreq+0x6e4>
      }
      error = tcp_attach(so);
 d0371b4:	e13ffc17 	ldw	r4,-16(fp)
 d0371b8:	d0377880 	call	d037788 <tcp_attach>
 d0371bc:	e0bff915 	stw	r2,-28(fp)
      if (error)
 d0371c0:	e0bff917 	ldw	r2,-28(fp)
 d0371c4:	1004c03a 	cmpne	r2,r2,zero
 d0371c8:	1001671e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 d0371cc:	e0bffc17 	ldw	r2,-16(fp)
 d0371d0:	10800417 	ldw	r2,16(r2)
 d0371d4:	1080200c 	andi	r2,r2,128
 d0371d8:	1005003a 	cmpeq	r2,r2,zero
 d0371dc:	1001621e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
 d0371e0:	e0bffc17 	ldw	r2,-16(fp)
 d0371e4:	1080080b 	ldhu	r2,32(r2)
 d0371e8:	10bfffcc 	andi	r2,r2,65535
 d0371ec:	10a0001c 	xori	r2,r2,32768
 d0371f0:	10a00004 	addi	r2,r2,-32768
 d0371f4:	1004c03a 	cmpne	r2,r2,zero
 d0371f8:	10015b1e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
         so->so_linger = TCP_LINGERTIME;
 d0371fc:	e0fffc17 	ldw	r3,-16(fp)
 d037200:	00801e04 	movi	r2,120
 d037204:	1880080d 	sth	r2,32(r3)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 d037208:	00015706 	br	d037768 <tcp_usrreq+0x6e4>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 d03720c:	e0bffa17 	ldw	r2,-24(fp)
 d037210:	10800217 	ldw	r2,8(r2)
 d037214:	10800090 	cmplti	r2,r2,2
 d037218:	1000031e 	bne	r2,zero,d037228 <tcp_usrreq+0x1a4>
         SETTP(tp, tcp_disconnect(tp));
 d03721c:	e13ffa17 	ldw	r4,-24(fp)
 d037220:	d0378bc0 	call	d0378bc <tcp_disconnect>
 d037224:	00015006 	br	d037768 <tcp_usrreq+0x6e4>
      else
         SETTP(tp, tcp_close(tp));
 d037228:	e13ffa17 	ldw	r4,-24(fp)
 d03722c:	d0366c00 	call	d0366c0 <tcp_close>
      break;
 d037230:	00014d06 	br	d037768 <tcp_usrreq+0x6e4>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 d037234:	e0bffb17 	ldw	r2,-20(fp)
 d037238:	10800817 	ldw	r2,32(r2)
 d03723c:	10800517 	ldw	r2,20(r2)
 d037240:	10800098 	cmpnei	r2,r2,2
 d037244:	1000051e 	bne	r2,zero,d03725c <tcp_usrreq+0x1d8>
      {
         error = in_pcbbind(inp, nam);
 d037248:	e13ffb17 	ldw	r4,-20(fp)
 d03724c:	e17ffe17 	ldw	r5,-8(fp)
 d037250:	d04637c0 	call	d04637c <in_pcbbind>
 d037254:	e0bff915 	stw	r2,-28(fp)
         break;
 d037258:	00014306 	br	d037768 <tcp_usrreq+0x6e4>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 d03725c:	d0293e80 	call	d0293e8 <dtrap>
      error = EINVAL;
 d037260:	00800584 	movi	r2,22
 d037264:	e0bff915 	stw	r2,-28(fp)
      break;
 d037268:	00013f06 	br	d037768 <tcp_usrreq+0x6e4>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 d03726c:	e0bffb17 	ldw	r2,-20(fp)
 d037270:	1080078b 	ldhu	r2,30(r2)
 d037274:	10bfffcc 	andi	r2,r2,65535
 d037278:	1004c03a 	cmpne	r2,r2,zero
 d03727c:	1000041e 	bne	r2,zero,d037290 <tcp_usrreq+0x20c>
         error = in_pcbbind(inp, (struct mbuf *)0);
 d037280:	e13ffb17 	ldw	r4,-20(fp)
 d037284:	000b883a 	mov	r5,zero
 d037288:	d04637c0 	call	d04637c <in_pcbbind>
 d03728c:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 d037290:	e0bff917 	ldw	r2,-28(fp)
 d037294:	1004c03a 	cmpne	r2,r2,zero
 d037298:	1001331e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
         tp->t_state = TCPS_LISTEN;
 d03729c:	e0fffa17 	ldw	r3,-24(fp)
 d0372a0:	00800044 	movi	r2,1
 d0372a4:	18800215 	stw	r2,8(r3)
      break;
 d0372a8:	00012f06 	br	d037768 <tcp_usrreq+0x6e4>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 d0372ac:	e0bffb17 	ldw	r2,-20(fp)
 d0372b0:	1080078b 	ldhu	r2,30(r2)
 d0372b4:	10bfffcc 	andi	r2,r2,65535
 d0372b8:	1004c03a 	cmpne	r2,r2,zero
 d0372bc:	1000071e 	bne	r2,zero,d0372dc <tcp_usrreq+0x258>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 d0372c0:	e13ffb17 	ldw	r4,-20(fp)
 d0372c4:	000b883a 	mov	r5,zero
 d0372c8:	d04637c0 	call	d04637c <in_pcbbind>
 d0372cc:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 d0372d0:	e0bff917 	ldw	r2,-28(fp)
 d0372d4:	1004c03a 	cmpne	r2,r2,zero
 d0372d8:	1001231e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 d0372dc:	e13ffb17 	ldw	r4,-20(fp)
 d0372e0:	e17ffe17 	ldw	r5,-8(fp)
 d0372e4:	d0465d00 	call	d0465d0 <in_pcbconnect>
 d0372e8:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 d0372ec:	e0bff917 	ldw	r2,-28(fp)
 d0372f0:	1004c03a 	cmpne	r2,r2,zero
 d0372f4:	10011c1e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
         break;
      tp->t_template = tcp_template(tp);
 d0372f8:	e13ffa17 	ldw	r4,-24(fp)
 d0372fc:	d035f5c0 	call	d035f5c <tcp_template>
 d037300:	1007883a 	mov	r3,r2
 d037304:	e0bffa17 	ldw	r2,-24(fp)
 d037308:	10c00c15 	stw	r3,48(r2)
      if (tp->t_template == 0) 
 d03730c:	e0bffa17 	ldw	r2,-24(fp)
 d037310:	10800c17 	ldw	r2,48(r2)
 d037314:	1004c03a 	cmpne	r2,r2,zero
 d037318:	1000051e 	bne	r2,zero,d037330 <tcp_usrreq+0x2ac>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 d03731c:	e13ffb17 	ldw	r4,-20(fp)
 d037320:	d0467e00 	call	d0467e0 <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 d037324:	00801a44 	movi	r2,105
 d037328:	e0bff915 	stw	r2,-28(fp)
         break;
 d03732c:	00010e06 	br	d037768 <tcp_usrreq+0x6e4>
      }

      soisconnecting(so);
 d037330:	e13ffc17 	ldw	r4,-16(fp)
 d037334:	d02ff900 	call	d02ff90 <soisconnecting>
      tcpstat.tcps_connattempt++;
 d037338:	008341b4 	movhi	r2,3334
 d03733c:	10b41504 	addi	r2,r2,-12204
 d037340:	10800017 	ldw	r2,0(r2)
 d037344:	10c00044 	addi	r3,r2,1
 d037348:	008341b4 	movhi	r2,3334
 d03734c:	10b41504 	addi	r2,r2,-12204
 d037350:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 d037354:	e0fffa17 	ldw	r3,-24(fp)
 d037358:	00800084 	movi	r2,2
 d03735c:	18800215 	stw	r2,8(r3)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 d037360:	e0fffa17 	ldw	r3,-24(fp)
 d037364:	00802584 	movi	r2,150
 d037368:	18800515 	stw	r2,20(r3)
      tp->iss = tcp_iss; 
 d03736c:	00834174 	movhi	r2,3333
 d037370:	108ad604 	addi	r2,r2,11096
 d037374:	10c00017 	ldw	r3,0(r2)
 d037378:	e0bffa17 	ldw	r2,-24(fp)
 d03737c:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 d037380:	00834174 	movhi	r2,3333
 d037384:	108ad604 	addi	r2,r2,11096
 d037388:	10c00017 	ldw	r3,0(r2)
 d03738c:	00be9fd4 	movui	r2,64127
 d037390:	1887883a 	add	r3,r3,r2
 d037394:	00834174 	movhi	r2,3333
 d037398:	108ad604 	addi	r2,r2,11096
 d03739c:	10c00015 	stw	r3,0(r2)
      tcp_sendseqinit(tp);
 d0373a0:	e0bffa17 	ldw	r2,-24(fp)
 d0373a4:	10c01317 	ldw	r3,76(r2)
 d0373a8:	e0bffa17 	ldw	r2,-24(fp)
 d0373ac:	10c01015 	stw	r3,64(r2)
 d0373b0:	e0bffa17 	ldw	r2,-24(fp)
 d0373b4:	10c01017 	ldw	r3,64(r2)
 d0373b8:	e0bffa17 	ldw	r2,-24(fp)
 d0373bc:	10c01a15 	stw	r3,104(r2)
 d0373c0:	e0bffa17 	ldw	r2,-24(fp)
 d0373c4:	10c01a17 	ldw	r3,104(r2)
 d0373c8:	e0bffa17 	ldw	r2,-24(fp)
 d0373cc:	10c00f15 	stw	r3,60(r2)
 d0373d0:	e0bffa17 	ldw	r2,-24(fp)
 d0373d4:	10c00f17 	ldw	r3,60(r2)
 d0373d8:	e0bffa17 	ldw	r2,-24(fp)
 d0373dc:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 d0373e0:	e13ffa17 	ldw	r4,-24(fp)
 d0373e4:	d034ba40 	call	d034ba4 <tcp_output>
 d0373e8:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 d0373ec:	e0bff917 	ldw	r2,-28(fp)
 d0373f0:	1004c03a 	cmpne	r2,r2,zero
 d0373f4:	1000dc1e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 d0373f8:	008341b4 	movhi	r2,3334
 d0373fc:	10b3e704 	addi	r2,r2,-12388
 d037400:	10800417 	ldw	r2,16(r2)
 d037404:	10c00044 	addi	r3,r2,1
 d037408:	008341b4 	movhi	r2,3334
 d03740c:	10b3e704 	addi	r2,r2,-12388
 d037410:	10c00415 	stw	r3,16(r2)
      break;
 d037414:	0000d406 	br	d037768 <tcp_usrreq+0x6e4>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 d037418:	008017c4 	movi	r2,95
 d03741c:	e0bff915 	stw	r2,-28(fp)
      break;
 d037420:	0000d106 	br	d037768 <tcp_usrreq+0x6e4>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 d037424:	e13ffa17 	ldw	r4,-24(fp)
 d037428:	d0378bc0 	call	d0378bc <tcp_disconnect>
      break;
 d03742c:	0000ce06 	br	d037768 <tcp_usrreq+0x6e4>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 d037430:	e0bffe17 	ldw	r2,-8(fp)
 d037434:	10800317 	ldw	r2,12(r2)
 d037438:	e0bff715 	stw	r2,-36(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 d03743c:	e0bffc17 	ldw	r2,-16(fp)
 d037440:	10800517 	ldw	r2,20(r2)
 d037444:	10800098 	cmpnei	r2,r2,2
 d037448:	10000e1e 	bne	r2,zero,d037484 <tcp_usrreq+0x400>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 d03744c:	e0fffe17 	ldw	r3,-8(fp)
 d037450:	00800404 	movi	r2,16
 d037454:	18800215 	stw	r2,8(r3)
            sin->sin_family = AF_INET;
 d037458:	e0fff717 	ldw	r3,-36(fp)
 d03745c:	00800084 	movi	r2,2
 d037460:	1880000d 	sth	r2,0(r3)
            sin->sin_port = inp->inp_fport;
 d037464:	e0bffb17 	ldw	r2,-20(fp)
 d037468:	10c0070b 	ldhu	r3,28(r2)
 d03746c:	e0bff717 	ldw	r2,-36(fp)
 d037470:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 d037474:	e0bffb17 	ldw	r2,-20(fp)
 d037478:	10c00317 	ldw	r3,12(r2)
 d03747c:	e0bff717 	ldw	r2,-36(fp)
 d037480:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 d037484:	e0bffc17 	ldw	r2,-16(fp)
 d037488:	10800517 	ldw	r2,20(r2)
 d03748c:	108000a0 	cmpeqi	r2,r2,2
 d037490:	10000a1e 	bne	r2,zero,d0374bc <tcp_usrreq+0x438>
 d037494:	e0bffc17 	ldw	r2,-16(fp)
 d037498:	10800517 	ldw	r2,20(r2)
 d03749c:	108000e0 	cmpeqi	r2,r2,3
 d0374a0:	1000061e 	bne	r2,zero,d0374bc <tcp_usrreq+0x438>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 d0374a4:	e0bffc17 	ldw	r2,-16(fp)
 d0374a8:	11400517 	ldw	r5,20(r2)
 d0374ac:	01034174 	movhi	r4,3333
 d0374b0:	213e2b04 	addi	r4,r4,-1876
 d0374b4:	d0029980 	call	d002998 <printf>
            dtrap();
 d0374b8:	d0293e80 	call	d0293e8 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 d0374bc:	008341b4 	movhi	r2,3334
 d0374c0:	10b3e704 	addi	r2,r2,-12388
 d0374c4:	10800517 	ldw	r2,20(r2)
 d0374c8:	10c00044 	addi	r3,r2,1
 d0374cc:	008341b4 	movhi	r2,3334
 d0374d0:	10b3e704 	addi	r2,r2,-12388
 d0374d4:	10c00515 	stw	r3,20(r2)
         break;
 d0374d8:	0000a306 	br	d037768 <tcp_usrreq+0x6e4>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 d0374dc:	e13ffc17 	ldw	r4,-16(fp)
 d0374e0:	d0306280 	call	d030628 <socantsendmore>
      tp = tcp_usrclosed(tp);
 d0374e4:	e13ffa17 	ldw	r4,-24(fp)
 d0374e8:	d0379900 	call	d037990 <tcp_usrclosed>
 d0374ec:	e0bffa15 	stw	r2,-24(fp)
      if (tp)
 d0374f0:	e0bffa17 	ldw	r2,-24(fp)
 d0374f4:	1005003a 	cmpeq	r2,r2,zero
 d0374f8:	10009b1e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
         error = tcp_output(tp);
 d0374fc:	e13ffa17 	ldw	r4,-24(fp)
 d037500:	d034ba40 	call	d034ba4 <tcp_output>
 d037504:	e0bff915 	stw	r2,-28(fp)
      break;
 d037508:	00009706 	br	d037768 <tcp_usrreq+0x6e4>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 d03750c:	e13ffa17 	ldw	r4,-24(fp)
 d037510:	d034ba40 	call	d034ba4 <tcp_output>
      break;
 d037514:	00009406 	br	d037768 <tcp_usrreq+0x6e4>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 d037518:	e0bffc17 	ldw	r2,-16(fp)
 d03751c:	10800117 	ldw	r2,4(r2)
 d037520:	1004c03a 	cmpne	r2,r2,zero
 d037524:	1000031e 	bne	r2,zero,d037534 <tcp_usrreq+0x4b0>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 d037528:	00800804 	movi	r2,32
 d03752c:	e0bff915 	stw	r2,-28(fp)
         break;
 d037530:	00008d06 	br	d037768 <tcp_usrreq+0x6e4>
      }
      sbappend(&so->so_snd, m);
 d037534:	e0bffc17 	ldw	r2,-16(fp)
 d037538:	11001204 	addi	r4,r2,72
 d03753c:	e17ffd17 	ldw	r5,-12(fp)
 d037540:	d03092c0 	call	d03092c <sbappend>
      error = tcp_output(tp);
 d037544:	e13ffa17 	ldw	r4,-24(fp)
 d037548:	d034ba40 	call	d034ba4 <tcp_output>
 d03754c:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 d037550:	e0bff917 	ldw	r2,-28(fp)
 d037554:	10801a58 	cmpnei	r2,r2,105
 d037558:	1000831e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 d03755c:	e0bffc17 	ldw	r2,-16(fp)
 d037560:	11001204 	addi	r4,r2,72
 d037564:	e17ffd17 	ldw	r5,-12(fp)
 d037568:	d0311040 	call	d031104 <sbdropend>
      break;
 d03756c:	00007e06 	br	d037768 <tcp_usrreq+0x6e4>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 d037570:	e13ffa17 	ldw	r4,-24(fp)
 d037574:	01401c44 	movi	r5,113
 d037578:	d0366140 	call	d036614 <tcp_drop>
      break;
 d03757c:	00007a06 	br	d037768 <tcp_usrreq+0x6e4>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 d037580:	d0293e80 	call	d0293e8 <dtrap>
      return (0);
 d037584:	e03fff15 	stw	zero,-4(fp)
 d037588:	00007906 	br	d037770 <tcp_usrreq+0x6ec>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 d03758c:	e0bffc17 	ldw	r2,-16(fp)
 d037590:	10801a17 	ldw	r2,104(r2)
 d037594:	1004c03a 	cmpne	r2,r2,zero
 d037598:	1000061e 	bne	r2,zero,d0375b4 <tcp_usrreq+0x530>
 d03759c:	e0bffc17 	ldw	r2,-16(fp)
 d0375a0:	1080088b 	ldhu	r2,34(r2)
 d0375a4:	10bfffcc 	andi	r2,r2,65535
 d0375a8:	1080100c 	andi	r2,r2,64
 d0375ac:	1005003a 	cmpeq	r2,r2,zero
 d0375b0:	10000b1e 	bne	r2,zero,d0375e0 <tcp_usrreq+0x55c>
 d0375b4:	e0bffc17 	ldw	r2,-16(fp)
 d0375b8:	10800417 	ldw	r2,16(r2)
 d0375bc:	1080400c 	andi	r2,r2,256
 d0375c0:	1004c03a 	cmpne	r2,r2,zero
 d0375c4:	1000061e 	bne	r2,zero,d0375e0 <tcp_usrreq+0x55c>
 d0375c8:	e0bffa17 	ldw	r2,-24(fp)
 d0375cc:	10802403 	ldbu	r2,144(r2)
 d0375d0:	10803fcc 	andi	r2,r2,255
 d0375d4:	1080008c 	andi	r2,r2,2
 d0375d8:	1005003a 	cmpeq	r2,r2,zero
 d0375dc:	1000031e 	bne	r2,zero,d0375ec <tcp_usrreq+0x568>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 d0375e0:	00800584 	movi	r2,22
 d0375e4:	e0bff915 	stw	r2,-28(fp)
         break;
 d0375e8:	00005f06 	br	d037768 <tcp_usrreq+0x6e4>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 d0375ec:	e0bffa17 	ldw	r2,-24(fp)
 d0375f0:	10802403 	ldbu	r2,144(r2)
 d0375f4:	10803fcc 	andi	r2,r2,255
 d0375f8:	1080004c 	andi	r2,r2,1
 d0375fc:	1004c03a 	cmpne	r2,r2,zero
 d037600:	1000031e 	bne	r2,zero,d037610 <tcp_usrreq+0x58c>
      {
         error = EWOULDBLOCK;
 d037604:	008002c4 	movi	r2,11
 d037608:	e0bff915 	stw	r2,-28(fp)
         break;
 d03760c:	00005606 	br	d037768 <tcp_usrreq+0x6e4>
      }
      m->m_len = 1;
 d037610:	e0fffd17 	ldw	r3,-12(fp)
 d037614:	00800044 	movi	r2,1
 d037618:	18800215 	stw	r2,8(r3)
      *mtod(m, char *) = tp->t_iobc;
 d03761c:	e0bffd17 	ldw	r2,-12(fp)
 d037620:	10c00317 	ldw	r3,12(r2)
 d037624:	e0bffa17 	ldw	r2,-24(fp)
 d037628:	10802443 	ldbu	r2,145(r2)
 d03762c:	18800005 	stb	r2,0(r3)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 d037630:	e0bffe17 	ldw	r2,-8(fp)
 d037634:	1080008c 	andi	r2,r2,2
 d037638:	1004c03a 	cmpne	r2,r2,zero
 d03763c:	10004a1e 	bne	r2,zero,d037768 <tcp_usrreq+0x6e4>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 d037640:	e0bffa17 	ldw	r2,-24(fp)
 d037644:	10802403 	ldbu	r2,144(r2)
 d037648:	108000dc 	xori	r2,r2,3
 d03764c:	1007883a 	mov	r3,r2
 d037650:	e0bffa17 	ldw	r2,-24(fp)
 d037654:	10c02405 	stb	r3,144(r2)
      break;
 d037658:	00004306 	br	d037768 <tcp_usrreq+0x6e4>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 d03765c:	e0bffc17 	ldw	r2,-16(fp)
 d037660:	10800117 	ldw	r2,4(r2)
 d037664:	1004c03a 	cmpne	r2,r2,zero
 d037668:	1000031e 	bne	r2,zero,d037678 <tcp_usrreq+0x5f4>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 d03766c:	00800804 	movi	r2,32
 d037670:	e0bff915 	stw	r2,-28(fp)
         break;
 d037674:	00003c06 	br	d037768 <tcp_usrreq+0x6e4>
      }
      if (sbspace(&so->so_snd) == 0) 
 d037678:	e0bffc17 	ldw	r2,-16(fp)
 d03767c:	10801317 	ldw	r2,76(r2)
 d037680:	1007883a 	mov	r3,r2
 d037684:	e0bffc17 	ldw	r2,-16(fp)
 d037688:	10801217 	ldw	r2,72(r2)
 d03768c:	1885c83a 	sub	r2,r3,r2
 d037690:	1004803a 	cmplt	r2,r2,zero
 d037694:	1000051e 	bne	r2,zero,d0376ac <tcp_usrreq+0x628>
 d037698:	e0bffc17 	ldw	r2,-16(fp)
 d03769c:	10c01317 	ldw	r3,76(r2)
 d0376a0:	e0bffc17 	ldw	r2,-16(fp)
 d0376a4:	10801217 	ldw	r2,72(r2)
 d0376a8:	1880051e 	bne	r3,r2,d0376c0 <tcp_usrreq+0x63c>
      {
         m_freem(m);
 d0376ac:	e13ffd17 	ldw	r4,-12(fp)
 d0376b0:	d02a4c40 	call	d02a4c4 <m_freem>
         error = ENOBUFS;
 d0376b4:	00801a44 	movi	r2,105
 d0376b8:	e0bff915 	stw	r2,-28(fp)
         break;
 d0376bc:	00002a06 	br	d037768 <tcp_usrreq+0x6e4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 d0376c0:	e0bffc17 	ldw	r2,-16(fp)
 d0376c4:	11001204 	addi	r4,r2,72
 d0376c8:	e17ffd17 	ldw	r5,-12(fp)
 d0376cc:	d03092c0 	call	d03092c <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 d0376d0:	e0bffa17 	ldw	r2,-24(fp)
 d0376d4:	10c00e17 	ldw	r3,56(r2)
 d0376d8:	e0bffc17 	ldw	r2,-16(fp)
 d0376dc:	10801217 	ldw	r2,72(r2)
 d0376e0:	1887883a 	add	r3,r3,r2
 d0376e4:	e0bffa17 	ldw	r2,-24(fp)
 d0376e8:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 d0376ec:	e0fffa17 	ldw	r3,-24(fp)
 d0376f0:	00800044 	movi	r2,1
 d0376f4:	18800a85 	stb	r2,42(r3)
      error = tcp_output(tp);
 d0376f8:	e13ffa17 	ldw	r4,-24(fp)
 d0376fc:	d034ba40 	call	d034ba4 <tcp_output>
 d037700:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 d037704:	e0bff917 	ldw	r2,-28(fp)
 d037708:	10801a58 	cmpnei	r2,r2,105
 d03770c:	1000041e 	bne	r2,zero,d037720 <tcp_usrreq+0x69c>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 d037710:	e0bffc17 	ldw	r2,-16(fp)
 d037714:	11001204 	addi	r4,r2,72
 d037718:	e17ffd17 	ldw	r5,-12(fp)
 d03771c:	d0311040 	call	d031104 <sbdropend>
      tp->t_force = 0;
 d037720:	e0bffa17 	ldw	r2,-24(fp)
 d037724:	10000a85 	stb	zero,42(r2)
      break;
 d037728:	00000f06 	br	d037768 <tcp_usrreq+0x6e4>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 d03772c:	e13ffb17 	ldw	r4,-20(fp)
 d037730:	e17ffe17 	ldw	r5,-8(fp)
 d037734:	d0468400 	call	d046840 <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 d037738:	00000b06 	br	d037768 <tcp_usrreq+0x6e4>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 d03773c:	e13ffb17 	ldw	r4,-20(fp)
 d037740:	e17ffe17 	ldw	r5,-8(fp)
 d037744:	d0468bc0 	call	d0468bc <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 d037748:	00000706 	br	d037768 <tcp_usrreq+0x6e4>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 d03774c:	e17ffe17 	ldw	r5,-8(fp)
 d037750:	e13ffa17 	ldw	r4,-24(fp)
 d037754:	d036be80 	call	d036be8 <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 d037758:	00000306 	br	d037768 <tcp_usrreq+0x6e4>

      default:
      panic("tcp_usrreq");
 d03775c:	01034174 	movhi	r4,3333
 d037760:	213e3304 	addi	r4,r4,-1844
 d037764:	d0246440 	call	d024644 <panic>
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 d037768:	e0bff917 	ldw	r2,-28(fp)
 d03776c:	e0bfff15 	stw	r2,-4(fp)
 d037770:	e0bfff17 	ldw	r2,-4(fp)
}
 d037774:	e037883a 	mov	sp,fp
 d037778:	dfc00117 	ldw	ra,4(sp)
 d03777c:	df000017 	ldw	fp,0(sp)
 d037780:	dec00204 	addi	sp,sp,8
 d037784:	f800283a 	ret

0d037788 <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 d037788:	defff804 	addi	sp,sp,-32
 d03778c:	dfc00715 	stw	ra,28(sp)
 d037790:	df000615 	stw	fp,24(sp)
 d037794:	df000604 	addi	fp,sp,24
 d037798:	e13ffe15 	stw	r4,-8(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 d03779c:	e0bffe17 	ldw	r2,-8(fp)
 d0377a0:	10801317 	ldw	r2,76(r2)
 d0377a4:	1005003a 	cmpeq	r2,r2,zero
 d0377a8:	1000041e 	bne	r2,zero,d0377bc <tcp_attach+0x34>
 d0377ac:	e0bffe17 	ldw	r2,-8(fp)
 d0377b0:	10800b17 	ldw	r2,44(r2)
 d0377b4:	1004c03a 	cmpne	r2,r2,zero
 d0377b8:	10000b1e 	bne	r2,zero,d0377e8 <tcp_attach+0x60>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 d0377bc:	d1604017 	ldw	r5,-32512(gp)
 d0377c0:	d1a04117 	ldw	r6,-32508(gp)
 d0377c4:	e13ffe17 	ldw	r4,-8(fp)
 d0377c8:	d0308040 	call	d030804 <soreserve>
 d0377cc:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 d0377d0:	e0bffb17 	ldw	r2,-20(fp)
 d0377d4:	1005003a 	cmpeq	r2,r2,zero
 d0377d8:	1000031e 	bne	r2,zero,d0377e8 <tcp_attach+0x60>
         return (error);
 d0377dc:	e0bffb17 	ldw	r2,-20(fp)
 d0377e0:	e0bfff15 	stw	r2,-4(fp)
 d0377e4:	00002f06 	br	d0378a4 <tcp_attach+0x11c>
   }
   error = in_pcballoc(so, &tcb);
 d0377e8:	e13ffe17 	ldw	r4,-8(fp)
 d0377ec:	014341b4 	movhi	r5,3334
 d0377f0:	29740a04 	addi	r5,r5,-12248
 d0377f4:	d0462940 	call	d046294 <in_pcballoc>
 d0377f8:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 d0377fc:	e0bffb17 	ldw	r2,-20(fp)
 d037800:	1005003a 	cmpeq	r2,r2,zero
 d037804:	1000031e 	bne	r2,zero,d037814 <tcp_attach+0x8c>
      return (error);
 d037808:	e0bffb17 	ldw	r2,-20(fp)
 d03780c:	e0bfff15 	stw	r2,-4(fp)
 d037810:	00002406 	br	d0378a4 <tcp_attach+0x11c>
   inp = sotoinpcb(so);
 d037814:	e0bffe17 	ldw	r2,-8(fp)
 d037818:	10800117 	ldw	r2,4(r2)
 d03781c:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 d037820:	e13ffc17 	ldw	r4,-16(fp)
 d037824:	d0364fc0 	call	d0364fc <tcp_newtcpcb>
 d037828:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 d03782c:	e0bffd17 	ldw	r2,-12(fp)
 d037830:	1004c03a 	cmpne	r2,r2,zero
 d037834:	1000181e 	bne	r2,zero,d037898 <tcp_attach+0x110>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 d037838:	e0bffe17 	ldw	r2,-8(fp)
 d03783c:	1080088b 	ldhu	r2,34(r2)
 d037840:	10bfffcc 	andi	r2,r2,65535
 d037844:	1080004c 	andi	r2,r2,1
 d037848:	e0bffa15 	stw	r2,-24(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 d03784c:	e0bffe17 	ldw	r2,-8(fp)
 d037850:	10c0088b 	ldhu	r3,34(r2)
 d037854:	00bfff84 	movi	r2,-2
 d037858:	1884703a 	and	r2,r3,r2
 d03785c:	1007883a 	mov	r3,r2
 d037860:	e0bffe17 	ldw	r2,-8(fp)
 d037864:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 d037868:	e13ffc17 	ldw	r4,-16(fp)
 d03786c:	d0463280 	call	d046328 <in_pcbdetach>
      so->so_state |= nofd;
 d037870:	e0bffe17 	ldw	r2,-8(fp)
 d037874:	10c0088b 	ldhu	r3,34(r2)
 d037878:	e0bffa17 	ldw	r2,-24(fp)
 d03787c:	1884b03a 	or	r2,r3,r2
 d037880:	1007883a 	mov	r3,r2
 d037884:	e0bffe17 	ldw	r2,-8(fp)
 d037888:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 d03788c:	00801a44 	movi	r2,105
 d037890:	e0bfff15 	stw	r2,-4(fp)
 d037894:	00000306 	br	d0378a4 <tcp_attach+0x11c>
   }
   tp->t_state = TCPS_CLOSED;
 d037898:	e0bffd17 	ldw	r2,-12(fp)
 d03789c:	10000215 	stw	zero,8(r2)
   return (0);
 d0378a0:	e03fff15 	stw	zero,-4(fp)
 d0378a4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0378a8:	e037883a 	mov	sp,fp
 d0378ac:	dfc00117 	ldw	ra,4(sp)
 d0378b0:	df000017 	ldw	fp,0(sp)
 d0378b4:	dec00204 	addi	sp,sp,8
 d0378b8:	f800283a 	ret

0d0378bc <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 d0378bc:	defffc04 	addi	sp,sp,-16
 d0378c0:	dfc00315 	stw	ra,12(sp)
 d0378c4:	df000215 	stw	fp,8(sp)
 d0378c8:	df000204 	addi	fp,sp,8
 d0378cc:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 d0378d0:	e0bfff17 	ldw	r2,-4(fp)
 d0378d4:	10800d17 	ldw	r2,52(r2)
 d0378d8:	10800817 	ldw	r2,32(r2)
 d0378dc:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 d0378e0:	e0bfff17 	ldw	r2,-4(fp)
 d0378e4:	10800217 	ldw	r2,8(r2)
 d0378e8:	10800108 	cmpgei	r2,r2,4
 d0378ec:	1000041e 	bne	r2,zero,d037900 <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 d0378f0:	e13fff17 	ldw	r4,-4(fp)
 d0378f4:	d0366c00 	call	d0366c0 <tcp_close>
 d0378f8:	e0bfff15 	stw	r2,-4(fp)
 d0378fc:	00001e06 	br	d037978 <tcp_disconnect+0xbc>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 d037900:	e0bffe17 	ldw	r2,-8(fp)
 d037904:	10800417 	ldw	r2,16(r2)
 d037908:	1080200c 	andi	r2,r2,128
 d03790c:	1005003a 	cmpeq	r2,r2,zero
 d037910:	10000c1e 	bne	r2,zero,d037944 <tcp_disconnect+0x88>
 d037914:	e0bffe17 	ldw	r2,-8(fp)
 d037918:	1080080b 	ldhu	r2,32(r2)
 d03791c:	10bfffcc 	andi	r2,r2,65535
 d037920:	10a0001c 	xori	r2,r2,32768
 d037924:	10a00004 	addi	r2,r2,-32768
 d037928:	1004c03a 	cmpne	r2,r2,zero
 d03792c:	1000051e 	bne	r2,zero,d037944 <tcp_disconnect+0x88>
      tp = tcp_drop(tp, 0);
 d037930:	e13fff17 	ldw	r4,-4(fp)
 d037934:	000b883a 	mov	r5,zero
 d037938:	d0366140 	call	d036614 <tcp_drop>
 d03793c:	e0bfff15 	stw	r2,-4(fp)
{
   struct socket *   so =  tp->t_inpcb->inp_socket;

   if (tp->t_state < TCPS_ESTABLISHED)
      tp = tcp_close(tp);
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 d037940:	00000d06 	br	d037978 <tcp_disconnect+0xbc>
      tp = tcp_drop(tp, 0);
   else 
   {
      soisdisconnecting(so);
 d037944:	e13ffe17 	ldw	r4,-8(fp)
 d037948:	d0300f80 	call	d0300f8 <soisdisconnecting>
      sbflush(&so->so_rcv);
 d03794c:	e0bffe17 	ldw	r2,-8(fp)
 d037950:	11000a04 	addi	r4,r2,40
 d037954:	d030ea40 	call	d030ea4 <sbflush>
      tp = tcp_usrclosed(tp);
 d037958:	e13fff17 	ldw	r4,-4(fp)
 d03795c:	d0379900 	call	d037990 <tcp_usrclosed>
 d037960:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 d037964:	e0bfff17 	ldw	r2,-4(fp)
 d037968:	1005003a 	cmpeq	r2,r2,zero
 d03796c:	1000021e 	bne	r2,zero,d037978 <tcp_disconnect+0xbc>
         (void) tcp_output(tp);
 d037970:	e13fff17 	ldw	r4,-4(fp)
 d037974:	d034ba40 	call	d034ba4 <tcp_output>
   }
   return (tp);
 d037978:	e0bfff17 	ldw	r2,-4(fp)
}
 d03797c:	e037883a 	mov	sp,fp
 d037980:	dfc00117 	ldw	ra,4(sp)
 d037984:	df000017 	ldw	fp,0(sp)
 d037988:	dec00204 	addi	sp,sp,8
 d03798c:	f800283a 	ret

0d037990 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 d037990:	defffc04 	addi	sp,sp,-16
 d037994:	dfc00315 	stw	ra,12(sp)
 d037998:	df000215 	stw	fp,8(sp)
 d03799c:	df000204 	addi	fp,sp,8
 d0379a0:	e13ffe15 	stw	r4,-8(fp)

   switch (tp->t_state) 
 d0379a4:	e0bffe17 	ldw	r2,-8(fp)
 d0379a8:	10800217 	ldw	r2,8(r2)
 d0379ac:	e0bfff15 	stw	r2,-4(fp)
 d0379b0:	e0ffff17 	ldw	r3,-4(fp)
 d0379b4:	188001a8 	cmpgeui	r2,r3,6
 d0379b8:	10001c1e 	bne	r2,zero,d037a2c <tcp_usrclosed+0x9c>
 d0379bc:	e13fff17 	ldw	r4,-4(fp)
 d0379c0:	e13fff17 	ldw	r4,-4(fp)
 d0379c4:	2105883a 	add	r2,r4,r4
 d0379c8:	1087883a 	add	r3,r2,r2
 d0379cc:	008340f4 	movhi	r2,3331
 d0379d0:	109e7804 	addi	r2,r2,31200
 d0379d4:	1885883a 	add	r2,r3,r2
 d0379d8:	10800017 	ldw	r2,0(r2)
 d0379dc:	1000683a 	jmp	r2
 d0379e0:	0d0379f8 	rdprs	r20,at,3559
 d0379e4:	0d0379f8 	rdprs	r20,at,3559
 d0379e8:	0d0379f8 	rdprs	r20,at,3559
 d0379ec:	0d037a10 	cmplti	r20,at,3560
 d0379f0:	0d037a10 	cmplti	r20,at,3560
 d0379f4:	0d037a20 	cmpeqi	r20,at,3560
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 d0379f8:	e0bffe17 	ldw	r2,-8(fp)
 d0379fc:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 d037a00:	e13ffe17 	ldw	r4,-8(fp)
 d037a04:	d0366c00 	call	d0366c0 <tcp_close>
 d037a08:	e0bffe15 	stw	r2,-8(fp)
      break;
 d037a0c:	00000706 	br	d037a2c <tcp_usrclosed+0x9c>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 d037a10:	e0fffe17 	ldw	r3,-8(fp)
 d037a14:	00800184 	movi	r2,6
 d037a18:	18800215 	stw	r2,8(r3)
      break;
 d037a1c:	00000306 	br	d037a2c <tcp_usrclosed+0x9c>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 d037a20:	e0fffe17 	ldw	r3,-8(fp)
 d037a24:	00800204 	movi	r2,8
 d037a28:	18800215 	stw	r2,8(r3)
      break;
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 d037a2c:	e0bffe17 	ldw	r2,-8(fp)
 d037a30:	1005003a 	cmpeq	r2,r2,zero
 d037a34:	1000081e 	bne	r2,zero,d037a58 <tcp_usrclosed+0xc8>
 d037a38:	e0bffe17 	ldw	r2,-8(fp)
 d037a3c:	10800217 	ldw	r2,8(r2)
 d037a40:	10800250 	cmplti	r2,r2,9
 d037a44:	1000041e 	bne	r2,zero,d037a58 <tcp_usrclosed+0xc8>
      soisdisconnected(tp->t_inpcb->inp_socket);
 d037a48:	e0bffe17 	ldw	r2,-8(fp)
 d037a4c:	10800d17 	ldw	r2,52(r2)
 d037a50:	11000817 	ldw	r4,32(r2)
 d037a54:	d0301840 	call	d030184 <soisdisconnected>
   return (tp);
 d037a58:	e0bffe17 	ldw	r2,-8(fp)
}
 d037a5c:	e037883a 	mov	sp,fp
 d037a60:	dfc00117 	ldw	ra,4(sp)
 d037a64:	df000017 	ldw	fp,0(sp)
 d037a68:	dec00204 	addi	sp,sp,8
 d037a6c:	f800283a 	ret

0d037a70 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 d037a70:	defffc04 	addi	sp,sp,-16
 d037a74:	dfc00315 	stw	ra,12(sp)
 d037a78:	df000215 	stw	fp,8(sp)
 d037a7c:	df000204 	addi	fp,sp,8
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 d037a80:	d02abe80 	call	d02abe8 <nptcp_init>
 d037a84:	e0bffe15 	stw	r2,-8(fp)
   if (e)
 d037a88:	e0bffe17 	ldw	r2,-8(fp)
 d037a8c:	1005003a 	cmpeq	r2,r2,zero
 d037a90:	1000031e 	bne	r2,zero,d037aa0 <tcpinit+0x30>
      return e;
 d037a94:	e0bffe17 	ldw	r2,-8(fp)
 d037a98:	e0bfff15 	stw	r2,-4(fp)
 d037a9c:	00000106 	br	d037aa4 <tcpinit+0x34>

   return 0;   /* good return */
 d037aa0:	e03fff15 	stw	zero,-4(fp)
 d037aa4:	e0bfff17 	ldw	r2,-4(fp)
}
 d037aa8:	e037883a 	mov	sp,fp
 d037aac:	dfc00117 	ldw	ra,4(sp)
 d037ab0:	df000017 	ldw	fp,0(sp)
 d037ab4:	dec00204 	addi	sp,sp,8
 d037ab8:	f800283a 	ret

0d037abc <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 d037abc:	defffc04 	addi	sp,sp,-16
 d037ac0:	df000315 	stw	fp,12(sp)
 d037ac4:	df000304 	addi	fp,sp,12
 d037ac8:	e13ffe15 	stw	r4,-8(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d037acc:	00834174 	movhi	r2,3333
 d037ad0:	108abd04 	addi	r2,r2,10996
 d037ad4:	10800017 	ldw	r2,0(r2)
 d037ad8:	e0bffd15 	stw	r2,-12(fp)
 d037adc:	00000a06 	br	d037b08 <udp_lookup+0x4c>
      if (tmp->u_data == (void*)so)
 d037ae0:	e0bffd17 	ldw	r2,-12(fp)
 d037ae4:	10c00617 	ldw	r3,24(r2)
 d037ae8:	e0bffe17 	ldw	r2,-8(fp)
 d037aec:	1880031e 	bne	r3,r2,d037afc <udp_lookup+0x40>
      return (tmp);
 d037af0:	e0bffd17 	ldw	r2,-12(fp)
 d037af4:	e0bfff15 	stw	r2,-4(fp)
 d037af8:	00000706 	br	d037b18 <udp_lookup+0x5c>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d037afc:	e0bffd17 	ldw	r2,-12(fp)
 d037b00:	10800017 	ldw	r2,0(r2)
 d037b04:	e0bffd15 	stw	r2,-12(fp)
 d037b08:	e0bffd17 	ldw	r2,-12(fp)
 d037b0c:	1004c03a 	cmpne	r2,r2,zero
 d037b10:	103ff31e 	bne	r2,zero,d037ae0 <udp_lookup+0x24>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 d037b14:	e03fff15 	stw	zero,-4(fp)
 d037b18:	e0bfff17 	ldw	r2,-4(fp)
}
 d037b1c:	e037883a 	mov	sp,fp
 d037b20:	df000017 	ldw	fp,0(sp)
 d037b24:	dec00104 	addi	sp,sp,4
 d037b28:	f800283a 	ret

0d037b2c <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 d037b2c:	defff404 	addi	sp,sp,-48
 d037b30:	dfc00b15 	stw	ra,44(sp)
 d037b34:	df000a15 	stw	fp,40(sp)
 d037b38:	df000a04 	addi	fp,sp,40
 d037b3c:	e13ffd15 	stw	r4,-12(fp)
 d037b40:	e17ffe15 	stw	r5,-8(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 d037b44:	e0bffe17 	ldw	r2,-8(fp)
 d037b48:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 d037b4c:	0009883a 	mov	r4,zero
 d037b50:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 d037b54:	e0bff717 	ldw	r2,-36(fp)
 d037b58:	10c00a17 	ldw	r3,40(r2)
 d037b5c:	e0bffd17 	ldw	r2,-12(fp)
 d037b60:	10800417 	ldw	r2,16(r2)
 d037b64:	1887883a 	add	r3,r3,r2
 d037b68:	e0bff717 	ldw	r2,-36(fp)
 d037b6c:	10800b17 	ldw	r2,44(r2)
 d037b70:	18800536 	bltu	r3,r2,d037b88 <udp_soinput+0x5c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d037b74:	0009883a 	mov	r4,zero
 d037b78:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d037b7c:	00801a44 	movi	r2,105
 d037b80:	e0bfff15 	stw	r2,-4(fp)
 d037b84:	00005106 	br	d037ccc <udp_soinput+0x1a0>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 d037b88:	01000044 	movi	r4,1
 d037b8c:	000b883a 	mov	r5,zero
 d037b90:	d02a1e80 	call	d02a1e8 <m_getnbuf>
 d037b94:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 d037b98:	e0bff817 	ldw	r2,-32(fp)
 d037b9c:	1004c03a 	cmpne	r2,r2,zero
 d037ba0:	1000051e 	bne	r2,zero,d037bb8 <udp_soinput+0x8c>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d037ba4:	0009883a 	mov	r4,zero
 d037ba8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d037bac:	00801a44 	movi	r2,105
 d037bb0:	e0bfff15 	stw	r2,-4(fp)
 d037bb4:	00004506 	br	d037ccc <udp_soinput+0x1a0>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 d037bb8:	e0fff817 	ldw	r3,-32(fp)
 d037bbc:	e0bffd17 	ldw	r2,-12(fp)
 d037bc0:	18800115 	stw	r2,4(r3)
   m_in->m_data = pkt->nb_prot;
 d037bc4:	e0bffd17 	ldw	r2,-12(fp)
 d037bc8:	10c00317 	ldw	r3,12(r2)
 d037bcc:	e0bff817 	ldw	r2,-32(fp)
 d037bd0:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 d037bd4:	e0bffd17 	ldw	r2,-12(fp)
 d037bd8:	10c00417 	ldw	r3,16(r2)
 d037bdc:	e0bff817 	ldw	r2,-32(fp)
 d037be0:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 d037be4:	e0bffd17 	ldw	r2,-12(fp)
 d037be8:	10c00117 	ldw	r3,4(r2)
 d037bec:	e0bff817 	ldw	r2,-32(fp)
 d037bf0:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 d037bf4:	e0bffd17 	ldw	r2,-12(fp)
 d037bf8:	10c00217 	ldw	r3,8(r2)
 d037bfc:	e0bff817 	ldw	r2,-32(fp)
 d037c00:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 d037c04:	e0bffd17 	ldw	r2,-12(fp)
 d037c08:	10800717 	ldw	r2,28(r2)
 d037c0c:	e0bffa15 	stw	r2,-24(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 d037c10:	e0bffd17 	ldw	r2,-12(fp)
 d037c14:	10800317 	ldw	r2,12(r2)
 d037c18:	10bffe04 	addi	r2,r2,-8
 d037c1c:	e0bff615 	stw	r2,-40(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 d037c20:	e0bff617 	ldw	r2,-40(fp)
 d037c24:	1080000b 	ldhu	r2,0(r2)
 d037c28:	10bfffcc 	andi	r2,r2,65535
 d037c2c:	1004d23a 	srli	r2,r2,8
 d037c30:	10803fcc 	andi	r2,r2,255
 d037c34:	1009883a 	mov	r4,r2
 d037c38:	e0bff617 	ldw	r2,-40(fp)
 d037c3c:	1080000b 	ldhu	r2,0(r2)
 d037c40:	10bfffcc 	andi	r2,r2,65535
 d037c44:	1004923a 	slli	r2,r2,8
 d037c48:	1007883a 	mov	r3,r2
 d037c4c:	00bfc004 	movi	r2,-256
 d037c50:	1884703a 	and	r2,r3,r2
 d037c54:	2084b03a 	or	r2,r4,r2
 d037c58:	e0bff98d 	sth	r2,-26(fp)
   sin.sin_family = AF_INET;
 d037c5c:	00800084 	movi	r2,2
 d037c60:	e0bff90d 	sth	r2,-28(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 d037c64:	e0bff717 	ldw	r2,-36(fp)
 d037c68:	11000a04 	addi	r4,r2,40
 d037c6c:	e17ff904 	addi	r5,fp,-28
 d037c70:	e1bff817 	ldw	r6,-32(fp)
 d037c74:	d030ab40 	call	d030ab4 <sbappendaddr>
 d037c78:	1004c03a 	cmpne	r2,r2,zero
 d037c7c:	1000091e 	bne	r2,zero,d037ca4 <udp_soinput+0x178>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 d037c80:	e0bff817 	ldw	r2,-32(fp)
 d037c84:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 d037c88:	e13ff817 	ldw	r4,-32(fp)
 d037c8c:	d02a3900 	call	d02a390 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d037c90:	0009883a 	mov	r4,zero
 d037c94:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 d037c98:	00801a44 	movi	r2,105
 d037c9c:	e0bfff15 	stw	r2,-4(fp)
 d037ca0:	00000a06 	br	d037ccc <udp_soinput+0x1a0>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 d037ca4:	e0bff717 	ldw	r2,-36(fp)
 d037ca8:	11000a04 	addi	r4,r2,40
 d037cac:	d02515c0 	call	d02515c <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 d037cb0:	e0bff717 	ldw	r2,-36(fp)
 d037cb4:	11400a04 	addi	r5,r2,40
 d037cb8:	e13ff717 	ldw	r4,-36(fp)
 d037cbc:	d0307680 	call	d030768 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 d037cc0:	0009883a 	mov	r4,zero
 d037cc4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return 0;
 d037cc8:	e03fff15 	stw	zero,-4(fp)
 d037ccc:	e0bfff17 	ldw	r2,-4(fp)
}
 d037cd0:	e037883a 	mov	sp,fp
 d037cd4:	dfc00117 	ldw	ra,4(sp)
 d037cd8:	df000017 	ldw	fp,0(sp)
 d037cdc:	dec00204 	addi	sp,sp,8
 d037ce0:	f800283a 	ret

0d037ce4 <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 d037ce4:	defff704 	addi	sp,sp,-36
 d037ce8:	dfc00815 	stw	ra,32(sp)
 d037cec:	df000715 	stw	fp,28(sp)
 d037cf0:	df000704 	addi	fp,sp,28
 d037cf4:	e13ffc15 	stw	r4,-16(fp)
 d037cf8:	e17ffd15 	stw	r5,-12(fp)
 d037cfc:	e1bffe15 	stw	r6,-8(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 d037d00:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 d037d04:	e0bffc17 	ldw	r2,-16(fp)
 d037d08:	10800717 	ldw	r2,28(r2)
 d037d0c:	e0bffa15 	stw	r2,-24(fp)

   switch (req) 
 d037d10:	e0bffa17 	ldw	r2,-24(fp)
 d037d14:	10800468 	cmpgeui	r2,r2,17
 d037d18:	10008b1e 	bne	r2,zero,d037f48 <udp_usrreq+0x264>
 d037d1c:	e0bffa17 	ldw	r2,-24(fp)
 d037d20:	1085883a 	add	r2,r2,r2
 d037d24:	1087883a 	add	r3,r2,r2
 d037d28:	008340f4 	movhi	r2,3331
 d037d2c:	109f4f04 	addi	r2,r2,32060
 d037d30:	1885883a 	add	r2,r3,r2
 d037d34:	10800017 	ldw	r2,0(r2)
 d037d38:	1000683a 	jmp	r2
 d037d3c:	0d037d80 	call	d037d8 <OSCtxSw_SWITCH_PC+0xd03798>
 d037d40:	0d037e08 	cmpgei	r20,at,3576
 d037d44:	0d037e4c 	andi	r20,at,3577
 d037d48:	0d037f48 	cmpgei	r20,at,3581
 d037d4c:	0d037e4c 	andi	r20,at,3577
 d037d50:	0d037f48 	cmpgei	r20,at,3581
 d037d54:	0d037f3c 	xorhi	r20,at,3580
 d037d58:	0d037f48 	cmpgei	r20,at,3581
 d037d5c:	0d037f3c 	xorhi	r20,at,3580
 d037d60:	0d037e9c 	xori	r20,at,3578
 d037d64:	0d037f48 	cmpgei	r20,at,3581
 d037d68:	0d037f48 	cmpgei	r20,at,3581
 d037d6c:	0d037f48 	cmpgei	r20,at,3581
 d037d70:	0d037f48 	cmpgei	r20,at,3581
 d037d74:	0d037f48 	cmpgei	r20,at,3581
 d037d78:	0d037eec 	andhi	r20,at,3579
 d037d7c:	0d037eec 	andhi	r20,at,3579
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 d037d80:	d0436600 	call	d043660 <udp_maxalloc>
 d037d84:	1007883a 	mov	r3,r2
 d037d88:	e0bffc17 	ldw	r2,-16(fp)
 d037d8c:	10c01315 	stw	r3,76(r2)
 d037d90:	e0bffc17 	ldw	r2,-16(fp)
 d037d94:	10c01317 	ldw	r3,76(r2)
 d037d98:	e0bffc17 	ldw	r2,-16(fp)
 d037d9c:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 d037da0:	e0bffc17 	ldw	r2,-16(fp)
 d037da4:	10800517 	ldw	r2,20(r2)
 d037da8:	10800098 	cmpnei	r2,r2,2
 d037dac:	10000e1e 	bne	r2,zero,d037de8 <udp_usrreq+0x104>
        UNLOCK_NET_RESOURCE(NET_RESID);
 d037db0:	0009883a 	mov	r4,zero
 d037db4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 d037db8:	d0434d00 	call	d0434d0 <udp_socket>
 d037dbc:	11bfffcc 	andi	r6,r2,65535
 d037dc0:	e0bffc17 	ldw	r2,-16(fp)
 d037dc4:	d8800015 	stw	r2,0(sp)
 d037dc8:	0009883a 	mov	r4,zero
 d037dcc:	000b883a 	mov	r5,zero
 d037dd0:	01c340f4 	movhi	r7,3331
 d037dd4:	39decb04 	addi	r7,r7,31532
 d037dd8:	d028f380 	call	d028f38 <udp_open>
 d037ddc:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 d037de0:	0009883a 	mov	r4,zero
 d037de4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 d037de8:	e0bffb17 	ldw	r2,-20(fp)
 d037dec:	1004c03a 	cmpne	r2,r2,zero
 d037df0:	1000031e 	bne	r2,zero,d037e00 <udp_usrreq+0x11c>
         return(EINVAL);
 d037df4:	00800584 	movi	r2,22
 d037df8:	e0bfff15 	stw	r2,-4(fp)
 d037dfc:	00005406 	br	d037f50 <udp_usrreq+0x26c>
      return 0;
 d037e00:	e03fff15 	stw	zero,-4(fp)
 d037e04:	00005206 	br	d037f50 <udp_usrreq+0x26c>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 d037e08:	e13ffc17 	ldw	r4,-16(fp)
 d037e0c:	d037abc0 	call	d037abc <udp_lookup>
 d037e10:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 d037e14:	e0bffb17 	ldw	r2,-20(fp)
 d037e18:	1004c03a 	cmpne	r2,r2,zero
 d037e1c:	1000031e 	bne	r2,zero,d037e2c <udp_usrreq+0x148>
         return(EINVAL);
 d037e20:	00800584 	movi	r2,22
 d037e24:	e0bfff15 	stw	r2,-4(fp)
 d037e28:	00004906 	br	d037f50 <udp_usrreq+0x26c>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d037e2c:	0009883a 	mov	r4,zero
 d037e30:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 d037e34:	e13ffb17 	ldw	r4,-20(fp)
 d037e38:	d0291700 	call	d029170 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 d037e3c:	0009883a 	mov	r4,zero
 d037e40:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      return 0;
 d037e44:	e03fff15 	stw	zero,-4(fp)
 d037e48:	00004106 	br	d037f50 <udp_usrreq+0x26c>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 d037e4c:	e0bffe17 	ldw	r2,-8(fp)
 d037e50:	1004c03a 	cmpne	r2,r2,zero
 d037e54:	1000031e 	bne	r2,zero,d037e64 <udp_usrreq+0x180>
         return(EINVAL);
 d037e58:	00800584 	movi	r2,22
 d037e5c:	e0bfff15 	stw	r2,-4(fp)
 d037e60:	00003b06 	br	d037f50 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 d037e64:	e0bffc17 	ldw	r2,-16(fp)
 d037e68:	10800517 	ldw	r2,20(r2)
 d037e6c:	10800098 	cmpnei	r2,r2,2
 d037e70:	1000061e 	bne	r2,zero,d037e8c <udp_usrreq+0x1a8>
        return udp4_sockbind(so, nam, req );
 d037e74:	e13ffc17 	ldw	r4,-16(fp)
 d037e78:	e17ffe17 	ldw	r5,-8(fp)
 d037e7c:	e1bffa17 	ldw	r6,-24(fp)
 d037e80:	d037f680 	call	d037f68 <udp4_sockbind>
 d037e84:	e0bfff15 	stw	r2,-4(fp)
 d037e88:	00003106 	br	d037f50 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 d037e8c:	d0293e80 	call	d0293e8 <dtrap>
      return EINVAL;
 d037e90:	00800584 	movi	r2,22
 d037e94:	e0bfff15 	stw	r2,-4(fp)
 d037e98:	00002d06 	br	d037f50 <udp_usrreq+0x26c>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 d037e9c:	e0bffd17 	ldw	r2,-12(fp)
 d037ea0:	1004c03a 	cmpne	r2,r2,zero
 d037ea4:	1000031e 	bne	r2,zero,d037eb4 <udp_usrreq+0x1d0>
         return(EINVAL);
 d037ea8:	00800584 	movi	r2,22
 d037eac:	e0bfff15 	stw	r2,-4(fp)
 d037eb0:	00002706 	br	d037f50 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 d037eb4:	e0bffc17 	ldw	r2,-16(fp)
 d037eb8:	10800517 	ldw	r2,20(r2)
 d037ebc:	10800098 	cmpnei	r2,r2,2
 d037ec0:	1000061e 	bne	r2,zero,d037edc <udp_usrreq+0x1f8>
        return udp4_socksend(so, m, nam );
 d037ec4:	e13ffc17 	ldw	r4,-16(fp)
 d037ec8:	e17ffd17 	ldw	r5,-12(fp)
 d037ecc:	e1bffe17 	ldw	r6,-8(fp)
 d037ed0:	d0382a40 	call	d0382a4 <udp4_socksend>
 d037ed4:	e0bfff15 	stw	r2,-4(fp)
 d037ed8:	00001d06 	br	d037f50 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 d037edc:	d0293e80 	call	d0293e8 <dtrap>
      return EINVAL;
 d037ee0:	00800584 	movi	r2,22
 d037ee4:	e0bfff15 	stw	r2,-4(fp)
 d037ee8:	00001906 	br	d037f50 <udp_usrreq+0x26c>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 d037eec:	e0bffe17 	ldw	r2,-8(fp)
 d037ef0:	1004c03a 	cmpne	r2,r2,zero
 d037ef4:	1000031e 	bne	r2,zero,d037f04 <udp_usrreq+0x220>
         return(EINVAL);
 d037ef8:	00800584 	movi	r2,22
 d037efc:	e0bfff15 	stw	r2,-4(fp)
 d037f00:	00001306 	br	d037f50 <udp_usrreq+0x26c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 d037f04:	e0bffc17 	ldw	r2,-16(fp)
 d037f08:	10800517 	ldw	r2,20(r2)
 d037f0c:	10800098 	cmpnei	r2,r2,2
 d037f10:	1000061e 	bne	r2,zero,d037f2c <udp_usrreq+0x248>
        return udp4_sockaddr(so, nam, req );
 d037f14:	e13ffc17 	ldw	r4,-16(fp)
 d037f18:	e17ffe17 	ldw	r5,-8(fp)
 d037f1c:	e1bffa17 	ldw	r6,-24(fp)
 d037f20:	d0386800 	call	d038680 <udp4_sockaddr>
 d037f24:	e0bfff15 	stw	r2,-4(fp)
 d037f28:	00000906 	br	d037f50 <udp_usrreq+0x26c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 d037f2c:	d0293e80 	call	d0293e8 <dtrap>
      return EINVAL;
 d037f30:	00800584 	movi	r2,22
 d037f34:	e0bfff15 	stw	r2,-4(fp)
 d037f38:	00000506 	br	d037f50 <udp_usrreq+0x26c>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 d037f3c:	d0293e80 	call	d0293e8 <dtrap>
      return 0;
 d037f40:	e03fff15 	stw	zero,-4(fp)
 d037f44:	00000206 	br	d037f50 <udp_usrreq+0x26c>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 d037f48:	008017c4 	movi	r2,95
 d037f4c:	e0bfff15 	stw	r2,-4(fp)
 d037f50:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d037f54:	e037883a 	mov	sp,fp
 d037f58:	dfc00117 	ldw	ra,4(sp)
 d037f5c:	df000017 	ldw	fp,0(sp)
 d037f60:	dec00204 	addi	sp,sp,8
 d037f64:	f800283a 	ret

0d037f68 <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 d037f68:	defff304 	addi	sp,sp,-52
 d037f6c:	dfc00c15 	stw	ra,48(sp)
 d037f70:	df000b15 	stw	fp,44(sp)
 d037f74:	df000b04 	addi	fp,sp,44
 d037f78:	e13ffc15 	stw	r4,-16(fp)
 d037f7c:	e17ffd15 	stw	r5,-12(fp)
 d037f80:	e1bffe15 	stw	r6,-8(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 d037f84:	e0bffd17 	ldw	r2,-12(fp)
 d037f88:	10800317 	ldw	r2,12(r2)
 d037f8c:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 d037f90:	e0bffb17 	ldw	r2,-20(fp)
 d037f94:	1004c03a 	cmpne	r2,r2,zero
 d037f98:	1000031e 	bne	r2,zero,d037fa8 <udp4_sockbind+0x40>
    return(EINVAL);
 d037f9c:	00800584 	movi	r2,22
 d037fa0:	e0bfff15 	stw	r2,-4(fp)
 d037fa4:	0000b906 	br	d03828c <udp4_sockbind+0x324>
  if (nam->m_len != sizeof (*sin))
 d037fa8:	e0bffd17 	ldw	r2,-12(fp)
 d037fac:	10800217 	ldw	r2,8(r2)
 d037fb0:	10800420 	cmpeqi	r2,r2,16
 d037fb4:	1000031e 	bne	r2,zero,d037fc4 <udp4_sockbind+0x5c>
    return(EINVAL);
 d037fb8:	00800584 	movi	r2,22
 d037fbc:	e0bfff15 	stw	r2,-4(fp)
 d037fc0:	0000b206 	br	d03828c <udp4_sockbind+0x324>
  udpconn = udp_lookup(so);
 d037fc4:	e13ffc17 	ldw	r4,-16(fp)
 d037fc8:	d037abc0 	call	d037abc <udp_lookup>
 d037fcc:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 d037fd0:	e0bffa17 	ldw	r2,-24(fp)
 d037fd4:	1004c03a 	cmpne	r2,r2,zero
 d037fd8:	1000031e 	bne	r2,zero,d037fe8 <udp4_sockbind+0x80>
     return(EINVAL);
 d037fdc:	00800584 	movi	r2,22
 d037fe0:	e0bfff15 	stw	r2,-4(fp)
 d037fe4:	0000a906 	br	d03828c <udp4_sockbind+0x324>
  if (req == PRU_BIND)
 d037fe8:	e0bffe17 	ldw	r2,-8(fp)
 d037fec:	10800098 	cmpnei	r2,r2,2
 d037ff0:	1000601e 	bne	r2,zero,d038174 <udp4_sockbind+0x20c>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 d037ff4:	e0bffb17 	ldw	r2,-20(fp)
 d037ff8:	1080008b 	ldhu	r2,2(r2)
 d037ffc:	10bfffcc 	andi	r2,r2,65535
 d038000:	1004c03a 	cmpne	r2,r2,zero
 d038004:	10000c1e 	bne	r2,zero,d038038 <udp4_sockbind+0xd0>
    {
      if (udpconn->u_lport != 0)
 d038008:	e0bffa17 	ldw	r2,-24(fp)
 d03800c:	1080018b 	ldhu	r2,6(r2)
 d038010:	10bfffcc 	andi	r2,r2,65535
 d038014:	1005003a 	cmpeq	r2,r2,zero
 d038018:	1000041e 	bne	r2,zero,d03802c <udp4_sockbind+0xc4>
        lport = udpconn->u_lport;
 d03801c:	e0bffa17 	ldw	r2,-24(fp)
 d038020:	1080018b 	ldhu	r2,6(r2)
 d038024:	e0bff80d 	sth	r2,-32(fp)
 d038028:	00001206 	br	d038074 <udp4_sockbind+0x10c>
      else
        lport = udp_socket();
 d03802c:	d0434d00 	call	d0434d0 <udp_socket>
 d038030:	e0bff80d 	sth	r2,-32(fp)
 d038034:	00000f06 	br	d038074 <udp4_sockbind+0x10c>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 d038038:	e0bffb17 	ldw	r2,-20(fp)
 d03803c:	1080008b 	ldhu	r2,2(r2)
 d038040:	10bfffcc 	andi	r2,r2,65535
 d038044:	1004d23a 	srli	r2,r2,8
 d038048:	10803fcc 	andi	r2,r2,255
 d03804c:	1009883a 	mov	r4,r2
 d038050:	e0bffb17 	ldw	r2,-20(fp)
 d038054:	1080008b 	ldhu	r2,2(r2)
 d038058:	10bfffcc 	andi	r2,r2,65535
 d03805c:	1004923a 	slli	r2,r2,8
 d038060:	1007883a 	mov	r3,r2
 d038064:	00bfc004 	movi	r2,-256
 d038068:	1884703a 	and	r2,r3,r2
 d03806c:	2084b03a 	or	r2,r4,r2
 d038070:	e0bff80d 	sth	r2,-32(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 d038074:	e0bffb17 	ldw	r2,-20(fp)
 d038078:	10800117 	ldw	r2,4(r2)
 d03807c:	1004c03a 	cmpne	r2,r2,zero
 d038080:	1000021e 	bne	r2,zero,d03808c <udp4_sockbind+0x124>
    {
      lhost = 0L;
 d038084:	e03ff615 	stw	zero,-40(fp)
 d038088:	00001806 	br	d0380ec <udp4_sockbind+0x184>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 d03808c:	e0bffb17 	ldw	r2,-20(fp)
 d038090:	10800117 	ldw	r2,4(r2)
 d038094:	e0bff615 	stw	r2,-40(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d038098:	008341b4 	movhi	r2,3334
 d03809c:	10b4e604 	addi	r2,r2,-11368
 d0380a0:	10800017 	ldw	r2,0(r2)
 d0380a4:	e0bff515 	stw	r2,-44(fp)
 d0380a8:	00000706 	br	d0380c8 <udp4_sockbind+0x160>
        if (ifp->n_ipaddr == lhost)
 d0380ac:	e0bff517 	ldw	r2,-44(fp)
 d0380b0:	10c00a17 	ldw	r3,40(r2)
 d0380b4:	e0bff617 	ldw	r2,-40(fp)
 d0380b8:	18800626 	beq	r3,r2,d0380d4 <udp4_sockbind+0x16c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d0380bc:	e0bff517 	ldw	r2,-44(fp)
 d0380c0:	10800017 	ldw	r2,0(r2)
 d0380c4:	e0bff515 	stw	r2,-44(fp)
 d0380c8:	e0bff517 	ldw	r2,-44(fp)
 d0380cc:	1004c03a 	cmpne	r2,r2,zero
 d0380d0:	103ff61e 	bne	r2,zero,d0380ac <udp4_sockbind+0x144>
        if (ifp->n_ipaddr == lhost)
          break;
      if (ifp == NULL)
 d0380d4:	e0bff517 	ldw	r2,-44(fp)
 d0380d8:	1004c03a 	cmpne	r2,r2,zero
 d0380dc:	1000031e 	bne	r2,zero,d0380ec <udp4_sockbind+0x184>
        return(EADDRNOTAVAIL);
 d0380e0:	00801f44 	movi	r2,125
 d0380e4:	e0bfff15 	stw	r2,-4(fp)
 d0380e8:	00006806 	br	d03828c <udp4_sockbind+0x324>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 d0380ec:	e0bffc17 	ldw	r2,-16(fp)
 d0380f0:	10800417 	ldw	r2,16(r2)
 d0380f4:	1080010c 	andi	r2,r2,4
 d0380f8:	1004c03a 	cmpne	r2,r2,zero
 d0380fc:	1000161e 	bne	r2,zero,d038158 <udp4_sockbind+0x1f0>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 d038100:	00834174 	movhi	r2,3333
 d038104:	108abd04 	addi	r2,r2,10996
 d038108:	10800017 	ldw	r2,0(r2)
 d03810c:	e0bff915 	stw	r2,-28(fp)
 d038110:	00000e06 	br	d03814c <udp4_sockbind+0x1e4>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 d038114:	e0bff917 	ldw	r2,-28(fp)
 d038118:	1080018b 	ldhu	r2,6(r2)
 d03811c:	10ffffcc 	andi	r3,r2,65535
 d038120:	e0bff80b 	ldhu	r2,-32(fp)
 d038124:	1880061e 	bne	r3,r2,d038140 <udp4_sockbind+0x1d8>
 d038128:	e0fff917 	ldw	r3,-28(fp)
 d03812c:	e0bffa17 	ldw	r2,-24(fp)
 d038130:	18800326 	beq	r3,r2,d038140 <udp4_sockbind+0x1d8>
          return(EADDRINUSE);
 d038134:	00801c04 	movi	r2,112
 d038138:	e0bfff15 	stw	r2,-4(fp)
 d03813c:	00005306 	br	d03828c <udp4_sockbind+0x324>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 d038140:	e0bff917 	ldw	r2,-28(fp)
 d038144:	10800017 	ldw	r2,0(r2)
 d038148:	e0bff915 	stw	r2,-28(fp)
 d03814c:	e0bff917 	ldw	r2,-28(fp)
 d038150:	1004c03a 	cmpne	r2,r2,zero
 d038154:	103fef1e 	bne	r2,zero,d038114 <udp4_sockbind+0x1ac>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 d038158:	e0fffa17 	ldw	r3,-24(fp)
 d03815c:	e0bff80b 	ldhu	r2,-32(fp)
 d038160:	1880018d 	sth	r2,6(r3)
    udpconn->u_lhost = lhost;
 d038164:	e0fffa17 	ldw	r3,-24(fp)
 d038168:	e0bff617 	ldw	r2,-40(fp)
 d03816c:	18800315 	stw	r2,12(r3)
 d038170:	00004506 	br	d038288 <udp4_sockbind+0x320>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 d038174:	e0bffb17 	ldw	r2,-20(fp)
 d038178:	1080008b 	ldhu	r2,2(r2)
 d03817c:	10bfffcc 	andi	r2,r2,65535
 d038180:	1004d23a 	srli	r2,r2,8
 d038184:	10803fcc 	andi	r2,r2,255
 d038188:	1009883a 	mov	r4,r2
 d03818c:	e0bffb17 	ldw	r2,-20(fp)
 d038190:	1080008b 	ldhu	r2,2(r2)
 d038194:	10bfffcc 	andi	r2,r2,65535
 d038198:	1004923a 	slli	r2,r2,8
 d03819c:	1007883a 	mov	r3,r2
 d0381a0:	00bfc004 	movi	r2,-256
 d0381a4:	1884703a 	and	r2,r3,r2
 d0381a8:	2084b03a 	or	r2,r4,r2
 d0381ac:	e0bff88d 	sth	r2,-30(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 d0381b0:	e0bffb17 	ldw	r2,-20(fp)
 d0381b4:	10800117 	ldw	r2,4(r2)
 d0381b8:	1004c03a 	cmpne	r2,r2,zero
 d0381bc:	1000021e 	bne	r2,zero,d0381c8 <udp4_sockbind+0x260>
      fhost = 0L;
 d0381c0:	e03ff715 	stw	zero,-36(fp)
 d0381c4:	00000306 	br	d0381d4 <udp4_sockbind+0x26c>
    else
      fhost = sin->sin_addr.s_addr;
 d0381c8:	e0bffb17 	ldw	r2,-20(fp)
 d0381cc:	10800117 	ldw	r2,4(r2)
 d0381d0:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 d0381d4:	e13ff717 	ldw	r4,-36(fp)
 d0381d8:	d03e5a80 	call	d03e5a8 <ip_mymach>
 d0381dc:	e0bff615 	stw	r2,-40(fp)
    if (lhost == 0)
 d0381e0:	e0bff617 	ldw	r2,-40(fp)
 d0381e4:	1004c03a 	cmpne	r2,r2,zero
 d0381e8:	1000031e 	bne	r2,zero,d0381f8 <udp4_sockbind+0x290>
      return(ENETUNREACH);
 d0381ec:	00801c84 	movi	r2,114
 d0381f0:	e0bfff15 	stw	r2,-4(fp)
 d0381f4:	00002506 	br	d03828c <udp4_sockbind+0x324>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 d0381f8:	e0bffa17 	ldw	r2,-24(fp)
 d0381fc:	1080018b 	ldhu	r2,6(r2)
 d038200:	e0bff80d 	sth	r2,-32(fp)
    if (lport == 0)
 d038204:	e0bff80b 	ldhu	r2,-32(fp)
 d038208:	1004c03a 	cmpne	r2,r2,zero
 d03820c:	1000021e 	bne	r2,zero,d038218 <udp4_sockbind+0x2b0>
      lport = udp_socket();
 d038210:	d0434d00 	call	d0434d0 <udp_socket>
 d038214:	e0bff80d 	sth	r2,-32(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 d038218:	e0fffa17 	ldw	r3,-24(fp)
 d03821c:	e0bff617 	ldw	r2,-40(fp)
 d038220:	18800315 	stw	r2,12(r3)
    udpconn->u_lport = lport;
 d038224:	e0fffa17 	ldw	r3,-24(fp)
 d038228:	e0bff80b 	ldhu	r2,-32(fp)
 d03822c:	1880018d 	sth	r2,6(r3)
    udpconn->u_fhost = fhost;
 d038230:	e0fffa17 	ldw	r3,-24(fp)
 d038234:	e0bff717 	ldw	r2,-36(fp)
 d038238:	18800415 	stw	r2,16(r3)
    udpconn->u_fport = fport;
 d03823c:	e0fffa17 	ldw	r3,-24(fp)
 d038240:	e0bff88b 	ldhu	r2,-30(fp)
 d038244:	1880020d 	sth	r2,8(r3)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 d038248:	e0bffc17 	ldw	r2,-16(fp)
 d03824c:	10c0088b 	ldhu	r3,34(r2)
 d038250:	00bffcc4 	movi	r2,-13
 d038254:	1884703a 	and	r2,r3,r2
 d038258:	1007883a 	mov	r3,r2
 d03825c:	e0bffc17 	ldw	r2,-16(fp)
 d038260:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 d038264:	e0bffc17 	ldw	r2,-16(fp)
 d038268:	1080088b 	ldhu	r2,34(r2)
 d03826c:	10800094 	ori	r2,r2,2
 d038270:	1007883a 	mov	r3,r2
 d038274:	e0bffc17 	ldw	r2,-16(fp)
 d038278:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 d03827c:	e0bffc17 	ldw	r2,-16(fp)
 d038280:	11000a04 	addi	r4,r2,40
 d038284:	d030ea40 	call	d030ea4 <sbflush>
  }
  return 0;
 d038288:	e03fff15 	stw	zero,-4(fp)
 d03828c:	e0bfff17 	ldw	r2,-4(fp)
}
 d038290:	e037883a 	mov	sp,fp
 d038294:	dfc00117 	ldw	ra,4(sp)
 d038298:	df000017 	ldw	fp,0(sp)
 d03829c:	dec00204 	addi	sp,sp,8
 d0382a0:	f800283a 	ret

0d0382a4 <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 d0382a4:	defff204 	addi	sp,sp,-56
 d0382a8:	dfc00d15 	stw	ra,52(sp)
 d0382ac:	df000c15 	stw	fp,48(sp)
 d0382b0:	dc000b15 	stw	r16,44(sp)
 d0382b4:	df000b04 	addi	fp,sp,44
 d0382b8:	e13ffc15 	stw	r4,-16(fp)
 d0382bc:	e17ffd15 	stw	r5,-12(fp)
 d0382c0:	e1bffe15 	stw	r6,-8(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 d0382c4:	e13ffc17 	ldw	r4,-16(fp)
 d0382c8:	d037abc0 	call	d037abc <udp_lookup>
 d0382cc:	e0bff915 	stw	r2,-28(fp)
  if (!udpconn)
 d0382d0:	e0bff917 	ldw	r2,-28(fp)
 d0382d4:	1004c03a 	cmpne	r2,r2,zero
 d0382d8:	1000051e 	bne	r2,zero,d0382f0 <udp4_socksend+0x4c>
  {
    m_free(m);
 d0382dc:	e13ffd17 	ldw	r4,-12(fp)
 d0382e0:	d02a3900 	call	d02a390 <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 d0382e4:	00801bc4 	movi	r2,111
 d0382e8:	e0bfff15 	stw	r2,-4(fp)
 d0382ec:	0000dd06 	br	d038664 <udp4_socksend+0x3c0>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 d0382f0:	e0bffe17 	ldw	r2,-8(fp)
 d0382f4:	1004c03a 	cmpne	r2,r2,zero
 d0382f8:	1000101e 	bne	r2,zero,d03833c <udp4_socksend+0x98>
  { 
    if (so->so_state & SS_ISCONNECTED)
 d0382fc:	e0bffc17 	ldw	r2,-16(fp)
 d038300:	1080088b 	ldhu	r2,34(r2)
 d038304:	10bfffcc 	andi	r2,r2,65535
 d038308:	1080008c 	andi	r2,r2,2
 d03830c:	1005003a 	cmpeq	r2,r2,zero
 d038310:	1000071e 	bne	r2,zero,d038330 <udp4_socksend+0x8c>
    {
      fport = udpconn->u_fport;
 d038314:	e0bff917 	ldw	r2,-28(fp)
 d038318:	1080020b 	ldhu	r2,8(r2)
 d03831c:	e0bff80d 	sth	r2,-32(fp)
      fhost = udpconn->u_fhost;
 d038320:	e0bff917 	ldw	r2,-28(fp)
 d038324:	10800417 	ldw	r2,16(r2)
 d038328:	e0bff715 	stw	r2,-36(fp)
 d03832c:	00003106 	br	d0383f4 <udp4_socksend+0x150>
    }
    else
      return (EINVAL);
 d038330:	00800584 	movi	r2,22
 d038334:	e0bfff15 	stw	r2,-4(fp)
 d038338:	0000ca06 	br	d038664 <udp4_socksend+0x3c0>
  }
  else if(nam->m_len != sizeof (*sin))
 d03833c:	e0bffe17 	ldw	r2,-8(fp)
 d038340:	10800217 	ldw	r2,8(r2)
 d038344:	10800420 	cmpeqi	r2,r2,16
 d038348:	1000041e 	bne	r2,zero,d03835c <udp4_socksend+0xb8>
  {
    dtrap();
 d03834c:	d0293e80 	call	d0293e8 <dtrap>
    return (EINVAL);
 d038350:	00800584 	movi	r2,22
 d038354:	e0bfff15 	stw	r2,-4(fp)
 d038358:	0000c206 	br	d038664 <udp4_socksend+0x3c0>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 d03835c:	e0bffe17 	ldw	r2,-8(fp)
 d038360:	10800317 	ldw	r2,12(r2)
 d038364:	e0bffa15 	stw	r2,-24(fp)
    fhost = sin->sin_addr.s_addr;
 d038368:	e0bffa17 	ldw	r2,-24(fp)
 d03836c:	10800117 	ldw	r2,4(r2)
 d038370:	e0bff715 	stw	r2,-36(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 d038374:	e0bffa17 	ldw	r2,-24(fp)
 d038378:	1080008b 	ldhu	r2,2(r2)
 d03837c:	10bfffcc 	andi	r2,r2,65535
 d038380:	1005003a 	cmpeq	r2,r2,zero
 d038384:	1000101e 	bne	r2,zero,d0383c8 <udp4_socksend+0x124>
      fport = ntohs(sin->sin_port);
 d038388:	e0bffa17 	ldw	r2,-24(fp)
 d03838c:	1080008b 	ldhu	r2,2(r2)
 d038390:	10bfffcc 	andi	r2,r2,65535
 d038394:	1004d23a 	srli	r2,r2,8
 d038398:	10803fcc 	andi	r2,r2,255
 d03839c:	1009883a 	mov	r4,r2
 d0383a0:	e0bffa17 	ldw	r2,-24(fp)
 d0383a4:	1080008b 	ldhu	r2,2(r2)
 d0383a8:	10bfffcc 	andi	r2,r2,65535
 d0383ac:	1004923a 	slli	r2,r2,8
 d0383b0:	1007883a 	mov	r3,r2
 d0383b4:	00bfc004 	movi	r2,-256
 d0383b8:	1884703a 	and	r2,r3,r2
 d0383bc:	2084b03a 	or	r2,r4,r2
 d0383c0:	e0bff80d 	sth	r2,-32(fp)
 d0383c4:	00000b06 	br	d0383f4 <udp4_socksend+0x150>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 d0383c8:	e0bff917 	ldw	r2,-28(fp)
 d0383cc:	1080020b 	ldhu	r2,8(r2)
 d0383d0:	10bfffcc 	andi	r2,r2,65535
 d0383d4:	1004c03a 	cmpne	r2,r2,zero
 d0383d8:	1000031e 	bne	r2,zero,d0383e8 <udp4_socksend+0x144>
        return (EINVAL);
 d0383dc:	00800584 	movi	r2,22
 d0383e0:	e0bfff15 	stw	r2,-4(fp)
 d0383e4:	00009f06 	br	d038664 <udp4_socksend+0x3c0>
      fport = udpconn->u_fport;
 d0383e8:	e0bff917 	ldw	r2,-28(fp)
 d0383ec:	1080020b 	ldhu	r2,8(r2)
 d0383f0:	e0bff80d 	sth	r2,-32(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 d0383f4:	e0bffd17 	ldw	r2,-12(fp)
 d0383f8:	14000217 	ldw	r16,8(r2)
 d0383fc:	d0436600 	call	d043660 <udp_maxalloc>
 d038400:	1400042e 	bgeu	r2,r16,d038414 <udp4_socksend+0x170>
  {
    dtrap(); /* should never happen */
 d038404:	d0293e80 	call	d0293e8 <dtrap>
    return EMSGSIZE;  /* try to recover */
 d038408:	00801e84 	movi	r2,122
 d03840c:	e0bfff15 	stw	r2,-4(fp)
 d038410:	00009406 	br	d038664 <udp4_socksend+0x3c0>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 d038414:	e0bffd17 	ldw	r2,-12(fp)
 d038418:	10800217 	ldw	r2,8(r2)
 d03841c:	1009883a 	mov	r4,r2
 d038420:	000b883a 	mov	r5,zero
 d038424:	d0435a00 	call	d0435a0 <udp_alloc>
 d038428:	e0bff615 	stw	r2,-40(fp)
  if (!pkt)
 d03842c:	e0bff617 	ldw	r2,-40(fp)
 d038430:	1004c03a 	cmpne	r2,r2,zero
 d038434:	1000051e 	bne	r2,zero,d03844c <udp4_socksend+0x1a8>
  {
    m_free(m);
 d038438:	e13ffd17 	ldw	r4,-12(fp)
 d03843c:	d02a3900 	call	d02a390 <m_free>
    return ENOBUFS;   /* report buffer shortages */
 d038440:	00801a44 	movi	r2,105
 d038444:	e0bfff15 	stw	r2,-4(fp)
 d038448:	00008606 	br	d038664 <udp4_socksend+0x3c0>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 d03844c:	e0bff617 	ldw	r2,-40(fp)
 d038450:	10c00317 	ldw	r3,12(r2)
 d038454:	e0bffd17 	ldw	r2,-12(fp)
 d038458:	11400317 	ldw	r5,12(r2)
 d03845c:	e0bffd17 	ldw	r2,-12(fp)
 d038460:	10800217 	ldw	r2,8(r2)
 d038464:	1809883a 	mov	r4,r3
 d038468:	100d883a 	mov	r6,r2
 d03846c:	d0027000 	call	d002700 <memcpy>
  pkt->nb_plen = m->m_len;
 d038470:	e0bffd17 	ldw	r2,-12(fp)
 d038474:	10c00217 	ldw	r3,8(r2)
 d038478:	e0bff617 	ldw	r2,-40(fp)
 d03847c:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 d038480:	e13ffd17 	ldw	r4,-12(fp)
 d038484:	d02a3900 	call	d02a390 <m_free>
  pkt->fhost = fhost;
 d038488:	e0fff617 	ldw	r3,-40(fp)
 d03848c:	e0bff717 	ldw	r2,-36(fp)
 d038490:	18800715 	stw	r2,28(r3)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 d038494:	e0bff717 	ldw	r2,-36(fp)
 d038498:	10bfffd8 	cmpnei	r2,r2,-1
 d03849c:	10004f1e 	bne	r2,zero,d0385dc <udp4_socksend+0x338>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 d0384a0:	e0bff917 	ldw	r2,-28(fp)
 d0384a4:	10800317 	ldw	r2,12(r2)
 d0384a8:	1005003a 	cmpeq	r2,r2,zero
 d0384ac:	1000111e 	bne	r2,zero,d0384f4 <udp4_socksend+0x250>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d0384b0:	008341b4 	movhi	r2,3334
 d0384b4:	10b4e604 	addi	r2,r2,-11368
 d0384b8:	10800017 	ldw	r2,0(r2)
 d0384bc:	e0bff515 	stw	r2,-44(fp)
 d0384c0:	00000806 	br	d0384e4 <udp4_socksend+0x240>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 d0384c4:	e0bff517 	ldw	r2,-44(fp)
 d0384c8:	10c00a17 	ldw	r3,40(r2)
 d0384cc:	e0bff917 	ldw	r2,-28(fp)
 d0384d0:	10800317 	ldw	r2,12(r2)
 d0384d4:	18802126 	beq	r3,r2,d03855c <udp4_socksend+0x2b8>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d0384d8:	e0bff517 	ldw	r2,-44(fp)
 d0384dc:	10800017 	ldw	r2,0(r2)
 d0384e0:	e0bff515 	stw	r2,-44(fp)
 d0384e4:	e0bff517 	ldw	r2,-44(fp)
 d0384e8:	1004c03a 	cmpne	r2,r2,zero
 d0384ec:	103ff51e 	bne	r2,zero,d0384c4 <udp4_socksend+0x220>
 d0384f0:	00001a06 	br	d03855c <udp4_socksend+0x2b8>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d0384f4:	008341b4 	movhi	r2,3334
 d0384f8:	10b4e604 	addi	r2,r2,-11368
 d0384fc:	10800017 	ldw	r2,0(r2)
 d038500:	e0bff515 	stw	r2,-44(fp)
 d038504:	00001206 	br	d038550 <udp4_socksend+0x2ac>
        if ((ifp->n_flags & NF_BCAST) &&
 d038508:	e0bff517 	ldw	r2,-44(fp)
 d03850c:	10802a17 	ldw	r2,168(r2)
 d038510:	1080004c 	andi	r2,r2,1
 d038514:	10803fcc 	andi	r2,r2,255
 d038518:	1005003a 	cmpeq	r2,r2,zero
 d03851c:	1000091e 	bne	r2,zero,d038544 <udp4_socksend+0x2a0>
 d038520:	e0bff517 	ldw	r2,-44(fp)
 d038524:	10802717 	ldw	r2,156(r2)
 d038528:	1005003a 	cmpeq	r2,r2,zero
 d03852c:	1000051e 	bne	r2,zero,d038544 <udp4_socksend+0x2a0>
 d038530:	e0bff517 	ldw	r2,-44(fp)
 d038534:	10802717 	ldw	r2,156(r2)
 d038538:	10800617 	ldw	r2,24(r2)
 d03853c:	10800060 	cmpeqi	r2,r2,1
 d038540:	1000061e 	bne	r2,zero,d03855c <udp4_socksend+0x2b8>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d038544:	e0bff517 	ldw	r2,-44(fp)
 d038548:	10800017 	ldw	r2,0(r2)
 d03854c:	e0bff515 	stw	r2,-44(fp)
 d038550:	e0bff517 	ldw	r2,-44(fp)
 d038554:	1004c03a 	cmpne	r2,r2,zero
 d038558:	103feb1e 	bne	r2,zero,d038508 <udp4_socksend+0x264>
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
 d03855c:	e0bff517 	ldw	r2,-44(fp)
 d038560:	1004c03a 	cmpne	r2,r2,zero
 d038564:	10001a1e 	bne	r2,zero,d0385d0 <udp4_socksend+0x32c>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d038568:	008341b4 	movhi	r2,3334
 d03856c:	10b4e604 	addi	r2,r2,-11368
 d038570:	10800017 	ldw	r2,0(r2)
 d038574:	e0bff515 	stw	r2,-44(fp)
 d038578:	00000c06 	br	d0385ac <udp4_socksend+0x308>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 d03857c:	e0bff517 	ldw	r2,-44(fp)
 d038580:	10802717 	ldw	r2,156(r2)
 d038584:	1005003a 	cmpeq	r2,r2,zero
 d038588:	1000051e 	bne	r2,zero,d0385a0 <udp4_socksend+0x2fc>
 d03858c:	e0bff517 	ldw	r2,-44(fp)
 d038590:	10802717 	ldw	r2,156(r2)
 d038594:	10800617 	ldw	r2,24(r2)
 d038598:	10800060 	cmpeqi	r2,r2,1
 d03859c:	1000061e 	bne	r2,zero,d0385b8 <udp4_socksend+0x314>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d0385a0:	e0bff517 	ldw	r2,-44(fp)
 d0385a4:	10800017 	ldw	r2,0(r2)
 d0385a8:	e0bff515 	stw	r2,-44(fp)
 d0385ac:	e0bff517 	ldw	r2,-44(fp)
 d0385b0:	1004c03a 	cmpne	r2,r2,zero
 d0385b4:	103ff11e 	bne	r2,zero,d03857c <udp4_socksend+0x2d8>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
      if (ifp == NULL)
 d0385b8:	e0bff517 	ldw	r2,-44(fp)
 d0385bc:	1004c03a 	cmpne	r2,r2,zero
 d0385c0:	1000031e 	bne	r2,zero,d0385d0 <udp4_socksend+0x32c>
        return(EADDRNOTAVAIL);
 d0385c4:	00801f44 	movi	r2,125
 d0385c8:	e0bfff15 	stw	r2,-4(fp)
 d0385cc:	00002506 	br	d038664 <udp4_socksend+0x3c0>
    }
    pkt->net = ifp;
 d0385d0:	e0fff617 	ldw	r3,-40(fp)
 d0385d4:	e0bff517 	ldw	r2,-44(fp)
 d0385d8:	18800615 	stw	r2,24(r3)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 d0385dc:	e0bffc17 	ldw	r2,-16(fp)
 d0385e0:	10800317 	ldw	r2,12(r2)
 d0385e4:	1005003a 	cmpeq	r2,r2,zero
 d0385e8:	1000041e 	bne	r2,zero,d0385fc <udp4_socksend+0x358>
     pkt->imo = so->inp_moptions;
 d0385ec:	e0bffc17 	ldw	r2,-16(fp)
 d0385f0:	10c00317 	ldw	r3,12(r2)
 d0385f4:	e0bff617 	ldw	r2,-40(fp)
 d0385f8:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 d0385fc:	e0bffc17 	ldw	r2,-16(fp)
 d038600:	10801f17 	ldw	r2,124(r2)
 d038604:	1005003a 	cmpeq	r2,r2,zero
 d038608:	1000041e 	bne	r2,zero,d03861c <udp4_socksend+0x378>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 d03860c:	e0bffc17 	ldw	r2,-16(fp)
 d038610:	10c01f17 	ldw	r3,124(r2)
 d038614:	e0bff617 	ldw	r2,-40(fp)
 d038618:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 d03861c:	0009883a 	mov	r4,zero
 d038620:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 d038624:	e13ff80b 	ldhu	r4,-32(fp)
 d038628:	e0bff917 	ldw	r2,-28(fp)
 d03862c:	1080018b 	ldhu	r2,6(r2)
 d038630:	117fffcc 	andi	r5,r2,65535
 d038634:	e1bff617 	ldw	r6,-40(fp)
 d038638:	d0430e80 	call	d0430e8 <udp_send>
 d03863c:	e0bffb15 	stw	r2,-20(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 d038640:	0009883a 	mov	r4,zero
 d038644:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
  if (e < 0) 
 d038648:	e0bffb17 	ldw	r2,-20(fp)
 d03864c:	1004403a 	cmpge	r2,r2,zero
 d038650:	1000031e 	bne	r2,zero,d038660 <udp4_socksend+0x3bc>
     return(e);
 d038654:	e0bffb17 	ldw	r2,-20(fp)
 d038658:	e0bfff15 	stw	r2,-4(fp)
 d03865c:	00000106 	br	d038664 <udp4_socksend+0x3c0>
  return 0;
 d038660:	e03fff15 	stw	zero,-4(fp)
 d038664:	e0bfff17 	ldw	r2,-4(fp)
}
 d038668:	e037883a 	mov	sp,fp
 d03866c:	dfc00217 	ldw	ra,8(sp)
 d038670:	df000117 	ldw	fp,4(sp)
 d038674:	dc000017 	ldw	r16,0(sp)
 d038678:	dec00304 	addi	sp,sp,12
 d03867c:	f800283a 	ret

0d038680 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 d038680:	defff804 	addi	sp,sp,-32
 d038684:	dfc00715 	stw	ra,28(sp)
 d038688:	df000615 	stw	fp,24(sp)
 d03868c:	df000604 	addi	fp,sp,24
 d038690:	e13ffc15 	stw	r4,-16(fp)
 d038694:	e17ffd15 	stw	r5,-12(fp)
 d038698:	e1bffe15 	stw	r6,-8(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 d03869c:	e0bffd17 	ldw	r2,-12(fp)
 d0386a0:	10800317 	ldw	r2,12(r2)
 d0386a4:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 d0386a8:	e0bffb17 	ldw	r2,-20(fp)
 d0386ac:	1004c03a 	cmpne	r2,r2,zero
 d0386b0:	1000031e 	bne	r2,zero,d0386c0 <udp4_sockaddr+0x40>
     return(EINVAL);
 d0386b4:	00800584 	movi	r2,22
 d0386b8:	e0bfff15 	stw	r2,-4(fp)
 d0386bc:	00004106 	br	d0387c4 <udp4_sockaddr+0x144>
  udpconn = udp_lookup(so);
 d0386c0:	e13ffc17 	ldw	r4,-16(fp)
 d0386c4:	d037abc0 	call	d037abc <udp_lookup>
 d0386c8:	e0bffa15 	stw	r2,-24(fp)
  if (!udpconn)
 d0386cc:	e0bffa17 	ldw	r2,-24(fp)
 d0386d0:	1004c03a 	cmpne	r2,r2,zero
 d0386d4:	1000031e 	bne	r2,zero,d0386e4 <udp4_sockaddr+0x64>
     return(EINVAL);
 d0386d8:	00800584 	movi	r2,22
 d0386dc:	e0bfff15 	stw	r2,-4(fp)
 d0386e0:	00003806 	br	d0387c4 <udp4_sockaddr+0x144>
  nam->m_len = sizeof(*sin);
 d0386e4:	e0fffd17 	ldw	r3,-12(fp)
 d0386e8:	00800404 	movi	r2,16
 d0386ec:	18800215 	stw	r2,8(r3)
  if (req == PRU_SOCKADDR)
 d0386f0:	e0bffe17 	ldw	r2,-8(fp)
 d0386f4:	108003d8 	cmpnei	r2,r2,15
 d0386f8:	1000191e 	bne	r2,zero,d038760 <udp4_sockaddr+0xe0>
  {
     sin->sin_family = AF_INET;
 d0386fc:	e0fffb17 	ldw	r3,-20(fp)
 d038700:	00800084 	movi	r2,2
 d038704:	1880000d 	sth	r2,0(r3)
     sin->sin_port = htons(udpconn->u_lport);
 d038708:	e0bffa17 	ldw	r2,-24(fp)
 d03870c:	1080018b 	ldhu	r2,6(r2)
 d038710:	10bfffcc 	andi	r2,r2,65535
 d038714:	1004d23a 	srli	r2,r2,8
 d038718:	10803fcc 	andi	r2,r2,255
 d03871c:	1009883a 	mov	r4,r2
 d038720:	e0bffa17 	ldw	r2,-24(fp)
 d038724:	1080018b 	ldhu	r2,6(r2)
 d038728:	10bfffcc 	andi	r2,r2,65535
 d03872c:	1004923a 	slli	r2,r2,8
 d038730:	1007883a 	mov	r3,r2
 d038734:	00bfc004 	movi	r2,-256
 d038738:	1884703a 	and	r2,r3,r2
 d03873c:	2084b03a 	or	r2,r4,r2
 d038740:	1007883a 	mov	r3,r2
 d038744:	e0bffb17 	ldw	r2,-20(fp)
 d038748:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 d03874c:	e0bffa17 	ldw	r2,-24(fp)
 d038750:	10c00317 	ldw	r3,12(r2)
 d038754:	e0bffb17 	ldw	r2,-20(fp)
 d038758:	10c00115 	stw	r3,4(r2)
 d03875c:	00001806 	br	d0387c0 <udp4_sockaddr+0x140>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 d038760:	e0fffb17 	ldw	r3,-20(fp)
 d038764:	00800084 	movi	r2,2
 d038768:	1880000d 	sth	r2,0(r3)
    sin->sin_port = htons(udpconn->u_fport);
 d03876c:	e0bffa17 	ldw	r2,-24(fp)
 d038770:	1080020b 	ldhu	r2,8(r2)
 d038774:	10bfffcc 	andi	r2,r2,65535
 d038778:	1004d23a 	srli	r2,r2,8
 d03877c:	10803fcc 	andi	r2,r2,255
 d038780:	1009883a 	mov	r4,r2
 d038784:	e0bffa17 	ldw	r2,-24(fp)
 d038788:	1080020b 	ldhu	r2,8(r2)
 d03878c:	10bfffcc 	andi	r2,r2,65535
 d038790:	1004923a 	slli	r2,r2,8
 d038794:	1007883a 	mov	r3,r2
 d038798:	00bfc004 	movi	r2,-256
 d03879c:	1884703a 	and	r2,r3,r2
 d0387a0:	2084b03a 	or	r2,r4,r2
 d0387a4:	1007883a 	mov	r3,r2
 d0387a8:	e0bffb17 	ldw	r2,-20(fp)
 d0387ac:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 d0387b0:	e0bffa17 	ldw	r2,-24(fp)
 d0387b4:	10c00417 	ldw	r3,16(r2)
 d0387b8:	e0bffb17 	ldw	r2,-20(fp)
 d0387bc:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 d0387c0:	e03fff15 	stw	zero,-4(fp)
 d0387c4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0387c8:	e037883a 	mov	sp,fp
 d0387cc:	dfc00117 	ldw	ra,4(sp)
 d0387d0:	df000017 	ldw	fp,0(sp)
 d0387d4:	dec00204 	addi	sp,sp,8
 d0387d8:	f800283a 	ret

0d0387dc <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 d0387dc:	defff404 	addi	sp,sp,-48
 d0387e0:	df000b15 	stw	fp,44(sp)
 d0387e4:	df000b04 	addi	fp,sp,44
 d0387e8:	e13ffb15 	stw	r4,-20(fp)
 d0387ec:	e17ffc15 	stw	r5,-16(fp)
 d0387f0:	e1bffd15 	stw	r6,-12(fp)
 d0387f4:	e1fffe15 	stw	r7,-8(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 d0387f8:	e03ff915 	stw	zero,-28(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 d0387fc:	00834174 	movhi	r2,3333
 d038800:	108ad904 	addi	r2,r2,11108
 d038804:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 d038808:	1005003a 	cmpeq	r2,r2,zero
 d03880c:	1000411e 	bne	r2,zero,d038914 <alt_alarm_start+0x138>
  {
    if (alarm)
 d038810:	e0bffb17 	ldw	r2,-20(fp)
 d038814:	1005003a 	cmpeq	r2,r2,zero
 d038818:	10003b1e 	bne	r2,zero,d038908 <alt_alarm_start+0x12c>
    {
      alarm->callback = callback;
 d03881c:	e0fffb17 	ldw	r3,-20(fp)
 d038820:	e0bffd17 	ldw	r2,-12(fp)
 d038824:	18800315 	stw	r2,12(r3)
      alarm->context  = context;
 d038828:	e0fffb17 	ldw	r3,-20(fp)
 d03882c:	e0bffe17 	ldw	r2,-8(fp)
 d038830:	18800515 	stw	r2,20(r3)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d038834:	0005303a 	rdctl	r2,status
 d038838:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d03883c:	e0fff817 	ldw	r3,-32(fp)
 d038840:	00bfff84 	movi	r2,-2
 d038844:	1884703a 	and	r2,r3,r2
 d038848:	1001703a 	wrctl	status,r2
  
  return context;
 d03884c:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 d038850:	e0bffa15 	stw	r2,-24(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 d038854:	00834174 	movhi	r2,3333
 d038858:	108ada04 	addi	r2,r2,11112
 d03885c:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 d038860:	e0bff915 	stw	r2,-28(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 d038864:	e0fffc17 	ldw	r3,-16(fp)
 d038868:	e0bff917 	ldw	r2,-28(fp)
 d03886c:	1885883a 	add	r2,r3,r2
 d038870:	10c00044 	addi	r3,r2,1
 d038874:	e0bffb17 	ldw	r2,-20(fp)
 d038878:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 d03887c:	e0bffb17 	ldw	r2,-20(fp)
 d038880:	10c00217 	ldw	r3,8(r2)
 d038884:	e0bff917 	ldw	r2,-28(fp)
 d038888:	1880042e 	bgeu	r3,r2,d03889c <alt_alarm_start+0xc0>
      {
        alarm->rollover = 1;
 d03888c:	e0fffb17 	ldw	r3,-20(fp)
 d038890:	00800044 	movi	r2,1
 d038894:	18800405 	stb	r2,16(r3)
 d038898:	00000206 	br	d0388a4 <alt_alarm_start+0xc8>
      }
      else
      {
        alarm->rollover = 0;
 d03889c:	e0bffb17 	ldw	r2,-20(fp)
 d0388a0:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 d0388a4:	e0fffb17 	ldw	r3,-20(fp)
 d0388a8:	00834174 	movhi	r2,3333
 d0388ac:	108a6a04 	addi	r2,r2,10664
 d0388b0:	e0bff615 	stw	r2,-40(fp)
 d0388b4:	e0fff715 	stw	r3,-36(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 d0388b8:	e0fff717 	ldw	r3,-36(fp)
 d0388bc:	e0bff617 	ldw	r2,-40(fp)
 d0388c0:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 d0388c4:	e0bff617 	ldw	r2,-40(fp)
 d0388c8:	10c00017 	ldw	r3,0(r2)
 d0388cc:	e0bff717 	ldw	r2,-36(fp)
 d0388d0:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 d0388d4:	e0bff617 	ldw	r2,-40(fp)
 d0388d8:	10c00017 	ldw	r3,0(r2)
 d0388dc:	e0bff717 	ldw	r2,-36(fp)
 d0388e0:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 d0388e4:	e0fff617 	ldw	r3,-40(fp)
 d0388e8:	e0bff717 	ldw	r2,-36(fp)
 d0388ec:	18800015 	stw	r2,0(r3)
 d0388f0:	e0bffa17 	ldw	r2,-24(fp)
 d0388f4:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d0388f8:	e0bff517 	ldw	r2,-44(fp)
 d0388fc:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 d038900:	e03fff15 	stw	zero,-4(fp)
 d038904:	00000506 	br	d03891c <alt_alarm_start+0x140>
    }
    else
    {
      return -EINVAL;
 d038908:	00bffa84 	movi	r2,-22
 d03890c:	e0bfff15 	stw	r2,-4(fp)
 d038910:	00000206 	br	d03891c <alt_alarm_start+0x140>
    }
  }
  else
  {
    return -ENOTSUP;
 d038914:	00bfde84 	movi	r2,-134
 d038918:	e0bfff15 	stw	r2,-4(fp)
 d03891c:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 d038920:	e037883a 	mov	sp,fp
 d038924:	df000017 	ldw	fp,0(sp)
 d038928:	dec00104 	addi	sp,sp,4
 d03892c:	f800283a 	ret

0d038930 <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 d038930:	defff804 	addi	sp,sp,-32
 d038934:	dfc00715 	stw	ra,28(sp)
 d038938:	df000615 	stw	fp,24(sp)
 d03893c:	df000604 	addi	fp,sp,24
 d038940:	e13ffc15 	stw	r4,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 d038944:	e0bffc17 	ldw	r2,-16(fp)
 d038948:	1004803a 	cmplt	r2,r2,zero
 d03894c:	1000081e 	bne	r2,zero,d038970 <alt_close+0x40>
 d038950:	e0bffc17 	ldw	r2,-16(fp)
 d038954:	10800324 	muli	r2,r2,12
 d038958:	1007883a 	mov	r3,r2
 d03895c:	00834174 	movhi	r2,3333
 d038960:	10895d04 	addi	r2,r2,9588
 d038964:	1887883a 	add	r3,r3,r2
 d038968:	e0ffff15 	stw	r3,-4(fp)
 d03896c:	00000106 	br	d038974 <alt_close+0x44>
 d038970:	e03fff15 	stw	zero,-4(fp)
 d038974:	e0bfff17 	ldw	r2,-4(fp)
 d038978:	e0bffb15 	stw	r2,-20(fp)

  if (fd)
 d03897c:	e0bffb17 	ldw	r2,-20(fp)
 d038980:	1005003a 	cmpeq	r2,r2,zero
 d038984:	10001d1e 	bne	r2,zero,d0389fc <alt_close+0xcc>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 d038988:	e0bffb17 	ldw	r2,-20(fp)
 d03898c:	10800017 	ldw	r2,0(r2)
 d038990:	10800417 	ldw	r2,16(r2)
 d038994:	1005003a 	cmpeq	r2,r2,zero
 d038998:	1000071e 	bne	r2,zero,d0389b8 <alt_close+0x88>
 d03899c:	e0bffb17 	ldw	r2,-20(fp)
 d0389a0:	10800017 	ldw	r2,0(r2)
 d0389a4:	10800417 	ldw	r2,16(r2)
 d0389a8:	e13ffb17 	ldw	r4,-20(fp)
 d0389ac:	103ee83a 	callr	r2
 d0389b0:	e0bffe15 	stw	r2,-8(fp)
 d0389b4:	00000106 	br	d0389bc <alt_close+0x8c>
 d0389b8:	e03ffe15 	stw	zero,-8(fp)
 d0389bc:	e0bffe17 	ldw	r2,-8(fp)
 d0389c0:	e0bffa15 	stw	r2,-24(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 d0389c4:	e13ffc17 	ldw	r4,-16(fp)
 d0389c8:	d0395ec0 	call	d0395ec <alt_release_fd>
    if (rval < 0)
 d0389cc:	e0bffa17 	ldw	r2,-24(fp)
 d0389d0:	1004403a 	cmpge	r2,r2,zero
 d0389d4:	1000071e 	bne	r2,zero,d0389f4 <alt_close+0xc4>
    {
      ALT_ERRNO = -rval;
 d0389d8:	d038a2c0 	call	d038a2c <alt_get_errno>
 d0389dc:	e0fffa17 	ldw	r3,-24(fp)
 d0389e0:	00c7c83a 	sub	r3,zero,r3
 d0389e4:	10c00015 	stw	r3,0(r2)
      return -1;
 d0389e8:	00bfffc4 	movi	r2,-1
 d0389ec:	e0bffd15 	stw	r2,-12(fp)
 d0389f0:	00000806 	br	d038a14 <alt_close+0xe4>
    }
    return 0;
 d0389f4:	e03ffd15 	stw	zero,-12(fp)
 d0389f8:	00000606 	br	d038a14 <alt_close+0xe4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 d0389fc:	d038a2c0 	call	d038a2c <alt_get_errno>
 d038a00:	1007883a 	mov	r3,r2
 d038a04:	00801444 	movi	r2,81
 d038a08:	18800015 	stw	r2,0(r3)
    return -1;
 d038a0c:	00bfffc4 	movi	r2,-1
 d038a10:	e0bffd15 	stw	r2,-12(fp)
 d038a14:	e0bffd17 	ldw	r2,-12(fp)
  }
}
 d038a18:	e037883a 	mov	sp,fp
 d038a1c:	dfc00117 	ldw	ra,4(sp)
 d038a20:	df000017 	ldw	fp,0(sp)
 d038a24:	dec00204 	addi	sp,sp,8
 d038a28:	f800283a 	ret

0d038a2c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d038a2c:	defffd04 	addi	sp,sp,-12
 d038a30:	dfc00215 	stw	ra,8(sp)
 d038a34:	df000115 	stw	fp,4(sp)
 d038a38:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d038a3c:	00834174 	movhi	r2,3333
 d038a40:	108a6804 	addi	r2,r2,10656
 d038a44:	10800017 	ldw	r2,0(r2)
 d038a48:	1005003a 	cmpeq	r2,r2,zero
 d038a4c:	1000061e 	bne	r2,zero,d038a68 <alt_get_errno+0x3c>
 d038a50:	00834174 	movhi	r2,3333
 d038a54:	108a6804 	addi	r2,r2,10656
 d038a58:	10800017 	ldw	r2,0(r2)
 d038a5c:	103ee83a 	callr	r2
 d038a60:	e0bfff15 	stw	r2,-4(fp)
 d038a64:	00000306 	br	d038a74 <alt_get_errno+0x48>
 d038a68:	00834174 	movhi	r2,3333
 d038a6c:	108a8404 	addi	r2,r2,10768
 d038a70:	e0bfff15 	stw	r2,-4(fp)
 d038a74:	e0bfff17 	ldw	r2,-4(fp)
}
 d038a78:	e037883a 	mov	sp,fp
 d038a7c:	dfc00117 	ldw	ra,4(sp)
 d038a80:	df000017 	ldw	fp,0(sp)
 d038a84:	dec00204 	addi	sp,sp,8
 d038a88:	f800283a 	ret

0d038a8c <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 d038a8c:	defffb04 	addi	sp,sp,-20
 d038a90:	df000415 	stw	fp,16(sp)
 d038a94:	df000404 	addi	fp,sp,16
 d038a98:	e13ffe15 	stw	r4,-8(fp)
 d038a9c:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 d038aa0:	e0fffe17 	ldw	r3,-8(fp)
 d038aa4:	e0bfff17 	ldw	r2,-4(fp)
 d038aa8:	1885883a 	add	r2,r3,r2
 d038aac:	e0bffc15 	stw	r2,-16(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 d038ab0:	e0bffe17 	ldw	r2,-8(fp)
 d038ab4:	e0bffd15 	stw	r2,-12(fp)
 d038ab8:	00000506 	br	d038ad0 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 d038abc:	e0bffd17 	ldw	r2,-12(fp)
 d038ac0:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 d038ac4:	e0bffd17 	ldw	r2,-12(fp)
 d038ac8:	10800804 	addi	r2,r2,32
 d038acc:	e0bffd15 	stw	r2,-12(fp)
 d038ad0:	e0fffd17 	ldw	r3,-12(fp)
 d038ad4:	e0bffc17 	ldw	r2,-16(fp)
 d038ad8:	18bff836 	bltu	r3,r2,d038abc <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 d038adc:	e0bffe17 	ldw	r2,-8(fp)
 d038ae0:	108007cc 	andi	r2,r2,31
 d038ae4:	1005003a 	cmpeq	r2,r2,zero
 d038ae8:	1000021e 	bne	r2,zero,d038af4 <alt_dcache_flush+0x68>
  {
    ALT_FLUSH_DATA(i);
 d038aec:	e0bffd17 	ldw	r2,-12(fp)
 d038af0:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 d038af4:	e037883a 	mov	sp,fp
 d038af8:	df000017 	ldw	fp,0(sp)
 d038afc:	dec00104 	addi	sp,sp,4
 d038b00:	f800283a 	ret

0d038b04 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 d038b04:	defffc04 	addi	sp,sp,-16
 d038b08:	df000315 	stw	fp,12(sp)
 d038b0c:	df000304 	addi	fp,sp,12
 d038b10:	e13ffd15 	stw	r4,-12(fp)
 d038b14:	e17ffe15 	stw	r5,-8(fp)
 d038b18:	e1bfff15 	stw	r6,-4(fp)
  return len;
 d038b1c:	e0bfff17 	ldw	r2,-4(fp)
}
 d038b20:	e037883a 	mov	sp,fp
 d038b24:	df000017 	ldw	fp,0(sp)
 d038b28:	dec00104 	addi	sp,sp,4
 d038b2c:	f800283a 	ret

0d038b30 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 d038b30:	defff904 	addi	sp,sp,-28
 d038b34:	dfc00615 	stw	ra,24(sp)
 d038b38:	df000515 	stw	fp,20(sp)
 d038b3c:	df000504 	addi	fp,sp,20
 d038b40:	e13ffd15 	stw	r4,-12(fp)
 d038b44:	e17ffe15 	stw	r5,-8(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 d038b48:	e0bffd17 	ldw	r2,-12(fp)
 d038b4c:	1005003a 	cmpeq	r2,r2,zero
 d038b50:	1000041e 	bne	r2,zero,d038b64 <alt_dev_llist_insert+0x34>
 d038b54:	e0bffd17 	ldw	r2,-12(fp)
 d038b58:	10800217 	ldw	r2,8(r2)
 d038b5c:	1004c03a 	cmpne	r2,r2,zero
 d038b60:	1000071e 	bne	r2,zero,d038b80 <alt_dev_llist_insert+0x50>
  {
    ALT_ERRNO = EINVAL;
 d038b64:	d038be40 	call	d038be4 <alt_get_errno>
 d038b68:	1007883a 	mov	r3,r2
 d038b6c:	00800584 	movi	r2,22
 d038b70:	18800015 	stw	r2,0(r3)
    return -EINVAL;
 d038b74:	00bffa84 	movi	r2,-22
 d038b78:	e0bfff15 	stw	r2,-4(fp)
 d038b7c:	00001306 	br	d038bcc <alt_dev_llist_insert+0x9c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 d038b80:	e0fffd17 	ldw	r3,-12(fp)
 d038b84:	e0bffe17 	ldw	r2,-8(fp)
 d038b88:	e0bffb15 	stw	r2,-20(fp)
 d038b8c:	e0fffc15 	stw	r3,-16(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 d038b90:	e0fffc17 	ldw	r3,-16(fp)
 d038b94:	e0bffb17 	ldw	r2,-20(fp)
 d038b98:	18800115 	stw	r2,4(r3)
  entry->next     = list->next;
 d038b9c:	e0bffb17 	ldw	r2,-20(fp)
 d038ba0:	10c00017 	ldw	r3,0(r2)
 d038ba4:	e0bffc17 	ldw	r2,-16(fp)
 d038ba8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 d038bac:	e0bffb17 	ldw	r2,-20(fp)
 d038bb0:	10c00017 	ldw	r3,0(r2)
 d038bb4:	e0bffc17 	ldw	r2,-16(fp)
 d038bb8:	18800115 	stw	r2,4(r3)
  list->next           = entry;
 d038bbc:	e0fffb17 	ldw	r3,-20(fp)
 d038bc0:	e0bffc17 	ldw	r2,-16(fp)
 d038bc4:	18800015 	stw	r2,0(r3)

  return 0;  
 d038bc8:	e03fff15 	stw	zero,-4(fp)
 d038bcc:	e0bfff17 	ldw	r2,-4(fp)
}
 d038bd0:	e037883a 	mov	sp,fp
 d038bd4:	dfc00117 	ldw	ra,4(sp)
 d038bd8:	df000017 	ldw	fp,0(sp)
 d038bdc:	dec00204 	addi	sp,sp,8
 d038be0:	f800283a 	ret

0d038be4 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d038be4:	defffd04 	addi	sp,sp,-12
 d038be8:	dfc00215 	stw	ra,8(sp)
 d038bec:	df000115 	stw	fp,4(sp)
 d038bf0:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d038bf4:	00834174 	movhi	r2,3333
 d038bf8:	108a6804 	addi	r2,r2,10656
 d038bfc:	10800017 	ldw	r2,0(r2)
 d038c00:	1005003a 	cmpeq	r2,r2,zero
 d038c04:	1000061e 	bne	r2,zero,d038c20 <alt_get_errno+0x3c>
 d038c08:	00834174 	movhi	r2,3333
 d038c0c:	108a6804 	addi	r2,r2,10656
 d038c10:	10800017 	ldw	r2,0(r2)
 d038c14:	103ee83a 	callr	r2
 d038c18:	e0bfff15 	stw	r2,-4(fp)
 d038c1c:	00000306 	br	d038c2c <alt_get_errno+0x48>
 d038c20:	00834174 	movhi	r2,3333
 d038c24:	108a8404 	addi	r2,r2,10768
 d038c28:	e0bfff15 	stw	r2,-4(fp)
 d038c2c:	e0bfff17 	ldw	r2,-4(fp)
}
 d038c30:	e037883a 	mov	sp,fp
 d038c34:	dfc00117 	ldw	ra,4(sp)
 d038c38:	df000017 	ldw	fp,0(sp)
 d038c3c:	dec00204 	addi	sp,sp,8
 d038c40:	f800283a 	ret

0d038c44 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 d038c44:	defffd04 	addi	sp,sp,-12
 d038c48:	dfc00215 	stw	ra,8(sp)
 d038c4c:	df000115 	stw	fp,4(sp)
 d038c50:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 d038c54:	00bfff04 	movi	r2,-4
 d038c58:	00c34174 	movhi	r3,3333
 d038c5c:	18ea1504 	addi	r3,r3,-22444
 d038c60:	1885883a 	add	r2,r3,r2
 d038c64:	e0bfff15 	stw	r2,-4(fp)
 d038c68:	00000606 	br	d038c84 <_do_ctors+0x40>
        (*ctor) (); 
 d038c6c:	e0bfff17 	ldw	r2,-4(fp)
 d038c70:	10800017 	ldw	r2,0(r2)
 d038c74:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 d038c78:	e0bfff17 	ldw	r2,-4(fp)
 d038c7c:	10bfff04 	addi	r2,r2,-4
 d038c80:	e0bfff15 	stw	r2,-4(fp)
 d038c84:	e0ffff17 	ldw	r3,-4(fp)
 d038c88:	00834174 	movhi	r2,3333
 d038c8c:	10aa1404 	addi	r2,r2,-22448
 d038c90:	18bff62e 	bgeu	r3,r2,d038c6c <_do_ctors+0x28>
        (*ctor) (); 
}
 d038c94:	e037883a 	mov	sp,fp
 d038c98:	dfc00117 	ldw	ra,4(sp)
 d038c9c:	df000017 	ldw	fp,0(sp)
 d038ca0:	dec00204 	addi	sp,sp,8
 d038ca4:	f800283a 	ret

0d038ca8 <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 d038ca8:	defffd04 	addi	sp,sp,-12
 d038cac:	dfc00215 	stw	ra,8(sp)
 d038cb0:	df000115 	stw	fp,4(sp)
 d038cb4:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 d038cb8:	00bfff04 	movi	r2,-4
 d038cbc:	00c34174 	movhi	r3,3333
 d038cc0:	18ea1504 	addi	r3,r3,-22444
 d038cc4:	1885883a 	add	r2,r3,r2
 d038cc8:	e0bfff15 	stw	r2,-4(fp)
 d038ccc:	00000606 	br	d038ce8 <_do_dtors+0x40>
        (*dtor) (); 
 d038cd0:	e0bfff17 	ldw	r2,-4(fp)
 d038cd4:	10800017 	ldw	r2,0(r2)
 d038cd8:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 d038cdc:	e0bfff17 	ldw	r2,-4(fp)
 d038ce0:	10bfff04 	addi	r2,r2,-4
 d038ce4:	e0bfff15 	stw	r2,-4(fp)
 d038ce8:	e0ffff17 	ldw	r3,-4(fp)
 d038cec:	00834174 	movhi	r2,3333
 d038cf0:	10aa1504 	addi	r2,r2,-22444
 d038cf4:	18bff62e 	bgeu	r3,r2,d038cd0 <_do_dtors+0x28>
        (*dtor) (); 
}
 d038cf8:	e037883a 	mov	sp,fp
 d038cfc:	dfc00117 	ldw	ra,4(sp)
 d038d00:	df000017 	ldw	fp,0(sp)
 d038d04:	dec00204 	addi	sp,sp,8
 d038d08:	f800283a 	ret

0d038d0c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 d038d0c:	defff904 	addi	sp,sp,-28
 d038d10:	dfc00615 	stw	ra,24(sp)
 d038d14:	df000515 	stw	fp,20(sp)
 d038d18:	df000504 	addi	fp,sp,20
 d038d1c:	e13ffd15 	stw	r4,-12(fp)
 d038d20:	e17ffe15 	stw	r5,-8(fp)
  alt_dev* next = (alt_dev*) llist->next;
 d038d24:	e0bffe17 	ldw	r2,-8(fp)
 d038d28:	10800017 	ldw	r2,0(r2)
 d038d2c:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 d038d30:	e13ffd17 	ldw	r4,-12(fp)
 d038d34:	d00355c0 	call	d00355c <strlen>
 d038d38:	10800044 	addi	r2,r2,1
 d038d3c:	e0bffb15 	stw	r2,-20(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 d038d40:	00000d06 	br	d038d78 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 d038d44:	e0bffc17 	ldw	r2,-16(fp)
 d038d48:	11000217 	ldw	r4,8(r2)
 d038d4c:	e1bffb17 	ldw	r6,-20(fp)
 d038d50:	e17ffd17 	ldw	r5,-12(fp)
 d038d54:	d049ed40 	call	d049ed4 <memcmp>
 d038d58:	1004c03a 	cmpne	r2,r2,zero
 d038d5c:	1000031e 	bne	r2,zero,d038d6c <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 d038d60:	e0bffc17 	ldw	r2,-16(fp)
 d038d64:	e0bfff15 	stw	r2,-4(fp)
 d038d68:	00000706 	br	d038d88 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 d038d6c:	e0bffc17 	ldw	r2,-16(fp)
 d038d70:	10800017 	ldw	r2,0(r2)
 d038d74:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 d038d78:	e0fffe17 	ldw	r3,-8(fp)
 d038d7c:	e0bffc17 	ldw	r2,-16(fp)
 d038d80:	10fff01e 	bne	r2,r3,d038d44 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 d038d84:	e03fff15 	stw	zero,-4(fp)
 d038d88:	e0bfff17 	ldw	r2,-4(fp)
}
 d038d8c:	e037883a 	mov	sp,fp
 d038d90:	dfc00117 	ldw	ra,4(sp)
 d038d94:	df000017 	ldw	fp,0(sp)
 d038d98:	dec00204 	addi	sp,sp,8
 d038d9c:	f800283a 	ret

0d038da0 <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 d038da0:	defff904 	addi	sp,sp,-28
 d038da4:	dfc00615 	stw	ra,24(sp)
 d038da8:	df000515 	stw	fp,20(sp)
 d038dac:	df000504 	addi	fp,sp,20
 d038db0:	e13ffc15 	stw	r4,-16(fp)
 d038db4:	e17ffd15 	stw	r5,-12(fp)
 d038db8:	e1bffe15 	stw	r6,-8(fp)
 d038dbc:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 d038dc0:	e0800217 	ldw	r2,8(fp)
 d038dc4:	d8800015 	stw	r2,0(sp)
 d038dc8:	e13ffc17 	ldw	r4,-16(fp)
 d038dcc:	e17ffd17 	ldw	r5,-12(fp)
 d038dd0:	e1bffe17 	ldw	r6,-8(fp)
 d038dd4:	e1ffff17 	ldw	r7,-4(fp)
 d038dd8:	d038f740 	call	d038f74 <alt_iic_isr_register>
}  
 d038ddc:	e037883a 	mov	sp,fp
 d038de0:	dfc00117 	ldw	ra,4(sp)
 d038de4:	df000017 	ldw	fp,0(sp)
 d038de8:	dec00204 	addi	sp,sp,8
 d038dec:	f800283a 	ret

0d038df0 <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 d038df0:	defff904 	addi	sp,sp,-28
 d038df4:	df000615 	stw	fp,24(sp)
 d038df8:	df000604 	addi	fp,sp,24
 d038dfc:	e13ffe15 	stw	r4,-8(fp)
 d038e00:	e17fff15 	stw	r5,-4(fp)
 d038e04:	e0bfff17 	ldw	r2,-4(fp)
 d038e08:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d038e0c:	0005303a 	rdctl	r2,status
 d038e10:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d038e14:	e0fffb17 	ldw	r3,-20(fp)
 d038e18:	00bfff84 	movi	r2,-2
 d038e1c:	1884703a 	and	r2,r3,r2
 d038e20:	1001703a 	wrctl	status,r2
  
  return context;
 d038e24:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 d038e28:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active |= (1 << id);
 d038e2c:	e0fffc17 	ldw	r3,-16(fp)
 d038e30:	00800044 	movi	r2,1
 d038e34:	10c4983a 	sll	r2,r2,r3
 d038e38:	1007883a 	mov	r3,r2
 d038e3c:	00834174 	movhi	r2,3333
 d038e40:	108ad804 	addi	r2,r2,11104
 d038e44:	10800017 	ldw	r2,0(r2)
 d038e48:	1886b03a 	or	r3,r3,r2
 d038e4c:	00834174 	movhi	r2,3333
 d038e50:	108ad804 	addi	r2,r2,11104
 d038e54:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 d038e58:	00834174 	movhi	r2,3333
 d038e5c:	108ad804 	addi	r2,r2,11104
 d038e60:	10800017 	ldw	r2,0(r2)
 d038e64:	100170fa 	wrctl	ienable,r2
 d038e68:	e0bffd17 	ldw	r2,-12(fp)
 d038e6c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d038e70:	e0bffa17 	ldw	r2,-24(fp)
 d038e74:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 d038e78:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 d038e7c:	e037883a 	mov	sp,fp
 d038e80:	df000017 	ldw	fp,0(sp)
 d038e84:	dec00104 	addi	sp,sp,4
 d038e88:	f800283a 	ret

0d038e8c <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 d038e8c:	defff904 	addi	sp,sp,-28
 d038e90:	df000615 	stw	fp,24(sp)
 d038e94:	df000604 	addi	fp,sp,24
 d038e98:	e13ffe15 	stw	r4,-8(fp)
 d038e9c:	e17fff15 	stw	r5,-4(fp)
 d038ea0:	e0bfff17 	ldw	r2,-4(fp)
 d038ea4:	e0bffc15 	stw	r2,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d038ea8:	0005303a 	rdctl	r2,status
 d038eac:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d038eb0:	e0fffb17 	ldw	r3,-20(fp)
 d038eb4:	00bfff84 	movi	r2,-2
 d038eb8:	1884703a 	and	r2,r3,r2
 d038ebc:	1001703a 	wrctl	status,r2
  
  return context;
 d038ec0:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 d038ec4:	e0bffd15 	stw	r2,-12(fp)

  alt_irq_active &= ~(1 << id);
 d038ec8:	e0fffc17 	ldw	r3,-16(fp)
 d038ecc:	00800044 	movi	r2,1
 d038ed0:	10c4983a 	sll	r2,r2,r3
 d038ed4:	0084303a 	nor	r2,zero,r2
 d038ed8:	1007883a 	mov	r3,r2
 d038edc:	00834174 	movhi	r2,3333
 d038ee0:	108ad804 	addi	r2,r2,11104
 d038ee4:	10800017 	ldw	r2,0(r2)
 d038ee8:	1886703a 	and	r3,r3,r2
 d038eec:	00834174 	movhi	r2,3333
 d038ef0:	108ad804 	addi	r2,r2,11104
 d038ef4:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 d038ef8:	00834174 	movhi	r2,3333
 d038efc:	108ad804 	addi	r2,r2,11104
 d038f00:	10800017 	ldw	r2,0(r2)
 d038f04:	100170fa 	wrctl	ienable,r2
 d038f08:	e0bffd17 	ldw	r2,-12(fp)
 d038f0c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d038f10:	e0bffa17 	ldw	r2,-24(fp)
 d038f14:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 d038f18:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 d038f1c:	e037883a 	mov	sp,fp
 d038f20:	df000017 	ldw	fp,0(sp)
 d038f24:	dec00104 	addi	sp,sp,4
 d038f28:	f800283a 	ret

0d038f2c <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 d038f2c:	defffc04 	addi	sp,sp,-16
 d038f30:	df000315 	stw	fp,12(sp)
 d038f34:	df000304 	addi	fp,sp,12
 d038f38:	e13ffe15 	stw	r4,-8(fp)
 d038f3c:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 d038f40:	000530fa 	rdctl	r2,ienable
 d038f44:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 d038f48:	e0ffff17 	ldw	r3,-4(fp)
 d038f4c:	00800044 	movi	r2,1
 d038f50:	10c4983a 	sll	r2,r2,r3
 d038f54:	1007883a 	mov	r3,r2
 d038f58:	e0bffd17 	ldw	r2,-12(fp)
 d038f5c:	1884703a 	and	r2,r3,r2
 d038f60:	1004c03a 	cmpne	r2,r2,zero
}
 d038f64:	e037883a 	mov	sp,fp
 d038f68:	df000017 	ldw	fp,0(sp)
 d038f6c:	dec00104 	addi	sp,sp,4
 d038f70:	f800283a 	ret

0d038f74 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 d038f74:	defff404 	addi	sp,sp,-48
 d038f78:	dfc00b15 	stw	ra,44(sp)
 d038f7c:	df000a15 	stw	fp,40(sp)
 d038f80:	df000a04 	addi	fp,sp,40
 d038f84:	e13ffb15 	stw	r4,-20(fp)
 d038f88:	e17ffc15 	stw	r5,-16(fp)
 d038f8c:	e1bffd15 	stw	r6,-12(fp)
 d038f90:	e1fffe15 	stw	r7,-8(fp)
  int rc = -EINVAL;  
 d038f94:	00bffa84 	movi	r2,-22
 d038f98:	e0bffa15 	stw	r2,-24(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 d038f9c:	e0bffc17 	ldw	r2,-16(fp)
 d038fa0:	e0bff915 	stw	r2,-28(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 d038fa4:	e0bff917 	ldw	r2,-28(fp)
 d038fa8:	10800808 	cmpgei	r2,r2,32
 d038fac:	1000291e 	bne	r2,zero,d039054 <alt_iic_isr_register+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d038fb0:	0005303a 	rdctl	r2,status
 d038fb4:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d038fb8:	e0fff717 	ldw	r3,-36(fp)
 d038fbc:	00bfff84 	movi	r2,-2
 d038fc0:	1884703a 	and	r2,r3,r2
 d038fc4:	1001703a 	wrctl	status,r2
  
  return context;
 d038fc8:	e0bff717 	ldw	r2,-36(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 d038fcc:	e0bff815 	stw	r2,-32(fp)

    alt_irq[id].handler = isr;
 d038fd0:	e0bff917 	ldw	r2,-28(fp)
 d038fd4:	00c341b4 	movhi	r3,3334
 d038fd8:	18f44d04 	addi	r3,r3,-11980
 d038fdc:	100490fa 	slli	r2,r2,3
 d038fe0:	10c7883a 	add	r3,r2,r3
 d038fe4:	e0bffd17 	ldw	r2,-12(fp)
 d038fe8:	18800015 	stw	r2,0(r3)
    alt_irq[id].context = isr_context;
 d038fec:	e0bff917 	ldw	r2,-28(fp)
 d038ff0:	00c341b4 	movhi	r3,3334
 d038ff4:	18f44d04 	addi	r3,r3,-11980
 d038ff8:	100490fa 	slli	r2,r2,3
 d038ffc:	10c5883a 	add	r2,r2,r3
 d039000:	10c00104 	addi	r3,r2,4
 d039004:	e0bffe17 	ldw	r2,-8(fp)
 d039008:	18800015 	stw	r2,0(r3)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 d03900c:	e0bffd17 	ldw	r2,-12(fp)
 d039010:	1005003a 	cmpeq	r2,r2,zero
 d039014:	1000051e 	bne	r2,zero,d03902c <alt_iic_isr_register+0xb8>
 d039018:	e17ff917 	ldw	r5,-28(fp)
 d03901c:	e13ffb17 	ldw	r4,-20(fp)
 d039020:	d038df00 	call	d038df0 <alt_ic_irq_enable>
 d039024:	e0bfff15 	stw	r2,-4(fp)
 d039028:	00000406 	br	d03903c <alt_iic_isr_register+0xc8>
 d03902c:	e17ff917 	ldw	r5,-28(fp)
 d039030:	e13ffb17 	ldw	r4,-20(fp)
 d039034:	d038e8c0 	call	d038e8c <alt_ic_irq_disable>
 d039038:	e0bfff15 	stw	r2,-4(fp)
 d03903c:	e0bfff17 	ldw	r2,-4(fp)
 d039040:	e0bffa15 	stw	r2,-24(fp)
 d039044:	e0bff817 	ldw	r2,-32(fp)
 d039048:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d03904c:	e0bff617 	ldw	r2,-40(fp)
 d039050:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 d039054:	e0bffa17 	ldw	r2,-24(fp)
}
 d039058:	e037883a 	mov	sp,fp
 d03905c:	dfc00117 	ldw	ra,4(sp)
 d039060:	df000017 	ldw	fp,0(sp)
 d039064:	dec00204 	addi	sp,sp,8
 d039068:	f800283a 	ret

0d03906c <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 d03906c:	defff904 	addi	sp,sp,-28
 d039070:	dfc00615 	stw	ra,24(sp)
 d039074:	df000515 	stw	fp,20(sp)
 d039078:	df000504 	addi	fp,sp,20
 d03907c:	e13ffc15 	stw	r4,-16(fp)
 d039080:	e17ffd15 	stw	r5,-12(fp)
 d039084:	e1bffe15 	stw	r6,-8(fp)
 d039088:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 d03908c:	e13ffd17 	ldw	r4,-12(fp)
 d039090:	e17ffe17 	ldw	r5,-8(fp)
 d039094:	e1bfff17 	ldw	r6,-4(fp)
 d039098:	d0392840 	call	d039284 <open>
 d03909c:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 d0390a0:	e0bffb17 	ldw	r2,-20(fp)
 d0390a4:	1004803a 	cmplt	r2,r2,zero
 d0390a8:	10001c1e 	bne	r2,zero,d03911c <alt_open_fd+0xb0>
  {
    fd->dev      = alt_fd_list[old].dev;
 d0390ac:	e0bffb17 	ldw	r2,-20(fp)
 d0390b0:	00c34174 	movhi	r3,3333
 d0390b4:	18c95d04 	addi	r3,r3,9588
 d0390b8:	10800324 	muli	r2,r2,12
 d0390bc:	10c5883a 	add	r2,r2,r3
 d0390c0:	10c00017 	ldw	r3,0(r2)
 d0390c4:	e0bffc17 	ldw	r2,-16(fp)
 d0390c8:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 d0390cc:	e0bffb17 	ldw	r2,-20(fp)
 d0390d0:	00c34174 	movhi	r3,3333
 d0390d4:	18c95d04 	addi	r3,r3,9588
 d0390d8:	10800324 	muli	r2,r2,12
 d0390dc:	10c5883a 	add	r2,r2,r3
 d0390e0:	10800104 	addi	r2,r2,4
 d0390e4:	10c00017 	ldw	r3,0(r2)
 d0390e8:	e0bffc17 	ldw	r2,-16(fp)
 d0390ec:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 d0390f0:	e0bffb17 	ldw	r2,-20(fp)
 d0390f4:	00c34174 	movhi	r3,3333
 d0390f8:	18c95d04 	addi	r3,r3,9588
 d0390fc:	10800324 	muli	r2,r2,12
 d039100:	10c5883a 	add	r2,r2,r3
 d039104:	10800204 	addi	r2,r2,8
 d039108:	10c00017 	ldw	r3,0(r2)
 d03910c:	e0bffc17 	ldw	r2,-16(fp)
 d039110:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 d039114:	e13ffb17 	ldw	r4,-20(fp)
 d039118:	d0395ec0 	call	d0395ec <alt_release_fd>
  }
} 
 d03911c:	e037883a 	mov	sp,fp
 d039120:	dfc00117 	ldw	ra,4(sp)
 d039124:	df000017 	ldw	fp,0(sp)
 d039128:	dec00204 	addi	sp,sp,8
 d03912c:	f800283a 	ret

0d039130 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 d039130:	defffb04 	addi	sp,sp,-20
 d039134:	dfc00415 	stw	ra,16(sp)
 d039138:	df000315 	stw	fp,12(sp)
 d03913c:	df000304 	addi	fp,sp,12
 d039140:	e13ffd15 	stw	r4,-12(fp)
 d039144:	e17ffe15 	stw	r5,-8(fp)
 d039148:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 d03914c:	01034174 	movhi	r4,3333
 d039150:	21096004 	addi	r4,r4,9600
 d039154:	e17ffd17 	ldw	r5,-12(fp)
 d039158:	01800044 	movi	r6,1
 d03915c:	01c07fc4 	movi	r7,511
 d039160:	d03906c0 	call	d03906c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 d039164:	01034174 	movhi	r4,3333
 d039168:	21095d04 	addi	r4,r4,9588
 d03916c:	e17ffe17 	ldw	r5,-8(fp)
 d039170:	000d883a 	mov	r6,zero
 d039174:	01c07fc4 	movi	r7,511
 d039178:	d03906c0 	call	d03906c <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 d03917c:	01034174 	movhi	r4,3333
 d039180:	21096304 	addi	r4,r4,9612
 d039184:	e17fff17 	ldw	r5,-4(fp)
 d039188:	01800044 	movi	r6,1
 d03918c:	01c07fc4 	movi	r7,511
 d039190:	d03906c0 	call	d03906c <alt_open_fd>
}  
 d039194:	e037883a 	mov	sp,fp
 d039198:	dfc00117 	ldw	ra,4(sp)
 d03919c:	df000017 	ldw	fp,0(sp)
 d0391a0:	dec00204 	addi	sp,sp,8
 d0391a4:	f800283a 	ret

0d0391a8 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 d0391a8:	defffc04 	addi	sp,sp,-16
 d0391ac:	df000315 	stw	fp,12(sp)
 d0391b0:	df000304 	addi	fp,sp,12
 d0391b4:	e13ffe15 	stw	r4,-8(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 d0391b8:	e0bffe17 	ldw	r2,-8(fp)
 d0391bc:	10800217 	ldw	r2,8(r2)
 d0391c0:	10d00034 	orhi	r3,r2,16384
 d0391c4:	e0bffe17 	ldw	r2,-8(fp)
 d0391c8:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 d0391cc:	e03ffd15 	stw	zero,-12(fp)
 d0391d0:	00002006 	br	d039254 <alt_file_locked+0xac>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 d0391d4:	e0bffd17 	ldw	r2,-12(fp)
 d0391d8:	00c34174 	movhi	r3,3333
 d0391dc:	18c95d04 	addi	r3,r3,9588
 d0391e0:	10800324 	muli	r2,r2,12
 d0391e4:	10c5883a 	add	r2,r2,r3
 d0391e8:	10c00017 	ldw	r3,0(r2)
 d0391ec:	e0bffe17 	ldw	r2,-8(fp)
 d0391f0:	10800017 	ldw	r2,0(r2)
 d0391f4:	1880141e 	bne	r3,r2,d039248 <alt_file_locked+0xa0>
 d0391f8:	e0bffd17 	ldw	r2,-12(fp)
 d0391fc:	00c34174 	movhi	r3,3333
 d039200:	18c95d04 	addi	r3,r3,9588
 d039204:	10800324 	muli	r2,r2,12
 d039208:	10c5883a 	add	r2,r2,r3
 d03920c:	10800204 	addi	r2,r2,8
 d039210:	10800017 	ldw	r2,0(r2)
 d039214:	1004403a 	cmpge	r2,r2,zero
 d039218:	10000b1e 	bne	r2,zero,d039248 <alt_file_locked+0xa0>
 d03921c:	e0bffd17 	ldw	r2,-12(fp)
 d039220:	10800324 	muli	r2,r2,12
 d039224:	1007883a 	mov	r3,r2
 d039228:	00834174 	movhi	r2,3333
 d03922c:	10895d04 	addi	r2,r2,9588
 d039230:	1887883a 	add	r3,r3,r2
 d039234:	e0bffe17 	ldw	r2,-8(fp)
 d039238:	18800326 	beq	r3,r2,d039248 <alt_file_locked+0xa0>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 d03923c:	00bffcc4 	movi	r2,-13
 d039240:	e0bfff15 	stw	r2,-4(fp)
 d039244:	00000a06 	br	d039270 <alt_file_locked+0xc8>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 d039248:	e0bffd17 	ldw	r2,-12(fp)
 d03924c:	10800044 	addi	r2,r2,1
 d039250:	e0bffd15 	stw	r2,-12(fp)
 d039254:	00834174 	movhi	r2,3333
 d039258:	108a6704 	addi	r2,r2,10652
 d03925c:	10800017 	ldw	r2,0(r2)
 d039260:	1007883a 	mov	r3,r2
 d039264:	e0bffd17 	ldw	r2,-12(fp)
 d039268:	18bfda2e 	bgeu	r3,r2,d0391d4 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 d03926c:	e03fff15 	stw	zero,-4(fp)
 d039270:	e0bfff17 	ldw	r2,-4(fp)
}
 d039274:	e037883a 	mov	sp,fp
 d039278:	df000017 	ldw	fp,0(sp)
 d03927c:	dec00104 	addi	sp,sp,4
 d039280:	f800283a 	ret

0d039284 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 d039284:	defff404 	addi	sp,sp,-48
 d039288:	dfc00b15 	stw	ra,44(sp)
 d03928c:	df000a15 	stw	fp,40(sp)
 d039290:	df000a04 	addi	fp,sp,40
 d039294:	e13ffb15 	stw	r4,-20(fp)
 d039298:	e17ffc15 	stw	r5,-16(fp)
 d03929c:	e1bffd15 	stw	r6,-12(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 d0392a0:	00bfffc4 	movi	r2,-1
 d0392a4:	e0bff815 	stw	r2,-32(fp)
  int status = -ENODEV;
 d0392a8:	00bffb44 	movi	r2,-19
 d0392ac:	e0bff715 	stw	r2,-36(fp)
  int isafs = 0;
 d0392b0:	e03ff615 	stw	zero,-40(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 d0392b4:	e13ffb17 	ldw	r4,-20(fp)
 d0392b8:	01434174 	movhi	r5,3333
 d0392bc:	294a6504 	addi	r5,r5,10644
 d0392c0:	d038d0c0 	call	d038d0c <alt_find_dev>
 d0392c4:	e0bffa15 	stw	r2,-24(fp)
 d0392c8:	e0bffa17 	ldw	r2,-24(fp)
 d0392cc:	1004c03a 	cmpne	r2,r2,zero
 d0392d0:	1000051e 	bne	r2,zero,d0392e8 <open+0x64>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 d0392d4:	e13ffb17 	ldw	r4,-20(fp)
 d0392d8:	d04890c0 	call	d04890c <alt_find_file>
 d0392dc:	e0bffa15 	stw	r2,-24(fp)
    isafs = 1;
 d0392e0:	00800044 	movi	r2,1
 d0392e4:	e0bff615 	stw	r2,-40(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 d0392e8:	e0bffa17 	ldw	r2,-24(fp)
 d0392ec:	1005003a 	cmpeq	r2,r2,zero
 d0392f0:	1000301e 	bne	r2,zero,d0393b4 <open+0x130>
  {
    if ((index = alt_get_fd (dev)) < 0)
 d0392f4:	e13ffa17 	ldw	r4,-24(fp)
 d0392f8:	d048a2c0 	call	d048a2c <alt_get_fd>
 d0392fc:	e0bff815 	stw	r2,-32(fp)
 d039300:	e0bff817 	ldw	r2,-32(fp)
 d039304:	1004403a 	cmpge	r2,r2,zero
 d039308:	1000031e 	bne	r2,zero,d039318 <open+0x94>
    {
      status = index;
 d03930c:	e0bff817 	ldw	r2,-32(fp)
 d039310:	e0bff715 	stw	r2,-36(fp)
 d039314:	00002906 	br	d0393bc <open+0x138>
    }
    else
    {
      fd = &alt_fd_list[index];
 d039318:	e0bff817 	ldw	r2,-32(fp)
 d03931c:	10800324 	muli	r2,r2,12
 d039320:	1007883a 	mov	r3,r2
 d039324:	00834174 	movhi	r2,3333
 d039328:	10895d04 	addi	r2,r2,9588
 d03932c:	1885883a 	add	r2,r3,r2
 d039330:	e0bff915 	stw	r2,-28(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 d039334:	e0fffc17 	ldw	r3,-16(fp)
 d039338:	00900034 	movhi	r2,16384
 d03933c:	10bfffc4 	addi	r2,r2,-1
 d039340:	1886703a 	and	r3,r3,r2
 d039344:	e0bff917 	ldw	r2,-28(fp)
 d039348:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 d03934c:	e0bff617 	ldw	r2,-40(fp)
 d039350:	1004c03a 	cmpne	r2,r2,zero
 d039354:	1000061e 	bne	r2,zero,d039370 <open+0xec>
 d039358:	e13ff917 	ldw	r4,-28(fp)
 d03935c:	d0391a80 	call	d0391a8 <alt_file_locked>
 d039360:	e0bff715 	stw	r2,-36(fp)
 d039364:	e0bff717 	ldw	r2,-36(fp)
 d039368:	1004803a 	cmplt	r2,r2,zero
 d03936c:	1000131e 	bne	r2,zero,d0393bc <open+0x138>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 d039370:	e0bffa17 	ldw	r2,-24(fp)
 d039374:	10800317 	ldw	r2,12(r2)
 d039378:	1005003a 	cmpeq	r2,r2,zero
 d03937c:	1000091e 	bne	r2,zero,d0393a4 <open+0x120>
 d039380:	e0bffa17 	ldw	r2,-24(fp)
 d039384:	10800317 	ldw	r2,12(r2)
 d039388:	e13ff917 	ldw	r4,-28(fp)
 d03938c:	e17ffb17 	ldw	r5,-20(fp)
 d039390:	e1bffc17 	ldw	r6,-16(fp)
 d039394:	e1fffd17 	ldw	r7,-12(fp)
 d039398:	103ee83a 	callr	r2
 d03939c:	e0bfff15 	stw	r2,-4(fp)
 d0393a0:	00000106 	br	d0393a8 <open+0x124>
 d0393a4:	e03fff15 	stw	zero,-4(fp)
 d0393a8:	e0bfff17 	ldw	r2,-4(fp)
 d0393ac:	e0bff715 	stw	r2,-36(fp)
 d0393b0:	00000206 	br	d0393bc <open+0x138>
      }
    }
  }
  else
  {
    status = -ENODEV;
 d0393b4:	00bffb44 	movi	r2,-19
 d0393b8:	e0bff715 	stw	r2,-36(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 d0393bc:	e0bff717 	ldw	r2,-36(fp)
 d0393c0:	1004403a 	cmpge	r2,r2,zero
 d0393c4:	1000091e 	bne	r2,zero,d0393ec <open+0x168>
  {
    alt_release_fd (index);  
 d0393c8:	e13ff817 	ldw	r4,-32(fp)
 d0393cc:	d0395ec0 	call	d0395ec <alt_release_fd>
    ALT_ERRNO = -status;
 d0393d0:	d03940c0 	call	d03940c <alt_get_errno>
 d0393d4:	e0fff717 	ldw	r3,-36(fp)
 d0393d8:	00c7c83a 	sub	r3,zero,r3
 d0393dc:	10c00015 	stw	r3,0(r2)
    return -1;
 d0393e0:	00bfffc4 	movi	r2,-1
 d0393e4:	e0bffe15 	stw	r2,-8(fp)
 d0393e8:	00000206 	br	d0393f4 <open+0x170>
  }
  
  /* return the reference upon success */

  return index;
 d0393ec:	e0bff817 	ldw	r2,-32(fp)
 d0393f0:	e0bffe15 	stw	r2,-8(fp)
 d0393f4:	e0bffe17 	ldw	r2,-8(fp)
}
 d0393f8:	e037883a 	mov	sp,fp
 d0393fc:	dfc00117 	ldw	ra,4(sp)
 d039400:	df000017 	ldw	fp,0(sp)
 d039404:	dec00204 	addi	sp,sp,8
 d039408:	f800283a 	ret

0d03940c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d03940c:	defffd04 	addi	sp,sp,-12
 d039410:	dfc00215 	stw	ra,8(sp)
 d039414:	df000115 	stw	fp,4(sp)
 d039418:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d03941c:	00834174 	movhi	r2,3333
 d039420:	108a6804 	addi	r2,r2,10656
 d039424:	10800017 	ldw	r2,0(r2)
 d039428:	1005003a 	cmpeq	r2,r2,zero
 d03942c:	1000061e 	bne	r2,zero,d039448 <alt_get_errno+0x3c>
 d039430:	00834174 	movhi	r2,3333
 d039434:	108a6804 	addi	r2,r2,10656
 d039438:	10800017 	ldw	r2,0(r2)
 d03943c:	103ee83a 	callr	r2
 d039440:	e0bfff15 	stw	r2,-4(fp)
 d039444:	00000306 	br	d039454 <alt_get_errno+0x48>
 d039448:	00834174 	movhi	r2,3333
 d03944c:	108a8404 	addi	r2,r2,10768
 d039450:	e0bfff15 	stw	r2,-4(fp)
 d039454:	e0bfff17 	ldw	r2,-4(fp)
}
 d039458:	e037883a 	mov	sp,fp
 d03945c:	dfc00117 	ldw	ra,4(sp)
 d039460:	df000017 	ldw	fp,0(sp)
 d039464:	dec00204 	addi	sp,sp,8
 d039468:	f800283a 	ret

0d03946c <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 d03946c:	defff704 	addi	sp,sp,-36
 d039470:	dfc00815 	stw	ra,32(sp)
 d039474:	df000715 	stw	fp,28(sp)
 d039478:	df000704 	addi	fp,sp,28
 d03947c:	e13ffb15 	stw	r4,-20(fp)
 d039480:	e17ffc15 	stw	r5,-16(fp)
 d039484:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d039488:	e0bffb17 	ldw	r2,-20(fp)
 d03948c:	1004803a 	cmplt	r2,r2,zero
 d039490:	1000081e 	bne	r2,zero,d0394b4 <alt_read+0x48>
 d039494:	e0bffb17 	ldw	r2,-20(fp)
 d039498:	10800324 	muli	r2,r2,12
 d03949c:	1007883a 	mov	r3,r2
 d0394a0:	00834174 	movhi	r2,3333
 d0394a4:	10895d04 	addi	r2,r2,9588
 d0394a8:	1887883a 	add	r3,r3,r2
 d0394ac:	e0ffff15 	stw	r3,-4(fp)
 d0394b0:	00000106 	br	d0394b8 <alt_read+0x4c>
 d0394b4:	e03fff15 	stw	zero,-4(fp)
 d0394b8:	e0bfff17 	ldw	r2,-4(fp)
 d0394bc:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 d0394c0:	e0bffa17 	ldw	r2,-24(fp)
 d0394c4:	1005003a 	cmpeq	r2,r2,zero
 d0394c8:	1000241e 	bne	r2,zero,d03955c <alt_read+0xf0>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 d0394cc:	e0bffa17 	ldw	r2,-24(fp)
 d0394d0:	10800217 	ldw	r2,8(r2)
 d0394d4:	108000cc 	andi	r2,r2,3
 d0394d8:	10800060 	cmpeqi	r2,r2,1
 d0394dc:	10001a1e 	bne	r2,zero,d039548 <alt_read+0xdc>
 d0394e0:	e0bffa17 	ldw	r2,-24(fp)
 d0394e4:	10800017 	ldw	r2,0(r2)
 d0394e8:	10800517 	ldw	r2,20(r2)
 d0394ec:	1005003a 	cmpeq	r2,r2,zero
 d0394f0:	1000151e 	bne	r2,zero,d039548 <alt_read+0xdc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 d0394f4:	e0bffa17 	ldw	r2,-24(fp)
 d0394f8:	10800017 	ldw	r2,0(r2)
 d0394fc:	10800517 	ldw	r2,20(r2)
 d039500:	e17ffc17 	ldw	r5,-16(fp)
 d039504:	e1bffd17 	ldw	r6,-12(fp)
 d039508:	e13ffa17 	ldw	r4,-24(fp)
 d03950c:	103ee83a 	callr	r2
 d039510:	e0bff915 	stw	r2,-28(fp)
 d039514:	e0bff917 	ldw	r2,-28(fp)
 d039518:	1004403a 	cmpge	r2,r2,zero
 d03951c:	1000071e 	bne	r2,zero,d03953c <alt_read+0xd0>
        {
          ALT_ERRNO = -rval;
 d039520:	d03958c0 	call	d03958c <alt_get_errno>
 d039524:	e0fff917 	ldw	r3,-28(fp)
 d039528:	00c7c83a 	sub	r3,zero,r3
 d03952c:	10c00015 	stw	r3,0(r2)
          return -1;
 d039530:	00bfffc4 	movi	r2,-1
 d039534:	e0bffe15 	stw	r2,-8(fp)
 d039538:	00000e06 	br	d039574 <alt_read+0x108>
        }
        return rval;
 d03953c:	e0bff917 	ldw	r2,-28(fp)
 d039540:	e0bffe15 	stw	r2,-8(fp)
 d039544:	00000b06 	br	d039574 <alt_read+0x108>
      }
      else
      {
        ALT_ERRNO = EACCES;
 d039548:	d03958c0 	call	d03958c <alt_get_errno>
 d03954c:	1007883a 	mov	r3,r2
 d039550:	00800344 	movi	r2,13
 d039554:	18800015 	stw	r2,0(r3)
 d039558:	00000406 	br	d03956c <alt_read+0x100>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 d03955c:	d03958c0 	call	d03958c <alt_get_errno>
 d039560:	1007883a 	mov	r3,r2
 d039564:	00801444 	movi	r2,81
 d039568:	18800015 	stw	r2,0(r3)
  }
  return -1;
 d03956c:	00bfffc4 	movi	r2,-1
 d039570:	e0bffe15 	stw	r2,-8(fp)
 d039574:	e0bffe17 	ldw	r2,-8(fp)
}
 d039578:	e037883a 	mov	sp,fp
 d03957c:	dfc00117 	ldw	ra,4(sp)
 d039580:	df000017 	ldw	fp,0(sp)
 d039584:	dec00204 	addi	sp,sp,8
 d039588:	f800283a 	ret

0d03958c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d03958c:	defffd04 	addi	sp,sp,-12
 d039590:	dfc00215 	stw	ra,8(sp)
 d039594:	df000115 	stw	fp,4(sp)
 d039598:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d03959c:	00834174 	movhi	r2,3333
 d0395a0:	108a6804 	addi	r2,r2,10656
 d0395a4:	10800017 	ldw	r2,0(r2)
 d0395a8:	1005003a 	cmpeq	r2,r2,zero
 d0395ac:	1000061e 	bne	r2,zero,d0395c8 <alt_get_errno+0x3c>
 d0395b0:	00834174 	movhi	r2,3333
 d0395b4:	108a6804 	addi	r2,r2,10656
 d0395b8:	10800017 	ldw	r2,0(r2)
 d0395bc:	103ee83a 	callr	r2
 d0395c0:	e0bfff15 	stw	r2,-4(fp)
 d0395c4:	00000306 	br	d0395d4 <alt_get_errno+0x48>
 d0395c8:	00834174 	movhi	r2,3333
 d0395cc:	108a8404 	addi	r2,r2,10768
 d0395d0:	e0bfff15 	stw	r2,-4(fp)
 d0395d4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0395d8:	e037883a 	mov	sp,fp
 d0395dc:	dfc00117 	ldw	ra,4(sp)
 d0395e0:	df000017 	ldw	fp,0(sp)
 d0395e4:	dec00204 	addi	sp,sp,8
 d0395e8:	f800283a 	ret

0d0395ec <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 d0395ec:	defffe04 	addi	sp,sp,-8
 d0395f0:	df000115 	stw	fp,4(sp)
 d0395f4:	df000104 	addi	fp,sp,4
 d0395f8:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 d0395fc:	e0bfff17 	ldw	r2,-4(fp)
 d039600:	108000d0 	cmplti	r2,r2,3
 d039604:	10000d1e 	bne	r2,zero,d03963c <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 d039608:	e0bfff17 	ldw	r2,-4(fp)
 d03960c:	00c34174 	movhi	r3,3333
 d039610:	18c95d04 	addi	r3,r3,9588
 d039614:	10800324 	muli	r2,r2,12
 d039618:	10c5883a 	add	r2,r2,r3
 d03961c:	10800204 	addi	r2,r2,8
 d039620:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 d039624:	e0bfff17 	ldw	r2,-4(fp)
 d039628:	00c34174 	movhi	r3,3333
 d03962c:	18c95d04 	addi	r3,r3,9588
 d039630:	10800324 	muli	r2,r2,12
 d039634:	10c5883a 	add	r2,r2,r3
 d039638:	10000015 	stw	zero,0(r2)
  }
}
 d03963c:	e037883a 	mov	sp,fp
 d039640:	df000017 	ldw	fp,0(sp)
 d039644:	dec00104 	addi	sp,sp,4
 d039648:	f800283a 	ret

0d03964c <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 d03964c:	defffd04 	addi	sp,sp,-12
 d039650:	df000215 	stw	fp,8(sp)
 d039654:	df000204 	addi	fp,sp,8
 d039658:	e13ffe15 	stw	r4,-8(fp)
 d03965c:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 d039660:	e0bffe17 	ldw	r2,-8(fp)
 d039664:	1007883a 	mov	r3,r2
 d039668:	00a00034 	movhi	r2,32768
 d03966c:	10bfffc4 	addi	r2,r2,-1
 d039670:	1884703a 	and	r2,r3,r2
}
 d039674:	e037883a 	mov	sp,fp
 d039678:	df000017 	ldw	fp,0(sp)
 d03967c:	dec00104 	addi	sp,sp,4
 d039680:	f800283a 	ret

0d039684 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
 d039684:	defffc04 	addi	sp,sp,-16
 d039688:	dfc00315 	stw	ra,12(sp)
 d03968c:	df000215 	stw	fp,8(sp)
 d039690:	df000204 	addi	fp,sp,8
 d039694:	e13ffe15 	stw	r4,-8(fp)
 d039698:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
 d03969c:	e13ffe17 	ldw	r4,-8(fp)
 d0396a0:	e17fff17 	ldw	r5,-4(fp)
 d0396a4:	d038a8c0 	call	d038a8c <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
 d0396a8:	e0bffe17 	ldw	r2,-8(fp)
 d0396ac:	10a00034 	orhi	r2,r2,32768
}
 d0396b0:	e037883a 	mov	sp,fp
 d0396b4:	dfc00117 	ldw	ra,4(sp)
 d0396b8:	df000017 	ldw	fp,0(sp)
 d0396bc:	dec00204 	addi	sp,sp,8
 d0396c0:	f800283a 	ret

0d0396c4 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 d0396c4:	defffa04 	addi	sp,sp,-24
 d0396c8:	df000515 	stw	fp,20(sp)
 d0396cc:	df000504 	addi	fp,sp,20
 d0396d0:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 d0396d4:	0005303a 	rdctl	r2,status
 d0396d8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 d0396dc:	e0fffd17 	ldw	r3,-12(fp)
 d0396e0:	00bfff84 	movi	r2,-2
 d0396e4:	1884703a 	and	r2,r3,r2
 d0396e8:	1001703a 	wrctl	status,r2
  
  return context;
 d0396ec:	e0bffd17 	ldw	r2,-12(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 d0396f0:	e0bffe15 	stw	r2,-8(fp)
  alt_llist_remove (&alarm->llist);
 d0396f4:	e0bfff17 	ldw	r2,-4(fp)
 d0396f8:	e0bffc15 	stw	r2,-16(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 d0396fc:	e0bffc17 	ldw	r2,-16(fp)
 d039700:	10c00017 	ldw	r3,0(r2)
 d039704:	e0bffc17 	ldw	r2,-16(fp)
 d039708:	10800117 	ldw	r2,4(r2)
 d03970c:	18800115 	stw	r2,4(r3)
  entry->previous->next = entry->next;
 d039710:	e0bffc17 	ldw	r2,-16(fp)
 d039714:	10c00117 	ldw	r3,4(r2)
 d039718:	e0bffc17 	ldw	r2,-16(fp)
 d03971c:	10800017 	ldw	r2,0(r2)
 d039720:	18800015 	stw	r2,0(r3)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 d039724:	e0fffc17 	ldw	r3,-16(fp)
 d039728:	e0bffc17 	ldw	r2,-16(fp)
 d03972c:	18800115 	stw	r2,4(r3)
  entry->next     = entry;
 d039730:	e0fffc17 	ldw	r3,-16(fp)
 d039734:	e0bffc17 	ldw	r2,-16(fp)
 d039738:	18800015 	stw	r2,0(r3)
 d03973c:	e0bffe17 	ldw	r2,-8(fp)
 d039740:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 d039744:	e0bffb17 	ldw	r2,-20(fp)
 d039748:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 d03974c:	e037883a 	mov	sp,fp
 d039750:	df000017 	ldw	fp,0(sp)
 d039754:	dec00104 	addi	sp,sp,4
 d039758:	f800283a 	ret

0d03975c <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 d03975c:	defffb04 	addi	sp,sp,-20
 d039760:	dfc00415 	stw	ra,16(sp)
 d039764:	df000315 	stw	fp,12(sp)
 d039768:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 d03976c:	d0a04917 	ldw	r2,-32476(gp)
 d039770:	e0bffe15 	stw	r2,-8(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 d039774:	d0a0b917 	ldw	r2,-32028(gp)
 d039778:	10800044 	addi	r2,r2,1
 d03977c:	d0a0b915 	stw	r2,-32028(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 d039780:	00003106 	br	d039848 <alt_tick+0xec>
  {
    next = (alt_alarm*) alarm->llist.next;
 d039784:	e0bffe17 	ldw	r2,-8(fp)
 d039788:	10800017 	ldw	r2,0(r2)
 d03978c:	e0bfff15 	stw	r2,-4(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 d039790:	e0bffe17 	ldw	r2,-8(fp)
 d039794:	10800403 	ldbu	r2,16(r2)
 d039798:	10803fcc 	andi	r2,r2,255
 d03979c:	1005003a 	cmpeq	r2,r2,zero
 d0397a0:	1000051e 	bne	r2,zero,d0397b8 <alt_tick+0x5c>
 d0397a4:	d0a0b917 	ldw	r2,-32028(gp)
 d0397a8:	1004c03a 	cmpne	r2,r2,zero
 d0397ac:	1000021e 	bne	r2,zero,d0397b8 <alt_tick+0x5c>
    {
      alarm->rollover = 0;
 d0397b0:	e0bffe17 	ldw	r2,-8(fp)
 d0397b4:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 d0397b8:	e0bffe17 	ldw	r2,-8(fp)
 d0397bc:	10c00217 	ldw	r3,8(r2)
 d0397c0:	d0a0b917 	ldw	r2,-32028(gp)
 d0397c4:	10c01e36 	bltu	r2,r3,d039840 <alt_tick+0xe4>
 d0397c8:	e0bffe17 	ldw	r2,-8(fp)
 d0397cc:	10800403 	ldbu	r2,16(r2)
 d0397d0:	10803fcc 	andi	r2,r2,255
 d0397d4:	1004c03a 	cmpne	r2,r2,zero
 d0397d8:	1000191e 	bne	r2,zero,d039840 <alt_tick+0xe4>
    {
      next_callback = alarm->callback (alarm->context);
 d0397dc:	e0bffe17 	ldw	r2,-8(fp)
 d0397e0:	10c00317 	ldw	r3,12(r2)
 d0397e4:	e0bffe17 	ldw	r2,-8(fp)
 d0397e8:	11000517 	ldw	r4,20(r2)
 d0397ec:	183ee83a 	callr	r3
 d0397f0:	e0bffd15 	stw	r2,-12(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 d0397f4:	e0bffd17 	ldw	r2,-12(fp)
 d0397f8:	1004c03a 	cmpne	r2,r2,zero
 d0397fc:	1000031e 	bne	r2,zero,d03980c <alt_tick+0xb0>
      {
        alt_alarm_stop (alarm);
 d039800:	e13ffe17 	ldw	r4,-8(fp)
 d039804:	d0396c40 	call	d0396c4 <alt_alarm_stop>
 d039808:	00000d06 	br	d039840 <alt_tick+0xe4>
      }
      else
      {
        alarm->time += next_callback;
 d03980c:	e0bffe17 	ldw	r2,-8(fp)
 d039810:	10c00217 	ldw	r3,8(r2)
 d039814:	e0bffd17 	ldw	r2,-12(fp)
 d039818:	1887883a 	add	r3,r3,r2
 d03981c:	e0bffe17 	ldw	r2,-8(fp)
 d039820:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 d039824:	e0bffe17 	ldw	r2,-8(fp)
 d039828:	10c00217 	ldw	r3,8(r2)
 d03982c:	d0a0b917 	ldw	r2,-32028(gp)
 d039830:	1880032e 	bgeu	r3,r2,d039840 <alt_tick+0xe4>
        {
          alarm->rollover = 1;
 d039834:	e0fffe17 	ldw	r3,-8(fp)
 d039838:	00800044 	movi	r2,1
 d03983c:	18800405 	stb	r2,16(r3)
        }
      }
    }
    alarm = next;
 d039840:	e0bfff17 	ldw	r2,-4(fp)
 d039844:	e0bffe15 	stw	r2,-8(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 d039848:	d0e04904 	addi	r3,gp,-32476
 d03984c:	e0bffe17 	ldw	r2,-8(fp)
 d039850:	10ffcc1e 	bne	r2,r3,d039784 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 d039854:	d00e4380 	call	d00e438 <OSTimeTick>
}
 d039858:	e037883a 	mov	sp,fp
 d03985c:	dfc00117 	ldw	ra,4(sp)
 d039860:	df000017 	ldw	fp,0(sp)
 d039864:	dec00204 	addi	sp,sp,8
 d039868:	f800283a 	ret

0d03986c <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
 d03986c:	defffb04 	addi	sp,sp,-20
 d039870:	dfc00415 	stw	ra,16(sp)
 d039874:	df000315 	stw	fp,12(sp)
 d039878:	df000304 	addi	fp,sp,12
 d03987c:	e13ffe15 	stw	r4,-8(fp)
  void* ptr;

  ptr = malloc (size);
 d039880:	e13ffe17 	ldw	r4,-8(fp)
 d039884:	d049ec00 	call	d049ec0 <malloc>
 d039888:	e0bffd15 	stw	r2,-12(fp)

  alt_dcache_flush (ptr, size);
 d03988c:	e13ffd17 	ldw	r4,-12(fp)
 d039890:	e17ffe17 	ldw	r5,-8(fp)
 d039894:	d038a8c0 	call	d038a8c <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
 d039898:	e0bffd17 	ldw	r2,-12(fp)
 d03989c:	1005003a 	cmpeq	r2,r2,zero
 d0398a0:	1000041e 	bne	r2,zero,d0398b4 <alt_uncached_malloc+0x48>
 d0398a4:	e0bffd17 	ldw	r2,-12(fp)
 d0398a8:	10a00034 	orhi	r2,r2,32768
 d0398ac:	e0bfff15 	stw	r2,-4(fp)
 d0398b0:	00000106 	br	d0398b8 <alt_uncached_malloc+0x4c>
 d0398b4:	e03fff15 	stw	zero,-4(fp)
 d0398b8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0398bc:	e037883a 	mov	sp,fp
 d0398c0:	dfc00117 	ldw	ra,4(sp)
 d0398c4:	df000017 	ldw	fp,0(sp)
 d0398c8:	dec00204 	addi	sp,sp,8
 d0398cc:	f800283a 	ret

0d0398d0 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 d0398d0:	defffa04 	addi	sp,sp,-24
 d0398d4:	dfc00515 	stw	ra,20(sp)
 d0398d8:	df000415 	stw	fp,16(sp)
 d0398dc:	df000404 	addi	fp,sp,16
 d0398e0:	e13ffe15 	stw	r4,-8(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 d0398e4:	00834174 	movhi	r2,3333
 d0398e8:	108a8c44 	addi	r2,r2,10801
 d0398ec:	10800003 	ldbu	r2,0(r2)
 d0398f0:	10803fcc 	andi	r2,r2,255
 d0398f4:	1004c03a 	cmpne	r2,r2,zero
 d0398f8:	1000041e 	bne	r2,zero,d03990c <usleep+0x3c>
  {
    return alt_busy_sleep (us);
 d0398fc:	e13ffe17 	ldw	r4,-8(fp)
 d039900:	d04862c0 	call	d04862c <alt_busy_sleep>
 d039904:	e0bfff15 	stw	r2,-4(fp)
 d039908:	00003106 	br	d0399d0 <usleep+0x100>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 d03990c:	00834174 	movhi	r2,3333
 d039910:	108ad904 	addi	r2,r2,11108
 d039914:	10800017 	ldw	r2,0(r2)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 d039918:	e0bffc15 	stw	r2,-16(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 d03991c:	e0fffe17 	ldw	r3,-8(fp)
 d039920:	008003f4 	movhi	r2,15
 d039924:	10909004 	addi	r2,r2,16960
 d039928:	1887203a 	divu	r3,r3,r2
 d03992c:	e0bffc17 	ldw	r2,-16(fp)
 d039930:	188b383a 	mul	r5,r3,r2
 d039934:	e13ffe17 	ldw	r4,-8(fp)
 d039938:	008003f4 	movhi	r2,15
 d03993c:	10909004 	addi	r2,r2,16960
 d039940:	2087203a 	divu	r3,r4,r2
 d039944:	008003f4 	movhi	r2,15
 d039948:	10909004 	addi	r2,r2,16960
 d03994c:	1885383a 	mul	r2,r3,r2
 d039950:	2087c83a 	sub	r3,r4,r2
 d039954:	e0bffc17 	ldw	r2,-16(fp)
 d039958:	1887383a 	mul	r3,r3,r2
 d03995c:	008003f4 	movhi	r2,15
 d039960:	10909004 	addi	r2,r2,16960
 d039964:	1885203a 	divu	r2,r3,r2
 d039968:	2885883a 	add	r2,r5,r2
 d03996c:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 d039970:	00000706 	br	d039990 <usleep+0xc0>
  {
    OSTimeDly(0xffff);
 d039974:	013fffd4 	movui	r4,65535
 d039978:	d0153e80 	call	d0153e8 <OSTimeDly>
    ticks -= 0xffff;
 d03997c:	e0bffd17 	ldw	r2,-12(fp)
 d039980:	00fffff4 	movhi	r3,65535
 d039984:	18c00044 	addi	r3,r3,1
 d039988:	10c5883a 	add	r2,r2,r3
 d03998c:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 d039990:	e0fffd17 	ldw	r3,-12(fp)
 d039994:	00bfffd4 	movui	r2,65535
 d039998:	10fff636 	bltu	r2,r3,d039974 <usleep+0xa4>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 d03999c:	e0bffd17 	ldw	r2,-12(fp)
 d0399a0:	113fffcc 	andi	r4,r2,65535
 d0399a4:	d0153e80 	call	d0153e8 <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 d0399a8:	00c003f4 	movhi	r3,15
 d0399ac:	18d09004 	addi	r3,r3,16960
 d0399b0:	e0bffc17 	ldw	r2,-16(fp)
 d0399b4:	1887203a 	divu	r3,r3,r2
 d0399b8:	e13ffe17 	ldw	r4,-8(fp)
 d0399bc:	20c5203a 	divu	r2,r4,r3
 d0399c0:	10c5383a 	mul	r2,r2,r3
 d0399c4:	2089c83a 	sub	r4,r4,r2
 d0399c8:	d04862c0 	call	d04862c <alt_busy_sleep>

  return 0;  
 d0399cc:	e03fff15 	stw	zero,-4(fp)
 d0399d0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0399d4:	e037883a 	mov	sp,fp
 d0399d8:	dfc00117 	ldw	ra,4(sp)
 d0399dc:	df000017 	ldw	fp,0(sp)
 d0399e0:	dec00204 	addi	sp,sp,8
 d0399e4:	f800283a 	ret

0d0399e8 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 d0399e8:	defff704 	addi	sp,sp,-36
 d0399ec:	dfc00815 	stw	ra,32(sp)
 d0399f0:	df000715 	stw	fp,28(sp)
 d0399f4:	df000704 	addi	fp,sp,28
 d0399f8:	e13ffb15 	stw	r4,-20(fp)
 d0399fc:	e17ffc15 	stw	r5,-16(fp)
 d039a00:	e1bffd15 	stw	r6,-12(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d039a04:	e0bffb17 	ldw	r2,-20(fp)
 d039a08:	1004803a 	cmplt	r2,r2,zero
 d039a0c:	1000081e 	bne	r2,zero,d039a30 <alt_write+0x48>
 d039a10:	e0bffb17 	ldw	r2,-20(fp)
 d039a14:	10800324 	muli	r2,r2,12
 d039a18:	1007883a 	mov	r3,r2
 d039a1c:	00834174 	movhi	r2,3333
 d039a20:	10895d04 	addi	r2,r2,9588
 d039a24:	1887883a 	add	r3,r3,r2
 d039a28:	e0ffff15 	stw	r3,-4(fp)
 d039a2c:	00000106 	br	d039a34 <alt_write+0x4c>
 d039a30:	e03fff15 	stw	zero,-4(fp)
 d039a34:	e0bfff17 	ldw	r2,-4(fp)
 d039a38:	e0bffa15 	stw	r2,-24(fp)
  
  if (fd)
 d039a3c:	e0bffa17 	ldw	r2,-24(fp)
 d039a40:	1005003a 	cmpeq	r2,r2,zero
 d039a44:	1000241e 	bne	r2,zero,d039ad8 <alt_write+0xf0>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 d039a48:	e0bffa17 	ldw	r2,-24(fp)
 d039a4c:	10800217 	ldw	r2,8(r2)
 d039a50:	108000cc 	andi	r2,r2,3
 d039a54:	1005003a 	cmpeq	r2,r2,zero
 d039a58:	10001a1e 	bne	r2,zero,d039ac4 <alt_write+0xdc>
 d039a5c:	e0bffa17 	ldw	r2,-24(fp)
 d039a60:	10800017 	ldw	r2,0(r2)
 d039a64:	10800617 	ldw	r2,24(r2)
 d039a68:	1005003a 	cmpeq	r2,r2,zero
 d039a6c:	1000151e 	bne	r2,zero,d039ac4 <alt_write+0xdc>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 d039a70:	e0bffa17 	ldw	r2,-24(fp)
 d039a74:	10800017 	ldw	r2,0(r2)
 d039a78:	10800617 	ldw	r2,24(r2)
 d039a7c:	e17ffc17 	ldw	r5,-16(fp)
 d039a80:	e1bffd17 	ldw	r6,-12(fp)
 d039a84:	e13ffa17 	ldw	r4,-24(fp)
 d039a88:	103ee83a 	callr	r2
 d039a8c:	e0bff915 	stw	r2,-28(fp)
 d039a90:	e0bff917 	ldw	r2,-28(fp)
 d039a94:	1004403a 	cmpge	r2,r2,zero
 d039a98:	1000071e 	bne	r2,zero,d039ab8 <alt_write+0xd0>
      {
        ALT_ERRNO = -rval;
 d039a9c:	d039b080 	call	d039b08 <alt_get_errno>
 d039aa0:	e0fff917 	ldw	r3,-28(fp)
 d039aa4:	00c7c83a 	sub	r3,zero,r3
 d039aa8:	10c00015 	stw	r3,0(r2)
        return -1;
 d039aac:	00bfffc4 	movi	r2,-1
 d039ab0:	e0bffe15 	stw	r2,-8(fp)
 d039ab4:	00000e06 	br	d039af0 <alt_write+0x108>
      }
      return rval;
 d039ab8:	e0bff917 	ldw	r2,-28(fp)
 d039abc:	e0bffe15 	stw	r2,-8(fp)
 d039ac0:	00000b06 	br	d039af0 <alt_write+0x108>
    }
    else
    {
      ALT_ERRNO = EACCES;
 d039ac4:	d039b080 	call	d039b08 <alt_get_errno>
 d039ac8:	1007883a 	mov	r3,r2
 d039acc:	00800344 	movi	r2,13
 d039ad0:	18800015 	stw	r2,0(r3)
 d039ad4:	00000406 	br	d039ae8 <alt_write+0x100>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 d039ad8:	d039b080 	call	d039b08 <alt_get_errno>
 d039adc:	1007883a 	mov	r3,r2
 d039ae0:	00801444 	movi	r2,81
 d039ae4:	18800015 	stw	r2,0(r3)
  }
  return -1;
 d039ae8:	00bfffc4 	movi	r2,-1
 d039aec:	e0bffe15 	stw	r2,-8(fp)
 d039af0:	e0bffe17 	ldw	r2,-8(fp)
}
 d039af4:	e037883a 	mov	sp,fp
 d039af8:	dfc00117 	ldw	ra,4(sp)
 d039afc:	df000017 	ldw	fp,0(sp)
 d039b00:	dec00204 	addi	sp,sp,8
 d039b04:	f800283a 	ret

0d039b08 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d039b08:	defffd04 	addi	sp,sp,-12
 d039b0c:	dfc00215 	stw	ra,8(sp)
 d039b10:	df000115 	stw	fp,4(sp)
 d039b14:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d039b18:	00834174 	movhi	r2,3333
 d039b1c:	108a6804 	addi	r2,r2,10656
 d039b20:	10800017 	ldw	r2,0(r2)
 d039b24:	1005003a 	cmpeq	r2,r2,zero
 d039b28:	1000061e 	bne	r2,zero,d039b44 <alt_get_errno+0x3c>
 d039b2c:	00834174 	movhi	r2,3333
 d039b30:	108a6804 	addi	r2,r2,10656
 d039b34:	10800017 	ldw	r2,0(r2)
 d039b38:	103ee83a 	callr	r2
 d039b3c:	e0bfff15 	stw	r2,-4(fp)
 d039b40:	00000306 	br	d039b50 <alt_get_errno+0x48>
 d039b44:	00834174 	movhi	r2,3333
 d039b48:	108a8404 	addi	r2,r2,10768
 d039b4c:	e0bfff15 	stw	r2,-4(fp)
 d039b50:	e0bfff17 	ldw	r2,-4(fp)
}
 d039b54:	e037883a 	mov	sp,fp
 d039b58:	dfc00117 	ldw	ra,4(sp)
 d039b5c:	df000017 	ldw	fp,0(sp)
 d039b60:	dec00204 	addi	sp,sp,8
 d039b64:	f800283a 	ret

0d039b68 <altera_nios2_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_irq_init(void) 
{
 d039b68:	deffff04 	addi	sp,sp,-4
 d039b6c:	df000015 	stw	fp,0(sp)
 d039b70:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 d039b74:	000170fa 	wrctl	ienable,zero
}
 d039b78:	e037883a 	mov	sp,fp
 d039b7c:	df000017 	ldw	fp,0(sp)
 d039b80:	dec00104 	addi	sp,sp,4
 d039b84:	f800283a 	ret

0d039b88 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 d039b88:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 d039b8c:	d0e00117 	ldw	r3,-32764(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 d039b90:	d1207a17 	ldw	r4,-32280(gp)

      stw ra,  0(sp)
 d039b94:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 d039b98:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 d039b9c:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 d039ba0:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 d039ba4:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 d039ba8:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 d039bac:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 d039bb0:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 d039bb4:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 d039bb8:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 d039bbc:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 d039bc0:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 d039bc4:	d039fa80 	call	d039fa8 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 d039bc8:	d1207517 	ldw	r4,-32300(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 d039bcc:	d1606d07 	ldb	r5,-32332(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 d039bd0:	d1207a15 	stw	r4,-32280(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 d039bd4:	d1606d45 	stb	r5,-32331(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 d039bd8:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 d039bdc:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 d039be0:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 d039be4:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 d039be8:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 d039bec:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 d039bf0:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 d039bf4:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 d039bf8:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 d039bfc:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 d039c00:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 d039c04:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 d039c08:	d0e00115 	stw	r3,-32764(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 d039c0c:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 d039c10:	f800283a 	ret

0d039c14 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 d039c14:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 d039c18:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 d039c1c:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 d039c20:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 d039c24:	d039fa80 	call	d039fa8 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 d039c28:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 d039c2c:	d4a06b45 	stb	r18,-32339(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 d039c30:	003fe506 	br	d039bc8 <OSCtxSw+0x40>

0d039c34 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 d039c34:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 d039c38:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 d039c3c:	10800054 	ori	r2,r2,1
      wrctl status, r2
 d039c40:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 d039c44:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 d039c48:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 d039c4c:	dec00204 	addi	sp,sp,8

      callr r2
 d039c50:	103ee83a 	callr	r2

      nop
 d039c54:	0001883a 	nop

0d039c58 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 d039c58:	defff704 	addi	sp,sp,-36
 d039c5c:	dfc00815 	stw	ra,32(sp)
 d039c60:	df000715 	stw	fp,28(sp)
 d039c64:	df000704 	addi	fp,sp,28
 d039c68:	e13ffc15 	stw	r4,-16(fp)
 d039c6c:	e17ffd15 	stw	r5,-12(fp)
 d039c70:	e1bffe15 	stw	r6,-8(fp)
 d039c74:	e1ffff0d 	sth	r7,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 d039c78:	e0bffe17 	ldw	r2,-8(fp)
 d039c7c:	1007883a 	mov	r3,r2
 d039c80:	00bfff04 	movi	r2,-4
 d039c84:	1884703a 	and	r2,r3,r2
 d039c88:	10bf0004 	addi	r2,r2,-1024
 d039c8c:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 d039c90:	e0bff917 	ldw	r2,-28(fp)
 d039c94:	10000015 	stw	zero,0(r2)
 d039c98:	e0bff917 	ldw	r2,-28(fp)
 d039c9c:	10c0bb04 	addi	r3,r2,748
 d039ca0:	e0bff917 	ldw	r2,-28(fp)
 d039ca4:	10c00115 	stw	r3,4(r2)
 d039ca8:	e0bff917 	ldw	r2,-28(fp)
 d039cac:	1080bb04 	addi	r2,r2,748
 d039cb0:	10c01704 	addi	r3,r2,92
 d039cb4:	e0bff917 	ldw	r2,-28(fp)
 d039cb8:	10c00215 	stw	r3,8(r2)
 d039cbc:	e0bff917 	ldw	r2,-28(fp)
 d039cc0:	1080bb04 	addi	r2,r2,748
 d039cc4:	10c02e04 	addi	r3,r2,184
 d039cc8:	e0bff917 	ldw	r2,-28(fp)
 d039ccc:	10c00315 	stw	r3,12(r2)
 d039cd0:	e0bff917 	ldw	r2,-28(fp)
 d039cd4:	10000415 	stw	zero,16(r2)
 d039cd8:	e0bff917 	ldw	r2,-28(fp)
 d039cdc:	10800504 	addi	r2,r2,20
 d039ce0:	1009883a 	mov	r4,r2
 d039ce4:	01800644 	movi	r6,25
 d039ce8:	000b883a 	mov	r5,zero
 d039cec:	d0028800 	call	d002880 <memset>
 d039cf0:	e0bff917 	ldw	r2,-28(fp)
 d039cf4:	10000c15 	stw	zero,48(r2)
 d039cf8:	e0fff917 	ldw	r3,-28(fp)
 d039cfc:	00834174 	movhi	r2,3333
 d039d00:	10be3904 	addi	r2,r2,-1820
 d039d04:	18800d15 	stw	r2,52(r3)
 d039d08:	e0bff917 	ldw	r2,-28(fp)
 d039d0c:	10000e15 	stw	zero,56(r2)
 d039d10:	e0bff917 	ldw	r2,-28(fp)
 d039d14:	10000f15 	stw	zero,60(r2)
 d039d18:	e0bff917 	ldw	r2,-28(fp)
 d039d1c:	10001015 	stw	zero,64(r2)
 d039d20:	e0bff917 	ldw	r2,-28(fp)
 d039d24:	10001115 	stw	zero,68(r2)
 d039d28:	e0bff917 	ldw	r2,-28(fp)
 d039d2c:	10001215 	stw	zero,72(r2)
 d039d30:	e0bff917 	ldw	r2,-28(fp)
 d039d34:	10001315 	stw	zero,76(r2)
 d039d38:	e0bff917 	ldw	r2,-28(fp)
 d039d3c:	10001415 	stw	zero,80(r2)
 d039d40:	e0bff917 	ldw	r2,-28(fp)
 d039d44:	10001515 	stw	zero,84(r2)
 d039d48:	e0bff917 	ldw	r2,-28(fp)
 d039d4c:	10001615 	stw	zero,88(r2)
 d039d50:	e0bff917 	ldw	r2,-28(fp)
 d039d54:	10001715 	stw	zero,92(r2)
 d039d58:	e0bff917 	ldw	r2,-28(fp)
 d039d5c:	10001805 	stb	zero,96(r2)
 d039d60:	e0bff917 	ldw	r2,-28(fp)
 d039d64:	10801f04 	addi	r2,r2,124
 d039d68:	10000015 	stw	zero,0(r2)
 d039d6c:	10000115 	stw	zero,4(r2)
 d039d70:	10000215 	stw	zero,8(r2)
 d039d74:	10000315 	stw	zero,12(r2)
 d039d78:	10000415 	stw	zero,16(r2)
 d039d7c:	10000515 	stw	zero,20(r2)
 d039d80:	10000615 	stw	zero,24(r2)
 d039d84:	10000715 	stw	zero,28(r2)
 d039d88:	10000815 	stw	zero,32(r2)
 d039d8c:	e0bff917 	ldw	r2,-28(fp)
 d039d90:	10002815 	stw	zero,160(r2)
 d039d94:	e0fff917 	ldw	r3,-28(fp)
 d039d98:	00800044 	movi	r2,1
 d039d9c:	18802915 	stw	r2,164(r3)
 d039da0:	18002a15 	stw	zero,168(r3)
 d039da4:	e0fff917 	ldw	r3,-28(fp)
 d039da8:	008cc384 	movi	r2,13070
 d039dac:	18802b0d 	sth	r2,172(r3)
 d039db0:	e0fff917 	ldw	r3,-28(fp)
 d039db4:	00aaf344 	movi	r2,-21555
 d039db8:	18802b8d 	sth	r2,174(r3)
 d039dbc:	e0fff917 	ldw	r3,-28(fp)
 d039dc0:	00848d04 	movi	r2,4660
 d039dc4:	18802c0d 	sth	r2,176(r3)
 d039dc8:	e0fff917 	ldw	r3,-28(fp)
 d039dcc:	00b99b44 	movi	r2,-6547
 d039dd0:	18802c8d 	sth	r2,178(r3)
 d039dd4:	e0fff917 	ldw	r3,-28(fp)
 d039dd8:	00b7bb04 	movi	r2,-8468
 d039ddc:	18802d0d 	sth	r2,180(r3)
 d039de0:	e0fff917 	ldw	r3,-28(fp)
 d039de4:	00800144 	movi	r2,5
 d039de8:	18802d8d 	sth	r2,182(r3)
 d039dec:	e0fff917 	ldw	r3,-28(fp)
 d039df0:	008002c4 	movi	r2,11
 d039df4:	18802e0d 	sth	r2,184(r3)
 d039df8:	e0bff917 	ldw	r2,-28(fp)
 d039dfc:	10002f15 	stw	zero,188(r2)
 d039e00:	e0bff917 	ldw	r2,-28(fp)
 d039e04:	10003015 	stw	zero,192(r2)
 d039e08:	e0bff917 	ldw	r2,-28(fp)
 d039e0c:	10003115 	stw	zero,196(r2)
 d039e10:	e0bff917 	ldw	r2,-28(fp)
 d039e14:	10003215 	stw	zero,200(r2)
 d039e18:	e0bff917 	ldw	r2,-28(fp)
 d039e1c:	10003315 	stw	zero,204(r2)
 d039e20:	e0bff917 	ldw	r2,-28(fp)
 d039e24:	10003415 	stw	zero,208(r2)
 d039e28:	e0bff917 	ldw	r2,-28(fp)
 d039e2c:	10003e15 	stw	zero,248(r2)
 d039e30:	e0bff917 	ldw	r2,-28(fp)
 d039e34:	10003f15 	stw	zero,252(r2)
 d039e38:	e0bff917 	ldw	r2,-28(fp)
 d039e3c:	10004015 	stw	zero,256(r2)
 d039e40:	e0bff917 	ldw	r2,-28(fp)
 d039e44:	10004115 	stw	zero,260(r2)
 d039e48:	e0bff917 	ldw	r2,-28(fp)
 d039e4c:	10004215 	stw	zero,264(r2)
 d039e50:	e0bff917 	ldw	r2,-28(fp)
 d039e54:	10004315 	stw	zero,268(r2)
 d039e58:	e0bff917 	ldw	r2,-28(fp)
 d039e5c:	10004415 	stw	zero,272(r2)
 d039e60:	e0bff917 	ldw	r2,-28(fp)
 d039e64:	10004515 	stw	zero,276(r2)
 d039e68:	e0bff917 	ldw	r2,-28(fp)
 d039e6c:	10004615 	stw	zero,280(r2)
 d039e70:	e0bff917 	ldw	r2,-28(fp)
 d039e74:	10004715 	stw	zero,284(r2)
 d039e78:	e0bff917 	ldw	r2,-28(fp)
 d039e7c:	10003505 	stb	zero,212(r2)
 d039e80:	e0bff917 	ldw	r2,-28(fp)
 d039e84:	10003705 	stb	zero,220(r2)
 d039e88:	e0bff917 	ldw	r2,-28(fp)
 d039e8c:	10003d15 	stw	zero,244(r2)
 d039e90:	e0bff917 	ldw	r2,-28(fp)
 d039e94:	10005215 	stw	zero,328(r2)
 d039e98:	e0bff917 	ldw	r2,-28(fp)
 d039e9c:	10005315 	stw	zero,332(r2)
 d039ea0:	e0bff917 	ldw	r2,-28(fp)
 d039ea4:	10005415 	stw	zero,336(r2)
 d039ea8:	e0bff917 	ldw	r2,-28(fp)
 d039eac:	10005515 	stw	zero,340(r2)
 d039eb0:	e0bff917 	ldw	r2,-28(fp)
 d039eb4:	1000b515 	stw	zero,724(r2)
 d039eb8:	e0bff917 	ldw	r2,-28(fp)
 d039ebc:	10007515 	stw	zero,468(r2)
 d039ec0:	e0bff917 	ldw	r2,-28(fp)
 d039ec4:	1000b715 	stw	zero,732(r2)
 d039ec8:	e0bff917 	ldw	r2,-28(fp)
 d039ecc:	1000b815 	stw	zero,736(r2)
 d039ed0:	e0bff917 	ldw	r2,-28(fp)
 d039ed4:	1000b915 	stw	zero,740(r2)
 d039ed8:	e0bff917 	ldw	r2,-28(fp)
 d039edc:	1000ba15 	stw	zero,744(r2)
 d039ee0:	e0bff917 	ldw	r2,-28(fp)
 d039ee4:	1080bb04 	addi	r2,r2,748
 d039ee8:	1009883a 	mov	r4,r2
 d039eec:	01804504 	movi	r6,276
 d039ef0:	000b883a 	mov	r5,zero
 d039ef4:	d0028800 	call	d002880 <memset>
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 d039ef8:	e0bff917 	ldw	r2,-28(fp)
 d039efc:	e0bffb15 	stw	r2,-20(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 d039f00:	e0bffb17 	ldw	r2,-20(fp)
 d039f04:	10bff304 	addi	r2,r2,-52
 d039f08:	e0bffa15 	stw	r2,-24(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 d039f0c:	e0bffa17 	ldw	r2,-24(fp)
 d039f10:	10c00c04 	addi	r3,r2,48
 d039f14:	e0bffc17 	ldw	r2,-16(fp)
 d039f18:	18800015 	stw	r2,0(r3)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 d039f1c:	e0bffa17 	ldw	r2,-24(fp)
 d039f20:	10c00b04 	addi	r3,r2,44
 d039f24:	e0bffd17 	ldw	r2,-12(fp)
 d039f28:	18800015 	stw	r2,0(r3)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 d039f2c:	e0bffa17 	ldw	r2,-24(fp)
 d039f30:	10c00a04 	addi	r3,r2,40
 d039f34:	e0bff917 	ldw	r2,-28(fp)
 d039f38:	18800015 	stw	r2,0(r3)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 d039f3c:	00834134 	movhi	r2,3332
 d039f40:	10a70d04 	addi	r2,r2,-25548
 d039f44:	10c00104 	addi	r3,r2,4
 d039f48:	e0bffa17 	ldw	r2,-24(fp)
 d039f4c:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 d039f50:	e0bffa17 	ldw	r2,-24(fp)
}
 d039f54:	e037883a 	mov	sp,fp
 d039f58:	dfc00117 	ldw	ra,4(sp)
 d039f5c:	df000017 	ldw	fp,0(sp)
 d039f60:	dec00204 	addi	sp,sp,8
 d039f64:	f800283a 	ret

0d039f68 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 d039f68:	defffe04 	addi	sp,sp,-8
 d039f6c:	df000115 	stw	fp,4(sp)
 d039f70:	df000104 	addi	fp,sp,4
 d039f74:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 d039f78:	e037883a 	mov	sp,fp
 d039f7c:	df000017 	ldw	fp,0(sp)
 d039f80:	dec00104 	addi	sp,sp,4
 d039f84:	f800283a 	ret

0d039f88 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 d039f88:	defffe04 	addi	sp,sp,-8
 d039f8c:	df000115 	stw	fp,4(sp)
 d039f90:	df000104 	addi	fp,sp,4
 d039f94:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 d039f98:	e037883a 	mov	sp,fp
 d039f9c:	df000017 	ldw	fp,0(sp)
 d039fa0:	dec00104 	addi	sp,sp,4
 d039fa4:	f800283a 	ret

0d039fa8 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 d039fa8:	deffff04 	addi	sp,sp,-4
 d039fac:	df000015 	stw	fp,0(sp)
 d039fb0:	d839883a 	mov	fp,sp
}
 d039fb4:	e037883a 	mov	sp,fp
 d039fb8:	df000017 	ldw	fp,0(sp)
 d039fbc:	dec00104 	addi	sp,sp,4
 d039fc0:	f800283a 	ret

0d039fc4 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 d039fc4:	deffff04 	addi	sp,sp,-4
 d039fc8:	df000015 	stw	fp,0(sp)
 d039fcc:	d839883a 	mov	fp,sp
}
 d039fd0:	e037883a 	mov	sp,fp
 d039fd4:	df000017 	ldw	fp,0(sp)
 d039fd8:	dec00104 	addi	sp,sp,4
 d039fdc:	f800283a 	ret

0d039fe0 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 d039fe0:	defffe04 	addi	sp,sp,-8
 d039fe4:	dfc00115 	stw	ra,4(sp)
 d039fe8:	df000015 	stw	fp,0(sp)
 d039fec:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 d039ff0:	d02957c0 	call	d02957c <cticks_hook>
#endif
}
 d039ff4:	e037883a 	mov	sp,fp
 d039ff8:	dfc00117 	ldw	ra,4(sp)
 d039ffc:	df000017 	ldw	fp,0(sp)
 d03a000:	dec00204 	addi	sp,sp,8
 d03a004:	f800283a 	ret

0d03a008 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 d03a008:	deffff04 	addi	sp,sp,-4
 d03a00c:	df000015 	stw	fp,0(sp)
 d03a010:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 d03a014:	e037883a 	mov	sp,fp
 d03a018:	df000017 	ldw	fp,0(sp)
 d03a01c:	dec00104 	addi	sp,sp,4
 d03a020:	f800283a 	ret

0d03a024 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 d03a024:	deffff04 	addi	sp,sp,-4
 d03a028:	df000015 	stw	fp,0(sp)
 d03a02c:	d839883a 	mov	fp,sp
}
 d03a030:	e037883a 	mov	sp,fp
 d03a034:	df000017 	ldw	fp,0(sp)
 d03a038:	dec00104 	addi	sp,sp,4
 d03a03c:	f800283a 	ret

0d03a040 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 d03a040:	deffff04 	addi	sp,sp,-4
 d03a044:	df000015 	stw	fp,0(sp)
 d03a048:	d839883a 	mov	fp,sp
}
 d03a04c:	e037883a 	mov	sp,fp
 d03a050:	df000017 	ldw	fp,0(sp)
 d03a054:	dec00104 	addi	sp,sp,4
 d03a058:	f800283a 	ret

0d03a05c <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 d03a05c:	defffe04 	addi	sp,sp,-8
 d03a060:	df000115 	stw	fp,4(sp)
 d03a064:	df000104 	addi	fp,sp,4
 d03a068:	e13fff15 	stw	r4,-4(fp)
}
 d03a06c:	e037883a 	mov	sp,fp
 d03a070:	df000017 	ldw	fp,0(sp)
 d03a074:	dec00104 	addi	sp,sp,4
 d03a078:	f800283a 	ret

0d03a07c <alt_program_amd>:
 * then writes Addr, Data Addr, Data etc.
 */
int alt_program_amd(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 d03a07c:	defff704 	addi	sp,sp,-36
 d03a080:	dfc00815 	stw	ra,32(sp)
 d03a084:	df000715 	stw	fp,28(sp)
 d03a088:	df000704 	addi	fp,sp,28
 d03a08c:	e13ffc15 	stw	r4,-16(fp)
 d03a090:	e17ffd15 	stw	r5,-12(fp)
 d03a094:	e1bffe15 	stw	r6,-8(fp)
 d03a098:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 d03a09c:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d03a0a0:	e0bffc17 	ldw	r2,-16(fp)
 d03a0a4:	e0bffa15 	stw	r2,-24(fp)
  
  
  ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 d03a0a8:	e1bfff17 	ldw	r6,-4(fp)
 d03a0ac:	00834134 	movhi	r2,3332
 d03a0b0:	10a90804 	addi	r2,r2,-23520
 d03a0b4:	d8800015 	stw	r2,0(sp)
 d03a0b8:	e13ffa17 	ldw	r4,-24(fp)
 d03a0bc:	e17ffe17 	ldw	r5,-8(fp)
 d03a0c0:	e1c00217 	ldw	r7,8(fp)
 d03a0c4:	d01624c0 	call	d01624c <alt_flash_program_block>
 d03a0c8:	e0bffb15 	stw	r2,-20(fp)
                                    alt_write_word_amd);
  return ret_code;
 d03a0cc:	e0bffb17 	ldw	r2,-20(fp)
}
 d03a0d0:	e037883a 	mov	sp,fp
 d03a0d4:	dfc00117 	ldw	ra,4(sp)
 d03a0d8:	df000017 	ldw	fp,0(sp)
 d03a0dc:	dec00204 	addi	sp,sp,8
 d03a0e0:	f800283a 	ret

0d03a0e4 <alt_erase_block_amd>:
 * alt_erase_block_amd
 * 
 * Erase the selected erase block
 */
int alt_erase_block_amd(alt_flash_dev* flash_info, int block_offset)
{
 d03a0e4:	defff804 	addi	sp,sp,-32
 d03a0e8:	dfc00715 	stw	ra,28(sp)
 d03a0ec:	df000615 	stw	fp,24(sp)
 d03a0f0:	df000604 	addi	fp,sp,24
 d03a0f4:	e13ffe15 	stw	r4,-8(fp)
 d03a0f8:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 d03a0fc:	e03ffc15 	stw	zero,-16(fp)
  int   timeout;
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d03a100:	e0bffe17 	ldw	r2,-8(fp)
 d03a104:	e0bffa15 	stw	r2,-24(fp)
  volatile alt_u8  value;

  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 d03a108:	e0bffa17 	ldw	r2,-24(fp)
 d03a10c:	10c03317 	ldw	r3,204(r2)
 d03a110:	e0bffa17 	ldw	r2,-24(fp)
 d03a114:	11000a17 	ldw	r4,40(r2)
 d03a118:	01415544 	movi	r5,1365
 d03a11c:	01802a84 	movi	r6,170
 d03a120:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 d03a124:	e0bffa17 	ldw	r2,-24(fp)
 d03a128:	10c03317 	ldw	r3,204(r2)
 d03a12c:	e0bffa17 	ldw	r2,-24(fp)
 d03a130:	11000a17 	ldw	r4,40(r2)
 d03a134:	0140aa84 	movi	r5,682
 d03a138:	01801544 	movi	r6,85
 d03a13c:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0x80);
 d03a140:	e0bffa17 	ldw	r2,-24(fp)
 d03a144:	10c03317 	ldw	r3,204(r2)
 d03a148:	e0bffa17 	ldw	r2,-24(fp)
 d03a14c:	11000a17 	ldw	r4,40(r2)
 d03a150:	01415544 	movi	r5,1365
 d03a154:	01802004 	movi	r6,128
 d03a158:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 d03a15c:	e0bffa17 	ldw	r2,-24(fp)
 d03a160:	10c03317 	ldw	r3,204(r2)
 d03a164:	e0bffa17 	ldw	r2,-24(fp)
 d03a168:	11000a17 	ldw	r4,40(r2)
 d03a16c:	01415544 	movi	r5,1365
 d03a170:	01802a84 	movi	r6,170
 d03a174:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 d03a178:	e0bffa17 	ldw	r2,-24(fp)
 d03a17c:	10c03317 	ldw	r3,204(r2)
 d03a180:	e0bffa17 	ldw	r2,-24(fp)
 d03a184:	11000a17 	ldw	r4,40(r2)
 d03a188:	0140aa84 	movi	r5,682
 d03a18c:	01801544 	movi	r6,85
 d03a190:	183ee83a 	callr	r3

  (*flash->write_native)((alt_u8*)flash->dev.base_addr+block_offset, 0x30);
 d03a194:	e0bffa17 	ldw	r2,-24(fp)
 d03a198:	11803517 	ldw	r6,212(r2)
 d03a19c:	e0bffa17 	ldw	r2,-24(fp)
 d03a1a0:	10800a17 	ldw	r2,40(r2)
 d03a1a4:	1007883a 	mov	r3,r2
 d03a1a8:	e0bfff17 	ldw	r2,-4(fp)
 d03a1ac:	1889883a 	add	r4,r3,r2
 d03a1b0:	01400c04 	movi	r5,48
 d03a1b4:	303ee83a 	callr	r6

  /*
   * Delay to meet AM29LV065D timing requirements
   */
  usleep(10000);
 d03a1b8:	0109c404 	movi	r4,10000
 d03a1bc:	d0398d00 	call	d0398d0 <usleep>
  
  /*
   * Bit 3 indicates that the erase command has been accepted
   * this last 50S
   */
  timeout = 50;   
 d03a1c0:	00800c84 	movi	r2,50
 d03a1c4:	e0bffb15 	stw	r2,-20(fp)
  do 
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 d03a1c8:	e0bffa17 	ldw	r2,-24(fp)
 d03a1cc:	10800a17 	ldw	r2,40(r2)
 d03a1d0:	1007883a 	mov	r3,r2
 d03a1d4:	e0bfff17 	ldw	r2,-4(fp)
 d03a1d8:	1885883a 	add	r2,r3,r2
 d03a1dc:	10800023 	ldbuio	r2,0(r2)
 d03a1e0:	e0bffd05 	stb	r2,-12(fp)
    usleep(1000);
 d03a1e4:	0100fa04 	movi	r4,1000
 d03a1e8:	d0398d00 	call	d0398d0 <usleep>
    timeout--;
 d03a1ec:	e0bffb17 	ldw	r2,-20(fp)
 d03a1f0:	10bfffc4 	addi	r2,r2,-1
 d03a1f4:	e0bffb15 	stw	r2,-20(fp)
  }while(!(value & 0x8) && (timeout > 0));
 d03a1f8:	e0bffd03 	ldbu	r2,-12(fp)
 d03a1fc:	10803fcc 	andi	r2,r2,255
 d03a200:	1080020c 	andi	r2,r2,8
 d03a204:	1004c03a 	cmpne	r2,r2,zero
 d03a208:	1000031e 	bne	r2,zero,d03a218 <alt_erase_block_amd+0x134>
 d03a20c:	e0bffb17 	ldw	r2,-20(fp)
 d03a210:	10800048 	cmpgei	r2,r2,1
 d03a214:	103fec1e 	bne	r2,zero,d03a1c8 <alt_erase_block_amd+0xe4>


  timeout = flash->erase_timeout;
 d03a218:	e0bffa17 	ldw	r2,-24(fp)
 d03a21c:	10803117 	ldw	r2,196(r2)
 d03a220:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 d03a224:	00001706 	br	d03a284 <alt_erase_block_amd+0x1a0>
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 d03a228:	e0bffa17 	ldw	r2,-24(fp)
 d03a22c:	10800a17 	ldw	r2,40(r2)
 d03a230:	1007883a 	mov	r3,r2
 d03a234:	e0bfff17 	ldw	r2,-4(fp)
 d03a238:	1885883a 	add	r2,r3,r2
 d03a23c:	10800023 	ldbuio	r2,0(r2)
 d03a240:	e0bffd05 	stb	r2,-12(fp)
    if ((value & 0x80) || (value &0x20))
 d03a244:	e0bffd03 	ldbu	r2,-12(fp)
 d03a248:	10803fcc 	andi	r2,r2,255
 d03a24c:	1080201c 	xori	r2,r2,128
 d03a250:	10bfe004 	addi	r2,r2,-128
 d03a254:	1004803a 	cmplt	r2,r2,zero
 d03a258:	10000d1e 	bne	r2,zero,d03a290 <alt_erase_block_amd+0x1ac>
 d03a25c:	e0bffd03 	ldbu	r2,-12(fp)
 d03a260:	10803fcc 	andi	r2,r2,255
 d03a264:	1080080c 	andi	r2,r2,32
 d03a268:	1004c03a 	cmpne	r2,r2,zero
 d03a26c:	1000081e 	bne	r2,zero,d03a290 <alt_erase_block_amd+0x1ac>
    {
      break;
    }
    usleep(1000);
 d03a270:	0100fa04 	movi	r4,1000
 d03a274:	d0398d00 	call	d0398d0 <usleep>
    timeout -= 1000;
 d03a278:	e0bffb17 	ldw	r2,-20(fp)
 d03a27c:	10bf0604 	addi	r2,r2,-1000
 d03a280:	e0bffb15 	stw	r2,-20(fp)
  
  /*
   *  Bit 7 goes low until the block is erased if bit 5 goes to 
   *  1 it's an error
   */
  while (timeout > 0)
 d03a284:	e0bffb17 	ldw	r2,-20(fp)
 d03a288:	10800048 	cmpgei	r2,r2,1
 d03a28c:	103fe61e 	bne	r2,zero,d03a228 <alt_erase_block_amd+0x144>
    }
    usleep(1000);
    timeout -= 1000;
  }
  
  if (timeout <= 0)
 d03a290:	e0bffb17 	ldw	r2,-20(fp)
 d03a294:	10800048 	cmpgei	r2,r2,1
 d03a298:	1000031e 	bne	r2,zero,d03a2a8 <alt_erase_block_amd+0x1c4>
  {
    ret_code = -ETIMEDOUT;
 d03a29c:	00bfe304 	movi	r2,-116
 d03a2a0:	e0bffc15 	stw	r2,-16(fp)
 d03a2a4:	00000f06 	br	d03a2e4 <alt_erase_block_amd+0x200>
  }
  else
  {
    value = IORD_8DIRECT((alt_u8*)flash->dev.base_addr + block_offset, 0);
 d03a2a8:	e0bffa17 	ldw	r2,-24(fp)
 d03a2ac:	10800a17 	ldw	r2,40(r2)
 d03a2b0:	1007883a 	mov	r3,r2
 d03a2b4:	e0bfff17 	ldw	r2,-4(fp)
 d03a2b8:	1885883a 	add	r2,r3,r2
 d03a2bc:	10800023 	ldbuio	r2,0(r2)
 d03a2c0:	e0bffd05 	stb	r2,-12(fp)
    if (!(value & 0x80))
 d03a2c4:	e0bffd03 	ldbu	r2,-12(fp)
 d03a2c8:	10803fcc 	andi	r2,r2,255
 d03a2cc:	1080201c 	xori	r2,r2,128
 d03a2d0:	10bfe004 	addi	r2,r2,-128
 d03a2d4:	1004803a 	cmplt	r2,r2,zero
 d03a2d8:	1000021e 	bne	r2,zero,d03a2e4 <alt_erase_block_amd+0x200>
    {
      ret_code = -EIO;
 d03a2dc:	00bffec4 	movi	r2,-5
 d03a2e0:	e0bffc15 	stw	r2,-16(fp)
    }
  }    
  
  return ret_code;
 d03a2e4:	e0bffc17 	ldw	r2,-16(fp)
}
 d03a2e8:	e037883a 	mov	sp,fp
 d03a2ec:	dfc00117 	ldw	ra,4(sp)
 d03a2f0:	df000017 	ldw	fp,0(sp)
 d03a2f4:	dec00204 	addi	sp,sp,8
 d03a2f8:	f800283a 	ret

0d03a2fc <alt_wait_for_command_to_complete_amd>:
 */
 
int alt_wait_for_command_to_complete_amd(alt_flash_cfi_dev* flash,
                                         int offset, 
                                          alt_u8 data)
{
 d03a2fc:	defff804 	addi	sp,sp,-32
 d03a300:	dfc00715 	stw	ra,28(sp)
 d03a304:	df000615 	stw	fp,24(sp)
 d03a308:	df000604 	addi	fp,sp,24
 d03a30c:	e13ffd15 	stw	r4,-12(fp)
 d03a310:	e17ffe15 	stw	r5,-8(fp)
 d03a314:	e1bfff05 	stb	r6,-4(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
 d03a318:	e0bffd17 	ldw	r2,-12(fp)
 d03a31c:	10803017 	ldw	r2,192(r2)
 d03a320:	10801924 	muli	r2,r2,100
 d03a324:	e0bffb15 	stw	r2,-20(fp)
  int ret_code = 0;
 d03a328:	e03ffa15 	stw	zero,-24(fp)
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
 d03a32c:	e0bffd17 	ldw	r2,-12(fp)
 d03a330:	10800a17 	ldw	r2,40(r2)
 d03a334:	1007883a 	mov	r3,r2
 d03a338:	e0bffe17 	ldw	r2,-8(fp)
 d03a33c:	1885883a 	add	r2,r3,r2
 d03a340:	10800023 	ldbuio	r2,0(r2)
 d03a344:	e0bffc05 	stb	r2,-16(fp)
  while (timeout > 0)
 d03a348:	00001706 	br	d03a3a8 <alt_wait_for_command_to_complete_amd+0xac>
  {
    if (((value & 0x80 ) == (data &0x80)) ||
 d03a34c:	e0bffc03 	ldbu	r2,-16(fp)
 d03a350:	10803fcc 	andi	r2,r2,255
 d03a354:	10c0200c 	andi	r3,r2,128
 d03a358:	e0bfff03 	ldbu	r2,-4(fp)
 d03a35c:	1080200c 	andi	r2,r2,128
 d03a360:	18801426 	beq	r3,r2,d03a3b4 <alt_wait_for_command_to_complete_amd+0xb8>
 d03a364:	e0bffc03 	ldbu	r2,-16(fp)
 d03a368:	10803fcc 	andi	r2,r2,255
 d03a36c:	1080080c 	andi	r2,r2,32
 d03a370:	1004c03a 	cmpne	r2,r2,zero
 d03a374:	10000f1e 	bne	r2,zero,d03a3b4 <alt_wait_for_command_to_complete_amd+0xb8>
        (value & 0x20))
    {
      break;
    }
    usleep (1);
 d03a378:	01000044 	movi	r4,1
 d03a37c:	d0398d00 	call	d0398d0 <usleep>
    timeout--;
 d03a380:	e0bffb17 	ldw	r2,-20(fp)
 d03a384:	10bfffc4 	addi	r2,r2,-1
 d03a388:	e0bffb15 	stw	r2,-20(fp)
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 d03a38c:	e0bffd17 	ldw	r2,-12(fp)
 d03a390:	10800a17 	ldw	r2,40(r2)
 d03a394:	1007883a 	mov	r3,r2
 d03a398:	e0bffe17 	ldw	r2,-8(fp)
 d03a39c:	1885883a 	add	r2,r3,r2
 d03a3a0:	10800023 	ldbuio	r2,0(r2)
 d03a3a4:	e0bffc05 	stb	r2,-16(fp)
  volatile alt_u8  value;
  int timeout = flash->write_timeout * 100;
  int ret_code = 0;
  
  value = IORD_8DIRECT(flash->dev.base_addr, offset);
  while (timeout > 0)
 d03a3a8:	e0bffb17 	ldw	r2,-20(fp)
 d03a3ac:	10800048 	cmpgei	r2,r2,1
 d03a3b0:	103fe61e 	bne	r2,zero,d03a34c <alt_wait_for_command_to_complete_amd+0x50>
    usleep (1);
    timeout--;
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
  }
  
  if (timeout == 0)
 d03a3b4:	e0bffb17 	ldw	r2,-20(fp)
 d03a3b8:	1004c03a 	cmpne	r2,r2,zero
 d03a3bc:	1000031e 	bne	r2,zero,d03a3cc <alt_wait_for_command_to_complete_amd+0xd0>
  {
    ret_code = -ETIMEDOUT;
 d03a3c0:	00bfe304 	movi	r2,-116
 d03a3c4:	e0bffa15 	stw	r2,-24(fp)
 d03a3c8:	00000f06 	br	d03a408 <alt_wait_for_command_to_complete_amd+0x10c>
  }
  else
  {
    value = IORD_8DIRECT(flash->dev.base_addr, offset);
 d03a3cc:	e0bffd17 	ldw	r2,-12(fp)
 d03a3d0:	10800a17 	ldw	r2,40(r2)
 d03a3d4:	1007883a 	mov	r3,r2
 d03a3d8:	e0bffe17 	ldw	r2,-8(fp)
 d03a3dc:	1885883a 	add	r2,r3,r2
 d03a3e0:	10800023 	ldbuio	r2,0(r2)
 d03a3e4:	e0bffc05 	stb	r2,-16(fp)
    if ((value & 0x80) != (data&0x80))
 d03a3e8:	e0bffc03 	ldbu	r2,-16(fp)
 d03a3ec:	10803fcc 	andi	r2,r2,255
 d03a3f0:	10c0200c 	andi	r3,r2,128
 d03a3f4:	e0bfff03 	ldbu	r2,-4(fp)
 d03a3f8:	1080200c 	andi	r2,r2,128
 d03a3fc:	18800226 	beq	r3,r2,d03a408 <alt_wait_for_command_to_complete_amd+0x10c>
    {
      ret_code = -EIO;
 d03a400:	00bffec4 	movi	r2,-5
 d03a404:	e0bffa15 	stw	r2,-24(fp)
    }
  }    
  return ret_code;
 d03a408:	e0bffa17 	ldw	r2,-24(fp)
}
 d03a40c:	e037883a 	mov	sp,fp
 d03a410:	dfc00117 	ldw	ra,4(sp)
 d03a414:	df000017 	ldw	fp,0(sp)
 d03a418:	dec00204 	addi	sp,sp,8
 d03a41c:	f800283a 	ret

0d03a420 <alt_write_word_amd>:

static int alt_write_word_amd(  alt_flash_cfi_dev* flash, 
                                const int offset, 
                                const alt_u8* src_addr)
{
 d03a420:	defff904 	addi	sp,sp,-28
 d03a424:	dfc00615 	stw	ra,24(sp)
 d03a428:	df000515 	stw	fp,20(sp)
 d03a42c:	df000504 	addi	fp,sp,20
 d03a430:	e13ffd15 	stw	r4,-12(fp)
 d03a434:	e17ffe15 	stw	r5,-8(fp)
 d03a438:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 d03a43c:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 value;
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xAA);
 d03a440:	e0bffd17 	ldw	r2,-12(fp)
 d03a444:	10c03317 	ldw	r3,204(r2)
 d03a448:	e0bffd17 	ldw	r2,-12(fp)
 d03a44c:	11000a17 	ldw	r4,40(r2)
 d03a450:	01415544 	movi	r5,1365
 d03a454:	01802a84 	movi	r6,170
 d03a458:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x2AA, (alt_u8)0x55);
 d03a45c:	e0bffd17 	ldw	r2,-12(fp)
 d03a460:	10c03317 	ldw	r3,204(r2)
 d03a464:	e0bffd17 	ldw	r2,-12(fp)
 d03a468:	11000a17 	ldw	r4,40(r2)
 d03a46c:	0140aa84 	movi	r5,682
 d03a470:	01801544 	movi	r6,85
 d03a474:	183ee83a 	callr	r3
  (*flash->write_command)(flash->dev.base_addr, 0x555, (alt_u8)0xA0);
 d03a478:	e0bffd17 	ldw	r2,-12(fp)
 d03a47c:	10c03317 	ldw	r3,204(r2)
 d03a480:	e0bffd17 	ldw	r2,-12(fp)
 d03a484:	11000a17 	ldw	r4,40(r2)
 d03a488:	01415544 	movi	r5,1365
 d03a48c:	01802804 	movi	r6,160
 d03a490:	183ee83a 	callr	r3
  
  value = *src_addr;
 d03a494:	e0bfff17 	ldw	r2,-4(fp)
 d03a498:	10800003 	ldbu	r2,0(r2)
 d03a49c:	e0bffb05 	stb	r2,-20(fp)

  alt_write_value_to_flash(flash, offset, src_addr);
 d03a4a0:	e13ffd17 	ldw	r4,-12(fp)
 d03a4a4:	e17ffe17 	ldw	r5,-8(fp)
 d03a4a8:	e1bfff17 	ldw	r6,-4(fp)
 d03a4ac:	d0160e80 	call	d0160e8 <alt_write_value_to_flash>
  
  ret_code = alt_wait_for_command_to_complete_amd(flash, 
 d03a4b0:	e1bffb03 	ldbu	r6,-20(fp)
 d03a4b4:	e13ffd17 	ldw	r4,-12(fp)
 d03a4b8:	e17ffe17 	ldw	r5,-8(fp)
 d03a4bc:	d03a2fc0 	call	d03a2fc <alt_wait_for_command_to_complete_amd>
 d03a4c0:	e0bffc15 	stw	r2,-16(fp)
                                                  offset,
                                                  value);
  return ret_code;
 d03a4c4:	e0bffc17 	ldw	r2,-16(fp)
  
}
 d03a4c8:	e037883a 	mov	sp,fp
 d03a4cc:	dfc00117 	ldw	ra,4(sp)
 d03a4d0:	df000017 	ldw	fp,0(sp)
 d03a4d4:	dec00204 	addi	sp,sp,8
 d03a4d8:	f800283a 	ret

0d03a4dc <alt_program_intel>:
 * Program a block (or part of one)
 */
int alt_program_intel(alt_flash_dev* flash_info, int block_offset, 
                int offset, const void* src_addr, 
                int length)
{
 d03a4dc:	defff704 	addi	sp,sp,-36
 d03a4e0:	dfc00815 	stw	ra,32(sp)
 d03a4e4:	df000715 	stw	fp,28(sp)
 d03a4e8:	df000704 	addi	fp,sp,28
 d03a4ec:	e13ffc15 	stw	r4,-16(fp)
 d03a4f0:	e17ffd15 	stw	r5,-12(fp)
 d03a4f4:	e1bffe15 	stw	r6,-8(fp)
 d03a4f8:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 d03a4fc:	e03ffb15 	stw	zero,-20(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d03a500:	e0bffc17 	ldw	r2,-16(fp)
 d03a504:	e0bffa15 	stw	r2,-24(fp)
  
   /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 d03a508:	e13ffa17 	ldw	r4,-24(fp)
 d03a50c:	e17ffd17 	ldw	r5,-12(fp)
 d03a510:	d03a6d40 	call	d03a6d4 <alt_unlock_block_intel>
 d03a514:	e0bffb15 	stw	r2,-20(fp)

  if (!ret_code)
 d03a518:	e0bffb17 	ldw	r2,-20(fp)
 d03a51c:	1004c03a 	cmpne	r2,r2,zero
 d03a520:	1000091e 	bne	r2,zero,d03a548 <alt_program_intel+0x6c>
  {

    ret_code = alt_flash_program_block( flash, offset, src_addr, length, 
 d03a524:	e1bfff17 	ldw	r6,-4(fp)
 d03a528:	00834134 	movhi	r2,3332
 d03a52c:	10aa1804 	addi	r2,r2,-22432
 d03a530:	d8800015 	stw	r2,0(sp)
 d03a534:	e13ffa17 	ldw	r4,-24(fp)
 d03a538:	e17ffe17 	ldw	r5,-8(fp)
 d03a53c:	e1c00217 	ldw	r7,8(fp)
 d03a540:	d01624c0 	call	d01624c <alt_flash_program_block>
 d03a544:	e0bffb15 	stw	r2,-20(fp)
                                        alt_write_word_intel);
  }
  
  return ret_code;
 d03a548:	e0bffb17 	ldw	r2,-20(fp)
}
 d03a54c:	e037883a 	mov	sp,fp
 d03a550:	dfc00117 	ldw	ra,4(sp)
 d03a554:	df000017 	ldw	fp,0(sp)
 d03a558:	dec00204 	addi	sp,sp,8
 d03a55c:	f800283a 	ret

0d03a560 <alt_erase_block_intel>:
 * alt_erase_block_intel
 * 
 * Erase the selected erase block
 */
int alt_erase_block_intel(alt_flash_dev* flash_info, int block_offset)
{
 d03a560:	defff804 	addi	sp,sp,-32
 d03a564:	dfc00715 	stw	ra,28(sp)
 d03a568:	df000615 	stw	fp,24(sp)
 d03a56c:	df000604 	addi	fp,sp,24
 d03a570:	e13ffe15 	stw	r4,-8(fp)
 d03a574:	e17fff15 	stw	r5,-4(fp)
  int   ret_code = 0;
 d03a578:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_cfi_dev* flash = (alt_flash_cfi_dev*)flash_info;
 d03a57c:	e0bffe17 	ldw	r2,-8(fp)
 d03a580:	e0bffb15 	stw	r2,-20(fp)
  volatile alt_u8  status;
  int   timeout = flash->erase_timeout;
 d03a584:	e0bffb17 	ldw	r2,-20(fp)
 d03a588:	10803117 	ldw	r2,196(r2)
 d03a58c:	e0bffa15 	stw	r2,-24(fp)

  /*
  * If this block is locked then unlock it
  */
  ret_code = alt_unlock_block_intel(flash, block_offset);
 d03a590:	e13ffb17 	ldw	r4,-20(fp)
 d03a594:	e17fff17 	ldw	r5,-4(fp)
 d03a598:	d03a6d40 	call	d03a6d4 <alt_unlock_block_intel>
 d03a59c:	e0bffc15 	stw	r2,-16(fp)

  if (!ret_code)
 d03a5a0:	e0bffc17 	ldw	r2,-16(fp)
 d03a5a4:	1004c03a 	cmpne	r2,r2,zero
 d03a5a8:	1000441e 	bne	r2,zero,d03a6bc <alt_erase_block_intel+0x15c>
  {

    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x20);
 d03a5ac:	e0bffb17 	ldw	r2,-20(fp)
 d03a5b0:	11803517 	ldw	r6,212(r2)
 d03a5b4:	e0bffb17 	ldw	r2,-20(fp)
 d03a5b8:	10800a17 	ldw	r2,40(r2)
 d03a5bc:	1007883a 	mov	r3,r2
 d03a5c0:	e0bfff17 	ldw	r2,-4(fp)
 d03a5c4:	1889883a 	add	r4,r3,r2
 d03a5c8:	01400804 	movi	r5,32
 d03a5cc:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 d03a5d0:	e0bffb17 	ldw	r2,-20(fp)
 d03a5d4:	11803517 	ldw	r6,212(r2)
 d03a5d8:	e0bffb17 	ldw	r2,-20(fp)
 d03a5dc:	10800a17 	ldw	r2,40(r2)
 d03a5e0:	1007883a 	mov	r3,r2
 d03a5e4:	e0bfff17 	ldw	r2,-4(fp)
 d03a5e8:	1889883a 	add	r4,r3,r2
 d03a5ec:	01403404 	movi	r5,208
 d03a5f0:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 d03a5f4:	e0bffb17 	ldw	r2,-20(fp)
 d03a5f8:	10800a17 	ldw	r2,40(r2)
 d03a5fc:	1007883a 	mov	r3,r2
 d03a600:	e0bfff17 	ldw	r2,-4(fp)
 d03a604:	1885883a 	add	r2,r3,r2
 d03a608:	10800023 	ldbuio	r2,0(r2)
 d03a60c:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 d03a610:	e0bffd03 	ldbu	r2,-12(fp)
 d03a614:	10803fcc 	andi	r2,r2,255
 d03a618:	1080201c 	xori	r2,r2,128
 d03a61c:	10bfe004 	addi	r2,r2,-128
 d03a620:	1004803a 	cmplt	r2,r2,zero
 d03a624:	1000081e 	bne	r2,zero,d03a648 <alt_erase_block_intel+0xe8>
      {
        break;
      }
      usleep(1000);
 d03a628:	0100fa04 	movi	r4,1000
 d03a62c:	d0398d00 	call	d0398d0 <usleep>
      timeout -= 1000;
 d03a630:	e0bffa17 	ldw	r2,-24(fp)
 d03a634:	10bf0604 	addi	r2,r2,-1000
 d03a638:	e0bffa15 	stw	r2,-24(fp)
    }while(timeout > 0);
 d03a63c:	e0bffa17 	ldw	r2,-24(fp)
 d03a640:	10800048 	cmpgei	r2,r2,1
 d03a644:	103feb1e 	bne	r2,zero,d03a5f4 <alt_erase_block_intel+0x94>
    
    if (timeout <= 0)
 d03a648:	e0bffa17 	ldw	r2,-24(fp)
 d03a64c:	10800048 	cmpgei	r2,r2,1
 d03a650:	1000031e 	bne	r2,zero,d03a660 <alt_erase_block_intel+0x100>
    {
      ret_code = -ETIMEDOUT;
 d03a654:	00bfe304 	movi	r2,-116
 d03a658:	e0bffc15 	stw	r2,-16(fp)
 d03a65c:	00000e06 	br	d03a698 <alt_erase_block_intel+0x138>
    }
    else if (status & 0x7f)
 d03a660:	e0bffd03 	ldbu	r2,-12(fp)
 d03a664:	10803fcc 	andi	r2,r2,255
 d03a668:	10801fcc 	andi	r2,r2,127
 d03a66c:	1005003a 	cmpeq	r2,r2,zero
 d03a670:	1000091e 	bne	r2,zero,d03a698 <alt_erase_block_intel+0x138>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 d03a674:	00bffec4 	movi	r2,-5
 d03a678:	e0bffc15 	stw	r2,-16(fp)
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 d03a67c:	e0bffb17 	ldw	r2,-20(fp)
 d03a680:	10800a17 	ldw	r2,40(r2)
 d03a684:	1007883a 	mov	r3,r2
 d03a688:	e0bfff17 	ldw	r2,-4(fp)
 d03a68c:	1885883a 	add	r2,r3,r2
 d03a690:	10800023 	ldbuio	r2,0(r2)
 d03a694:	e0bffd05 	stb	r2,-12(fp)
    }

    /* Put the device back into read array mode */
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 d03a698:	e0bffb17 	ldw	r2,-20(fp)
 d03a69c:	11803517 	ldw	r6,212(r2)
 d03a6a0:	e0bffb17 	ldw	r2,-20(fp)
 d03a6a4:	10800a17 	ldw	r2,40(r2)
 d03a6a8:	1007883a 	mov	r3,r2
 d03a6ac:	e0bfff17 	ldw	r2,-4(fp)
 d03a6b0:	1889883a 	add	r4,r3,r2
 d03a6b4:	01403fc4 	movi	r5,255
 d03a6b8:	303ee83a 	callr	r6
  }
  
  return ret_code;
 d03a6bc:	e0bffc17 	ldw	r2,-16(fp)
}
 d03a6c0:	e037883a 	mov	sp,fp
 d03a6c4:	dfc00117 	ldw	ra,4(sp)
 d03a6c8:	df000017 	ldw	fp,0(sp)
 d03a6cc:	dec00204 	addi	sp,sp,8
 d03a6d0:	f800283a 	ret

0d03a6d4 <alt_unlock_block_intel>:
/*
* Private Intel specific functions
*/

static int alt_unlock_block_intel(alt_flash_cfi_dev* flash, int block_offset)
{
 d03a6d4:	defff904 	addi	sp,sp,-28
 d03a6d8:	dfc00615 	stw	ra,24(sp)
 d03a6dc:	df000515 	stw	fp,20(sp)
 d03a6e0:	df000504 	addi	fp,sp,20
 d03a6e4:	e13ffe15 	stw	r4,-8(fp)
 d03a6e8:	e17fff15 	stw	r5,-4(fp)
  alt_u8  locked;
  alt_u8  status;
  int ret_code = 0;
 d03a6ec:	e03ffc15 	stw	zero,-16(fp)
  int timeout = flash->write_timeout * 100;
 d03a6f0:	e0bffe17 	ldw	r2,-8(fp)
 d03a6f4:	10803017 	ldw	r2,192(r2)
 d03a6f8:	10801924 	muli	r2,r2,100
 d03a6fc:	e0bffb15 	stw	r2,-20(fp)


  /*
  * Is this block locked?
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x90);
 d03a700:	e0bffe17 	ldw	r2,-8(fp)
 d03a704:	11803517 	ldw	r6,212(r2)
 d03a708:	e0bffe17 	ldw	r2,-8(fp)
 d03a70c:	10800a17 	ldw	r2,40(r2)
 d03a710:	1007883a 	mov	r3,r2
 d03a714:	e0bfff17 	ldw	r2,-4(fp)
 d03a718:	1889883a 	add	r4,r3,r2
 d03a71c:	01402404 	movi	r5,144
 d03a720:	303ee83a 	callr	r6
  locked = IORD_8DIRECT(flash->dev.base_addr, block_offset + 4);
 d03a724:	e0bffe17 	ldw	r2,-8(fp)
 d03a728:	10800a17 	ldw	r2,40(r2)
 d03a72c:	1007883a 	mov	r3,r2
 d03a730:	e0bfff17 	ldw	r2,-4(fp)
 d03a734:	1885883a 	add	r2,r3,r2
 d03a738:	10800104 	addi	r2,r2,4
 d03a73c:	10800023 	ldbuio	r2,0(r2)
 d03a740:	e0bffd45 	stb	r2,-11(fp)
  if (locked & 0x1)
 d03a744:	e0bffd43 	ldbu	r2,-11(fp)
 d03a748:	1080004c 	andi	r2,r2,1
 d03a74c:	10803fcc 	andi	r2,r2,255
 d03a750:	1005003a 	cmpeq	r2,r2,zero
 d03a754:	1000331e 	bne	r2,zero,d03a824 <alt_unlock_block_intel+0x150>
  {
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0x60);
 d03a758:	e0bffe17 	ldw	r2,-8(fp)
 d03a75c:	11803517 	ldw	r6,212(r2)
 d03a760:	e0bffe17 	ldw	r2,-8(fp)
 d03a764:	10800a17 	ldw	r2,40(r2)
 d03a768:	1007883a 	mov	r3,r2
 d03a76c:	e0bfff17 	ldw	r2,-4(fp)
 d03a770:	1889883a 	add	r4,r3,r2
 d03a774:	01401804 	movi	r5,96
 d03a778:	303ee83a 	callr	r6
    flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xD0);
 d03a77c:	e0bffe17 	ldw	r2,-8(fp)
 d03a780:	11803517 	ldw	r6,212(r2)
 d03a784:	e0bffe17 	ldw	r2,-8(fp)
 d03a788:	10800a17 	ldw	r2,40(r2)
 d03a78c:	1007883a 	mov	r3,r2
 d03a790:	e0bfff17 	ldw	r2,-4(fp)
 d03a794:	1889883a 	add	r4,r3,r2
 d03a798:	01403404 	movi	r5,208
 d03a79c:	303ee83a 	callr	r6

    do
    {
      status = IORD_8DIRECT(flash->dev.base_addr, block_offset);
 d03a7a0:	e0bffe17 	ldw	r2,-8(fp)
 d03a7a4:	10800a17 	ldw	r2,40(r2)
 d03a7a8:	1007883a 	mov	r3,r2
 d03a7ac:	e0bfff17 	ldw	r2,-4(fp)
 d03a7b0:	1885883a 	add	r2,r3,r2
 d03a7b4:	10800023 	ldbuio	r2,0(r2)
 d03a7b8:	e0bffd05 	stb	r2,-12(fp)
      if (status & 0x80)
 d03a7bc:	e0bffd03 	ldbu	r2,-12(fp)
 d03a7c0:	10803fcc 	andi	r2,r2,255
 d03a7c4:	1080201c 	xori	r2,r2,128
 d03a7c8:	10bfe004 	addi	r2,r2,-128
 d03a7cc:	1004803a 	cmplt	r2,r2,zero
 d03a7d0:	1000081e 	bne	r2,zero,d03a7f4 <alt_unlock_block_intel+0x120>
      {
        break;
      }
      timeout--;
 d03a7d4:	e0bffb17 	ldw	r2,-20(fp)
 d03a7d8:	10bfffc4 	addi	r2,r2,-1
 d03a7dc:	e0bffb15 	stw	r2,-20(fp)
      usleep(1);
 d03a7e0:	01000044 	movi	r4,1
 d03a7e4:	d0398d00 	call	d0398d0 <usleep>
    }while(timeout > 0);
 d03a7e8:	e0bffb17 	ldw	r2,-20(fp)
 d03a7ec:	10800048 	cmpgei	r2,r2,1
 d03a7f0:	103feb1e 	bne	r2,zero,d03a7a0 <alt_unlock_block_intel+0xcc>

    if (timeout == 0)
 d03a7f4:	e0bffb17 	ldw	r2,-20(fp)
 d03a7f8:	1004c03a 	cmpne	r2,r2,zero
 d03a7fc:	1000031e 	bne	r2,zero,d03a80c <alt_unlock_block_intel+0x138>
    {
      ret_code = -ETIMEDOUT;
 d03a800:	00bfe304 	movi	r2,-116
 d03a804:	e0bffc15 	stw	r2,-16(fp)
 d03a808:	00000606 	br	d03a824 <alt_unlock_block_intel+0x150>
    }
    else if (status & 0x7f)
 d03a80c:	e0bffd03 	ldbu	r2,-12(fp)
 d03a810:	10801fcc 	andi	r2,r2,127
 d03a814:	1005003a 	cmpeq	r2,r2,zero
 d03a818:	1000021e 	bne	r2,zero,d03a824 <alt_unlock_block_intel+0x150>
    {
      /* If we have an error of some kind bomb out */
      ret_code = -EIO;
 d03a81c:	00bffec4 	movi	r2,-5
 d03a820:	e0bffc15 	stw	r2,-16(fp)
  }

  /*
  * Back to Read Array mode
  */
  flash->write_native((alt_u8*)flash->dev.base_addr + block_offset, 0xFF);
 d03a824:	e0bffe17 	ldw	r2,-8(fp)
 d03a828:	11803517 	ldw	r6,212(r2)
 d03a82c:	e0bffe17 	ldw	r2,-8(fp)
 d03a830:	10800a17 	ldw	r2,40(r2)
 d03a834:	1007883a 	mov	r3,r2
 d03a838:	e0bfff17 	ldw	r2,-4(fp)
 d03a83c:	1889883a 	add	r4,r3,r2
 d03a840:	01403fc4 	movi	r5,255
 d03a844:	303ee83a 	callr	r6

  return ret_code;
 d03a848:	e0bffc17 	ldw	r2,-16(fp)
}
 d03a84c:	e037883a 	mov	sp,fp
 d03a850:	dfc00117 	ldw	ra,4(sp)
 d03a854:	df000017 	ldw	fp,0(sp)
 d03a858:	dec00204 	addi	sp,sp,8
 d03a85c:	f800283a 	ret

0d03a860 <alt_write_word_intel>:
 * offset bytes into the flash
 */
 
int alt_write_word_intel( alt_flash_cfi_dev* flash, 
                                  const int offset, const alt_u8* src_addr)
{ 
 d03a860:	defff904 	addi	sp,sp,-28
 d03a864:	dfc00615 	stw	ra,24(sp)
 d03a868:	df000515 	stw	fp,20(sp)
 d03a86c:	df000504 	addi	fp,sp,20
 d03a870:	e13ffd15 	stw	r4,-12(fp)
 d03a874:	e17ffe15 	stw	r5,-8(fp)
 d03a878:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 d03a87c:	e03ffc15 	stw	zero,-16(fp)
  alt_u8 status;
  (*flash->write_native)((alt_u8*)flash->dev.base_addr+offset, 0x40);
 d03a880:	e0bffd17 	ldw	r2,-12(fp)
 d03a884:	11803517 	ldw	r6,212(r2)
 d03a888:	e0bffd17 	ldw	r2,-12(fp)
 d03a88c:	10800a17 	ldw	r2,40(r2)
 d03a890:	1007883a 	mov	r3,r2
 d03a894:	e0bffe17 	ldw	r2,-8(fp)
 d03a898:	1889883a 	add	r4,r3,r2
 d03a89c:	01401004 	movi	r5,64
 d03a8a0:	303ee83a 	callr	r6
  alt_write_value_to_flash(flash, offset, src_addr);
 d03a8a4:	e13ffd17 	ldw	r4,-12(fp)
 d03a8a8:	e17ffe17 	ldw	r5,-8(fp)
 d03a8ac:	e1bfff17 	ldw	r6,-4(fp)
 d03a8b0:	d0160e80 	call	d0160e8 <alt_write_value_to_flash>

  do
  {
    status = IORD_8DIRECT(flash->dev.base_addr, offset);
 d03a8b4:	e0bffd17 	ldw	r2,-12(fp)
 d03a8b8:	10800a17 	ldw	r2,40(r2)
 d03a8bc:	1007883a 	mov	r3,r2
 d03a8c0:	e0bffe17 	ldw	r2,-8(fp)
 d03a8c4:	1885883a 	add	r2,r3,r2
 d03a8c8:	10800023 	ldbuio	r2,0(r2)
 d03a8cc:	e0bffb05 	stb	r2,-20(fp)
  }while(!(status & 0x80));
 d03a8d0:	e0bffb03 	ldbu	r2,-20(fp)
 d03a8d4:	10803fcc 	andi	r2,r2,255
 d03a8d8:	1080201c 	xori	r2,r2,128
 d03a8dc:	10bfe004 	addi	r2,r2,-128
 d03a8e0:	1004403a 	cmpge	r2,r2,zero
 d03a8e4:	103ff31e 	bne	r2,zero,d03a8b4 <alt_write_word_intel+0x54>

  /* If we have an error of some kind bomb out */
  if (status & 0x7f)
 d03a8e8:	e0bffb03 	ldbu	r2,-20(fp)
 d03a8ec:	10801fcc 	andi	r2,r2,127
 d03a8f0:	1005003a 	cmpeq	r2,r2,zero
 d03a8f4:	1000021e 	bne	r2,zero,d03a900 <alt_write_word_intel+0xa0>
  {
    ret_code = -EIO;
 d03a8f8:	00bffec4 	movi	r2,-5
 d03a8fc:	e0bffc15 	stw	r2,-16(fp)
  }

  /* Put the device back into read array mode */
  flash->write_native((alt_u8*)flash->dev.base_addr + offset, 0xFF);
 d03a900:	e0bffd17 	ldw	r2,-12(fp)
 d03a904:	11803517 	ldw	r6,212(r2)
 d03a908:	e0bffd17 	ldw	r2,-12(fp)
 d03a90c:	10800a17 	ldw	r2,40(r2)
 d03a910:	1007883a 	mov	r3,r2
 d03a914:	e0bffe17 	ldw	r2,-8(fp)
 d03a918:	1889883a 	add	r4,r3,r2
 d03a91c:	01403fc4 	movi	r5,255
 d03a920:	303ee83a 	callr	r6
  
  return ret_code;
 d03a924:	e0bffc17 	ldw	r2,-16(fp)
}
 d03a928:	e037883a 	mov	sp,fp
 d03a92c:	dfc00117 	ldw	ra,4(sp)
 d03a930:	df000017 	ldw	fp,0(sp)
 d03a934:	dec00204 	addi	sp,sp,8
 d03a938:	f800283a 	ret

0d03a93c <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 d03a93c:	defffb04 	addi	sp,sp,-20
 d03a940:	dfc00415 	stw	ra,16(sp)
 d03a944:	df000315 	stw	fp,12(sp)
 d03a948:	dc000215 	stw	r16,8(sp)
 d03a94c:	df000204 	addi	fp,sp,8
   int   e = 0;
 d03a950:	e03fff15 	stw	zero,-4(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 d03a954:	d1204b17 	ldw	r4,-32468(gp)
 d03a958:	d002cc00 	call	d002cc0 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 d03a95c:	01034174 	movhi	r4,3333
 d03a960:	213e4504 	addi	r4,r4,-1772
 d03a964:	d002cc00 	call	d002cc0 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 d03a968:	d029d2c0 	call	d029d2c <pre_task_setup>
 d03a96c:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 d03a970:	e0bffe17 	ldw	r2,-8(fp)
 d03a974:	1005003a 	cmpeq	r2,r2,zero
 d03a978:	1000021e 	bne	r2,zero,d03a984 <netmain_init+0x48>
      panic(msg);
 d03a97c:	e13ffe17 	ldw	r4,-8(fp)
 d03a980:	d0246440 	call	d024644 <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 d03a984:	d0221780 	call	d022178 <ip_startup>
 d03a988:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 d03a98c:	e0bffe17 	ldw	r2,-8(fp)
 d03a990:	1005003a 	cmpeq	r2,r2,zero
 d03a994:	1000071e 	bne	r2,zero,d03a9b4 <netmain_init+0x78>
   {
      printf("inet startup error: %s\n", msg);
 d03a998:	01034174 	movhi	r4,3333
 d03a99c:	213e5704 	addi	r4,r4,-1700
 d03a9a0:	e17ffe17 	ldw	r5,-8(fp)
 d03a9a4:	d0029980 	call	d002998 <printf>
      panic("IP");
 d03a9a8:	01034174 	movhi	r4,3333
 d03a9ac:	213e5d04 	addi	r4,r4,-1676
 d03a9b0:	d0246440 	call	d024644 <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 d03a9b4:	d0454ac0 	call	d0454ac <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 d03a9b8:	d044a780 	call	d044a78 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 d03a9bc:	00834174 	movhi	r2,3333
 d03a9c0:	108aa404 	addi	r2,r2,10896
 d03a9c4:	10000015 	stw	zero,0(r2)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 d03a9c8:	008341b4 	movhi	r2,3334
 d03a9cc:	10b4e604 	addi	r2,r2,-11368
 d03a9d0:	10800017 	ldw	r2,0(r2)
 d03a9d4:	14000104 	addi	r16,r2,4
 d03a9d8:	008341b4 	movhi	r2,3334
 d03a9dc:	10b4e604 	addi	r2,r2,-11368
 d03a9e0:	10800017 	ldw	r2,0(r2)
 d03a9e4:	11000a17 	ldw	r4,40(r2)
 d03a9e8:	d02448c0 	call	d02448c <print_ipad>
 d03a9ec:	100d883a 	mov	r6,r2
 d03a9f0:	01034174 	movhi	r4,3333
 d03a9f4:	213e5e04 	addi	r4,r4,-1672
 d03a9f8:	800b883a 	mov	r5,r16
 d03a9fc:	d0029980 	call	d002998 <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 d03aa00:	d029da00 	call	d029da0 <post_task_setup>
 d03aa04:	e0bffe15 	stw	r2,-8(fp)
   if (msg)
 d03aa08:	e0bffe17 	ldw	r2,-8(fp)
 d03aa0c:	1005003a 	cmpeq	r2,r2,zero
 d03aa10:	1000021e 	bne	r2,zero,d03aa1c <netmain_init+0xe0>
      panic(msg);
 d03aa14:	e13ffe17 	ldw	r4,-8(fp)
 d03aa18:	d0246440 	call	d024644 <panic>
#ifdef USE_AUTOIP
   Upnp_init();      /* start Auto IP before DHCP client */
#endif   /* USE_AUTOIP */

#ifdef DHCP_CLIENT
   dhc_setup();   /* kick off any DHCP clients */
 d03aa1c:	d0451240 	call	d045124 <dhc_setup>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 d03aa20:	e037883a 	mov	sp,fp
 d03aa24:	dfc00217 	ldw	ra,8(sp)
 d03aa28:	df000117 	ldw	fp,4(sp)
 d03aa2c:	dc000017 	ldw	r16,0(sp)
 d03aa30:	dec00304 	addi	sp,sp,12
 d03aa34:	f800283a 	ret

0d03aa38 <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 d03aa38:	defffb04 	addi	sp,sp,-20
 d03aa3c:	dfc00415 	stw	ra,16(sp)
 d03aa40:	df000315 	stw	fp,12(sp)
 d03aa44:	dc000215 	stw	r16,8(sp)
 d03aa48:	df000204 	addi	fp,sp,8
 d03aa4c:	e13ffe15 	stw	r4,-8(fp)
 d03aa50:	e17fff15 	stw	r5,-4(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 d03aa54:	e0bfff17 	ldw	r2,-4(fp)
 d03aa58:	10800003 	ldbu	r2,0(r2)
 d03aa5c:	10803fcc 	andi	r2,r2,255
 d03aa60:	1080201c 	xori	r2,r2,128
 d03aa64:	10bfe004 	addi	r2,r2,-128
 d03aa68:	00c34174 	movhi	r3,3333
 d03aa6c:	18c9bd04 	addi	r3,r3,9972
 d03aa70:	1085883a 	add	r2,r2,r2
 d03aa74:	1085883a 	add	r2,r2,r2
 d03aa78:	10c5883a 	add	r2,r2,r3
 d03aa7c:	14000017 	ldw	r16,0(r2)
 d03aa80:	e0bffe17 	ldw	r2,-8(fp)
 d03aa84:	11000717 	ldw	r4,28(r2)
 d03aa88:	d02448c0 	call	d02448c <print_ipad>
 d03aa8c:	100d883a 	mov	r6,r2
 d03aa90:	01034174 	movhi	r4,3333
 d03aa94:	213e6e04 	addi	r4,r4,-1608
 d03aa98:	800b883a 	mov	r5,r16
 d03aa9c:	d0029980 	call	d002998 <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 d03aaa0:	d1204c17 	ldw	r4,-32464(gp)
 d03aaa4:	d0029980 	call	d002998 <printf>
}
 d03aaa8:	e037883a 	mov	sp,fp
 d03aaac:	dfc00217 	ldw	ra,8(sp)
 d03aab0:	df000117 	ldw	fp,4(sp)
 d03aab4:	dc000017 	ldw	r16,0(sp)
 d03aab8:	dec00304 	addi	sp,sp,12
 d03aabc:	f800283a 	ret

0d03aac0 <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 d03aac0:	defff904 	addi	sp,sp,-28
 d03aac4:	dfc00615 	stw	ra,24(sp)
 d03aac8:	df000515 	stw	fp,20(sp)
 d03aacc:	dc000415 	stw	r16,16(sp)
 d03aad0:	df000404 	addi	fp,sp,16
 d03aad4:	e13fff15 	stw	r4,-4(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 d03aad8:	e03ffe15 	stw	zero,-8(fp)
 d03aadc:	008341b4 	movhi	r2,3334
 d03aae0:	10b4e604 	addi	r2,r2,-11368
 d03aae4:	10800017 	ldw	r2,0(r2)
 d03aae8:	e0bffd15 	stw	r2,-12(fp)
 d03aaec:	00002206 	br	d03ab78 <station_state+0xb8>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 d03aaf0:	e0bffd17 	ldw	r2,-12(fp)
 d03aaf4:	14000104 	addi	r16,r2,4
 d03aaf8:	e0bffd17 	ldw	r2,-12(fp)
 d03aafc:	11000a17 	ldw	r4,40(r2)
 d03ab00:	d02448c0 	call	d02448c <print_ipad>
 d03ab04:	d8800015 	stw	r2,0(sp)
 d03ab08:	e13fff17 	ldw	r4,-4(fp)
 d03ab0c:	01434174 	movhi	r5,3333
 d03ab10:	297e7704 	addi	r5,r5,-1572
 d03ab14:	e1bffe17 	ldw	r6,-8(fp)
 d03ab18:	800f883a 	mov	r7,r16
 d03ab1c:	d02486c0 	call	d02486c <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 d03ab20:	e0bffd17 	ldw	r2,-12(fp)
 d03ab24:	11000c17 	ldw	r4,48(r2)
 d03ab28:	d02448c0 	call	d02448c <print_ipad>
 d03ab2c:	100d883a 	mov	r6,r2
 d03ab30:	e13fff17 	ldw	r4,-4(fp)
 d03ab34:	01434174 	movhi	r5,3333
 d03ab38:	297e7e04 	addi	r5,r5,-1544
 d03ab3c:	d02486c0 	call	d02486c <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 d03ab40:	e0bffd17 	ldw	r2,-12(fp)
 d03ab44:	11000d17 	ldw	r4,52(r2)
 d03ab48:	d02448c0 	call	d02448c <print_ipad>
 d03ab4c:	100d883a 	mov	r6,r2
 d03ab50:	e13fff17 	ldw	r4,-4(fp)
 d03ab54:	01434174 	movhi	r5,3333
 d03ab58:	297e8104 	addi	r5,r5,-1532
 d03ab5c:	d02486c0 	call	d02486c <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 d03ab60:	e0bffd17 	ldw	r2,-12(fp)
 d03ab64:	10800017 	ldw	r2,0(r2)
 d03ab68:	e0bffd15 	stw	r2,-12(fp)
 d03ab6c:	e0bffe17 	ldw	r2,-8(fp)
 d03ab70:	10800044 	addi	r2,r2,1
 d03ab74:	e0bffe15 	stw	r2,-8(fp)
 d03ab78:	e0bffd17 	ldw	r2,-12(fp)
 d03ab7c:	1004c03a 	cmpne	r2,r2,zero
 d03ab80:	103fdb1e 	bne	r2,zero,d03aaf0 <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 d03ab84:	00834174 	movhi	r2,3333
 d03ab88:	108ac904 	addi	r2,r2,11044
 d03ab8c:	11800017 	ldw	r6,0(r2)
 d03ab90:	e13fff17 	ldw	r4,-4(fp)
 d03ab94:	01434174 	movhi	r5,3333
 d03ab98:	297e8404 	addi	r5,r5,-1520
 d03ab9c:	d02486c0 	call	d02486c <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 d03aba0:	d1a04d17 	ldw	r6,-32460(gp)
 d03aba4:	d0a04d17 	ldw	r2,-32460(gp)
 d03aba8:	11c002a4 	muli	r7,r2,10
 d03abac:	e13fff17 	ldw	r4,-4(fp)
 d03abb0:	01434174 	movhi	r5,3333
 d03abb4:	297e8a04 	addi	r5,r5,-1496
 d03abb8:	d02486c0 	call	d02486c <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 d03abbc:	d120ba17 	ldw	r4,-32024(gp)
 d03abc0:	d02448c0 	call	d02448c <print_ipad>
 d03abc4:	100d883a 	mov	r6,r2
 d03abc8:	e13fff17 	ldw	r4,-4(fp)
 d03abcc:	01434174 	movhi	r5,3333
 d03abd0:	297e9604 	addi	r5,r5,-1448
 d03abd4:	d02486c0 	call	d02486c <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 d03abd8:	d1a04e17 	ldw	r6,-32456(gp)
 d03abdc:	e13fff17 	ldw	r4,-4(fp)
 d03abe0:	01434174 	movhi	r5,3333
 d03abe4:	297e9d04 	addi	r5,r5,-1420
 d03abe8:	d02486c0 	call	d02486c <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 d03abec:	e13fff17 	ldw	r4,-4(fp)
 d03abf0:	d03b19c0 	call	d03b19c <task_stats>

   return 0;
 d03abf4:	0005883a 	mov	r2,zero
}
 d03abf8:	e037883a 	mov	sp,fp
 d03abfc:	dfc00217 	ldw	ra,8(sp)
 d03ac00:	df000117 	ldw	fp,4(sp)
 d03ac04:	dc000017 	ldw	r16,0(sp)
 d03ac08:	dec00304 	addi	sp,sp,12
 d03ac0c:	f800283a 	ret

0d03ac10 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 d03ac10:	deffff04 	addi	sp,sp,-4
 d03ac14:	df000015 	stw	fp,0(sp)
 d03ac18:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 d03ac1c:	00834174 	movhi	r2,3333
 d03ac20:	108ac904 	addi	r2,r2,11044
 d03ac24:	10c00017 	ldw	r3,0(r2)
 d03ac28:	00801904 	movi	r2,100
 d03ac2c:	1885203a 	divu	r2,r3,r2
 d03ac30:	10801924 	muli	r2,r2,100
}
 d03ac34:	e037883a 	mov	sp,fp
 d03ac38:	df000017 	ldw	fp,0(sp)
 d03ac3c:	dec00104 	addi	sp,sp,4
 d03ac40:	f800283a 	ret

0d03ac44 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 d03ac44:	defffe04 	addi	sp,sp,-8
 d03ac48:	dfc00115 	stw	ra,4(sp)
 d03ac4c:	df000015 	stw	fp,0(sp)
 d03ac50:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 d03ac54:	d0a0bb17 	ldw	r2,-32020(gp)
 d03ac58:	1004c03a 	cmpne	r2,r2,zero
 d03ac5c:	1000071e 	bne	r2,zero,d03ac7c <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 d03ac60:	d0a0bb17 	ldw	r2,-32020(gp)
 d03ac64:	10800044 	addi	r2,r2,1
 d03ac68:	d0a0bb15 	stw	r2,-32020(gp)
   pktdemux();          /* process low level packet input */
 d03ac6c:	d021b300 	call	d021b30 <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 d03ac70:	d0a0bb17 	ldw	r2,-32020(gp)
 d03ac74:	10bfffc4 	addi	r2,r2,-1
 d03ac78:	d0a0bb15 	stw	r2,-32020(gp)
}
 d03ac7c:	e037883a 	mov	sp,fp
 d03ac80:	dfc00117 	ldw	ra,4(sp)
 d03ac84:	df000017 	ldw	fp,0(sp)
 d03ac88:	dec00204 	addi	sp,sp,8
 d03ac8c:	f800283a 	ret

0d03ac90 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 d03ac90:	defffe04 	addi	sp,sp,-8
 d03ac94:	df000115 	stw	fp,4(sp)
 d03ac98:	df000104 	addi	fp,sp,4
 d03ac9c:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 d03aca0:	0005883a 	mov	r2,zero
}
 d03aca4:	e037883a 	mov	sp,fp
 d03aca8:	df000017 	ldw	fp,0(sp)
 d03acac:	dec00104 	addi	sp,sp,4
 d03acb0:	f800283a 	ret

0d03acb4 <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 d03acb4:	defffd04 	addi	sp,sp,-12
 d03acb8:	dfc00215 	stw	ra,8(sp)
 d03acbc:	df000115 	stw	fp,4(sp)
 d03acc0:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 d03acc4:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 d03acc8:	d0486080 	call	d048608 <prep_vfs>
 d03accc:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 d03acd0:	e0bfff17 	ldw	r2,-4(fp)
 d03acd4:	1005003a 	cmpeq	r2,r2,zero
 d03acd8:	1000061e 	bne	r2,zero,d03acf4 <prep_modules+0x40>
   {
      dprintf("VFS Module prep failed\n");
 d03acdc:	01034174 	movhi	r4,3333
 d03ace0:	213ea504 	addi	r4,r4,-1388
 d03ace4:	d002cc00 	call	d002cc0 <puts>
      panic("prep_modules");
 d03ace8:	01034174 	movhi	r4,3333
 d03acec:	213eab04 	addi	r4,r4,-1364
 d03acf0:	d0246440 	call	d024644 <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 d03acf4:	0005883a 	mov	r2,zero
}
 d03acf8:	e037883a 	mov	sp,fp
 d03acfc:	dfc00117 	ldw	ra,4(sp)
 d03ad00:	df000017 	ldw	fp,0(sp)
 d03ad04:	dec00204 	addi	sp,sp,8
 d03ad08:	f800283a 	ret

0d03ad0c <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 d03ad0c:	defffe04 	addi	sp,sp,-8
 d03ad10:	dfc00115 	stw	ra,4(sp)
 d03ad14:	df000015 	stw	fp,0(sp)
 d03ad18:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 d03ad1c:	00834174 	movhi	r2,3333
 d03ad20:	108aea04 	addi	r2,r2,11176
 d03ad24:	10c00017 	ldw	r3,0(r2)
 d03ad28:	00834174 	movhi	r2,3333
 d03ad2c:	108ac904 	addi	r2,r2,11044
 d03ad30:	10800017 	ldw	r2,0(r2)
 d03ad34:	1880012e 	bgeu	r3,r2,d03ad3c <inet_timer+0x30>
      ip_reasm_process_timer_tick ();
 d03ad38:	d0402b00 	call	d0402b0 <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 d03ad3c:	d02b9700 	call	d02b970 <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 d03ad40:	d03add00 	call	d03add0 <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 d03ad44:	00834174 	movhi	r2,3333
 d03ad48:	108aa804 	addi	r2,r2,10912
 d03ad4c:	10c00017 	ldw	r3,0(r2)
 d03ad50:	00834174 	movhi	r2,3333
 d03ad54:	108ac904 	addi	r2,r2,11044
 d03ad58:	10800017 	ldw	r2,0(r2)
 d03ad5c:	1880012e 	bgeu	r3,r2,d03ad64 <inet_timer+0x58>
      igmp_fasttimo();
 d03ad60:	d0227d00 	call	d0227d0 <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 d03ad64:	d0a0bc17 	ldw	r2,-32016(gp)
 d03ad68:	00c34174 	movhi	r3,3333
 d03ad6c:	18cac904 	addi	r3,r3,11044
 d03ad70:	18c00017 	ldw	r3,0(r3)
 d03ad74:	10c00636 	bltu	r2,r3,d03ad90 <inet_timer+0x84>
 d03ad78:	00834174 	movhi	r2,3333
 d03ad7c:	108ac904 	addi	r2,r2,11044
 d03ad80:	10800017 	ldw	r2,0(r2)
 d03ad84:	10c0fa04 	addi	r3,r2,1000
 d03ad88:	d0a0bc17 	ldw	r2,-32016(gp)
 d03ad8c:	18800b2e 	bgeu	r3,r2,d03adbc <inet_timer+0xb0>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 d03ad90:	00834174 	movhi	r2,3333
 d03ad94:	108ac904 	addi	r2,r2,11044
 d03ad98:	10800017 	ldw	r2,0(r2)
 d03ad9c:	10801904 	addi	r2,r2,100
 d03ada0:	d0a0bc15 	stw	r2,-32016(gp)

      if (port_1s_callout != NULL)
 d03ada4:	d0a0bd17 	ldw	r2,-32012(gp)
 d03ada8:	1005003a 	cmpeq	r2,r2,zero
 d03adac:	1000021e 	bne	r2,zero,d03adb8 <inet_timer+0xac>
         (*port_1s_callout)();
 d03adb0:	d0a0bd17 	ldw	r2,-32012(gp)
 d03adb4:	103ee83a 	callr	r2

#ifdef USE_PPP
      ppp_timeisup();
#endif
#ifdef DHCP_CLIENT
      dhc_second();
 d03adb8:	d027a400 	call	d027a40 <dhc_second>
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 d03adbc:	e037883a 	mov	sp,fp
 d03adc0:	dfc00117 	ldw	ra,4(sp)
 d03adc4:	df000017 	ldw	fp,0(sp)
 d03adc8:	dec00204 	addi	sp,sp,8
 d03adcc:	f800283a 	ret

0d03add0 <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 d03add0:	defffc04 	addi	sp,sp,-16
 d03add4:	dfc00315 	stw	ra,12(sp)
 d03add8:	df000215 	stw	fp,8(sp)
 d03addc:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 d03ade0:	e03ffe15 	stw	zero,-8(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 d03ade4:	d0a0be17 	ldw	r2,-32008(gp)
 d03ade8:	10800050 	cmplti	r2,r2,1
 d03adec:	1000591e 	bne	r2,zero,d03af54 <check_interval_timers+0x184>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 d03adf0:	e03fff15 	stw	zero,-4(fp)
 d03adf4:	00005406 	br	d03af48 <check_interval_timers+0x178>
      {
         if (intimers[i].callback)   /* is this timer active? */
 d03adf8:	e0bfff17 	ldw	r2,-4(fp)
 d03adfc:	00c341b4 	movhi	r3,3334
 d03ae00:	18f48d04 	addi	r3,r3,-11724
 d03ae04:	10800524 	muli	r2,r2,20
 d03ae08:	10c5883a 	add	r2,r2,r3
 d03ae0c:	10800017 	ldw	r2,0(r2)
 d03ae10:	1005003a 	cmpeq	r2,r2,zero
 d03ae14:	1000491e 	bne	r2,zero,d03af3c <check_interval_timers+0x16c>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 d03ae18:	e0bfff17 	ldw	r2,-4(fp)
 d03ae1c:	00c341b4 	movhi	r3,3334
 d03ae20:	18f48d04 	addi	r3,r3,-11724
 d03ae24:	10800524 	muli	r2,r2,20
 d03ae28:	10c5883a 	add	r2,r2,r3
 d03ae2c:	10800304 	addi	r2,r2,12
 d03ae30:	10c00017 	ldw	r3,0(r2)
 d03ae34:	00834174 	movhi	r2,3333
 d03ae38:	108ac904 	addi	r2,r2,11044
 d03ae3c:	10800017 	ldw	r2,0(r2)
 d03ae40:	1880382e 	bgeu	r3,r2,d03af24 <check_interval_timers+0x154>
 d03ae44:	e0bfff17 	ldw	r2,-4(fp)
 d03ae48:	00c341b4 	movhi	r3,3334
 d03ae4c:	18f48d04 	addi	r3,r3,-11724
 d03ae50:	10800524 	muli	r2,r2,20
 d03ae54:	10c5883a 	add	r2,r2,r3
 d03ae58:	10800404 	addi	r2,r2,16
 d03ae5c:	10800017 	ldw	r2,0(r2)
 d03ae60:	1004c03a 	cmpne	r2,r2,zero
 d03ae64:	10002f1e 	bne	r2,zero,d03af24 <check_interval_timers+0x154>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 d03ae68:	e17fff17 	ldw	r5,-4(fp)
 d03ae6c:	e0bfff17 	ldw	r2,-4(fp)
 d03ae70:	00c341b4 	movhi	r3,3334
 d03ae74:	18f48d04 	addi	r3,r3,-11724
 d03ae78:	10800524 	muli	r2,r2,20
 d03ae7c:	10c5883a 	add	r2,r2,r3
 d03ae80:	10800204 	addi	r2,r2,8
 d03ae84:	10c00017 	ldw	r3,0(r2)
 d03ae88:	00834174 	movhi	r2,3333
 d03ae8c:	108ac904 	addi	r2,r2,11044
 d03ae90:	10800017 	ldw	r2,0(r2)
 d03ae94:	1889883a 	add	r4,r3,r2
 d03ae98:	00c341b4 	movhi	r3,3334
 d03ae9c:	18f48d04 	addi	r3,r3,-11724
 d03aea0:	28800524 	muli	r2,r5,20
 d03aea4:	10c5883a 	add	r2,r2,r3
 d03aea8:	10800304 	addi	r2,r2,12
 d03aeac:	11000015 	stw	r4,0(r2)
               intimers[i].inuse = TRUE;
 d03aeb0:	e0bfff17 	ldw	r2,-4(fp)
 d03aeb4:	00c341b4 	movhi	r3,3334
 d03aeb8:	18f48d04 	addi	r3,r3,-11724
 d03aebc:	10800524 	muli	r2,r2,20
 d03aec0:	10c5883a 	add	r2,r2,r3
 d03aec4:	10c00404 	addi	r3,r2,16
 d03aec8:	00800044 	movi	r2,1
 d03aecc:	18800015 	stw	r2,0(r3)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 d03aed0:	e0bfff17 	ldw	r2,-4(fp)
 d03aed4:	00c341b4 	movhi	r3,3334
 d03aed8:	18f48d04 	addi	r3,r3,-11724
 d03aedc:	10800524 	muli	r2,r2,20
 d03aee0:	10c5883a 	add	r2,r2,r3
 d03aee4:	11400017 	ldw	r5,0(r2)
 d03aee8:	e0bfff17 	ldw	r2,-4(fp)
 d03aeec:	00c341b4 	movhi	r3,3334
 d03aef0:	18f48d04 	addi	r3,r3,-11724
 d03aef4:	10800524 	muli	r2,r2,20
 d03aef8:	10c5883a 	add	r2,r2,r3
 d03aefc:	10800104 	addi	r2,r2,4
 d03af00:	11000017 	ldw	r4,0(r2)
 d03af04:	283ee83a 	callr	r5
               intimers[i].inuse = FALSE;
 d03af08:	e0bfff17 	ldw	r2,-4(fp)
 d03af0c:	00c341b4 	movhi	r3,3334
 d03af10:	18f48d04 	addi	r3,r3,-11724
 d03af14:	10800524 	muli	r2,r2,20
 d03af18:	10c5883a 	add	r2,r2,r3
 d03af1c:	10800404 	addi	r2,r2,16
 d03af20:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 d03af24:	e0bffe17 	ldw	r2,-8(fp)
 d03af28:	10800044 	addi	r2,r2,1
 d03af2c:	e0bffe15 	stw	r2,-8(fp)
 d03af30:	d0e0be17 	ldw	r3,-32008(gp)
 d03af34:	e0bffe17 	ldw	r2,-8(fp)
 d03af38:	10c0060e 	bge	r2,r3,d03af54 <check_interval_timers+0x184>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 d03af3c:	e0bfff17 	ldw	r2,-4(fp)
 d03af40:	10800044 	addi	r2,r2,1
 d03af44:	e0bfff15 	stw	r2,-4(fp)
 d03af48:	e0bfff17 	ldw	r2,-4(fp)
 d03af4c:	10800150 	cmplti	r2,r2,5
 d03af50:	103fa91e 	bne	r2,zero,d03adf8 <check_interval_timers+0x28>
            if (++found >= numtimers)
               break;
         }
      }
   }
}
 d03af54:	e037883a 	mov	sp,fp
 d03af58:	dfc00117 	ldw	ra,4(sp)
 d03af5c:	df000017 	ldw	fp,0(sp)
 d03af60:	dec00204 	addi	sp,sp,8
 d03af64:	f800283a 	ret

0d03af68 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 d03af68:	defffa04 	addi	sp,sp,-24
 d03af6c:	df000515 	stw	fp,20(sp)
 d03af70:	df000504 	addi	fp,sp,20
 d03af74:	e13ffc15 	stw	r4,-16(fp)
 d03af78:	e17ffd15 	stw	r5,-12(fp)
 d03af7c:	e1bffe15 	stw	r6,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 d03af80:	e03ffb15 	stw	zero,-20(fp)
 d03af84:	00004906 	br	d03b0ac <in_timerset+0x144>
   {
      if(intimers[i].callback == NULL)
 d03af88:	e0bffb17 	ldw	r2,-20(fp)
 d03af8c:	00c341b4 	movhi	r3,3334
 d03af90:	18f48d04 	addi	r3,r3,-11724
 d03af94:	10800524 	muli	r2,r2,20
 d03af98:	10c5883a 	add	r2,r2,r3
 d03af9c:	10800017 	ldw	r2,0(r2)
 d03afa0:	1004c03a 	cmpne	r2,r2,zero
 d03afa4:	10003e1e 	bne	r2,zero,d03b0a0 <in_timerset+0x138>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 d03afa8:	e0bffb17 	ldw	r2,-20(fp)
 d03afac:	00c341b4 	movhi	r3,3334
 d03afb0:	18f48d04 	addi	r3,r3,-11724
 d03afb4:	10800524 	muli	r2,r2,20
 d03afb8:	10c7883a 	add	r3,r2,r3
 d03afbc:	e0bffc17 	ldw	r2,-16(fp)
 d03afc0:	18800015 	stw	r2,0(r3)
         intimers[i].parm = parm;
 d03afc4:	e0bffb17 	ldw	r2,-20(fp)
 d03afc8:	00c341b4 	movhi	r3,3334
 d03afcc:	18f48d04 	addi	r3,r3,-11724
 d03afd0:	10800524 	muli	r2,r2,20
 d03afd4:	10c5883a 	add	r2,r2,r3
 d03afd8:	10c00104 	addi	r3,r2,4
 d03afdc:	e0bffe17 	ldw	r2,-8(fp)
 d03afe0:	18800015 	stw	r2,0(r3)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 d03afe4:	e17ffb17 	ldw	r5,-20(fp)
 d03afe8:	e0bffd17 	ldw	r2,-12(fp)
 d03afec:	10c01924 	muli	r3,r2,100
 d03aff0:	0080fa04 	movi	r2,1000
 d03aff4:	1889203a 	divu	r4,r3,r2
 d03aff8:	00c341b4 	movhi	r3,3334
 d03affc:	18f48d04 	addi	r3,r3,-11724
 d03b000:	28800524 	muli	r2,r5,20
 d03b004:	10c5883a 	add	r2,r2,r3
 d03b008:	10800204 	addi	r2,r2,8
 d03b00c:	11000015 	stw	r4,0(r2)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 d03b010:	e17ffb17 	ldw	r5,-20(fp)
 d03b014:	e0bffb17 	ldw	r2,-20(fp)
 d03b018:	00c341b4 	movhi	r3,3334
 d03b01c:	18f48d04 	addi	r3,r3,-11724
 d03b020:	10800524 	muli	r2,r2,20
 d03b024:	10c5883a 	add	r2,r2,r3
 d03b028:	10800204 	addi	r2,r2,8
 d03b02c:	10c00017 	ldw	r3,0(r2)
 d03b030:	00834174 	movhi	r2,3333
 d03b034:	108ac904 	addi	r2,r2,11044
 d03b038:	10800017 	ldw	r2,0(r2)
 d03b03c:	1889883a 	add	r4,r3,r2
 d03b040:	00c341b4 	movhi	r3,3334
 d03b044:	18f48d04 	addi	r3,r3,-11724
 d03b048:	28800524 	muli	r2,r5,20
 d03b04c:	10c5883a 	add	r2,r2,r3
 d03b050:	10800304 	addi	r2,r2,12
 d03b054:	11000015 	stw	r4,0(r2)
		 intimers[i].inuse = FALSE;
 d03b058:	e0bffb17 	ldw	r2,-20(fp)
 d03b05c:	00c341b4 	movhi	r3,3334
 d03b060:	18f48d04 	addi	r3,r3,-11724
 d03b064:	10800524 	muli	r2,r2,20
 d03b068:	10c5883a 	add	r2,r2,r3
 d03b06c:	10800404 	addi	r2,r2,16
 d03b070:	10000015 	stw	zero,0(r2)
         numtimers++;
 d03b074:	d0a0be17 	ldw	r2,-32008(gp)
 d03b078:	10800044 	addi	r2,r2,1
 d03b07c:	d0a0be15 	stw	r2,-32008(gp)
         return (long)&intimers[i];
 d03b080:	e0bffb17 	ldw	r2,-20(fp)
 d03b084:	10800524 	muli	r2,r2,20
 d03b088:	1007883a 	mov	r3,r2
 d03b08c:	008341b4 	movhi	r2,3334
 d03b090:	10b48d04 	addi	r2,r2,-11724
 d03b094:	1885883a 	add	r2,r3,r2
 d03b098:	e0bfff15 	stw	r2,-4(fp)
 d03b09c:	00000706 	br	d03b0bc <in_timerset+0x154>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 d03b0a0:	e0bffb17 	ldw	r2,-20(fp)
 d03b0a4:	10800044 	addi	r2,r2,1
 d03b0a8:	e0bffb15 	stw	r2,-20(fp)
 d03b0ac:	e0bffb17 	ldw	r2,-20(fp)
 d03b0b0:	10800150 	cmplti	r2,r2,5
 d03b0b4:	103fb41e 	bne	r2,zero,d03af88 <in_timerset+0x20>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 d03b0b8:	e03fff15 	stw	zero,-4(fp)
 d03b0bc:	e0bfff17 	ldw	r2,-4(fp)
}
 d03b0c0:	e037883a 	mov	sp,fp
 d03b0c4:	df000017 	ldw	fp,0(sp)
 d03b0c8:	dec00104 	addi	sp,sp,4
 d03b0cc:	f800283a 	ret

0d03b0d0 <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 d03b0d0:	defffb04 	addi	sp,sp,-20
 d03b0d4:	dfc00415 	stw	ra,16(sp)
 d03b0d8:	df000315 	stw	fp,12(sp)
 d03b0dc:	df000304 	addi	fp,sp,12
 d03b0e0:	e13ffe15 	stw	r4,-8(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 d03b0e4:	e03ffd15 	stw	zero,-12(fp)
 d03b0e8:	00001706 	br	d03b148 <in_timerkill+0x78>
   {
      if(timer == (long)&intimers[i])
 d03b0ec:	e0bffd17 	ldw	r2,-12(fp)
 d03b0f0:	10800524 	muli	r2,r2,20
 d03b0f4:	1007883a 	mov	r3,r2
 d03b0f8:	008341b4 	movhi	r2,3334
 d03b0fc:	10b48d04 	addi	r2,r2,-11724
 d03b100:	1885883a 	add	r2,r3,r2
 d03b104:	1007883a 	mov	r3,r2
 d03b108:	e0bffe17 	ldw	r2,-8(fp)
 d03b10c:	18800b1e 	bne	r3,r2,d03b13c <in_timerkill+0x6c>
      {
         intimers[i].callback = NULL;
 d03b110:	e0bffd17 	ldw	r2,-12(fp)
 d03b114:	00c341b4 	movhi	r3,3334
 d03b118:	18f48d04 	addi	r3,r3,-11724
 d03b11c:	10800524 	muli	r2,r2,20
 d03b120:	10c5883a 	add	r2,r2,r3
 d03b124:	10000015 	stw	zero,0(r2)
         numtimers--;
 d03b128:	d0a0be17 	ldw	r2,-32008(gp)
 d03b12c:	10bfffc4 	addi	r2,r2,-1
 d03b130:	d0a0be15 	stw	r2,-32008(gp)
         return 0;      /* OK return */
 d03b134:	e03fff15 	stw	zero,-4(fp)
 d03b138:	00000906 	br	d03b160 <in_timerkill+0x90>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 d03b13c:	e0bffd17 	ldw	r2,-12(fp)
 d03b140:	10800044 	addi	r2,r2,1
 d03b144:	e0bffd15 	stw	r2,-12(fp)
 d03b148:	e0bffd17 	ldw	r2,-12(fp)
 d03b14c:	10800150 	cmplti	r2,r2,5
 d03b150:	103fe61e 	bne	r2,zero,d03b0ec <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 d03b154:	d0293e80 	call	d0293e8 <dtrap>
   return ENP_PARAM;
 d03b158:	00bffd84 	movi	r2,-10
 d03b15c:	e0bfff15 	stw	r2,-4(fp)
 d03b160:	e0bfff17 	ldw	r2,-4(fp)
}
 d03b164:	e037883a 	mov	sp,fp
 d03b168:	dfc00117 	ldw	ra,4(sp)
 d03b16c:	df000017 	ldw	fp,0(sp)
 d03b170:	dec00204 	addi	sp,sp,8
 d03b174:	f800283a 	ret

0d03b178 <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 d03b178:	defffe04 	addi	sp,sp,-8
 d03b17c:	df000115 	stw	fp,4(sp)
 d03b180:	df000104 	addi	fp,sp,4
int e = 0;
 d03b184:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 d03b188:	e0bfff17 	ldw	r2,-4(fp)
}
 d03b18c:	e037883a 	mov	sp,fp
 d03b190:	df000017 	ldw	fp,0(sp)
 d03b194:	dec00104 	addi	sp,sp,4
 d03b198:	f800283a 	ret

0d03b19c <task_stats>:
 */


void
task_stats(void * pio)
{
 d03b19c:	defffd04 	addi	sp,sp,-12
 d03b1a0:	dfc00215 	stw	ra,8(sp)
 d03b1a4:	df000115 	stw	fp,4(sp)
 d03b1a8:	df000104 	addi	fp,sp,4
 d03b1ac:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 d03b1b0:	e13fff17 	ldw	r4,-4(fp)
 d03b1b4:	01434174 	movhi	r5,3333
 d03b1b8:	297eaf04 	addi	r5,r5,-1348
 d03b1bc:	d02486c0 	call	d02486c <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 d03b1c0:	00834174 	movhi	r2,3333
 d03b1c4:	108aab04 	addi	r2,r2,10924
 d03b1c8:	11800017 	ldw	r6,0(r2)
 d03b1cc:	e13fff17 	ldw	r4,-4(fp)
 d03b1d0:	01434174 	movhi	r5,3333
 d03b1d4:	297eb304 	addi	r5,r5,-1332
 d03b1d8:	d02486c0 	call	d02486c <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 d03b1dc:	00834174 	movhi	r2,3333
 d03b1e0:	108aac04 	addi	r2,r2,10928
 d03b1e4:	11800017 	ldw	r6,0(r2)
 d03b1e8:	e13fff17 	ldw	r4,-4(fp)
 d03b1ec:	01434174 	movhi	r5,3333
 d03b1f0:	297eb704 	addi	r5,r5,-1316
 d03b1f4:	d02486c0 	call	d02486c <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 d03b1f8:	e13fff17 	ldw	r4,-4(fp)
 d03b1fc:	01434174 	movhi	r5,3333
 d03b200:	297ebb04 	addi	r5,r5,-1300
 d03b204:	d02486c0 	call	d02486c <ns_printf>
}
 d03b208:	e037883a 	mov	sp,fp
 d03b20c:	dfc00117 	ldw	ra,4(sp)
 d03b210:	df000017 	ldw	fp,0(sp)
 d03b214:	dec00204 	addi	sp,sp,8
 d03b218:	f800283a 	ret

0d03b21c <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 d03b21c:	defff704 	addi	sp,sp,-36
 d03b220:	dfc00615 	stw	ra,24(sp)
 d03b224:	df000515 	stw	fp,20(sp)
 d03b228:	df000504 	addi	fp,sp,20
 d03b22c:	e13ffd15 	stw	r4,-12(fp)
 d03b230:	e1800215 	stw	r6,8(fp)
 d03b234:	e1c00315 	stw	r7,12(fp)
 d03b238:	e17ffe15 	stw	r5,-8(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 d03b23c:	e0bffd17 	ldw	r2,-12(fp)
 d03b240:	10800808 	cmpgei	r2,r2,32
 d03b244:	10000e1e 	bne	r2,zero,d03b280 <fcntl+0x64>
  {
    va_start(argp, cmd);
 d03b248:	e0800204 	addi	r2,fp,8
 d03b24c:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 d03b250:	e0fffc17 	ldw	r3,-16(fp)
 d03b254:	18800104 	addi	r2,r3,4
 d03b258:	e0bffc15 	stw	r2,-16(fp)
 d03b25c:	1805883a 	mov	r2,r3
 d03b260:	10800017 	ldw	r2,0(r2)
 d03b264:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 d03b268:	e13ffd17 	ldw	r4,-12(fp)
 d03b26c:	e17ffe17 	ldw	r5,-8(fp)
 d03b270:	e1bffb17 	ldw	r6,-20(fp)
 d03b274:	d0487580 	call	d048758 <alt_fcntl>
 d03b278:	e0bfff15 	stw	r2,-4(fp)
 d03b27c:	00000d06 	br	d03b2b4 <fcntl+0x98>
  }
  else
  {
    va_start(argp, cmd);
 d03b280:	e0800204 	addi	r2,fp,8
 d03b284:	e0bffc15 	stw	r2,-16(fp)
    flags = va_arg(argp, long);
 d03b288:	e0fffc17 	ldw	r3,-16(fp)
 d03b28c:	18800104 	addi	r2,r3,4
 d03b290:	e0bffc15 	stw	r2,-16(fp)
 d03b294:	1805883a 	mov	r2,r3
 d03b298:	10800017 	ldw	r2,0(r2)
 d03b29c:	e0bffb15 	stw	r2,-20(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 d03b2a0:	e17ffe17 	ldw	r5,-8(fp)
 d03b2a4:	e13ffd17 	ldw	r4,-12(fp)
 d03b2a8:	e1bffb17 	ldw	r6,-20(fp)
 d03b2ac:	d023cac0 	call	d023cac <bsd_ioctl>
 d03b2b0:	e0bfff15 	stw	r2,-4(fp)
 d03b2b4:	e0bfff17 	ldw	r2,-4(fp)
  }
}
 d03b2b8:	e037883a 	mov	sp,fp
 d03b2bc:	dfc00117 	ldw	ra,4(sp)
 d03b2c0:	df000017 	ldw	fp,0(sp)
 d03b2c4:	dec00404 	addi	sp,sp,16
 d03b2c8:	f800283a 	ret

0d03b2cc <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 d03b2cc:	defffd04 	addi	sp,sp,-12
 d03b2d0:	dfc00215 	stw	ra,8(sp)
 d03b2d4:	df000115 	stw	fp,4(sp)
 d03b2d8:	df000104 	addi	fp,sp,4
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 d03b2dc:	01018204 	movi	r4,1544
 d03b2e0:	d03c8d00 	call	d03c8d0 <reg_type>
 d03b2e4:	1005003a 	cmpeq	r2,r2,zero
 d03b2e8:	1000061e 	bne	r2,zero,d03b304 <etainit+0x38>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 d03b2ec:	01034174 	movhi	r4,3333
 d03b2f0:	213ebc04 	addi	r4,r4,-1296
 d03b2f4:	d002cc00 	call	d002cc0 <puts>
#endif
      return (1);
 d03b2f8:	00800044 	movi	r2,1
 d03b2fc:	e0bfff15 	stw	r2,-4(fp)
 d03b300:	00000106 	br	d03b308 <etainit+0x3c>
   }
   return (0);
 d03b304:	e03fff15 	stw	zero,-4(fp)
 d03b308:	e0bfff17 	ldw	r2,-4(fp)
}
 d03b30c:	e037883a 	mov	sp,fp
 d03b310:	dfc00117 	ldw	ra,4(sp)
 d03b314:	df000017 	ldw	fp,0(sp)
 d03b318:	dec00204 	addi	sp,sp,8
 d03b31c:	f800283a 	ret

0d03b320 <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 d03b320:	defff904 	addi	sp,sp,-28
 d03b324:	dfc00615 	stw	ra,24(sp)
 d03b328:	df000515 	stw	fp,20(sp)
 d03b32c:	df000504 	addi	fp,sp,20
 d03b330:	e13ffe15 	stw	r4,-8(fp)
 d03b334:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 d03b338:	e0bffe17 	ldw	r2,-8(fp)
 d03b33c:	10800617 	ldw	r2,24(r2)
 d03b340:	10802717 	ldw	r2,156(r2)
 d03b344:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 d03b348:	00834174 	movhi	r2,3333
 d03b34c:	108ac904 	addi	r2,r2,11044
 d03b350:	10c00017 	ldw	r3,0(r2)
 d03b354:	e0bfff17 	ldw	r2,-4(fp)
 d03b358:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 d03b35c:	e0bffe17 	ldw	r2,-8(fp)
 d03b360:	10800317 	ldw	r2,12(r2)
 d03b364:	10fffc04 	addi	r3,r2,-16
 d03b368:	e0bffe17 	ldw	r2,-8(fp)
 d03b36c:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 d03b370:	e0bffe17 	ldw	r2,-8(fp)
 d03b374:	10800417 	ldw	r2,16(r2)
 d03b378:	10c00404 	addi	r3,r2,16
 d03b37c:	e0bffe17 	ldw	r2,-8(fp)
 d03b380:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 d03b384:	e0bffe17 	ldw	r2,-8(fp)
 d03b388:	10800317 	ldw	r2,12(r2)
 d03b38c:	10800084 	addi	r2,r2,2
 d03b390:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 d03b394:	e0bffe17 	ldw	r2,-8(fp)
 d03b398:	10c00117 	ldw	r3,4(r2)
 d03b39c:	e0bffd17 	ldw	r2,-12(fp)
 d03b3a0:	10c0032e 	bgeu	r2,r3,d03b3b0 <et_send+0x90>
      panic("et_send: prepend");
 d03b3a4:	01034174 	movhi	r4,3333
 d03b3a8:	213ec804 	addi	r4,r4,-1248
 d03b3ac:	d0246440 	call	d024644 <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 d03b3b0:	e0bfff17 	ldw	r2,-4(fp)
 d03b3b4:	11400104 	addi	r5,r2,4
 d03b3b8:	e13ffd17 	ldw	r4,-12(fp)
 d03b3bc:	01800184 	movi	r6,6
 d03b3c0:	d0027a00 	call	d0027a0 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 d03b3c4:	e0bffd17 	ldw	r2,-12(fp)
 d03b3c8:	11000184 	addi	r4,r2,6
 d03b3cc:	e0bffc17 	ldw	r2,-16(fp)
 d03b3d0:	11400517 	ldw	r5,20(r2)
 d03b3d4:	01800184 	movi	r6,6
 d03b3d8:	d0027a00 	call	d0027a0 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 d03b3dc:	e0bfff17 	ldw	r2,-4(fp)
 d03b3e0:	1080070b 	ldhu	r2,28(r2)
 d03b3e4:	10bfffcc 	andi	r2,r2,65535
 d03b3e8:	108000cc 	andi	r2,r2,3
 d03b3ec:	108000a0 	cmpeqi	r2,r2,2
 d03b3f0:	1000041e 	bne	r2,zero,d03b404 <et_send+0xe4>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 d03b3f4:	e0bffd17 	ldw	r2,-12(fp)
 d03b3f8:	10c00304 	addi	r3,r2,12
 d03b3fc:	00800204 	movi	r2,8
 d03b400:	18800005 	stb	r2,0(r3)
 d03b404:	e0bffd17 	ldw	r2,-12(fp)
 d03b408:	10800344 	addi	r2,r2,13
 d03b40c:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 d03b410:	e0bffe17 	ldw	r2,-8(fp)
 d03b414:	10800617 	ldw	r2,24(r2)
 d03b418:	10800417 	ldw	r2,16(r2)
 d03b41c:	1005003a 	cmpeq	r2,r2,zero
 d03b420:	1000071e 	bne	r2,zero,d03b440 <et_send+0x120>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 d03b424:	e0bffe17 	ldw	r2,-8(fp)
 d03b428:	10800617 	ldw	r2,24(r2)
 d03b42c:	10800417 	ldw	r2,16(r2)
 d03b430:	e13ffe17 	ldw	r4,-8(fp)
 d03b434:	103ee83a 	callr	r2
 d03b438:	e0bffb15 	stw	r2,-20(fp)
 d03b43c:	00001106 	br	d03b484 <et_send+0x164>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 d03b440:	e0bffe17 	ldw	r2,-8(fp)
 d03b444:	10800617 	ldw	r2,24(r2)
 d03b448:	10c00317 	ldw	r3,12(r2)
 d03b44c:	e0bffe17 	ldw	r2,-8(fp)
 d03b450:	11000617 	ldw	r4,24(r2)
 d03b454:	e0bffe17 	ldw	r2,-8(fp)
 d03b458:	11400317 	ldw	r5,12(r2)
 d03b45c:	e0bffe17 	ldw	r2,-8(fp)
 d03b460:	11800417 	ldw	r6,16(r2)
 d03b464:	183ee83a 	callr	r3
 d03b468:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03b46c:	01000084 	movi	r4,2
 d03b470:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d03b474:	e13ffe17 	ldw	r4,-8(fp)
 d03b478:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03b47c:	01000084 	movi	r4,2
 d03b480:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   }

   return (err);
 d03b484:	e0bffb17 	ldw	r2,-20(fp)
}
 d03b488:	e037883a 	mov	sp,fp
 d03b48c:	dfc00117 	ldw	ra,4(sp)
 d03b490:	df000017 	ldw	fp,0(sp)
 d03b494:	dec00204 	addi	sp,sp,8
 d03b498:	f800283a 	ret

0d03b49c <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 d03b49c:	defffb04 	addi	sp,sp,-20
 d03b4a0:	dfc00415 	stw	ra,16(sp)
 d03b4a4:	df000315 	stw	fp,12(sp)
 d03b4a8:	df000304 	addi	fp,sp,12
 d03b4ac:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 d03b4b0:	e0bfff17 	ldw	r2,-4(fp)
 d03b4b4:	10800417 	ldw	r2,16(r2)
 d03b4b8:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;
 d03b4bc:	e0bfff17 	ldw	r2,-4(fp)
 d03b4c0:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 d03b4c4:	01000084 	movi	r4,2
 d03b4c8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 d03b4cc:	00000906 	br	d03b4f4 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 d03b4d0:	e0bffe17 	ldw	r2,-8(fp)
 d03b4d4:	10800017 	ldw	r2,0(r2)
 d03b4d8:	e0bffd15 	stw	r2,-12(fp)
      tmppkt->next = (PACKET)NULL;
 d03b4dc:	e0bffe17 	ldw	r2,-8(fp)
 d03b4e0:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 d03b4e4:	e13ffe17 	ldw	r4,-8(fp)
 d03b4e8:	d028b380 	call	d028b38 <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 d03b4ec:	e0bffd17 	ldw	r2,-12(fp)
 d03b4f0:	e0bffe15 	stw	r2,-8(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 d03b4f4:	e0bffe17 	ldw	r2,-8(fp)
 d03b4f8:	1004c03a 	cmpne	r2,r2,zero
 d03b4fc:	103ff41e 	bne	r2,zero,d03b4d0 <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 d03b500:	e0bfff17 	ldw	r2,-4(fp)
 d03b504:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03b508:	01000084 	movi	r4,2
 d03b50c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
}
 d03b510:	e037883a 	mov	sp,fp
 d03b514:	dfc00117 	ldw	ra,4(sp)
 d03b518:	df000017 	ldw	fp,0(sp)
 d03b51c:	dec00204 	addi	sp,sp,8
 d03b520:	f800283a 	ret

0d03b524 <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 d03b524:	defffc04 	addi	sp,sp,-16
 d03b528:	dfc00315 	stw	ra,12(sp)
 d03b52c:	df000215 	stw	fp,8(sp)
 d03b530:	df000204 	addi	fp,sp,8
 d03b534:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 d03b538:	e0bfff17 	ldw	r2,-4(fp)
 d03b53c:	10800417 	ldw	r2,16(r2)
 d03b540:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 d03b544:	00000906 	br	d03b56c <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 d03b548:	e0bffe17 	ldw	r2,-8(fp)
 d03b54c:	10c00017 	ldw	r3,0(r2)
 d03b550:	e0bfff17 	ldw	r2,-4(fp)
 d03b554:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 d03b558:	e0bffe17 	ldw	r2,-8(fp)
 d03b55c:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 d03b560:	e13ffe17 	ldw	r4,-8(fp)
 d03b564:	e17fff17 	ldw	r5,-4(fp)
 d03b568:	d03b3200 	call	d03b320 <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 d03b56c:	e0bfff17 	ldw	r2,-4(fp)
 d03b570:	10800417 	ldw	r2,16(r2)
 d03b574:	e0bffe15 	stw	r2,-8(fp)
 d03b578:	e0bffe17 	ldw	r2,-8(fp)
 d03b57c:	1004c03a 	cmpne	r2,r2,zero
 d03b580:	103ff11e 	bne	r2,zero,d03b548 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 d03b584:	e037883a 	mov	sp,fp
 d03b588:	dfc00117 	ldw	ra,4(sp)
 d03b58c:	df000017 	ldw	fp,0(sp)
 d03b590:	dec00204 	addi	sp,sp,8
 d03b594:	f800283a 	ret

0d03b598 <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 d03b598:	defff304 	addi	sp,sp,-52
 d03b59c:	dfc00c15 	stw	ra,48(sp)
 d03b5a0:	df000b15 	stw	fp,44(sp)
 d03b5a4:	df000b04 	addi	fp,sp,44
 d03b5a8:	e13ffd15 	stw	r4,-12(fp)
 d03b5ac:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 d03b5b0:	e0bffd17 	ldw	r2,-12(fp)
 d03b5b4:	10800617 	ldw	r2,24(r2)
 d03b5b8:	e0bff915 	stw	r2,-28(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 d03b5bc:	e0bffd17 	ldw	r2,-12(fp)
 d03b5c0:	10800617 	ldw	r2,24(r2)
 d03b5c4:	10802717 	ldw	r2,156(r2)
 d03b5c8:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 d03b5cc:	e0bffe17 	ldw	r2,-8(fp)
 d03b5d0:	10bfffe0 	cmpeqi	r2,r2,-1
 d03b5d4:	10001b1e 	bne	r2,zero,d03b644 <send_arp+0xac>
 d03b5d8:	e0bff917 	ldw	r2,-28(fp)
 d03b5dc:	10800c17 	ldw	r2,48(r2)
 d03b5e0:	0086303a 	nor	r3,zero,r2
 d03b5e4:	e0bffe17 	ldw	r2,-8(fp)
 d03b5e8:	1886703a 	and	r3,r3,r2
 d03b5ec:	e0bff917 	ldw	r2,-28(fp)
 d03b5f0:	10800c17 	ldw	r2,48(r2)
 d03b5f4:	0084303a 	nor	r2,zero,r2
 d03b5f8:	18801226 	beq	r3,r2,d03b644 <send_arp+0xac>
 d03b5fc:	e0bffe17 	ldw	r2,-8(fp)
 d03b600:	1004d63a 	srli	r2,r2,24
 d03b604:	10c03fcc 	andi	r3,r2,255
 d03b608:	e0bffe17 	ldw	r2,-8(fp)
 d03b60c:	1004d23a 	srli	r2,r2,8
 d03b610:	10bfc00c 	andi	r2,r2,65280
 d03b614:	1886b03a 	or	r3,r3,r2
 d03b618:	e0bffe17 	ldw	r2,-8(fp)
 d03b61c:	10bfc00c 	andi	r2,r2,65280
 d03b620:	1004923a 	slli	r2,r2,8
 d03b624:	1886b03a 	or	r3,r3,r2
 d03b628:	e0bffe17 	ldw	r2,-8(fp)
 d03b62c:	10803fcc 	andi	r2,r2,255
 d03b630:	1004963a 	slli	r2,r2,24
 d03b634:	1884b03a 	or	r2,r3,r2
 d03b638:	10fc002c 	andhi	r3,r2,61440
 d03b63c:	00b80034 	movhi	r2,57344
 d03b640:	1880441e 	bne	r3,r2,d03b754 <send_arp+0x1bc>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 d03b644:	e0bffd17 	ldw	r2,-12(fp)
 d03b648:	11400617 	ldw	r5,24(r2)
 d03b64c:	e13ffe17 	ldw	r4,-8(fp)
 d03b650:	d03bbd80 	call	d03bbd8 <make_arp_entry>
 d03b654:	e0bffb15 	stw	r2,-20(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 d03b658:	e0bffb17 	ldw	r2,-20(fp)
 d03b65c:	10c00104 	addi	r3,r2,4
 d03b660:	00bfffc4 	movi	r2,-1
 d03b664:	18800005 	stb	r2,0(r3)
 d03b668:	00bfffc4 	movi	r2,-1
 d03b66c:	18800045 	stb	r2,1(r3)
 d03b670:	00bfffc4 	movi	r2,-1
 d03b674:	18800085 	stb	r2,2(r3)
 d03b678:	00bfffc4 	movi	r2,-1
 d03b67c:	188000c5 	stb	r2,3(r3)
 d03b680:	00bfffc4 	movi	r2,-1
 d03b684:	18800105 	stb	r2,4(r3)
 d03b688:	00bfffc4 	movi	r2,-1
 d03b68c:	18800145 	stb	r2,5(r3)
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 d03b690:	e0bffd17 	ldw	r2,-12(fp)
 d03b694:	10800617 	ldw	r2,24(r2)
 d03b698:	10802b17 	ldw	r2,172(r2)
 d03b69c:	1005003a 	cmpeq	r2,r2,zero
 d03b6a0:	1000271e 	bne	r2,zero,d03b740 <send_arp+0x1a8>
 d03b6a4:	e0bffe17 	ldw	r2,-8(fp)
 d03b6a8:	1004d63a 	srli	r2,r2,24
 d03b6ac:	10c03fcc 	andi	r3,r2,255
 d03b6b0:	e0bffe17 	ldw	r2,-8(fp)
 d03b6b4:	1004d23a 	srli	r2,r2,8
 d03b6b8:	10bfc00c 	andi	r2,r2,65280
 d03b6bc:	1886b03a 	or	r3,r3,r2
 d03b6c0:	e0bffe17 	ldw	r2,-8(fp)
 d03b6c4:	10bfc00c 	andi	r2,r2,65280
 d03b6c8:	1004923a 	slli	r2,r2,8
 d03b6cc:	1886b03a 	or	r3,r3,r2
 d03b6d0:	e0bffe17 	ldw	r2,-8(fp)
 d03b6d4:	10803fcc 	andi	r2,r2,255
 d03b6d8:	1004963a 	slli	r2,r2,24
 d03b6dc:	1884b03a 	or	r2,r3,r2
 d03b6e0:	10fc002c 	andhi	r3,r2,61440
 d03b6e4:	00b80034 	movhi	r2,57344
 d03b6e8:	1880151e 	bne	r3,r2,d03b740 <send_arp+0x1a8>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 d03b6ec:	e0bffe17 	ldw	r2,-8(fp)
 d03b6f0:	e0bffc15 	stw	r2,-16(fp)
         oldest->t_phy_addr[0] = 0x01;
 d03b6f4:	e0fffb17 	ldw	r3,-20(fp)
 d03b6f8:	00800044 	movi	r2,1
 d03b6fc:	18800105 	stb	r2,4(r3)
         oldest->t_phy_addr[1] = 0x00;
 d03b700:	e0bffb17 	ldw	r2,-20(fp)
 d03b704:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 d03b708:	e0fffb17 	ldw	r3,-20(fp)
 d03b70c:	00801784 	movi	r2,94
 d03b710:	18800185 	stb	r2,6(r3)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 d03b714:	e0bffc43 	ldbu	r2,-15(fp)
 d03b718:	10801fcc 	andi	r2,r2,127
 d03b71c:	1007883a 	mov	r3,r2
 d03b720:	e0bffb17 	ldw	r2,-20(fp)
 d03b724:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 d03b728:	e0fffc83 	ldbu	r3,-14(fp)
 d03b72c:	e0bffb17 	ldw	r2,-20(fp)
 d03b730:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 d03b734:	e0fffcc3 	ldbu	r3,-13(fp)
 d03b738:	e0bffb17 	ldw	r2,-20(fp)
 d03b73c:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 d03b740:	e13ffd17 	ldw	r4,-12(fp)
 d03b744:	e17ffb17 	ldw	r5,-20(fp)
 d03b748:	d03b3200 	call	d03b320 <et_send>
 d03b74c:	e0bfff15 	stw	r2,-4(fp)
 d03b750:	0000b106 	br	d03ba18 <send_arp+0x480>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 d03b754:	e0bffd17 	ldw	r2,-12(fp)
 d03b758:	10c00717 	ldw	r3,28(r2)
 d03b75c:	e0bffd17 	ldw	r2,-12(fp)
 d03b760:	10800617 	ldw	r2,24(r2)
 d03b764:	10800a17 	ldw	r2,40(r2)
 d03b768:	18800e1e 	bne	r3,r2,d03b7a4 <send_arp+0x20c>
 d03b76c:	e0bffd17 	ldw	r2,-12(fp)
 d03b770:	10800717 	ldw	r2,28(r2)
 d03b774:	10803fcc 	andi	r2,r2,255
 d03b778:	10801fe0 	cmpeqi	r2,r2,127
 d03b77c:	1000091e 	bne	r2,zero,d03b7a4 <send_arp+0x20c>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03b780:	01000084 	movi	r4,2
 d03b784:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d03b788:	e13ffd17 	ldw	r4,-12(fp)
 d03b78c:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03b790:	01000084 	movi	r4,2
 d03b794:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 d03b798:	00bff7c4 	movi	r2,-33
 d03b79c:	e0bfff15 	stw	r2,-4(fp)
 d03b7a0:	00009d06 	br	d03ba18 <send_arp+0x480>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 d03b7a4:	01000084 	movi	r4,2
 d03b7a8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 d03b7ac:	01000c04 	movi	r4,48
 d03b7b0:	d0287a40 	call	d0287a4 <pk_alloc>
 d03b7b4:	e0bff615 	stw	r2,-40(fp)
   if (!arppkt)
 d03b7b8:	e0bff617 	ldw	r2,-40(fp)
 d03b7bc:	1004c03a 	cmpne	r2,r2,zero
 d03b7c0:	1000071e 	bne	r2,zero,d03b7e0 <send_arp+0x248>
   {
      pk_free(pkt);
 d03b7c4:	e13ffd17 	ldw	r4,-12(fp)
 d03b7c8:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03b7cc:	01000084 	movi	r4,2
 d03b7d0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 d03b7d4:	00bffa84 	movi	r2,-22
 d03b7d8:	e0bfff15 	stw	r2,-4(fp)
 d03b7dc:	00008e06 	br	d03ba18 <send_arp+0x480>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03b7e0:	01000084 	movi	r4,2
 d03b7e4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 d03b7e8:	e0bff617 	ldw	r2,-40(fp)
 d03b7ec:	10c00117 	ldw	r3,4(r2)
 d03b7f0:	e0bff617 	ldw	r2,-40(fp)
 d03b7f4:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 d03b7f8:	e0fff617 	ldw	r3,-40(fp)
 d03b7fc:	00800c04 	movi	r2,48
 d03b800:	18800415 	stw	r2,16(r3)
   arppkt->net = pkt->net;
 d03b804:	e0bffd17 	ldw	r2,-12(fp)
 d03b808:	10c00617 	ldw	r3,24(r2)
 d03b80c:	e0bff617 	ldw	r2,-40(fp)
 d03b810:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 d03b814:	e0bffd17 	ldw	r2,-12(fp)
 d03b818:	11400617 	ldw	r5,24(r2)
 d03b81c:	e13ffe17 	ldw	r4,-8(fp)
 d03b820:	d03bbd80 	call	d03bbd8 <make_arp_entry>
 d03b824:	e0bffb15 	stw	r2,-20(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 d03b828:	e0fffb17 	ldw	r3,-20(fp)
 d03b82c:	e0bffd17 	ldw	r2,-12(fp)
 d03b830:	18800415 	stw	r2,16(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 d03b834:	e0bff617 	ldw	r2,-40(fp)
 d03b838:	10800117 	ldw	r2,4(r2)
 d03b83c:	10800084 	addi	r2,r2,2
 d03b840:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 d03b844:	e0bff617 	ldw	r2,-40(fp)
 d03b848:	10800117 	ldw	r2,4(r2)
 d03b84c:	10800404 	addi	r2,r2,16
 d03b850:	e0bff815 	stw	r2,-32(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 d03b854:	e0fff817 	ldw	r3,-32(fp)
 d03b858:	00804004 	movi	r2,256
 d03b85c:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 d03b860:	e0fff817 	ldw	r3,-32(fp)
 d03b864:	00800204 	movi	r2,8
 d03b868:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 d03b86c:	e0fff817 	ldw	r3,-32(fp)
 d03b870:	00800184 	movi	r2,6
 d03b874:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 d03b878:	e0fff817 	ldw	r3,-32(fp)
 d03b87c:	00800104 	movi	r2,4
 d03b880:	18800145 	stb	r2,5(r3)
   arphdr->ar_op = ARREQ;
 d03b884:	e0fff817 	ldw	r3,-32(fp)
 d03b888:	00804004 	movi	r2,256
 d03b88c:	1880018d 	sth	r2,6(r3)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 d03b890:	e0fff817 	ldw	r3,-32(fp)
 d03b894:	e0bffe17 	ldw	r2,-8(fp)
 d03b898:	18800715 	stw	r2,28(r3)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 d03b89c:	e0bffd17 	ldw	r2,-12(fp)
 d03b8a0:	10800617 	ldw	r2,24(r2)
 d03b8a4:	10c00a17 	ldw	r3,40(r2)
 d03b8a8:	e0bff817 	ldw	r2,-32(fp)
 d03b8ac:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 d03b8b0:	e0bff817 	ldw	r2,-32(fp)
 d03b8b4:	11000204 	addi	r4,r2,8
 d03b8b8:	e0bff717 	ldw	r2,-36(fp)
 d03b8bc:	11400517 	ldw	r5,20(r2)
 d03b8c0:	01800184 	movi	r6,6
 d03b8c4:	d0027a00 	call	d0027a0 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 d03b8c8:	e0fffa17 	ldw	r3,-24(fp)
 d03b8cc:	00bfffc4 	movi	r2,-1
 d03b8d0:	18800005 	stb	r2,0(r3)
 d03b8d4:	00bfffc4 	movi	r2,-1
 d03b8d8:	18800045 	stb	r2,1(r3)
 d03b8dc:	00bfffc4 	movi	r2,-1
 d03b8e0:	18800085 	stb	r2,2(r3)
 d03b8e4:	00bfffc4 	movi	r2,-1
 d03b8e8:	188000c5 	stb	r2,3(r3)
 d03b8ec:	00bfffc4 	movi	r2,-1
 d03b8f0:	18800105 	stb	r2,4(r3)
 d03b8f4:	00bfffc4 	movi	r2,-1
 d03b8f8:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 d03b8fc:	e0bffa17 	ldw	r2,-24(fp)
 d03b900:	11000184 	addi	r4,r2,6
 d03b904:	e0bff717 	ldw	r2,-36(fp)
 d03b908:	11400517 	ldw	r5,20(r2)
 d03b90c:	01800184 	movi	r6,6
 d03b910:	d0027a00 	call	d0027a0 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 d03b914:	e0bffa17 	ldw	r2,-24(fp)
 d03b918:	10c00304 	addi	r3,r2,12
 d03b91c:	00800204 	movi	r2,8
 d03b920:	18800005 	stb	r2,0(r3)
 d03b924:	e0bffa17 	ldw	r2,-24(fp)
 d03b928:	10c00344 	addi	r3,r2,13
 d03b92c:	00800184 	movi	r2,6
 d03b930:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 d03b934:	e0bff817 	ldw	r2,-32(fp)
 d03b938:	e0bff515 	stw	r2,-44(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 d03b93c:	e0bff517 	ldw	r2,-44(fp)
 d03b940:	11000204 	addi	r4,r2,8
 d03b944:	e0bff817 	ldw	r2,-32(fp)
 d03b948:	11400204 	addi	r5,r2,8
 d03b94c:	01800184 	movi	r6,6
 d03b950:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 d03b954:	e0bff517 	ldw	r2,-44(fp)
 d03b958:	10800204 	addi	r2,r2,8
 d03b95c:	11000184 	addi	r4,r2,6
 d03b960:	e0bff817 	ldw	r2,-32(fp)
 d03b964:	11400404 	addi	r5,r2,16
 d03b968:	01800104 	movi	r6,4
 d03b96c:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 d03b970:	e0bff517 	ldw	r2,-44(fp)
 d03b974:	10800204 	addi	r2,r2,8
 d03b978:	11000284 	addi	r4,r2,10
 d03b97c:	e0bff817 	ldw	r2,-32(fp)
 d03b980:	11400504 	addi	r5,r2,20
 d03b984:	01800184 	movi	r6,6
 d03b988:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 d03b98c:	e0bff517 	ldw	r2,-44(fp)
 d03b990:	10800204 	addi	r2,r2,8
 d03b994:	11000404 	addi	r4,r2,16
 d03b998:	e0bff817 	ldw	r2,-32(fp)
 d03b99c:	11400704 	addi	r5,r2,28
 d03b9a0:	01800104 	movi	r6,4
 d03b9a4:	d0027a00 	call	d0027a0 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 d03b9a8:	e0bff917 	ldw	r2,-28(fp)
 d03b9ac:	10800417 	ldw	r2,16(r2)
 d03b9b0:	1005003a 	cmpeq	r2,r2,zero
 d03b9b4:	1000051e 	bne	r2,zero,d03b9cc <send_arp+0x434>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 d03b9b8:	e0bff917 	ldw	r2,-28(fp)
 d03b9bc:	10800417 	ldw	r2,16(r2)
 d03b9c0:	e13ff617 	ldw	r4,-40(fp)
 d03b9c4:	103ee83a 	callr	r2
 d03b9c8:	00000e06 	br	d03ba04 <send_arp+0x46c>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 d03b9cc:	e0bff917 	ldw	r2,-28(fp)
 d03b9d0:	10c00317 	ldw	r3,12(r2)
 d03b9d4:	e0bff617 	ldw	r2,-40(fp)
 d03b9d8:	11000617 	ldw	r4,24(r2)
 d03b9dc:	e0bff617 	ldw	r2,-40(fp)
 d03b9e0:	11400117 	ldw	r5,4(r2)
 d03b9e4:	01800c04 	movi	r6,48
 d03b9e8:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03b9ec:	01000084 	movi	r4,2
 d03b9f0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 d03b9f4:	e13ff617 	ldw	r4,-40(fp)
 d03b9f8:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03b9fc:	01000084 	movi	r4,2
 d03ba00:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 d03ba04:	d0a0c217 	ldw	r2,-31992(gp)
 d03ba08:	10800044 	addi	r2,r2,1
 d03ba0c:	d0a0c215 	stw	r2,-31992(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 d03ba10:	00800044 	movi	r2,1
 d03ba14:	e0bfff15 	stw	r2,-4(fp)
 d03ba18:	e0bfff17 	ldw	r2,-4(fp)
}
 d03ba1c:	e037883a 	mov	sp,fp
 d03ba20:	dfc00117 	ldw	ra,4(sp)
 d03ba24:	df000017 	ldw	fp,0(sp)
 d03ba28:	dec00204 	addi	sp,sp,8
 d03ba2c:	f800283a 	ret

0d03ba30 <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 d03ba30:	defff604 	addi	sp,sp,-40
 d03ba34:	dfc00915 	stw	ra,36(sp)
 d03ba38:	df000815 	stw	fp,32(sp)
 d03ba3c:	df000804 	addi	fp,sp,32
 d03ba40:	e13ffd15 	stw	r4,-12(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 d03ba44:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 d03ba48:	e03ffa15 	stw	zero,-24(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 d03ba4c:	e03ff915 	stw	zero,-28(fp)
   unsigned long lticks = cticks;
 d03ba50:	00834174 	movhi	r2,3333
 d03ba54:	108ac904 	addi	r2,r2,11044
 d03ba58:	10800017 	ldw	r2,0(r2)
 d03ba5c:	e0bff815 	stw	r2,-32(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03ba60:	008341b4 	movhi	r2,3334
 d03ba64:	10b4a604 	addi	r2,r2,-11624
 d03ba68:	e0bffc15 	stw	r2,-16(fp)
 d03ba6c:	00004006 	br	d03bb70 <find_oldest_arp+0x140>
   {
      /* age out old, pending entries */
      if (tp->pending)
 d03ba70:	e0bffc17 	ldw	r2,-16(fp)
 d03ba74:	10800417 	ldw	r2,16(r2)
 d03ba78:	1005003a 	cmpeq	r2,r2,zero
 d03ba7c:	10000b1e 	bne	r2,zero,d03baac <find_oldest_arp+0x7c>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 d03ba80:	e0bffc17 	ldw	r2,-16(fp)
 d03ba84:	10c00517 	ldw	r3,20(r2)
 d03ba88:	e0bff817 	ldw	r2,-32(fp)
 d03ba8c:	10c5c83a 	sub	r2,r2,r3
 d03ba90:	10801970 	cmpltui	r2,r2,101
 d03ba94:	1000181e 	bne	r2,zero,d03baf8 <find_oldest_arp+0xc8>
         {
            arp_free_pending(tp);   /* free pending packets */
 d03ba98:	e13ffc17 	ldw	r4,-16(fp)
 d03ba9c:	d03b49c0 	call	d03b49c <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 d03baa0:	e0bffc17 	ldw	r2,-16(fp)
 d03baa4:	10000015 	stw	zero,0(r2)
 d03baa8:	00001306 	br	d03baf8 <find_oldest_arp+0xc8>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 d03baac:	e0bffc17 	ldw	r2,-16(fp)
 d03bab0:	10800017 	ldw	r2,0(r2)
 d03bab4:	1005003a 	cmpeq	r2,r2,zero
 d03bab8:	10000f1e 	bne	r2,zero,d03baf8 <find_oldest_arp+0xc8>
 d03babc:	e0bffc17 	ldw	r2,-16(fp)
 d03bac0:	10c00517 	ldw	r3,20(r2)
 d03bac4:	e0bff817 	ldw	r2,-32(fp)
 d03bac8:	10c5c83a 	sub	r2,r2,r3
 d03bacc:	1007883a 	mov	r3,r2
 d03bad0:	d0a04f17 	ldw	r2,-32452(gp)
 d03bad4:	18800816 	blt	r3,r2,d03baf8 <find_oldest_arp+0xc8>
 d03bad8:	e0bffc17 	ldw	r2,-16(fp)
 d03badc:	10c00617 	ldw	r3,24(r2)
 d03bae0:	e0bff817 	ldw	r2,-32(fp)
 d03bae4:	10c5c83a 	sub	r2,r2,r3
 d03bae8:	10801930 	cmpltui	r2,r2,100
 d03baec:	1000021e 	bne	r2,zero,d03baf8 <find_oldest_arp+0xc8>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 d03baf0:	e0bffc17 	ldw	r2,-16(fp)
 d03baf4:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 d03baf8:	e0bffc17 	ldw	r2,-16(fp)
 d03bafc:	10c00017 	ldw	r3,0(r2)
 d03bb00:	e0bffd17 	ldw	r2,-12(fp)
 d03bb04:	1880031e 	bne	r3,r2,d03bb14 <find_oldest_arp+0xe4>
      {
         exact = tp;
 d03bb08:	e0bffc17 	ldw	r2,-16(fp)
 d03bb0c:	e0bffb15 	stw	r2,-20(fp)
 d03bb10:	00001406 	br	d03bb64 <find_oldest_arp+0x134>
      }
      else if (tp->t_pro_addr != 0)
 d03bb14:	e0bffc17 	ldw	r2,-16(fp)
 d03bb18:	10800017 	ldw	r2,0(r2)
 d03bb1c:	1005003a 	cmpeq	r2,r2,zero
 d03bb20:	10000b1e 	bne	r2,zero,d03bb50 <find_oldest_arp+0x120>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 d03bb24:	e0bffa17 	ldw	r2,-24(fp)
 d03bb28:	1005003a 	cmpeq	r2,r2,zero
 d03bb2c:	1000051e 	bne	r2,zero,d03bb44 <find_oldest_arp+0x114>
 d03bb30:	e0bffc17 	ldw	r2,-16(fp)
 d03bb34:	10c00617 	ldw	r3,24(r2)
 d03bb38:	e0bffa17 	ldw	r2,-24(fp)
 d03bb3c:	10800617 	ldw	r2,24(r2)
 d03bb40:	1880082e 	bgeu	r3,r2,d03bb64 <find_oldest_arp+0x134>
            oldest = tp;
 d03bb44:	e0bffc17 	ldw	r2,-16(fp)
 d03bb48:	e0bffa15 	stw	r2,-24(fp)
 d03bb4c:	00000506 	br	d03bb64 <find_oldest_arp+0x134>
      }
      else if (!empty)
 d03bb50:	e0bff917 	ldw	r2,-28(fp)
 d03bb54:	1004c03a 	cmpne	r2,r2,zero
 d03bb58:	1000021e 	bne	r2,zero,d03bb64 <find_oldest_arp+0x134>
         empty = tp;          /* grab first empty slot */
 d03bb5c:	e0bffc17 	ldw	r2,-16(fp)
 d03bb60:	e0bff915 	stw	r2,-28(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03bb64:	e0bffc17 	ldw	r2,-16(fp)
 d03bb68:	10800804 	addi	r2,r2,32
 d03bb6c:	e0bffc15 	stw	r2,-16(fp)
 d03bb70:	00c341b4 	movhi	r3,3334
 d03bb74:	18f4e604 	addi	r3,r3,-11368
 d03bb78:	e0bffc17 	ldw	r2,-16(fp)
 d03bb7c:	10ffbc36 	bltu	r2,r3,d03ba70 <find_oldest_arp+0x40>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 d03bb80:	e0bffb17 	ldw	r2,-20(fp)
 d03bb84:	1004c03a 	cmpne	r2,r2,zero
 d03bb88:	10000b1e 	bne	r2,zero,d03bbb8 <find_oldest_arp+0x188>
 d03bb8c:	e0bff917 	ldw	r2,-28(fp)
 d03bb90:	1005003a 	cmpeq	r2,r2,zero
 d03bb94:	1000031e 	bne	r2,zero,d03bba4 <find_oldest_arp+0x174>
 d03bb98:	e0bff917 	ldw	r2,-28(fp)
 d03bb9c:	e0bffe15 	stw	r2,-8(fp)
 d03bba0:	00000206 	br	d03bbac <find_oldest_arp+0x17c>
 d03bba4:	e0bffa17 	ldw	r2,-24(fp)
 d03bba8:	e0bffe15 	stw	r2,-8(fp)
 d03bbac:	e0bffe17 	ldw	r2,-8(fp)
 d03bbb0:	e0bfff15 	stw	r2,-4(fp)
 d03bbb4:	00000206 	br	d03bbc0 <find_oldest_arp+0x190>
 d03bbb8:	e0bffb17 	ldw	r2,-20(fp)
 d03bbbc:	e0bfff15 	stw	r2,-4(fp)
 d03bbc0:	e0bfff17 	ldw	r2,-4(fp)
}
 d03bbc4:	e037883a 	mov	sp,fp
 d03bbc8:	dfc00117 	ldw	ra,4(sp)
 d03bbcc:	df000017 	ldw	fp,0(sp)
 d03bbd0:	dec00204 	addi	sp,sp,8
 d03bbd4:	f800283a 	ret

0d03bbd8 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 d03bbd8:	defffa04 	addi	sp,sp,-24
 d03bbdc:	dfc00515 	stw	ra,20(sp)
 d03bbe0:	df000415 	stw	fp,16(sp)
 d03bbe4:	df000404 	addi	fp,sp,16
 d03bbe8:	e13ffe15 	stw	r4,-8(fp)
 d03bbec:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 d03bbf0:	00834174 	movhi	r2,3333
 d03bbf4:	108ac904 	addi	r2,r2,11044
 d03bbf8:	10800017 	ldw	r2,0(r2)
 d03bbfc:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 d03bc00:	e13ffe17 	ldw	r4,-8(fp)
 d03bc04:	d03ba300 	call	d03ba30 <find_oldest_arp>
 d03bc08:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 d03bc0c:	e0bffd17 	ldw	r2,-12(fp)
 d03bc10:	10800417 	ldw	r2,16(r2)
 d03bc14:	1005003a 	cmpeq	r2,r2,zero
 d03bc18:	1000061e 	bne	r2,zero,d03bc34 <make_arp_entry+0x5c>
 d03bc1c:	e0bffd17 	ldw	r2,-12(fp)
 d03bc20:	10c00017 	ldw	r3,0(r2)
 d03bc24:	e0bffe17 	ldw	r2,-8(fp)
 d03bc28:	18800226 	beq	r3,r2,d03bc34 <make_arp_entry+0x5c>
   {
      arp_free_pending(oldest);
 d03bc2c:	e13ffd17 	ldw	r4,-12(fp)
 d03bc30:	d03b49c0 	call	d03b49c <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 d03bc34:	e0fffd17 	ldw	r3,-12(fp)
 d03bc38:	e0bffe17 	ldw	r2,-8(fp)
 d03bc3c:	18800015 	stw	r2,0(r3)
   oldest->net = net;
 d03bc40:	e0fffd17 	ldw	r3,-12(fp)
 d03bc44:	e0bfff17 	ldw	r2,-4(fp)
 d03bc48:	18800315 	stw	r2,12(r3)
   oldest->flags = 0;
 d03bc4c:	e0bffd17 	ldw	r2,-12(fp)
 d03bc50:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 d03bc54:	e0bffd17 	ldw	r2,-12(fp)
 d03bc58:	10800104 	addi	r2,r2,4
 d03bc5c:	10000005 	stb	zero,0(r2)
 d03bc60:	10000045 	stb	zero,1(r2)
 d03bc64:	10000085 	stb	zero,2(r2)
 d03bc68:	100000c5 	stb	zero,3(r2)
 d03bc6c:	10000105 	stb	zero,4(r2)
 d03bc70:	10000145 	stb	zero,5(r2)
   oldest->createtime = oldest->lasttime = lticks;
 d03bc74:	e0fffd17 	ldw	r3,-12(fp)
 d03bc78:	e0bffc17 	ldw	r2,-16(fp)
 d03bc7c:	18800615 	stw	r2,24(r3)
 d03bc80:	e0bffd17 	ldw	r2,-12(fp)
 d03bc84:	10c00617 	ldw	r3,24(r2)
 d03bc88:	e0bffd17 	ldw	r2,-12(fp)
 d03bc8c:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 d03bc90:	d0a0bf17 	ldw	r2,-32004(gp)
 d03bc94:	1004c03a 	cmpne	r2,r2,zero
 d03bc98:	1000071e 	bne	r2,zero,d03bcb8 <make_arp_entry+0xe0>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 d03bc9c:	01034134 	movhi	r4,3332
 d03bca0:	2130e204 	addi	r4,r4,-15480
 d03bca4:	0149c404 	movi	r5,10000
 d03bca8:	000d883a 	mov	r6,zero
 d03bcac:	d03af680 	call	d03af68 <in_timerset>
 d03bcb0:	d0a0bf15 	stw	r2,-32004(gp)
 d03bcb4:	00000706 	br	d03bcd4 <make_arp_entry+0xfc>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 d03bcb8:	d0a0bf17 	ldw	r2,-32004(gp)
 d03bcbc:	1009883a 	mov	r4,r2
 d03bcc0:	d0a0bf17 	ldw	r2,-32004(gp)
 d03bcc4:	10c00217 	ldw	r3,8(r2)
 d03bcc8:	e0bffc17 	ldw	r2,-16(fp)
 d03bccc:	1885883a 	add	r2,r3,r2
 d03bcd0:	20800315 	stw	r2,12(r4)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 d03bcd4:	e0bffd17 	ldw	r2,-12(fp)
}
 d03bcd8:	e037883a 	mov	sp,fp
 d03bcdc:	dfc00117 	ldw	ra,4(sp)
 d03bce0:	df000017 	ldw	fp,0(sp)
 d03bce4:	dec00204 	addi	sp,sp,8
 d03bce8:	f800283a 	ret

0d03bcec <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 d03bcec:	defff704 	addi	sp,sp,-36
 d03bcf0:	dfc00815 	stw	ra,32(sp)
 d03bcf4:	df000715 	stw	fp,28(sp)
 d03bcf8:	df000704 	addi	fp,sp,28
 d03bcfc:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 d03bd00:	01000084 	movi	r4,2
 d03bd04:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 d03bd08:	01000c04 	movi	r4,48
 d03bd0c:	d0287a40 	call	d0287a4 <pk_alloc>
 d03bd10:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03bd14:	01000084 	movi	r4,2
 d03bd18:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 d03bd1c:	e0bffe17 	ldw	r2,-8(fp)
 d03bd20:	1004c03a 	cmpne	r2,r2,zero
 d03bd24:	1000021e 	bne	r2,zero,d03bd30 <arpReply+0x44>
   {
      dtrap();
 d03bd28:	d0293e80 	call	d0293e8 <dtrap>
      return;
 d03bd2c:	00008f06 	br	d03bf6c <arpReply+0x280>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 d03bd30:	e0bfff17 	ldw	r2,-4(fp)
 d03bd34:	10c00617 	ldw	r3,24(r2)
 d03bd38:	e0bffe17 	ldw	r2,-8(fp)
 d03bd3c:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 d03bd40:	e0bfff17 	ldw	r2,-4(fp)
 d03bd44:	10800317 	ldw	r2,12(r2)
 d03bd48:	10bffc84 	addi	r2,r2,-14
 d03bd4c:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 d03bd50:	e0bffe17 	ldw	r2,-8(fp)
 d03bd54:	10800117 	ldw	r2,4(r2)
 d03bd58:	10800084 	addi	r2,r2,2
 d03bd5c:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 d03bd60:	e0bffb17 	ldw	r2,-20(fp)
 d03bd64:	10c00304 	addi	r3,r2,12
 d03bd68:	00800204 	movi	r2,8
 d03bd6c:	18800005 	stb	r2,0(r3)
 d03bd70:	e0bffb17 	ldw	r2,-20(fp)
 d03bd74:	10c00344 	addi	r3,r2,13
 d03bd78:	00800184 	movi	r2,6
 d03bd7c:	18800005 	stb	r2,0(r3)
      in = (struct arp_hdr *)(pkt->nb_prot);
 d03bd80:	e0bfff17 	ldw	r2,-4(fp)
 d03bd84:	10800317 	ldw	r2,12(r2)
 d03bd88:	e0bffd15 	stw	r2,-12(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 d03bd8c:	e0bffe17 	ldw	r2,-8(fp)
 d03bd90:	10800117 	ldw	r2,4(r2)
 d03bd94:	10800404 	addi	r2,r2,16
 d03bd98:	e0bffc15 	stw	r2,-16(fp)
      outpkt->nb_plen = arpsize;
 d03bd9c:	e0fffe17 	ldw	r3,-8(fp)
 d03bda0:	00800c04 	movi	r2,48
 d03bda4:	18800415 	stw	r2,16(r3)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 d03bda8:	e0fffc17 	ldw	r3,-16(fp)
 d03bdac:	00804004 	movi	r2,256
 d03bdb0:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 d03bdb4:	e0fffc17 	ldw	r3,-16(fp)
 d03bdb8:	00800204 	movi	r2,8
 d03bdbc:	1880008d 	sth	r2,2(r3)
   out->ar_hln = 6;
 d03bdc0:	e0fffc17 	ldw	r3,-16(fp)
 d03bdc4:	00800184 	movi	r2,6
 d03bdc8:	18800105 	stb	r2,4(r3)
   out->ar_pln = 4;
 d03bdcc:	e0fffc17 	ldw	r3,-16(fp)
 d03bdd0:	00800104 	movi	r2,4
 d03bdd4:	18800145 	stb	r2,5(r3)
   out->ar_op = ARREP;
 d03bdd8:	e0fffc17 	ldw	r3,-16(fp)
 d03bddc:	00808004 	movi	r2,512
 d03bde0:	1880018d 	sth	r2,6(r3)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 d03bde4:	e0bffd17 	ldw	r2,-12(fp)
 d03bde8:	10c00417 	ldw	r3,16(r2)
 d03bdec:	e0bffc17 	ldw	r2,-16(fp)
 d03bdf0:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 d03bdf4:	e0bffd17 	ldw	r2,-12(fp)
 d03bdf8:	10c00717 	ldw	r3,28(r2)
 d03bdfc:	e0bffc17 	ldw	r2,-16(fp)
 d03be00:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 d03be04:	e0bffc17 	ldw	r2,-16(fp)
 d03be08:	11000504 	addi	r4,r2,20
 d03be0c:	e0bffd17 	ldw	r2,-12(fp)
 d03be10:	11400204 	addi	r5,r2,8
 d03be14:	01800184 	movi	r6,6
 d03be18:	d0027a00 	call	d0027a0 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 d03be1c:	e0bffc17 	ldw	r2,-16(fp)
 d03be20:	11000204 	addi	r4,r2,8
 d03be24:	e0bffe17 	ldw	r2,-8(fp)
 d03be28:	10800617 	ldw	r2,24(r2)
 d03be2c:	10802717 	ldw	r2,156(r2)
 d03be30:	11400517 	ldw	r5,20(r2)
 d03be34:	01800184 	movi	r6,6
 d03be38:	d0027a00 	call	d0027a0 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 d03be3c:	e0bffa17 	ldw	r2,-24(fp)
 d03be40:	11400184 	addi	r5,r2,6
 d03be44:	e13ffb17 	ldw	r4,-20(fp)
 d03be48:	01800184 	movi	r6,6
 d03be4c:	d0027a00 	call	d0027a0 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 d03be50:	e0bffb17 	ldw	r2,-20(fp)
 d03be54:	11000184 	addi	r4,r2,6
 d03be58:	e0bffe17 	ldw	r2,-8(fp)
 d03be5c:	10800617 	ldw	r2,24(r2)
 d03be60:	10802717 	ldw	r2,156(r2)
 d03be64:	11400517 	ldw	r5,20(r2)
 d03be68:	01800184 	movi	r6,6
 d03be6c:	d0027a00 	call	d0027a0 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 d03be70:	e0bffc17 	ldw	r2,-16(fp)
 d03be74:	e0bff915 	stw	r2,-28(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 d03be78:	e0bff917 	ldw	r2,-28(fp)
 d03be7c:	11000204 	addi	r4,r2,8
 d03be80:	e0bffc17 	ldw	r2,-16(fp)
 d03be84:	11400204 	addi	r5,r2,8
 d03be88:	01800184 	movi	r6,6
 d03be8c:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 d03be90:	e0bff917 	ldw	r2,-28(fp)
 d03be94:	10800204 	addi	r2,r2,8
 d03be98:	11000184 	addi	r4,r2,6
 d03be9c:	e0bffc17 	ldw	r2,-16(fp)
 d03bea0:	11400404 	addi	r5,r2,16
 d03bea4:	01800104 	movi	r6,4
 d03bea8:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 d03beac:	e0bff917 	ldw	r2,-28(fp)
 d03beb0:	10800204 	addi	r2,r2,8
 d03beb4:	11000284 	addi	r4,r2,10
 d03beb8:	e0bffc17 	ldw	r2,-16(fp)
 d03bebc:	11400504 	addi	r5,r2,20
 d03bec0:	01800184 	movi	r6,6
 d03bec4:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 d03bec8:	e0bff917 	ldw	r2,-28(fp)
 d03becc:	10800204 	addi	r2,r2,8
 d03bed0:	11000404 	addi	r4,r2,16
 d03bed4:	e0bffc17 	ldw	r2,-16(fp)
 d03bed8:	11400704 	addi	r5,r2,28
 d03bedc:	01800104 	movi	r6,4
 d03bee0:	d0027a00 	call	d0027a0 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 d03bee4:	e0bffe17 	ldw	r2,-8(fp)
 d03bee8:	10800617 	ldw	r2,24(r2)
 d03beec:	10800417 	ldw	r2,16(r2)
 d03bef0:	1005003a 	cmpeq	r2,r2,zero
 d03bef4:	10000a1e 	bne	r2,zero,d03bf20 <arpReply+0x234>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 d03bef8:	e0bffe17 	ldw	r2,-8(fp)
 d03befc:	10c00117 	ldw	r3,4(r2)
 d03bf00:	e0bffe17 	ldw	r2,-8(fp)
 d03bf04:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 d03bf08:	e0bffe17 	ldw	r2,-8(fp)
 d03bf0c:	10800617 	ldw	r2,24(r2)
 d03bf10:	10800417 	ldw	r2,16(r2)
 d03bf14:	e13ffe17 	ldw	r4,-8(fp)
 d03bf18:	103ee83a 	callr	r2
 d03bf1c:	00001006 	br	d03bf60 <arpReply+0x274>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 d03bf20:	e0bffe17 	ldw	r2,-8(fp)
 d03bf24:	10800617 	ldw	r2,24(r2)
 d03bf28:	10c00317 	ldw	r3,12(r2)
 d03bf2c:	e0bfff17 	ldw	r2,-4(fp)
 d03bf30:	11000617 	ldw	r4,24(r2)
 d03bf34:	e0bffe17 	ldw	r2,-8(fp)
 d03bf38:	11400117 	ldw	r5,4(r2)
 d03bf3c:	e0bffe17 	ldw	r2,-8(fp)
 d03bf40:	11800417 	ldw	r6,16(r2)
 d03bf44:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03bf48:	01000084 	movi	r4,2
 d03bf4c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 d03bf50:	e13ffe17 	ldw	r4,-8(fp)
 d03bf54:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03bf58:	01000084 	movi	r4,2
 d03bf5c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 d03bf60:	d0a0c417 	ldw	r2,-31984(gp)
 d03bf64:	10800044 	addi	r2,r2,1
 d03bf68:	d0a0c415 	stw	r2,-31984(gp)
}
 d03bf6c:	e037883a 	mov	sp,fp
 d03bf70:	dfc00117 	ldw	ra,4(sp)
 d03bf74:	df000017 	ldw	fp,0(sp)
 d03bf78:	dec00204 	addi	sp,sp,8
 d03bf7c:	f800283a 	ret

0d03bf80 <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 d03bf80:	defff804 	addi	sp,sp,-32
 d03bf84:	dfc00715 	stw	ra,28(sp)
 d03bf88:	df000615 	stw	fp,24(sp)
 d03bf8c:	df000604 	addi	fp,sp,24
 d03bf90:	e13ffe15 	stw	r4,-8(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 d03bf94:	e0bffe17 	ldw	r2,-8(fp)
 d03bf98:	10800317 	ldw	r2,12(r2)
 d03bf9c:	10bffc84 	addi	r2,r2,-14
 d03bfa0:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 d03bfa4:	e0bffe17 	ldw	r2,-8(fp)
 d03bfa8:	10800317 	ldw	r2,12(r2)
 d03bfac:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 d03bfb0:	e0bffd17 	ldw	r2,-12(fp)
 d03bfb4:	e0bffa15 	stw	r2,-24(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 d03bfb8:	e0bffd17 	ldw	r2,-12(fp)
 d03bfbc:	11000704 	addi	r4,r2,28
 d03bfc0:	e0bffa17 	ldw	r2,-24(fp)
 d03bfc4:	10800204 	addi	r2,r2,8
 d03bfc8:	11400404 	addi	r5,r2,16
 d03bfcc:	01800104 	movi	r6,4
 d03bfd0:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 d03bfd4:	e0bffd17 	ldw	r2,-12(fp)
 d03bfd8:	11000504 	addi	r4,r2,20
 d03bfdc:	e0bffa17 	ldw	r2,-24(fp)
 d03bfe0:	10800204 	addi	r2,r2,8
 d03bfe4:	11400284 	addi	r5,r2,10
 d03bfe8:	01800184 	movi	r6,6
 d03bfec:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 d03bff0:	e0bffd17 	ldw	r2,-12(fp)
 d03bff4:	11000404 	addi	r4,r2,16
 d03bff8:	e0bffa17 	ldw	r2,-24(fp)
 d03bffc:	10800204 	addi	r2,r2,8
 d03c000:	11400184 	addi	r5,r2,6
 d03c004:	01800104 	movi	r6,4
 d03c008:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 d03c00c:	e0bffd17 	ldw	r2,-12(fp)
 d03c010:	11000204 	addi	r4,r2,8
 d03c014:	e0bffa17 	ldw	r2,-24(fp)
 d03c018:	11400204 	addi	r5,r2,8
 d03c01c:	01800184 	movi	r6,6
 d03c020:	d0027a00 	call	d0027a0 <memmove>
   }
#endif

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 d03c024:	e0bffd17 	ldw	r2,-12(fp)
 d03c028:	10c00717 	ldw	r3,28(r2)
 d03c02c:	e0bffe17 	ldw	r2,-8(fp)
 d03c030:	10800617 	ldw	r2,24(r2)
 d03c034:	10800a17 	ldw	r2,40(r2)
 d03c038:	18801f26 	beq	r3,r2,d03c0b8 <arprcv+0x138>
 d03c03c:	e0bffd17 	ldw	r2,-12(fp)
 d03c040:	10800717 	ldw	r2,28(r2)
 d03c044:	1004d63a 	srli	r2,r2,24
 d03c048:	10c03fcc 	andi	r3,r2,255
 d03c04c:	e0bffd17 	ldw	r2,-12(fp)
 d03c050:	10800717 	ldw	r2,28(r2)
 d03c054:	1004d23a 	srli	r2,r2,8
 d03c058:	10bfc00c 	andi	r2,r2,65280
 d03c05c:	1886b03a 	or	r3,r3,r2
 d03c060:	e0bffd17 	ldw	r2,-12(fp)
 d03c064:	10800717 	ldw	r2,28(r2)
 d03c068:	10bfc00c 	andi	r2,r2,65280
 d03c06c:	1004923a 	slli	r2,r2,8
 d03c070:	1886b03a 	or	r3,r3,r2
 d03c074:	e0bffd17 	ldw	r2,-12(fp)
 d03c078:	10800717 	ldw	r2,28(r2)
 d03c07c:	10803fcc 	andi	r2,r2,255
 d03c080:	1004963a 	slli	r2,r2,24
 d03c084:	1884b03a 	or	r2,r3,r2
 d03c088:	10fc002c 	andhi	r3,r2,61440
 d03c08c:	00b80034 	movhi	r2,57344
 d03c090:	18800926 	beq	r3,r2,d03c0b8 <arprcv+0x138>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03c094:	01000084 	movi	r4,2
 d03c098:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 d03c09c:	e13ffe17 	ldw	r4,-8(fp)
 d03c0a0:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03c0a4:	01000084 	movi	r4,2
 d03c0a8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 d03c0ac:	00800084 	movi	r2,2
 d03c0b0:	e0bfff15 	stw	r2,-4(fp)
 d03c0b4:	00004406 	br	d03c1c8 <arprcv+0x248>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 d03c0b8:	e0bffd17 	ldw	r2,-12(fp)
 d03c0bc:	1080018b 	ldhu	r2,6(r2)
 d03c0c0:	10bfffcc 	andi	r2,r2,65535
 d03c0c4:	10804018 	cmpnei	r2,r2,256
 d03c0c8:	10000b1e 	bne	r2,zero,d03c0f8 <arprcv+0x178>
   {
      arpReqsIn++;   /* count these */
 d03c0cc:	d0a0c117 	ldw	r2,-31996(gp)
 d03c0d0:	10800044 	addi	r2,r2,1
 d03c0d4:	d0a0c115 	stw	r2,-31996(gp)
      arpReply(pkt); /* send arp reply */
 d03c0d8:	e13ffe17 	ldw	r4,-8(fp)
 d03c0dc:	d03bcec0 	call	d03bcec <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 d03c0e0:	e0bffd17 	ldw	r2,-12(fp)
 d03c0e4:	11000417 	ldw	r4,16(r2)
 d03c0e8:	e0bffe17 	ldw	r2,-8(fp)
 d03c0ec:	11400617 	ldw	r5,24(r2)
 d03c0f0:	d03bbd80 	call	d03bbd8 <make_arp_entry>
 d03c0f4:	00000306 	br	d03c104 <arprcv+0x184>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 d03c0f8:	d0a0c317 	ldw	r2,-31988(gp)
 d03c0fc:	10800044 	addi	r2,r2,1
 d03c100:	d0a0c315 	stw	r2,-31988(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03c104:	008341b4 	movhi	r2,3334
 d03c108:	10b4a604 	addi	r2,r2,-11624
 d03c10c:	e0bffc15 	stw	r2,-16(fp)
 d03c110:	00002106 	br	d03c198 <arprcv+0x218>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 d03c114:	e0bffc17 	ldw	r2,-16(fp)
 d03c118:	10c00017 	ldw	r3,0(r2)
 d03c11c:	e0bffd17 	ldw	r2,-12(fp)
 d03c120:	10800417 	ldw	r2,16(r2)
 d03c124:	1880191e 	bne	r3,r2,d03c18c <arprcv+0x20c>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 d03c128:	e0bffc17 	ldw	r2,-16(fp)
 d03c12c:	11000104 	addi	r4,r2,4
 d03c130:	e0bffd17 	ldw	r2,-12(fp)
 d03c134:	11400204 	addi	r5,r2,8
 d03c138:	01800184 	movi	r6,6
 d03c13c:	d0027a00 	call	d0027a0 <memmove>
         tp->lasttime = cticks;
 d03c140:	00834174 	movhi	r2,3333
 d03c144:	108ac904 	addi	r2,r2,11044
 d03c148:	10c00017 	ldw	r3,0(r2)
 d03c14c:	e0bffc17 	ldw	r2,-16(fp)
 d03c150:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 d03c154:	e0bffc17 	ldw	r2,-16(fp)
 d03c158:	10800417 	ldw	r2,16(r2)
 d03c15c:	1005003a 	cmpeq	r2,r2,zero
 d03c160:	1000021e 	bne	r2,zero,d03c16c <arprcv+0x1ec>
         {
            arp_send_pending(tp);
 d03c164:	e13ffc17 	ldw	r4,-16(fp)
 d03c168:	d03b5240 	call	d03b524 <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03c16c:	01000084 	movi	r4,2
 d03c170:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 d03c174:	e13ffe17 	ldw	r4,-8(fp)
 d03c178:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03c17c:	01000084 	movi	r4,2
 d03c180:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

         return (0);
 d03c184:	e03fff15 	stw	zero,-4(fp)
 d03c188:	00000f06 	br	d03c1c8 <arprcv+0x248>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03c18c:	e0bffc17 	ldw	r2,-16(fp)
 d03c190:	10800804 	addi	r2,r2,32
 d03c194:	e0bffc15 	stw	r2,-16(fp)
 d03c198:	00c341b4 	movhi	r3,3334
 d03c19c:	18f4e604 	addi	r3,r3,-11368
 d03c1a0:	e0bffc17 	ldw	r2,-16(fp)
 d03c1a4:	10ffdb36 	bltu	r2,r3,d03c114 <arprcv+0x194>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d03c1a8:	01000084 	movi	r4,2
 d03c1ac:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free(pkt);
 d03c1b0:	e13ffe17 	ldw	r4,-8(fp)
 d03c1b4:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03c1b8:	01000084 	movi	r4,2
 d03c1bc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 d03c1c0:	00800084 	movi	r2,2
 d03c1c4:	e0bfff15 	stw	r2,-4(fp)
 d03c1c8:	e0bfff17 	ldw	r2,-4(fp)
}
 d03c1cc:	e037883a 	mov	sp,fp
 d03c1d0:	dfc00117 	ldw	ra,4(sp)
 d03c1d4:	df000017 	ldw	fp,0(sp)
 d03c1d8:	dec00204 	addi	sp,sp,8
 d03c1dc:	f800283a 	ret

0d03c1e0 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 d03c1e0:	defff704 	addi	sp,sp,-36
 d03c1e4:	dfc00815 	stw	ra,32(sp)
 d03c1e8:	df000715 	stw	fp,28(sp)
 d03c1ec:	df000704 	addi	fp,sp,28
 d03c1f0:	e13ffd15 	stw	r4,-12(fp)
 d03c1f4:	e17ffe15 	stw	r5,-8(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 d03c1f8:	00834174 	movhi	r2,3333
 d03c1fc:	108ac904 	addi	r2,r2,11044
 d03c200:	10800017 	ldw	r2,0(r2)
 d03c204:	e0bffb15 	stw	r2,-20(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 d03c208:	e0bffe17 	ldw	r2,-8(fp)
 d03c20c:	1004c03a 	cmpne	r2,r2,zero
 d03c210:	1000091e 	bne	r2,zero,d03c238 <send_via_arp+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03c214:	01000084 	movi	r4,2
 d03c218:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 d03c21c:	e13ffd17 	ldw	r4,-12(fp)
 d03c220:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03c224:	01000084 	movi	r4,2
 d03c228:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 d03c22c:	00bffa84 	movi	r2,-22
 d03c230:	e0bfff15 	stw	r2,-4(fp)
 d03c234:	00004e06 	br	d03c370 <send_via_arp+0x190>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 d03c238:	d0e0c517 	ldw	r3,-31980(gp)
 d03c23c:	e0bffb17 	ldw	r2,-20(fp)
 d03c240:	10c5c83a 	sub	r2,r2,r3
 d03c244:	10801970 	cmpltui	r2,r2,101
 d03c248:	1000011e 	bne	r2,zero,d03c250 <send_via_arp+0x70>
      arpcache = (struct arptabent *)NULL;
 d03c24c:	d020c015 	stw	zero,-32000(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 d03c250:	d0a0c017 	ldw	r2,-32000(gp)
 d03c254:	1005003a 	cmpeq	r2,r2,zero
 d03c258:	1000071e 	bne	r2,zero,d03c278 <send_via_arp+0x98>
 d03c25c:	d0a0c017 	ldw	r2,-32000(gp)
 d03c260:	10c00017 	ldw	r3,0(r2)
 d03c264:	e0bffe17 	ldw	r2,-8(fp)
 d03c268:	1880031e 	bne	r3,r2,d03c278 <send_via_arp+0x98>
      tp = arpcache;
 d03c26c:	d0a0c017 	ldw	r2,-32000(gp)
 d03c270:	e0bffc15 	stw	r2,-16(fp)
   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
      arpcache = (struct arptabent *)NULL;

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 d03c274:	00000306 	br	d03c284 <send_via_arp+0xa4>
      tp = arpcache;
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 d03c278:	e13ffe17 	ldw	r4,-8(fp)
 d03c27c:	d03ba300 	call	d03ba30 <find_oldest_arp>
 d03c280:	e0bffc15 	stw	r2,-16(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 d03c284:	e0bffc17 	ldw	r2,-16(fp)
 d03c288:	10c00017 	ldw	r3,0(r2)
 d03c28c:	e0bffe17 	ldw	r2,-8(fp)
 d03c290:	1880311e 	bne	r3,r2,d03c358 <send_via_arp+0x178>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 d03c294:	e0bffc17 	ldw	r2,-16(fp)
 d03c298:	10800417 	ldw	r2,16(r2)
 d03c29c:	1005003a 	cmpeq	r2,r2,zero
 d03c2a0:	1000241e 	bne	r2,zero,d03c334 <send_via_arp+0x154>
      {
         if (lilfreeq.q_len < 2)
 d03c2a4:	008341b4 	movhi	r2,3334
 d03c2a8:	10b30704 	addi	r2,r2,-13284
 d03c2ac:	10800217 	ldw	r2,8(r2)
 d03c2b0:	10800088 	cmpgei	r2,r2,2
 d03c2b4:	1000091e 	bne	r2,zero,d03c2dc <send_via_arp+0xfc>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03c2b8:	01000084 	movi	r4,2
 d03c2bc:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 d03c2c0:	e13ffd17 	ldw	r4,-12(fp)
 d03c2c4:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03c2c8:	01000084 	movi	r4,2
 d03c2cc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 d03c2d0:	00bffa84 	movi	r2,-22
 d03c2d4:	e0bffa15 	stw	r2,-24(fp)
 d03c2d8:	00002306 	br	d03c368 <send_via_arp+0x188>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 d03c2dc:	e0bffc17 	ldw	r2,-16(fp)
 d03c2e0:	10800417 	ldw	r2,16(r2)
 d03c2e4:	e0bff915 	stw	r2,-28(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 d03c2e8:	00000306 	br	d03c2f8 <send_via_arp+0x118>
               tmppkt = tmppkt->next;
 d03c2ec:	e0bff917 	ldw	r2,-28(fp)
 d03c2f0:	10800017 	ldw	r2,0(r2)
 d03c2f4:	e0bff915 	stw	r2,-28(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 d03c2f8:	e0bff917 	ldw	r2,-28(fp)
 d03c2fc:	10800017 	ldw	r2,0(r2)
 d03c300:	1004c03a 	cmpne	r2,r2,zero
 d03c304:	103ff91e 	bne	r2,zero,d03c2ec <send_via_arp+0x10c>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 d03c308:	e0fff917 	ldw	r3,-28(fp)
 d03c30c:	e0bffd17 	ldw	r2,-12(fp)
 d03c310:	18800015 	stw	r2,0(r3)
            if (pkt->next)
 d03c314:	e0bffd17 	ldw	r2,-12(fp)
 d03c318:	10800017 	ldw	r2,0(r2)
 d03c31c:	1005003a 	cmpeq	r2,r2,zero
 d03c320:	1000011e 	bne	r2,zero,d03c328 <send_via_arp+0x148>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 d03c324:	d0293e80 	call	d0293e8 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 d03c328:	00800044 	movi	r2,1
 d03c32c:	e0bffa15 	stw	r2,-24(fp)
 d03c330:	00000d06 	br	d03c368 <send_via_arp+0x188>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 d03c334:	e0bffc17 	ldw	r2,-16(fp)
 d03c338:	d0a0c015 	stw	r2,-32000(gp)
         cachetime = lticks;  /* mark time we cached */
 d03c33c:	e0bffb17 	ldw	r2,-20(fp)
 d03c340:	d0a0c515 	stw	r2,-31980(gp)
         err = et_send(pkt, tp);
 d03c344:	e13ffd17 	ldw	r4,-12(fp)
 d03c348:	e17ffc17 	ldw	r5,-16(fp)
 d03c34c:	d03b3200 	call	d03b320 <et_send>
 d03c350:	e0bffa15 	stw	r2,-24(fp)
 d03c354:	00000406 	br	d03c368 <send_via_arp+0x188>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 d03c358:	e13ffd17 	ldw	r4,-12(fp)
 d03c35c:	e17ffe17 	ldw	r5,-8(fp)
 d03c360:	d03b5980 	call	d03b598 <send_arp>
 d03c364:	e0bffa15 	stw	r2,-24(fp)

   return (err);
 d03c368:	e0bffa17 	ldw	r2,-24(fp)
 d03c36c:	e0bfff15 	stw	r2,-4(fp)
 d03c370:	e0bfff17 	ldw	r2,-4(fp)
}
 d03c374:	e037883a 	mov	sp,fp
 d03c378:	dfc00117 	ldw	ra,4(sp)
 d03c37c:	df000017 	ldw	fp,0(sp)
 d03c380:	dec00204 	addi	sp,sp,8
 d03c384:	f800283a 	ret

0d03c388 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 d03c388:	defffa04 	addi	sp,sp,-24
 d03c38c:	dfc00515 	stw	ra,20(sp)
 d03c390:	df000415 	stw	fp,16(sp)
 d03c394:	df000404 	addi	fp,sp,16
 d03c398:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 d03c39c:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 d03c3a0:	00834174 	movhi	r2,3333
 d03c3a4:	108ac904 	addi	r2,r2,11044
 d03c3a8:	10800017 	ldw	r2,0(r2)
 d03c3ac:	e0bffc15 	stw	r2,-16(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03c3b0:	008341b4 	movhi	r2,3334
 d03c3b4:	10b4a604 	addi	r2,r2,-11624
 d03c3b8:	e0bffe15 	stw	r2,-8(fp)
 d03c3bc:	00002906 	br	d03c464 <cb_arpent_tmo+0xdc>
   {
      if (tp->t_pro_addr != 0)
 d03c3c0:	e0bffe17 	ldw	r2,-8(fp)
 d03c3c4:	10800017 	ldw	r2,0(r2)
 d03c3c8:	1005003a 	cmpeq	r2,r2,zero
 d03c3cc:	1000221e 	bne	r2,zero,d03c458 <cb_arpent_tmo+0xd0>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 d03c3d0:	e0bffe17 	ldw	r2,-8(fp)
 d03c3d4:	10800417 	ldw	r2,16(r2)
 d03c3d8:	1005003a 	cmpeq	r2,r2,zero
 d03c3dc:	10000b1e 	bne	r2,zero,d03c40c <cb_arpent_tmo+0x84>
 d03c3e0:	e0bffe17 	ldw	r2,-8(fp)
 d03c3e4:	10c00517 	ldw	r3,20(r2)
 d03c3e8:	e0bffc17 	ldw	r2,-16(fp)
 d03c3ec:	10c5c83a 	sub	r2,r2,r3
 d03c3f0:	10801970 	cmpltui	r2,r2,101
 d03c3f4:	1000051e 	bne	r2,zero,d03c40c <cb_arpent_tmo+0x84>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 d03c3f8:	e13ffe17 	ldw	r4,-8(fp)
 d03c3fc:	d03b49c0 	call	d03b49c <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 d03c400:	e0bffe17 	ldw	r2,-8(fp)
 d03c404:	10000015 	stw	zero,0(r2)
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
   {
      if (tp->t_pro_addr != 0)
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 d03c408:	00001306 	br	d03c458 <cb_arpent_tmo+0xd0>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 d03c40c:	e0bffe17 	ldw	r2,-8(fp)
 d03c410:	10c00517 	ldw	r3,20(r2)
 d03c414:	e0bffc17 	ldw	r2,-16(fp)
 d03c418:	10c5c83a 	sub	r2,r2,r3
 d03c41c:	1007883a 	mov	r3,r2
 d03c420:	d0a04f17 	ldw	r2,-32452(gp)
 d03c424:	18800916 	blt	r3,r2,d03c44c <cb_arpent_tmo+0xc4>
 d03c428:	e0bffe17 	ldw	r2,-8(fp)
 d03c42c:	10c00617 	ldw	r3,24(r2)
 d03c430:	e0bffc17 	ldw	r2,-16(fp)
 d03c434:	10c5c83a 	sub	r2,r2,r3
 d03c438:	10801930 	cmpltui	r2,r2,100
 d03c43c:	1000031e 	bne	r2,zero,d03c44c <cb_arpent_tmo+0xc4>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 d03c440:	e0bffe17 	ldw	r2,-8(fp)
 d03c444:	10000015 	stw	zero,0(r2)
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 d03c448:	00000306 	br	d03c458 <cb_arpent_tmo+0xd0>
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else
            arp_count++;
 d03c44c:	e0bffd17 	ldw	r2,-12(fp)
 d03c450:	10800044 	addi	r2,r2,1
 d03c454:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 d03c458:	e0bffe17 	ldw	r2,-8(fp)
 d03c45c:	10800804 	addi	r2,r2,32
 d03c460:	e0bffe15 	stw	r2,-8(fp)
 d03c464:	00c341b4 	movhi	r3,3334
 d03c468:	18f4e604 	addi	r3,r3,-11368
 d03c46c:	e0bffe17 	ldw	r2,-8(fp)
 d03c470:	10ffd336 	bltu	r2,r3,d03c3c0 <cb_arpent_tmo+0x38>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 d03c474:	e0bffd17 	ldw	r2,-12(fp)
 d03c478:	1004c03a 	cmpne	r2,r2,zero
 d03c47c:	1000031e 	bne	r2,zero,d03c48c <cb_arpent_tmo+0x104>
   {
      in_timerkill(arp_timer);
 d03c480:	d120bf17 	ldw	r4,-32004(gp)
 d03c484:	d03b0d00 	call	d03b0d0 <in_timerkill>
      arp_timer = 0;
 d03c488:	d020bf15 	stw	zero,-32004(gp)
   }
      
   USE_ARG(arg);
}
 d03c48c:	e037883a 	mov	sp,fp
 d03c490:	dfc00117 	ldw	ra,4(sp)
 d03c494:	df000017 	ldw	fp,0(sp)
 d03c498:	dec00204 	addi	sp,sp,8
 d03c49c:	f800283a 	ret

0d03c4a0 <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 d03c4a0:	defff604 	addi	sp,sp,-40
 d03c4a4:	dfc00915 	stw	ra,36(sp)
 d03c4a8:	df000815 	stw	fp,32(sp)
 d03c4ac:	df000804 	addi	fp,sp,32
 d03c4b0:	e13ffd15 	stw	r4,-12(fp)
 d03c4b4:	e17ffe15 	stw	r5,-8(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 d03c4b8:	e0bffd17 	ldw	r2,-12(fp)
 d03c4bc:	10802717 	ldw	r2,156(r2)
 d03c4c0:	e0bffa15 	stw	r2,-24(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 d03c4c4:	01000084 	movi	r4,2
 d03c4c8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 d03c4cc:	01000c04 	movi	r4,48
 d03c4d0:	d0287a40 	call	d0287a4 <pk_alloc>
 d03c4d4:	e0bff915 	stw	r2,-28(fp)
   if (!arppkt)
 d03c4d8:	e0bff917 	ldw	r2,-28(fp)
 d03c4dc:	1004c03a 	cmpne	r2,r2,zero
 d03c4e0:	1000051e 	bne	r2,zero,d03c4f8 <grat_arp+0x58>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03c4e4:	01000084 	movi	r4,2
 d03c4e8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 d03c4ec:	00bffa84 	movi	r2,-22
 d03c4f0:	e0bfff15 	stw	r2,-4(fp)
 d03c4f4:	00009706 	br	d03c754 <grat_arp+0x2b4>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03c4f8:	01000084 	movi	r4,2
 d03c4fc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 d03c500:	e0bff917 	ldw	r2,-28(fp)
 d03c504:	10c00117 	ldw	r3,4(r2)
 d03c508:	e0bff917 	ldw	r2,-28(fp)
 d03c50c:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 d03c510:	e0fff917 	ldw	r3,-28(fp)
 d03c514:	00800c04 	movi	r2,48
 d03c518:	18800415 	stw	r2,16(r3)
   arppkt->net = net;
 d03c51c:	e0fff917 	ldw	r3,-28(fp)
 d03c520:	e0bffd17 	ldw	r2,-12(fp)
 d03c524:	18800615 	stw	r2,24(r3)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 d03c528:	e0bff917 	ldw	r2,-28(fp)
 d03c52c:	10800117 	ldw	r2,4(r2)
 d03c530:	10800084 	addi	r2,r2,2
 d03c534:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 d03c538:	e0bff917 	ldw	r2,-28(fp)
 d03c53c:	10800117 	ldw	r2,4(r2)
 d03c540:	10800404 	addi	r2,r2,16
 d03c544:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 d03c548:	e0fffb17 	ldw	r3,-20(fp)
 d03c54c:	00804004 	movi	r2,256
 d03c550:	1880000d 	sth	r2,0(r3)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 d03c554:	e0fffb17 	ldw	r3,-20(fp)
 d03c558:	00800204 	movi	r2,8
 d03c55c:	1880008d 	sth	r2,2(r3)
   arphdr->ar_hln = 6;
 d03c560:	e0fffb17 	ldw	r3,-20(fp)
 d03c564:	00800184 	movi	r2,6
 d03c568:	18800105 	stb	r2,4(r3)
   arphdr->ar_pln = 4;
 d03c56c:	e0fffb17 	ldw	r3,-20(fp)
 d03c570:	00800104 	movi	r2,4
 d03c574:	18800145 	stb	r2,5(r3)
   
   /* ARP req? */
   if (flag == 0)
 d03c578:	e0bffe17 	ldw	r2,-8(fp)
 d03c57c:	1004c03a 	cmpne	r2,r2,zero
 d03c580:	1000041e 	bne	r2,zero,d03c594 <grat_arp+0xf4>
      /* yup */
      arphdr->ar_op = ARREQ;
 d03c584:	e0fffb17 	ldw	r3,-20(fp)
 d03c588:	00804004 	movi	r2,256
 d03c58c:	1880018d 	sth	r2,6(r3)
 d03c590:	00000306 	br	d03c5a0 <grat_arp+0x100>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 d03c594:	e0fffb17 	ldw	r3,-20(fp)
 d03c598:	00808004 	movi	r2,512
 d03c59c:	1880018d 	sth	r2,6(r3)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 d03c5a0:	e0bffd17 	ldw	r2,-12(fp)
 d03c5a4:	10c00a17 	ldw	r3,40(r2)
 d03c5a8:	e0bffb17 	ldw	r2,-20(fp)
 d03c5ac:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 d03c5b0:	e0bffd17 	ldw	r2,-12(fp)
 d03c5b4:	10c00a17 	ldw	r3,40(r2)
 d03c5b8:	e0bffb17 	ldw	r2,-20(fp)
 d03c5bc:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 d03c5c0:	e0bffb17 	ldw	r2,-20(fp)
 d03c5c4:	11000204 	addi	r4,r2,8
 d03c5c8:	e0bffa17 	ldw	r2,-24(fp)
 d03c5cc:	11400517 	ldw	r5,20(r2)
 d03c5d0:	01800184 	movi	r6,6
 d03c5d4:	d0027a00 	call	d0027a0 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 d03c5d8:	e0fffc17 	ldw	r3,-16(fp)
 d03c5dc:	00bfffc4 	movi	r2,-1
 d03c5e0:	18800005 	stb	r2,0(r3)
 d03c5e4:	00bfffc4 	movi	r2,-1
 d03c5e8:	18800045 	stb	r2,1(r3)
 d03c5ec:	00bfffc4 	movi	r2,-1
 d03c5f0:	18800085 	stb	r2,2(r3)
 d03c5f4:	00bfffc4 	movi	r2,-1
 d03c5f8:	188000c5 	stb	r2,3(r3)
 d03c5fc:	00bfffc4 	movi	r2,-1
 d03c600:	18800105 	stb	r2,4(r3)
 d03c604:	00bfffc4 	movi	r2,-1
 d03c608:	18800145 	stb	r2,5(r3)
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 d03c60c:	e0bffc17 	ldw	r2,-16(fp)
 d03c610:	11000184 	addi	r4,r2,6
 d03c614:	e0bffa17 	ldw	r2,-24(fp)
 d03c618:	11400517 	ldw	r5,20(r2)
 d03c61c:	01800184 	movi	r6,6
 d03c620:	d0027a00 	call	d0027a0 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 d03c624:	e0bffc17 	ldw	r2,-16(fp)
 d03c628:	10c00304 	addi	r3,r2,12
 d03c62c:	00800204 	movi	r2,8
 d03c630:	18800005 	stb	r2,0(r3)
 d03c634:	e0bffc17 	ldw	r2,-16(fp)
 d03c638:	10c00344 	addi	r3,r2,13
 d03c63c:	00800184 	movi	r2,6
 d03c640:	18800005 	stb	r2,0(r3)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 d03c644:	e0bffb17 	ldw	r2,-20(fp)
 d03c648:	e0bff815 	stw	r2,-32(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 d03c64c:	e0bff817 	ldw	r2,-32(fp)
 d03c650:	11000204 	addi	r4,r2,8
 d03c654:	e0bffb17 	ldw	r2,-20(fp)
 d03c658:	11400204 	addi	r5,r2,8
 d03c65c:	01800184 	movi	r6,6
 d03c660:	d0027a00 	call	d0027a0 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 d03c664:	e0bff817 	ldw	r2,-32(fp)
 d03c668:	10800204 	addi	r2,r2,8
 d03c66c:	11000184 	addi	r4,r2,6
 d03c670:	e0bffb17 	ldw	r2,-20(fp)
 d03c674:	11400404 	addi	r5,r2,16
 d03c678:	01800104 	movi	r6,4
 d03c67c:	d0027a00 	call	d0027a0 <memmove>

   /* ARP req? */
   if (flag == 0)
 d03c680:	e0bffe17 	ldw	r2,-8(fp)
 d03c684:	1004c03a 	cmpne	r2,r2,zero
 d03c688:	1000081e 	bne	r2,zero,d03c6ac <grat_arp+0x20c>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 d03c68c:	e0bff817 	ldw	r2,-32(fp)
 d03c690:	10800204 	addi	r2,r2,8
 d03c694:	11000284 	addi	r4,r2,10
 d03c698:	e0bffb17 	ldw	r2,-20(fp)
 d03c69c:	11400504 	addi	r5,r2,20
 d03c6a0:	01800184 	movi	r6,6
 d03c6a4:	d0027a00 	call	d0027a0 <memmove>
 d03c6a8:	00000706 	br	d03c6c8 <grat_arp+0x228>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 d03c6ac:	e0bff817 	ldw	r2,-32(fp)
 d03c6b0:	10800204 	addi	r2,r2,8
 d03c6b4:	11000284 	addi	r4,r2,10
 d03c6b8:	e0bffb17 	ldw	r2,-20(fp)
 d03c6bc:	11400204 	addi	r5,r2,8
 d03c6c0:	01800184 	movi	r6,6
 d03c6c4:	d0027a00 	call	d0027a0 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 d03c6c8:	e0bff817 	ldw	r2,-32(fp)
 d03c6cc:	10800204 	addi	r2,r2,8
 d03c6d0:	11000404 	addi	r4,r2,16
 d03c6d4:	e0bffb17 	ldw	r2,-20(fp)
 d03c6d8:	11400704 	addi	r5,r2,28
 d03c6dc:	01800104 	movi	r6,4
 d03c6e0:	d0027a00 	call	d0027a0 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 d03c6e4:	e0bffd17 	ldw	r2,-12(fp)
 d03c6e8:	10800417 	ldw	r2,16(r2)
 d03c6ec:	1005003a 	cmpeq	r2,r2,zero
 d03c6f0:	1000051e 	bne	r2,zero,d03c708 <grat_arp+0x268>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 d03c6f4:	e0bffd17 	ldw	r2,-12(fp)
 d03c6f8:	10800417 	ldw	r2,16(r2)
 d03c6fc:	e13ff917 	ldw	r4,-28(fp)
 d03c700:	103ee83a 	callr	r2
 d03c704:	00000e06 	br	d03c740 <grat_arp+0x2a0>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 d03c708:	e0bffd17 	ldw	r2,-12(fp)
 d03c70c:	10c00317 	ldw	r3,12(r2)
 d03c710:	e0bff917 	ldw	r2,-28(fp)
 d03c714:	11000617 	ldw	r4,24(r2)
 d03c718:	e0bff917 	ldw	r2,-28(fp)
 d03c71c:	11400117 	ldw	r5,4(r2)
 d03c720:	01800c04 	movi	r6,48
 d03c724:	183ee83a 	callr	r3
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03c728:	01000084 	movi	r4,2
 d03c72c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 d03c730:	e13ff917 	ldw	r4,-28(fp)
 d03c734:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03c738:	01000084 	movi	r4,2
 d03c73c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 d03c740:	d0a0c217 	ldw	r2,-31992(gp)
 d03c744:	10800044 	addi	r2,r2,1
 d03c748:	d0a0c215 	stw	r2,-31992(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 d03c74c:	00800044 	movi	r2,1
 d03c750:	e0bfff15 	stw	r2,-4(fp)
 d03c754:	e0bfff17 	ldw	r2,-4(fp)
}
 d03c758:	e037883a 	mov	sp,fp
 d03c75c:	dfc00117 	ldw	ra,4(sp)
 d03c760:	df000017 	ldw	fp,0(sp)
 d03c764:	dec00204 	addi	sp,sp,8
 d03c768:	f800283a 	ret

0d03c76c <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 d03c76c:	defffb04 	addi	sp,sp,-20
 d03c770:	dfc00415 	stw	ra,16(sp)
 d03c774:	df000315 	stw	fp,12(sp)
 d03c778:	df000304 	addi	fp,sp,12
 d03c77c:	e13ffe15 	stw	r4,-8(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d03c780:	008341b4 	movhi	r2,3334
 d03c784:	10b4e604 	addi	r2,r2,-11368
 d03c788:	10800017 	ldw	r2,0(r2)
 d03c78c:	e0bffd15 	stw	r2,-12(fp)
 d03c790:	00000c06 	br	d03c7c4 <if_getbynum+0x58>
   {
      if(ifnum-- == 0)
 d03c794:	e0bffe17 	ldw	r2,-8(fp)
 d03c798:	10bfffc4 	addi	r2,r2,-1
 d03c79c:	e0bffe15 	stw	r2,-8(fp)
 d03c7a0:	e0bffe17 	ldw	r2,-8(fp)
 d03c7a4:	10bfffd8 	cmpnei	r2,r2,-1
 d03c7a8:	1000031e 	bne	r2,zero,d03c7b8 <if_getbynum+0x4c>
         return ifp;
 d03c7ac:	e0bffd17 	ldw	r2,-12(fp)
 d03c7b0:	e0bfff15 	stw	r2,-4(fp)
 d03c7b4:	00000806 	br	d03c7d8 <if_getbynum+0x6c>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d03c7b8:	e0bffd17 	ldw	r2,-12(fp)
 d03c7bc:	10800017 	ldw	r2,0(r2)
 d03c7c0:	e0bffd15 	stw	r2,-12(fp)
 d03c7c4:	e0bffd17 	ldw	r2,-12(fp)
 d03c7c8:	1004c03a 	cmpne	r2,r2,zero
 d03c7cc:	103ff11e 	bne	r2,zero,d03c794 <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 d03c7d0:	d0293e80 	call	d0293e8 <dtrap>
   return NULL;   /* list is not long enough */
 d03c7d4:	e03fff15 	stw	zero,-4(fp)
 d03c7d8:	e0bfff17 	ldw	r2,-4(fp)
}
 d03c7dc:	e037883a 	mov	sp,fp
 d03c7e0:	dfc00117 	ldw	ra,4(sp)
 d03c7e4:	df000017 	ldw	fp,0(sp)
 d03c7e8:	dec00204 	addi	sp,sp,8
 d03c7ec:	f800283a 	ret

0d03c7f0 <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 d03c7f0:	defffc04 	addi	sp,sp,-16
 d03c7f4:	df000315 	stw	fp,12(sp)
 d03c7f8:	df000304 	addi	fp,sp,12
 d03c7fc:	e13ffd15 	stw	r4,-12(fp)
 d03c800:	e17ffe15 	stw	r5,-8(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 d03c804:	e0bffe17 	ldw	r2,-8(fp)
 d03c808:	108000cc 	andi	r2,r2,3
 d03c80c:	1005003a 	cmpeq	r2,r2,zero
 d03c810:	10000e1e 	bne	r2,zero,d03c84c <isbcast+0x5c>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 d03c814:	e0bffe17 	ldw	r2,-8(fp)
 d03c818:	1080000b 	ldhu	r2,0(r2)
 d03c81c:	10ffffcc 	andi	r3,r2,65535
 d03c820:	00bfffd4 	movui	r2,65535
 d03c824:	18800226 	beq	r3,r2,d03c830 <isbcast+0x40>
         return(FALSE);
 d03c828:	e03fff15 	stw	zero,-4(fp)
 d03c82c:	00002306 	br	d03c8bc <isbcast+0xcc>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 d03c830:	e0bffe17 	ldw	r2,-8(fp)
 d03c834:	10800084 	addi	r2,r2,2
 d03c838:	10800017 	ldw	r2,0(r2)
 d03c83c:	10bfffe0 	cmpeqi	r2,r2,-1
 d03c840:	1000101e 	bne	r2,zero,d03c884 <isbcast+0x94>
         return FALSE;
 d03c844:	e03fff15 	stw	zero,-4(fp)
 d03c848:	00001c06 	br	d03c8bc <isbcast+0xcc>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 d03c84c:	e0bffe17 	ldw	r2,-8(fp)
 d03c850:	10800017 	ldw	r2,0(r2)
 d03c854:	10bfffe0 	cmpeqi	r2,r2,-1
 d03c858:	1000021e 	bne	r2,zero,d03c864 <isbcast+0x74>
         return FALSE;
 d03c85c:	e03fff15 	stw	zero,-4(fp)
 d03c860:	00001606 	br	d03c8bc <isbcast+0xcc>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 d03c864:	e0bffe17 	ldw	r2,-8(fp)
 d03c868:	10800104 	addi	r2,r2,4
 d03c86c:	1080000b 	ldhu	r2,0(r2)
 d03c870:	10ffffcc 	andi	r3,r2,65535
 d03c874:	00bfffd4 	movui	r2,65535
 d03c878:	18800226 	beq	r3,r2,d03c884 <isbcast+0x94>
         return(FALSE);
 d03c87c:	e03fff15 	stw	zero,-4(fp)
 d03c880:	00000e06 	br	d03c8bc <isbcast+0xcc>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 d03c884:	e0bffd17 	ldw	r2,-12(fp)
 d03c888:	10802717 	ldw	r2,156(r2)
 d03c88c:	10800217 	ldw	r2,8(r2)
 d03c890:	108005e0 	cmpeqi	r2,r2,23
 d03c894:	1000051e 	bne	r2,zero,d03c8ac <isbcast+0xbc>
 d03c898:	e0bffd17 	ldw	r2,-12(fp)
 d03c89c:	10802717 	ldw	r2,156(r2)
 d03c8a0:	10800217 	ldw	r2,8(r2)
 d03c8a4:	10800718 	cmpnei	r2,r2,28
 d03c8a8:	1000021e 	bne	r2,zero,d03c8b4 <isbcast+0xc4>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 d03c8ac:	e03fff15 	stw	zero,-4(fp)
 d03c8b0:	00000206 	br	d03c8bc <isbcast+0xcc>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 d03c8b4:	00800044 	movi	r2,1
 d03c8b8:	e0bfff15 	stw	r2,-4(fp)
 d03c8bc:	e0bfff17 	ldw	r2,-4(fp)
}
 d03c8c0:	e037883a 	mov	sp,fp
 d03c8c4:	df000017 	ldw	fp,0(sp)
 d03c8c8:	dec00104 	addi	sp,sp,4
 d03c8cc:	f800283a 	ret

0d03c8d0 <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 d03c8d0:	defffa04 	addi	sp,sp,-24
 d03c8d4:	dfc00515 	stw	ra,20(sp)
 d03c8d8:	df000415 	stw	fp,16(sp)
 d03c8dc:	df000404 	addi	fp,sp,16
 d03c8e0:	e13ffe0d 	sth	r4,-8(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d03c8e4:	008341b4 	movhi	r2,3334
 d03c8e8:	10b4e604 	addi	r2,r2,-11368
 d03c8ec:	10800017 	ldw	r2,0(r2)
 d03c8f0:	e0bffd15 	stw	r2,-12(fp)
 d03c8f4:	00001306 	br	d03c944 <reg_type+0x74>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 d03c8f8:	e0bffd17 	ldw	r2,-12(fp)
 d03c8fc:	10800617 	ldw	r2,24(r2)
 d03c900:	1005003a 	cmpeq	r2,r2,zero
 d03c904:	10000c1e 	bne	r2,zero,d03c938 <reg_type+0x68>
      {
         e = (ifp->n_reg_type)(type, ifp);
 d03c908:	e0bffd17 	ldw	r2,-12(fp)
 d03c90c:	10800617 	ldw	r2,24(r2)
 d03c910:	e13ffe0b 	ldhu	r4,-8(fp)
 d03c914:	e17ffd17 	ldw	r5,-12(fp)
 d03c918:	103ee83a 	callr	r2
 d03c91c:	e0bffc15 	stw	r2,-16(fp)
         if (e)
 d03c920:	e0bffc17 	ldw	r2,-16(fp)
 d03c924:	1005003a 	cmpeq	r2,r2,zero
 d03c928:	1000031e 	bne	r2,zero,d03c938 <reg_type+0x68>
            return e;   /* bails out if error */
 d03c92c:	e0bffc17 	ldw	r2,-16(fp)
 d03c930:	e0bfff15 	stw	r2,-4(fp)
 d03c934:	00000706 	br	d03c954 <reg_type+0x84>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 d03c938:	e0bffd17 	ldw	r2,-12(fp)
 d03c93c:	10800017 	ldw	r2,0(r2)
 d03c940:	e0bffd15 	stw	r2,-12(fp)
 d03c944:	e0bffd17 	ldw	r2,-12(fp)
 d03c948:	1004c03a 	cmpne	r2,r2,zero
 d03c94c:	103fea1e 	bne	r2,zero,d03c8f8 <reg_type+0x28>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 d03c950:	e03fff15 	stw	zero,-4(fp)
 d03c954:	e0bfff17 	ldw	r2,-4(fp)
}
 d03c958:	e037883a 	mov	sp,fp
 d03c95c:	dfc00117 	ldw	ra,4(sp)
 d03c960:	df000017 	ldw	fp,0(sp)
 d03c964:	dec00204 	addi	sp,sp,8
 d03c968:	f800283a 	ret

0d03c96c <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 d03c96c:	defffa04 	addi	sp,sp,-24
 d03c970:	dfc00515 	stw	ra,20(sp)
 d03c974:	df000415 	stw	fp,16(sp)
 d03c978:	df000404 	addi	fp,sp,16
 d03c97c:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 d03c980:	008341b4 	movhi	r2,3334
 d03c984:	10b3e204 	addi	r2,r2,-12408
 d03c988:	10800017 	ldw	r2,0(r2)
 d03c98c:	e0bffe15 	stw	r2,-8(fp)
   while(so)
 d03c990:	00001406 	br	d03c9e4 <if_killsocks+0x78>
   {
      if(so->so_pcb)
 d03c994:	e0bffe17 	ldw	r2,-8(fp)
 d03c998:	10800117 	ldw	r2,4(r2)
 d03c99c:	1005003a 	cmpeq	r2,r2,zero
 d03c9a0:	1000051e 	bne	r2,zero,d03c9b8 <if_killsocks+0x4c>
         so_ifp = so->so_pcb->ifp;
 d03c9a4:	e0bffe17 	ldw	r2,-8(fp)
 d03c9a8:	10800117 	ldw	r2,4(r2)
 d03c9ac:	10800a17 	ldw	r2,40(r2)
 d03c9b0:	e0bffc15 	stw	r2,-16(fp)
 d03c9b4:	00000106 	br	d03c9bc <if_killsocks+0x50>
      else
         so_ifp = NULL;
 d03c9b8:	e03ffc15 	stw	zero,-16(fp)
      next = (struct socket *)so->next;
 d03c9bc:	e0bffe17 	ldw	r2,-8(fp)
 d03c9c0:	10800017 	ldw	r2,0(r2)
 d03c9c4:	e0bffd15 	stw	r2,-12(fp)
      if (so_ifp == ifp)
 d03c9c8:	e0fffc17 	ldw	r3,-16(fp)
 d03c9cc:	e0bfff17 	ldw	r2,-4(fp)
 d03c9d0:	1880021e 	bne	r3,r2,d03c9dc <if_killsocks+0x70>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 d03c9d4:	e13ffe17 	ldw	r4,-8(fp)
 d03c9d8:	d02e3580 	call	d02e358 <soabort>
      }
      so = next;
 d03c9dc:	e0bffd17 	ldw	r2,-12(fp)
 d03c9e0:	e0bffe15 	stw	r2,-8(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 d03c9e4:	e0bffe17 	ldw	r2,-8(fp)
 d03c9e8:	1004c03a 	cmpne	r2,r2,zero
 d03c9ec:	103fe91e 	bne	r2,zero,d03c994 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 d03c9f0:	e037883a 	mov	sp,fp
 d03c9f4:	dfc00117 	ldw	ra,4(sp)
 d03c9f8:	df000017 	ldw	fp,0(sp)
 d03c9fc:	dec00204 	addi	sp,sp,8
 d03ca00:	f800283a 	ret

0d03ca04 <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 d03ca04:	defffd04 	addi	sp,sp,-12
 d03ca08:	dfc00215 	stw	ra,8(sp)
 d03ca0c:	df000115 	stw	fp,4(sp)
 d03ca10:	df000104 	addi	fp,sp,4

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 d03ca14:	01000204 	movi	r4,8
 d03ca18:	d03c8d00 	call	d03c8d0 <reg_type>
 d03ca1c:	1005003a 	cmpeq	r2,r2,zero
 d03ca20:	1000061e 	bne	r2,zero,d03ca3c <ip_init+0x38>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 d03ca24:	01034174 	movhi	r4,3333
 d03ca28:	213ecd04 	addi	r4,r4,-1228
 d03ca2c:	d002cc00 	call	d002cc0 <puts>
#endif
      return(1);
 d03ca30:	00800044 	movi	r2,1
 d03ca34:	e0bfff15 	stw	r2,-4(fp)
 d03ca38:	00002b06 	br	d03cae8 <ip_init+0xe4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 d03ca3c:	008341b4 	movhi	r2,3334
 d03ca40:	10b4eb04 	addi	r2,r2,-11348
 d03ca44:	1009883a 	mov	r4,r2
 d03ca48:	01801404 	movi	r6,80
 d03ca4c:	000b883a 	mov	r5,zero
 d03ca50:	d0028800 	call	d002880 <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 d03ca54:	00c341b4 	movhi	r3,3334
 d03ca58:	18f4eb04 	addi	r3,r3,-11348
 d03ca5c:	00800084 	movi	r2,2
 d03ca60:	18800015 	stw	r2,0(r3)
   ip_mib.ipDefaultTTL = IP_TTL;
 d03ca64:	00c341b4 	movhi	r3,3334
 d03ca68:	18f4eb04 	addi	r3,r3,-11348
 d03ca6c:	00801004 	movi	r2,64
 d03ca70:	18800115 	stw	r2,4(r3)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 d03ca74:	d0a05117 	ldw	r2,-32444(gp)
 d03ca78:	11000f24 	muli	r4,r2,60
 d03ca7c:	d029e2c0 	call	d029e2c <npalloc>
 d03ca80:	d0a0c615 	stw	r2,-31976(gp)
   if (!rt_mib)
 d03ca84:	d0a0c617 	ldw	r2,-31976(gp)
 d03ca88:	1004c03a 	cmpne	r2,r2,zero
 d03ca8c:	1000061e 	bne	r2,zero,d03caa8 <ip_init+0xa4>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 d03ca90:	01034174 	movhi	r4,3333
 d03ca94:	213eda04 	addi	r4,r4,-1176
 d03ca98:	d002cc00 	call	d002cc0 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 d03ca9c:	00bffb04 	movi	r2,-20
 d03caa0:	e0bfff15 	stw	r2,-4(fp)
 d03caa4:	00001006 	br	d03cae8 <ip_init+0xe4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 d03caa8:	d0e0c617 	ldw	r3,-31976(gp)
 d03caac:	d0a05117 	ldw	r2,-32444(gp)
 d03cab0:	10800f24 	muli	r2,r2,60
 d03cab4:	1809883a 	mov	r4,r3
 d03cab8:	100d883a 	mov	r6,r2
 d03cabc:	000b883a 	mov	r5,zero
 d03cac0:	d0028800 	call	d002880 <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 d03cac4:	00c341b4 	movhi	r3,3334
 d03cac8:	18f4eb04 	addi	r3,r3,-11348
 d03cacc:	00800044 	movi	r2,1
 d03cad0:	18800015 	stw	r2,0(r3)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 d03cad4:	00c341b4 	movhi	r3,3334
 d03cad8:	18f4eb04 	addi	r3,r3,-11348
 d03cadc:	00801e04 	movi	r2,120
 d03cae0:	18800c15 	stw	r2,48(r3)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 d03cae4:	e03fff15 	stw	zero,-4(fp)
 d03cae8:	e0bfff17 	ldw	r2,-4(fp)
}
 d03caec:	e037883a 	mov	sp,fp
 d03caf0:	dfc00117 	ldw	ra,4(sp)
 d03caf4:	df000017 	ldw	fp,0(sp)
 d03caf8:	dec00204 	addi	sp,sp,8
 d03cafc:	f800283a 	ret

0d03cb00 <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 d03cb00:	defff804 	addi	sp,sp,-32
 d03cb04:	dfc00715 	stw	ra,28(sp)
 d03cb08:	df000615 	stw	fp,24(sp)
 d03cb0c:	df000604 	addi	fp,sp,24
 d03cb10:	e13ffc15 	stw	r4,-16(fp)
 d03cb14:	e17ffd15 	stw	r5,-12(fp)
 d03cb18:	e1bffe05 	stb	r6,-8(fp)
 d03cb1c:	e1ffff0d 	sth	r7,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 d03cb20:	e0bffc17 	ldw	r2,-16(fp)
 d03cb24:	10800317 	ldw	r2,12(r2)
 d03cb28:	10fffb04 	addi	r3,r2,-20
 d03cb2c:	e0bffc17 	ldw	r2,-16(fp)
 d03cb30:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 d03cb34:	e0bffc17 	ldw	r2,-16(fp)
 d03cb38:	10800417 	ldw	r2,16(r2)
 d03cb3c:	10c00504 	addi	r3,r2,20
 d03cb40:	e0bffc17 	ldw	r2,-16(fp)
 d03cb44:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 d03cb48:	e0bffc17 	ldw	r2,-16(fp)
 d03cb4c:	10800317 	ldw	r2,12(r2)
 d03cb50:	e0bffb15 	stw	r2,-20(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 d03cb54:	e0fffb17 	ldw	r3,-20(fp)
 d03cb58:	00801144 	movi	r2,69
 d03cb5c:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 d03cb60:	e0fffb17 	ldw	r3,-20(fp)
 d03cb64:	e0bfff0b 	ldhu	r2,-4(fp)
 d03cb68:	1880018d 	sth	r2,6(r3)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 d03cb6c:	e0bffd17 	ldw	r2,-12(fp)
 d03cb70:	10bfffcc 	andi	r2,r2,65535
 d03cb74:	1004d23a 	srli	r2,r2,8
 d03cb78:	10803fcc 	andi	r2,r2,255
 d03cb7c:	1009883a 	mov	r4,r2
 d03cb80:	e0bffd17 	ldw	r2,-12(fp)
 d03cb84:	10bfffcc 	andi	r2,r2,65535
 d03cb88:	1004923a 	slli	r2,r2,8
 d03cb8c:	1007883a 	mov	r3,r2
 d03cb90:	00bfc004 	movi	r2,-256
 d03cb94:	1884703a 	and	r2,r3,r2
 d03cb98:	2084b03a 	or	r2,r4,r2
 d03cb9c:	1007883a 	mov	r3,r2
 d03cba0:	e0bffb17 	ldw	r2,-20(fp)
 d03cba4:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 d03cba8:	e0bffc17 	ldw	r2,-16(fp)
 d03cbac:	10800417 	ldw	r2,16(r2)
 d03cbb0:	10bfffcc 	andi	r2,r2,65535
 d03cbb4:	1004d23a 	srli	r2,r2,8
 d03cbb8:	10803fcc 	andi	r2,r2,255
 d03cbbc:	1009883a 	mov	r4,r2
 d03cbc0:	e0bffc17 	ldw	r2,-16(fp)
 d03cbc4:	10800417 	ldw	r2,16(r2)
 d03cbc8:	10bfffcc 	andi	r2,r2,65535
 d03cbcc:	1004923a 	slli	r2,r2,8
 d03cbd0:	1007883a 	mov	r3,r2
 d03cbd4:	00bfc004 	movi	r2,-256
 d03cbd8:	1884703a 	and	r2,r3,r2
 d03cbdc:	2084b03a 	or	r2,r4,r2
 d03cbe0:	1007883a 	mov	r3,r2
 d03cbe4:	e0bffb17 	ldw	r2,-20(fp)
 d03cbe8:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 d03cbec:	e0fffb17 	ldw	r3,-20(fp)
 d03cbf0:	e0bffe03 	ldbu	r2,-8(fp)
 d03cbf4:	18800245 	stb	r2,9(r3)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 d03cbf8:	e0bffc17 	ldw	r2,-16(fp)
 d03cbfc:	10800c17 	ldw	r2,48(r2)
 d03cc00:	e0bffa15 	stw	r2,-24(fp)
 d03cc04:	e0bffa17 	ldw	r2,-24(fp)
 d03cc08:	1005003a 	cmpeq	r2,r2,zero
 d03cc0c:	1000121e 	bne	r2,zero,d03cc58 <ip_bldhead+0x158>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 d03cc10:	e0bffa17 	ldw	r2,-24(fp)
 d03cc14:	10800043 	ldbu	r2,1(r2)
 d03cc18:	10803fcc 	andi	r2,r2,255
 d03cc1c:	1005003a 	cmpeq	r2,r2,zero
 d03cc20:	1000051e 	bne	r2,zero,d03cc38 <ip_bldhead+0x138>
         pip->ip_time = sopts->ip_ttl;
 d03cc24:	e0bffa17 	ldw	r2,-24(fp)
 d03cc28:	10c00043 	ldbu	r3,1(r2)
 d03cc2c:	e0bffb17 	ldw	r2,-20(fp)
 d03cc30:	10c00205 	stb	r3,8(r2)
 d03cc34:	00000306 	br	d03cc44 <ip_bldhead+0x144>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 d03cc38:	e0fffb17 	ldw	r3,-20(fp)
 d03cc3c:	00801004 	movi	r2,64
 d03cc40:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 d03cc44:	e0bffa17 	ldw	r2,-24(fp)
 d03cc48:	10c00003 	ldbu	r3,0(r2)
 d03cc4c:	e0bffb17 	ldw	r2,-20(fp)
 d03cc50:	10c00045 	stb	r3,1(r2)
 d03cc54:	00000506 	br	d03cc6c <ip_bldhead+0x16c>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 d03cc58:	e0bffb17 	ldw	r2,-20(fp)
 d03cc5c:	00c01004 	movi	r3,64
 d03cc60:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 d03cc64:	e0bffb17 	ldw	r2,-20(fp)
 d03cc68:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 d03cc6c:	e0bffb17 	ldw	r2,-20(fp)
 d03cc70:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 d03cc74:	e13ffb17 	ldw	r4,-20(fp)
 d03cc78:	01400284 	movi	r5,10
 d03cc7c:	d0242340 	call	d024234 <cksum>
 d03cc80:	0084303a 	nor	r2,zero,r2
 d03cc84:	1007883a 	mov	r3,r2
 d03cc88:	e0bffb17 	ldw	r2,-20(fp)
 d03cc8c:	10c0028d 	sth	r3,10(r2)
}
 d03cc90:	e037883a 	mov	sp,fp
 d03cc94:	dfc00117 	ldw	ra,4(sp)
 d03cc98:	df000017 	ldw	fp,0(sp)
 d03cc9c:	dec00204 	addi	sp,sp,8
 d03cca0:	f800283a 	ret

0d03cca4 <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 d03cca4:	deffed04 	addi	sp,sp,-76
 d03cca8:	dfc01215 	stw	ra,72(sp)
 d03ccac:	df001115 	stw	fp,68(sp)
 d03ccb0:	df001104 	addi	fp,sp,68
 d03ccb4:	e13ffc15 	stw	r4,-16(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 d03ccb8:	e0bffc17 	ldw	r2,-16(fp)
 d03ccbc:	10800717 	ldw	r2,28(r2)
 d03ccc0:	1004d63a 	srli	r2,r2,24
 d03ccc4:	10c03fcc 	andi	r3,r2,255
 d03ccc8:	e0bffc17 	ldw	r2,-16(fp)
 d03cccc:	10800717 	ldw	r2,28(r2)
 d03ccd0:	1004d23a 	srli	r2,r2,8
 d03ccd4:	10bfc00c 	andi	r2,r2,65280
 d03ccd8:	1886b03a 	or	r3,r3,r2
 d03ccdc:	e0bffc17 	ldw	r2,-16(fp)
 d03cce0:	10800717 	ldw	r2,28(r2)
 d03cce4:	10bfc00c 	andi	r2,r2,65280
 d03cce8:	1004923a 	slli	r2,r2,8
 d03ccec:	1886b03a 	or	r3,r3,r2
 d03ccf0:	e0bffc17 	ldw	r2,-16(fp)
 d03ccf4:	10800717 	ldw	r2,28(r2)
 d03ccf8:	10803fcc 	andi	r2,r2,255
 d03ccfc:	1004963a 	slli	r2,r2,24
 d03cd00:	1884b03a 	or	r2,r3,r2
 d03cd04:	10fc002c 	andhi	r3,r2,61440
 d03cd08:	00b80034 	movhi	r2,57344
 d03cd0c:	1880b31e 	bne	r3,r2,d03cfdc <ip_write_internal+0x338>
   {
      if (p->imo != NULL)
 d03cd10:	e0bffc17 	ldw	r2,-16(fp)
 d03cd14:	10800b17 	ldw	r2,44(r2)
 d03cd18:	1005003a 	cmpeq	r2,r2,zero
 d03cd1c:	1000131e 	bne	r2,zero,d03cd6c <ip_write_internal+0xc8>
         if (p->imo->imo_multicast_netp)
 d03cd20:	e0bffc17 	ldw	r2,-16(fp)
 d03cd24:	10800b17 	ldw	r2,44(r2)
 d03cd28:	10800017 	ldw	r2,0(r2)
 d03cd2c:	1005003a 	cmpeq	r2,r2,zero
 d03cd30:	1000061e 	bne	r2,zero,d03cd4c <ip_write_internal+0xa8>
            p->net = p->imo->imo_multicast_netp;
 d03cd34:	e0bffc17 	ldw	r2,-16(fp)
 d03cd38:	10800b17 	ldw	r2,44(r2)
 d03cd3c:	10c00017 	ldw	r3,0(r2)
 d03cd40:	e0bffc17 	ldw	r2,-16(fp)
 d03cd44:	10c00615 	stw	r3,24(r2)
 d03cd48:	00002606 	br	d03cde4 <ip_write_internal+0x140>
         else
            p->net = iproute(p->fhost, &firsthop);
 d03cd4c:	e0bffc17 	ldw	r2,-16(fp)
 d03cd50:	11000717 	ldw	r4,28(r2)
 d03cd54:	e17ffb04 	addi	r5,fp,-20
 d03cd58:	d03e90c0 	call	d03e90c <iproute>
 d03cd5c:	1007883a 	mov	r3,r2
 d03cd60:	e0bffc17 	ldw	r2,-16(fp)
 d03cd64:	10c00615 	stw	r3,24(r2)
 d03cd68:	00001e06 	br	d03cde4 <ip_write_internal+0x140>
      else
      {
         for (i = 0; i < ifNumber; i++)
 d03cd6c:	e03ff815 	stw	zero,-32(fp)
 d03cd70:	00001706 	br	d03cdd0 <ip_write_internal+0x12c>
            if (nets[i]->n_mcastlist)
 d03cd74:	e0bff817 	ldw	r2,-32(fp)
 d03cd78:	00c341b4 	movhi	r3,3334
 d03cd7c:	18f2a504 	addi	r3,r3,-13676
 d03cd80:	1085883a 	add	r2,r2,r2
 d03cd84:	1085883a 	add	r2,r2,r2
 d03cd88:	10c5883a 	add	r2,r2,r3
 d03cd8c:	10800017 	ldw	r2,0(r2)
 d03cd90:	10802b17 	ldw	r2,172(r2)
 d03cd94:	1005003a 	cmpeq	r2,r2,zero
 d03cd98:	10000a1e 	bne	r2,zero,d03cdc4 <ip_write_internal+0x120>
            {
               p->net = nets[i];
 d03cd9c:	e0bff817 	ldw	r2,-32(fp)
 d03cda0:	00c341b4 	movhi	r3,3334
 d03cda4:	18f2a504 	addi	r3,r3,-13676
 d03cda8:	1085883a 	add	r2,r2,r2
 d03cdac:	1085883a 	add	r2,r2,r2
 d03cdb0:	10c5883a 	add	r2,r2,r3
 d03cdb4:	10c00017 	ldw	r3,0(r2)
 d03cdb8:	e0bffc17 	ldw	r2,-16(fp)
 d03cdbc:	10c00615 	stw	r3,24(r2)
               break;
 d03cdc0:	00000806 	br	d03cde4 <ip_write_internal+0x140>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 d03cdc4:	e0bff817 	ldw	r2,-32(fp)
 d03cdc8:	10800044 	addi	r2,r2,1
 d03cdcc:	e0bff815 	stw	r2,-32(fp)
 d03cdd0:	00834174 	movhi	r2,3333
 d03cdd4:	108aa504 	addi	r2,r2,10900
 d03cdd8:	10c00017 	ldw	r3,0(r2)
 d03cddc:	e0bff817 	ldw	r2,-32(fp)
 d03cde0:	10ffe436 	bltu	r2,r3,d03cd74 <ip_write_internal+0xd0>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 d03cde4:	e0bffc17 	ldw	r2,-16(fp)
 d03cde8:	10800617 	ldw	r2,24(r2)
 d03cdec:	1005003a 	cmpeq	r2,r2,zero
 d03cdf0:	1000051e 	bne	r2,zero,d03ce08 <ip_write_internal+0x164>
 d03cdf4:	e0bffc17 	ldw	r2,-16(fp)
 d03cdf8:	10800617 	ldw	r2,24(r2)
 d03cdfc:	10802b17 	ldw	r2,172(r2)
 d03ce00:	1004c03a 	cmpne	r2,r2,zero
 d03ce04:	10002e1e 	bne	r2,zero,d03cec0 <ip_write_internal+0x21c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 d03ce08:	00834174 	movhi	r2,3333
 d03ce0c:	108aa404 	addi	r2,r2,10896
 d03ce10:	10800017 	ldw	r2,0(r2)
 d03ce14:	1080840c 	andi	r2,r2,528
 d03ce18:	1005003a 	cmpeq	r2,r2,zero
 d03ce1c:	1000181e 	bne	r2,zero,d03ce80 <ip_write_internal+0x1dc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 d03ce20:	e0bffc17 	ldw	r2,-16(fp)
 d03ce24:	11800417 	ldw	r6,16(r2)
 d03ce28:	e0bffc17 	ldw	r2,-16(fp)
 d03ce2c:	10800717 	ldw	r2,28(r2)
 d03ce30:	11c03fcc 	andi	r7,r2,255
 d03ce34:	e0bffc17 	ldw	r2,-16(fp)
 d03ce38:	10800717 	ldw	r2,28(r2)
 d03ce3c:	1004d23a 	srli	r2,r2,8
 d03ce40:	11003fcc 	andi	r4,r2,255
 d03ce44:	e0bffc17 	ldw	r2,-16(fp)
 d03ce48:	10800717 	ldw	r2,28(r2)
 d03ce4c:	1004d43a 	srli	r2,r2,16
 d03ce50:	10c03fcc 	andi	r3,r2,255
 d03ce54:	e0bffc17 	ldw	r2,-16(fp)
 d03ce58:	10800717 	ldw	r2,28(r2)
 d03ce5c:	1004d63a 	srli	r2,r2,24
 d03ce60:	d9000015 	stw	r4,0(sp)
 d03ce64:	d8c00115 	stw	r3,4(sp)
 d03ce68:	d8800215 	stw	r2,8(sp)
 d03ce6c:	01034174 	movhi	r4,3333
 d03ce70:	213ee404 	addi	r4,r4,-1136
 d03ce74:	e17ffc17 	ldw	r5,-16(fp)
 d03ce78:	d0029980 	call	d002998 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 d03ce7c:	d0293e80 	call	d0293e8 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 d03ce80:	008341b4 	movhi	r2,3334
 d03ce84:	10b4eb04 	addi	r2,r2,-11348
 d03ce88:	10800b17 	ldw	r2,44(r2)
 d03ce8c:	10c00044 	addi	r3,r2,1
 d03ce90:	008341b4 	movhi	r2,3334
 d03ce94:	10b4eb04 	addi	r2,r2,-11348
 d03ce98:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03ce9c:	01000084 	movi	r4,2
 d03cea0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(p);
 d03cea4:	e13ffc17 	ldw	r4,-16(fp)
 d03cea8:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03ceac:	01000084 	movi	r4,2
 d03ceb0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 d03ceb4:	00bff7c4 	movi	r2,-33
 d03ceb8:	e0bffd15 	stw	r2,-12(fp)
 d03cebc:	00015306 	br	d03d40c <ip_write_internal+0x768>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 d03cec0:	e0bffc17 	ldw	r2,-16(fp)
 d03cec4:	11000717 	ldw	r4,28(r2)
 d03cec8:	e0bffc17 	ldw	r2,-16(fp)
 d03cecc:	11400617 	ldw	r5,24(r2)
 d03ced0:	d041afc0 	call	d041afc <lookup_mcast>
 d03ced4:	e0bff915 	stw	r2,-28(fp)
      if ((inm != NULL) &&
 d03ced8:	e0bff917 	ldw	r2,-28(fp)
 d03cedc:	1005003a 	cmpeq	r2,r2,zero
 d03cee0:	10001f1e 	bne	r2,zero,d03cf60 <ip_write_internal+0x2bc>
 d03cee4:	e0bffc17 	ldw	r2,-16(fp)
 d03cee8:	10800b17 	ldw	r2,44(r2)
 d03ceec:	1005003a 	cmpeq	r2,r2,zero
 d03cef0:	1000061e 	bne	r2,zero,d03cf0c <ip_write_internal+0x268>
 d03cef4:	e0bffc17 	ldw	r2,-16(fp)
 d03cef8:	10800b17 	ldw	r2,44(r2)
 d03cefc:	10800143 	ldbu	r2,5(r2)
 d03cf00:	10803fcc 	andi	r2,r2,255
 d03cf04:	1005003a 	cmpeq	r2,r2,zero
 d03cf08:	1000151e 	bne	r2,zero,d03cf60 <ip_write_internal+0x2bc>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
      {
         p->type = IPTP;
 d03cf0c:	e0fffc17 	ldw	r3,-16(fp)
 d03cf10:	00800204 	movi	r2,8
 d03cf14:	1880080d 	sth	r2,32(r3)
         pkt2 = ip_copypkt(p);
 d03cf18:	e13ffc17 	ldw	r4,-16(fp)
 d03cf1c:	d03eb780 	call	d03eb78 <ip_copypkt>
 d03cf20:	e0bffa15 	stw	r2,-24(fp)
         if (pkt2)
 d03cf24:	e0bffa17 	ldw	r2,-24(fp)
 d03cf28:	1005003a 	cmpeq	r2,r2,zero
 d03cf2c:	10000c1e 	bne	r2,zero,d03cf60 <ip_write_internal+0x2bc>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 d03cf30:	01000044 	movi	r4,1
 d03cf34:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 d03cf38:	e17ffa17 	ldw	r5,-24(fp)
 d03cf3c:	010341b4 	movhi	r4,3334
 d03cf40:	2131e004 	addi	r4,r4,-14464
 d03cf44:	d028d780 	call	d028d78 <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 d03cf48:	01000044 	movi	r4,1
 d03cf4c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 d03cf50:	00834174 	movhi	r2,3333
 d03cf54:	108acc04 	addi	r2,r2,11056
 d03cf58:	11000017 	ldw	r4,0(r2)
 d03cf5c:	d01364c0 	call	d01364c <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 d03cf60:	e0bffc17 	ldw	r2,-16(fp)
 d03cf64:	10800317 	ldw	r2,12(r2)
 d03cf68:	e0bff715 	stw	r2,-36(fp)
      if ((pip->ip_time == 0) || 
 d03cf6c:	e0bff717 	ldw	r2,-36(fp)
 d03cf70:	10800203 	ldbu	r2,8(r2)
 d03cf74:	10803fcc 	andi	r2,r2,255
 d03cf78:	1005003a 	cmpeq	r2,r2,zero
 d03cf7c:	10000b1e 	bne	r2,zero,d03cfac <ip_write_internal+0x308>
 d03cf80:	e0bffc17 	ldw	r2,-16(fp)
 d03cf84:	10800717 	ldw	r2,28(r2)
 d03cf88:	10803fcc 	andi	r2,r2,255
 d03cf8c:	10801fe0 	cmpeqi	r2,r2,127
 d03cf90:	1000061e 	bne	r2,zero,d03cfac <ip_write_internal+0x308>
 d03cf94:	e0bffc17 	ldw	r2,-16(fp)
 d03cf98:	10c00717 	ldw	r3,28(r2)
 d03cf9c:	e0bffc17 	ldw	r2,-16(fp)
 d03cfa0:	10800617 	ldw	r2,24(r2)
 d03cfa4:	10800a17 	ldw	r2,40(r2)
 d03cfa8:	1880081e 	bne	r3,r2,d03cfcc <ip_write_internal+0x328>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03cfac:	01000084 	movi	r4,2
 d03cfb0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(p);
 d03cfb4:	e13ffc17 	ldw	r4,-16(fp)
 d03cfb8:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03cfbc:	01000084 	movi	r4,2
 d03cfc0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 d03cfc4:	e03ffd15 	stw	zero,-12(fp)
 d03cfc8:	00011006 	br	d03d40c <ip_write_internal+0x768>
      }

      firsthop = p->fhost;
 d03cfcc:	e0bffc17 	ldw	r2,-16(fp)
 d03cfd0:	10800717 	ldw	r2,28(r2)
 d03cfd4:	e0bffb15 	stw	r2,-20(fp)

      goto sendit;
 d03cfd8:	00004106 	br	d03d0e0 <ip_write_internal+0x43c>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 d03cfdc:	e0bffc17 	ldw	r2,-16(fp)
 d03cfe0:	10800717 	ldw	r2,28(r2)
 d03cfe4:	10bfffd8 	cmpnei	r2,r2,-1
 d03cfe8:	1000041e 	bne	r2,zero,d03cffc <ip_write_internal+0x358>
   {
      firsthop = p->fhost;
 d03cfec:	e0bffc17 	ldw	r2,-16(fp)
 d03cff0:	10800717 	ldw	r2,28(r2)
 d03cff4:	e0bffb15 	stw	r2,-20(fp)
 d03cff8:	00003906 	br	d03d0e0 <ip_write_internal+0x43c>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 d03cffc:	e0bffc17 	ldw	r2,-16(fp)
 d03d000:	11000717 	ldw	r4,28(r2)
 d03d004:	e17ffb04 	addi	r5,fp,-20
 d03d008:	d03e90c0 	call	d03e90c <iproute>
 d03d00c:	1007883a 	mov	r3,r2
 d03d010:	e0bffc17 	ldw	r2,-16(fp)
 d03d014:	10c00615 	stw	r3,24(r2)
      if (p->net == NULL)
 d03d018:	e0bffc17 	ldw	r2,-16(fp)
 d03d01c:	10800617 	ldw	r2,24(r2)
 d03d020:	1004c03a 	cmpne	r2,r2,zero
 d03d024:	10002e1e 	bne	r2,zero,d03d0e0 <ip_write_internal+0x43c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 d03d028:	00834174 	movhi	r2,3333
 d03d02c:	108aa404 	addi	r2,r2,10896
 d03d030:	10800017 	ldw	r2,0(r2)
 d03d034:	1080840c 	andi	r2,r2,528
 d03d038:	1005003a 	cmpeq	r2,r2,zero
 d03d03c:	1000181e 	bne	r2,zero,d03d0a0 <ip_write_internal+0x3fc>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 d03d040:	e0bffc17 	ldw	r2,-16(fp)
 d03d044:	11800417 	ldw	r6,16(r2)
 d03d048:	e0bffc17 	ldw	r2,-16(fp)
 d03d04c:	10800717 	ldw	r2,28(r2)
 d03d050:	11c03fcc 	andi	r7,r2,255
 d03d054:	e0bffc17 	ldw	r2,-16(fp)
 d03d058:	10800717 	ldw	r2,28(r2)
 d03d05c:	1004d23a 	srli	r2,r2,8
 d03d060:	11003fcc 	andi	r4,r2,255
 d03d064:	e0bffc17 	ldw	r2,-16(fp)
 d03d068:	10800717 	ldw	r2,28(r2)
 d03d06c:	1004d43a 	srli	r2,r2,16
 d03d070:	10c03fcc 	andi	r3,r2,255
 d03d074:	e0bffc17 	ldw	r2,-16(fp)
 d03d078:	10800717 	ldw	r2,28(r2)
 d03d07c:	1004d63a 	srli	r2,r2,24
 d03d080:	d9000015 	stw	r4,0(sp)
 d03d084:	d8c00115 	stw	r3,4(sp)
 d03d088:	d8800215 	stw	r2,8(sp)
 d03d08c:	01034174 	movhi	r4,3333
 d03d090:	213ee404 	addi	r4,r4,-1136
 d03d094:	e17ffc17 	ldw	r5,-16(fp)
 d03d098:	d0029980 	call	d002998 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 d03d09c:	d0293e80 	call	d0293e8 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 d03d0a0:	008341b4 	movhi	r2,3334
 d03d0a4:	10b4eb04 	addi	r2,r2,-11348
 d03d0a8:	10800b17 	ldw	r2,44(r2)
 d03d0ac:	10c00044 	addi	r3,r2,1
 d03d0b0:	008341b4 	movhi	r2,3334
 d03d0b4:	10b4eb04 	addi	r2,r2,-11348
 d03d0b8:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03d0bc:	01000084 	movi	r4,2
 d03d0c0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(p);
 d03d0c4:	e13ffc17 	ldw	r4,-16(fp)
 d03d0c8:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d0cc:	01000084 	movi	r4,2
 d03d0d0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 d03d0d4:	00fff7c4 	movi	r3,-33
 d03d0d8:	e0fffd15 	stw	r3,-12(fp)
 d03d0dc:	0000cb06 	br	d03d40c <ip_write_internal+0x768>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 d03d0e0:	00834174 	movhi	r2,3333
 d03d0e4:	108aa404 	addi	r2,r2,10896
 d03d0e8:	10800017 	ldw	r2,0(r2)
 d03d0ec:	1080800c 	andi	r2,r2,512
 d03d0f0:	1005003a 	cmpeq	r2,r2,zero
 d03d0f4:	1000231e 	bne	r2,zero,d03d184 <ip_write_internal+0x4e0>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 d03d0f8:	e0bffc17 	ldw	r2,-16(fp)
 d03d0fc:	11400417 	ldw	r5,16(r2)
 d03d100:	e0bffc17 	ldw	r2,-16(fp)
 d03d104:	10800717 	ldw	r2,28(r2)
 d03d108:	11803fcc 	andi	r6,r2,255
 d03d10c:	e0bffc17 	ldw	r2,-16(fp)
 d03d110:	10800717 	ldw	r2,28(r2)
 d03d114:	1004d23a 	srli	r2,r2,8
 d03d118:	11c03fcc 	andi	r7,r2,255
 d03d11c:	e0bffc17 	ldw	r2,-16(fp)
 d03d120:	10800717 	ldw	r2,28(r2)
 d03d124:	1004d43a 	srli	r2,r2,16
 d03d128:	10c03fcc 	andi	r3,r2,255
 d03d12c:	e0bffc17 	ldw	r2,-16(fp)
 d03d130:	10800717 	ldw	r2,28(r2)
 d03d134:	1004d63a 	srli	r2,r2,24
 d03d138:	d8c00015 	stw	r3,0(sp)
 d03d13c:	d8800115 	stw	r2,4(sp)
 d03d140:	01034174 	movhi	r4,3333
 d03d144:	213ef404 	addi	r4,r4,-1072
 d03d148:	d0029980 	call	d002998 <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 d03d14c:	e0bffb17 	ldw	r2,-20(fp)
 d03d150:	11403fcc 	andi	r5,r2,255
 d03d154:	e0bffb17 	ldw	r2,-20(fp)
 d03d158:	1004d23a 	srli	r2,r2,8
 d03d15c:	11803fcc 	andi	r6,r2,255
 d03d160:	e0bffb17 	ldw	r2,-20(fp)
 d03d164:	1004d43a 	srli	r2,r2,16
 d03d168:	11c03fcc 	andi	r7,r2,255
 d03d16c:	e0bffb17 	ldw	r2,-20(fp)
 d03d170:	1004d63a 	srli	r2,r2,24
 d03d174:	d8800015 	stw	r2,0(sp)
 d03d178:	01034174 	movhi	r4,3333
 d03d17c:	213efd04 	addi	r4,r4,-1036
 d03d180:	d0029980 	call	d002998 <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 d03d184:	e0bffc17 	ldw	r2,-16(fp)
 d03d188:	10800617 	ldw	r2,24(r2)
 d03d18c:	10c00a17 	ldw	r3,40(r2)
 d03d190:	e0bffc17 	ldw	r2,-16(fp)
 d03d194:	10800717 	ldw	r2,28(r2)
 d03d198:	18802a1e 	bne	r3,r2,d03d244 <ip_write_internal+0x5a0>
 d03d19c:	e0bffc17 	ldw	r2,-16(fp)
 d03d1a0:	10800717 	ldw	r2,28(r2)
 d03d1a4:	10803fcc 	andi	r2,r2,255
 d03d1a8:	10801fe0 	cmpeqi	r2,r2,127
 d03d1ac:	1000251e 	bne	r2,zero,d03d244 <ip_write_internal+0x5a0>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 d03d1b0:	e0bffc17 	ldw	r2,-16(fp)
 d03d1b4:	10800617 	ldw	r2,24(r2)
 d03d1b8:	10802a17 	ldw	r2,168(r2)
 d03d1bc:	1080020c 	andi	r2,r2,8
 d03d1c0:	1004c03a 	cmpne	r2,r2,zero
 d03d1c4:	10000a1e 	bne	r2,zero,d03d1f0 <ip_write_internal+0x54c>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 d03d1c8:	d0293e80 	call	d0293e8 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03d1cc:	01000084 	movi	r4,2
 d03d1d0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(p);
 d03d1d4:	e13ffc17 	ldw	r4,-16(fp)
 d03d1d8:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d1dc:	01000084 	movi	r4,2
 d03d1e0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 d03d1e4:	00bffd44 	movi	r2,-11
 d03d1e8:	e0bffd15 	stw	r2,-12(fp)
 d03d1ec:	00008706 	br	d03d40c <ip_write_internal+0x768>
      }
      p->type = IPTP;
 d03d1f0:	e0fffc17 	ldw	r3,-16(fp)
 d03d1f4:	00800204 	movi	r2,8
 d03d1f8:	1880080d 	sth	r2,32(r3)
      UNLOCK_NET_RESOURCE(NET_RESID);
 d03d1fc:	0009883a 	mov	r4,zero
 d03d200:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 d03d204:	01000044 	movi	r4,1
 d03d208:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 d03d20c:	e17ffc17 	ldw	r5,-16(fp)
 d03d210:	010341b4 	movhi	r4,3334
 d03d214:	2131e004 	addi	r4,r4,-14464
 d03d218:	d028d780 	call	d028d78 <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 d03d21c:	01000044 	movi	r4,1
 d03d220:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 d03d224:	0009883a 	mov	r4,zero
 d03d228:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 d03d22c:	00834174 	movhi	r2,3333
 d03d230:	108acc04 	addi	r2,r2,11056
 d03d234:	11000017 	ldw	r4,0(r2)
 d03d238:	d01364c0 	call	d01364c <OSSemPost>

      return SUCCESS;
 d03d23c:	e03ffd15 	stw	zero,-12(fp)
 d03d240:	00007206 	br	d03d40c <ip_write_internal+0x768>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 d03d244:	e0bffc17 	ldw	r2,-16(fp)
 d03d248:	10800a17 	ldw	r2,40(r2)
 d03d24c:	1080040c 	andi	r2,r2,16
 d03d250:	1005003a 	cmpeq	r2,r2,zero
 d03d254:	e0bff605 	stb	r2,-40(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 d03d258:	d028be40 	call	d028be4 <pk_get_max_intrsafe_buf_len>
 d03d25c:	e0bff315 	stw	r2,-52(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 d03d260:	e0bff603 	ldbu	r2,-40(fp)
 d03d264:	1004c03a 	cmpne	r2,r2,zero
 d03d268:	10000e1e 	bne	r2,zero,d03d2a4 <ip_write_internal+0x600>
       limit = MIN(maxbuflen,p->net->n_mtu);
 d03d26c:	e0bffc17 	ldw	r2,-16(fp)
 d03d270:	10800617 	ldw	r2,24(r2)
 d03d274:	10800917 	ldw	r2,36(r2)
 d03d278:	e0fff317 	ldw	r3,-52(fp)
 d03d27c:	e0ffff15 	stw	r3,-4(fp)
 d03d280:	e0bffe15 	stw	r2,-8(fp)
 d03d284:	e0bfff17 	ldw	r2,-4(fp)
 d03d288:	e0fffe17 	ldw	r3,-8(fp)
 d03d28c:	10c0022e 	bgeu	r2,r3,d03d298 <ip_write_internal+0x5f4>
 d03d290:	e0bfff17 	ldw	r2,-4(fp)
 d03d294:	e0bffe15 	stw	r2,-8(fp)
 d03d298:	e0fffe17 	ldw	r3,-8(fp)
 d03d29c:	e0fff515 	stw	r3,-44(fp)
 d03d2a0:	00000406 	br	d03d2b4 <ip_write_internal+0x610>
   else
       limit = p->net->n_mtu;
 d03d2a4:	e0bffc17 	ldw	r2,-16(fp)
 d03d2a8:	10800617 	ldw	r2,24(r2)
 d03d2ac:	10800917 	ldw	r2,36(r2)
 d03d2b0:	e0bff515 	stw	r2,-44(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 d03d2b4:	e0bffc17 	ldw	r2,-16(fp)
 d03d2b8:	10c00417 	ldw	r3,16(r2)
 d03d2bc:	e0bffc17 	ldw	r2,-16(fp)
 d03d2c0:	10800617 	ldw	r2,24(r2)
 d03d2c4:	10800817 	ldw	r2,32(r2)
 d03d2c8:	1887883a 	add	r3,r3,r2
 d03d2cc:	e0bff517 	ldw	r2,-44(fp)
 d03d2d0:	10c0072e 	bgeu	r2,r3,d03d2f0 <ip_write_internal+0x64c>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 d03d2d4:	e17ffb17 	ldw	r5,-20(fp)
 d03d2d8:	e13ffc17 	ldw	r4,-16(fp)
 d03d2dc:	d03df7c0 	call	d03df7c <ip_fragment>
 d03d2e0:	e0bff215 	stw	r2,-56(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 d03d2e4:	e0bff217 	ldw	r2,-56(fp)
 d03d2e8:	e0bffd15 	stw	r2,-12(fp)
 d03d2ec:	00004706 	br	d03d40c <ip_write_internal+0x768>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 d03d2f0:	e0bff603 	ldbu	r2,-40(fp)
 d03d2f4:	1004c03a 	cmpne	r2,r2,zero
 d03d2f8:	1000401e 	bne	r2,zero,d03d3fc <ip_write_internal+0x758>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03d2fc:	01000084 	movi	r4,2
 d03d300:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 d03d304:	e0bffc17 	ldw	r2,-16(fp)
 d03d308:	10c00417 	ldw	r3,16(r2)
 d03d30c:	e0bffc17 	ldw	r2,-16(fp)
 d03d310:	10800617 	ldw	r2,24(r2)
 d03d314:	10800817 	ldw	r2,32(r2)
 d03d318:	1889883a 	add	r4,r3,r2
 d03d31c:	d0287a40 	call	d0287a4 <pk_alloc>
 d03d320:	e0bff415 	stw	r2,-48(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d324:	01000084 	movi	r4,2
 d03d328:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 d03d32c:	e0bff417 	ldw	r2,-48(fp)
 d03d330:	1004c03a 	cmpne	r2,r2,zero
 d03d334:	1000091e 	bne	r2,zero,d03d35c <ip_write_internal+0x6b8>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03d338:	01000084 	movi	r4,2
 d03d33c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free(p);
 d03d340:	e13ffc17 	ldw	r4,-16(fp)
 d03d344:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d348:	01000084 	movi	r4,2
 d03d34c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 d03d350:	00fffac4 	movi	r3,-21
 d03d354:	e0fffd15 	stw	r3,-12(fp)
 d03d358:	00002c06 	br	d03d40c <ip_write_internal+0x768>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 d03d35c:	e0bff417 	ldw	r2,-48(fp)
 d03d360:	10c00117 	ldw	r3,4(r2)
 d03d364:	e0bffc17 	ldw	r2,-16(fp)
 d03d368:	10800617 	ldw	r2,24(r2)
 d03d36c:	10800817 	ldw	r2,32(r2)
 d03d370:	1887883a 	add	r3,r3,r2
 d03d374:	e0bff417 	ldw	r2,-48(fp)
 d03d378:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 d03d37c:	e0bff417 	ldw	r2,-48(fp)
 d03d380:	10c00317 	ldw	r3,12(r2)
 d03d384:	e0bffc17 	ldw	r2,-16(fp)
 d03d388:	11400317 	ldw	r5,12(r2)
 d03d38c:	e0bffc17 	ldw	r2,-16(fp)
 d03d390:	10800417 	ldw	r2,16(r2)
 d03d394:	1809883a 	mov	r4,r3
 d03d398:	100d883a 	mov	r6,r2
 d03d39c:	d0027000 	call	d002700 <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 d03d3a0:	e0bffc17 	ldw	r2,-16(fp)
 d03d3a4:	10c00417 	ldw	r3,16(r2)
 d03d3a8:	e0bff417 	ldw	r2,-48(fp)
 d03d3ac:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 d03d3b0:	e0bffc17 	ldw	r2,-16(fp)
 d03d3b4:	10c00617 	ldw	r3,24(r2)
 d03d3b8:	e0bff417 	ldw	r2,-48(fp)
 d03d3bc:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 d03d3c0:	e0bffc17 	ldw	r2,-16(fp)
 d03d3c4:	10c00717 	ldw	r3,28(r2)
 d03d3c8:	e0bff417 	ldw	r2,-48(fp)
 d03d3cc:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03d3d0:	01000084 	movi	r4,2
 d03d3d4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free(p);
 d03d3d8:	e13ffc17 	ldw	r4,-16(fp)
 d03d3dc:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03d3e0:	01000084 	movi	r4,2
 d03d3e4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 d03d3e8:	e17ffb17 	ldw	r5,-20(fp)
 d03d3ec:	e13ff417 	ldw	r4,-48(fp)
 d03d3f0:	d021fd40 	call	d021fd4 <ip2mac>
 d03d3f4:	e0bffd15 	stw	r2,-12(fp)
 d03d3f8:	00000406 	br	d03d40c <ip_write_internal+0x768>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 d03d3fc:	e17ffb17 	ldw	r5,-20(fp)
 d03d400:	e13ffc17 	ldw	r4,-16(fp)
 d03d404:	d021fd40 	call	d021fd4 <ip2mac>
 d03d408:	e0bffd15 	stw	r2,-12(fp)
 d03d40c:	e0bffd17 	ldw	r2,-12(fp)
      }
   }
}
 d03d410:	e037883a 	mov	sp,fp
 d03d414:	dfc00117 	ldw	ra,4(sp)
 d03d418:	df000017 	ldw	fp,0(sp)
 d03d41c:	dec00204 	addi	sp,sp,8
 d03d420:	f800283a 	ret

0d03d424 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 d03d424:	defff904 	addi	sp,sp,-28
 d03d428:	dfc00615 	stw	ra,24(sp)
 d03d42c:	df000515 	stw	fp,20(sp)
 d03d430:	df000504 	addi	fp,sp,20
 d03d434:	e17fff15 	stw	r5,-4(fp)
 d03d438:	e13ffe05 	stb	r4,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 d03d43c:	008341b4 	movhi	r2,3334
 d03d440:	10b4eb04 	addi	r2,r2,-11348
 d03d444:	10800917 	ldw	r2,36(r2)
 d03d448:	10c00044 	addi	r3,r2,1
 d03d44c:	008341b4 	movhi	r2,3334
 d03d450:	10b4eb04 	addi	r2,r2,-11348
 d03d454:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 d03d458:	e0bfff17 	ldw	r2,-4(fp)
 d03d45c:	10800317 	ldw	r2,12(r2)
 d03d460:	10fffb04 	addi	r3,r2,-20
 d03d464:	e0bfff17 	ldw	r2,-4(fp)
 d03d468:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 d03d46c:	e0bfff17 	ldw	r2,-4(fp)
 d03d470:	10800417 	ldw	r2,16(r2)
 d03d474:	10c00504 	addi	r3,r2,20
 d03d478:	e0bfff17 	ldw	r2,-4(fp)
 d03d47c:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 d03d480:	e0bfff17 	ldw	r2,-4(fp)
 d03d484:	10800317 	ldw	r2,12(r2)
 d03d488:	e0bffd15 	stw	r2,-12(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 d03d48c:	e0fffd17 	ldw	r3,-12(fp)
 d03d490:	00801144 	movi	r2,69
 d03d494:	18800005 	stb	r2,0(r3)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 d03d498:	e0bffd17 	ldw	r2,-12(fp)
 d03d49c:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 d03d4a0:	d0a05017 	ldw	r2,-32448(gp)
 d03d4a4:	10bfffcc 	andi	r2,r2,65535
 d03d4a8:	1004d23a 	srli	r2,r2,8
 d03d4ac:	10803fcc 	andi	r2,r2,255
 d03d4b0:	1009883a 	mov	r4,r2
 d03d4b4:	d0a05017 	ldw	r2,-32448(gp)
 d03d4b8:	10bfffcc 	andi	r2,r2,65535
 d03d4bc:	1004923a 	slli	r2,r2,8
 d03d4c0:	1007883a 	mov	r3,r2
 d03d4c4:	00bfc004 	movi	r2,-256
 d03d4c8:	1884703a 	and	r2,r3,r2
 d03d4cc:	2084b03a 	or	r2,r4,r2
 d03d4d0:	1007883a 	mov	r3,r2
 d03d4d4:	e0bffd17 	ldw	r2,-12(fp)
 d03d4d8:	10c0010d 	sth	r3,4(r2)
   uid++;
 d03d4dc:	d0a05017 	ldw	r2,-32448(gp)
 d03d4e0:	10800044 	addi	r2,r2,1
 d03d4e4:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 d03d4e8:	e0bfff17 	ldw	r2,-4(fp)
 d03d4ec:	10800417 	ldw	r2,16(r2)
 d03d4f0:	10bfffcc 	andi	r2,r2,65535
 d03d4f4:	1004d23a 	srli	r2,r2,8
 d03d4f8:	10803fcc 	andi	r2,r2,255
 d03d4fc:	1009883a 	mov	r4,r2
 d03d500:	e0bfff17 	ldw	r2,-4(fp)
 d03d504:	10800417 	ldw	r2,16(r2)
 d03d508:	10bfffcc 	andi	r2,r2,65535
 d03d50c:	1004923a 	slli	r2,r2,8
 d03d510:	1007883a 	mov	r3,r2
 d03d514:	00bfc004 	movi	r2,-256
 d03d518:	1884703a 	and	r2,r3,r2
 d03d51c:	2084b03a 	or	r2,r4,r2
 d03d520:	1007883a 	mov	r3,r2
 d03d524:	e0bffd17 	ldw	r2,-12(fp)
 d03d528:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 d03d52c:	e0fffd17 	ldw	r3,-12(fp)
 d03d530:	e0bffe03 	ldbu	r2,-8(fp)
 d03d534:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 d03d538:	e0bffd17 	ldw	r2,-12(fp)
 d03d53c:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 d03d540:	00801004 	movi	r2,64
 d03d544:	e0bffc05 	stb	r2,-16(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 d03d548:	e0bfff17 	ldw	r2,-4(fp)
 d03d54c:	10800717 	ldw	r2,28(r2)
 d03d550:	1004d63a 	srli	r2,r2,24
 d03d554:	10c03fcc 	andi	r3,r2,255
 d03d558:	e0bfff17 	ldw	r2,-4(fp)
 d03d55c:	10800717 	ldw	r2,28(r2)
 d03d560:	1004d23a 	srli	r2,r2,8
 d03d564:	10bfc00c 	andi	r2,r2,65280
 d03d568:	1886b03a 	or	r3,r3,r2
 d03d56c:	e0bfff17 	ldw	r2,-4(fp)
 d03d570:	10800717 	ldw	r2,28(r2)
 d03d574:	10bfc00c 	andi	r2,r2,65280
 d03d578:	1004923a 	slli	r2,r2,8
 d03d57c:	1886b03a 	or	r3,r3,r2
 d03d580:	e0bfff17 	ldw	r2,-4(fp)
 d03d584:	10800717 	ldw	r2,28(r2)
 d03d588:	10803fcc 	andi	r2,r2,255
 d03d58c:	1004963a 	slli	r2,r2,24
 d03d590:	1884b03a 	or	r2,r3,r2
 d03d594:	10fc002c 	andhi	r3,r2,61440
 d03d598:	00b80034 	movhi	r2,57344
 d03d59c:	1880081e 	bne	r3,r2,d03d5c0 <ip_write+0x19c>
 d03d5a0:	e0bfff17 	ldw	r2,-4(fp)
 d03d5a4:	10800b17 	ldw	r2,44(r2)
 d03d5a8:	1005003a 	cmpeq	r2,r2,zero
 d03d5ac:	1000041e 	bne	r2,zero,d03d5c0 <ip_write+0x19c>
      ttl = p->imo->imo_multicast_ttl;
 d03d5b0:	e0bfff17 	ldw	r2,-4(fp)
 d03d5b4:	10800b17 	ldw	r2,44(r2)
 d03d5b8:	10800103 	ldbu	r2,4(r2)
 d03d5bc:	e0bffc05 	stb	r2,-16(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 d03d5c0:	e0bfff17 	ldw	r2,-4(fp)
 d03d5c4:	10800c17 	ldw	r2,48(r2)
 d03d5c8:	e0bffb15 	stw	r2,-20(fp)
 d03d5cc:	e0bffb17 	ldw	r2,-20(fp)
 d03d5d0:	1005003a 	cmpeq	r2,r2,zero
 d03d5d4:	1000121e 	bne	r2,zero,d03d620 <ip_write+0x1fc>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 d03d5d8:	e0bffb17 	ldw	r2,-20(fp)
 d03d5dc:	10800043 	ldbu	r2,1(r2)
 d03d5e0:	10803fcc 	andi	r2,r2,255
 d03d5e4:	1005003a 	cmpeq	r2,r2,zero
 d03d5e8:	1000051e 	bne	r2,zero,d03d600 <ip_write+0x1dc>
         pip->ip_time = sopts->ip_ttl;
 d03d5ec:	e0bffb17 	ldw	r2,-20(fp)
 d03d5f0:	10c00043 	ldbu	r3,1(r2)
 d03d5f4:	e0bffd17 	ldw	r2,-12(fp)
 d03d5f8:	10c00205 	stb	r3,8(r2)
 d03d5fc:	00000306 	br	d03d60c <ip_write+0x1e8>
	  else
         pip->ip_time = ttl;
 d03d600:	e0fffd17 	ldw	r3,-12(fp)
 d03d604:	e0bffc03 	ldbu	r2,-16(fp)
 d03d608:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 d03d60c:	e0bffb17 	ldw	r2,-20(fp)
 d03d610:	10c00003 	ldbu	r3,0(r2)
 d03d614:	e0bffd17 	ldw	r2,-12(fp)
 d03d618:	10c00045 	stb	r3,1(r2)
 d03d61c:	00000506 	br	d03d634 <ip_write+0x210>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 d03d620:	e0bffd17 	ldw	r2,-12(fp)
 d03d624:	e0fffc03 	ldbu	r3,-16(fp)
 d03d628:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 d03d62c:	e0bffd17 	ldw	r2,-12(fp)
 d03d630:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 d03d634:	e13ffd17 	ldw	r4,-12(fp)
 d03d638:	01400284 	movi	r5,10
 d03d63c:	d0242340 	call	d024234 <cksum>
 d03d640:	0084303a 	nor	r2,zero,r2
 d03d644:	1007883a 	mov	r3,r2
 d03d648:	e0bffd17 	ldw	r2,-12(fp)
 d03d64c:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 d03d650:	e13fff17 	ldw	r4,-4(fp)
 d03d654:	d03cca40 	call	d03cca4 <ip_write_internal>
}
 d03d658:	e037883a 	mov	sp,fp
 d03d65c:	dfc00117 	ldw	ra,4(sp)
 d03d660:	df000017 	ldw	fp,0(sp)
 d03d664:	dec00204 	addi	sp,sp,8
 d03d668:	f800283a 	ret

0d03d66c <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 d03d66c:	defff504 	addi	sp,sp,-44
 d03d670:	dfc00a15 	stw	ra,40(sp)
 d03d674:	df000915 	stw	fp,36(sp)
 d03d678:	df000904 	addi	fp,sp,36
 d03d67c:	e17ffe15 	stw	r5,-8(fp)
 d03d680:	e1bfff15 	stw	r6,-4(fp)
 d03d684:	e13ffd05 	stb	r4,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 d03d688:	00800504 	movi	r2,20
 d03d68c:	e0bff905 	stb	r2,-28(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 d03d690:	008341b4 	movhi	r2,3334
 d03d694:	10b4eb04 	addi	r2,r2,-11348
 d03d698:	10800917 	ldw	r2,36(r2)
 d03d69c:	10c00044 	addi	r3,r2,1
 d03d6a0:	008341b4 	movhi	r2,3334
 d03d6a4:	10b4eb04 	addi	r2,r2,-11348
 d03d6a8:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 d03d6ac:	e0bfff17 	ldw	r2,-4(fp)
 d03d6b0:	e0bff815 	stw	r2,-32(fp)
 d03d6b4:	00000c06 	br	d03d6e8 <ip_write2+0x7c>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 d03d6b8:	e0bff817 	ldw	r2,-32(fp)
 d03d6bc:	10800003 	ldbu	r2,0(r2)
 d03d6c0:	10803fcc 	andi	r2,r2,255
 d03d6c4:	10800520 	cmpeqi	r2,r2,20
 d03d6c8:	1000011e 	bne	r2,zero,d03d6d0 <ip_write2+0x64>
 d03d6cc:	00000306 	br	d03d6dc <ip_write2+0x70>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 d03d6d0:	e0bff903 	ldbu	r2,-28(fp)
 d03d6d4:	10800104 	addi	r2,r2,4
 d03d6d8:	e0bff905 	stb	r2,-28(fp)
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 d03d6dc:	e0bff817 	ldw	r2,-32(fp)
 d03d6e0:	10800044 	addi	r2,r2,1
 d03d6e4:	e0bff815 	stw	r2,-32(fp)
 d03d6e8:	e0bff817 	ldw	r2,-32(fp)
 d03d6ec:	10800003 	ldbu	r2,0(r2)
 d03d6f0:	10803fcc 	andi	r2,r2,255
 d03d6f4:	1004c03a 	cmpne	r2,r2,zero
 d03d6f8:	103fef1e 	bne	r2,zero,d03d6b8 <ip_write2+0x4c>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 d03d6fc:	e0bff903 	ldbu	r2,-28(fp)
 d03d700:	108000cc 	andi	r2,r2,3
 d03d704:	1005003a 	cmpeq	r2,r2,zero
 d03d708:	1000071e 	bne	r2,zero,d03d728 <ip_write2+0xbc>
      iphlen_pad = 4 - (iphlen & 0x3);
 d03d70c:	e0bff903 	ldbu	r2,-28(fp)
 d03d710:	108000cc 	andi	r2,r2,3
 d03d714:	1007883a 	mov	r3,r2
 d03d718:	00800104 	movi	r2,4
 d03d71c:	10c5c83a 	sub	r2,r2,r3
 d03d720:	e0bff745 	stb	r2,-35(fp)
 d03d724:	00000106 	br	d03d72c <ip_write2+0xc0>
   else iphlen_pad = 0; /* no header padding required */
 d03d728:	e03ff745 	stb	zero,-35(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 d03d72c:	e0bffe17 	ldw	r2,-8(fp)
 d03d730:	11000317 	ldw	r4,12(r2)
 d03d734:	e0fff903 	ldbu	r3,-28(fp)
 d03d738:	e0bff743 	ldbu	r2,-35(fp)
 d03d73c:	1885883a 	add	r2,r3,r2
 d03d740:	2087c83a 	sub	r3,r4,r2
 d03d744:	e0bffe17 	ldw	r2,-8(fp)
 d03d748:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 d03d74c:	e0bffe17 	ldw	r2,-8(fp)
 d03d750:	11000417 	ldw	r4,16(r2)
 d03d754:	e0fff903 	ldbu	r3,-28(fp)
 d03d758:	e0bff743 	ldbu	r2,-35(fp)
 d03d75c:	1885883a 	add	r2,r3,r2
 d03d760:	2087883a 	add	r3,r4,r2
 d03d764:	e0bffe17 	ldw	r2,-8(fp)
 d03d768:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 d03d76c:	e0bffe17 	ldw	r2,-8(fp)
 d03d770:	10800317 	ldw	r2,12(r2)
 d03d774:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 d03d778:	e0fff903 	ldbu	r3,-28(fp)
 d03d77c:	e0bff743 	ldbu	r2,-35(fp)
 d03d780:	1885883a 	add	r2,r3,r2
 d03d784:	1005d0ba 	srai	r2,r2,2
 d03d788:	10801014 	ori	r2,r2,64
 d03d78c:	1007883a 	mov	r3,r2
 d03d790:	e0bffc17 	ldw	r2,-16(fp)
 d03d794:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 d03d798:	e0bffc17 	ldw	r2,-16(fp)
 d03d79c:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 d03d7a0:	d0a05017 	ldw	r2,-32448(gp)
 d03d7a4:	10bfffcc 	andi	r2,r2,65535
 d03d7a8:	1004d23a 	srli	r2,r2,8
 d03d7ac:	10803fcc 	andi	r2,r2,255
 d03d7b0:	1009883a 	mov	r4,r2
 d03d7b4:	d0a05017 	ldw	r2,-32448(gp)
 d03d7b8:	10bfffcc 	andi	r2,r2,65535
 d03d7bc:	1004923a 	slli	r2,r2,8
 d03d7c0:	1007883a 	mov	r3,r2
 d03d7c4:	00bfc004 	movi	r2,-256
 d03d7c8:	1884703a 	and	r2,r3,r2
 d03d7cc:	2084b03a 	or	r2,r4,r2
 d03d7d0:	1007883a 	mov	r3,r2
 d03d7d4:	e0bffc17 	ldw	r2,-16(fp)
 d03d7d8:	10c0010d 	sth	r3,4(r2)
   uid++;
 d03d7dc:	d0a05017 	ldw	r2,-32448(gp)
 d03d7e0:	10800044 	addi	r2,r2,1
 d03d7e4:	d0a05015 	stw	r2,-32448(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 d03d7e8:	e0bffe17 	ldw	r2,-8(fp)
 d03d7ec:	10800417 	ldw	r2,16(r2)
 d03d7f0:	10bfffcc 	andi	r2,r2,65535
 d03d7f4:	1004d23a 	srli	r2,r2,8
 d03d7f8:	10803fcc 	andi	r2,r2,255
 d03d7fc:	1009883a 	mov	r4,r2
 d03d800:	e0bffe17 	ldw	r2,-8(fp)
 d03d804:	10800417 	ldw	r2,16(r2)
 d03d808:	10bfffcc 	andi	r2,r2,65535
 d03d80c:	1004923a 	slli	r2,r2,8
 d03d810:	1007883a 	mov	r3,r2
 d03d814:	00bfc004 	movi	r2,-256
 d03d818:	1884703a 	and	r2,r3,r2
 d03d81c:	2084b03a 	or	r2,r4,r2
 d03d820:	1007883a 	mov	r3,r2
 d03d824:	e0bffc17 	ldw	r2,-16(fp)
 d03d828:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 d03d82c:	e0fffc17 	ldw	r3,-16(fp)
 d03d830:	e0bffd03 	ldbu	r2,-12(fp)
 d03d834:	18800245 	stb	r2,9(r3)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 d03d838:	e0bffc17 	ldw	r2,-16(fp)
 d03d83c:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 d03d840:	00801004 	movi	r2,64
 d03d844:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 d03d848:	e0bffe17 	ldw	r2,-8(fp)
 d03d84c:	10800717 	ldw	r2,28(r2)
 d03d850:	1004d63a 	srli	r2,r2,24
 d03d854:	10c03fcc 	andi	r3,r2,255
 d03d858:	e0bffe17 	ldw	r2,-8(fp)
 d03d85c:	10800717 	ldw	r2,28(r2)
 d03d860:	1004d23a 	srli	r2,r2,8
 d03d864:	10bfc00c 	andi	r2,r2,65280
 d03d868:	1886b03a 	or	r3,r3,r2
 d03d86c:	e0bffe17 	ldw	r2,-8(fp)
 d03d870:	10800717 	ldw	r2,28(r2)
 d03d874:	10bfc00c 	andi	r2,r2,65280
 d03d878:	1004923a 	slli	r2,r2,8
 d03d87c:	1886b03a 	or	r3,r3,r2
 d03d880:	e0bffe17 	ldw	r2,-8(fp)
 d03d884:	10800717 	ldw	r2,28(r2)
 d03d888:	10803fcc 	andi	r2,r2,255
 d03d88c:	1004963a 	slli	r2,r2,24
 d03d890:	1884b03a 	or	r2,r3,r2
 d03d894:	10fc002c 	andhi	r3,r2,61440
 d03d898:	00b80034 	movhi	r2,57344
 d03d89c:	1880081e 	bne	r3,r2,d03d8c0 <ip_write2+0x254>
 d03d8a0:	e0bffe17 	ldw	r2,-8(fp)
 d03d8a4:	10800b17 	ldw	r2,44(r2)
 d03d8a8:	1005003a 	cmpeq	r2,r2,zero
 d03d8ac:	1000041e 	bne	r2,zero,d03d8c0 <ip_write2+0x254>
      ttl = p->imo->imo_multicast_ttl;
 d03d8b0:	e0bffe17 	ldw	r2,-8(fp)
 d03d8b4:	10800b17 	ldw	r2,44(r2)
 d03d8b8:	10800103 	ldbu	r2,4(r2)
 d03d8bc:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 d03d8c0:	e0bffe17 	ldw	r2,-8(fp)
 d03d8c4:	10800c17 	ldw	r2,48(r2)
 d03d8c8:	e0bffa15 	stw	r2,-24(fp)
 d03d8cc:	e0bffa17 	ldw	r2,-24(fp)
 d03d8d0:	1005003a 	cmpeq	r2,r2,zero
 d03d8d4:	1000121e 	bne	r2,zero,d03d920 <ip_write2+0x2b4>
   {
      if (sopts->ip_ttl)
 d03d8d8:	e0bffa17 	ldw	r2,-24(fp)
 d03d8dc:	10800043 	ldbu	r2,1(r2)
 d03d8e0:	10803fcc 	andi	r2,r2,255
 d03d8e4:	1005003a 	cmpeq	r2,r2,zero
 d03d8e8:	1000051e 	bne	r2,zero,d03d900 <ip_write2+0x294>
         pip->ip_time = sopts->ip_ttl;
 d03d8ec:	e0bffa17 	ldw	r2,-24(fp)
 d03d8f0:	10c00043 	ldbu	r3,1(r2)
 d03d8f4:	e0bffc17 	ldw	r2,-16(fp)
 d03d8f8:	10c00205 	stb	r3,8(r2)
 d03d8fc:	00000306 	br	d03d90c <ip_write2+0x2a0>
      else
         pip->ip_time = ttl;
 d03d900:	e0fffc17 	ldw	r3,-16(fp)
 d03d904:	e0bffb03 	ldbu	r2,-20(fp)
 d03d908:	18800205 	stb	r2,8(r3)
      pip->ip_tos = sopts->ip_tos;
 d03d90c:	e0bffa17 	ldw	r2,-24(fp)
 d03d910:	10c00003 	ldbu	r3,0(r2)
 d03d914:	e0bffc17 	ldw	r2,-16(fp)
 d03d918:	10c00045 	stb	r3,1(r2)
 d03d91c:	00000506 	br	d03d934 <ip_write2+0x2c8>
   }
   else
   {
      pip->ip_time = ttl;
 d03d920:	e0bffc17 	ldw	r2,-16(fp)
 d03d924:	e0fffb03 	ldbu	r3,-20(fp)
 d03d928:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 d03d92c:	e0bffc17 	ldw	r2,-16(fp)
 d03d930:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 d03d934:	e0bffe17 	ldw	r2,-8(fp)
 d03d938:	10800317 	ldw	r2,12(r2)
 d03d93c:	10800504 	addi	r2,r2,20
 d03d940:	e0bff815 	stw	r2,-32(fp)
 d03d944:	00000f06 	br	d03d984 <ip_write2+0x318>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 d03d948:	e0bfff17 	ldw	r2,-4(fp)
 d03d94c:	10800003 	ldbu	r2,0(r2)
 d03d950:	10803fcc 	andi	r2,r2,255
 d03d954:	10800520 	cmpeqi	r2,r2,20
 d03d958:	1000011e 	bne	r2,zero,d03d960 <ip_write2+0x2f4>
 d03d95c:	00000606 	br	d03d978 <ip_write2+0x30c>
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 d03d960:	e0fff817 	ldw	r3,-32(fp)
 d03d964:	00812504 	movi	r2,1172
 d03d968:	18800015 	stw	r2,0(r3)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 d03d96c:	e0bff817 	ldw	r2,-32(fp)
 d03d970:	10800104 	addi	r2,r2,4
 d03d974:	e0bff815 	stw	r2,-32(fp)
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 d03d978:	e0bfff17 	ldw	r2,-4(fp)
 d03d97c:	10800044 	addi	r2,r2,1
 d03d980:	e0bfff15 	stw	r2,-4(fp)
 d03d984:	e0bfff17 	ldw	r2,-4(fp)
 d03d988:	10800003 	ldbu	r2,0(r2)
 d03d98c:	10803fcc 	andi	r2,r2,255
 d03d990:	1004c03a 	cmpne	r2,r2,zero
 d03d994:	103fec1e 	bne	r2,zero,d03d948 <ip_write2+0x2dc>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 d03d998:	e03ff705 	stb	zero,-36(fp)
 d03d99c:	00000806 	br	d03d9c0 <ip_write2+0x354>
 d03d9a0:	e0bff703 	ldbu	r2,-36(fp)
 d03d9a4:	1007883a 	mov	r3,r2
 d03d9a8:	e0bff817 	ldw	r2,-32(fp)
 d03d9ac:	1885883a 	add	r2,r3,r2
 d03d9b0:	10000005 	stb	zero,0(r2)
 d03d9b4:	e0bff703 	ldbu	r2,-36(fp)
 d03d9b8:	10800044 	addi	r2,r2,1
 d03d9bc:	e0bff705 	stb	r2,-36(fp)
 d03d9c0:	e0fff703 	ldbu	r3,-36(fp)
 d03d9c4:	e0bff743 	ldbu	r2,-35(fp)
 d03d9c8:	18bff536 	bltu	r3,r2,d03d9a0 <ip_write2+0x334>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 d03d9cc:	e0fff903 	ldbu	r3,-28(fp)
 d03d9d0:	e0bff743 	ldbu	r2,-35(fp)
 d03d9d4:	1887883a 	add	r3,r3,r2
 d03d9d8:	1804d7fa 	srli	r2,r3,31
 d03d9dc:	10c5883a 	add	r2,r2,r3
 d03d9e0:	1005d07a 	srai	r2,r2,1
 d03d9e4:	100b883a 	mov	r5,r2
 d03d9e8:	e13ffc17 	ldw	r4,-16(fp)
 d03d9ec:	d0242340 	call	d024234 <cksum>
 d03d9f0:	0084303a 	nor	r2,zero,r2
 d03d9f4:	1007883a 	mov	r3,r2
 d03d9f8:	e0bffc17 	ldw	r2,-16(fp)
 d03d9fc:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 d03da00:	e13ffe17 	ldw	r4,-8(fp)
 d03da04:	d03cca40 	call	d03cca4 <ip_write_internal>
}
 d03da08:	e037883a 	mov	sp,fp
 d03da0c:	dfc00117 	ldw	ra,4(sp)
 d03da10:	df000017 	ldw	fp,0(sp)
 d03da14:	dec00204 	addi	sp,sp,8
 d03da18:	f800283a 	ret

0d03da1c <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 d03da1c:	defffc04 	addi	sp,sp,-16
 d03da20:	dfc00315 	stw	ra,12(sp)
 d03da24:	df000215 	stw	fp,8(sp)
 d03da28:	df000204 	addi	fp,sp,8
 d03da2c:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 d03da30:	008341b4 	movhi	r2,3334
 d03da34:	10b4eb04 	addi	r2,r2,-11348
 d03da38:	10800917 	ldw	r2,36(r2)
 d03da3c:	10c00044 	addi	r3,r2,1
 d03da40:	008341b4 	movhi	r2,3334
 d03da44:	10b4eb04 	addi	r2,r2,-11348
 d03da48:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 d03da4c:	e0bfff17 	ldw	r2,-4(fp)
 d03da50:	10800317 	ldw	r2,12(r2)
 d03da54:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 d03da58:	e0bffe17 	ldw	r2,-8(fp)
 d03da5c:	1080010b 	ldhu	r2,4(r2)
 d03da60:	10bfffcc 	andi	r2,r2,65535
 d03da64:	1004c03a 	cmpne	r2,r2,zero
 d03da68:	1000121e 	bne	r2,zero,d03dab4 <ip_raw_write+0x98>
   {
      pip->ip_id = htons((unshort)uid);
 d03da6c:	d0a05017 	ldw	r2,-32448(gp)
 d03da70:	10bfffcc 	andi	r2,r2,65535
 d03da74:	1004d23a 	srli	r2,r2,8
 d03da78:	10803fcc 	andi	r2,r2,255
 d03da7c:	1009883a 	mov	r4,r2
 d03da80:	d0a05017 	ldw	r2,-32448(gp)
 d03da84:	10bfffcc 	andi	r2,r2,65535
 d03da88:	1004923a 	slli	r2,r2,8
 d03da8c:	1007883a 	mov	r3,r2
 d03da90:	00bfc004 	movi	r2,-256
 d03da94:	1884703a 	and	r2,r3,r2
 d03da98:	2084b03a 	or	r2,r4,r2
 d03da9c:	1007883a 	mov	r3,r2
 d03daa0:	e0bffe17 	ldw	r2,-8(fp)
 d03daa4:	10c0010d 	sth	r3,4(r2)
      uid++;
 d03daa8:	d0a05017 	ldw	r2,-32448(gp)
 d03daac:	10800044 	addi	r2,r2,1
 d03dab0:	d0a05015 	stw	r2,-32448(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 d03dab4:	e0bffe17 	ldw	r2,-8(fp)
 d03dab8:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 d03dabc:	e13ffe17 	ldw	r4,-8(fp)
 d03dac0:	01400284 	movi	r5,10
 d03dac4:	d0242340 	call	d024234 <cksum>
 d03dac8:	0084303a 	nor	r2,zero,r2
 d03dacc:	1007883a 	mov	r3,r2
 d03dad0:	e0bffe17 	ldw	r2,-8(fp)
 d03dad4:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 d03dad8:	e13fff17 	ldw	r4,-4(fp)
 d03dadc:	d03cca40 	call	d03cca4 <ip_write_internal>
}
 d03dae0:	e037883a 	mov	sp,fp
 d03dae4:	dfc00117 	ldw	ra,4(sp)
 d03dae8:	df000017 	ldw	fp,0(sp)
 d03daec:	dec00204 	addi	sp,sp,8
 d03daf0:	f800283a 	ret

0d03daf4 <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 d03daf4:	deffed04 	addi	sp,sp,-76
 d03daf8:	dfc01215 	stw	ra,72(sp)
 d03dafc:	df001115 	stw	fp,68(sp)
 d03db00:	df001104 	addi	fp,sp,68
 d03db04:	e13ffa15 	stw	r4,-24(fp)
 d03db08:	e17ffb15 	stw	r5,-20(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 d03db0c:	008341b4 	movhi	r2,3334
 d03db10:	10b4eb04 	addi	r2,r2,-11348
 d03db14:	10801017 	ldw	r2,64(r2)
 d03db18:	10c00044 	addi	r3,r2,1
 d03db1c:	008341b4 	movhi	r2,3334
 d03db20:	10b4eb04 	addi	r2,r2,-11348
 d03db24:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 d03db28:	e0bffa17 	ldw	r2,-24(fp)
 d03db2c:	10800317 	ldw	r2,12(r2)
 d03db30:	e0bff115 	stw	r2,-60(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 d03db34:	e0bff117 	ldw	r2,-60(fp)
 d03db38:	10800003 	ldbu	r2,0(r2)
 d03db3c:	10803fcc 	andi	r2,r2,255
 d03db40:	108003cc 	andi	r2,r2,15
 d03db44:	1085883a 	add	r2,r2,r2
 d03db48:	1085883a 	add	r2,r2,r2
 d03db4c:	e0bff015 	stw	r2,-64(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 d03db50:	e0bffa17 	ldw	r2,-24(fp)
 d03db54:	10800417 	ldw	r2,16(r2)
 d03db58:	1007883a 	mov	r3,r2
 d03db5c:	e0bff017 	ldw	r2,-64(fp)
 d03db60:	1885c83a 	sub	r2,r3,r2
 d03db64:	e0bff415 	stw	r2,-48(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 d03db68:	e0bffa17 	ldw	r2,-24(fp)
 d03db6c:	10800617 	ldw	r2,24(r2)
 d03db70:	11000917 	ldw	r4,36(r2)
 d03db74:	e0bffa17 	ldw	r2,-24(fp)
 d03db78:	10800617 	ldw	r2,24(r2)
 d03db7c:	10c00817 	ldw	r3,32(r2)
 d03db80:	e0bff017 	ldw	r2,-64(fp)
 d03db84:	1885883a 	add	r2,r3,r2
 d03db88:	2085c83a 	sub	r2,r4,r2
 d03db8c:	10bffe04 	addi	r2,r2,-8
 d03db90:	e0bff815 	stw	r2,-32(fp)
   if (maxipsize < 64)  /* to small to use */
 d03db94:	e0bff817 	ldw	r2,-32(fp)
 d03db98:	10801028 	cmpgeui	r2,r2,64
 d03db9c:	1000041e 	bne	r2,zero,d03dbb0 <ip_fragment_lc+0xbc>
   {
      dtrap();    /* probably bad programming */
 d03dba0:	d0293e80 	call	d0293e8 <dtrap>
      return ENP_LOGIC;
 d03dba4:	00bffd44 	movi	r2,-11
 d03dba8:	e0bffe15 	stw	r2,-8(fp)
 d03dbac:	0000ed06 	br	d03df64 <ip_fragment_lc+0x470>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 d03dbb0:	e0bffa17 	ldw	r2,-24(fp)
 d03dbb4:	10c00417 	ldw	r3,16(r2)
 d03dbb8:	e0bff817 	ldw	r2,-32(fp)
 d03dbbc:	1885203a 	divu	r2,r3,r2
 d03dbc0:	10800044 	addi	r2,r2,1
 d03dbc4:	e0bff715 	stw	r2,-36(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 d03dbc8:	e0bffa17 	ldw	r2,-24(fp)
 d03dbcc:	10c00417 	ldw	r3,16(r2)
 d03dbd0:	e0bff717 	ldw	r2,-36(fp)
 d03dbd4:	1885883a 	add	r2,r3,r2
 d03dbd8:	10ffffc4 	addi	r3,r2,-1
 d03dbdc:	e0bff717 	ldw	r2,-36(fp)
 d03dbe0:	1885203a 	divu	r2,r3,r2
 d03dbe4:	10c001c4 	addi	r3,r2,7
 d03dbe8:	00bffe04 	movi	r2,-8
 d03dbec:	1884703a 	and	r2,r3,r2
 d03dbf0:	e0bff915 	stw	r2,-28(fp)
   foffset = 0;
 d03dbf4:	e03ff615 	stw	zero,-40(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 d03dbf8:	e0bff117 	ldw	r2,-60(fp)
 d03dbfc:	1080018b 	ldhu	r2,6(r2)
 d03dc00:	10bfffcc 	andi	r2,r2,65535
 d03dc04:	1004d23a 	srli	r2,r2,8
 d03dc08:	10803fcc 	andi	r2,r2,255
 d03dc0c:	1009883a 	mov	r4,r2
 d03dc10:	e0bff117 	ldw	r2,-60(fp)
 d03dc14:	1080018b 	ldhu	r2,6(r2)
 d03dc18:	10bfffcc 	andi	r2,r2,65535
 d03dc1c:	1004923a 	slli	r2,r2,8
 d03dc20:	1007883a 	mov	r3,r2
 d03dc24:	00bfc004 	movi	r2,-256
 d03dc28:	1884703a 	and	r2,r3,r2
 d03dc2c:	2084b03a 	or	r2,r4,r2
 d03dc30:	e0bfef0d 	sth	r2,-68(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 d03dc34:	e0ffef0b 	ldhu	r3,-68(fp)
 d03dc38:	00bffff4 	movhi	r2,65535
 d03dc3c:	1087ffc4 	addi	r2,r2,8191
 d03dc40:	1884703a 	and	r2,r3,r2
 d03dc44:	1005003a 	cmpeq	r2,r2,zero
 d03dc48:	1000081e 	bne	r2,zero,d03dc6c <ip_fragment_lc+0x178>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 d03dc4c:	e0ffef0b 	ldhu	r3,-68(fp)
 d03dc50:	00bffff4 	movhi	r2,65535
 d03dc54:	1087ffc4 	addi	r2,r2,8191
 d03dc58:	1884703a 	and	r2,r3,r2
 d03dc5c:	e0bff615 	stw	r2,-40(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 d03dc60:	e0bff617 	ldw	r2,-40(fp)
 d03dc64:	100490fa 	slli	r2,r2,3
 d03dc68:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 d03dc6c:	e0bffa17 	ldw	r2,-24(fp)
 d03dc70:	e0bff315 	stw	r2,-52(fp)
   e = 0;
 d03dc74:	e03ff215 	stw	zero,-56(fp)
   while (left > 1)  /* more data left to send? */
 d03dc78:	0000b506 	br	d03df50 <ip_fragment_lc+0x45c>
   {
      p = pkt2;  /* move next fragment up */
 d03dc7c:	e0bff317 	ldw	r2,-52(fp)
 d03dc80:	e0bffa15 	stw	r2,-24(fp)
      pip = (struct ip *)(p->nb_prot);
 d03dc84:	e0bffa17 	ldw	r2,-24(fp)
 d03dc88:	10800317 	ldw	r2,12(r2)
 d03dc8c:	e0bff115 	stw	r2,-60(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 d03dc90:	e0bff917 	ldw	r2,-28(fp)
 d03dc94:	e0fff417 	ldw	r3,-48(fp)
 d03dc98:	e0ffff15 	stw	r3,-4(fp)
 d03dc9c:	e0bffd15 	stw	r2,-12(fp)
 d03dca0:	e0bfff17 	ldw	r2,-4(fp)
 d03dca4:	e0fffd17 	ldw	r3,-12(fp)
 d03dca8:	10c0020e 	bge	r2,r3,d03dcb4 <ip_fragment_lc+0x1c0>
 d03dcac:	e0bfff17 	ldw	r2,-4(fp)
 d03dcb0:	e0bffd15 	stw	r2,-12(fp)
 d03dcb4:	e0bff017 	ldw	r2,-64(fp)
 d03dcb8:	e0fffd17 	ldw	r3,-12(fp)
 d03dcbc:	1885883a 	add	r2,r3,r2
 d03dcc0:	1007883a 	mov	r3,r2
 d03dcc4:	e0bffa17 	ldw	r2,-24(fp)
 d03dcc8:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 d03dccc:	e0fff417 	ldw	r3,-48(fp)
 d03dcd0:	e0bff917 	ldw	r2,-28(fp)
 d03dcd4:	1885c83a 	sub	r2,r3,r2
 d03dcd8:	e0bff415 	stw	r2,-48(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 d03dcdc:	e0bffa17 	ldw	r2,-24(fp)
 d03dce0:	10800417 	ldw	r2,16(r2)
 d03dce4:	10bfffcc 	andi	r2,r2,65535
 d03dce8:	1004d23a 	srli	r2,r2,8
 d03dcec:	10803fcc 	andi	r2,r2,255
 d03dcf0:	1009883a 	mov	r4,r2
 d03dcf4:	e0bffa17 	ldw	r2,-24(fp)
 d03dcf8:	10800417 	ldw	r2,16(r2)
 d03dcfc:	10bfffcc 	andi	r2,r2,65535
 d03dd00:	1004923a 	slli	r2,r2,8
 d03dd04:	1007883a 	mov	r3,r2
 d03dd08:	00bfc004 	movi	r2,-256
 d03dd0c:	1884703a 	and	r2,r3,r2
 d03dd10:	2084b03a 	or	r2,r4,r2
 d03dd14:	1007883a 	mov	r3,r2
 d03dd18:	e0bff117 	ldw	r2,-60(fp)
 d03dd1c:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 d03dd20:	e0bff617 	ldw	r2,-40(fp)
 d03dd24:	1004d0fa 	srli	r2,r2,3
 d03dd28:	e0bff50d 	sth	r2,-44(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 d03dd2c:	e0bff417 	ldw	r2,-48(fp)
 d03dd30:	10800090 	cmplti	r2,r2,2
 d03dd34:	1000031e 	bne	r2,zero,d03dd44 <ip_fragment_lc+0x250>
 d03dd38:	00880004 	movi	r2,8192
 d03dd3c:	e0bffc0d 	sth	r2,-16(fp)
 d03dd40:	00000106 	br	d03dd48 <ip_fragment_lc+0x254>
 d03dd44:	e03ffc0d 	sth	zero,-16(fp)
 d03dd48:	e0bff50b 	ldhu	r2,-44(fp)
 d03dd4c:	e0fffc0b 	ldhu	r3,-16(fp)
 d03dd50:	1884b03a 	or	r2,r3,r2
 d03dd54:	e0bff50d 	sth	r2,-44(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 d03dd58:	e0bfef0b 	ldhu	r2,-68(fp)
 d03dd5c:	1088000c 	andi	r2,r2,8192
 d03dd60:	1005003a 	cmpeq	r2,r2,zero
 d03dd64:	1000031e 	bne	r2,zero,d03dd74 <ip_fragment_lc+0x280>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 d03dd68:	e0bff50b 	ldhu	r2,-44(fp)
 d03dd6c:	10880014 	ori	r2,r2,8192
 d03dd70:	e0bff50d 	sth	r2,-44(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 d03dd74:	e0bff50b 	ldhu	r2,-44(fp)
 d03dd78:	1004d23a 	srli	r2,r2,8
 d03dd7c:	10803fcc 	andi	r2,r2,255
 d03dd80:	1009883a 	mov	r4,r2
 d03dd84:	e0bff50b 	ldhu	r2,-44(fp)
 d03dd88:	1004923a 	slli	r2,r2,8
 d03dd8c:	1007883a 	mov	r3,r2
 d03dd90:	00bfc004 	movi	r2,-256
 d03dd94:	1884703a 	and	r2,r3,r2
 d03dd98:	2084b03a 	or	r2,r4,r2
 d03dd9c:	1007883a 	mov	r3,r2
 d03dda0:	e0bff117 	ldw	r2,-60(fp)
 d03dda4:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 d03dda8:	e0bff417 	ldw	r2,-48(fp)
 d03ddac:	10800090 	cmplti	r2,r2,2
 d03ddb0:	1000401e 	bne	r2,zero,d03deb4 <ip_fragment_lc+0x3c0>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03ddb4:	01000084 	movi	r4,2
 d03ddb8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 d03ddbc:	e0fff417 	ldw	r3,-48(fp)
 d03ddc0:	e0bff017 	ldw	r2,-64(fp)
 d03ddc4:	1887883a 	add	r3,r3,r2
 d03ddc8:	00834174 	movhi	r2,3333
 d03ddcc:	108aa204 	addi	r2,r2,10888
 d03ddd0:	10800017 	ldw	r2,0(r2)
 d03ddd4:	1885883a 	add	r2,r3,r2
 d03ddd8:	1009883a 	mov	r4,r2
 d03dddc:	d0287a40 	call	d0287a4 <pk_alloc>
 d03dde0:	e0bff315 	stw	r2,-52(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03dde4:	01000084 	movi	r4,2
 d03dde8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 d03ddec:	e0bff317 	ldw	r2,-52(fp)
 d03ddf0:	1004c03a 	cmpne	r2,r2,zero
 d03ddf4:	1000111e 	bne	r2,zero,d03de3c <ip_fragment_lc+0x348>
         {
            dtrap();
 d03ddf8:	d0293e80 	call	d0293e8 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03ddfc:	01000084 	movi	r4,2
 d03de00:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free(p);
 d03de04:	e13ffa17 	ldw	r4,-24(fp)
 d03de08:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03de0c:	01000084 	movi	r4,2
 d03de10:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 d03de14:	008341b4 	movhi	r2,3334
 d03de18:	10b4eb04 	addi	r2,r2,-11348
 d03de1c:	10801117 	ldw	r2,68(r2)
 d03de20:	10c00044 	addi	r3,r2,1
 d03de24:	008341b4 	movhi	r2,3334
 d03de28:	10b4eb04 	addi	r2,r2,-11348
 d03de2c:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 d03de30:	00bffa84 	movi	r2,-22
 d03de34:	e0bffe15 	stw	r2,-8(fp)
 d03de38:	00004a06 	br	d03df64 <ip_fragment_lc+0x470>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 d03de3c:	e0bffa17 	ldw	r2,-24(fp)
 d03de40:	10c00617 	ldw	r3,24(r2)
 d03de44:	e0bff317 	ldw	r2,-52(fp)
 d03de48:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 d03de4c:	e0bffa17 	ldw	r2,-24(fp)
 d03de50:	10c00717 	ldw	r3,28(r2)
 d03de54:	e0bff317 	ldw	r2,-52(fp)
 d03de58:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 d03de5c:	e0bff317 	ldw	r2,-52(fp)
 d03de60:	11000317 	ldw	r4,12(r2)
 d03de64:	e0bffa17 	ldw	r2,-24(fp)
 d03de68:	10800317 	ldw	r2,12(r2)
 d03de6c:	e0fff017 	ldw	r3,-64(fp)
 d03de70:	100b883a 	mov	r5,r2
 d03de74:	180d883a 	mov	r6,r3
 d03de78:	d0027000 	call	d002700 <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 d03de7c:	e0bff317 	ldw	r2,-52(fp)
 d03de80:	10c00317 	ldw	r3,12(r2)
 d03de84:	e0bff017 	ldw	r2,-64(fp)
 d03de88:	1889883a 	add	r4,r3,r2
 d03de8c:	e0bffa17 	ldw	r2,-24(fp)
 d03de90:	10c00317 	ldw	r3,12(r2)
 d03de94:	e0bff017 	ldw	r2,-64(fp)
 d03de98:	1887883a 	add	r3,r3,r2
 d03de9c:	e0bff917 	ldw	r2,-28(fp)
 d03dea0:	1885883a 	add	r2,r3,r2
 d03dea4:	e0fff417 	ldw	r3,-48(fp)
 d03dea8:	100b883a 	mov	r5,r2
 d03deac:	180d883a 	mov	r6,r3
 d03deb0:	d0027000 	call	d002700 <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 d03deb4:	e0bff117 	ldw	r2,-60(fp)
 d03deb8:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 d03debc:	e13ff117 	ldw	r4,-60(fp)
 d03dec0:	01400284 	movi	r5,10
 d03dec4:	d0242340 	call	d024234 <cksum>
 d03dec8:	0084303a 	nor	r2,zero,r2
 d03decc:	1007883a 	mov	r3,r2
 d03ded0:	e0bff117 	ldw	r2,-60(fp)
 d03ded4:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 d03ded8:	e13ffa17 	ldw	r4,-24(fp)
 d03dedc:	e17ffb17 	ldw	r5,-20(fp)
 d03dee0:	d021fd40 	call	d021fd4 <ip2mac>
 d03dee4:	e0bff215 	stw	r2,-56(fp)
      ip_mib.ipFragCreates++;
 d03dee8:	008341b4 	movhi	r2,3334
 d03deec:	10b4eb04 	addi	r2,r2,-11348
 d03def0:	10801217 	ldw	r2,72(r2)
 d03def4:	10c00044 	addi	r3,r2,1
 d03def8:	008341b4 	movhi	r2,3334
 d03defc:	10b4eb04 	addi	r2,r2,-11348
 d03df00:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 d03df04:	e0bff217 	ldw	r2,-56(fp)
 d03df08:	1004403a 	cmpge	r2,r2,zero
 d03df0c:	10000c1e 	bne	r2,zero,d03df40 <ip_fragment_lc+0x44c>
      {
         if (left > 1) 
 d03df10:	e0bff417 	ldw	r2,-48(fp)
 d03df14:	10800090 	cmplti	r2,r2,2
 d03df18:	1000061e 	bne	r2,zero,d03df34 <ip_fragment_lc+0x440>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03df1c:	01000084 	movi	r4,2
 d03df20:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 d03df24:	e13ff317 	ldw	r4,-52(fp)
 d03df28:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03df2c:	01000084 	movi	r4,2
 d03df30:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         }
         return e;
 d03df34:	e0fff217 	ldw	r3,-56(fp)
 d03df38:	e0fffe15 	stw	r3,-8(fp)
 d03df3c:	00000906 	br	d03df64 <ip_fragment_lc+0x470>
      }
      foffset += fragsize;    /* offset for next fragment */
 d03df40:	e0bff617 	ldw	r2,-40(fp)
 d03df44:	e0fff917 	ldw	r3,-28(fp)
 d03df48:	10c5883a 	add	r2,r2,r3
 d03df4c:	e0bff615 	stw	r2,-40(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 d03df50:	e0bff417 	ldw	r2,-48(fp)
 d03df54:	10800088 	cmpgei	r2,r2,2
 d03df58:	103f481e 	bne	r2,zero,d03dc7c <ip_fragment_lc+0x188>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 d03df5c:	e0bff217 	ldw	r2,-56(fp)
 d03df60:	e0bffe15 	stw	r2,-8(fp)
 d03df64:	e0bffe17 	ldw	r2,-8(fp)
}
 d03df68:	e037883a 	mov	sp,fp
 d03df6c:	dfc00117 	ldw	ra,4(sp)
 d03df70:	df000017 	ldw	fp,0(sp)
 d03df74:	dec00204 	addi	sp,sp,8
 d03df78:	f800283a 	ret

0d03df7c <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 d03df7c:	deffed04 	addi	sp,sp,-76
 d03df80:	dfc01215 	stw	ra,72(sp)
 d03df84:	df001115 	stw	fp,68(sp)
 d03df88:	df001104 	addi	fp,sp,68
 d03df8c:	e13ffa15 	stw	r4,-24(fp)
 d03df90:	e17ffb15 	stw	r5,-20(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 d03df94:	e0bffa17 	ldw	r2,-24(fp)
 d03df98:	10800317 	ldw	r2,12(r2)
 d03df9c:	e0bff815 	stw	r2,-32(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 d03dfa0:	e0bff817 	ldw	r2,-32(fp)
 d03dfa4:	1080018b 	ldhu	r2,6(r2)
 d03dfa8:	10bfffcc 	andi	r2,r2,65535
 d03dfac:	1004d23a 	srli	r2,r2,8
 d03dfb0:	10bfffcc 	andi	r2,r2,65535
 d03dfb4:	10c03fcc 	andi	r3,r2,255
 d03dfb8:	e0bff817 	ldw	r2,-32(fp)
 d03dfbc:	1080018b 	ldhu	r2,6(r2)
 d03dfc0:	10bfffcc 	andi	r2,r2,65535
 d03dfc4:	1004923a 	slli	r2,r2,8
 d03dfc8:	10bfc00c 	andi	r2,r2,65280
 d03dfcc:	1884b03a 	or	r2,r3,r2
 d03dfd0:	1090000c 	andi	r2,r2,16384
 d03dfd4:	1005003a 	cmpeq	r2,r2,zero
 d03dfd8:	10001a1e 	bne	r2,zero,d03e044 <ip_fragment+0xc8>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03dfdc:	01000084 	movi	r4,2
 d03dfe0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d03dfe4:	e13ffa17 	ldw	r4,-24(fp)
 d03dfe8:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03dfec:	01000084 	movi	r4,2
 d03dff0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 d03dff4:	008341b4 	movhi	r2,3334
 d03dff8:	10b4eb04 	addi	r2,r2,-11348
 d03dffc:	10801117 	ldw	r2,68(r2)
 d03e000:	10c00044 	addi	r3,r2,1
 d03e004:	008341b4 	movhi	r2,3334
 d03e008:	10b4eb04 	addi	r2,r2,-11348
 d03e00c:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 d03e010:	e0bff817 	ldw	r2,-32(fp)
 d03e014:	11000317 	ldw	r4,12(r2)
 d03e018:	e0bffa17 	ldw	r2,-24(fp)
 d03e01c:	10800617 	ldw	r2,24(r2)
 d03e020:	11400a17 	ldw	r5,40(r2)
 d03e024:	e0bffa17 	ldw	r2,-24(fp)
 d03e028:	10800617 	ldw	r2,24(r2)
 d03e02c:	d8800015 	stw	r2,0(sp)
 d03e030:	e1bff817 	ldw	r6,-32(fp)
 d03e034:	01c00104 	movi	r7,4
 d03e038:	d0497540 	call	d049754 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 d03e03c:	e03ffe15 	stw	zero,-8(fp)
 d03e040:	00015306 	br	d03e590 <ip_fragment+0x614>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 d03e044:	d028be40 	call	d028be4 <pk_get_max_intrsafe_buf_len>
 d03e048:	e0bff915 	stw	r2,-28(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 d03e04c:	e0bffa17 	ldw	r2,-24(fp)
 d03e050:	10800617 	ldw	r2,24(r2)
 d03e054:	10800917 	ldw	r2,36(r2)
 d03e058:	e0fff917 	ldw	r3,-28(fp)
 d03e05c:	e0ffff15 	stw	r3,-4(fp)
 d03e060:	e0bffd15 	stw	r2,-12(fp)
 d03e064:	e0bfff17 	ldw	r2,-4(fp)
 d03e068:	e0fffd17 	ldw	r3,-12(fp)
 d03e06c:	10c0022e 	bgeu	r2,r3,d03e078 <ip_fragment+0xfc>
 d03e070:	e0bfff17 	ldw	r2,-4(fp)
 d03e074:	e0bffd15 	stw	r2,-12(fp)
 d03e078:	e0fffd17 	ldw	r3,-12(fp)
 d03e07c:	e0fff58d 	sth	r3,-42(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 d03e080:	e0bff817 	ldw	r2,-32(fp)
 d03e084:	10800003 	ldbu	r2,0(r2)
 d03e088:	108003cc 	andi	r2,r2,15
 d03e08c:	1085883a 	add	r2,r2,r2
 d03e090:	1085883a 	add	r2,r2,r2
 d03e094:	e0bff7c5 	stb	r2,-33(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 d03e098:	e0bffa17 	ldw	r2,-24(fp)
 d03e09c:	10800617 	ldw	r2,24(r2)
 d03e0a0:	10800817 	ldw	r2,32(r2)
 d03e0a4:	e0bff785 	stb	r2,-34(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 d03e0a8:	e0fff7c3 	ldbu	r3,-33(fp)
 d03e0ac:	e0bff58b 	ldhu	r2,-42(fp)
 d03e0b0:	10c5c83a 	sub	r2,r2,r3
 d03e0b4:	1007883a 	mov	r3,r2
 d03e0b8:	e0bff783 	ldbu	r2,-34(fp)
 d03e0bc:	1885c83a 	sub	r2,r3,r2
 d03e0c0:	e0bff70d 	sth	r2,-36(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 d03e0c4:	e0fff70b 	ldhu	r3,-36(fp)
 d03e0c8:	00bffe04 	movi	r2,-8
 d03e0cc:	1884703a 	and	r2,r3,r2
 d03e0d0:	e0bff70d 	sth	r2,-36(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 d03e0d4:	e0bff817 	ldw	r2,-32(fp)
 d03e0d8:	1080008b 	ldhu	r2,2(r2)
 d03e0dc:	10bfffcc 	andi	r2,r2,65535
 d03e0e0:	1004d23a 	srli	r2,r2,8
 d03e0e4:	10803fcc 	andi	r2,r2,255
 d03e0e8:	1009883a 	mov	r4,r2
 d03e0ec:	e0bff817 	ldw	r2,-32(fp)
 d03e0f0:	1080008b 	ldhu	r2,2(r2)
 d03e0f4:	10bfffcc 	andi	r2,r2,65535
 d03e0f8:	1004923a 	slli	r2,r2,8
 d03e0fc:	1007883a 	mov	r3,r2
 d03e100:	00bfc004 	movi	r2,-256
 d03e104:	1884703a 	and	r2,r3,r2
 d03e108:	2084b03a 	or	r2,r4,r2
 d03e10c:	1007883a 	mov	r3,r2
 d03e110:	e0bff7c3 	ldbu	r2,-33(fp)
 d03e114:	1885c83a 	sub	r2,r3,r2
 d03e118:	e0bff68d 	sth	r2,-38(fp)
   num_frags = (total_payload_len / useable_payload_len);
 d03e11c:	e0fff68b 	ldhu	r3,-38(fp)
 d03e120:	e0bff70b 	ldhu	r2,-36(fp)
 d03e124:	1885203a 	divu	r2,r3,r2
 d03e128:	e0bff50d 	sth	r2,-44(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 d03e12c:	e13ff68b 	ldhu	r4,-38(fp)
 d03e130:	e0fff70b 	ldhu	r3,-36(fp)
 d03e134:	20c5203a 	divu	r2,r4,r3
 d03e138:	10c5383a 	mul	r2,r2,r3
 d03e13c:	2085c83a 	sub	r2,r4,r2
 d03e140:	e0bff60d 	sth	r2,-40(fp)
 d03e144:	e0bff60b 	ldhu	r2,-40(fp)
 d03e148:	1005003a 	cmpeq	r2,r2,zero
 d03e14c:	1000031e 	bne	r2,zero,d03e15c <ip_fragment+0x1e0>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 d03e150:	e0bff50b 	ldhu	r2,-44(fp)
 d03e154:	10800044 	addi	r2,r2,1
 d03e158:	e0bff50d 	sth	r2,-44(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 d03e15c:	e0bff50b 	ldhu	r2,-44(fp)
 d03e160:	10800128 	cmpgeui	r2,r2,4
 d03e164:	10000a1e 	bne	r2,zero,d03e190 <ip_fragment+0x214>
 d03e168:	e0bffa17 	ldw	r2,-24(fp)
 d03e16c:	10800a17 	ldw	r2,40(r2)
 d03e170:	1080040c 	andi	r2,r2,16
 d03e174:	1004c03a 	cmpne	r2,r2,zero
 d03e178:	1000051e 	bne	r2,zero,d03e190 <ip_fragment+0x214>
   {
      return (ip_fragment_lc (p, firsthop));
 d03e17c:	e13ffa17 	ldw	r4,-24(fp)
 d03e180:	e17ffb17 	ldw	r5,-20(fp)
 d03e184:	d03daf40 	call	d03daf4 <ip_fragment_lc>
 d03e188:	e0bffe15 	stw	r2,-8(fp)
 d03e18c:	00010006 	br	d03e590 <ip_fragment+0x614>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 d03e190:	e0bff817 	ldw	r2,-32(fp)
 d03e194:	1080018b 	ldhu	r2,6(r2)
 d03e198:	10bfffcc 	andi	r2,r2,65535
 d03e19c:	1004d23a 	srli	r2,r2,8
 d03e1a0:	10803fcc 	andi	r2,r2,255
 d03e1a4:	1009883a 	mov	r4,r2
 d03e1a8:	e0bff817 	ldw	r2,-32(fp)
 d03e1ac:	1080018b 	ldhu	r2,6(r2)
 d03e1b0:	10bfffcc 	andi	r2,r2,65535
 d03e1b4:	1004923a 	slli	r2,r2,8
 d03e1b8:	1007883a 	mov	r3,r2
 d03e1bc:	00bfc004 	movi	r2,-256
 d03e1c0:	1884703a 	and	r2,r3,r2
 d03e1c4:	2084b03a 	or	r2,r4,r2
 d03e1c8:	1087ffcc 	andi	r2,r2,8191
 d03e1cc:	100490fa 	slli	r2,r2,3
 d03e1d0:	e0bff38d 	sth	r2,-50(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 d03e1d4:	e0bff817 	ldw	r2,-32(fp)
 d03e1d8:	1080018b 	ldhu	r2,6(r2)
 d03e1dc:	10bfffcc 	andi	r2,r2,65535
 d03e1e0:	1004d23a 	srli	r2,r2,8
 d03e1e4:	10803fcc 	andi	r2,r2,255
 d03e1e8:	1009883a 	mov	r4,r2
 d03e1ec:	e0bff817 	ldw	r2,-32(fp)
 d03e1f0:	1080018b 	ldhu	r2,6(r2)
 d03e1f4:	10bfffcc 	andi	r2,r2,65535
 d03e1f8:	1004923a 	slli	r2,r2,8
 d03e1fc:	1007883a 	mov	r3,r2
 d03e200:	00bfc004 	movi	r2,-256
 d03e204:	1884703a 	and	r2,r3,r2
 d03e208:	2084b03a 	or	r2,r4,r2
 d03e20c:	1088000c 	andi	r2,r2,8192
 d03e210:	e0bff30d 	sth	r2,-52(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 d03e214:	e03ff48d 	sth	zero,-46(fp)
 d03e218:	0000cc06 	br	d03e54c <ip_fragment+0x5d0>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d03e21c:	01000084 	movi	r4,2
 d03e220:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 d03e224:	e0fff70b 	ldhu	r3,-36(fp)
 d03e228:	e0bff7c3 	ldbu	r2,-33(fp)
 d03e22c:	1887883a 	add	r3,r3,r2
 d03e230:	e0bff783 	ldbu	r2,-34(fp)
 d03e234:	1885883a 	add	r2,r3,r2
 d03e238:	1009883a 	mov	r4,r2
 d03e23c:	d0287a40 	call	d0287a4 <pk_alloc>
 d03e240:	e0bff215 	stw	r2,-56(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03e244:	01000084 	movi	r4,2
 d03e248:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 d03e24c:	e0bff217 	ldw	r2,-56(fp)
 d03e250:	1004c03a 	cmpne	r2,r2,zero
 d03e254:	1000101e 	bne	r2,zero,d03e298 <ip_fragment+0x31c>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d03e258:	01000084 	movi	r4,2
 d03e25c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(p);
 d03e260:	e13ffa17 	ldw	r4,-24(fp)
 d03e264:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03e268:	01000084 	movi	r4,2
 d03e26c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 d03e270:	008341b4 	movhi	r2,3334
 d03e274:	10b4eb04 	addi	r2,r2,-11348
 d03e278:	10801117 	ldw	r2,68(r2)
 d03e27c:	10c00044 	addi	r3,r2,1
 d03e280:	008341b4 	movhi	r2,3334
 d03e284:	10b4eb04 	addi	r2,r2,-11348
 d03e288:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 d03e28c:	00bffac4 	movi	r2,-21
 d03e290:	e0bffe15 	stw	r2,-8(fp)
 d03e294:	0000be06 	br	d03e590 <ip_fragment+0x614>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 d03e298:	e0bff217 	ldw	r2,-56(fp)
 d03e29c:	10c00117 	ldw	r3,4(r2)
 d03e2a0:	e0bff783 	ldbu	r2,-34(fp)
 d03e2a4:	1889883a 	add	r4,r3,r2
 d03e2a8:	e0bffa17 	ldw	r2,-24(fp)
 d03e2ac:	10800317 	ldw	r2,12(r2)
 d03e2b0:	e0fff7c3 	ldbu	r3,-33(fp)
 d03e2b4:	100b883a 	mov	r5,r2
 d03e2b8:	180d883a 	mov	r6,r3
 d03e2bc:	d0027000 	call	d002700 <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 d03e2c0:	e0fff48b 	ldhu	r3,-46(fp)
 d03e2c4:	e0bff50b 	ldhu	r2,-44(fp)
 d03e2c8:	10bfffc4 	addi	r2,r2,-1
 d03e2cc:	1880030e 	bge	r3,r2,d03e2dc <ip_fragment+0x360>
         {
            amt_to_copy = useable_payload_len;
 d03e2d0:	e0bff70b 	ldhu	r2,-36(fp)
 d03e2d4:	e0bff40d 	sth	r2,-48(fp)
 d03e2d8:	00000a06 	br	d03e304 <ip_fragment+0x388>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 d03e2dc:	e0bff60b 	ldhu	r2,-40(fp)
 d03e2e0:	1004c03a 	cmpne	r2,r2,zero
 d03e2e4:	1000031e 	bne	r2,zero,d03e2f4 <ip_fragment+0x378>
 d03e2e8:	e0fff70b 	ldhu	r3,-36(fp)
 d03e2ec:	e0fffc0d 	sth	r3,-16(fp)
 d03e2f0:	00000206 	br	d03e2fc <ip_fragment+0x380>
 d03e2f4:	e0bff60b 	ldhu	r2,-40(fp)
 d03e2f8:	e0bffc0d 	sth	r2,-16(fp)
 d03e2fc:	e0fffc0b 	ldhu	r3,-16(fp)
 d03e300:	e0fff40d 	sth	r3,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 d03e304:	e0bff217 	ldw	r2,-56(fp)
 d03e308:	10c00117 	ldw	r3,4(r2)
 d03e30c:	e0bff783 	ldbu	r2,-34(fp)
 d03e310:	1887883a 	add	r3,r3,r2
 d03e314:	e0bff7c3 	ldbu	r2,-33(fp)
 d03e318:	188b883a 	add	r5,r3,r2
 d03e31c:	e0bffa17 	ldw	r2,-24(fp)
 d03e320:	10c00317 	ldw	r3,12(r2)
 d03e324:	e0bff7c3 	ldbu	r2,-33(fp)
 d03e328:	1889883a 	add	r4,r3,r2
 d03e32c:	e0fff70b 	ldhu	r3,-36(fp)
 d03e330:	e0bff48b 	ldhu	r2,-46(fp)
 d03e334:	1885383a 	mul	r2,r3,r2
 d03e338:	2085883a 	add	r2,r4,r2
 d03e33c:	e0fff40b 	ldhu	r3,-48(fp)
 d03e340:	2809883a 	mov	r4,r5
 d03e344:	100b883a 	mov	r5,r2
 d03e348:	180d883a 	mov	r6,r3
 d03e34c:	d0027000 	call	d002700 <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 d03e350:	e0bff217 	ldw	r2,-56(fp)
 d03e354:	10c00117 	ldw	r3,4(r2)
 d03e358:	e0bff783 	ldbu	r2,-34(fp)
 d03e35c:	1887883a 	add	r3,r3,r2
 d03e360:	e0bff217 	ldw	r2,-56(fp)
 d03e364:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 d03e368:	e0fff7c3 	ldbu	r3,-33(fp)
 d03e36c:	e0bff40b 	ldhu	r2,-48(fp)
 d03e370:	1885883a 	add	r2,r3,r2
 d03e374:	1007883a 	mov	r3,r2
 d03e378:	e0bff217 	ldw	r2,-56(fp)
 d03e37c:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 d03e380:	e0bffa17 	ldw	r2,-24(fp)
 d03e384:	10c00617 	ldw	r3,24(r2)
 d03e388:	e0bff217 	ldw	r2,-56(fp)
 d03e38c:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 d03e390:	e0bffa17 	ldw	r2,-24(fp)
 d03e394:	10c00717 	ldw	r3,28(r2)
 d03e398:	e0bff217 	ldw	r2,-56(fp)
 d03e39c:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 d03e3a0:	e0fff217 	ldw	r3,-56(fp)
 d03e3a4:	00820004 	movi	r2,2048
 d03e3a8:	1880080d 	sth	r2,32(r3)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 d03e3ac:	e0bff217 	ldw	r2,-56(fp)
 d03e3b0:	10800317 	ldw	r2,12(r2)
 d03e3b4:	e0bff115 	stw	r2,-60(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 d03e3b8:	e0bff217 	ldw	r2,-56(fp)
 d03e3bc:	10800417 	ldw	r2,16(r2)
 d03e3c0:	1004d23a 	srli	r2,r2,8
 d03e3c4:	10803fcc 	andi	r2,r2,255
 d03e3c8:	1009883a 	mov	r4,r2
 d03e3cc:	e0bff217 	ldw	r2,-56(fp)
 d03e3d0:	10800417 	ldw	r2,16(r2)
 d03e3d4:	1004923a 	slli	r2,r2,8
 d03e3d8:	1007883a 	mov	r3,r2
 d03e3dc:	00bfc004 	movi	r2,-256
 d03e3e0:	1884703a 	and	r2,r3,r2
 d03e3e4:	2084b03a 	or	r2,r4,r2
 d03e3e8:	1007883a 	mov	r3,r2
 d03e3ec:	e0bff117 	ldw	r2,-60(fp)
 d03e3f0:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 d03e3f4:	e13ff38b 	ldhu	r4,-50(fp)
 d03e3f8:	e0fff70b 	ldhu	r3,-36(fp)
 d03e3fc:	e0bff48b 	ldhu	r2,-46(fp)
 d03e400:	1885383a 	mul	r2,r3,r2
 d03e404:	2085883a 	add	r2,r4,r2
 d03e408:	1005d2fa 	srai	r2,r2,11
 d03e40c:	10803fcc 	andi	r2,r2,255
 d03e410:	100b883a 	mov	r5,r2
 d03e414:	e13ff38b 	ldhu	r4,-50(fp)
 d03e418:	e0fff70b 	ldhu	r3,-36(fp)
 d03e41c:	e0bff48b 	ldhu	r2,-46(fp)
 d03e420:	1885383a 	mul	r2,r3,r2
 d03e424:	2085883a 	add	r2,r4,r2
 d03e428:	1005d0fa 	srai	r2,r2,3
 d03e42c:	1004923a 	slli	r2,r2,8
 d03e430:	1007883a 	mov	r3,r2
 d03e434:	00bfc004 	movi	r2,-256
 d03e438:	1884703a 	and	r2,r3,r2
 d03e43c:	2884b03a 	or	r2,r5,r2
 d03e440:	1007883a 	mov	r3,r2
 d03e444:	e0bff117 	ldw	r2,-60(fp)
 d03e448:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 d03e44c:	e0fff48b 	ldhu	r3,-46(fp)
 d03e450:	e0bff50b 	ldhu	r2,-44(fp)
 d03e454:	10bfffc4 	addi	r2,r2,-1
 d03e458:	1880070e 	bge	r3,r2,d03e478 <ip_fragment+0x4fc>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 d03e45c:	e0bff117 	ldw	r2,-60(fp)
 d03e460:	1080018b 	ldhu	r2,6(r2)
 d03e464:	10800814 	ori	r2,r2,32
 d03e468:	1007883a 	mov	r3,r2
 d03e46c:	e0bff117 	ldw	r2,-60(fp)
 d03e470:	10c0018d 	sth	r3,6(r2)
 d03e474:	00000906 	br	d03e49c <ip_fragment+0x520>
         }
         else
         {
            if (parent_mf)
 d03e478:	e0bff30b 	ldhu	r2,-52(fp)
 d03e47c:	1005003a 	cmpeq	r2,r2,zero
 d03e480:	1000061e 	bne	r2,zero,d03e49c <ip_fragment+0x520>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 d03e484:	e0bff117 	ldw	r2,-60(fp)
 d03e488:	1080018b 	ldhu	r2,6(r2)
 d03e48c:	10800814 	ori	r2,r2,32
 d03e490:	1007883a 	mov	r3,r2
 d03e494:	e0bff117 	ldw	r2,-60(fp)
 d03e498:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 d03e49c:	e0bff117 	ldw	r2,-60(fp)
 d03e4a0:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 d03e4a4:	e0bff7c3 	ldbu	r2,-33(fp)
 d03e4a8:	1004d07a 	srli	r2,r2,1
 d03e4ac:	11403fcc 	andi	r5,r2,255
 d03e4b0:	e13ff117 	ldw	r4,-60(fp)
 d03e4b4:	d0242340 	call	d024234 <cksum>
 d03e4b8:	0084303a 	nor	r2,zero,r2
 d03e4bc:	1007883a 	mov	r3,r2
 d03e4c0:	e0bff117 	ldw	r2,-60(fp)
 d03e4c4:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 d03e4c8:	008341b4 	movhi	r2,3334
 d03e4cc:	10b4eb04 	addi	r2,r2,-11348
 d03e4d0:	10801217 	ldw	r2,72(r2)
 d03e4d4:	10c00044 	addi	r3,r2,1
 d03e4d8:	008341b4 	movhi	r2,3334
 d03e4dc:	10b4eb04 	addi	r2,r2,-11348
 d03e4e0:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 d03e4e4:	e13ff217 	ldw	r4,-56(fp)
 d03e4e8:	e17ffb17 	ldw	r5,-20(fp)
 d03e4ec:	d021fd40 	call	d021fd4 <ip2mac>
 d03e4f0:	e0bff015 	stw	r2,-64(fp)
         if (e < 0)
 d03e4f4:	e0bff017 	ldw	r2,-64(fp)
 d03e4f8:	1004403a 	cmpge	r2,r2,zero
 d03e4fc:	1000101e 	bne	r2,zero,d03e540 <ip_fragment+0x5c4>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d03e500:	01000084 	movi	r4,2
 d03e504:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free(p);
 d03e508:	e13ffa17 	ldw	r4,-24(fp)
 d03e50c:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03e510:	01000084 	movi	r4,2
 d03e514:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 d03e518:	008341b4 	movhi	r2,3334
 d03e51c:	10b4eb04 	addi	r2,r2,-11348
 d03e520:	10801117 	ldw	r2,68(r2)
 d03e524:	10c00044 	addi	r3,r2,1
 d03e528:	008341b4 	movhi	r2,3334
 d03e52c:	10b4eb04 	addi	r2,r2,-11348
 d03e530:	10c01115 	stw	r3,68(r2)
            return e;
 d03e534:	e0bff017 	ldw	r2,-64(fp)
 d03e538:	e0bffe15 	stw	r2,-8(fp)
 d03e53c:	00001406 	br	d03e590 <ip_fragment+0x614>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 d03e540:	e0bff48b 	ldhu	r2,-46(fp)
 d03e544:	10800044 	addi	r2,r2,1
 d03e548:	e0bff48d 	sth	r2,-46(fp)
 d03e54c:	e0fff48b 	ldhu	r3,-46(fp)
 d03e550:	e0bff50b 	ldhu	r2,-44(fp)
 d03e554:	18bf3136 	bltu	r3,r2,d03e21c <ip_fragment+0x2a0>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d03e558:	01000084 	movi	r4,2
 d03e55c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free(p);
 d03e560:	e13ffa17 	ldw	r4,-24(fp)
 d03e564:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03e568:	01000084 	movi	r4,2
 d03e56c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 d03e570:	008341b4 	movhi	r2,3334
 d03e574:	10b4eb04 	addi	r2,r2,-11348
 d03e578:	10801017 	ldw	r2,64(r2)
 d03e57c:	10c00044 	addi	r3,r2,1
 d03e580:	008341b4 	movhi	r2,3334
 d03e584:	10b4eb04 	addi	r2,r2,-11348
 d03e588:	10c01015 	stw	r3,64(r2)

   return 0;
 d03e58c:	e03ffe15 	stw	zero,-8(fp)
 d03e590:	e0bffe17 	ldw	r2,-8(fp)
}
 d03e594:	e037883a 	mov	sp,fp
 d03e598:	dfc00117 	ldw	ra,4(sp)
 d03e59c:	df000017 	ldw	fp,0(sp)
 d03e5a0:	dec00204 	addi	sp,sp,8
 d03e5a4:	f800283a 	ret

0d03e5a8 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 d03e5a8:	defff904 	addi	sp,sp,-28
 d03e5ac:	dfc00615 	stw	ra,24(sp)
 d03e5b0:	df000515 	stw	fp,20(sp)
 d03e5b4:	df000504 	addi	fp,sp,20
 d03e5b8:	e13ffe15 	stw	r4,-8(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 d03e5bc:	e17ffd04 	addi	r5,fp,-12
 d03e5c0:	e13ffe17 	ldw	r4,-8(fp)
 d03e5c4:	d03e90c0 	call	d03e90c <iproute>
 d03e5c8:	e0bffc15 	stw	r2,-16(fp)
   if (tnet == 0)
 d03e5cc:	e0bffc17 	ldw	r2,-16(fp)
 d03e5d0:	1004c03a 	cmpne	r2,r2,zero
 d03e5d4:	1000161e 	bne	r2,zero,d03e630 <ip_mymach+0x88>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 d03e5d8:	00834174 	movhi	r2,3333
 d03e5dc:	108aa404 	addi	r2,r2,10896
 d03e5e0:	10800017 	ldw	r2,0(r2)
 d03e5e4:	1080050c 	andi	r2,r2,20
 d03e5e8:	1005003a 	cmpeq	r2,r2,zero
 d03e5ec:	10000e1e 	bne	r2,zero,d03e628 <ip_mymach+0x80>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 d03e5f0:	e0bffe17 	ldw	r2,-8(fp)
 d03e5f4:	11403fcc 	andi	r5,r2,255
 d03e5f8:	e0bffe17 	ldw	r2,-8(fp)
 d03e5fc:	1004d23a 	srli	r2,r2,8
 d03e600:	11803fcc 	andi	r6,r2,255
 d03e604:	e0bffe17 	ldw	r2,-8(fp)
 d03e608:	1004d43a 	srli	r2,r2,16
 d03e60c:	11c03fcc 	andi	r7,r2,255
 d03e610:	e0bffe17 	ldw	r2,-8(fp)
 d03e614:	1004d63a 	srli	r2,r2,24
 d03e618:	d8800015 	stw	r2,0(sp)
 d03e61c:	01034174 	movhi	r4,3333
 d03e620:	213f0204 	addi	r4,r4,-1016
 d03e624:	d0029980 	call	d002998 <printf>
#endif   /* NPDEBUG */
      return 0L;
 d03e628:	e03fff15 	stw	zero,-4(fp)
 d03e62c:	00000306 	br	d03e63c <ip_mymach+0x94>
   }
   return tnet->n_ipaddr;
 d03e630:	e0bffc17 	ldw	r2,-16(fp)
 d03e634:	10800a17 	ldw	r2,40(r2)
 d03e638:	e0bfff15 	stw	r2,-4(fp)
 d03e63c:	e0bfff17 	ldw	r2,-4(fp)
#endif /* MULTI_HOMED */
}
 d03e640:	e037883a 	mov	sp,fp
 d03e644:	dfc00117 	ldw	ra,4(sp)
 d03e648:	df000017 	ldw	fp,0(sp)
 d03e64c:	dec00204 	addi	sp,sp,8
 d03e650:	f800283a 	ret

0d03e654 <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 d03e654:	defff204 	addi	sp,sp,-56
 d03e658:	dfc00d15 	stw	ra,52(sp)
 d03e65c:	df000c15 	stw	fp,48(sp)
 d03e660:	df000c04 	addi	fp,sp,48
 d03e664:	e13ffa15 	stw	r4,-24(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 d03e668:	e0bffa17 	ldw	r2,-24(fp)
 d03e66c:	10800317 	ldw	r2,12(r2)
 d03e670:	e0bff915 	stw	r2,-28(fp)
   osum = pip->ip_chksum;
 d03e674:	e0bff917 	ldw	r2,-28(fp)
 d03e678:	1080028b 	ldhu	r2,10(r2)
 d03e67c:	e0bff70d 	sth	r2,-36(fp)
   pip->ip_chksum = 0;
 d03e680:	e0bff917 	ldw	r2,-28(fp)
 d03e684:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 d03e688:	e0bff917 	ldw	r2,-28(fp)
 d03e68c:	10800003 	ldbu	r2,0(r2)
 d03e690:	10803fcc 	andi	r2,r2,255
 d03e694:	108003cc 	andi	r2,r2,15
 d03e698:	1085883a 	add	r2,r2,r2
 d03e69c:	1085883a 	add	r2,r2,r2
 d03e6a0:	1005d07a 	srai	r2,r2,1
 d03e6a4:	100b883a 	mov	r5,r2
 d03e6a8:	e13ff917 	ldw	r4,-28(fp)
 d03e6ac:	d0242340 	call	d024234 <cksum>
 d03e6b0:	0084303a 	nor	r2,zero,r2
 d03e6b4:	e0bff78d 	sth	r2,-34(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 d03e6b8:	e0fff70b 	ldhu	r3,-36(fp)
 d03e6bc:	e0bff78b 	ldhu	r2,-34(fp)
 d03e6c0:	18800126 	beq	r3,r2,d03e6c8 <ip_dump+0x74>
   {
      dtrap();
 d03e6c4:	d0293e80 	call	d0293e8 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 d03e6c8:	0009883a 	mov	r4,zero
 d03e6cc:	01434174 	movhi	r5,3333
 d03e6d0:	297f0b04 	addi	r5,r5,-980
 d03e6d4:	d02486c0 	call	d02486c <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 d03e6d8:	e0bff917 	ldw	r2,-28(fp)
 d03e6dc:	e0bff815 	stw	r2,-32(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 d03e6e0:	e0bff817 	ldw	r2,-32(fp)
 d03e6e4:	10800003 	ldbu	r2,0(r2)
 d03e6e8:	11803fcc 	andi	r6,r2,255
 d03e6ec:	e0bff817 	ldw	r2,-32(fp)
 d03e6f0:	10800044 	addi	r2,r2,1
 d03e6f4:	10800003 	ldbu	r2,0(r2)
 d03e6f8:	11c03fcc 	andi	r7,r2,255
 d03e6fc:	e0bff917 	ldw	r2,-28(fp)
 d03e700:	1080008b 	ldhu	r2,2(r2)
 d03e704:	10bfffcc 	andi	r2,r2,65535
 d03e708:	1004d23a 	srli	r2,r2,8
 d03e70c:	10bfffcc 	andi	r2,r2,65535
 d03e710:	10c03fcc 	andi	r3,r2,255
 d03e714:	e0bff917 	ldw	r2,-28(fp)
 d03e718:	1080008b 	ldhu	r2,2(r2)
 d03e71c:	10bfffcc 	andi	r2,r2,65535
 d03e720:	1004923a 	slli	r2,r2,8
 d03e724:	10bfc00c 	andi	r2,r2,65280
 d03e728:	1888b03a 	or	r4,r3,r2
 d03e72c:	e0bff917 	ldw	r2,-28(fp)
 d03e730:	1080010b 	ldhu	r2,4(r2)
 d03e734:	10bfffcc 	andi	r2,r2,65535
 d03e738:	1004d23a 	srli	r2,r2,8
 d03e73c:	10bfffcc 	andi	r2,r2,65535
 d03e740:	10c03fcc 	andi	r3,r2,255
 d03e744:	e0bff917 	ldw	r2,-28(fp)
 d03e748:	1080010b 	ldhu	r2,4(r2)
 d03e74c:	10bfffcc 	andi	r2,r2,65535
 d03e750:	1004923a 	slli	r2,r2,8
 d03e754:	10bfc00c 	andi	r2,r2,65280
 d03e758:	1884b03a 	or	r2,r3,r2
 d03e75c:	d9000015 	stw	r4,0(sp)
 d03e760:	d8800115 	stw	r2,4(sp)
 d03e764:	0009883a 	mov	r4,zero
 d03e768:	01434174 	movhi	r5,3333
 d03e76c:	297f1004 	addi	r5,r5,-960
 d03e770:	d02486c0 	call	d02486c <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 d03e774:	e0bff817 	ldw	r2,-32(fp)
 d03e778:	10800184 	addi	r2,r2,6
 d03e77c:	1080000b 	ldhu	r2,0(r2)
 d03e780:	10bfffcc 	andi	r2,r2,65535
 d03e784:	1004d23a 	srli	r2,r2,8
 d03e788:	10bfffcc 	andi	r2,r2,65535
 d03e78c:	10c03fcc 	andi	r3,r2,255
 d03e790:	e0bff817 	ldw	r2,-32(fp)
 d03e794:	10800184 	addi	r2,r2,6
 d03e798:	1080000b 	ldhu	r2,0(r2)
 d03e79c:	10bfffcc 	andi	r2,r2,65535
 d03e7a0:	1004923a 	slli	r2,r2,8
 d03e7a4:	10bfc00c 	andi	r2,r2,65280
 d03e7a8:	1886b03a 	or	r3,r3,r2
 d03e7ac:	e0ffff15 	stw	r3,-4(fp)
 d03e7b0:	e0bff917 	ldw	r2,-28(fp)
 d03e7b4:	10800203 	ldbu	r2,8(r2)
 d03e7b8:	10803fcc 	andi	r2,r2,255
 d03e7bc:	e0bffe15 	stw	r2,-8(fp)
 d03e7c0:	e0bff917 	ldw	r2,-28(fp)
 d03e7c4:	10800243 	ldbu	r2,9(r2)
 d03e7c8:	10803fcc 	andi	r2,r2,255
 d03e7cc:	e0bffd15 	stw	r2,-12(fp)
 d03e7d0:	e0bff70b 	ldhu	r2,-36(fp)
 d03e7d4:	1004d23a 	srli	r2,r2,8
 d03e7d8:	10bfffcc 	andi	r2,r2,65535
 d03e7dc:	10c03fcc 	andi	r3,r2,255
 d03e7e0:	e0bff70b 	ldhu	r2,-36(fp)
 d03e7e4:	1004923a 	slli	r2,r2,8
 d03e7e8:	10bfc00c 	andi	r2,r2,65280
 d03e7ec:	1886b03a 	or	r3,r3,r2
 d03e7f0:	e0fffc15 	stw	r3,-16(fp)
 d03e7f4:	e0fff70b 	ldhu	r3,-36(fp)
 d03e7f8:	e0bff78b 	ldhu	r2,-34(fp)
 d03e7fc:	1880041e 	bne	r3,r2,d03e810 <ip_dump+0x1bc>
 d03e800:	00834174 	movhi	r2,3333
 d03e804:	10bf1c04 	addi	r2,r2,-912
 d03e808:	e0bffb15 	stw	r2,-20(fp)
 d03e80c:	00000306 	br	d03e81c <ip_dump+0x1c8>
 d03e810:	00834174 	movhi	r2,3333
 d03e814:	10bf1d04 	addi	r2,r2,-908
 d03e818:	e0bffb15 	stw	r2,-20(fp)
 d03e81c:	e0bffd17 	ldw	r2,-12(fp)
 d03e820:	d8800015 	stw	r2,0(sp)
 d03e824:	e0bffc17 	ldw	r2,-16(fp)
 d03e828:	d8800115 	stw	r2,4(sp)
 d03e82c:	e0bffb17 	ldw	r2,-20(fp)
 d03e830:	d8800215 	stw	r2,8(sp)
 d03e834:	0009883a 	mov	r4,zero
 d03e838:	01434174 	movhi	r5,3333
 d03e83c:	297f1e04 	addi	r5,r5,-904
 d03e840:	e1bfff17 	ldw	r6,-4(fp)
 d03e844:	e1fffe17 	ldw	r7,-8(fp)
 d03e848:	d02486c0 	call	d02486c <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 d03e84c:	e0bff917 	ldw	r2,-28(fp)
 d03e850:	10800317 	ldw	r2,12(r2)
 d03e854:	11803fcc 	andi	r6,r2,255
 d03e858:	e0bff917 	ldw	r2,-28(fp)
 d03e85c:	10800317 	ldw	r2,12(r2)
 d03e860:	1004d23a 	srli	r2,r2,8
 d03e864:	11c03fcc 	andi	r7,r2,255
 d03e868:	e0bff917 	ldw	r2,-28(fp)
 d03e86c:	10800317 	ldw	r2,12(r2)
 d03e870:	1004d43a 	srli	r2,r2,16
 d03e874:	10c03fcc 	andi	r3,r2,255
 d03e878:	e0bff917 	ldw	r2,-28(fp)
 d03e87c:	10800317 	ldw	r2,12(r2)
 d03e880:	1004d63a 	srli	r2,r2,24
 d03e884:	d8c00015 	stw	r3,0(sp)
 d03e888:	d8800115 	stw	r2,4(sp)
 d03e88c:	0009883a 	mov	r4,zero
 d03e890:	01434174 	movhi	r5,3333
 d03e894:	297f2e04 	addi	r5,r5,-840
 d03e898:	d02486c0 	call	d02486c <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 d03e89c:	e0bff917 	ldw	r2,-28(fp)
 d03e8a0:	10800417 	ldw	r2,16(r2)
 d03e8a4:	11803fcc 	andi	r6,r2,255
 d03e8a8:	e0bff917 	ldw	r2,-28(fp)
 d03e8ac:	10800417 	ldw	r2,16(r2)
 d03e8b0:	1004d23a 	srli	r2,r2,8
 d03e8b4:	11c03fcc 	andi	r7,r2,255
 d03e8b8:	e0bff917 	ldw	r2,-28(fp)
 d03e8bc:	10800417 	ldw	r2,16(r2)
 d03e8c0:	1004d43a 	srli	r2,r2,16
 d03e8c4:	10c03fcc 	andi	r3,r2,255
 d03e8c8:	e0bff917 	ldw	r2,-28(fp)
 d03e8cc:	10800417 	ldw	r2,16(r2)
 d03e8d0:	1004d63a 	srli	r2,r2,24
 d03e8d4:	d8c00015 	stw	r3,0(sp)
 d03e8d8:	d8800115 	stw	r2,4(sp)
 d03e8dc:	0009883a 	mov	r4,zero
 d03e8e0:	01434174 	movhi	r5,3333
 d03e8e4:	297f3304 	addi	r5,r5,-820
 d03e8e8:	d02486c0 	call	d02486c <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 d03e8ec:	e0fff917 	ldw	r3,-28(fp)
 d03e8f0:	e0bff70b 	ldhu	r2,-36(fp)
 d03e8f4:	1880028d 	sth	r2,10(r3)
}
 d03e8f8:	e037883a 	mov	sp,fp
 d03e8fc:	dfc00117 	ldw	ra,4(sp)
 d03e900:	df000017 	ldw	fp,0(sp)
 d03e904:	dec00204 	addi	sp,sp,8
 d03e908:	f800283a 	ret

0d03e90c <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 d03e90c:	defff704 	addi	sp,sp,-36
 d03e910:	dfc00815 	stw	ra,32(sp)
 d03e914:	df000715 	stw	fp,28(sp)
 d03e918:	df000704 	addi	fp,sp,28
 d03e91c:	e13ffd15 	stw	r4,-12(fp)
 d03e920:	e17ffe15 	stw	r5,-8(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 d03e924:	e0bffd17 	ldw	r2,-12(fp)
 d03e928:	1004c03a 	cmpne	r2,r2,zero
 d03e92c:	1000021e 	bne	r2,zero,d03e938 <iproute+0x2c>
      return NULL;
 d03e930:	e03fff15 	stw	zero,-4(fp)
 d03e934:	00008a06 	br	d03eb60 <iproute+0x254>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 d03e938:	d0a0c617 	ldw	r2,-31976(gp)
 d03e93c:	1004c03a 	cmpne	r2,r2,zero
 d03e940:	1000021e 	bne	r2,zero,d03e94c <iproute+0x40>
      return NULL;
 d03e944:	e03fff15 	stw	zero,-4(fp)
 d03e948:	00008506 	br	d03eb60 <iproute+0x254>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 d03e94c:	00834174 	movhi	r2,3333
 d03e950:	108af104 	addi	r2,r2,11204
 d03e954:	10800017 	ldw	r2,0(r2)
 d03e958:	1005003a 	cmpeq	r2,r2,zero
 d03e95c:	1000191e 	bne	r2,zero,d03e9c4 <iproute+0xb8>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 d03e960:	00834174 	movhi	r2,3333
 d03e964:	108af104 	addi	r2,r2,11204
 d03e968:	10800017 	ldw	r2,0(r2)
 d03e96c:	10c00017 	ldw	r3,0(r2)
 d03e970:	e0bffd17 	ldw	r2,-12(fp)
 d03e974:	1880131e 	bne	r3,r2,d03e9c4 <iproute+0xb8>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 d03e978:	00834174 	movhi	r2,3333
 d03e97c:	108af104 	addi	r2,r2,11204
 d03e980:	10800017 	ldw	r2,0(r2)
 d03e984:	10c00617 	ldw	r3,24(r2)
 d03e988:	e0bffe17 	ldw	r2,-8(fp)
 d03e98c:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 d03e990:	00834174 	movhi	r2,3333
 d03e994:	108af104 	addi	r2,r2,11204
 d03e998:	10c00017 	ldw	r3,0(r2)
 d03e99c:	00834174 	movhi	r2,3333
 d03e9a0:	108ac904 	addi	r2,r2,11044
 d03e9a4:	10800017 	ldw	r2,0(r2)
 d03e9a8:	18800915 	stw	r2,36(r3)
         return(cachedRoute->ifp); /* net to send on */
 d03e9ac:	00834174 	movhi	r2,3333
 d03e9b0:	108af104 	addi	r2,r2,11204
 d03e9b4:	10800017 	ldw	r2,0(r2)
 d03e9b8:	10800e17 	ldw	r2,56(r2)
 d03e9bc:	e0bfff15 	stw	r2,-4(fp)
 d03e9c0:	00006706 	br	d03eb60 <iproute+0x254>
      }
   }

   rtp = rt_lookup(host);
 d03e9c4:	e13ffd17 	ldw	r4,-12(fp)
 d03e9c8:	d0421a00 	call	d0421a0 <rt_lookup>
 d03e9cc:	e0bffa15 	stw	r2,-24(fp)
   if(rtp)
 d03e9d0:	e0bffa17 	ldw	r2,-24(fp)
 d03e9d4:	1005003a 	cmpeq	r2,r2,zero
 d03e9d8:	10000c1e 	bne	r2,zero,d03ea0c <iproute+0x100>
   {
      cachedRoute = rtp;
 d03e9dc:	00c34174 	movhi	r3,3333
 d03e9e0:	18caf104 	addi	r3,r3,11204
 d03e9e4:	e0bffa17 	ldw	r2,-24(fp)
 d03e9e8:	18800015 	stw	r2,0(r3)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 d03e9ec:	e0bffa17 	ldw	r2,-24(fp)
 d03e9f0:	10c00617 	ldw	r3,24(r2)
 d03e9f4:	e0bffe17 	ldw	r2,-8(fp)
 d03e9f8:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 d03e9fc:	e0bffa17 	ldw	r2,-24(fp)
 d03ea00:	10800e17 	ldw	r2,56(r2)
 d03ea04:	e0bfff15 	stw	r2,-4(fp)
 d03ea08:	00005506 	br	d03eb60 <iproute+0x254>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 d03ea0c:	008341b4 	movhi	r2,3334
 d03ea10:	10b4e604 	addi	r2,r2,-11368
 d03ea14:	10800017 	ldw	r2,0(r2)
 d03ea18:	e0bffb15 	stw	r2,-20(fp)
   i = 0;
 d03ea1c:	e03ffc15 	stw	zero,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 d03ea20:	00002f06 	br	d03eae0 <iproute+0x1d4>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 d03ea24:	e0bffb17 	ldw	r2,-20(fp)
 d03ea28:	10800c17 	ldw	r2,48(r2)
 d03ea2c:	1005003a 	cmpeq	r2,r2,zero
 d03ea30:	1000251e 	bne	r2,zero,d03eac8 <iproute+0x1bc>
 d03ea34:	e0bffb17 	ldw	r2,-20(fp)
 d03ea38:	10800a17 	ldw	r2,40(r2)
 d03ea3c:	1005003a 	cmpeq	r2,r2,zero
 d03ea40:	1000211e 	bne	r2,zero,d03eac8 <iproute+0x1bc>
 d03ea44:	e0bffb17 	ldw	r2,-20(fp)
 d03ea48:	10c00a17 	ldw	r3,40(r2)
 d03ea4c:	e0bffb17 	ldw	r2,-20(fp)
 d03ea50:	10800c17 	ldw	r2,48(r2)
 d03ea54:	1888703a 	and	r4,r3,r2
 d03ea58:	e0bffb17 	ldw	r2,-20(fp)
 d03ea5c:	10c00c17 	ldw	r3,48(r2)
 d03ea60:	e0bffd17 	ldw	r2,-12(fp)
 d03ea64:	1884703a 	and	r2,r3,r2
 d03ea68:	2080171e 	bne	r4,r2,d03eac8 <iproute+0x1bc>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 d03ea6c:	00800044 	movi	r2,1
 d03ea70:	d8800015 	stw	r2,0(sp)
 d03ea74:	e13ffd17 	ldw	r4,-12(fp)
 d03ea78:	017fffc4 	movi	r5,-1
 d03ea7c:	e1bffd17 	ldw	r6,-12(fp)
 d03ea80:	e1fffc17 	ldw	r7,-16(fp)
 d03ea84:	d0423240 	call	d042324 <add_route>
 d03ea88:	1007883a 	mov	r3,r2
 d03ea8c:	00834174 	movhi	r2,3333
 d03ea90:	108af104 	addi	r2,r2,11204
 d03ea94:	10c00015 	stw	r3,0(r2)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 d03ea98:	00834174 	movhi	r2,3333
 d03ea9c:	108af104 	addi	r2,r2,11204
 d03eaa0:	10800017 	ldw	r2,0(r2)
 d03eaa4:	1004c03a 	cmpne	r2,r2,zero
 d03eaa8:	1000011e 	bne	r2,zero,d03eab0 <iproute+0x1a4>
            dtrap();
 d03eaac:	d0293e80 	call	d0293e8 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 d03eab0:	e0fffe17 	ldw	r3,-8(fp)
 d03eab4:	e0bffd17 	ldw	r2,-12(fp)
 d03eab8:	18800015 	stw	r2,0(r3)
         return ifp;
 d03eabc:	e0bffb17 	ldw	r2,-20(fp)
 d03eac0:	e0bfff15 	stw	r2,-4(fp)
 d03eac4:	00002606 	br	d03eb60 <iproute+0x254>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 d03eac8:	e0bffb17 	ldw	r2,-20(fp)
 d03eacc:	10800017 	ldw	r2,0(r2)
 d03ead0:	e0bffb15 	stw	r2,-20(fp)
 d03ead4:	e0bffc17 	ldw	r2,-16(fp)
 d03ead8:	10800044 	addi	r2,r2,1
 d03eadc:	e0bffc15 	stw	r2,-16(fp)
 d03eae0:	e0bffb17 	ldw	r2,-20(fp)
 d03eae4:	1004c03a 	cmpne	r2,r2,zero
 d03eae8:	103fce1e 	bne	r2,zero,d03ea24 <iproute+0x118>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 d03eaec:	008341b4 	movhi	r2,3334
 d03eaf0:	10b4e604 	addi	r2,r2,-11368
 d03eaf4:	10800017 	ldw	r2,0(r2)
 d03eaf8:	e0bffb15 	stw	r2,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 d03eafc:	00000e06 	br	d03eb38 <iproute+0x22c>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 d03eb00:	e0bffb17 	ldw	r2,-20(fp)
 d03eb04:	10800d17 	ldw	r2,52(r2)
 d03eb08:	1005003a 	cmpeq	r2,r2,zero
 d03eb0c:	1000071e 	bne	r2,zero,d03eb2c <iproute+0x220>
      {
         *hop1 = ifp->n_defgw;
 d03eb10:	e0bffb17 	ldw	r2,-20(fp)
 d03eb14:	10c00d17 	ldw	r3,52(r2)
 d03eb18:	e0bffe17 	ldw	r2,-8(fp)
 d03eb1c:	10c00015 	stw	r3,0(r2)
         return ifp;
 d03eb20:	e0bffb17 	ldw	r2,-20(fp)
 d03eb24:	e0bfff15 	stw	r2,-4(fp)
 d03eb28:	00000d06 	br	d03eb60 <iproute+0x254>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 d03eb2c:	e0bffb17 	ldw	r2,-20(fp)
 d03eb30:	10800017 	ldw	r2,0(r2)
 d03eb34:	e0bffb15 	stw	r2,-20(fp)
 d03eb38:	e0bffb17 	ldw	r2,-20(fp)
 d03eb3c:	1004c03a 	cmpne	r2,r2,zero
 d03eb40:	103fef1e 	bne	r2,zero,d03eb00 <iproute+0x1f4>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 d03eb44:	e0fffe17 	ldw	r3,-8(fp)
 d03eb48:	e0bffd17 	ldw	r2,-12(fp)
 d03eb4c:	18800015 	stw	r2,0(r3)
   return((NET)(netlist.q_head));
 d03eb50:	008341b4 	movhi	r2,3334
 d03eb54:	10b4e604 	addi	r2,r2,-11368
 d03eb58:	10800017 	ldw	r2,0(r2)
 d03eb5c:	e0bfff15 	stw	r2,-4(fp)
 d03eb60:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* STRICT_SUBNETTING */
}
 d03eb64:	e037883a 	mov	sp,fp
 d03eb68:	dfc00117 	ldw	ra,4(sp)
 d03eb6c:	df000017 	ldw	fp,0(sp)
 d03eb70:	dec00204 	addi	sp,sp,8
 d03eb74:	f800283a 	ret

0d03eb78 <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 d03eb78:	defffa04 	addi	sp,sp,-24
 d03eb7c:	dfc00515 	stw	ra,20(sp)
 d03eb80:	df000415 	stw	fp,16(sp)
 d03eb84:	df000404 	addi	fp,sp,16
 d03eb88:	e13ffe15 	stw	r4,-8(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 d03eb8c:	e0bffe17 	ldw	r2,-8(fp)
 d03eb90:	11000417 	ldw	r4,16(r2)
 d03eb94:	e0bffe17 	ldw	r2,-8(fp)
 d03eb98:	10800317 	ldw	r2,12(r2)
 d03eb9c:	1007883a 	mov	r3,r2
 d03eba0:	e0bffe17 	ldw	r2,-8(fp)
 d03eba4:	10800117 	ldw	r2,4(r2)
 d03eba8:	1885c83a 	sub	r2,r3,r2
 d03ebac:	2085883a 	add	r2,r4,r2
 d03ebb0:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d03ebb4:	01000084 	movi	r4,2
 d03ebb8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 d03ebbc:	e13ffc17 	ldw	r4,-16(fp)
 d03ebc0:	d0287a40 	call	d0287a4 <pk_alloc>
 d03ebc4:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d03ebc8:	01000084 	movi	r4,2
 d03ebcc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 d03ebd0:	e0bffd17 	ldw	r2,-12(fp)
 d03ebd4:	1004c03a 	cmpne	r2,r2,zero
 d03ebd8:	1000061e 	bne	r2,zero,d03ebf4 <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 d03ebdc:	01034174 	movhi	r4,3333
 d03ebe0:	213f3804 	addi	r4,r4,-800
 d03ebe4:	e17ffc17 	ldw	r5,-16(fp)
 d03ebe8:	d0029980 	call	d002998 <printf>
#endif
      return NULL;
 d03ebec:	e03fff15 	stw	zero,-4(fp)
 d03ebf0:	00002906 	br	d03ec98 <ip_copypkt+0x120>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 d03ebf4:	e0bffd17 	ldw	r2,-12(fp)
 d03ebf8:	11000117 	ldw	r4,4(r2)
 d03ebfc:	e0bffe17 	ldw	r2,-8(fp)
 d03ec00:	10800117 	ldw	r2,4(r2)
 d03ec04:	e0fffc17 	ldw	r3,-16(fp)
 d03ec08:	100b883a 	mov	r5,r2
 d03ec0c:	180d883a 	mov	r6,r3
 d03ec10:	d0027000 	call	d002700 <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 d03ec14:	e0bffd17 	ldw	r2,-12(fp)
 d03ec18:	11000117 	ldw	r4,4(r2)
 d03ec1c:	e0bffe17 	ldw	r2,-8(fp)
 d03ec20:	10800317 	ldw	r2,12(r2)
 d03ec24:	1007883a 	mov	r3,r2
 d03ec28:	e0bffe17 	ldw	r2,-8(fp)
 d03ec2c:	10800117 	ldw	r2,4(r2)
 d03ec30:	1885c83a 	sub	r2,r3,r2
 d03ec34:	2087883a 	add	r3,r4,r2
 d03ec38:	e0bffd17 	ldw	r2,-12(fp)
 d03ec3c:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 d03ec40:	e0bffe17 	ldw	r2,-8(fp)
 d03ec44:	10c00417 	ldw	r3,16(r2)
 d03ec48:	e0bffd17 	ldw	r2,-12(fp)
 d03ec4c:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 d03ec50:	e0bffe17 	ldw	r2,-8(fp)
 d03ec54:	10c00617 	ldw	r3,24(r2)
 d03ec58:	e0bffd17 	ldw	r2,-12(fp)
 d03ec5c:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 d03ec60:	e0bffe17 	ldw	r2,-8(fp)
 d03ec64:	10c00717 	ldw	r3,28(r2)
 d03ec68:	e0bffd17 	ldw	r2,-12(fp)
 d03ec6c:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 d03ec70:	e0bffe17 	ldw	r2,-8(fp)
 d03ec74:	10c0080b 	ldhu	r3,32(r2)
 d03ec78:	e0bffd17 	ldw	r2,-12(fp)
 d03ec7c:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 d03ec80:	e0bffe17 	ldw	r2,-8(fp)
 d03ec84:	10c00517 	ldw	r3,20(r2)
 d03ec88:	e0bffd17 	ldw	r2,-12(fp)
 d03ec8c:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 d03ec90:	e0bffd17 	ldw	r2,-12(fp)
 d03ec94:	e0bfff15 	stw	r2,-4(fp)
 d03ec98:	e0bfff17 	ldw	r2,-4(fp)
}
 d03ec9c:	e037883a 	mov	sp,fp
 d03eca0:	dfc00117 	ldw	ra,4(sp)
 d03eca4:	df000017 	ldw	fp,0(sp)
 d03eca8:	dec00204 	addi	sp,sp,8
 d03ecac:	f800283a 	ret

0d03ecb0 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 d03ecb0:	defff904 	addi	sp,sp,-28
 d03ecb4:	df000615 	stw	fp,24(sp)
 d03ecb8:	df000604 	addi	fp,sp,24
 d03ecbc:	e13ffe15 	stw	r4,-8(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 d03ecc0:	e0bffe17 	ldw	r2,-8(fp)
 d03ecc4:	10800317 	ldw	r2,12(r2)
 d03ecc8:	e0bffd15 	stw	r2,-12(fp)
   dest = pip->ip_dest;
 d03eccc:	e0bffe17 	ldw	r2,-8(fp)
 d03ecd0:	10800417 	ldw	r2,16(r2)
 d03ecd4:	e0bffc15 	stw	r2,-16(fp)
   prot = pip->ip_prot;
 d03ecd8:	e0bffe17 	ldw	r2,-8(fp)
 d03ecdc:	10800243 	ldbu	r2,9(r2)
 d03ece0:	e0bffb85 	stb	r2,-18(fp)
   id = pip->ip_id;
 d03ece4:	e0bffe17 	ldw	r2,-8(fp)
 d03ece8:	1080010b 	ldhu	r2,4(r2)
 d03ecec:	e0bffb0d 	sth	r2,-20(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d03ecf0:	d0a0c817 	ldw	r2,-31968(gp)
 d03ecf4:	e0bffa15 	stw	r2,-24(fp)
 d03ecf8:	00001806 	br	d03ed5c <ip_reasm_match_frag_with_ire+0xac>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 d03ecfc:	e0bffa17 	ldw	r2,-24(fp)
 d03ed00:	10c00117 	ldw	r3,4(r2)
 d03ed04:	e0bffd17 	ldw	r2,-12(fp)
 d03ed08:	1880111e 	bne	r3,r2,d03ed50 <ip_reasm_match_frag_with_ire+0xa0>
 d03ed0c:	e0bffa17 	ldw	r2,-24(fp)
 d03ed10:	10c00217 	ldw	r3,8(r2)
 d03ed14:	e0bffc17 	ldw	r2,-16(fp)
 d03ed18:	18800d1e 	bne	r3,r2,d03ed50 <ip_reasm_match_frag_with_ire+0xa0>
 d03ed1c:	e0bffa17 	ldw	r2,-24(fp)
 d03ed20:	10800383 	ldbu	r2,14(r2)
 d03ed24:	10c03fcc 	andi	r3,r2,255
 d03ed28:	e0bffb83 	ldbu	r2,-18(fp)
 d03ed2c:	1880081e 	bne	r3,r2,d03ed50 <ip_reasm_match_frag_with_ire+0xa0>
 d03ed30:	e0bffa17 	ldw	r2,-24(fp)
 d03ed34:	1080030b 	ldhu	r2,12(r2)
 d03ed38:	10ffffcc 	andi	r3,r2,65535
 d03ed3c:	e0bffb0b 	ldhu	r2,-20(fp)
 d03ed40:	1880031e 	bne	r3,r2,d03ed50 <ip_reasm_match_frag_with_ire+0xa0>
          (tmpp->prot == prot) && (tmpp->id == id))
         {
         return tmpp; /* we've found a match */
 d03ed44:	e0bffa17 	ldw	r2,-24(fp)
 d03ed48:	e0bfff15 	stw	r2,-4(fp)
 d03ed4c:	00000706 	br	d03ed6c <ip_reasm_match_frag_with_ire+0xbc>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d03ed50:	e0bffa17 	ldw	r2,-24(fp)
 d03ed54:	10800017 	ldw	r2,0(r2)
 d03ed58:	e0bffa15 	stw	r2,-24(fp)
 d03ed5c:	e0bffa17 	ldw	r2,-24(fp)
 d03ed60:	1004c03a 	cmpne	r2,r2,zero
 d03ed64:	103fe51e 	bne	r2,zero,d03ecfc <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 d03ed68:	e03fff15 	stw	zero,-4(fp)
 d03ed6c:	e0bfff17 	ldw	r2,-4(fp)
}
 d03ed70:	e037883a 	mov	sp,fp
 d03ed74:	df000017 	ldw	fp,0(sp)
 d03ed78:	dec00104 	addi	sp,sp,4
 d03ed7c:	f800283a 	ret

0d03ed80 <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 d03ed80:	defffc04 	addi	sp,sp,-16
 d03ed84:	df000315 	stw	fp,12(sp)
 d03ed88:	df000304 	addi	fp,sp,12
 d03ed8c:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 d03ed90:	e0bfff17 	ldw	r2,-4(fp)
 d03ed94:	1080018b 	ldhu	r2,6(r2)
 d03ed98:	10bfffcc 	andi	r2,r2,65535
 d03ed9c:	1004d23a 	srli	r2,r2,8
 d03eda0:	10bfffcc 	andi	r2,r2,65535
 d03eda4:	10c03fcc 	andi	r3,r2,255
 d03eda8:	e0bfff17 	ldw	r2,-4(fp)
 d03edac:	1080018b 	ldhu	r2,6(r2)
 d03edb0:	10bfffcc 	andi	r2,r2,65535
 d03edb4:	1004923a 	slli	r2,r2,8
 d03edb8:	10bfc00c 	andi	r2,r2,65280
 d03edbc:	1884b03a 	or	r2,r3,r2
 d03edc0:	1088000c 	andi	r2,r2,8192
 d03edc4:	1005d37a 	srai	r2,r2,13
 d03edc8:	e0bffe8d 	sth	r2,-6(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 d03edcc:	e0bfff17 	ldw	r2,-4(fp)
 d03edd0:	1080018b 	ldhu	r2,6(r2)
 d03edd4:	10bfffcc 	andi	r2,r2,65535
 d03edd8:	1004d23a 	srli	r2,r2,8
 d03eddc:	10803fcc 	andi	r2,r2,255
 d03ede0:	1009883a 	mov	r4,r2
 d03ede4:	e0bfff17 	ldw	r2,-4(fp)
 d03ede8:	1080018b 	ldhu	r2,6(r2)
 d03edec:	10bfffcc 	andi	r2,r2,65535
 d03edf0:	1004923a 	slli	r2,r2,8
 d03edf4:	1007883a 	mov	r3,r2
 d03edf8:	00bfc004 	movi	r2,-256
 d03edfc:	1884703a 	and	r2,r3,r2
 d03ee00:	2084b03a 	or	r2,r4,r2
 d03ee04:	1087ffcc 	andi	r2,r2,8191
 d03ee08:	e0bffe0d 	sth	r2,-8(fp)

  if (mf == 0)
 d03ee0c:	e0bffe8b 	ldhu	r2,-6(fp)
 d03ee10:	1004c03a 	cmpne	r2,r2,zero
 d03ee14:	1000081e 	bne	r2,zero,d03ee38 <ip_reasm_determine_type_of_frag+0xb8>
     {
     if (foff == 0) {rc = IP_CP;}
 d03ee18:	e0bffe0b 	ldhu	r2,-8(fp)
 d03ee1c:	1004c03a 	cmpne	r2,r2,zero
 d03ee20:	1000021e 	bne	r2,zero,d03ee2c <ip_reasm_determine_type_of_frag+0xac>
 d03ee24:	e03ffd15 	stw	zero,-12(fp)
 d03ee28:	00000b06 	br	d03ee58 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_LF;}
 d03ee2c:	00800144 	movi	r2,5
 d03ee30:	e0bffd15 	stw	r2,-12(fp)
 d03ee34:	00000806 	br	d03ee58 <ip_reasm_determine_type_of_frag+0xd8>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 d03ee38:	e0bffe0b 	ldhu	r2,-8(fp)
 d03ee3c:	1004c03a 	cmpne	r2,r2,zero
 d03ee40:	1000031e 	bne	r2,zero,d03ee50 <ip_reasm_determine_type_of_frag+0xd0>
 d03ee44:	00800044 	movi	r2,1
 d03ee48:	e0bffd15 	stw	r2,-12(fp)
 d03ee4c:	00000206 	br	d03ee58 <ip_reasm_determine_type_of_frag+0xd8>
     else {rc = IP_MF;}
 d03ee50:	008000c4 	movi	r2,3
 d03ee54:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 d03ee58:	e0bffd17 	ldw	r2,-12(fp)
}
 d03ee5c:	e037883a 	mov	sp,fp
 d03ee60:	df000017 	ldw	fp,0(sp)
 d03ee64:	dec00104 	addi	sp,sp,4
 d03ee68:	f800283a 	ret

0d03ee6c <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 d03ee6c:	defffd04 	addi	sp,sp,-12
 d03ee70:	df000215 	stw	fp,8(sp)
 d03ee74:	df000204 	addi	fp,sp,8
 d03ee78:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 d03ee7c:	d0e0c717 	ldw	r3,-31972(gp)
 d03ee80:	008001b4 	movhi	r2,6
 d03ee84:	10c0072e 	bgeu	r2,r3,d03eea4 <ip_reasm_check_mem_useage+0x38>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 d03ee88:	008341b4 	movhi	r2,3334
 d03ee8c:	10b4ff04 	addi	r2,r2,-11268
 d03ee90:	10800217 	ldw	r2,8(r2)
 d03ee94:	10c00044 	addi	r3,r2,1
 d03ee98:	008341b4 	movhi	r2,3334
 d03ee9c:	10b4ff04 	addi	r2,r2,-11268
 d03eea0:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 d03eea4:	d0e0c717 	ldw	r3,-31972(gp)
 d03eea8:	008001b4 	movhi	r2,6
 d03eeac:	18800526 	beq	r3,r2,d03eec4 <ip_reasm_check_mem_useage+0x58>
 d03eeb0:	e0fffe0b 	ldhu	r3,-8(fp)
 d03eeb4:	d0a0c717 	ldw	r2,-31972(gp)
 d03eeb8:	1887883a 	add	r3,r3,r2
 d03eebc:	008001b4 	movhi	r2,6
 d03eec0:	10c00a2e 	bgeu	r2,r3,d03eeec <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 d03eec4:	008341b4 	movhi	r2,3334
 d03eec8:	10b4ff04 	addi	r2,r2,-11268
 d03eecc:	10800317 	ldw	r2,12(r2)
 d03eed0:	10c00044 	addi	r3,r2,1
 d03eed4:	008341b4 	movhi	r2,3334
 d03eed8:	10b4ff04 	addi	r2,r2,-11268
 d03eedc:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 d03eee0:	00bffa84 	movi	r2,-22
 d03eee4:	e0bfff15 	stw	r2,-4(fp)
 d03eee8:	00000106 	br	d03eef0 <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 d03eeec:	e03fff15 	stw	zero,-4(fp)
 d03eef0:	e0bfff17 	ldw	r2,-4(fp)
}
 d03eef4:	e037883a 	mov	sp,fp
 d03eef8:	df000017 	ldw	fp,0(sp)
 d03eefc:	dec00104 	addi	sp,sp,4
 d03ef00:	f800283a 	ret

0d03ef04 <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 d03ef04:	defffd04 	addi	sp,sp,-12
 d03ef08:	df000215 	stw	fp,8(sp)
 d03ef0c:	df000204 	addi	fp,sp,8
 d03ef10:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 d03ef14:	d0e0c717 	ldw	r3,-31972(gp)
 d03ef18:	008001b4 	movhi	r2,6
 d03ef1c:	10c00a2e 	bgeu	r2,r3,d03ef48 <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 d03ef20:	008341b4 	movhi	r2,3334
 d03ef24:	10b4ff04 	addi	r2,r2,-11268
 d03ef28:	10800217 	ldw	r2,8(r2)
 d03ef2c:	10c00044 	addi	r3,r2,1
 d03ef30:	008341b4 	movhi	r2,3334
 d03ef34:	10b4ff04 	addi	r2,r2,-11268
 d03ef38:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 d03ef3c:	00bffa84 	movi	r2,-22
 d03ef40:	e0bfff15 	stw	r2,-4(fp)
 d03ef44:	00001406 	br	d03ef98 <ip_reasm_incr_mem_useage+0x94>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 d03ef48:	e0fffe0b 	ldhu	r3,-8(fp)
 d03ef4c:	d0a0c717 	ldw	r2,-31972(gp)
 d03ef50:	1887883a 	add	r3,r3,r2
 d03ef54:	008001b4 	movhi	r2,6
 d03ef58:	10c00a2e 	bgeu	r2,r3,d03ef84 <ip_reasm_incr_mem_useage+0x80>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 d03ef5c:	008341b4 	movhi	r2,3334
 d03ef60:	10b4ff04 	addi	r2,r2,-11268
 d03ef64:	10800417 	ldw	r2,16(r2)
 d03ef68:	10c00044 	addi	r3,r2,1
 d03ef6c:	008341b4 	movhi	r2,3334
 d03ef70:	10b4ff04 	addi	r2,r2,-11268
 d03ef74:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 d03ef78:	00bffa84 	movi	r2,-22
 d03ef7c:	e0bfff15 	stw	r2,-4(fp)
 d03ef80:	00000506 	br	d03ef98 <ip_reasm_incr_mem_useage+0x94>
   }

   ipr_curr_mem += increment;
 d03ef84:	e0bffe0b 	ldhu	r2,-8(fp)
 d03ef88:	d0e0c717 	ldw	r3,-31972(gp)
 d03ef8c:	10c5883a 	add	r2,r2,r3
 d03ef90:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 d03ef94:	e03fff15 	stw	zero,-4(fp)
 d03ef98:	e0bfff17 	ldw	r2,-4(fp)
}
 d03ef9c:	e037883a 	mov	sp,fp
 d03efa0:	df000017 	ldw	fp,0(sp)
 d03efa4:	dec00104 	addi	sp,sp,4
 d03efa8:	f800283a 	ret

0d03efac <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 d03efac:	defffd04 	addi	sp,sp,-12
 d03efb0:	df000215 	stw	fp,8(sp)
 d03efb4:	df000204 	addi	fp,sp,8
 d03efb8:	e13ffe0d 	sth	r4,-8(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 d03efbc:	d0e0c717 	ldw	r3,-31972(gp)
 d03efc0:	008001b4 	movhi	r2,6
 d03efc4:	10c00a2e 	bgeu	r2,r3,d03eff0 <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 d03efc8:	008341b4 	movhi	r2,3334
 d03efcc:	10b4ff04 	addi	r2,r2,-11268
 d03efd0:	10800217 	ldw	r2,8(r2)
 d03efd4:	10c00044 	addi	r3,r2,1
 d03efd8:	008341b4 	movhi	r2,3334
 d03efdc:	10b4ff04 	addi	r2,r2,-11268
 d03efe0:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 d03efe4:	00bffa84 	movi	r2,-22
 d03efe8:	e0bfff15 	stw	r2,-4(fp)
 d03efec:	00001206 	br	d03f038 <ip_reasm_decr_mem_useage+0x8c>
   }
   if (ipr_curr_mem < decrement)
 d03eff0:	e0fffe0b 	ldhu	r3,-8(fp)
 d03eff4:	d0a0c717 	ldw	r2,-31972(gp)
 d03eff8:	10c00a2e 	bgeu	r2,r3,d03f024 <ip_reasm_decr_mem_useage+0x78>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 d03effc:	008341b4 	movhi	r2,3334
 d03f000:	10b4ff04 	addi	r2,r2,-11268
 d03f004:	10800517 	ldw	r2,20(r2)
 d03f008:	10c00044 	addi	r3,r2,1
 d03f00c:	008341b4 	movhi	r2,3334
 d03f010:	10b4ff04 	addi	r2,r2,-11268
 d03f014:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 d03f018:	00bffa84 	movi	r2,-22
 d03f01c:	e0bfff15 	stw	r2,-4(fp)
 d03f020:	00000506 	br	d03f038 <ip_reasm_decr_mem_useage+0x8c>
   }

   ipr_curr_mem -= decrement;
 d03f024:	d0a0c717 	ldw	r2,-31972(gp)
 d03f028:	e0fffe0b 	ldhu	r3,-8(fp)
 d03f02c:	10c5c83a 	sub	r2,r2,r3
 d03f030:	d0a0c715 	stw	r2,-31972(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 d03f034:	e03fff15 	stw	zero,-4(fp)
 d03f038:	e0bfff17 	ldw	r2,-4(fp)
}
 d03f03c:	e037883a 	mov	sp,fp
 d03f040:	df000017 	ldw	fp,0(sp)
 d03f044:	dec00104 	addi	sp,sp,4
 d03f048:	f800283a 	ret

0d03f04c <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 d03f04c:	defff604 	addi	sp,sp,-40
 d03f050:	dfc00915 	stw	ra,36(sp)
 d03f054:	df000815 	stw	fp,32(sp)
 d03f058:	df000804 	addi	fp,sp,32
 d03f05c:	e13ffe15 	stw	r4,-8(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 d03f060:	e0bffe17 	ldw	r2,-8(fp)
 d03f064:	10800217 	ldw	r2,8(r2)
 d03f068:	10802204 	addi	r2,r2,136
 d03f06c:	113fffcc 	andi	r4,r2,65535
 d03f070:	d03ee6c0 	call	d03ee6c <ip_reasm_check_mem_useage>
 d03f074:	e0bff815 	stw	r2,-32(fp)
 d03f078:	e0bff817 	ldw	r2,-32(fp)
 d03f07c:	1005003a 	cmpeq	r2,r2,zero
 d03f080:	1000101e 	bne	r2,zero,d03f0c4 <ip_reasm_process_first_fragment+0x78>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d03f084:	01000084 	movi	r4,2
 d03f088:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free (p);
 d03f08c:	e13ffe17 	ldw	r4,-8(fp)
 d03f090:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03f094:	01000084 	movi	r4,2
 d03f098:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 d03f09c:	008341b4 	movhi	r2,3334
 d03f0a0:	10b4eb04 	addi	r2,r2,-11348
 d03f0a4:	10800f17 	ldw	r2,60(r2)
 d03f0a8:	10c00044 	addi	r3,r2,1
 d03f0ac:	008341b4 	movhi	r2,3334
 d03f0b0:	10b4eb04 	addi	r2,r2,-11348
 d03f0b4:	10c00f15 	stw	r3,60(r2)
      return rc;
 d03f0b8:	e0bff817 	ldw	r2,-32(fp)
 d03f0bc:	e0bfff15 	stw	r2,-4(fp)
 d03f0c0:	00009406 	br	d03f314 <ip_reasm_process_first_fragment+0x2c8>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 d03f0c4:	01002204 	movi	r4,136
 d03f0c8:	d029e2c0 	call	d029e2c <npalloc>
 d03f0cc:	e0bffc15 	stw	r2,-16(fp)
   if (irep == 0) 
 d03f0d0:	e0bffc17 	ldw	r2,-16(fp)
 d03f0d4:	1004c03a 	cmpne	r2,r2,zero
 d03f0d8:	1000101e 	bne	r2,zero,d03f11c <ip_reasm_process_first_fragment+0xd0>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d03f0dc:	01000084 	movi	r4,2
 d03f0e0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free (p);
 d03f0e4:	e13ffe17 	ldw	r4,-8(fp)
 d03f0e8:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03f0ec:	01000084 	movi	r4,2
 d03f0f0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 d03f0f4:	008341b4 	movhi	r2,3334
 d03f0f8:	10b4eb04 	addi	r2,r2,-11348
 d03f0fc:	10800f17 	ldw	r2,60(r2)
 d03f100:	10c00044 	addi	r3,r2,1
 d03f104:	008341b4 	movhi	r2,3334
 d03f108:	10b4eb04 	addi	r2,r2,-11348
 d03f10c:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 d03f110:	00bffa84 	movi	r2,-22
 d03f114:	e0bfff15 	stw	r2,-4(fp)
 d03f118:	00007e06 	br	d03f314 <ip_reasm_process_first_fragment+0x2c8>
   }

   pip = ip_head(p);
 d03f11c:	e0bffe17 	ldw	r2,-8(fp)
 d03f120:	10800317 	ldw	r2,12(r2)
 d03f124:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen(pip);
 d03f128:	e0bffd17 	ldw	r2,-12(fp)
 d03f12c:	10800003 	ldbu	r2,0(r2)
 d03f130:	108003cc 	andi	r2,r2,15
 d03f134:	1085883a 	add	r2,r2,r2
 d03f138:	1085883a 	add	r2,r2,r2
 d03f13c:	e0bffa05 	stb	r2,-24(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 d03f140:	e13ffd17 	ldw	r4,-12(fp)
 d03f144:	d03ed800 	call	d03ed80 <ip_reasm_determine_type_of_frag>
 d03f148:	e0bffb15 	stw	r2,-20(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 d03f14c:	e0bffd17 	ldw	r2,-12(fp)
 d03f150:	1080018b 	ldhu	r2,6(r2)
 d03f154:	10bfffcc 	andi	r2,r2,65535
 d03f158:	1004d23a 	srli	r2,r2,8
 d03f15c:	10803fcc 	andi	r2,r2,255
 d03f160:	1009883a 	mov	r4,r2
 d03f164:	e0bffd17 	ldw	r2,-12(fp)
 d03f168:	1080018b 	ldhu	r2,6(r2)
 d03f16c:	10bfffcc 	andi	r2,r2,65535
 d03f170:	1004923a 	slli	r2,r2,8
 d03f174:	1007883a 	mov	r3,r2
 d03f178:	00bfc004 	movi	r2,-256
 d03f17c:	1884703a 	and	r2,r3,r2
 d03f180:	2084b03a 	or	r2,r4,r2
 d03f184:	1087ffcc 	andi	r2,r2,8191
 d03f188:	100490fa 	slli	r2,r2,3
 d03f18c:	e0bff98d 	sth	r2,-26(fp)
   total_len = ntohs(pip->ip_len);
 d03f190:	e0bffd17 	ldw	r2,-12(fp)
 d03f194:	1080008b 	ldhu	r2,2(r2)
 d03f198:	10bfffcc 	andi	r2,r2,65535
 d03f19c:	1004d23a 	srli	r2,r2,8
 d03f1a0:	10803fcc 	andi	r2,r2,255
 d03f1a4:	1009883a 	mov	r4,r2
 d03f1a8:	e0bffd17 	ldw	r2,-12(fp)
 d03f1ac:	1080008b 	ldhu	r2,2(r2)
 d03f1b0:	10bfffcc 	andi	r2,r2,65535
 d03f1b4:	1004923a 	slli	r2,r2,8
 d03f1b8:	1007883a 	mov	r3,r2
 d03f1bc:	00bfc004 	movi	r2,-256
 d03f1c0:	1884703a 	and	r2,r3,r2
 d03f1c4:	2084b03a 	or	r2,r4,r2
 d03f1c8:	e0bff90d 	sth	r2,-28(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 d03f1cc:	e0bffd17 	ldw	r2,-12(fp)
 d03f1d0:	10c00317 	ldw	r3,12(r2)
 d03f1d4:	e0bffc17 	ldw	r2,-16(fp)
 d03f1d8:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 d03f1dc:	e0bffd17 	ldw	r2,-12(fp)
 d03f1e0:	10c00417 	ldw	r3,16(r2)
 d03f1e4:	e0bffc17 	ldw	r2,-16(fp)
 d03f1e8:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 d03f1ec:	e0bffd17 	ldw	r2,-12(fp)
 d03f1f0:	10c00243 	ldbu	r3,9(r2)
 d03f1f4:	e0bffc17 	ldw	r2,-16(fp)
 d03f1f8:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 d03f1fc:	e0bffd17 	ldw	r2,-12(fp)
 d03f200:	10c0010b 	ldhu	r3,4(r2)
 d03f204:	e0bffc17 	ldw	r2,-16(fp)
 d03f208:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 d03f20c:	e0bffb17 	ldw	r2,-20(fp)
 d03f210:	10800158 	cmpnei	r2,r2,5
 d03f214:	10000a1e 	bne	r2,zero,d03f240 <ip_reasm_process_first_fragment+0x1f4>
      {
      irep->length = frag_offset + (total_len - iphlen);
 d03f218:	e0fffa03 	ldbu	r3,-24(fp)
 d03f21c:	e0bff90b 	ldhu	r2,-28(fp)
 d03f220:	10c5c83a 	sub	r2,r2,r3
 d03f224:	1007883a 	mov	r3,r2
 d03f228:	e0bff98b 	ldhu	r2,-26(fp)
 d03f22c:	1885883a 	add	r2,r3,r2
 d03f230:	1007883a 	mov	r3,r2
 d03f234:	e0bffc17 	ldw	r2,-16(fp)
 d03f238:	10c0040d 	sth	r3,16(r2)
 d03f23c:	00000a06 	br	d03f268 <ip_reasm_process_first_fragment+0x21c>
      }
   else if (ftype == IP_FF)
 d03f240:	e0bffb17 	ldw	r2,-20(fp)
 d03f244:	10800058 	cmpnei	r2,r2,1
 d03f248:	1000071e 	bne	r2,zero,d03f268 <ip_reasm_process_first_fragment+0x21c>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 d03f24c:	e0bffe17 	ldw	r2,-8(fp)
 d03f250:	10c00117 	ldw	r3,4(r2)
 d03f254:	e0bffc17 	ldw	r2,-16(fp)
 d03f258:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 d03f25c:	e0fffd17 	ldw	r3,-12(fp)
 d03f260:	e0bffc17 	ldw	r2,-16(fp)
 d03f264:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 d03f268:	e0fffa03 	ldbu	r3,-24(fp)
 d03f26c:	e0bff90b 	ldhu	r2,-28(fp)
 d03f270:	10c5c83a 	sub	r2,r2,r3
 d03f274:	1007883a 	mov	r3,r2
 d03f278:	e0bffc17 	ldw	r2,-16(fp)
 d03f27c:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 d03f280:	e0bffc17 	ldw	r2,-16(fp)
 d03f284:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 d03f288:	e0bffc17 	ldw	r2,-16(fp)
 d03f28c:	10802103 	ldbu	r2,132(r2)
 d03f290:	10800054 	ori	r2,r2,1
 d03f294:	1007883a 	mov	r3,r2
 d03f298:	e0bffc17 	ldw	r2,-16(fp)
 d03f29c:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 d03f2a0:	e0fffc17 	ldw	r3,-16(fp)
 d03f2a4:	e0bffe17 	ldw	r2,-8(fp)
 d03f2a8:	18800715 	stw	r2,28(r3)
   irep->rfq.frag_offset[0] = frag_offset;
 d03f2ac:	e0fffc17 	ldw	r3,-16(fp)
 d03f2b0:	e0bff98b 	ldhu	r2,-26(fp)
 d03f2b4:	1880170d 	sth	r2,92(r3)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 d03f2b8:	e0bffe17 	ldw	r2,-8(fp)
 d03f2bc:	10c00317 	ldw	r3,12(r2)
 d03f2c0:	e0bffa03 	ldbu	r2,-24(fp)
 d03f2c4:	1887883a 	add	r3,r3,r2
 d03f2c8:	e0bffe17 	ldw	r2,-8(fp)
 d03f2cc:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 d03f2d0:	e0bffe17 	ldw	r2,-8(fp)
 d03f2d4:	10c00417 	ldw	r3,16(r2)
 d03f2d8:	e0bffa03 	ldbu	r2,-24(fp)
 d03f2dc:	1887c83a 	sub	r3,r3,r2
 d03f2e0:	e0bffe17 	ldw	r2,-8(fp)
 d03f2e4:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 d03f2e8:	d0e0c817 	ldw	r3,-31968(gp)
 d03f2ec:	e0bffc17 	ldw	r2,-16(fp)
 d03f2f0:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 d03f2f4:	e0bffc17 	ldw	r2,-16(fp)
 d03f2f8:	d0a0c815 	stw	r2,-31968(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 d03f2fc:	e0bffe17 	ldw	r2,-8(fp)
 d03f300:	10800217 	ldw	r2,8(r2)
 d03f304:	10802204 	addi	r2,r2,136
 d03f308:	113fffcc 	andi	r4,r2,65535
 d03f30c:	d03ef040 	call	d03ef04 <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 d03f310:	e03fff15 	stw	zero,-4(fp)
 d03f314:	e0bfff17 	ldw	r2,-4(fp)
}
 d03f318:	e037883a 	mov	sp,fp
 d03f31c:	dfc00117 	ldw	ra,4(sp)
 d03f320:	df000017 	ldw	fp,0(sp)
 d03f324:	dec00204 	addi	sp,sp,8
 d03f328:	f800283a 	ret

0d03f32c <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 d03f32c:	defff804 	addi	sp,sp,-32
 d03f330:	dfc00715 	stw	ra,28(sp)
 d03f334:	df000615 	stw	fp,24(sp)
 d03f338:	df000604 	addi	fp,sp,24
 d03f33c:	e13ffe15 	stw	r4,-8(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 d03f340:	e0bffe17 	ldw	r2,-8(fp)
 d03f344:	10800317 	ldw	r2,12(r2)
 d03f348:	e0bffc15 	stw	r2,-16(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 d03f34c:	e13ffc17 	ldw	r4,-16(fp)
 d03f350:	d03ecb00 	call	d03ecb0 <ip_reasm_match_frag_with_ire>
 d03f354:	e0bffd15 	stw	r2,-12(fp)

   if (!irep)
 d03f358:	e0bffd17 	ldw	r2,-12(fp)
 d03f35c:	1004c03a 	cmpne	r2,r2,zero
 d03f360:	1000091e 	bne	r2,zero,d03f388 <ip_reassm+0x5c>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 d03f364:	e13ffe17 	ldw	r4,-8(fp)
 d03f368:	d03f04c0 	call	d03f04c <ip_reasm_process_first_fragment>
 d03f36c:	e0bffb15 	stw	r2,-20(fp)
 d03f370:	e0bffb17 	ldw	r2,-20(fp)
 d03f374:	1005003a 	cmpeq	r2,r2,zero
 d03f378:	10000d1e 	bne	r2,zero,d03f3b0 <ip_reassm+0x84>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 d03f37c:	e0bffb17 	ldw	r2,-20(fp)
 d03f380:	e0bfff15 	stw	r2,-4(fp)
 d03f384:	00000b06 	br	d03f3b4 <ip_reassm+0x88>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 d03f388:	e13ffe17 	ldw	r4,-8(fp)
 d03f38c:	e17ffd17 	ldw	r5,-12(fp)
 d03f390:	d03f95c0 	call	d03f95c <ip_reasm_process_subsequent_fragments>
 d03f394:	e0bffa15 	stw	r2,-24(fp)
 d03f398:	e0bffa17 	ldw	r2,-24(fp)
 d03f39c:	1005003a 	cmpeq	r2,r2,zero
 d03f3a0:	1000031e 	bne	r2,zero,d03f3b0 <ip_reassm+0x84>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 d03f3a4:	e0bffa17 	ldw	r2,-24(fp)
 d03f3a8:	e0bfff15 	stw	r2,-4(fp)
 d03f3ac:	00000106 	br	d03f3b4 <ip_reassm+0x88>
      }
   }

   return IPREASM_OK;
 d03f3b0:	e03fff15 	stw	zero,-4(fp)
 d03f3b4:	e0bfff17 	ldw	r2,-4(fp)
}
 d03f3b8:	e037883a 	mov	sp,fp
 d03f3bc:	dfc00117 	ldw	ra,4(sp)
 d03f3c0:	df000017 	ldw	fp,0(sp)
 d03f3c4:	dec00204 	addi	sp,sp,8
 d03f3c8:	f800283a 	ret

0d03f3cc <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 d03f3cc:	defff204 	addi	sp,sp,-56
 d03f3d0:	dfc00d15 	stw	ra,52(sp)
 d03f3d4:	df000c15 	stw	fp,48(sp)
 d03f3d8:	df000c04 	addi	fp,sp,48
 d03f3dc:	e13ffb15 	stw	r4,-20(fp)
 d03f3e0:	e17ffc15 	stw	r5,-16(fp)
 d03f3e4:	e1bffd15 	stw	r6,-12(fp)
 d03f3e8:	e1fffe15 	stw	r7,-8(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 d03f3ec:	e13ffc17 	ldw	r4,-16(fp)
 d03f3f0:	d03fef00 	call	d03fef0 <ip_reasm_find_ire>
 d03f3f4:	10803fcc 	andi	r2,r2,255
 d03f3f8:	10800060 	cmpeqi	r2,r2,1
 d03f3fc:	1000101e 	bne	r2,zero,d03f440 <ip_reasm_compute_overlap+0x74>
      {
      ++ire_stats.bad_irep;
 d03f400:	008341b4 	movhi	r2,3334
 d03f404:	10b4ff04 	addi	r2,r2,-11268
 d03f408:	10800017 	ldw	r2,0(r2)
 d03f40c:	10c00044 	addi	r3,r2,1
 d03f410:	008341b4 	movhi	r2,3334
 d03f414:	10b4ff04 	addi	r2,r2,-11268
 d03f418:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d03f41c:	01000084 	movi	r4,2
 d03f420:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free (p);
 d03f424:	e13ffb17 	ldw	r4,-20(fp)
 d03f428:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03f42c:	01000084 	movi	r4,2
 d03f430:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 d03f434:	00800044 	movi	r2,1
 d03f438:	e0bfff15 	stw	r2,-4(fp)
 d03f43c:	00014106 	br	d03f944 <ip_reasm_compute_overlap+0x578>
      }

   jrip = ip_head(p);
 d03f440:	e0bffb17 	ldw	r2,-20(fp)
 d03f444:	10800317 	ldw	r2,12(r2)
 d03f448:	e0bff815 	stw	r2,-32(fp)
   iphlen = ip_hlen (jrip);
 d03f44c:	e0bff817 	ldw	r2,-32(fp)
 d03f450:	10800003 	ldbu	r2,0(r2)
 d03f454:	108003cc 	andi	r2,r2,15
 d03f458:	1085883a 	add	r2,r2,r2
 d03f45c:	1085883a 	add	r2,r2,r2
 d03f460:	e0bff485 	stb	r2,-46(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 d03f464:	e0bff817 	ldw	r2,-32(fp)
 d03f468:	1080018b 	ldhu	r2,6(r2)
 d03f46c:	10bfffcc 	andi	r2,r2,65535
 d03f470:	1004d23a 	srli	r2,r2,8
 d03f474:	10803fcc 	andi	r2,r2,255
 d03f478:	1009883a 	mov	r4,r2
 d03f47c:	e0bff817 	ldw	r2,-32(fp)
 d03f480:	1080018b 	ldhu	r2,6(r2)
 d03f484:	10bfffcc 	andi	r2,r2,65535
 d03f488:	1004923a 	slli	r2,r2,8
 d03f48c:	1007883a 	mov	r3,r2
 d03f490:	00bfc004 	movi	r2,-256
 d03f494:	1884703a 	and	r2,r3,r2
 d03f498:	2084b03a 	or	r2,r4,r2
 d03f49c:	1087ffcc 	andi	r2,r2,8191
 d03f4a0:	100490fa 	slli	r2,r2,3
 d03f4a4:	e0bff70d 	sth	r2,-36(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 d03f4a8:	e0bff817 	ldw	r2,-32(fp)
 d03f4ac:	1080008b 	ldhu	r2,2(r2)
 d03f4b0:	10bfffcc 	andi	r2,r2,65535
 d03f4b4:	1004d23a 	srli	r2,r2,8
 d03f4b8:	10803fcc 	andi	r2,r2,255
 d03f4bc:	1009883a 	mov	r4,r2
 d03f4c0:	e0bff817 	ldw	r2,-32(fp)
 d03f4c4:	1080008b 	ldhu	r2,2(r2)
 d03f4c8:	10bfffcc 	andi	r2,r2,65535
 d03f4cc:	1004923a 	slli	r2,r2,8
 d03f4d0:	1007883a 	mov	r3,r2
 d03f4d4:	00bfc004 	movi	r2,-256
 d03f4d8:	1884703a 	and	r2,r3,r2
 d03f4dc:	2084b03a 	or	r2,r4,r2
 d03f4e0:	1007883a 	mov	r3,r2
 d03f4e4:	e0bff483 	ldbu	r2,-46(fp)
 d03f4e8:	1885c83a 	sub	r2,r3,r2
 d03f4ec:	1007883a 	mov	r3,r2
 d03f4f0:	e0bff70b 	ldhu	r2,-36(fp)
 d03f4f4:	1885883a 	add	r2,r3,r2
 d03f4f8:	10bfffc4 	addi	r2,r2,-1
 d03f4fc:	e0bff68d 	sth	r2,-38(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 d03f500:	e0bffb17 	ldw	r2,-20(fp)
 d03f504:	10c00317 	ldw	r3,12(r2)
 d03f508:	e0bff483 	ldbu	r2,-46(fp)
 d03f50c:	1887883a 	add	r3,r3,r2
 d03f510:	e0bffb17 	ldw	r2,-20(fp)
 d03f514:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 d03f518:	e0bffb17 	ldw	r2,-20(fp)
 d03f51c:	10c00417 	ldw	r3,16(r2)
 d03f520:	e0bff483 	ldbu	r2,-46(fp)
 d03f524:	1887c83a 	sub	r3,r3,r2
 d03f528:	e0bffb17 	ldw	r2,-20(fp)
 d03f52c:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 d03f530:	e0c00217 	ldw	r3,8(fp)
 d03f534:	e0bff70b 	ldhu	r2,-36(fp)
 d03f538:	1880000d 	sth	r2,0(r3)
   *indexp = INVALID_FRAG_INDEX;
 d03f53c:	e0fffd17 	ldw	r3,-12(fp)
 d03f540:	00800404 	movi	r2,16
 d03f544:	1880000d 	sth	r2,0(r3)
   *last_rfqpp = 0;
 d03f548:	e0bffe17 	ldw	r2,-8(fp)
 d03f54c:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 d03f550:	e0800317 	ldw	r2,12(fp)
 d03f554:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 d03f558:	e0bffc17 	ldw	r2,-16(fp)
 d03f55c:	10800604 	addi	r2,r2,24
 d03f560:	e0bffa15 	stw	r2,-24(fp)

   while (rfqp)
 d03f564:	0000ef06 	br	d03f924 <ip_reasm_compute_overlap+0x558>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d03f568:	e03ff40d 	sth	zero,-48(fp)
 d03f56c:	0000df06 	br	d03f8ec <ip_reasm_compute_overlap+0x520>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 d03f570:	e0bff40b 	ldhu	r2,-48(fp)
 d03f574:	e0fffa17 	ldw	r3,-24(fp)
 d03f578:	1085883a 	add	r2,r2,r2
 d03f57c:	1085883a 	add	r2,r2,r2
 d03f580:	10c5883a 	add	r2,r2,r3
 d03f584:	10800104 	addi	r2,r2,4
 d03f588:	10800017 	ldw	r2,0(r2)
 d03f58c:	e0bff915 	stw	r2,-28(fp)
 d03f590:	e0bff917 	ldw	r2,-28(fp)
 d03f594:	1005003a 	cmpeq	r2,r2,zero
 d03f598:	1000bf1e 	bne	r2,zero,d03f898 <ip_reasm_compute_overlap+0x4cc>
            {
            currstart = rfqp->frag_offset[i];
 d03f59c:	e0bff40b 	ldhu	r2,-48(fp)
 d03f5a0:	e0fffa17 	ldw	r3,-24(fp)
 d03f5a4:	1085883a 	add	r2,r2,r2
 d03f5a8:	10c5883a 	add	r2,r2,r3
 d03f5ac:	10801104 	addi	r2,r2,68
 d03f5b0:	1080000b 	ldhu	r2,0(r2)
 d03f5b4:	e0bff60d 	sth	r2,-40(fp)
            currend = currstart + currpkt->nb_plen - 1;
 d03f5b8:	e0bff917 	ldw	r2,-28(fp)
 d03f5bc:	10800417 	ldw	r2,16(r2)
 d03f5c0:	1007883a 	mov	r3,r2
 d03f5c4:	e0bff60b 	ldhu	r2,-40(fp)
 d03f5c8:	1885883a 	add	r2,r3,r2
 d03f5cc:	10bfffc4 	addi	r2,r2,-1
 d03f5d0:	e0bff58d 	sth	r2,-42(fp)

            if (currstart < jrstart)
 d03f5d4:	e0fff60b 	ldhu	r3,-40(fp)
 d03f5d8:	e0bff70b 	ldhu	r2,-36(fp)
 d03f5dc:	18802b2e 	bgeu	r3,r2,d03f68c <ip_reasm_compute_overlap+0x2c0>
               {
               if (currend < jrend) /* cases A1 and A2 */
 d03f5e0:	e0fff58b 	ldhu	r3,-42(fp)
 d03f5e4:	e0bff68b 	ldhu	r2,-38(fp)
 d03f5e8:	1880202e 	bgeu	r3,r2,d03f66c <ip_reasm_compute_overlap+0x2a0>
                  {
                  if (currend < jrstart) /* A1 */
 d03f5ec:	e0fff58b 	ldhu	r3,-42(fp)
 d03f5f0:	e0bff70b 	ldhu	r2,-36(fp)
 d03f5f4:	1880ba36 	bltu	r3,r2,d03f8e0 <ip_reasm_compute_overlap+0x514>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 d03f5f8:	e0fff58b 	ldhu	r3,-42(fp)
 d03f5fc:	e0bff70b 	ldhu	r2,-36(fp)
 d03f600:	1885c83a 	sub	r2,r3,r2
 d03f604:	10800044 	addi	r2,r2,1
 d03f608:	e0bff50d 	sth	r2,-44(fp)
                     p->nb_prot += drop_len;
 d03f60c:	e0bffb17 	ldw	r2,-20(fp)
 d03f610:	10c00317 	ldw	r3,12(r2)
 d03f614:	e0bff50b 	ldhu	r2,-44(fp)
 d03f618:	1887883a 	add	r3,r3,r2
 d03f61c:	e0bffb17 	ldw	r2,-20(fp)
 d03f620:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 d03f624:	e0bffb17 	ldw	r2,-20(fp)
 d03f628:	10c00417 	ldw	r3,16(r2)
 d03f62c:	e0bff50b 	ldhu	r2,-44(fp)
 d03f630:	1887c83a 	sub	r3,r3,r2
 d03f634:	e0bffb17 	ldw	r2,-20(fp)
 d03f638:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 d03f63c:	e0fff70b 	ldhu	r3,-36(fp)
 d03f640:	e0bff50b 	ldhu	r2,-44(fp)
 d03f644:	1885883a 	add	r2,r3,r2
 d03f648:	e0bff70d 	sth	r2,-36(fp)
                     jrend = jrstart + p->nb_plen - 1;
 d03f64c:	e0bffb17 	ldw	r2,-20(fp)
 d03f650:	10800417 	ldw	r2,16(r2)
 d03f654:	1007883a 	mov	r3,r2
 d03f658:	e0bff70b 	ldhu	r2,-36(fp)
 d03f65c:	1885883a 	add	r2,r3,r2
 d03f660:	10bfffc4 	addi	r2,r2,-1
 d03f664:	e0bff68d 	sth	r2,-38(fp)
 d03f668:	00009d06 	br	d03f8e0 <ip_reasm_compute_overlap+0x514>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 d03f66c:	01000084 	movi	r4,2
 d03f670:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
                  pk_free (p);
 d03f674:	e13ffb17 	ldw	r4,-20(fp)
 d03f678:	d028b380 	call	d028b38 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03f67c:	01000084 	movi	r4,2
 d03f680:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 d03f684:	e03fff15 	stw	zero,-4(fp)
 d03f688:	0000ae06 	br	d03f944 <ip_reasm_compute_overlap+0x578>
                  }
               }
            else if (currstart > jrstart)
 d03f68c:	e0fff60b 	ldhu	r3,-40(fp)
 d03f690:	e0bff70b 	ldhu	r2,-36(fp)
 d03f694:	10c04d2e 	bgeu	r2,r3,d03f7cc <ip_reasm_compute_overlap+0x400>
               {
               if (currend > jrend) /* cases B1 and B2 */
 d03f698:	e0fff58b 	ldhu	r3,-42(fp)
 d03f69c:	e0bff68b 	ldhu	r2,-38(fp)
 d03f6a0:	10c0112e 	bgeu	r2,r3,d03f6e8 <ip_reasm_compute_overlap+0x31c>
                  {
                  if (currstart > jrend) /* B1 */
 d03f6a4:	e0fff60b 	ldhu	r3,-40(fp)
 d03f6a8:	e0bff68b 	ldhu	r2,-38(fp)
 d03f6ac:	10c08c36 	bltu	r2,r3,d03f8e0 <ip_reasm_compute_overlap+0x514>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 d03f6b0:	e0fff60b 	ldhu	r3,-40(fp)
 d03f6b4:	e0bff70b 	ldhu	r2,-36(fp)
 d03f6b8:	1885c83a 	sub	r2,r3,r2
 d03f6bc:	1007883a 	mov	r3,r2
 d03f6c0:	e0bffb17 	ldw	r2,-20(fp)
 d03f6c4:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 d03f6c8:	e0bffb17 	ldw	r2,-20(fp)
 d03f6cc:	10800417 	ldw	r2,16(r2)
 d03f6d0:	1007883a 	mov	r3,r2
 d03f6d4:	e0bff70b 	ldhu	r2,-36(fp)
 d03f6d8:	1885883a 	add	r2,r3,r2
 d03f6dc:	10bfffc4 	addi	r2,r2,-1
 d03f6e0:	e0bff68d 	sth	r2,-38(fp)
 d03f6e4:	00007e06 	br	d03f8e0 <ip_reasm_compute_overlap+0x514>
                     }
                  }
               else if (currend == jrend) /* F1 */
 d03f6e8:	e0fff58b 	ldhu	r3,-42(fp)
 d03f6ec:	e0bff68b 	ldhu	r2,-38(fp)
 d03f6f0:	18800e1e 	bne	r3,r2,d03f72c <ip_reasm_compute_overlap+0x360>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 d03f6f4:	e0fff60b 	ldhu	r3,-40(fp)
 d03f6f8:	e0bff70b 	ldhu	r2,-36(fp)
 d03f6fc:	1885c83a 	sub	r2,r3,r2
 d03f700:	1007883a 	mov	r3,r2
 d03f704:	e0bffb17 	ldw	r2,-20(fp)
 d03f708:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 d03f70c:	e0bffb17 	ldw	r2,-20(fp)
 d03f710:	10800417 	ldw	r2,16(r2)
 d03f714:	1007883a 	mov	r3,r2
 d03f718:	e0bff70b 	ldhu	r2,-36(fp)
 d03f71c:	1885883a 	add	r2,r3,r2
 d03f720:	10bfffc4 	addi	r2,r2,-1
 d03f724:	e0bff68d 	sth	r2,-38(fp)
 d03f728:	00006d06 	br	d03f8e0 <ip_reasm_compute_overlap+0x514>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 d03f72c:	e0bff917 	ldw	r2,-28(fp)
 d03f730:	10800217 	ldw	r2,8(r2)
 d03f734:	113fffcc 	andi	r4,r2,65535
 d03f738:	d03efac0 	call	d03efac <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 d03f73c:	e0bffc17 	ldw	r2,-16(fp)
 d03f740:	10c0048b 	ldhu	r3,18(r2)
 d03f744:	e0bff917 	ldw	r2,-28(fp)
 d03f748:	10800417 	ldw	r2,16(r2)
 d03f74c:	1885c83a 	sub	r2,r3,r2
 d03f750:	1007883a 	mov	r3,r2
 d03f754:	e0bffc17 	ldw	r2,-16(fp)
 d03f758:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 d03f75c:	01000084 	movi	r4,2
 d03f760:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 d03f764:	e13ff917 	ldw	r4,-28(fp)
 d03f768:	d028b380 	call	d028b38 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03f76c:	01000084 	movi	r4,2
 d03f770:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 d03f774:	e0bff40b 	ldhu	r2,-48(fp)
 d03f778:	e0fffa17 	ldw	r3,-24(fp)
 d03f77c:	1085883a 	add	r2,r2,r2
 d03f780:	1085883a 	add	r2,r2,r2
 d03f784:	10c5883a 	add	r2,r2,r3
 d03f788:	10800104 	addi	r2,r2,4
 d03f78c:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 d03f790:	e0bffd17 	ldw	r2,-12(fp)
 d03f794:	1080000b 	ldhu	r2,0(r2)
 d03f798:	10bfffcc 	andi	r2,r2,65535
 d03f79c:	10800418 	cmpnei	r2,r2,16
 d03f7a0:	1000061e 	bne	r2,zero,d03f7bc <ip_reasm_compute_overlap+0x3f0>
                     {
                     *indexp = i;
 d03f7a4:	e0fffd17 	ldw	r3,-12(fp)
 d03f7a8:	e0bff40b 	ldhu	r2,-48(fp)
 d03f7ac:	1880000d 	sth	r2,0(r3)
                     *last_rfqpp = rfqp;
 d03f7b0:	e0fffe17 	ldw	r3,-8(fp)
 d03f7b4:	e0bffa17 	ldw	r2,-24(fp)
 d03f7b8:	18800015 	stw	r2,0(r3)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 d03f7bc:	e0c00317 	ldw	r3,12(fp)
 d03f7c0:	00800044 	movi	r2,1
 d03f7c4:	18800005 	stb	r2,0(r3)
 d03f7c8:	00004506 	br	d03f8e0 <ip_reasm_compute_overlap+0x514>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 d03f7cc:	e0fff58b 	ldhu	r3,-42(fp)
 d03f7d0:	e0bff68b 	ldhu	r2,-38(fp)
 d03f7d4:	1880081e 	bne	r3,r2,d03f7f8 <ip_reasm_compute_overlap+0x42c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 d03f7d8:	01000084 	movi	r4,2
 d03f7dc:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
                  pk_free (p);
 d03f7e0:	e13ffb17 	ldw	r4,-20(fp)
 d03f7e4:	d028b380 	call	d028b38 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03f7e8:	01000084 	movi	r4,2
 d03f7ec:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 d03f7f0:	e03fff15 	stw	zero,-4(fp)
 d03f7f4:	00005306 	br	d03f944 <ip_reasm_compute_overlap+0x578>
                  }
               else if (currend > jrend) /* case D1 */
 d03f7f8:	e0fff58b 	ldhu	r3,-42(fp)
 d03f7fc:	e0bff68b 	ldhu	r2,-38(fp)
 d03f800:	10c0082e 	bgeu	r2,r3,d03f824 <ip_reasm_compute_overlap+0x458>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 d03f804:	01000084 	movi	r4,2
 d03f808:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
                  pk_free (p);
 d03f80c:	e13ffb17 	ldw	r4,-20(fp)
 d03f810:	d028b380 	call	d028b38 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03f814:	01000084 	movi	r4,2
 d03f818:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 d03f81c:	e03fff15 	stw	zero,-4(fp)
 d03f820:	00004806 	br	d03f944 <ip_reasm_compute_overlap+0x578>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 d03f824:	e0fff58b 	ldhu	r3,-42(fp)
 d03f828:	e0bff70b 	ldhu	r2,-36(fp)
 d03f82c:	1885c83a 	sub	r2,r3,r2
 d03f830:	10800044 	addi	r2,r2,1
 d03f834:	e0bff50d 	sth	r2,-44(fp)
                  p->nb_prot += drop_len;
 d03f838:	e0bffb17 	ldw	r2,-20(fp)
 d03f83c:	10c00317 	ldw	r3,12(r2)
 d03f840:	e0bff50b 	ldhu	r2,-44(fp)
 d03f844:	1887883a 	add	r3,r3,r2
 d03f848:	e0bffb17 	ldw	r2,-20(fp)
 d03f84c:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 d03f850:	e0bffb17 	ldw	r2,-20(fp)
 d03f854:	10c00417 	ldw	r3,16(r2)
 d03f858:	e0bff50b 	ldhu	r2,-44(fp)
 d03f85c:	1887c83a 	sub	r3,r3,r2
 d03f860:	e0bffb17 	ldw	r2,-20(fp)
 d03f864:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 d03f868:	e0fff70b 	ldhu	r3,-36(fp)
 d03f86c:	e0bff50b 	ldhu	r2,-44(fp)
 d03f870:	1885883a 	add	r2,r3,r2
 d03f874:	e0bff70d 	sth	r2,-36(fp)
                  jrend = jrstart + p->nb_plen - 1;
 d03f878:	e0bffb17 	ldw	r2,-20(fp)
 d03f87c:	10800417 	ldw	r2,16(r2)
 d03f880:	1007883a 	mov	r3,r2
 d03f884:	e0bff70b 	ldhu	r2,-36(fp)
 d03f888:	1885883a 	add	r2,r3,r2
 d03f88c:	10bfffc4 	addi	r2,r2,-1
 d03f890:	e0bff68d 	sth	r2,-38(fp)
 d03f894:	00001206 	br	d03f8e0 <ip_reasm_compute_overlap+0x514>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 d03f898:	e0bffd17 	ldw	r2,-12(fp)
 d03f89c:	1080000b 	ldhu	r2,0(r2)
 d03f8a0:	10bfffcc 	andi	r2,r2,65535
 d03f8a4:	10800418 	cmpnei	r2,r2,16
 d03f8a8:	1000061e 	bne	r2,zero,d03f8c4 <ip_reasm_compute_overlap+0x4f8>
               {
               *indexp = i;
 d03f8ac:	e0fffd17 	ldw	r3,-12(fp)
 d03f8b0:	e0bff40b 	ldhu	r2,-48(fp)
 d03f8b4:	1880000d 	sth	r2,0(r3)
               *last_rfqpp = rfqp;               
 d03f8b8:	e0fffe17 	ldw	r3,-8(fp)
 d03f8bc:	e0bffa17 	ldw	r2,-24(fp)
 d03f8c0:	18800015 	stw	r2,0(r3)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 d03f8c4:	e0bffc17 	ldw	r2,-16(fp)
 d03f8c8:	10802103 	ldbu	r2,132(r2)
 d03f8cc:	10803fcc 	andi	r2,r2,255
 d03f8d0:	1080004c 	andi	r2,r2,1
 d03f8d4:	10803fcc 	andi	r2,r2,255
 d03f8d8:	1004c03a 	cmpne	r2,r2,zero
 d03f8dc:	1000061e 	bne	r2,zero,d03f8f8 <ip_reasm_compute_overlap+0x52c>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d03f8e0:	e0bff40b 	ldhu	r2,-48(fp)
 d03f8e4:	10800044 	addi	r2,r2,1
 d03f8e8:	e0bff40d 	sth	r2,-48(fp)
 d03f8ec:	e0bff40b 	ldhu	r2,-48(fp)
 d03f8f0:	10800430 	cmpltui	r2,r2,16
 d03f8f4:	103f1e1e 	bne	r2,zero,d03f570 <ip_reasm_compute_overlap+0x1a4>
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 d03f8f8:	e0bffd17 	ldw	r2,-12(fp)
 d03f8fc:	1080000b 	ldhu	r2,0(r2)
 d03f900:	10bfffcc 	andi	r2,r2,65535
 d03f904:	10800418 	cmpnei	r2,r2,16
 d03f908:	1000031e 	bne	r2,zero,d03f918 <ip_reasm_compute_overlap+0x54c>
         {
         *last_rfqpp = rfqp;
 d03f90c:	e0fffe17 	ldw	r3,-8(fp)
 d03f910:	e0bffa17 	ldw	r2,-24(fp)
 d03f914:	18800015 	stw	r2,0(r3)
         }
      rfqp = rfqp->next;
 d03f918:	e0bffa17 	ldw	r2,-24(fp)
 d03f91c:	10800017 	ldw	r2,0(r2)
 d03f920:	e0bffa15 	stw	r2,-24(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 d03f924:	e0bffa17 	ldw	r2,-24(fp)
 d03f928:	1004c03a 	cmpne	r2,r2,zero
 d03f92c:	103f0e1e 	bne	r2,zero,d03f568 <ip_reasm_compute_overlap+0x19c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 d03f930:	e0c00217 	ldw	r3,8(fp)
 d03f934:	e0bff70b 	ldhu	r2,-36(fp)
 d03f938:	1880000d 	sth	r2,0(r3)

   return IPREASM_ACCEPT_FRAG;
 d03f93c:	00800084 	movi	r2,2
 d03f940:	e0bfff15 	stw	r2,-4(fp)
 d03f944:	e0bfff17 	ldw	r2,-4(fp)
}
 d03f948:	e037883a 	mov	sp,fp
 d03f94c:	dfc00117 	ldw	ra,4(sp)
 d03f950:	df000017 	ldw	fp,0(sp)
 d03f954:	dec00204 	addi	sp,sp,8
 d03f958:	f800283a 	ret

0d03f95c <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 d03f95c:	deffed04 	addi	sp,sp,-76
 d03f960:	dfc01215 	stw	ra,72(sp)
 d03f964:	df001115 	stw	fp,68(sp)
 d03f968:	df001104 	addi	fp,sp,68
 d03f96c:	e13ffa15 	stw	r4,-24(fp)
 d03f970:	e17ffb15 	stw	r5,-20(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 d03f974:	e03ff415 	stw	zero,-48(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 d03f978:	e13ffb17 	ldw	r4,-20(fp)
 d03f97c:	d03fef00 	call	d03fef0 <ip_reasm_find_ire>
 d03f980:	10803fcc 	andi	r2,r2,255
 d03f984:	10800060 	cmpeqi	r2,r2,1
 d03f988:	1000171e 	bne	r2,zero,d03f9e8 <ip_reasm_process_subsequent_fragments+0x8c>
      {
      ++ire_stats.bad_irep;
 d03f98c:	008341b4 	movhi	r2,3334
 d03f990:	10b4ff04 	addi	r2,r2,-11268
 d03f994:	10800017 	ldw	r2,0(r2)
 d03f998:	10c00044 	addi	r3,r2,1
 d03f99c:	008341b4 	movhi	r2,3334
 d03f9a0:	10b4ff04 	addi	r2,r2,-11268
 d03f9a4:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d03f9a8:	01000084 	movi	r4,2
 d03f9ac:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free (p);
 d03f9b0:	e13ffa17 	ldw	r4,-24(fp)
 d03f9b4:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03f9b8:	01000084 	movi	r4,2
 d03f9bc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 d03f9c0:	008341b4 	movhi	r2,3334
 d03f9c4:	10b4eb04 	addi	r2,r2,-11348
 d03f9c8:	10800f17 	ldw	r2,60(r2)
 d03f9cc:	10c00044 	addi	r3,r2,1
 d03f9d0:	008341b4 	movhi	r2,3334
 d03f9d4:	10b4eb04 	addi	r2,r2,-11348
 d03f9d8:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 d03f9dc:	00bffd84 	movi	r2,-10
 d03f9e0:	e0bffe15 	stw	r2,-8(fp)
 d03f9e4:	00013c06 	br	d03fed8 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   pip = ip_head(p);
 d03f9e8:	e0bffa17 	ldw	r2,-24(fp)
 d03f9ec:	10800317 	ldw	r2,12(r2)
 d03f9f0:	e0bff515 	stw	r2,-44(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 d03f9f4:	e13ff517 	ldw	r4,-44(fp)
 d03f9f8:	d03ed800 	call	d03ed80 <ip_reasm_determine_type_of_frag>
 d03f9fc:	e0bff215 	stw	r2,-56(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 d03fa00:	e0bff217 	ldw	r2,-56(fp)
 d03fa04:	10800158 	cmpnei	r2,r2,5
 d03fa08:	10002c1e 	bne	r2,zero,d03fabc <ip_reasm_process_subsequent_fragments+0x160>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 d03fa0c:	e0bff517 	ldw	r2,-44(fp)
 d03fa10:	1080018b 	ldhu	r2,6(r2)
 d03fa14:	10bfffcc 	andi	r2,r2,65535
 d03fa18:	1004d23a 	srli	r2,r2,8
 d03fa1c:	10803fcc 	andi	r2,r2,255
 d03fa20:	1009883a 	mov	r4,r2
 d03fa24:	e0bff517 	ldw	r2,-44(fp)
 d03fa28:	1080018b 	ldhu	r2,6(r2)
 d03fa2c:	10bfffcc 	andi	r2,r2,65535
 d03fa30:	1004923a 	slli	r2,r2,8
 d03fa34:	1007883a 	mov	r3,r2
 d03fa38:	00bfc004 	movi	r2,-256
 d03fa3c:	1884703a 	and	r2,r3,r2
 d03fa40:	2084b03a 	or	r2,r4,r2
 d03fa44:	1087ffcc 	andi	r2,r2,8191
 d03fa48:	100490fa 	slli	r2,r2,3
 d03fa4c:	100b883a 	mov	r5,r2
 d03fa50:	e0bff517 	ldw	r2,-44(fp)
 d03fa54:	1080008b 	ldhu	r2,2(r2)
 d03fa58:	10bfffcc 	andi	r2,r2,65535
 d03fa5c:	1004d23a 	srli	r2,r2,8
 d03fa60:	10803fcc 	andi	r2,r2,255
 d03fa64:	1009883a 	mov	r4,r2
 d03fa68:	e0bff517 	ldw	r2,-44(fp)
 d03fa6c:	1080008b 	ldhu	r2,2(r2)
 d03fa70:	10bfffcc 	andi	r2,r2,65535
 d03fa74:	1004923a 	slli	r2,r2,8
 d03fa78:	1007883a 	mov	r3,r2
 d03fa7c:	00bfc004 	movi	r2,-256
 d03fa80:	1884703a 	and	r2,r3,r2
 d03fa84:	2084b03a 	or	r2,r4,r2
 d03fa88:	1007883a 	mov	r3,r2
 d03fa8c:	e0bff517 	ldw	r2,-44(fp)
 d03fa90:	10800003 	ldbu	r2,0(r2)
 d03fa94:	10803fcc 	andi	r2,r2,255
 d03fa98:	108003cc 	andi	r2,r2,15
 d03fa9c:	1085883a 	add	r2,r2,r2
 d03faa0:	1085883a 	add	r2,r2,r2
 d03faa4:	1885c83a 	sub	r2,r3,r2
 d03faa8:	2885883a 	add	r2,r5,r2
 d03faac:	1007883a 	mov	r3,r2
 d03fab0:	e0bffb17 	ldw	r2,-20(fp)
 d03fab4:	10c0040d 	sth	r3,16(r2)
 d03fab8:	00000a06 	br	d03fae4 <ip_reasm_process_subsequent_fragments+0x188>
      }
   else if (ftype == IP_FF)
 d03fabc:	e0bff217 	ldw	r2,-56(fp)
 d03fac0:	10800058 	cmpnei	r2,r2,1
 d03fac4:	1000071e 	bne	r2,zero,d03fae4 <ip_reasm_process_subsequent_fragments+0x188>
      {
      irep->l2_hdr = p->nb_buff;
 d03fac8:	e0bffa17 	ldw	r2,-24(fp)
 d03facc:	10c00117 	ldw	r3,4(r2)
 d03fad0:	e0bffb17 	ldw	r2,-20(fp)
 d03fad4:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 d03fad8:	e0fff517 	ldw	r3,-44(fp)
 d03fadc:	e0bffb17 	ldw	r2,-20(fp)
 d03fae0:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 d03fae4:	e1bff704 	addi	r6,fp,-36
 d03fae8:	e1fff804 	addi	r7,fp,-32
 d03faec:	e0bff904 	addi	r2,fp,-28
 d03faf0:	d8800015 	stw	r2,0(sp)
 d03faf4:	e0bff984 	addi	r2,fp,-26
 d03faf8:	d8800115 	stw	r2,4(sp)
 d03fafc:	e13ffa17 	ldw	r4,-24(fp)
 d03fb00:	e17ffb17 	ldw	r5,-20(fp)
 d03fb04:	d03f3cc0 	call	d03f3cc <ip_reasm_compute_overlap>
 d03fb08:	e0bff115 	stw	r2,-60(fp)
 d03fb0c:	e0bff117 	ldw	r2,-60(fp)
 d03fb10:	108000a0 	cmpeqi	r2,r2,2
 d03fb14:	10000e1e 	bne	r2,zero,d03fb50 <ip_reasm_process_subsequent_fragments+0x1f4>
      {
      switch (rc2)
 d03fb18:	e0fff117 	ldw	r3,-60(fp)
 d03fb1c:	e0ffff15 	stw	r3,-4(fp)
 d03fb20:	e13fff17 	ldw	r4,-4(fp)
 d03fb24:	2005003a 	cmpeq	r2,r4,zero
 d03fb28:	1000041e 	bne	r2,zero,d03fb3c <ip_reasm_process_subsequent_fragments+0x1e0>
 d03fb2c:	e0ffff17 	ldw	r3,-4(fp)
 d03fb30:	18800060 	cmpeqi	r2,r3,1
 d03fb34:	1000031e 	bne	r2,zero,d03fb44 <ip_reasm_process_subsequent_fragments+0x1e8>
 d03fb38:	00000506 	br	d03fb50 <ip_reasm_process_subsequent_fragments+0x1f4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 d03fb3c:	e03ffe15 	stw	zero,-8(fp)
 d03fb40:	0000e506 	br	d03fed8 <ip_reasm_process_subsequent_fragments+0x57c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 d03fb44:	013ffd84 	movi	r4,-10
 d03fb48:	e13ffe15 	stw	r4,-8(fp)
 d03fb4c:	0000e206 	br	d03fed8 <ip_reasm_process_subsequent_fragments+0x57c>
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 d03fb50:	e0bffa17 	ldw	r2,-24(fp)
 d03fb54:	10800217 	ldw	r2,8(r2)
 d03fb58:	113fffcc 	andi	r4,r2,65535
 d03fb5c:	d03ee6c0 	call	d03ee6c <ip_reasm_check_mem_useage>
 d03fb60:	e0bff315 	stw	r2,-52(fp)
 d03fb64:	e0bff317 	ldw	r2,-52(fp)
 d03fb68:	1005003a 	cmpeq	r2,r2,zero
 d03fb6c:	1000121e 	bne	r2,zero,d03fbb8 <ip_reasm_process_subsequent_fragments+0x25c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 d03fb70:	01000084 	movi	r4,2
 d03fb74:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free (p);
 d03fb78:	e13ffa17 	ldw	r4,-24(fp)
 d03fb7c:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03fb80:	01000084 	movi	r4,2
 d03fb84:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 d03fb88:	e13ffb17 	ldw	r4,-20(fp)
 d03fb8c:	d0403940 	call	d040394 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 d03fb90:	008341b4 	movhi	r2,3334
 d03fb94:	10b4eb04 	addi	r2,r2,-11348
 d03fb98:	10800f17 	ldw	r2,60(r2)
 d03fb9c:	10c00044 	addi	r3,r2,1
 d03fba0:	008341b4 	movhi	r2,3334
 d03fba4:	10b4eb04 	addi	r2,r2,-11348
 d03fba8:	10c00f15 	stw	r3,60(r2)
      return rc;
 d03fbac:	e0bff317 	ldw	r2,-52(fp)
 d03fbb0:	e0bffe15 	stw	r2,-8(fp)
 d03fbb4:	0000c806 	br	d03fed8 <ip_reasm_process_subsequent_fragments+0x57c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 d03fbb8:	e0bff70b 	ldhu	r2,-36(fp)
 d03fbbc:	10bfffcc 	andi	r2,r2,65535
 d03fbc0:	10800420 	cmpeqi	r2,r2,16
 d03fbc4:	1000121e 	bne	r2,zero,d03fc10 <ip_reasm_process_subsequent_fragments+0x2b4>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 d03fbc8:	e0fff817 	ldw	r3,-32(fp)
 d03fbcc:	e0bff70b 	ldhu	r2,-36(fp)
 d03fbd0:	10bfffcc 	andi	r2,r2,65535
 d03fbd4:	1085883a 	add	r2,r2,r2
 d03fbd8:	1085883a 	add	r2,r2,r2
 d03fbdc:	10c5883a 	add	r2,r2,r3
 d03fbe0:	10c00104 	addi	r3,r2,4
 d03fbe4:	e0bffa17 	ldw	r2,-24(fp)
 d03fbe8:	18800015 	stw	r2,0(r3)
      rfqp->frag_offset[index] = frag_offset;
 d03fbec:	e0fff817 	ldw	r3,-32(fp)
 d03fbf0:	e0bff70b 	ldhu	r2,-36(fp)
 d03fbf4:	10bfffcc 	andi	r2,r2,65535
 d03fbf8:	e13ff90b 	ldhu	r4,-28(fp)
 d03fbfc:	1085883a 	add	r2,r2,r2
 d03fc00:	10c5883a 	add	r2,r2,r3
 d03fc04:	10801104 	addi	r2,r2,68
 d03fc08:	1100000d 	sth	r4,0(r2)
 d03fc0c:	00003c06 	br	d03fd00 <ip_reasm_process_subsequent_fragments+0x3a4>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 d03fc10:	e0bffa17 	ldw	r2,-24(fp)
 d03fc14:	10800217 	ldw	r2,8(r2)
 d03fc18:	10801904 	addi	r2,r2,100
 d03fc1c:	113fffcc 	andi	r4,r2,65535
 d03fc20:	d03ee6c0 	call	d03ee6c <ip_reasm_check_mem_useage>
 d03fc24:	e0bff315 	stw	r2,-52(fp)
 d03fc28:	e0bff317 	ldw	r2,-52(fp)
 d03fc2c:	1005003a 	cmpeq	r2,r2,zero
 d03fc30:	1000121e 	bne	r2,zero,d03fc7c <ip_reasm_process_subsequent_fragments+0x320>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 d03fc34:	01000084 	movi	r4,2
 d03fc38:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free (p);
 d03fc3c:	e13ffa17 	ldw	r4,-24(fp)
 d03fc40:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03fc44:	01000084 	movi	r4,2
 d03fc48:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 d03fc4c:	e13ffb17 	ldw	r4,-20(fp)
 d03fc50:	d0403940 	call	d040394 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 d03fc54:	008341b4 	movhi	r2,3334
 d03fc58:	10b4eb04 	addi	r2,r2,-11348
 d03fc5c:	10800f17 	ldw	r2,60(r2)
 d03fc60:	10c00044 	addi	r3,r2,1
 d03fc64:	008341b4 	movhi	r2,3334
 d03fc68:	10b4eb04 	addi	r2,r2,-11348
 d03fc6c:	10c00f15 	stw	r3,60(r2)
         return rc;
 d03fc70:	e0fff317 	ldw	r3,-52(fp)
 d03fc74:	e0fffe15 	stw	r3,-8(fp)
 d03fc78:	00009706 	br	d03fed8 <ip_reasm_process_subsequent_fragments+0x57c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 d03fc7c:	01001904 	movi	r4,100
 d03fc80:	d029e2c0 	call	d029e2c <npalloc>
 d03fc84:	e0bff415 	stw	r2,-48(fp)
      if (new_rfqp == 0)
 d03fc88:	e0bff417 	ldw	r2,-48(fp)
 d03fc8c:	1004c03a 	cmpne	r2,r2,zero
 d03fc90:	1000121e 	bne	r2,zero,d03fcdc <ip_reasm_process_subsequent_fragments+0x380>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 d03fc94:	01000084 	movi	r4,2
 d03fc98:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free (p);
 d03fc9c:	e13ffa17 	ldw	r4,-24(fp)
 d03fca0:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03fca4:	01000084 	movi	r4,2
 d03fca8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 d03fcac:	e13ffb17 	ldw	r4,-20(fp)
 d03fcb0:	d0403940 	call	d040394 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 d03fcb4:	008341b4 	movhi	r2,3334
 d03fcb8:	10b4eb04 	addi	r2,r2,-11348
 d03fcbc:	10800f17 	ldw	r2,60(r2)
 d03fcc0:	10c00044 	addi	r3,r2,1
 d03fcc4:	008341b4 	movhi	r2,3334
 d03fcc8:	10b4eb04 	addi	r2,r2,-11348
 d03fccc:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 d03fcd0:	013ffa84 	movi	r4,-22
 d03fcd4:	e13ffe15 	stw	r4,-8(fp)
 d03fcd8:	00007f06 	br	d03fed8 <ip_reasm_process_subsequent_fragments+0x57c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 d03fcdc:	e0fff417 	ldw	r3,-48(fp)
 d03fce0:	e0bffa17 	ldw	r2,-24(fp)
 d03fce4:	18800115 	stw	r2,4(r3)
         new_rfqp->frag_offset[0] = frag_offset;
 d03fce8:	e0fff90b 	ldhu	r3,-28(fp)
 d03fcec:	e0bff417 	ldw	r2,-48(fp)
 d03fcf0:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 d03fcf4:	e0fff817 	ldw	r3,-32(fp)
 d03fcf8:	e0bff417 	ldw	r2,-48(fp)
 d03fcfc:	18800015 	stw	r2,0(r3)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 d03fd00:	e0bff983 	ldbu	r2,-26(fp)
 d03fd04:	10803fcc 	andi	r2,r2,255
 d03fd08:	1005003a 	cmpeq	r2,r2,zero
 d03fd0c:	1000161e 	bne	r2,zero,d03fd68 <ip_reasm_process_subsequent_fragments+0x40c>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 d03fd10:	e13ffb17 	ldw	r4,-20(fp)
 d03fd14:	d04055c0 	call	d04055c <ip_reasm_mark_compact_rfq>
 d03fd18:	e0bff315 	stw	r2,-52(fp)
 d03fd1c:	e0bff317 	ldw	r2,-52(fp)
 d03fd20:	1005003a 	cmpeq	r2,r2,zero
 d03fd24:	1000101e 	bne	r2,zero,d03fd68 <ip_reasm_process_subsequent_fragments+0x40c>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 d03fd28:	01000084 	movi	r4,2
 d03fd2c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free (p);
 d03fd30:	e13ffa17 	ldw	r4,-24(fp)
 d03fd34:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03fd38:	01000084 	movi	r4,2
 d03fd3c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 d03fd40:	008341b4 	movhi	r2,3334
 d03fd44:	10b4eb04 	addi	r2,r2,-11348
 d03fd48:	10800f17 	ldw	r2,60(r2)
 d03fd4c:	10c00044 	addi	r3,r2,1
 d03fd50:	008341b4 	movhi	r2,3334
 d03fd54:	10b4eb04 	addi	r2,r2,-11348
 d03fd58:	10c00f15 	stw	r3,60(r2)
            return rc;
 d03fd5c:	e0bff317 	ldw	r2,-52(fp)
 d03fd60:	e0bffe15 	stw	r2,-8(fp)
 d03fd64:	00005c06 	br	d03fed8 <ip_reasm_process_subsequent_fragments+0x57c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 d03fd68:	e0bffb17 	ldw	r2,-20(fp)
 d03fd6c:	10c0048b 	ldhu	r3,18(r2)
 d03fd70:	e0bffa17 	ldw	r2,-24(fp)
 d03fd74:	10800417 	ldw	r2,16(r2)
 d03fd78:	1885883a 	add	r2,r3,r2
 d03fd7c:	1007883a 	mov	r3,r2
 d03fd80:	e0bffb17 	ldw	r2,-20(fp)
 d03fd84:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 d03fd88:	e0bffa17 	ldw	r2,-24(fp)
 d03fd8c:	10800217 	ldw	r2,8(r2)
 d03fd90:	e0bffd0d 	sth	r2,-12(fp)
 d03fd94:	e0bff417 	ldw	r2,-48(fp)
 d03fd98:	1004c03a 	cmpne	r2,r2,zero
 d03fd9c:	1000021e 	bne	r2,zero,d03fda8 <ip_reasm_process_subsequent_fragments+0x44c>
 d03fda0:	e03ffc0d 	sth	zero,-16(fp)
 d03fda4:	00000206 	br	d03fdb0 <ip_reasm_process_subsequent_fragments+0x454>
 d03fda8:	00c01904 	movi	r3,100
 d03fdac:	e0fffc0d 	sth	r3,-16(fp)
 d03fdb0:	e13ffd0b 	ldhu	r4,-12(fp)
 d03fdb4:	e0fffc0b 	ldhu	r3,-16(fp)
 d03fdb8:	20c5883a 	add	r2,r4,r3
 d03fdbc:	113fffcc 	andi	r4,r2,65535
 d03fdc0:	d03ef040 	call	d03ef04 <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 d03fdc4:	e0bffb17 	ldw	r2,-20(fp)
 d03fdc8:	1080040b 	ldhu	r2,16(r2)
 d03fdcc:	10bfffcc 	andi	r2,r2,65535
 d03fdd0:	1005003a 	cmpeq	r2,r2,zero
 d03fdd4:	10003f1e 	bne	r2,zero,d03fed4 <ip_reasm_process_subsequent_fragments+0x578>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 d03fdd8:	e0bffb17 	ldw	r2,-20(fp)
 d03fddc:	10c0048b 	ldhu	r3,18(r2)
 d03fde0:	e0bffb17 	ldw	r2,-20(fp)
 d03fde4:	1080040b 	ldhu	r2,16(r2)
 d03fde8:	18ffffcc 	andi	r3,r3,65535
 d03fdec:	10bfffcc 	andi	r2,r2,65535
 d03fdf0:	1880381e 	bne	r3,r2,d03fed4 <ip_reasm_process_subsequent_fragments+0x578>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 d03fdf4:	e0bffb17 	ldw	r2,-20(fp)
 d03fdf8:	10802017 	ldw	r2,128(r2)
 d03fdfc:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 d03fe00:	01000084 	movi	r4,2
 d03fe04:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 d03fe08:	e0bffb17 	ldw	r2,-20(fp)
 d03fe0c:	1080040b 	ldhu	r2,16(r2)
 d03fe10:	113fffcc 	andi	r4,r2,65535
 d03fe14:	e0bffb17 	ldw	r2,-20(fp)
 d03fe18:	10802017 	ldw	r2,128(r2)
 d03fe1c:	1007883a 	mov	r3,r2
 d03fe20:	e0bffb17 	ldw	r2,-20(fp)
 d03fe24:	10801f17 	ldw	r2,124(r2)
 d03fe28:	1885c83a 	sub	r2,r3,r2
 d03fe2c:	2087883a 	add	r3,r4,r2
 d03fe30:	e0bff517 	ldw	r2,-44(fp)
 d03fe34:	10800003 	ldbu	r2,0(r2)
 d03fe38:	10803fcc 	andi	r2,r2,255
 d03fe3c:	108003cc 	andi	r2,r2,15
 d03fe40:	1085883a 	add	r2,r2,r2
 d03fe44:	1085883a 	add	r2,r2,r2
 d03fe48:	1885883a 	add	r2,r3,r2
 d03fe4c:	1009883a 	mov	r4,r2
 d03fe50:	d0287a40 	call	d0287a4 <pk_alloc>
 d03fe54:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d03fe58:	01000084 	movi	r4,2
 d03fe5c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 d03fe60:	e0bff617 	ldw	r2,-40(fp)
 d03fe64:	1004c03a 	cmpne	r2,r2,zero
 d03fe68:	10000c1e 	bne	r2,zero,d03fe9c <ip_reasm_process_subsequent_fragments+0x540>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 d03fe6c:	e13ffb17 	ldw	r4,-20(fp)
 d03fe70:	d0403940 	call	d040394 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 d03fe74:	008341b4 	movhi	r2,3334
 d03fe78:	10b4eb04 	addi	r2,r2,-11348
 d03fe7c:	10800f17 	ldw	r2,60(r2)
 d03fe80:	10c00044 	addi	r3,r2,1
 d03fe84:	008341b4 	movhi	r2,3334
 d03fe88:	10b4eb04 	addi	r2,r2,-11348
 d03fe8c:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 d03fe90:	013ffac4 	movi	r4,-21
 d03fe94:	e13ffe15 	stw	r4,-8(fp)
 d03fe98:	00000f06 	br	d03fed8 <ip_reasm_process_subsequent_fragments+0x57c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 d03fe9c:	e13ff617 	ldw	r4,-40(fp)
 d03fea0:	e17ffb17 	ldw	r5,-20(fp)
 d03fea4:	d03ff540 	call	d03ff54 <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 d03fea8:	e13ffb17 	ldw	r4,-20(fp)
 d03feac:	d0403940 	call	d040394 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 d03feb0:	008341b4 	movhi	r2,3334
 d03feb4:	10b4eb04 	addi	r2,r2,-11348
 d03feb8:	10800e17 	ldw	r2,56(r2)
 d03febc:	10c00044 	addi	r3,r2,1
 d03fec0:	008341b4 	movhi	r2,3334
 d03fec4:	10b4eb04 	addi	r2,r2,-11348
 d03fec8:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 d03fecc:	e13ff617 	ldw	r4,-40(fp)
 d03fed0:	d04144c0 	call	d04144c <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 d03fed4:	e03ffe15 	stw	zero,-8(fp)
 d03fed8:	e0bffe17 	ldw	r2,-8(fp)
}
 d03fedc:	e037883a 	mov	sp,fp
 d03fee0:	dfc00117 	ldw	ra,4(sp)
 d03fee4:	df000017 	ldw	fp,0(sp)
 d03fee8:	dec00204 	addi	sp,sp,8
 d03feec:	f800283a 	ret

0d03fef0 <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 d03fef0:	defffc04 	addi	sp,sp,-16
 d03fef4:	df000315 	stw	fp,12(sp)
 d03fef8:	df000304 	addi	fp,sp,12
 d03fefc:	e13ffe15 	stw	r4,-8(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d03ff00:	d0a0c817 	ldw	r2,-31968(gp)
 d03ff04:	e0bffd15 	stw	r2,-12(fp)
 d03ff08:	00000906 	br	d03ff30 <ip_reasm_find_ire+0x40>
      {
      if (tmpp == irep) 
 d03ff0c:	e0fffd17 	ldw	r3,-12(fp)
 d03ff10:	e0bffe17 	ldw	r2,-8(fp)
 d03ff14:	1880031e 	bne	r3,r2,d03ff24 <ip_reasm_find_ire+0x34>
         {
         return IPREASM_TRUE;
 d03ff18:	00800044 	movi	r2,1
 d03ff1c:	e0bfff15 	stw	r2,-4(fp)
 d03ff20:	00000706 	br	d03ff40 <ip_reasm_find_ire+0x50>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d03ff24:	e0bffd17 	ldw	r2,-12(fp)
 d03ff28:	10800017 	ldw	r2,0(r2)
 d03ff2c:	e0bffd15 	stw	r2,-12(fp)
 d03ff30:	e0bffd17 	ldw	r2,-12(fp)
 d03ff34:	1004c03a 	cmpne	r2,r2,zero
 d03ff38:	103ff41e 	bne	r2,zero,d03ff0c <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 d03ff3c:	e03fff15 	stw	zero,-4(fp)
 d03ff40:	e0bfff17 	ldw	r2,-4(fp)
}
 d03ff44:	e037883a 	mov	sp,fp
 d03ff48:	df000017 	ldw	fp,0(sp)
 d03ff4c:	dec00104 	addi	sp,sp,4
 d03ff50:	f800283a 	ret

0d03ff54 <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 d03ff54:	defff404 	addi	sp,sp,-48
 d03ff58:	dfc00b15 	stw	ra,44(sp)
 d03ff5c:	df000a15 	stw	fp,40(sp)
 d03ff60:	df000a04 	addi	fp,sp,40
 d03ff64:	e13ffe15 	stw	r4,-8(fp)
 d03ff68:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 d03ff6c:	e03ff615 	stw	zero,-40(fp)

   pip = (struct ip *) irep->l3_hdr;
 d03ff70:	e0bfff17 	ldw	r2,-4(fp)
 d03ff74:	10802017 	ldw	r2,128(r2)
 d03ff78:	e0bffd15 	stw	r2,-12(fp)
   iphlen = ip_hlen (pip);
 d03ff7c:	e0bffd17 	ldw	r2,-12(fp)
 d03ff80:	10800003 	ldbu	r2,0(r2)
 d03ff84:	108003cc 	andi	r2,r2,15
 d03ff88:	1085883a 	add	r2,r2,r2
 d03ff8c:	1085883a 	add	r2,r2,r2
 d03ff90:	e0bff805 	stb	r2,-32(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 d03ff94:	e0bfff17 	ldw	r2,-4(fp)
 d03ff98:	10802017 	ldw	r2,128(r2)
 d03ff9c:	1007883a 	mov	r3,r2
 d03ffa0:	e0bfff17 	ldw	r2,-4(fp)
 d03ffa4:	10801f17 	ldw	r2,124(r2)
 d03ffa8:	1885c83a 	sub	r2,r3,r2
 d03ffac:	1007883a 	mov	r3,r2
 d03ffb0:	e0bff803 	ldbu	r2,-32(fp)
 d03ffb4:	1885883a 	add	r2,r3,r2
 d03ffb8:	e0bffc05 	stb	r2,-16(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 d03ffbc:	e0bffe17 	ldw	r2,-8(fp)
 d03ffc0:	11000117 	ldw	r4,4(r2)
 d03ffc4:	e0bfff17 	ldw	r2,-4(fp)
 d03ffc8:	10801f17 	ldw	r2,124(r2)
 d03ffcc:	e0fffc03 	ldbu	r3,-16(fp)
 d03ffd0:	100b883a 	mov	r5,r2
 d03ffd4:	180d883a 	mov	r6,r3
 d03ffd8:	d0027000 	call	d002700 <memcpy>

   rfqp = &(irep->rfq);
 d03ffdc:	e0bfff17 	ldw	r2,-4(fp)
 d03ffe0:	10800604 	addi	r2,r2,24
 d03ffe4:	e0bffb15 	stw	r2,-20(fp)
   writep = reassy_pkt->nb_buff + offset;
 d03ffe8:	e0bffe17 	ldw	r2,-8(fp)
 d03ffec:	10c00117 	ldw	r3,4(r2)
 d03fff0:	e0bffc03 	ldbu	r2,-16(fp)
 d03fff4:	1885883a 	add	r2,r3,r2
 d03fff8:	e0bff715 	stw	r2,-36(fp)

   while (rfqp)
 d03fffc:	00004606 	br	d040118 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1c4>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d040000:	e03ffa0d 	sth	zero,-24(fp)
 d040004:	00003e06 	br	d040100 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1ac>
         {
         if ((p = rfqp->bufp [i]) != 0)
 d040008:	e0bffa0b 	ldhu	r2,-24(fp)
 d04000c:	e0fffb17 	ldw	r3,-20(fp)
 d040010:	1085883a 	add	r2,r2,r2
 d040014:	1085883a 	add	r2,r2,r2
 d040018:	10c5883a 	add	r2,r2,r3
 d04001c:	10800104 	addi	r2,r2,4
 d040020:	10800017 	ldw	r2,0(r2)
 d040024:	e0bff915 	stw	r2,-28(fp)
 d040028:	e0bff917 	ldw	r2,-28(fp)
 d04002c:	1005003a 	cmpeq	r2,r2,zero
 d040030:	1000291e 	bne	r2,zero,d0400d8 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x184>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 d040034:	e0bffa0b 	ldhu	r2,-24(fp)
 d040038:	e0fffb17 	ldw	r3,-20(fp)
 d04003c:	1085883a 	add	r2,r2,r2
 d040040:	10c5883a 	add	r2,r2,r3
 d040044:	10801104 	addi	r2,r2,68
 d040048:	1080000b 	ldhu	r2,0(r2)
 d04004c:	10bfffcc 	andi	r2,r2,65535
 d040050:	1007883a 	mov	r3,r2
 d040054:	e0bff717 	ldw	r2,-36(fp)
 d040058:	1887883a 	add	r3,r3,r2
 d04005c:	e0bff917 	ldw	r2,-28(fp)
 d040060:	11400317 	ldw	r5,12(r2)
 d040064:	e0bff917 	ldw	r2,-28(fp)
 d040068:	10800417 	ldw	r2,16(r2)
 d04006c:	1809883a 	mov	r4,r3
 d040070:	100d883a 	mov	r6,r2
 d040074:	d0027000 	call	d002700 <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 d040078:	e0bff617 	ldw	r2,-40(fp)
 d04007c:	1004c03a 	cmpne	r2,r2,zero
 d040080:	1000031e 	bne	r2,zero,d040090 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x13c>
 d040084:	e0bff917 	ldw	r2,-28(fp)
 d040088:	e0bff615 	stw	r2,-40(fp)
 d04008c:	00000a06 	br	d0400b8 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x164>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 d040090:	e0bff917 	ldw	r2,-28(fp)
 d040094:	10800217 	ldw	r2,8(r2)
 d040098:	113fffcc 	andi	r4,r2,65535
 d04009c:	d03efac0 	call	d03efac <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 d0400a0:	01000084 	movi	r4,2
 d0400a4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
               pk_free (p);
 d0400a8:	e13ff917 	ldw	r4,-28(fp)
 d0400ac:	d028b380 	call	d028b38 <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d0400b0:	01000084 	movi	r4,2
 d0400b4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 d0400b8:	e0bffa0b 	ldhu	r2,-24(fp)
 d0400bc:	e0fffb17 	ldw	r3,-20(fp)
 d0400c0:	1085883a 	add	r2,r2,r2
 d0400c4:	1085883a 	add	r2,r2,r2
 d0400c8:	10c5883a 	add	r2,r2,r3
 d0400cc:	10800104 	addi	r2,r2,4
 d0400d0:	10000015 	stw	zero,0(r2)
 d0400d4:	00000706 	br	d0400f4 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1a0>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 d0400d8:	e0bfff17 	ldw	r2,-4(fp)
 d0400dc:	10802103 	ldbu	r2,132(r2)
 d0400e0:	10803fcc 	andi	r2,r2,255
 d0400e4:	1080004c 	andi	r2,r2,1
 d0400e8:	10803fcc 	andi	r2,r2,255
 d0400ec:	1004c03a 	cmpne	r2,r2,zero
 d0400f0:	1000061e 	bne	r2,zero,d04010c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b8>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d0400f4:	e0bffa0b 	ldhu	r2,-24(fp)
 d0400f8:	10800044 	addi	r2,r2,1
 d0400fc:	e0bffa0d 	sth	r2,-24(fp)
 d040100:	e0bffa0b 	ldhu	r2,-24(fp)
 d040104:	10800430 	cmpltui	r2,r2,16
 d040108:	103fbf1e 	bne	r2,zero,d040008 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb4>
               break;
               }
            }
          }

      rfqp = rfqp->next;
 d04010c:	e0bffb17 	ldw	r2,-20(fp)
 d040110:	10800017 	ldw	r2,0(r2)
 d040114:	e0bffb15 	stw	r2,-20(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 d040118:	e0bffb17 	ldw	r2,-20(fp)
 d04011c:	1004c03a 	cmpne	r2,r2,zero
 d040120:	103fb71e 	bne	r2,zero,d040000 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xac>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 d040124:	e0bffe17 	ldw	r2,-8(fp)
 d040128:	11000117 	ldw	r4,4(r2)
 d04012c:	e0bfff17 	ldw	r2,-4(fp)
 d040130:	10802017 	ldw	r2,128(r2)
 d040134:	1007883a 	mov	r3,r2
 d040138:	e0bfff17 	ldw	r2,-4(fp)
 d04013c:	10801f17 	ldw	r2,124(r2)
 d040140:	1885c83a 	sub	r2,r3,r2
 d040144:	2087883a 	add	r3,r4,r2
 d040148:	e0bffe17 	ldw	r2,-8(fp)
 d04014c:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 d040150:	e0bfff17 	ldw	r2,-4(fp)
 d040154:	1080040b 	ldhu	r2,16(r2)
 d040158:	10ffffcc 	andi	r3,r2,65535
 d04015c:	e0bff803 	ldbu	r2,-32(fp)
 d040160:	1885883a 	add	r2,r3,r2
 d040164:	1007883a 	mov	r3,r2
 d040168:	e0bffe17 	ldw	r2,-8(fp)
 d04016c:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 d040170:	00834174 	movhi	r2,3333
 d040174:	108ac904 	addi	r2,r2,11044
 d040178:	10800017 	ldw	r2,0(r2)
 d04017c:	1007883a 	mov	r3,r2
 d040180:	e0bffe17 	ldw	r2,-8(fp)
 d040184:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 d040188:	e0bffe17 	ldw	r2,-8(fp)
 d04018c:	10c00a17 	ldw	r3,40(r2)
 d040190:	e0bff617 	ldw	r2,-40(fp)
 d040194:	10800a17 	ldw	r2,40(r2)
 d040198:	108000cc 	andi	r2,r2,3
 d04019c:	1886b03a 	or	r3,r3,r2
 d0401a0:	e0bffe17 	ldw	r2,-8(fp)
 d0401a4:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 d0401a8:	e0bff617 	ldw	r2,-40(fp)
 d0401ac:	10c00617 	ldw	r3,24(r2)
 d0401b0:	e0bffe17 	ldw	r2,-8(fp)
 d0401b4:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 d0401b8:	e0bff617 	ldw	r2,-40(fp)
 d0401bc:	10c0080b 	ldhu	r3,32(r2)
 d0401c0:	e0bffe17 	ldw	r2,-8(fp)
 d0401c4:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 d0401c8:	e0bff617 	ldw	r2,-40(fp)
 d0401cc:	10800217 	ldw	r2,8(r2)
 d0401d0:	113fffcc 	andi	r4,r2,65535
 d0401d4:	d03efac0 	call	d03efac <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 d0401d8:	01000084 	movi	r4,2
 d0401dc:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 d0401e0:	e13ff617 	ldw	r4,-40(fp)
 d0401e4:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 d0401e8:	01000084 	movi	r4,2
 d0401ec:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 d0401f0:	e0bffe17 	ldw	r2,-8(fp)
 d0401f4:	10800317 	ldw	r2,12(r2)
 d0401f8:	e0bffd15 	stw	r2,-12(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 d0401fc:	e0bffe17 	ldw	r2,-8(fp)
 d040200:	10800417 	ldw	r2,16(r2)
 d040204:	1004d23a 	srli	r2,r2,8
 d040208:	10803fcc 	andi	r2,r2,255
 d04020c:	1009883a 	mov	r4,r2
 d040210:	e0bffe17 	ldw	r2,-8(fp)
 d040214:	10800417 	ldw	r2,16(r2)
 d040218:	1004923a 	slli	r2,r2,8
 d04021c:	1007883a 	mov	r3,r2
 d040220:	00bfc004 	movi	r2,-256
 d040224:	1884703a 	and	r2,r3,r2
 d040228:	2084b03a 	or	r2,r4,r2
 d04022c:	1007883a 	mov	r3,r2
 d040230:	e0bffd17 	ldw	r2,-12(fp)
 d040234:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 d040238:	e0bffd17 	ldw	r2,-12(fp)
 d04023c:	10c0018b 	ldhu	r3,6(r2)
 d040240:	00bff7c4 	movi	r2,-33
 d040244:	1884703a 	and	r2,r3,r2
 d040248:	1007883a 	mov	r3,r2
 d04024c:	e0bffd17 	ldw	r2,-12(fp)
 d040250:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 d040254:	e0bffd17 	ldw	r2,-12(fp)
 d040258:	1080018b 	ldhu	r2,6(r2)
 d04025c:	1080380c 	andi	r2,r2,224
 d040260:	1007883a 	mov	r3,r2
 d040264:	e0bffd17 	ldw	r2,-12(fp)
 d040268:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 d04026c:	e0bffd17 	ldw	r2,-12(fp)
 d040270:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 d040274:	e0bff803 	ldbu	r2,-32(fp)
 d040278:	1004d07a 	srli	r2,r2,1
 d04027c:	11403fcc 	andi	r5,r2,255
 d040280:	e13ffd17 	ldw	r4,-12(fp)
 d040284:	d0242340 	call	d024234 <cksum>
 d040288:	0084303a 	nor	r2,zero,r2
 d04028c:	1007883a 	mov	r3,r2
 d040290:	e0bffd17 	ldw	r2,-12(fp)
 d040294:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 d040298:	0005883a 	mov	r2,zero
}
 d04029c:	e037883a 	mov	sp,fp
 d0402a0:	dfc00117 	ldw	ra,4(sp)
 d0402a4:	df000017 	ldw	fp,0(sp)
 d0402a8:	dec00204 	addi	sp,sp,8
 d0402ac:	f800283a 	ret

0d0402b0 <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 d0402b0:	defffc04 	addi	sp,sp,-16
 d0402b4:	dfc00315 	stw	ra,12(sp)
 d0402b8:	df000215 	stw	fp,8(sp)
 d0402bc:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 d0402c0:	0009883a 	mov	r4,zero
 d0402c4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 d0402c8:	d0a0c817 	ldw	r2,-31968(gp)
 d0402cc:	e0bfff15 	stw	r2,-4(fp)
 d0402d0:	00002006 	br	d040354 <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 d0402d4:	e0bfff17 	ldw	r2,-4(fp)
 d0402d8:	10800017 	ldw	r2,0(r2)
 d0402dc:	e0bffe15 	stw	r2,-8(fp)
      ++tmpp->age;
 d0402e0:	e0bfff17 	ldw	r2,-4(fp)
 d0402e4:	10800517 	ldw	r2,20(r2)
 d0402e8:	10c00044 	addi	r3,r2,1
 d0402ec:	e0bfff17 	ldw	r2,-4(fp)
 d0402f0:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 d0402f4:	e0bfff17 	ldw	r2,-4(fp)
 d0402f8:	10800517 	ldw	r2,20(r2)
 d0402fc:	10801e18 	cmpnei	r2,r2,120
 d040300:	1000121e 	bne	r2,zero,d04034c <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 d040304:	008341b4 	movhi	r2,3334
 d040308:	10b4ff04 	addi	r2,r2,-11268
 d04030c:	10800117 	ldw	r2,4(r2)
 d040310:	10c00044 	addi	r3,r2,1
 d040314:	008341b4 	movhi	r2,3334
 d040318:	10b4ff04 	addi	r2,r2,-11268
 d04031c:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 d040320:	e13fff17 	ldw	r4,-4(fp)
 d040324:	d0409ec0 	call	d0409ec <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 d040328:	e13fff17 	ldw	r4,-4(fp)
 d04032c:	d0403940 	call	d040394 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 d040330:	008341b4 	movhi	r2,3334
 d040334:	10b4eb04 	addi	r2,r2,-11348
 d040338:	10800f17 	ldw	r2,60(r2)
 d04033c:	10c00044 	addi	r3,r2,1
 d040340:	008341b4 	movhi	r2,3334
 d040344:	10b4eb04 	addi	r2,r2,-11348
 d040348:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 d04034c:	e0bffe17 	ldw	r2,-8(fp)
 d040350:	e0bfff15 	stw	r2,-4(fp)
 d040354:	e0bfff17 	ldw	r2,-4(fp)
 d040358:	1004c03a 	cmpne	r2,r2,zero
 d04035c:	103fdd1e 	bne	r2,zero,d0402d4 <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 d040360:	00834174 	movhi	r2,3333
 d040364:	108ac904 	addi	r2,r2,11044
 d040368:	10800017 	ldw	r2,0(r2)
 d04036c:	10801904 	addi	r2,r2,100
 d040370:	d0a0c915 	stw	r2,-31964(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 d040374:	0009883a 	mov	r4,zero
 d040378:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 d04037c:	0005883a 	mov	r2,zero
}
 d040380:	e037883a 	mov	sp,fp
 d040384:	dfc00117 	ldw	ra,4(sp)
 d040388:	df000017 	ldw	fp,0(sp)
 d04038c:	dec00204 	addi	sp,sp,8
 d040390:	f800283a 	ret

0d040394 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 d040394:	defff504 	addi	sp,sp,-44
 d040398:	dfc00a15 	stw	ra,40(sp)
 d04039c:	df000915 	stw	fp,36(sp)
 d0403a0:	df000904 	addi	fp,sp,36
 d0403a4:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 d0403a8:	e03ff715 	stw	zero,-36(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d0403ac:	d0a0c817 	ldw	r2,-31968(gp)
 d0403b0:	e0bff815 	stw	r2,-32(fp)
 d0403b4:	00001406 	br	d040408 <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 d0403b8:	e0fff817 	ldw	r3,-32(fp)
 d0403bc:	e0bffe17 	ldw	r2,-8(fp)
 d0403c0:	18800c1e 	bne	r3,r2,d0403f4 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 d0403c4:	d0e0c817 	ldw	r3,-31968(gp)
 d0403c8:	e0bff817 	ldw	r2,-32(fp)
 d0403cc:	10c0041e 	bne	r2,r3,d0403e0 <ip_reasm_delete_ire+0x4c>
 d0403d0:	e0bffe17 	ldw	r2,-8(fp)
 d0403d4:	10800017 	ldw	r2,0(r2)
 d0403d8:	d0a0c815 	stw	r2,-31968(gp)
 d0403dc:	00000d06 	br	d040414 <ip_reasm_delete_ire+0x80>
         else prev_tmpp->next = irep->next;
 d0403e0:	e0bffe17 	ldw	r2,-8(fp)
 d0403e4:	10c00017 	ldw	r3,0(r2)
 d0403e8:	e0bff717 	ldw	r2,-36(fp)
 d0403ec:	10c00015 	stw	r3,0(r2)
         break;
 d0403f0:	00000806 	br	d040414 <ip_reasm_delete_ire+0x80>
         }
      prev_tmpp = tmpp;
 d0403f4:	e0bff817 	ldw	r2,-32(fp)
 d0403f8:	e0bff715 	stw	r2,-36(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d0403fc:	e0bff817 	ldw	r2,-32(fp)
 d040400:	10800017 	ldw	r2,0(r2)
 d040404:	e0bff815 	stw	r2,-32(fp)
 d040408:	e0bff817 	ldw	r2,-32(fp)
 d04040c:	1004c03a 	cmpne	r2,r2,zero
 d040410:	103fe91e 	bne	r2,zero,d0403b8 <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 d040414:	e0bff817 	ldw	r2,-32(fp)
 d040418:	1004c03a 	cmpne	r2,r2,zero
 d04041c:	10000a1e 	bne	r2,zero,d040448 <ip_reasm_delete_ire+0xb4>
      {
      ++ire_stats.bad_irep;
 d040420:	008341b4 	movhi	r2,3334
 d040424:	10b4ff04 	addi	r2,r2,-11268
 d040428:	10800017 	ldw	r2,0(r2)
 d04042c:	10c00044 	addi	r3,r2,1
 d040430:	008341b4 	movhi	r2,3334
 d040434:	10b4ff04 	addi	r2,r2,-11268
 d040438:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 d04043c:	00bffd84 	movi	r2,-10
 d040440:	e0bfff15 	stw	r2,-4(fp)
 d040444:	00003f06 	br	d040544 <ip_reasm_delete_ire+0x1b0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 d040448:	e0bffe17 	ldw	r2,-8(fp)
 d04044c:	10800604 	addi	r2,r2,24
 d040450:	e0bffc15 	stw	r2,-16(fp)
 d040454:	e0bffc17 	ldw	r2,-16(fp)
 d040458:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 d04045c:	00003106 	br	d040524 <ip_reasm_delete_ire+0x190>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d040460:	e03ffa0d 	sth	zero,-24(fp)
 d040464:	00002006 	br	d0404e8 <ip_reasm_delete_ire+0x154>
         {
         if ((p = rfqp->bufp [i]) != 0)
 d040468:	e0bffa0b 	ldhu	r2,-24(fp)
 d04046c:	e0fffd17 	ldw	r3,-12(fp)
 d040470:	1085883a 	add	r2,r2,r2
 d040474:	1085883a 	add	r2,r2,r2
 d040478:	10c5883a 	add	r2,r2,r3
 d04047c:	10800104 	addi	r2,r2,4
 d040480:	10800017 	ldw	r2,0(r2)
 d040484:	e0bff915 	stw	r2,-28(fp)
 d040488:	e0bff917 	ldw	r2,-28(fp)
 d04048c:	1005003a 	cmpeq	r2,r2,zero
 d040490:	10000b1e 	bne	r2,zero,d0404c0 <ip_reasm_delete_ire+0x12c>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 d040494:	e0bff917 	ldw	r2,-28(fp)
 d040498:	10800217 	ldw	r2,8(r2)
 d04049c:	113fffcc 	andi	r4,r2,65535
 d0404a0:	d03efac0 	call	d03efac <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 d0404a4:	01000084 	movi	r4,2
 d0404a8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free (p);
 d0404ac:	e13ff917 	ldw	r4,-28(fp)
 d0404b0:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 d0404b4:	01000084 	movi	r4,2
 d0404b8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
 d0404bc:	00000706 	br	d0404dc <ip_reasm_delete_ire+0x148>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 d0404c0:	e0bffe17 	ldw	r2,-8(fp)
 d0404c4:	10802103 	ldbu	r2,132(r2)
 d0404c8:	10803fcc 	andi	r2,r2,255
 d0404cc:	1080004c 	andi	r2,r2,1
 d0404d0:	10803fcc 	andi	r2,r2,255
 d0404d4:	1004c03a 	cmpne	r2,r2,zero
 d0404d8:	1000061e 	bne	r2,zero,d0404f4 <ip_reasm_delete_ire+0x160>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d0404dc:	e0bffa0b 	ldhu	r2,-24(fp)
 d0404e0:	10800044 	addi	r2,r2,1
 d0404e4:	e0bffa0d 	sth	r2,-24(fp)
 d0404e8:	e0bffa0b 	ldhu	r2,-24(fp)
 d0404ec:	10800430 	cmpltui	r2,r2,16
 d0404f0:	103fdd1e 	bne	r2,zero,d040468 <ip_reasm_delete_ire+0xd4>
               break;
               }
            }
          }

       prev_rfqp = rfqp;
 d0404f4:	e0bffd17 	ldw	r2,-12(fp)
 d0404f8:	e0bffb15 	stw	r2,-20(fp)
       rfqp = rfqp->next;
 d0404fc:	e0bffd17 	ldw	r2,-12(fp)
 d040500:	10800017 	ldw	r2,0(r2)
 d040504:	e0bffd15 	stw	r2,-12(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 d040508:	e0fffb17 	ldw	r3,-20(fp)
 d04050c:	e0bffc17 	ldw	r2,-16(fp)
 d040510:	18800426 	beq	r3,r2,d040524 <ip_reasm_delete_ire+0x190>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 d040514:	01001904 	movi	r4,100
 d040518:	d03efac0 	call	d03efac <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 d04051c:	e13ffb17 	ldw	r4,-20(fp)
 d040520:	d029f200 	call	d029f20 <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 d040524:	e0bffd17 	ldw	r2,-12(fp)
 d040528:	1004c03a 	cmpne	r2,r2,zero
 d04052c:	103fcc1e 	bne	r2,zero,d040460 <ip_reasm_delete_ire+0xcc>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 d040530:	01002204 	movi	r4,136
 d040534:	d03efac0 	call	d03efac <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 d040538:	e13ffe17 	ldw	r4,-8(fp)
 d04053c:	d029f200 	call	d029f20 <npfree>

   return IPREASM_OK;
 d040540:	e03fff15 	stw	zero,-4(fp)
 d040544:	e0bfff17 	ldw	r2,-4(fp)
}
 d040548:	e037883a 	mov	sp,fp
 d04054c:	dfc00117 	ldw	ra,4(sp)
 d040550:	df000017 	ldw	fp,0(sp)
 d040554:	dec00204 	addi	sp,sp,8
 d040558:	f800283a 	ret

0d04055c <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 d04055c:	defffa04 	addi	sp,sp,-24
 d040560:	dfc00515 	stw	ra,20(sp)
 d040564:	df000415 	stw	fp,16(sp)
 d040568:	df000404 	addi	fp,sp,16
 d04056c:	e13ffe15 	stw	r4,-8(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 d040570:	e03ffc45 	stb	zero,-15(fp)
   u_char compact = IPREASM_TRUE;
 d040574:	00800044 	movi	r2,1
 d040578:	e0bffc05 	stb	r2,-16(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 d04057c:	e13ffe17 	ldw	r4,-8(fp)
 d040580:	d03fef00 	call	d03fef0 <ip_reasm_find_ire>
 d040584:	10803fcc 	andi	r2,r2,255
 d040588:	10800060 	cmpeqi	r2,r2,1
 d04058c:	10000a1e 	bne	r2,zero,d0405b8 <ip_reasm_mark_compact_rfq+0x5c>
   {
      ++ire_stats.bad_irep;
 d040590:	008341b4 	movhi	r2,3334
 d040594:	10b4ff04 	addi	r2,r2,-11268
 d040598:	10800017 	ldw	r2,0(r2)
 d04059c:	10c00044 	addi	r3,r2,1
 d0405a0:	008341b4 	movhi	r2,3334
 d0405a4:	10b4ff04 	addi	r2,r2,-11268
 d0405a8:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 d0405ac:	00bffd84 	movi	r2,-10
 d0405b0:	e0bfff15 	stw	r2,-4(fp)
 d0405b4:	00003506 	br	d04068c <ip_reasm_mark_compact_rfq+0x130>
   }

   rfqp = &(irep->rfq);
 d0405b8:	e0bffe17 	ldw	r2,-8(fp)
 d0405bc:	10800604 	addi	r2,r2,24
 d0405c0:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 d0405c4:	00001c06 	br	d040638 <ip_reasm_mark_compact_rfq+0xdc>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d0405c8:	e03ffc8d 	sth	zero,-14(fp)
 d0405cc:	00001406 	br	d040620 <ip_reasm_mark_compact_rfq+0xc4>
         {
         if (rfqp->bufp [i] == 0)
 d0405d0:	e0bffc8b 	ldhu	r2,-14(fp)
 d0405d4:	e0fffd17 	ldw	r3,-12(fp)
 d0405d8:	1085883a 	add	r2,r2,r2
 d0405dc:	1085883a 	add	r2,r2,r2
 d0405e0:	10c5883a 	add	r2,r2,r3
 d0405e4:	10800104 	addi	r2,r2,4
 d0405e8:	10800017 	ldw	r2,0(r2)
 d0405ec:	1004c03a 	cmpne	r2,r2,zero
 d0405f0:	1000031e 	bne	r2,zero,d040600 <ip_reasm_mark_compact_rfq+0xa4>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 d0405f4:	00800044 	movi	r2,1
 d0405f8:	e0bffc45 	stb	r2,-15(fp)
 d0405fc:	00000506 	br	d040614 <ip_reasm_mark_compact_rfq+0xb8>
            }
         else
            {
            if (empty_slot_discovered) 
 d040600:	e0bffc43 	ldbu	r2,-15(fp)
 d040604:	1005003a 	cmpeq	r2,r2,zero
 d040608:	1000021e 	bne	r2,zero,d040614 <ip_reasm_mark_compact_rfq+0xb8>
               {
               compact = IPREASM_FALSE;
 d04060c:	e03ffc05 	stb	zero,-16(fp)
               break;
 d040610:	00000606 	br	d04062c <ip_reasm_mark_compact_rfq+0xd0>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d040614:	e0bffc8b 	ldhu	r2,-14(fp)
 d040618:	10800044 	addi	r2,r2,1
 d04061c:	e0bffc8d 	sth	r2,-14(fp)
 d040620:	e0bffc8b 	ldhu	r2,-14(fp)
 d040624:	10800430 	cmpltui	r2,r2,16
 d040628:	103fe91e 	bne	r2,zero,d0405d0 <ip_reasm_mark_compact_rfq+0x74>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 d04062c:	e0bffd17 	ldw	r2,-12(fp)
 d040630:	10800017 	ldw	r2,0(r2)
 d040634:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 d040638:	e0bffd17 	ldw	r2,-12(fp)
 d04063c:	1004c03a 	cmpne	r2,r2,zero
 d040640:	103fe11e 	bne	r2,zero,d0405c8 <ip_reasm_mark_compact_rfq+0x6c>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 d040644:	e0bffc03 	ldbu	r2,-16(fp)
 d040648:	1005003a 	cmpeq	r2,r2,zero
 d04064c:	1000071e 	bne	r2,zero,d04066c <ip_reasm_mark_compact_rfq+0x110>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 d040650:	e0bffe17 	ldw	r2,-8(fp)
 d040654:	10802103 	ldbu	r2,132(r2)
 d040658:	10800054 	ori	r2,r2,1
 d04065c:	1007883a 	mov	r3,r2
 d040660:	e0bffe17 	ldw	r2,-8(fp)
 d040664:	10c02105 	stb	r3,132(r2)
 d040668:	00000706 	br	d040688 <ip_reasm_mark_compact_rfq+0x12c>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 d04066c:	e0bffe17 	ldw	r2,-8(fp)
 d040670:	10c02103 	ldbu	r3,132(r2)
 d040674:	00bfff84 	movi	r2,-2
 d040678:	1884703a 	and	r2,r3,r2
 d04067c:	1007883a 	mov	r3,r2
 d040680:	e0bffe17 	ldw	r2,-8(fp)
 d040684:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 d040688:	e03fff15 	stw	zero,-4(fp)
 d04068c:	e0bfff17 	ldw	r2,-4(fp)
}
 d040690:	e037883a 	mov	sp,fp
 d040694:	dfc00117 	ldw	ra,4(sp)
 d040698:	df000017 	ldw	fp,0(sp)
 d04069c:	dec00204 	addi	sp,sp,8
 d0406a0:	f800283a 	ret

0d0406a4 <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 d0406a4:	deffed04 	addi	sp,sp,-76
 d0406a8:	dfc01215 	stw	ra,72(sp)
 d0406ac:	df001115 	stw	fp,68(sp)
 d0406b0:	df001104 	addi	fp,sp,68
 d0406b4:	e13fff15 	stw	r4,-4(fp)
   unsigned long ticks_elapsed = cticks;
 d0406b8:	00834174 	movhi	r2,3333
 d0406bc:	108ac904 	addi	r2,r2,11044
 d0406c0:	10800017 	ldw	r2,0(r2)
 d0406c4:	e0bffe15 	stw	r2,-8(fp)
   u_short size_ire = sizeof(IRE);
 d0406c8:	00802204 	movi	r2,136
 d0406cc:	e0bffd8d 	sth	r2,-10(fp)
   u_short size_rfq = sizeof(RFQ);
 d0406d0:	00801904 	movi	r2,100
 d0406d4:	e0bffd0d 	sth	r2,-12(fp)
   IREP tmpp;
   u_short count = 0;
 d0406d8:	e03ffb0d 	sth	zero,-20(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 d0406dc:	e03ff98d 	sth	zero,-26(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 d0406e0:	e13fff17 	ldw	r4,-4(fp)
 d0406e4:	01434174 	movhi	r5,3333
 d0406e8:	297f4404 	addi	r5,r5,-752
 d0406ec:	d02486c0 	call	d02486c <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 d0406f0:	d1a0c717 	ldw	r6,-31972(gp)
 d0406f4:	e0fffe17 	ldw	r3,-8(fp)
 d0406f8:	00801904 	movi	r2,100
 d0406fc:	1885203a 	divu	r2,r3,r2
 d040700:	e0fffd8b 	ldhu	r3,-10(fp)
 d040704:	e13ffd0b 	ldhu	r4,-12(fp)
 d040708:	d8800015 	stw	r2,0(sp)
 d04070c:	d8c00115 	stw	r3,4(sp)
 d040710:	d9000215 	stw	r4,8(sp)
 d040714:	e13fff17 	ldw	r4,-4(fp)
 d040718:	01434174 	movhi	r5,3333
 d04071c:	297f4b04 	addi	r5,r5,-724
 d040720:	e1fffe17 	ldw	r7,-8(fp)
 d040724:	d02486c0 	call	d02486c <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 d040728:	008341b4 	movhi	r2,3334
 d04072c:	10b4ff04 	addi	r2,r2,-11268
 d040730:	11800117 	ldw	r6,4(r2)
 d040734:	008341b4 	movhi	r2,3334
 d040738:	10b4ff04 	addi	r2,r2,-11268
 d04073c:	11c00017 	ldw	r7,0(r2)
 d040740:	008341b4 	movhi	r2,3334
 d040744:	10b4ff04 	addi	r2,r2,-11268
 d040748:	11000217 	ldw	r4,8(r2)
 d04074c:	008341b4 	movhi	r2,3334
 d040750:	10b4ff04 	addi	r2,r2,-11268
 d040754:	11400317 	ldw	r5,12(r2)
 d040758:	008341b4 	movhi	r2,3334
 d04075c:	10b4ff04 	addi	r2,r2,-11268
 d040760:	10c00417 	ldw	r3,16(r2)
 d040764:	008341b4 	movhi	r2,3334
 d040768:	10b4ff04 	addi	r2,r2,-11268
 d04076c:	10800517 	ldw	r2,20(r2)
 d040770:	d9000015 	stw	r4,0(sp)
 d040774:	d9400115 	stw	r5,4(sp)
 d040778:	d8c00215 	stw	r3,8(sp)
 d04077c:	d8800315 	stw	r2,12(sp)
 d040780:	e13fff17 	ldw	r4,-4(fp)
 d040784:	01434174 	movhi	r5,3333
 d040788:	297f5b04 	addi	r5,r5,-660
 d04078c:	d02486c0 	call	d02486c <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 d040790:	d1a0c817 	ldw	r6,-31968(gp)
 d040794:	e13fff17 	ldw	r4,-4(fp)
 d040798:	01434174 	movhi	r5,3333
 d04079c:	297f7004 	addi	r5,r5,-576
 d0407a0:	d02486c0 	call	d02486c <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d0407a4:	d0a0c817 	ldw	r2,-31968(gp)
 d0407a8:	e0bffc15 	stw	r2,-16(fp)
 d0407ac:	00008106 	br	d0409b4 <ipr_stats+0x310>
      {
      ++count;
 d0407b0:	e0bffb0b 	ldhu	r2,-20(fp)
 d0407b4:	10800044 	addi	r2,r2,1
 d0407b8:	e0bffb0d 	sth	r2,-20(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 d0407bc:	e0bffc17 	ldw	r2,-16(fp)
 d0407c0:	10800604 	addi	r2,r2,24
 d0407c4:	e0bffa15 	stw	r2,-24(fp)
      while (rfqp)
 d0407c8:	00001f06 	br	d040848 <ipr_stats+0x1a4>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d0407cc:	e03ff90d 	sth	zero,-28(fp)
 d0407d0:	00001706 	br	d040830 <ipr_stats+0x18c>
            {
            if (rfqp->bufp [i] != 0)
 d0407d4:	e0bff90b 	ldhu	r2,-28(fp)
 d0407d8:	e0fffa17 	ldw	r3,-24(fp)
 d0407dc:	1085883a 	add	r2,r2,r2
 d0407e0:	1085883a 	add	r2,r2,r2
 d0407e4:	10c5883a 	add	r2,r2,r3
 d0407e8:	10800104 	addi	r2,r2,4
 d0407ec:	10800017 	ldw	r2,0(r2)
 d0407f0:	1005003a 	cmpeq	r2,r2,zero
 d0407f4:	1000041e 	bne	r2,zero,d040808 <ipr_stats+0x164>
               {
               ++frag_count;            
 d0407f8:	e0bff98b 	ldhu	r2,-26(fp)
 d0407fc:	10800044 	addi	r2,r2,1
 d040800:	e0bff98d 	sth	r2,-26(fp)
 d040804:	00000706 	br	d040824 <ipr_stats+0x180>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 d040808:	e0bffc17 	ldw	r2,-16(fp)
 d04080c:	10802103 	ldbu	r2,132(r2)
 d040810:	10803fcc 	andi	r2,r2,255
 d040814:	1080004c 	andi	r2,r2,1
 d040818:	10803fcc 	andi	r2,r2,255
 d04081c:	1004c03a 	cmpne	r2,r2,zero
 d040820:	1000061e 	bne	r2,zero,d04083c <ipr_stats+0x198>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 d040824:	e0bff90b 	ldhu	r2,-28(fp)
 d040828:	10800044 	addi	r2,r2,1
 d04082c:	e0bff90d 	sth	r2,-28(fp)
 d040830:	e0bff90b 	ldhu	r2,-28(fp)
 d040834:	10800430 	cmpltui	r2,r2,16
 d040838:	103fe61e 	bne	r2,zero,d0407d4 <ipr_stats+0x130>
                  {
                  break;
                  }
               }
            }
         rfqp = rfqp->next;
 d04083c:	e0bffa17 	ldw	r2,-24(fp)
 d040840:	10800017 	ldw	r2,0(r2)
 d040844:	e0bffa15 	stw	r2,-24(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 d040848:	e0bffa17 	ldw	r2,-24(fp)
 d04084c:	1004c03a 	cmpne	r2,r2,zero
 d040850:	103fde1e 	bne	r2,zero,d0407cc <ipr_stats+0x128>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 d040854:	e1fff98b 	ldhu	r7,-26(fp)
 d040858:	e0bffc17 	ldw	r2,-16(fp)
 d04085c:	10800117 	ldw	r2,4(r2)
 d040860:	1004d63a 	srli	r2,r2,24
 d040864:	10c03fcc 	andi	r3,r2,255
 d040868:	e0bffc17 	ldw	r2,-16(fp)
 d04086c:	10800117 	ldw	r2,4(r2)
 d040870:	1004d23a 	srli	r2,r2,8
 d040874:	10bfc00c 	andi	r2,r2,65280
 d040878:	1886b03a 	or	r3,r3,r2
 d04087c:	e0bffc17 	ldw	r2,-16(fp)
 d040880:	10800117 	ldw	r2,4(r2)
 d040884:	10bfc00c 	andi	r2,r2,65280
 d040888:	1004923a 	slli	r2,r2,8
 d04088c:	1886b03a 	or	r3,r3,r2
 d040890:	e0bffc17 	ldw	r2,-16(fp)
 d040894:	10800117 	ldw	r2,4(r2)
 d040898:	10803fcc 	andi	r2,r2,255
 d04089c:	1004963a 	slli	r2,r2,24
 d0408a0:	1888b03a 	or	r4,r3,r2
 d0408a4:	e0bffc17 	ldw	r2,-16(fp)
 d0408a8:	10800217 	ldw	r2,8(r2)
 d0408ac:	1004d63a 	srli	r2,r2,24
 d0408b0:	10c03fcc 	andi	r3,r2,255
 d0408b4:	e0bffc17 	ldw	r2,-16(fp)
 d0408b8:	10800217 	ldw	r2,8(r2)
 d0408bc:	1004d23a 	srli	r2,r2,8
 d0408c0:	10bfc00c 	andi	r2,r2,65280
 d0408c4:	1886b03a 	or	r3,r3,r2
 d0408c8:	e0bffc17 	ldw	r2,-16(fp)
 d0408cc:	10800217 	ldw	r2,8(r2)
 d0408d0:	10bfc00c 	andi	r2,r2,65280
 d0408d4:	1004923a 	slli	r2,r2,8
 d0408d8:	1886b03a 	or	r3,r3,r2
 d0408dc:	e0bffc17 	ldw	r2,-16(fp)
 d0408e0:	10800217 	ldw	r2,8(r2)
 d0408e4:	10803fcc 	andi	r2,r2,255
 d0408e8:	1004963a 	slli	r2,r2,24
 d0408ec:	188ab03a 	or	r5,r3,r2
 d0408f0:	e0bffc17 	ldw	r2,-16(fp)
 d0408f4:	10800383 	ldbu	r2,14(r2)
 d0408f8:	11803fcc 	andi	r6,r2,255
 d0408fc:	e0bffc17 	ldw	r2,-16(fp)
 d040900:	1080030b 	ldhu	r2,12(r2)
 d040904:	10bfffcc 	andi	r2,r2,65535
 d040908:	1004d23a 	srli	r2,r2,8
 d04090c:	10bfffcc 	andi	r2,r2,65535
 d040910:	10c03fcc 	andi	r3,r2,255
 d040914:	e0bffc17 	ldw	r2,-16(fp)
 d040918:	1080030b 	ldhu	r2,12(r2)
 d04091c:	10bfffcc 	andi	r2,r2,65535
 d040920:	1004923a 	slli	r2,r2,8
 d040924:	10bfc00c 	andi	r2,r2,65280
 d040928:	1886b03a 	or	r3,r3,r2
 d04092c:	e0bffc17 	ldw	r2,-16(fp)
 d040930:	1080040b 	ldhu	r2,16(r2)
 d040934:	123fffcc 	andi	r8,r2,65535
 d040938:	e0bffc17 	ldw	r2,-16(fp)
 d04093c:	1080048b 	ldhu	r2,18(r2)
 d040940:	127fffcc 	andi	r9,r2,65535
 d040944:	e0bffc17 	ldw	r2,-16(fp)
 d040948:	12800517 	ldw	r10,20(r2)
 d04094c:	e0bffc17 	ldw	r2,-16(fp)
 d040950:	12c01f17 	ldw	r11,124(r2)
 d040954:	e0bffc17 	ldw	r2,-16(fp)
 d040958:	13002017 	ldw	r12,128(r2)
 d04095c:	e0bffc17 	ldw	r2,-16(fp)
 d040960:	10802103 	ldbu	r2,132(r2)
 d040964:	10803fcc 	andi	r2,r2,255
 d040968:	1080004c 	andi	r2,r2,1
 d04096c:	d9000015 	stw	r4,0(sp)
 d040970:	d9400115 	stw	r5,4(sp)
 d040974:	d9800215 	stw	r6,8(sp)
 d040978:	d8c00315 	stw	r3,12(sp)
 d04097c:	da000415 	stw	r8,16(sp)
 d040980:	da400515 	stw	r9,20(sp)
 d040984:	da800615 	stw	r10,24(sp)
 d040988:	dac00715 	stw	r11,28(sp)
 d04098c:	db000815 	stw	r12,32(sp)
 d040990:	d8800915 	stw	r2,36(sp)
 d040994:	e13fff17 	ldw	r4,-4(fp)
 d040998:	01434174 	movhi	r5,3333
 d04099c:	297f7604 	addi	r5,r5,-552
 d0409a0:	e1bffc17 	ldw	r6,-16(fp)
 d0409a4:	d02486c0 	call	d02486c <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 d0409a8:	e0bffc17 	ldw	r2,-16(fp)
 d0409ac:	10800017 	ldw	r2,0(r2)
 d0409b0:	e0bffc15 	stw	r2,-16(fp)
 d0409b4:	e0bffc17 	ldw	r2,-16(fp)
 d0409b8:	1004c03a 	cmpne	r2,r2,zero
 d0409bc:	103f7c1e 	bne	r2,zero,d0407b0 <ipr_stats+0x10c>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 d0409c0:	e1bffb0b 	ldhu	r6,-20(fp)
 d0409c4:	e13fff17 	ldw	r4,-4(fp)
 d0409c8:	01434174 	movhi	r5,3333
 d0409cc:	297f9104 	addi	r5,r5,-444
 d0409d0:	d02486c0 	call	d02486c <ns_printf>

   return IPREASM_OK;
 d0409d4:	0005883a 	mov	r2,zero
}
 d0409d8:	e037883a 	mov	sp,fp
 d0409dc:	dfc00117 	ldw	ra,4(sp)
 d0409e0:	df000017 	ldw	fp,0(sp)
 d0409e4:	dec00204 	addi	sp,sp,8
 d0409e8:	f800283a 	ret

0d0409ec <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 d0409ec:	defffc04 	addi	sp,sp,-16
 d0409f0:	dfc00315 	stw	ra,12(sp)
 d0409f4:	df000215 	stw	fp,8(sp)
 d0409f8:	df000204 	addi	fp,sp,8
 d0409fc:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 d040a00:	e0bfff17 	ldw	r2,-4(fp)
 d040a04:	10801f17 	ldw	r2,124(r2)
 d040a08:	1005003a 	cmpeq	r2,r2,zero
 d040a0c:	1000061e 	bne	r2,zero,d040a28 <ip_reasm_send_icmp_timex+0x3c>
      {
      pip = (struct ip *) irep->l3_hdr;
 d040a10:	e0bfff17 	ldw	r2,-4(fp)
 d040a14:	10802017 	ldw	r2,128(r2)
 d040a18:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 d040a1c:	e13ffe17 	ldw	r4,-8(fp)
 d040a20:	01400044 	movi	r5,1
 d040a24:	d049aa40 	call	d049aa4 <icmp_timex>
      }

   return IPREASM_OK;
 d040a28:	0005883a 	mov	r2,zero
}
 d040a2c:	e037883a 	mov	sp,fp
 d040a30:	dfc00117 	ldw	ra,4(sp)
 d040a34:	df000017 	ldw	fp,0(sp)
 d040a38:	dec00204 	addi	sp,sp,8
 d040a3c:	f800283a 	ret

0d040a40 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 d040a40:	defff204 	addi	sp,sp,-56
 d040a44:	dfc00d15 	stw	ra,52(sp)
 d040a48:	df000c15 	stw	fp,48(sp)
 d040a4c:	dc000b15 	stw	r16,44(sp)
 d040a50:	df000b04 	addi	fp,sp,44
 d040a54:	e13ffe15 	stw	r4,-8(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 d040a58:	00bfffc4 	movi	r2,-1
 d040a5c:	e0bff515 	stw	r2,-44(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d040a60:	00834174 	movhi	r2,3333
 d040a64:	108aa404 	addi	r2,r2,10896
 d040a68:	10800017 	ldw	r2,0(r2)
 d040a6c:	1081000c 	andi	r2,r2,1024
 d040a70:	1005003a 	cmpeq	r2,r2,zero
 d040a74:	1000101e 	bne	r2,zero,d040ab8 <ip_rcv+0x78>
 d040a78:	00834174 	movhi	r2,3333
 d040a7c:	108aa404 	addi	r2,r2,10896
 d040a80:	10800017 	ldw	r2,0(r2)
 d040a84:	1080800c 	andi	r2,r2,512
 d040a88:	1005003a 	cmpeq	r2,r2,zero
 d040a8c:	10000a1e 	bne	r2,zero,d040ab8 <ip_rcv+0x78>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 d040a90:	e0bffe17 	ldw	r2,-8(fp)
 d040a94:	14000417 	ldw	r16,16(r2)
 d040a98:	e0bffe17 	ldw	r2,-8(fp)
 d040a9c:	11000617 	ldw	r4,24(r2)
 d040aa0:	d0225980 	call	d022598 <if_netnumber>
 d040aa4:	100d883a 	mov	r6,r2
 d040aa8:	01034174 	movhi	r4,3333
 d040aac:	213f9a04 	addi	r4,r4,-408
 d040ab0:	800b883a 	mov	r5,r16
 d040ab4:	d0029980 	call	d002998 <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   nt = p->net;      /* which interface it came in on */
 d040ab8:	e0bffe17 	ldw	r2,-8(fp)
 d040abc:	10800617 	ldw	r2,24(r2)
 d040ac0:	e0bffb15 	stw	r2,-20(fp)
   ip_mib.ipInReceives++;
 d040ac4:	008341b4 	movhi	r2,3334
 d040ac8:	10b4eb04 	addi	r2,r2,-11348
 d040acc:	10800217 	ldw	r2,8(r2)
 d040ad0:	10c00044 	addi	r3,r2,1
 d040ad4:	008341b4 	movhi	r2,3334
 d040ad8:	10b4eb04 	addi	r2,r2,-11348
 d040adc:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 d040ae0:	e0bffe17 	ldw	r2,-8(fp)
 d040ae4:	10800317 	ldw	r2,12(r2)
 d040ae8:	e0bffd15 	stw	r2,-12(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 d040aec:	e0bffe17 	ldw	r2,-8(fp)
 d040af0:	11000417 	ldw	r4,16(r2)
 d040af4:	e0bffd17 	ldw	r2,-12(fp)
 d040af8:	1080008b 	ldhu	r2,2(r2)
 d040afc:	10bfffcc 	andi	r2,r2,65535
 d040b00:	1004d23a 	srli	r2,r2,8
 d040b04:	10bfffcc 	andi	r2,r2,65535
 d040b08:	10c03fcc 	andi	r3,r2,255
 d040b0c:	e0bffd17 	ldw	r2,-12(fp)
 d040b10:	1080008b 	ldhu	r2,2(r2)
 d040b14:	10bfffcc 	andi	r2,r2,65535
 d040b18:	1004923a 	slli	r2,r2,8
 d040b1c:	10bfc00c 	andi	r2,r2,65280
 d040b20:	1884b03a 	or	r2,r3,r2
 d040b24:	2080272e 	bgeu	r4,r2,d040bc4 <ip_rcv+0x184>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d040b28:	00834174 	movhi	r2,3333
 d040b2c:	108aa404 	addi	r2,r2,10896
 d040b30:	10800017 	ldw	r2,0(r2)
 d040b34:	1081000c 	andi	r2,r2,1024
 d040b38:	1005003a 	cmpeq	r2,r2,zero
 d040b3c:	1000111e 	bne	r2,zero,d040b84 <ip_rcv+0x144>
 d040b40:	00834174 	movhi	r2,3333
 d040b44:	108aa404 	addi	r2,r2,10896
 d040b48:	10800017 	ldw	r2,0(r2)
 d040b4c:	1080800c 	andi	r2,r2,512
 d040b50:	1005003a 	cmpeq	r2,r2,zero
 d040b54:	10000b1e 	bne	r2,zero,d040b84 <ip_rcv+0x144>
      {
         dprintf("ip_rcv: bad pkt len\n");
 d040b58:	01034174 	movhi	r4,3333
 d040b5c:	213fa304 	addi	r4,r4,-372
 d040b60:	d002cc00 	call	d002cc0 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 d040b64:	00834174 	movhi	r2,3333
 d040b68:	108aa404 	addi	r2,r2,10896
 d040b6c:	10800017 	ldw	r2,0(r2)
 d040b70:	1080008c 	andi	r2,r2,2
 d040b74:	1005003a 	cmpeq	r2,r2,zero
 d040b78:	1000021e 	bne	r2,zero,d040b84 <ip_rcv+0x144>
 d040b7c:	e13ffe17 	ldw	r4,-8(fp)
 d040b80:	d03e6540 	call	d03e654 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 d040b84:	008341b4 	movhi	r2,3334
 d040b88:	10b4eb04 	addi	r2,r2,-11348
 d040b8c:	10800317 	ldw	r2,12(r2)
 d040b90:	10c00044 	addi	r3,r2,1
 d040b94:	008341b4 	movhi	r2,3334
 d040b98:	10b4eb04 	addi	r2,r2,-11348
 d040b9c:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d040ba0:	01000084 	movi	r4,2
 d040ba4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d040ba8:	e13ffe17 	ldw	r4,-8(fp)
 d040bac:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d040bb0:	01000084 	movi	r4,2
 d040bb4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 d040bb8:	00bff804 	movi	r2,-32
 d040bbc:	e0bfff15 	stw	r2,-4(fp)
 d040bc0:	00009806 	br	d040e24 <ip_rcv+0x3e4>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 d040bc4:	e0bffd17 	ldw	r2,-12(fp)
 d040bc8:	1080008b 	ldhu	r2,2(r2)
 d040bcc:	10bfffcc 	andi	r2,r2,65535
 d040bd0:	1004d23a 	srli	r2,r2,8
 d040bd4:	10bfffcc 	andi	r2,r2,65535
 d040bd8:	10c03fcc 	andi	r3,r2,255
 d040bdc:	e0bffd17 	ldw	r2,-12(fp)
 d040be0:	1080008b 	ldhu	r2,2(r2)
 d040be4:	10bfffcc 	andi	r2,r2,65535
 d040be8:	1004923a 	slli	r2,r2,8
 d040bec:	10bfc00c 	andi	r2,r2,65280
 d040bf0:	1884b03a 	or	r2,r3,r2
 d040bf4:	e0bff915 	stw	r2,-28(fp)
   p->nb_plen = len;       /* fix pkt len */
 d040bf8:	e0fffe17 	ldw	r3,-8(fp)
 d040bfc:	e0bff917 	ldw	r2,-28(fp)
 d040c00:	18800415 	stw	r2,16(r3)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 d040c04:	e0bffd17 	ldw	r2,-12(fp)
 d040c08:	10800003 	ldbu	r2,0(r2)
 d040c0c:	10803fcc 	andi	r2,r2,255
 d040c10:	10803c0c 	andi	r2,r2,240
 d040c14:	1005d13a 	srai	r2,r2,4
 d040c18:	10800120 	cmpeqi	r2,r2,4
 d040c1c:	1000271e 	bne	r2,zero,d040cbc <ip_rcv+0x27c>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d040c20:	00834174 	movhi	r2,3333
 d040c24:	108aa404 	addi	r2,r2,10896
 d040c28:	10800017 	ldw	r2,0(r2)
 d040c2c:	1081000c 	andi	r2,r2,1024
 d040c30:	1005003a 	cmpeq	r2,r2,zero
 d040c34:	1000111e 	bne	r2,zero,d040c7c <ip_rcv+0x23c>
 d040c38:	00834174 	movhi	r2,3333
 d040c3c:	108aa404 	addi	r2,r2,10896
 d040c40:	10800017 	ldw	r2,0(r2)
 d040c44:	1080800c 	andi	r2,r2,512
 d040c48:	1005003a 	cmpeq	r2,r2,zero
 d040c4c:	10000b1e 	bne	r2,zero,d040c7c <ip_rcv+0x23c>
      {
         dprintf("ip_rcv: bad version number\n");
 d040c50:	01034174 	movhi	r4,3333
 d040c54:	213fa804 	addi	r4,r4,-352
 d040c58:	d002cc00 	call	d002cc0 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 d040c5c:	00834174 	movhi	r2,3333
 d040c60:	108aa404 	addi	r2,r2,10896
 d040c64:	10800017 	ldw	r2,0(r2)
 d040c68:	1080008c 	andi	r2,r2,2
 d040c6c:	1005003a 	cmpeq	r2,r2,zero
 d040c70:	1000021e 	bne	r2,zero,d040c7c <ip_rcv+0x23c>
 d040c74:	e13ffe17 	ldw	r4,-8(fp)
 d040c78:	d03e6540 	call	d03e654 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 d040c7c:	008341b4 	movhi	r2,3334
 d040c80:	10b4eb04 	addi	r2,r2,-11348
 d040c84:	10800317 	ldw	r2,12(r2)
 d040c88:	10c00044 	addi	r3,r2,1
 d040c8c:	008341b4 	movhi	r2,3334
 d040c90:	10b4eb04 	addi	r2,r2,-11348
 d040c94:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d040c98:	01000084 	movi	r4,2
 d040c9c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d040ca0:	e13ffe17 	ldw	r4,-8(fp)
 d040ca4:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d040ca8:	01000084 	movi	r4,2
 d040cac:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 d040cb0:	00bff804 	movi	r2,-32
 d040cb4:	e0bfff15 	stw	r2,-4(fp)
 d040cb8:	00005a06 	br	d040e24 <ip_rcv+0x3e4>
   }

   csum = pip->ip_chksum;
 d040cbc:	e0bffd17 	ldw	r2,-12(fp)
 d040cc0:	1080028b 	ldhu	r2,10(r2)
 d040cc4:	e0bffc8d 	sth	r2,-14(fp)
   pip->ip_chksum = 0;
 d040cc8:	e0bffd17 	ldw	r2,-12(fp)
 d040ccc:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 d040cd0:	e0bffd17 	ldw	r2,-12(fp)
 d040cd4:	10800003 	ldbu	r2,0(r2)
 d040cd8:	10803fcc 	andi	r2,r2,255
 d040cdc:	108003cc 	andi	r2,r2,15
 d040ce0:	1085883a 	add	r2,r2,r2
 d040ce4:	1085883a 	add	r2,r2,r2
 d040ce8:	e0bffa15 	stw	r2,-24(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 d040cec:	e0bffa17 	ldw	r2,-24(fp)
 d040cf0:	100ad07a 	srli	r5,r2,1
 d040cf4:	e13ffd17 	ldw	r4,-12(fp)
 d040cf8:	d0242340 	call	d024234 <cksum>
 d040cfc:	0084303a 	nor	r2,zero,r2
 d040d00:	e0bffc0d 	sth	r2,-16(fp)

   if (csum != tempsum)
 d040d04:	e0fffc8b 	ldhu	r3,-14(fp)
 d040d08:	e0bffc0b 	ldhu	r2,-16(fp)
 d040d0c:	18802a26 	beq	r3,r2,d040db8 <ip_rcv+0x378>
   {
      pip->ip_chksum = csum;
 d040d10:	e0fffd17 	ldw	r3,-12(fp)
 d040d14:	e0bffc8b 	ldhu	r2,-14(fp)
 d040d18:	1880028d 	sth	r2,10(r3)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d040d1c:	00834174 	movhi	r2,3333
 d040d20:	108aa404 	addi	r2,r2,10896
 d040d24:	10800017 	ldw	r2,0(r2)
 d040d28:	1081000c 	andi	r2,r2,1024
 d040d2c:	1005003a 	cmpeq	r2,r2,zero
 d040d30:	1000111e 	bne	r2,zero,d040d78 <ip_rcv+0x338>
 d040d34:	00834174 	movhi	r2,3333
 d040d38:	108aa404 	addi	r2,r2,10896
 d040d3c:	10800017 	ldw	r2,0(r2)
 d040d40:	1080800c 	andi	r2,r2,512
 d040d44:	1005003a 	cmpeq	r2,r2,zero
 d040d48:	10000b1e 	bne	r2,zero,d040d78 <ip_rcv+0x338>
      {
         dprintf("ip_rcv: bad xsum\n");
 d040d4c:	01034174 	movhi	r4,3333
 d040d50:	213faf04 	addi	r4,r4,-324
 d040d54:	d002cc00 	call	d002cc0 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 d040d58:	00834174 	movhi	r2,3333
 d040d5c:	108aa404 	addi	r2,r2,10896
 d040d60:	10800017 	ldw	r2,0(r2)
 d040d64:	1080008c 	andi	r2,r2,2
 d040d68:	1005003a 	cmpeq	r2,r2,zero
 d040d6c:	1000021e 	bne	r2,zero,d040d78 <ip_rcv+0x338>
 d040d70:	e13ffe17 	ldw	r4,-8(fp)
 d040d74:	d03e6540 	call	d03e654 <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 d040d78:	008341b4 	movhi	r2,3334
 d040d7c:	10b4eb04 	addi	r2,r2,-11348
 d040d80:	10800317 	ldw	r2,12(r2)
 d040d84:	10c00044 	addi	r3,r2,1
 d040d88:	008341b4 	movhi	r2,3334
 d040d8c:	10b4eb04 	addi	r2,r2,-11348
 d040d90:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d040d94:	01000084 	movi	r4,2
 d040d98:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d040d9c:	e13ffe17 	ldw	r4,-8(fp)
 d040da0:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d040da4:	01000084 	movi	r4,2
 d040da8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 d040dac:	00bff804 	movi	r2,-32
 d040db0:	e0bfff15 	stw	r2,-4(fp)
 d040db4:	00001b06 	br	d040e24 <ip_rcv+0x3e4>
   }

   pip->ip_chksum = csum;
 d040db8:	e0fffd17 	ldw	r3,-12(fp)
 d040dbc:	e0bffc8b 	ldhu	r2,-14(fp)
 d040dc0:	1880028d 	sth	r2,10(r3)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 d040dc4:	00800044 	movi	r2,1
 d040dc8:	e0bff80d 	sth	r2,-32(fp)
    pktp = &p;
 d040dcc:	e0bffe04 	addi	r2,fp,-8
 d040dd0:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 d040dd4:	e03ff605 	stb	zero,-40(fp)
 d040dd8:	00000c06 	br	d040e0c <ip_rcv+0x3cc>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 d040ddc:	e0bff603 	ldbu	r2,-40(fp)
 d040de0:	1085883a 	add	r2,r2,r2
 d040de4:	1085883a 	add	r2,r2,r2
 d040de8:	1007883a 	mov	r3,r2
 d040dec:	e0bff717 	ldw	r2,-36(fp)
 d040df0:	1885883a 	add	r2,r3,r2
 d040df4:	11000017 	ldw	r4,0(r2)
 d040df8:	d040e400 	call	d040e40 <ip_rcv_phase2>
 d040dfc:	e0bff515 	stw	r2,-44(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 d040e00:	e0bff603 	ldbu	r2,-40(fp)
 d040e04:	10800044 	addi	r2,r2,1
 d040e08:	e0bff605 	stb	r2,-40(fp)
 d040e0c:	e0bff603 	ldbu	r2,-40(fp)
 d040e10:	10ffffcc 	andi	r3,r2,65535
 d040e14:	e0bff80b 	ldhu	r2,-32(fp)
 d040e18:	18bff036 	bltu	r3,r2,d040ddc <ip_rcv+0x39c>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 d040e1c:	e0bff517 	ldw	r2,-44(fp)
 d040e20:	e0bfff15 	stw	r2,-4(fp)
 d040e24:	e0bfff17 	ldw	r2,-4(fp)
}
 d040e28:	e037883a 	mov	sp,fp
 d040e2c:	dfc00217 	ldw	ra,8(sp)
 d040e30:	df000117 	ldw	fp,4(sp)
 d040e34:	dc000017 	ldw	r16,0(sp)
 d040e38:	dec00304 	addi	sp,sp,12
 d040e3c:	f800283a 	ret

0d040e40 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 d040e40:	defff404 	addi	sp,sp,-48
 d040e44:	dfc00b15 	stw	ra,44(sp)
 d040e48:	df000a15 	stw	fp,40(sp)
 d040e4c:	df000a04 	addi	fp,sp,40
 d040e50:	e13ffe15 	stw	r4,-8(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 d040e54:	e0bffe17 	ldw	r2,-8(fp)
 d040e58:	10800317 	ldw	r2,12(r2)
 d040e5c:	e0bffc15 	stw	r2,-16(fp)
   nt = p->net;      /* which interface it came in on */
 d040e60:	e0bffe17 	ldw	r2,-8(fp)
 d040e64:	10800617 	ldw	r2,24(r2)
 d040e68:	e0bffb15 	stw	r2,-20(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 d040e6c:	e0bffc17 	ldw	r2,-16(fp)
 d040e70:	10800417 	ldw	r2,16(r2)
 d040e74:	1004d63a 	srli	r2,r2,24
 d040e78:	10c03fcc 	andi	r3,r2,255
 d040e7c:	e0bffc17 	ldw	r2,-16(fp)
 d040e80:	10800417 	ldw	r2,16(r2)
 d040e84:	1004d23a 	srli	r2,r2,8
 d040e88:	10bfc00c 	andi	r2,r2,65280
 d040e8c:	1886b03a 	or	r3,r3,r2
 d040e90:	e0bffc17 	ldw	r2,-16(fp)
 d040e94:	10800417 	ldw	r2,16(r2)
 d040e98:	10bfc00c 	andi	r2,r2,65280
 d040e9c:	1004923a 	slli	r2,r2,8
 d040ea0:	1886b03a 	or	r3,r3,r2
 d040ea4:	e0bffc17 	ldw	r2,-16(fp)
 d040ea8:	10800417 	ldw	r2,16(r2)
 d040eac:	10803fcc 	andi	r2,r2,255
 d040eb0:	1004963a 	slli	r2,r2,24
 d040eb4:	1884b03a 	or	r2,r3,r2
 d040eb8:	10fc002c 	andhi	r3,r2,61440
 d040ebc:	00b80034 	movhi	r2,57344
 d040ec0:	1880181e 	bne	r3,r2,d040f24 <ip_rcv_phase2+0xe4>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 d040ec4:	e0bffc17 	ldw	r2,-16(fp)
 d040ec8:	11000417 	ldw	r4,16(r2)
 d040ecc:	e17ffb17 	ldw	r5,-20(fp)
 d040ed0:	d041afc0 	call	d041afc <lookup_mcast>
 d040ed4:	e0bff915 	stw	r2,-28(fp)
      if (inm == NULL) 
 d040ed8:	e0bff917 	ldw	r2,-28(fp)
 d040edc:	1004c03a 	cmpne	r2,r2,zero
 d040ee0:	10010d1e 	bne	r2,zero,d041318 <ip_rcv_phase2+0x4d8>
      {
         ip_mib.ipOutNoRoutes++;
 d040ee4:	008341b4 	movhi	r2,3334
 d040ee8:	10b4eb04 	addi	r2,r2,-11348
 d040eec:	10800b17 	ldw	r2,44(r2)
 d040ef0:	10c00044 	addi	r3,r2,1
 d040ef4:	008341b4 	movhi	r2,3334
 d040ef8:	10b4eb04 	addi	r2,r2,-11348
 d040efc:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d040f00:	01000084 	movi	r4,2
 d040f04:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(p);
 d040f08:	e13ffe17 	ldw	r4,-8(fp)
 d040f0c:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d040f10:	01000084 	movi	r4,2
 d040f14:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 d040f18:	00800084 	movi	r2,2
 d040f1c:	e0bfff15 	stw	r2,-4(fp)
 d040f20:	00014406 	br	d041434 <ip_rcv_phase2+0x5f4>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 d040f24:	e0bffc17 	ldw	r2,-16(fp)
 d040f28:	10c00417 	ldw	r3,16(r2)
 d040f2c:	e0bffb17 	ldw	r2,-20(fp)
 d040f30:	10800a17 	ldw	r2,40(r2)
 d040f34:	1880f826 	beq	r3,r2,d041318 <ip_rcv_phase2+0x4d8>
 d040f38:	e0bffc17 	ldw	r2,-16(fp)
 d040f3c:	10800417 	ldw	r2,16(r2)
 d040f40:	10bfffe0 	cmpeqi	r2,r2,-1
 d040f44:	1000f41e 	bne	r2,zero,d041318 <ip_rcv_phase2+0x4d8>
 d040f48:	e0bffc17 	ldw	r2,-16(fp)
 d040f4c:	10c00417 	ldw	r3,16(r2)
 d040f50:	e0bffb17 	ldw	r2,-20(fp)
 d040f54:	10800e17 	ldw	r2,56(r2)
 d040f58:	1880ef26 	beq	r3,r2,d041318 <ip_rcv_phase2+0x4d8>
 d040f5c:	e0bffc17 	ldw	r2,-16(fp)
 d040f60:	10c00417 	ldw	r3,16(r2)
 d040f64:	e0bffb17 	ldw	r2,-20(fp)
 d040f68:	10800f17 	ldw	r2,60(r2)
 d040f6c:	1880ea26 	beq	r3,r2,d041318 <ip_rcv_phase2+0x4d8>
 d040f70:	e0bffc17 	ldw	r2,-16(fp)
 d040f74:	10c00417 	ldw	r3,16(r2)
 d040f78:	e0bffb17 	ldw	r2,-20(fp)
 d040f7c:	10801017 	ldw	r2,64(r2)
 d040f80:	1880e526 	beq	r3,r2,d041318 <ip_rcv_phase2+0x4d8>
 d040f84:	e0bffb17 	ldw	r2,-20(fp)
 d040f88:	10c00a17 	ldw	r3,40(r2)
 d040f8c:	e0bffb17 	ldw	r2,-20(fp)
 d040f90:	10800c17 	ldw	r2,48(r2)
 d040f94:	0084303a 	nor	r2,zero,r2
 d040f98:	1884703a 	and	r2,r3,r2
 d040f9c:	1005003a 	cmpeq	r2,r2,zero
 d040fa0:	1000dd1e 	bne	r2,zero,d041318 <ip_rcv_phase2+0x4d8>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d040fa4:	00834174 	movhi	r2,3333
 d040fa8:	108aa404 	addi	r2,r2,10896
 d040fac:	10800017 	ldw	r2,0(r2)
 d040fb0:	1081000c 	andi	r2,r2,1024
 d040fb4:	1005003a 	cmpeq	r2,r2,zero
 d040fb8:	1000181e 	bne	r2,zero,d04101c <ip_rcv_phase2+0x1dc>
 d040fbc:	00834174 	movhi	r2,3333
 d040fc0:	108aa404 	addi	r2,r2,10896
 d040fc4:	10800017 	ldw	r2,0(r2)
 d040fc8:	1080800c 	andi	r2,r2,512
 d040fcc:	1005003a 	cmpeq	r2,r2,zero
 d040fd0:	1000121e 	bne	r2,zero,d04101c <ip_rcv_phase2+0x1dc>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 d040fd4:	e0bffc17 	ldw	r2,-16(fp)
 d040fd8:	10800417 	ldw	r2,16(r2)
 d040fdc:	11403fcc 	andi	r5,r2,255
 d040fe0:	e0bffc17 	ldw	r2,-16(fp)
 d040fe4:	10800417 	ldw	r2,16(r2)
 d040fe8:	1004d23a 	srli	r2,r2,8
 d040fec:	11803fcc 	andi	r6,r2,255
 d040ff0:	e0bffc17 	ldw	r2,-16(fp)
 d040ff4:	10800417 	ldw	r2,16(r2)
 d040ff8:	1004d43a 	srli	r2,r2,16
 d040ffc:	11c03fcc 	andi	r7,r2,255
 d041000:	e0bffc17 	ldw	r2,-16(fp)
 d041004:	10800417 	ldw	r2,16(r2)
 d041008:	1004d63a 	srli	r2,r2,24
 d04100c:	d8800015 	stw	r2,0(sp)
 d041010:	01034174 	movhi	r4,3333
 d041014:	213fb404 	addi	r4,r4,-304
 d041018:	d0029980 	call	d002998 <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 d04101c:	008341b4 	movhi	r2,3334
 d041020:	10b4eb04 	addi	r2,r2,-11348
 d041024:	10800017 	ldw	r2,0(r2)
 d041028:	10800098 	cmpnei	r2,r2,2
 d04102c:	1000101e 	bne	r2,zero,d041070 <ip_rcv_phase2+0x230>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 d041030:	008341b4 	movhi	r2,3334
 d041034:	10b4eb04 	addi	r2,r2,-11348
 d041038:	10800a17 	ldw	r2,40(r2)
 d04103c:	10c00044 	addi	r3,r2,1
 d041040:	008341b4 	movhi	r2,3334
 d041044:	10b4eb04 	addi	r2,r2,-11348
 d041048:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 d04104c:	01000084 	movi	r4,2
 d041050:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
         pk_free(p);
 d041054:	e13ffe17 	ldw	r4,-8(fp)
 d041058:	d028b380 	call	d028b38 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04105c:	01000084 	movi	r4,2
 d041060:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 d041064:	00bff7c4 	movi	r2,-33
 d041068:	e0bfff15 	stw	r2,-4(fp)
 d04106c:	0000f106 	br	d041434 <ip_rcv_phase2+0x5f4>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 d041070:	008341b4 	movhi	r2,3334
 d041074:	10b4eb04 	addi	r2,r2,-11348
 d041078:	10800517 	ldw	r2,20(r2)
 d04107c:	10c00044 	addi	r3,r2,1
 d041080:	008341b4 	movhi	r2,3334
 d041084:	10b4eb04 	addi	r2,r2,-11348
 d041088:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 d04108c:	e0bffc17 	ldw	r2,-16(fp)
 d041090:	10800203 	ldbu	r2,8(r2)
 d041094:	10803fcc 	andi	r2,r2,255
 d041098:	108000a8 	cmpgeui	r2,r2,2
 d04109c:	10001b1e 	bne	r2,zero,d04110c <ip_rcv_phase2+0x2cc>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 d0410a0:	008341b4 	movhi	r2,3334
 d0410a4:	10b4eb04 	addi	r2,r2,-11348
 d0410a8:	10800a17 	ldw	r2,40(r2)
 d0410ac:	10c00044 	addi	r3,r2,1
 d0410b0:	008341b4 	movhi	r2,3334
 d0410b4:	10b4eb04 	addi	r2,r2,-11348
 d0410b8:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 d0410bc:	e0bffc17 	ldw	r2,-16(fp)
 d0410c0:	11000317 	ldw	r4,12(r2)
 d0410c4:	e0bffe17 	ldw	r2,-8(fp)
 d0410c8:	10800617 	ldw	r2,24(r2)
 d0410cc:	11400a17 	ldw	r5,40(r2)
 d0410d0:	e0bffe17 	ldw	r2,-8(fp)
 d0410d4:	10800617 	ldw	r2,24(r2)
 d0410d8:	d8800015 	stw	r2,0(sp)
 d0410dc:	e1bffc17 	ldw	r6,-16(fp)
 d0410e0:	01c2c004 	movi	r7,2816
 d0410e4:	d0497540 	call	d049754 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d0410e8:	01000084 	movi	r4,2
 d0410ec:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free(p);
 d0410f0:	e13ffe17 	ldw	r4,-8(fp)
 d0410f4:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0410f8:	01000084 	movi	r4,2
 d0410fc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 d041100:	00bff7c4 	movi	r2,-33
 d041104:	e0bfff15 	stw	r2,-4(fp)
 d041108:	0000ca06 	br	d041434 <ip_rcv_phase2+0x5f4>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 d04110c:	e0bffc17 	ldw	r2,-16(fp)
 d041110:	10c00417 	ldw	r3,16(r2)
 d041114:	e0bffe17 	ldw	r2,-8(fp)
 d041118:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 d04111c:	e0bffe17 	ldw	r2,-8(fp)
 d041120:	11000717 	ldw	r4,28(r2)
 d041124:	e17ffd04 	addi	r5,fp,-12
 d041128:	d03e90c0 	call	d03e90c <iproute>
 d04112c:	e0bff815 	stw	r2,-32(fp)
 d041130:	e0bff817 	ldw	r2,-32(fp)
 d041134:	1004c03a 	cmpne	r2,r2,zero
 d041138:	1000101e 	bne	r2,zero,d04117c <ip_rcv_phase2+0x33c>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 d04113c:	008341b4 	movhi	r2,3334
 d041140:	10b4eb04 	addi	r2,r2,-11348
 d041144:	10800b17 	ldw	r2,44(r2)
 d041148:	10c00044 	addi	r3,r2,1
 d04114c:	008341b4 	movhi	r2,3334
 d041150:	10b4eb04 	addi	r2,r2,-11348
 d041154:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 d041158:	01000084 	movi	r4,2
 d04115c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
            pk_free(p);
 d041160:	e13ffe17 	ldw	r4,-8(fp)
 d041164:	d028b380 	call	d028b38 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d041168:	01000084 	movi	r4,2
 d04116c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 d041170:	00bff7c4 	movi	r2,-33
 d041174:	e0bfff15 	stw	r2,-4(fp)
 d041178:	0000ae06 	br	d041434 <ip_rcv_phase2+0x5f4>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 d04117c:	e0bffc17 	ldw	r2,-16(fp)
 d041180:	10c00417 	ldw	r3,16(r2)
 d041184:	e0bff817 	ldw	r2,-32(fp)
 d041188:	10800a17 	ldw	r2,40(r2)
 d04118c:	18806226 	beq	r3,r2,d041318 <ip_rcv_phase2+0x4d8>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 d041190:	e0bffc17 	ldw	r2,-16(fp)
 d041194:	10c00417 	ldw	r3,16(r2)
 d041198:	e0bff817 	ldw	r2,-32(fp)
 d04119c:	10800e17 	ldw	r2,56(r2)
 d0411a0:	18805d26 	beq	r3,r2,d041318 <ip_rcv_phase2+0x4d8>
 d0411a4:	e0bffc17 	ldw	r2,-16(fp)
 d0411a8:	10c00417 	ldw	r3,16(r2)
 d0411ac:	e0bffe17 	ldw	r2,-8(fp)
 d0411b0:	10800617 	ldw	r2,24(r2)
 d0411b4:	10800e17 	ldw	r2,56(r2)
 d0411b8:	18805726 	beq	r3,r2,d041318 <ip_rcv_phase2+0x4d8>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 d0411bc:	e0fffe17 	ldw	r3,-8(fp)
 d0411c0:	e0bff817 	ldw	r2,-32(fp)
 d0411c4:	18800615 	stw	r2,24(r3)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 d0411c8:	e0bffe17 	ldw	r2,-8(fp)
 d0411cc:	10c00417 	ldw	r3,16(r2)
 d0411d0:	e0bffe17 	ldw	r2,-8(fp)
 d0411d4:	10800617 	ldw	r2,24(r2)
 d0411d8:	10800817 	ldw	r2,32(r2)
 d0411dc:	1887883a 	add	r3,r3,r2
 d0411e0:	e0bff817 	ldw	r2,-32(fp)
 d0411e4:	10800917 	ldw	r2,36(r2)
 d0411e8:	10c0372e 	bgeu	r2,r3,d0412c8 <ip_rcv_phase2+0x488>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 d0411ec:	e0bffc17 	ldw	r2,-16(fp)
 d0411f0:	1080018b 	ldhu	r2,6(r2)
 d0411f4:	10bfffcc 	andi	r2,r2,65535
 d0411f8:	1004d23a 	srli	r2,r2,8
 d0411fc:	10bfffcc 	andi	r2,r2,65535
 d041200:	10c03fcc 	andi	r3,r2,255
 d041204:	e0bffc17 	ldw	r2,-16(fp)
 d041208:	1080018b 	ldhu	r2,6(r2)
 d04120c:	10bfffcc 	andi	r2,r2,65535
 d041210:	1004923a 	slli	r2,r2,8
 d041214:	10bfc00c 	andi	r2,r2,65280
 d041218:	1884b03a 	or	r2,r3,r2
 d04121c:	1090000c 	andi	r2,r2,16384
 d041220:	1005003a 	cmpeq	r2,r2,zero
 d041224:	10001b1e 	bne	r2,zero,d041294 <ip_rcv_phase2+0x454>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 d041228:	e0bffc17 	ldw	r2,-16(fp)
 d04122c:	11000317 	ldw	r4,12(r2)
 d041230:	e0bffe17 	ldw	r2,-8(fp)
 d041234:	10800617 	ldw	r2,24(r2)
 d041238:	11400a17 	ldw	r5,40(r2)
 d04123c:	e0bffe17 	ldw	r2,-8(fp)
 d041240:	10800617 	ldw	r2,24(r2)
 d041244:	d8800015 	stw	r2,0(sp)
 d041248:	e1bffc17 	ldw	r6,-16(fp)
 d04124c:	01c00104 	movi	r7,4
 d041250:	d0497540 	call	d049754 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 d041254:	008341b4 	movhi	r2,3334
 d041258:	10b4eb04 	addi	r2,r2,-11348
 d04125c:	10801117 	ldw	r2,68(r2)
 d041260:	10c00044 	addi	r3,r2,1
 d041264:	008341b4 	movhi	r2,3334
 d041268:	10b4eb04 	addi	r2,r2,-11348
 d04126c:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 d041270:	01000084 	movi	r4,2
 d041274:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
               pk_free(p);
 d041278:	e13ffe17 	ldw	r4,-8(fp)
 d04127c:	d028b380 	call	d028b38 <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d041280:	01000084 	movi	r4,2
 d041284:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 d041288:	00bffd44 	movi	r2,-11
 d04128c:	e0bfff15 	stw	r2,-4(fp)
 d041290:	00006806 	br	d041434 <ip_rcv_phase2+0x5f4>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 d041294:	e0bffc17 	ldw	r2,-16(fp)
 d041298:	10800203 	ldbu	r2,8(r2)
 d04129c:	10bfffc4 	addi	r2,r2,-1
 d0412a0:	1007883a 	mov	r3,r2
 d0412a4:	e0bffc17 	ldw	r2,-16(fp)
 d0412a8:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 d0412ac:	e17ffd17 	ldw	r5,-12(fp)
 d0412b0:	e13ffe17 	ldw	r4,-8(fp)
 d0412b4:	d03df7c0 	call	d03df7c <ip_fragment>
 d0412b8:	e0bff715 	stw	r2,-36(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 d0412bc:	e0bff717 	ldw	r2,-36(fp)
 d0412c0:	e0bfff15 	stw	r2,-4(fp)
 d0412c4:	00005b06 	br	d041434 <ip_rcv_phase2+0x5f4>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 d0412c8:	e0bffc17 	ldw	r2,-16(fp)
 d0412cc:	10800203 	ldbu	r2,8(r2)
 d0412d0:	10bfffc4 	addi	r2,r2,-1
 d0412d4:	1007883a 	mov	r3,r2
 d0412d8:	e0bffc17 	ldw	r2,-16(fp)
 d0412dc:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 d0412e0:	e0bffc17 	ldw	r2,-16(fp)
 d0412e4:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 d0412e8:	e13ffc17 	ldw	r4,-16(fp)
 d0412ec:	01400284 	movi	r5,10
 d0412f0:	d0242340 	call	d024234 <cksum>
 d0412f4:	0084303a 	nor	r2,zero,r2
 d0412f8:	1007883a 	mov	r3,r2
 d0412fc:	e0bffc17 	ldw	r2,-16(fp)
 d041300:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 d041304:	e17ffd17 	ldw	r5,-12(fp)
 d041308:	e13ffe17 	ldw	r4,-8(fp)
 d04130c:	d021fd40 	call	d021fd4 <ip2mac>
 d041310:	e0bfff15 	stw	r2,-4(fp)
 d041314:	00004706 	br	d041434 <ip_rcv_phase2+0x5f4>
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 d041318:	e0bffc17 	ldw	r2,-16(fp)
 d04131c:	1080018b 	ldhu	r2,6(r2)
 d041320:	10bfffcc 	andi	r2,r2,65535
 d041324:	1004d23a 	srli	r2,r2,8
 d041328:	10803fcc 	andi	r2,r2,255
 d04132c:	1009883a 	mov	r4,r2
 d041330:	e0bffc17 	ldw	r2,-16(fp)
 d041334:	1080018b 	ldhu	r2,6(r2)
 d041338:	10bfffcc 	andi	r2,r2,65535
 d04133c:	1004923a 	slli	r2,r2,8
 d041340:	1007883a 	mov	r3,r2
 d041344:	00bfc004 	movi	r2,-256
 d041348:	1884703a 	and	r2,r3,r2
 d04134c:	2084b03a 	or	r2,r4,r2
 d041350:	e0bffa0d 	sth	r2,-24(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 d041354:	e0bffa0b 	ldhu	r2,-24(fp)
 d041358:	1088000c 	andi	r2,r2,8192
 d04135c:	1004c03a 	cmpne	r2,r2,zero
 d041360:	1000061e 	bne	r2,zero,d04137c <ip_rcv_phase2+0x53c>
 d041364:	e0fffa0b 	ldhu	r3,-24(fp)
 d041368:	00bffff4 	movhi	r2,65535
 d04136c:	1087ffc4 	addi	r2,r2,8191
 d041370:	1884703a 	and	r2,r3,r2
 d041374:	1005003a 	cmpeq	r2,r2,zero
 d041378:	10002b1e 	bne	r2,zero,d041428 <ip_rcv_phase2+0x5e8>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d04137c:	00834174 	movhi	r2,3333
 d041380:	108aa404 	addi	r2,r2,10896
 d041384:	10800017 	ldw	r2,0(r2)
 d041388:	1081000c 	andi	r2,r2,1024
 d04138c:	1005003a 	cmpeq	r2,r2,zero
 d041390:	10001a1e 	bne	r2,zero,d0413fc <ip_rcv_phase2+0x5bc>
 d041394:	00834174 	movhi	r2,3333
 d041398:	108aa404 	addi	r2,r2,10896
 d04139c:	10800017 	ldw	r2,0(r2)
 d0413a0:	1080800c 	andi	r2,r2,512
 d0413a4:	1005003a 	cmpeq	r2,r2,zero
 d0413a8:	1000141e 	bne	r2,zero,d0413fc <ip_rcv_phase2+0x5bc>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 d0413ac:	e0bffc17 	ldw	r2,-16(fp)
 d0413b0:	10800317 	ldw	r2,12(r2)
 d0413b4:	11403fcc 	andi	r5,r2,255
 d0413b8:	e0bffc17 	ldw	r2,-16(fp)
 d0413bc:	10800317 	ldw	r2,12(r2)
 d0413c0:	1004d23a 	srli	r2,r2,8
 d0413c4:	11803fcc 	andi	r6,r2,255
 d0413c8:	e0bffc17 	ldw	r2,-16(fp)
 d0413cc:	10800317 	ldw	r2,12(r2)
 d0413d0:	1004d43a 	srli	r2,r2,16
 d0413d4:	11c03fcc 	andi	r7,r2,255
 d0413d8:	e0bffc17 	ldw	r2,-16(fp)
 d0413dc:	10800317 	ldw	r2,12(r2)
 d0413e0:	1004d63a 	srli	r2,r2,24
 d0413e4:	d8800015 	stw	r2,0(sp)
 d0413e8:	01034174 	movhi	r4,3333
 d0413ec:	213fc004 	addi	r4,r4,-256
 d0413f0:	d0029980 	call	d002998 <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 d0413f4:	e13ffe17 	ldw	r4,-8(fp)
 d0413f8:	d03e6540 	call	d03e654 <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 d0413fc:	008341b4 	movhi	r2,3334
 d041400:	10b4eb04 	addi	r2,r2,-11348
 d041404:	10800d17 	ldw	r2,52(r2)
 d041408:	10c00044 	addi	r3,r2,1
 d04140c:	008341b4 	movhi	r2,3334
 d041410:	10b4eb04 	addi	r2,r2,-11348
 d041414:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 d041418:	e13ffe17 	ldw	r4,-8(fp)
 d04141c:	d03f32c0 	call	d03f32c <ip_reassm>
 d041420:	e0bfff15 	stw	r2,-4(fp)
 d041424:	00000306 	br	d041434 <ip_rcv_phase2+0x5f4>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 d041428:	e13ffe17 	ldw	r4,-8(fp)
 d04142c:	d04144c0 	call	d04144c <ip_demux>
 d041430:	e0bfff15 	stw	r2,-4(fp)
 d041434:	e0bfff17 	ldw	r2,-4(fp)
}
 d041438:	e037883a 	mov	sp,fp
 d04143c:	dfc00117 	ldw	ra,4(sp)
 d041440:	df000017 	ldw	fp,0(sp)
 d041444:	dec00204 	addi	sp,sp,8
 d041448:	f800283a 	ret

0d04144c <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 d04144c:	defff704 	addi	sp,sp,-36
 d041450:	dfc00815 	stw	ra,32(sp)
 d041454:	df000715 	stw	fp,28(sp)
 d041458:	df000704 	addi	fp,sp,28
 d04145c:	e13ffd15 	stw	r4,-12(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 d041460:	e0bffd17 	ldw	r2,-12(fp)
 d041464:	10800317 	ldw	r2,12(r2)
 d041468:	e0bffc15 	stw	r2,-16(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 d04146c:	e0bffc17 	ldw	r2,-16(fp)
 d041470:	10800003 	ldbu	r2,0(r2)
 d041474:	10803fcc 	andi	r2,r2,255
 d041478:	10801160 	cmpeqi	r2,r2,69
 d04147c:	1000131e 	bne	r2,zero,d0414cc <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 d041480:	e0bffc17 	ldw	r2,-16(fp)
 d041484:	10800003 	ldbu	r2,0(r2)
 d041488:	10803fcc 	andi	r2,r2,255
 d04148c:	10801170 	cmpltui	r2,r2,69
 d041490:	1000051e 	bne	r2,zero,d0414a8 <ip_demux+0x5c>
 d041494:	e0bffc17 	ldw	r2,-16(fp)
 d041498:	10800003 	ldbu	r2,0(r2)
 d04149c:	10803fcc 	andi	r2,r2,255
 d0414a0:	10801230 	cmpltui	r2,r2,72
 d0414a4:	1000091e 	bne	r2,zero,d0414cc <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 d0414a8:	e0bffc17 	ldw	r2,-16(fp)
 d0414ac:	10800003 	ldbu	r2,0(r2)
 d0414b0:	11403fcc 	andi	r5,r2,255
 d0414b4:	01034174 	movhi	r4,3333
 d0414b8:	213fc904 	addi	r4,r4,-220
 d0414bc:	d0029980 	call	d002998 <printf>
         return ENP_LOGIC;
 d0414c0:	00bffd44 	movi	r2,-11
 d0414c4:	e0bfff15 	stw	r2,-4(fp)
 d0414c8:	0000e606 	br	d041864 <ip_demux+0x418>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 d0414cc:	e0bffc17 	ldw	r2,-16(fp)
 d0414d0:	10c00317 	ldw	r3,12(r2)
 d0414d4:	e0bffd17 	ldw	r2,-12(fp)
 d0414d8:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d0414dc:	00834174 	movhi	r2,3333
 d0414e0:	108aa404 	addi	r2,r2,10896
 d0414e4:	10800017 	ldw	r2,0(r2)
 d0414e8:	1081000c 	andi	r2,r2,1024
 d0414ec:	1005003a 	cmpeq	r2,r2,zero
 d0414f0:	1000241e 	bne	r2,zero,d041584 <ip_demux+0x138>
 d0414f4:	00834174 	movhi	r2,3333
 d0414f8:	108aa404 	addi	r2,r2,10896
 d0414fc:	10800017 	ldw	r2,0(r2)
 d041500:	1080800c 	andi	r2,r2,512
 d041504:	1005003a 	cmpeq	r2,r2,zero
 d041508:	10001e1e 	bne	r2,zero,d041584 <ip_demux+0x138>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 d04150c:	e0bffc17 	ldw	r2,-16(fp)
 d041510:	10800243 	ldbu	r2,9(r2)
 d041514:	11403fcc 	andi	r5,r2,255
 d041518:	e0bffc17 	ldw	r2,-16(fp)
 d04151c:	10800317 	ldw	r2,12(r2)
 d041520:	11803fcc 	andi	r6,r2,255
 d041524:	e0bffc17 	ldw	r2,-16(fp)
 d041528:	10800317 	ldw	r2,12(r2)
 d04152c:	1004d23a 	srli	r2,r2,8
 d041530:	11c03fcc 	andi	r7,r2,255
 d041534:	e0bffc17 	ldw	r2,-16(fp)
 d041538:	10800317 	ldw	r2,12(r2)
 d04153c:	1004d43a 	srli	r2,r2,16
 d041540:	10c03fcc 	andi	r3,r2,255
 d041544:	e0bffc17 	ldw	r2,-16(fp)
 d041548:	10800317 	ldw	r2,12(r2)
 d04154c:	1004d63a 	srli	r2,r2,24
 d041550:	d8c00015 	stw	r3,0(sp)
 d041554:	d8800115 	stw	r2,4(sp)
 d041558:	01034174 	movhi	r4,3333
 d04155c:	213fd004 	addi	r4,r4,-192
 d041560:	d0029980 	call	d002998 <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 d041564:	00834174 	movhi	r2,3333
 d041568:	108aa404 	addi	r2,r2,10896
 d04156c:	10800017 	ldw	r2,0(r2)
 d041570:	1080008c 	andi	r2,r2,2
 d041574:	1005003a 	cmpeq	r2,r2,zero
 d041578:	1000021e 	bne	r2,zero,d041584 <ip_demux+0x138>
 d04157c:	e13ffd17 	ldw	r4,-12(fp)
 d041580:	d03e6540 	call	d03e654 <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 d041584:	e0bffc17 	ldw	r2,-16(fp)
 d041588:	10800243 	ldbu	r2,9(r2)
 d04158c:	10803fcc 	andi	r2,r2,255
 d041590:	e0bffe15 	stw	r2,-8(fp)
 d041594:	e0fffe17 	ldw	r3,-8(fp)
 d041598:	188000a0 	cmpeqi	r2,r3,2
 d04159c:	1000241e 	bne	r2,zero,d041630 <ip_demux+0x1e4>
 d0415a0:	e0fffe17 	ldw	r3,-8(fp)
 d0415a4:	188000c8 	cmpgei	r2,r3,3
 d0415a8:	1000041e 	bne	r2,zero,d0415bc <ip_demux+0x170>
 d0415ac:	e0fffe17 	ldw	r3,-8(fp)
 d0415b0:	18800060 	cmpeqi	r2,r3,1
 d0415b4:	1000131e 	bne	r2,zero,d041604 <ip_demux+0x1b8>
 d0415b8:	00003306 	br	d041688 <ip_demux+0x23c>
 d0415bc:	e0fffe17 	ldw	r3,-8(fp)
 d0415c0:	188001a0 	cmpeqi	r2,r3,6
 d0415c4:	1000251e 	bne	r2,zero,d04165c <ip_demux+0x210>
 d0415c8:	e0fffe17 	ldw	r3,-8(fp)
 d0415cc:	18800460 	cmpeqi	r2,r3,17
 d0415d0:	1000011e 	bne	r2,zero,d0415d8 <ip_demux+0x18c>
 d0415d4:	00002c06 	br	d041688 <ip_demux+0x23c>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 d0415d8:	008341b4 	movhi	r2,3334
 d0415dc:	10b4eb04 	addi	r2,r2,-11348
 d0415e0:	10800817 	ldw	r2,32(r2)
 d0415e4:	10c00044 	addi	r3,r2,1
 d0415e8:	008341b4 	movhi	r2,3334
 d0415ec:	10b4eb04 	addi	r2,r2,-11348
 d0415f0:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 d0415f4:	e13ffd17 	ldw	r4,-12(fp)
 d0415f8:	d0428900 	call	d042890 <udpdemux>
 d0415fc:	e0bffb15 	stw	r2,-20(fp)
      break;
 d041600:	00002b06 	br	d0416b0 <ip_demux+0x264>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 d041604:	008341b4 	movhi	r2,3334
 d041608:	10b4eb04 	addi	r2,r2,-11348
 d04160c:	10800817 	ldw	r2,32(r2)
 d041610:	10c00044 	addi	r3,r2,1
 d041614:	008341b4 	movhi	r2,3334
 d041618:	10b4eb04 	addi	r2,r2,-11348
 d04161c:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 d041620:	e13ffd17 	ldw	r4,-12(fp)
 d041624:	d048b200 	call	d048b20 <icmprcv>
 d041628:	e0bffb15 	stw	r2,-20(fp)
      break;
 d04162c:	00002006 	br	d0416b0 <ip_demux+0x264>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 d041630:	008341b4 	movhi	r2,3334
 d041634:	10b4eb04 	addi	r2,r2,-11348
 d041638:	10800817 	ldw	r2,32(r2)
 d04163c:	10c00044 	addi	r3,r2,1
 d041640:	008341b4 	movhi	r2,3334
 d041644:	10b4eb04 	addi	r2,r2,-11348
 d041648:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 d04164c:	e13ffd17 	ldw	r4,-12(fp)
 d041650:	d0226d80 	call	d0226d8 <igmp_input>
 d041654:	e0bffb15 	stw	r2,-20(fp)
      break;
 d041658:	00001506 	br	d0416b0 <ip_demux+0x264>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 d04165c:	008341b4 	movhi	r2,3334
 d041660:	10b4eb04 	addi	r2,r2,-11348
 d041664:	10800817 	ldw	r2,32(r2)
 d041668:	10c00044 	addi	r3,r2,1
 d04166c:	008341b4 	movhi	r2,3334
 d041670:	10b4eb04 	addi	r2,r2,-11348
 d041674:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 d041678:	e13ffd17 	ldw	r4,-12(fp)
 d04167c:	d02ad0c0 	call	d02ad0c <tcp_rcv>
 d041680:	e0bffb15 	stw	r2,-20(fp)
      break;
 d041684:	00000a06 	br	d0416b0 <ip_demux+0x264>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 d041688:	008341b4 	movhi	r2,3334
 d04168c:	10b4eb04 	addi	r2,r2,-11348
 d041690:	10800817 	ldw	r2,32(r2)
 d041694:	10c00044 	addi	r3,r2,1
 d041698:	008341b4 	movhi	r2,3334
 d04169c:	10b4eb04 	addi	r2,r2,-11348
 d0416a0:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 d0416a4:	e13ffd17 	ldw	r4,-12(fp)
 d0416a8:	d041e000 	call	d041e00 <ip_raw_input>
 d0416ac:	e0bffb15 	stw	r2,-20(fp)
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 d0416b0:	e0bffb17 	ldw	r2,-20(fp)
 d0416b4:	10bffda0 	cmpeqi	r2,r2,-10
 d0416b8:	1000031e 	bne	r2,zero,d0416c8 <ip_demux+0x27c>
   {
      return err;
 d0416bc:	e0bffb17 	ldw	r2,-20(fp)
 d0416c0:	e0bfff15 	stw	r2,-4(fp)
 d0416c4:	00006706 	br	d041864 <ip_demux+0x418>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 d0416c8:	e0bffc17 	ldw	r2,-16(fp)
 d0416cc:	10800417 	ldw	r2,16(r2)
 d0416d0:	10bfffe0 	cmpeqi	r2,r2,-1
 d0416d4:	1000541e 	bne	r2,zero,d041828 <ip_demux+0x3dc>
 d0416d8:	e0bffc17 	ldw	r2,-16(fp)
 d0416dc:	10800417 	ldw	r2,16(r2)
 d0416e0:	1004d63a 	srli	r2,r2,24
 d0416e4:	10c03fcc 	andi	r3,r2,255
 d0416e8:	e0bffc17 	ldw	r2,-16(fp)
 d0416ec:	10800417 	ldw	r2,16(r2)
 d0416f0:	1004d23a 	srli	r2,r2,8
 d0416f4:	10bfc00c 	andi	r2,r2,65280
 d0416f8:	1886b03a 	or	r3,r3,r2
 d0416fc:	e0bffc17 	ldw	r2,-16(fp)
 d041700:	10800417 	ldw	r2,16(r2)
 d041704:	10bfc00c 	andi	r2,r2,65280
 d041708:	1004923a 	slli	r2,r2,8
 d04170c:	1886b03a 	or	r3,r3,r2
 d041710:	e0bffc17 	ldw	r2,-16(fp)
 d041714:	10800417 	ldw	r2,16(r2)
 d041718:	10803fcc 	andi	r2,r2,255
 d04171c:	1004963a 	slli	r2,r2,24
 d041720:	1884b03a 	or	r2,r3,r2
 d041724:	10fc002c 	andhi	r3,r2,61440
 d041728:	00b80034 	movhi	r2,57344
 d04172c:	18803e26 	beq	r3,r2,d041828 <ip_demux+0x3dc>
 d041730:	e0bffc17 	ldw	r2,-16(fp)
 d041734:	10c00417 	ldw	r3,16(r2)
 d041738:	e0bffd17 	ldw	r2,-12(fp)
 d04173c:	10800617 	ldw	r2,24(r2)
 d041740:	10800e17 	ldw	r2,56(r2)
 d041744:	18803826 	beq	r3,r2,d041828 <ip_demux+0x3dc>
 d041748:	e0bffc17 	ldw	r2,-16(fp)
 d04174c:	10c00417 	ldw	r3,16(r2)
 d041750:	e0bffd17 	ldw	r2,-12(fp)
 d041754:	10800617 	ldw	r2,24(r2)
 d041758:	10800f17 	ldw	r2,60(r2)
 d04175c:	18803226 	beq	r3,r2,d041828 <ip_demux+0x3dc>
 d041760:	e0bffc17 	ldw	r2,-16(fp)
 d041764:	10c00417 	ldw	r3,16(r2)
 d041768:	e0bffd17 	ldw	r2,-12(fp)
 d04176c:	10800617 	ldw	r2,24(r2)
 d041770:	10801017 	ldw	r2,64(r2)
 d041774:	18802c26 	beq	r3,r2,d041828 <ip_demux+0x3dc>
 d041778:	e0bffd17 	ldw	r2,-12(fp)
 d04177c:	10800617 	ldw	r2,24(r2)
 d041780:	10c00a17 	ldw	r3,40(r2)
 d041784:	e0bffd17 	ldw	r2,-12(fp)
 d041788:	10800617 	ldw	r2,24(r2)
 d04178c:	10801017 	ldw	r2,64(r2)
 d041790:	18802526 	beq	r3,r2,d041828 <ip_demux+0x3dc>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d041794:	00834174 	movhi	r2,3333
 d041798:	108aa404 	addi	r2,r2,10896
 d04179c:	10800017 	ldw	r2,0(r2)
 d0417a0:	1081000c 	andi	r2,r2,1024
 d0417a4:	1005003a 	cmpeq	r2,r2,zero
 d0417a8:	1000141e 	bne	r2,zero,d0417fc <ip_demux+0x3b0>
 d0417ac:	00834174 	movhi	r2,3333
 d0417b0:	108aa404 	addi	r2,r2,10896
 d0417b4:	10800017 	ldw	r2,0(r2)
 d0417b8:	1080800c 	andi	r2,r2,512
 d0417bc:	1005003a 	cmpeq	r2,r2,zero
 d0417c0:	10000e1e 	bne	r2,zero,d0417fc <ip_demux+0x3b0>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 d0417c4:	e0bffc17 	ldw	r2,-16(fp)
 d0417c8:	10800243 	ldbu	r2,9(r2)
 d0417cc:	11403fcc 	andi	r5,r2,255
 d0417d0:	01034174 	movhi	r4,3333
 d0417d4:	213fda04 	addi	r4,r4,-152
 d0417d8:	d0029980 	call	d002998 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 d0417dc:	00834174 	movhi	r2,3333
 d0417e0:	108aa404 	addi	r2,r2,10896
 d0417e4:	10800017 	ldw	r2,0(r2)
 d0417e8:	1080008c 	andi	r2,r2,2
 d0417ec:	1005003a 	cmpeq	r2,r2,zero
 d0417f0:	1000021e 	bne	r2,zero,d0417fc <ip_demux+0x3b0>
 d0417f4:	e13ffd17 	ldw	r4,-12(fp)
 d0417f8:	d03e6540 	call	d03e654 <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 d0417fc:	e0bffc17 	ldw	r2,-16(fp)
 d041800:	11000317 	ldw	r4,12(r2)
 d041804:	e0bffd17 	ldw	r2,-12(fp)
 d041808:	10800617 	ldw	r2,24(r2)
 d04180c:	11400a17 	ldw	r5,40(r2)
 d041810:	e0bffd17 	ldw	r2,-12(fp)
 d041814:	10800617 	ldw	r2,24(r2)
 d041818:	d8800015 	stw	r2,0(sp)
 d04181c:	e1bffc17 	ldw	r6,-16(fp)
 d041820:	01c00084 	movi	r7,2
 d041824:	d0497540 	call	d049754 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 d041828:	008341b4 	movhi	r2,3334
 d04182c:	10b4eb04 	addi	r2,r2,-11348
 d041830:	10800617 	ldw	r2,24(r2)
 d041834:	10c00044 	addi	r3,r2,1
 d041838:	008341b4 	movhi	r2,3334
 d04183c:	10b4eb04 	addi	r2,r2,-11348
 d041840:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d041844:	01000084 	movi	r4,2
 d041848:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free(p);
 d04184c:	e13ffd17 	ldw	r4,-12(fp)
 d041850:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d041854:	01000084 	movi	r4,2
 d041858:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 d04185c:	00c00084 	movi	r3,2
 d041860:	e0ffff15 	stw	r3,-4(fp)
 d041864:	e0bfff17 	ldw	r2,-4(fp)
}
 d041868:	e037883a 	mov	sp,fp
 d04186c:	dfc00117 	ldw	ra,4(sp)
 d041870:	df000017 	ldw	fp,0(sp)
 d041874:	dec00204 	addi	sp,sp,8
 d041878:	f800283a 	ret

0d04187c <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 d04187c:	defff804 	addi	sp,sp,-32
 d041880:	dfc00715 	stw	ra,28(sp)
 d041884:	df000615 	stw	fp,24(sp)
 d041888:	df000604 	addi	fp,sp,24
 d04188c:	e13ffc15 	stw	r4,-16(fp)
 d041890:	e17ffd15 	stw	r5,-12(fp)
 d041894:	e1bffe15 	stw	r6,-8(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 d041898:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 d04189c:	e0bffc17 	ldw	r2,-16(fp)
 d0418a0:	1005003a 	cmpeq	r2,r2,zero
 d0418a4:	1000041e 	bne	r2,zero,d0418b8 <in_addmulti+0x3c>
 d0418a8:	e0bffc17 	ldw	r2,-16(fp)
 d0418ac:	10800017 	ldw	r2,0(r2)
 d0418b0:	1004c03a 	cmpne	r2,r2,zero
 d0418b4:	1000021e 	bne	r2,zero,d0418c0 <in_addmulti+0x44>
      return ((struct in_multi *)NULL);  
 d0418b8:	e03fff15 	stw	zero,-4(fp)
 d0418bc:	00004306 	br	d0419cc <in_addmulti+0x150>

   ENTER_CRIT_SECTION(netp);
 d0418c0:	d0295e80 	call	d0295e8 <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 d0418c4:	e0bffe17 	ldw	r2,-8(fp)
 d0418c8:	108001a0 	cmpeqi	r2,r2,6
 d0418cc:	1000051e 	bne	r2,zero,d0418e4 <in_addmulti+0x68>
      inm = lookup_mcast(*ap, netp);
 d0418d0:	e0bffc17 	ldw	r2,-16(fp)
 d0418d4:	11000017 	ldw	r4,0(r2)
 d0418d8:	e17ffd17 	ldw	r5,-12(fp)
 d0418dc:	d041afc0 	call	d041afc <lookup_mcast>
 d0418e0:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 d0418e4:	e0bffb17 	ldw	r2,-20(fp)
 d0418e8:	1005003a 	cmpeq	r2,r2,zero
 d0418ec:	1000061e 	bne	r2,zero,d041908 <in_addmulti+0x8c>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 d0418f0:	e0bffb17 	ldw	r2,-20(fp)
 d0418f4:	10800217 	ldw	r2,8(r2)
 d0418f8:	10c00044 	addi	r3,r2,1
 d0418fc:	e0bffb17 	ldw	r2,-20(fp)
 d041900:	10c00215 	stw	r3,8(r2)
 d041904:	00002e06 	br	d0419c0 <in_addmulti+0x144>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 d041908:	01000604 	movi	r4,24
 d04190c:	d029e2c0 	call	d029e2c <npalloc>
 d041910:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 d041914:	e0bffb17 	ldw	r2,-20(fp)
 d041918:	1004c03a 	cmpne	r2,r2,zero
 d04191c:	1000031e 	bne	r2,zero,d04192c <in_addmulti+0xb0>
      {
         EXIT_CRIT_SECTION(netp);
 d041920:	d0296440 	call	d029644 <irq_Unmask>
         return ((struct in_multi *)NULL);
 d041924:	e03fff15 	stw	zero,-4(fp)
 d041928:	00002806 	br	d0419cc <in_addmulti+0x150>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 d04192c:	e0bffe17 	ldw	r2,-8(fp)
 d041930:	108001a0 	cmpeqi	r2,r2,6
 d041934:	1000041e 	bne	r2,zero,d041948 <in_addmulti+0xcc>
         inm->inm_addr = *ap;
 d041938:	e0bffc17 	ldw	r2,-16(fp)
 d04193c:	10c00017 	ldw	r3,0(r2)
 d041940:	e0bffb17 	ldw	r2,-20(fp)
 d041944:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 d041948:	e0fffb17 	ldw	r3,-20(fp)
 d04194c:	e0bffd17 	ldw	r2,-12(fp)
 d041950:	18800115 	stw	r2,4(r3)
      inm->inm_refcount = 1;
 d041954:	e0fffb17 	ldw	r3,-20(fp)
 d041958:	00800044 	movi	r2,1
 d04195c:	18800215 	stw	r2,8(r3)
      inm->inm_next = netp->mc_list;
 d041960:	e0bffd17 	ldw	r2,-12(fp)
 d041964:	10c02c17 	ldw	r3,176(r2)
 d041968:	e0bffb17 	ldw	r2,-20(fp)
 d04196c:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 d041970:	e0fffd17 	ldw	r3,-12(fp)
 d041974:	e0bffb17 	ldw	r2,-20(fp)
 d041978:	18802c15 	stw	r2,176(r3)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 d04197c:	e0bffd17 	ldw	r2,-12(fp)
 d041980:	10802b17 	ldw	r2,172(r2)
 d041984:	1005003a 	cmpeq	r2,r2,zero
 d041988:	1000061e 	bne	r2,zero,d0419a4 <in_addmulti+0x128>
         error = netp->n_mcastlist(inm);
 d04198c:	e0bffd17 	ldw	r2,-12(fp)
 d041990:	10802b17 	ldw	r2,172(r2)
 d041994:	e13ffb17 	ldw	r4,-20(fp)
 d041998:	103ee83a 	callr	r2
 d04199c:	e0bffa15 	stw	r2,-24(fp)
 d0419a0:	00000106 	br	d0419a8 <in_addmulti+0x12c>
      else
         error = 0;
 d0419a4:	e03ffa15 	stw	zero,-24(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 d0419a8:	e0bffb17 	ldw	r2,-20(fp)
 d0419ac:	10800017 	ldw	r2,0(r2)
 d0419b0:	1005003a 	cmpeq	r2,r2,zero
 d0419b4:	1000021e 	bne	r2,zero,d0419c0 <in_addmulti+0x144>
 d0419b8:	e13ffb17 	ldw	r4,-20(fp)
 d0419bc:	d022c100 	call	d022c10 <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 d0419c0:	d0296440 	call	d029644 <irq_Unmask>
   USE_ARG(error);

   return (inm);
 d0419c4:	e0bffb17 	ldw	r2,-20(fp)
 d0419c8:	e0bfff15 	stw	r2,-4(fp)
 d0419cc:	e0bfff17 	ldw	r2,-4(fp)
}
 d0419d0:	e037883a 	mov	sp,fp
 d0419d4:	dfc00117 	ldw	ra,4(sp)
 d0419d8:	df000017 	ldw	fp,0(sp)
 d0419dc:	dec00204 	addi	sp,sp,8
 d0419e0:	f800283a 	ret

0d0419e4 <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 d0419e4:	defffa04 	addi	sp,sp,-24
 d0419e8:	dfc00515 	stw	ra,20(sp)
 d0419ec:	df000415 	stw	fp,16(sp)
 d0419f0:	df000404 	addi	fp,sp,16
 d0419f4:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 d0419f8:	e0bfff17 	ldw	r2,-4(fp)
 d0419fc:	10800117 	ldw	r2,4(r2)
 d041a00:	e0bffd15 	stw	r2,-12(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 d041a04:	d0295e80 	call	d0295e8 <irq_Mask>
   if (--inm->inm_refcount == 0) 
 d041a08:	e0bfff17 	ldw	r2,-4(fp)
 d041a0c:	10800217 	ldw	r2,8(r2)
 d041a10:	10ffffc4 	addi	r3,r2,-1
 d041a14:	e0bfff17 	ldw	r2,-4(fp)
 d041a18:	10c00215 	stw	r3,8(r2)
 d041a1c:	e0bfff17 	ldw	r2,-4(fp)
 d041a20:	10800217 	ldw	r2,8(r2)
 d041a24:	1004c03a 	cmpne	r2,r2,zero
 d041a28:	10002e1e 	bne	r2,zero,d041ae4 <in_delmulti+0x100>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 d041a2c:	e0bffd17 	ldw	r2,-12(fp)
 d041a30:	10802c17 	ldw	r2,176(r2)
 d041a34:	e0bffe15 	stw	r2,-8(fp)
 d041a38:	00001406 	br	d041a8c <in_delmulti+0xa8>
      {
         if(p == inm)   /* inm is first in mc_list */
 d041a3c:	e0fffe17 	ldw	r3,-8(fp)
 d041a40:	e0bfff17 	ldw	r2,-4(fp)
 d041a44:	1880051e 	bne	r3,r2,d041a5c <in_delmulti+0x78>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 d041a48:	e0bffe17 	ldw	r2,-8(fp)
 d041a4c:	10c00517 	ldw	r3,20(r2)
 d041a50:	e0bffd17 	ldw	r2,-12(fp)
 d041a54:	10c02c15 	stw	r3,176(r2)
            break;
 d041a58:	00000f06 	br	d041a98 <in_delmulti+0xb4>
         }
         else if(p->inm_next == inm)   /* inm is next */
 d041a5c:	e0bffe17 	ldw	r2,-8(fp)
 d041a60:	10c00517 	ldw	r3,20(r2)
 d041a64:	e0bfff17 	ldw	r2,-4(fp)
 d041a68:	1880051e 	bne	r3,r2,d041a80 <in_delmulti+0x9c>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 d041a6c:	e0bfff17 	ldw	r2,-4(fp)
 d041a70:	10c00517 	ldw	r3,20(r2)
 d041a74:	e0bffe17 	ldw	r2,-8(fp)
 d041a78:	10c00515 	stw	r3,20(r2)
            break;
 d041a7c:	00000606 	br	d041a98 <in_delmulti+0xb4>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 d041a80:	e0bffe17 	ldw	r2,-8(fp)
 d041a84:	10800517 	ldw	r2,20(r2)
 d041a88:	e0bffe15 	stw	r2,-8(fp)
 d041a8c:	e0bffe17 	ldw	r2,-8(fp)
 d041a90:	1004c03a 	cmpne	r2,r2,zero
 d041a94:	103fe91e 	bne	r2,zero,d041a3c <in_delmulti+0x58>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 d041a98:	e0bffd17 	ldw	r2,-12(fp)
 d041a9c:	10802b17 	ldw	r2,172(r2)
 d041aa0:	1005003a 	cmpeq	r2,r2,zero
 d041aa4:	1000061e 	bne	r2,zero,d041ac0 <in_delmulti+0xdc>
         error = netp->n_mcastlist(inm);
 d041aa8:	e0bffd17 	ldw	r2,-12(fp)
 d041aac:	10802b17 	ldw	r2,172(r2)
 d041ab0:	e13fff17 	ldw	r4,-4(fp)
 d041ab4:	103ee83a 	callr	r2
 d041ab8:	e0bffc15 	stw	r2,-16(fp)
 d041abc:	00000106 	br	d041ac4 <in_delmulti+0xe0>
      else
         error = 0;
 d041ac0:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 d041ac4:	e0bfff17 	ldw	r2,-4(fp)
 d041ac8:	10800017 	ldw	r2,0(r2)
 d041acc:	1005003a 	cmpeq	r2,r2,zero
 d041ad0:	1000021e 	bne	r2,zero,d041adc <in_delmulti+0xf8>
 d041ad4:	e13fff17 	ldw	r4,-4(fp)
 d041ad8:	d022e8c0 	call	d022e8c <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 d041adc:	e13fff17 	ldw	r4,-4(fp)
 d041ae0:	d029f200 	call	d029f20 <npfree>
   }
   EXIT_CRIT_SECTION(inm);
 d041ae4:	d0296440 	call	d029644 <irq_Unmask>
}
 d041ae8:	e037883a 	mov	sp,fp
 d041aec:	dfc00117 	ldw	ra,4(sp)
 d041af0:	df000017 	ldw	fp,0(sp)
 d041af4:	dec00204 	addi	sp,sp,8
 d041af8:	f800283a 	ret

0d041afc <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 d041afc:	defffb04 	addi	sp,sp,-20
 d041b00:	df000415 	stw	fp,16(sp)
 d041b04:	df000404 	addi	fp,sp,16
 d041b08:	e13ffd15 	stw	r4,-12(fp)
 d041b0c:	e17ffe15 	stw	r5,-8(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 d041b10:	e0bffe17 	ldw	r2,-8(fp)
 d041b14:	10802c17 	ldw	r2,176(r2)
 d041b18:	e0bffc15 	stw	r2,-16(fp)
 d041b1c:	00000a06 	br	d041b48 <lookup_mcast+0x4c>
   {
      if(imp->inm_addr == addr)
 d041b20:	e0bffc17 	ldw	r2,-16(fp)
 d041b24:	10c00017 	ldw	r3,0(r2)
 d041b28:	e0bffd17 	ldw	r2,-12(fp)
 d041b2c:	1880031e 	bne	r3,r2,d041b3c <lookup_mcast+0x40>
         return imp;
 d041b30:	e0bffc17 	ldw	r2,-16(fp)
 d041b34:	e0bfff15 	stw	r2,-4(fp)
 d041b38:	00000706 	br	d041b58 <lookup_mcast+0x5c>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 d041b3c:	e0bffc17 	ldw	r2,-16(fp)
 d041b40:	10800517 	ldw	r2,20(r2)
 d041b44:	e0bffc15 	stw	r2,-16(fp)
 d041b48:	e0bffc17 	ldw	r2,-16(fp)
 d041b4c:	1004c03a 	cmpne	r2,r2,zero
 d041b50:	103ff31e 	bne	r2,zero,d041b20 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 d041b54:	e03fff15 	stw	zero,-4(fp)
 d041b58:	e0bfff17 	ldw	r2,-4(fp)
}
 d041b5c:	e037883a 	mov	sp,fp
 d041b60:	df000017 	ldw	fp,0(sp)
 d041b64:	dec00104 	addi	sp,sp,4
 d041b68:	f800283a 	ret

0d041b6c <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 d041b6c:	defffc04 	addi	sp,sp,-16
 d041b70:	dfc00315 	stw	ra,12(sp)
 d041b74:	df000215 	stw	fp,8(sp)
 d041b78:	df000204 	addi	fp,sp,8
 d041b7c:	e13ffe15 	stw	r4,-8(fp)
   if (port_prep)
 d041b80:	d0a0ca17 	ldw	r2,-31960(gp)
 d041b84:	1005003a 	cmpeq	r2,r2,zero
 d041b88:	1000041e 	bne	r2,zero,d041b9c <prep_ifaces+0x30>
      ifaces_found = port_prep(ifaces_found);
 d041b8c:	d0a0ca17 	ldw	r2,-31960(gp)
 d041b90:	e13ffe17 	ldw	r4,-8(fp)
 d041b94:	103ee83a 	callr	r2
 d041b98:	e0bffe15 	stw	r2,-8(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 d041b9c:	e0fffe17 	ldw	r3,-8(fp)
 d041ba0:	00834174 	movhi	r2,3333
 d041ba4:	108aa504 	addi	r2,r2,10900
 d041ba8:	10c00015 	stw	r3,0(r2)

   initmsg("prepped %u interface%s, initializing...\n", 
 d041bac:	e0bffe17 	ldw	r2,-8(fp)
 d041bb0:	10800058 	cmpnei	r2,r2,1
 d041bb4:	1000041e 	bne	r2,zero,d041bc8 <prep_ifaces+0x5c>
 d041bb8:	00834174 	movhi	r2,3333
 d041bbc:	10bfe204 	addi	r2,r2,-120
 d041bc0:	e0bfff15 	stw	r2,-4(fp)
 d041bc4:	00000306 	br	d041bd4 <prep_ifaces+0x68>
 d041bc8:	00834174 	movhi	r2,3333
 d041bcc:	10bfe304 	addi	r2,r2,-116
 d041bd0:	e0bfff15 	stw	r2,-4(fp)
 d041bd4:	01034174 	movhi	r4,3333
 d041bd8:	213fe404 	addi	r4,r4,-112
 d041bdc:	e17ffe17 	ldw	r5,-8(fp)
 d041be0:	e1bfff17 	ldw	r6,-4(fp)
 d041be4:	d0029980 	call	d002998 <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 d041be8:	e0bffe17 	ldw	r2,-8(fp)
}
 d041bec:	e037883a 	mov	sp,fp
 d041bf0:	dfc00117 	ldw	ra,4(sp)
 d041bf4:	df000017 	ldw	fp,0(sp)
 d041bf8:	dec00204 	addi	sp,sp,8
 d041bfc:	f800283a 	ret

0d041c00 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 d041c00:	defffd04 	addi	sp,sp,-12
 d041c04:	dfc00215 	stw	ra,8(sp)
 d041c08:	df000115 	stw	fp,4(sp)
 d041c0c:	df000104 	addi	fp,sp,4
 d041c10:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 d041c14:	00800044 	movi	r2,1
 d041c18:	d0a0cb15 	stw	r2,-31956(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 d041c1c:	d0224c80 	call	d0224c8 <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 d041c20:	e13fff17 	ldw	r4,-4(fp)
 d041c24:	d049e740 	call	d049e74 <exit>

0d041c28 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 d041c28:	deffff04 	addi	sp,sp,-4
 d041c2c:	df000015 	stw	fp,0(sp)
 d041c30:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 d041c34:	d020ce05 	stb	zero,-31944(gp)
   so_evtmap_create = 0;
 d041c38:	d020cc15 	stw	zero,-31952(gp)
   so_evtmap_delete = 0;
 d041c3c:	d020cd15 	stw	zero,-31948(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 d041c40:	e037883a 	mov	sp,fp
 d041c44:	df000017 	ldw	fp,0(sp)
 d041c48:	dec00104 	addi	sp,sp,4
 d041c4c:	f800283a 	ret

0d041c50 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 d041c50:	defff804 	addi	sp,sp,-32
 d041c54:	dfc00715 	stw	ra,28(sp)
 d041c58:	df000615 	stw	fp,24(sp)
 d041c5c:	df000604 	addi	fp,sp,24
 d041c60:	e17ffc15 	stw	r5,-16(fp)
 d041c64:	e1bffd15 	stw	r6,-12(fp)
 d041c68:	e1fffe15 	stw	r7,-8(fp)
 d041c6c:	e13ffb05 	stb	r4,-20(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 d041c70:	0009883a 	mov	r4,zero
 d041c74:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 d041c78:	01000604 	movi	r4,24
 d041c7c:	d029e2c0 	call	d029e2c <npalloc>
 d041c80:	e0bffa15 	stw	r2,-24(fp)
   if (ep == NULL)
 d041c84:	e0bffa17 	ldw	r2,-24(fp)
 d041c88:	1004c03a 	cmpne	r2,r2,zero
 d041c8c:	10000e1e 	bne	r2,zero,d041cc8 <ip_raw_open+0x78>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 d041c90:	00834174 	movhi	r2,3333
 d041c94:	108aa404 	addi	r2,r2,10896
 d041c98:	10800017 	ldw	r2,0(r2)
 d041c9c:	1080010c 	andi	r2,r2,4
 d041ca0:	1005003a 	cmpeq	r2,r2,zero
 d041ca4:	1000031e 	bne	r2,zero,d041cb4 <ip_raw_open+0x64>
         dprintf("IP: Couldn't allocate ep storage.\n");
 d041ca8:	01034174 	movhi	r4,3333
 d041cac:	213fef04 	addi	r4,r4,-68
 d041cb0:	d002cc00 	call	d002cc0 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 d041cb4:	0009883a 	mov	r4,zero
 d041cb8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ep;
 d041cbc:	e0bffa17 	ldw	r2,-24(fp)
 d041cc0:	e0bfff15 	stw	r2,-4(fp)
 d041cc4:	00001806 	br	d041d28 <ip_raw_open+0xd8>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 d041cc8:	e0fffa17 	ldw	r3,-24(fp)
 d041ccc:	e0bffc17 	ldw	r2,-16(fp)
 d041cd0:	18800115 	stw	r2,4(r3)
   ep->ipr_faddr = faddr;
 d041cd4:	e0fffa17 	ldw	r3,-24(fp)
 d041cd8:	e0bffd17 	ldw	r2,-12(fp)
 d041cdc:	18800215 	stw	r2,8(r3)
   ep->ipr_prot = prot;
 d041ce0:	e0fffa17 	ldw	r3,-24(fp)
 d041ce4:	e0bffb03 	ldbu	r2,-20(fp)
 d041ce8:	18800505 	stb	r2,20(r3)
   ep->ipr_rcv = handler;
 d041cec:	e0fffa17 	ldw	r3,-24(fp)
 d041cf0:	e0bffe17 	ldw	r2,-8(fp)
 d041cf4:	18800315 	stw	r2,12(r3)
   ep->ipr_data = data;
 d041cf8:	e0fffa17 	ldw	r3,-24(fp)
 d041cfc:	e0800217 	ldw	r2,8(fp)
 d041d00:	18800415 	stw	r2,16(r3)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 d041d04:	d0e0cf17 	ldw	r3,-31940(gp)
 d041d08:	e0bffa17 	ldw	r2,-24(fp)
 d041d0c:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 d041d10:	e0bffa17 	ldw	r2,-24(fp)
 d041d14:	d0a0cf15 	stw	r2,-31940(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 d041d18:	0009883a 	mov	r4,zero
 d041d1c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return ep;
 d041d20:	e0bffa17 	ldw	r2,-24(fp)
 d041d24:	e0bfff15 	stw	r2,-4(fp)
 d041d28:	e0bfff17 	ldw	r2,-4(fp)
}
 d041d2c:	e037883a 	mov	sp,fp
 d041d30:	dfc00117 	ldw	ra,4(sp)
 d041d34:	df000017 	ldw	fp,0(sp)
 d041d38:	dec00204 	addi	sp,sp,8
 d041d3c:	f800283a 	ret

0d041d40 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 d041d40:	defffb04 	addi	sp,sp,-20
 d041d44:	dfc00415 	stw	ra,16(sp)
 d041d48:	df000315 	stw	fp,12(sp)
 d041d4c:	df000304 	addi	fp,sp,12
 d041d50:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 d041d54:	0009883a 	mov	r4,zero
 d041d58:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 d041d5c:	e03ffe15 	stw	zero,-8(fp)
 d041d60:	d0a0cf17 	ldw	r2,-31940(gp)
 d041d64:	e0bffd15 	stw	r2,-12(fp)
        curr_ep != NULL;
 d041d68:	00000806 	br	d041d8c <ip_raw_close+0x4c>
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 d041d6c:	e0fffd17 	ldw	r3,-12(fp)
 d041d70:	e0bfff17 	ldw	r2,-4(fp)
 d041d74:	18800826 	beq	r3,r2,d041d98 <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 d041d78:	e0bffd17 	ldw	r2,-12(fp)
 d041d7c:	e0bffe15 	stw	r2,-8(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 d041d80:	e0bffd17 	ldw	r2,-12(fp)
 d041d84:	10800017 	ldw	r2,0(r2)
 d041d88:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
 d041d8c:	e0bffd17 	ldw	r2,-12(fp)
 d041d90:	1004c03a 	cmpne	r2,r2,zero
 d041d94:	103ff51e 	bne	r2,zero,d041d6c <ip_raw_close+0x2c>
         break;
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 d041d98:	e0bffd17 	ldw	r2,-12(fp)
 d041d9c:	1004c03a 	cmpne	r2,r2,zero
 d041da0:	1000041e 	bne	r2,zero,d041db4 <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 d041da4:	d0293e80 	call	d0293e8 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 d041da8:	0009883a 	mov	r4,zero
 d041dac:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return;
 d041db0:	00000e06 	br	d041dec <ip_raw_close+0xac>
   }

   /* unlink it from the list */
   if (prev_ep)
 d041db4:	e0bffe17 	ldw	r2,-8(fp)
 d041db8:	1005003a 	cmpeq	r2,r2,zero
 d041dbc:	1000041e 	bne	r2,zero,d041dd0 <ip_raw_close+0x90>
      prev_ep = curr_ep->ipr_next;
 d041dc0:	e0bffd17 	ldw	r2,-12(fp)
 d041dc4:	10800017 	ldw	r2,0(r2)
 d041dc8:	e0bffe15 	stw	r2,-8(fp)
 d041dcc:	00000306 	br	d041ddc <ip_raw_close+0x9c>
   else
      ipraw_eps = curr_ep->ipr_next;
 d041dd0:	e0bffd17 	ldw	r2,-12(fp)
 d041dd4:	10800017 	ldw	r2,0(r2)
 d041dd8:	d0a0cf15 	stw	r2,-31940(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 d041ddc:	e13ffd17 	ldw	r4,-12(fp)
 d041de0:	d029f200 	call	d029f20 <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 d041de4:	0009883a 	mov	r4,zero
 d041de8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
}
 d041dec:	e037883a 	mov	sp,fp
 d041df0:	dfc00117 	ldw	ra,4(sp)
 d041df4:	df000017 	ldw	fp,0(sp)
 d041df8:	dec00204 	addi	sp,sp,8
 d041dfc:	f800283a 	ret

0d041e00 <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 d041e00:	defff604 	addi	sp,sp,-40
 d041e04:	dfc00915 	stw	ra,36(sp)
 d041e08:	df000815 	stw	fp,32(sp)
 d041e0c:	df000804 	addi	fp,sp,32
 d041e10:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 d041e14:	e03ffb15 	stw	zero,-20(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 d041e18:	e03ff915 	stw	zero,-28(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 d041e1c:	e0bfff17 	ldw	r2,-4(fp)
 d041e20:	10800317 	ldw	r2,12(r2)
 d041e24:	e0bffe15 	stw	r2,-8(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 d041e28:	d0a0cf17 	ldw	r2,-31940(gp)
 d041e2c:	e0bffd15 	stw	r2,-12(fp)
 d041e30:	00004d06 	br	d041f68 <ip_raw_input+0x168>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 d041e34:	e0bffd17 	ldw	r2,-12(fp)
 d041e38:	10800017 	ldw	r2,0(r2)
 d041e3c:	e0bffc15 	stw	r2,-16(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 d041e40:	e0bffd17 	ldw	r2,-12(fp)
 d041e44:	10800503 	ldbu	r2,20(r2)
 d041e48:	10803fcc 	andi	r2,r2,255
 d041e4c:	1005003a 	cmpeq	r2,r2,zero
 d041e50:	1000071e 	bne	r2,zero,d041e70 <ip_raw_input+0x70>
 d041e54:	e0bffd17 	ldw	r2,-12(fp)
 d041e58:	10c00503 	ldbu	r3,20(r2)
 d041e5c:	e0bffe17 	ldw	r2,-8(fp)
 d041e60:	10800243 	ldbu	r2,9(r2)
 d041e64:	18c03fcc 	andi	r3,r3,255
 d041e68:	10803fcc 	andi	r2,r2,255
 d041e6c:	18803c1e 	bne	r3,r2,d041f60 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 d041e70:	e0bffd17 	ldw	r2,-12(fp)
 d041e74:	10800117 	ldw	r2,4(r2)
 d041e78:	1005003a 	cmpeq	r2,r2,zero
 d041e7c:	1000051e 	bne	r2,zero,d041e94 <ip_raw_input+0x94>
 d041e80:	e0bffd17 	ldw	r2,-12(fp)
 d041e84:	10c00117 	ldw	r3,4(r2)
 d041e88:	e0bffe17 	ldw	r2,-8(fp)
 d041e8c:	10800417 	ldw	r2,16(r2)
 d041e90:	1880331e 	bne	r3,r2,d041f60 <ip_raw_input+0x160>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 d041e94:	e0bffd17 	ldw	r2,-12(fp)
 d041e98:	10800217 	ldw	r2,8(r2)
 d041e9c:	1005003a 	cmpeq	r2,r2,zero
 d041ea0:	1000051e 	bne	r2,zero,d041eb8 <ip_raw_input+0xb8>
 d041ea4:	e0bffd17 	ldw	r2,-12(fp)
 d041ea8:	10c00217 	ldw	r3,8(r2)
 d041eac:	e0bffe17 	ldw	r2,-8(fp)
 d041eb0:	10800317 	ldw	r2,12(r2)
 d041eb4:	18802a1e 	bne	r3,r2,d041f60 <ip_raw_input+0x160>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 d041eb8:	e0bffd17 	ldw	r2,-12(fp)
 d041ebc:	10800317 	ldw	r2,12(r2)
 d041ec0:	1005003a 	cmpeq	r2,r2,zero
 d041ec4:	1000261e 	bne	r2,zero,d041f60 <ip_raw_input+0x160>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 d041ec8:	e0bffb17 	ldw	r2,-20(fp)
 d041ecc:	1005003a 	cmpeq	r2,r2,zero
 d041ed0:	1000211e 	bne	r2,zero,d041f58 <ip_raw_input+0x158>
 d041ed4:	e0bffb17 	ldw	r2,-20(fp)
 d041ed8:	10800317 	ldw	r2,12(r2)
 d041edc:	1005003a 	cmpeq	r2,r2,zero
 d041ee0:	10001d1e 	bne	r2,zero,d041f58 <ip_raw_input+0x158>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 d041ee4:	e13fff17 	ldw	r4,-4(fp)
 d041ee8:	d03eb780 	call	d03eb78 <ip_copypkt>
 d041eec:	e0bff815 	stw	r2,-32(fp)
            if (p2)
 d041ef0:	e0bff817 	ldw	r2,-32(fp)
 d041ef4:	1005003a 	cmpeq	r2,r2,zero
 d041ef8:	1000171e 	bne	r2,zero,d041f58 <ip_raw_input+0x158>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 d041efc:	0009883a 	mov	r4,zero
 d041f00:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 d041f04:	e0bffb17 	ldw	r2,-20(fp)
 d041f08:	10c00317 	ldw	r3,12(r2)
 d041f0c:	e0bffb17 	ldw	r2,-20(fp)
 d041f10:	11400417 	ldw	r5,16(r2)
 d041f14:	e13ff817 	ldw	r4,-32(fp)
 d041f18:	183ee83a 	callr	r3
 d041f1c:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 d041f20:	0009883a 	mov	r4,zero
 d041f24:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
               if (err)
 d041f28:	e0bffa17 	ldw	r2,-24(fp)
 d041f2c:	1005003a 	cmpeq	r2,r2,zero
 d041f30:	1000071e 	bne	r2,zero,d041f50 <ip_raw_input+0x150>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 d041f34:	01000084 	movi	r4,2
 d041f38:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
                  pk_free(p2);
 d041f3c:	e13ff817 	ldw	r4,-32(fp)
 d041f40:	d028b380 	call	d028b38 <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d041f44:	01000084 	movi	r4,2
 d041f48:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
 d041f4c:	00000206 	br	d041f58 <ip_raw_input+0x158>
               }
               else
                  delivered = 1;
 d041f50:	00800044 	movi	r2,1
 d041f54:	e0bff915 	stw	r2,-28(fp)
            }
         }
         matched_ep = ep;
 d041f58:	e0bffd17 	ldw	r2,-12(fp)
 d041f5c:	e0bffb15 	stw	r2,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 d041f60:	e0bffc17 	ldw	r2,-16(fp)
 d041f64:	e0bffd15 	stw	r2,-12(fp)
 d041f68:	e0bffd17 	ldw	r2,-12(fp)
 d041f6c:	1004c03a 	cmpne	r2,r2,zero
 d041f70:	103fb01e 	bne	r2,zero,d041e34 <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 d041f74:	e0bffb17 	ldw	r2,-20(fp)
 d041f78:	1005003a 	cmpeq	r2,r2,zero
 d041f7c:	1000151e 	bne	r2,zero,d041fd4 <ip_raw_input+0x1d4>
 d041f80:	e0bffb17 	ldw	r2,-20(fp)
 d041f84:	10800317 	ldw	r2,12(r2)
 d041f88:	1005003a 	cmpeq	r2,r2,zero
 d041f8c:	1000111e 	bne	r2,zero,d041fd4 <ip_raw_input+0x1d4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 d041f90:	0009883a 	mov	r4,zero
 d041f94:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 d041f98:	e0bffb17 	ldw	r2,-20(fp)
 d041f9c:	10c00317 	ldw	r3,12(r2)
 d041fa0:	e0bffb17 	ldw	r2,-20(fp)
 d041fa4:	11400417 	ldw	r5,16(r2)
 d041fa8:	e13fff17 	ldw	r4,-4(fp)
 d041fac:	183ee83a 	callr	r3
 d041fb0:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 d041fb4:	0009883a 	mov	r4,zero
 d041fb8:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      if (err == 0)
 d041fbc:	e0bffa17 	ldw	r2,-24(fp)
 d041fc0:	1004c03a 	cmpne	r2,r2,zero
 d041fc4:	10000c1e 	bne	r2,zero,d041ff8 <ip_raw_input+0x1f8>
         delivered = 1;
 d041fc8:	00800044 	movi	r2,1
 d041fcc:	e0bff915 	stw	r2,-28(fp)
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 d041fd0:	00000906 	br	d041ff8 <ip_raw_input+0x1f8>
      if (err == 0)
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 d041fd4:	00bffd84 	movi	r2,-10
 d041fd8:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 d041fdc:	008341b4 	movhi	r2,3334
 d041fe0:	10b4eb04 	addi	r2,r2,-11348
 d041fe4:	10800617 	ldw	r2,24(r2)
 d041fe8:	10c00044 	addi	r3,r2,1
 d041fec:	008341b4 	movhi	r2,3334
 d041ff0:	10b4eb04 	addi	r2,r2,-11348
 d041ff4:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 d041ff8:	e0bff917 	ldw	r2,-28(fp)
 d041ffc:	1004c03a 	cmpne	r2,r2,zero
 d042000:	1000071e 	bne	r2,zero,d042020 <ip_raw_input+0x220>
      ip_mib.ipInDelivers--;
 d042004:	008341b4 	movhi	r2,3334
 d042008:	10b4eb04 	addi	r2,r2,-11348
 d04200c:	10800817 	ldw	r2,32(r2)
 d042010:	10ffffc4 	addi	r3,r2,-1
 d042014:	008341b4 	movhi	r2,3334
 d042018:	10b4eb04 	addi	r2,r2,-11348
 d04201c:	10c00815 	stw	r3,32(r2)

   return err;
 d042020:	e0bffa17 	ldw	r2,-24(fp)
}
 d042024:	e037883a 	mov	sp,fp
 d042028:	dfc00117 	ldw	ra,4(sp)
 d04202c:	df000017 	ldw	fp,0(sp)
 d042030:	dec00204 	addi	sp,sp,8
 d042034:	f800283a 	ret

0d042038 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 d042038:	defffa04 	addi	sp,sp,-24
 d04203c:	dfc00515 	stw	ra,20(sp)
 d042040:	df000415 	stw	fp,16(sp)
 d042044:	df000404 	addi	fp,sp,16
 d042048:	e13ffe15 	stw	r4,-8(fp)
 d04204c:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 d042050:	e0bffe17 	ldw	r2,-8(fp)
 d042054:	10c00044 	addi	r3,r2,1
 d042058:	00bfff84 	movi	r2,-2
 d04205c:	1884703a 	and	r2,r3,r2
 d042060:	e0bffd15 	stw	r2,-12(fp)
   if (!hdrincl)
 d042064:	e0bfff17 	ldw	r2,-4(fp)
 d042068:	1004c03a 	cmpne	r2,r2,zero
 d04206c:	1000031e 	bne	r2,zero,d04207c <ip_raw_alloc+0x44>
      len += IPHSIZ;
 d042070:	e0bffd17 	ldw	r2,-12(fp)
 d042074:	10800504 	addi	r2,r2,20
 d042078:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d04207c:	01000084 	movi	r4,2
 d042080:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 d042084:	00834174 	movhi	r2,3333
 d042088:	108aa204 	addi	r2,r2,10888
 d04208c:	10c00017 	ldw	r3,0(r2)
 d042090:	e0bffd17 	ldw	r2,-12(fp)
 d042094:	1885883a 	add	r2,r3,r2
 d042098:	1009883a 	mov	r4,r2
 d04209c:	d0287a40 	call	d0287a4 <pk_alloc>
 d0420a0:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0420a4:	01000084 	movi	r4,2
 d0420a8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   if (p)
 d0420ac:	e0bffc17 	ldw	r2,-16(fp)
 d0420b0:	1005003a 	cmpeq	r2,r2,zero
 d0420b4:	10000d1e 	bne	r2,zero,d0420ec <ip_raw_alloc+0xb4>
   {
      if (!hdrincl)
 d0420b8:	e0bfff17 	ldw	r2,-4(fp)
 d0420bc:	1004c03a 	cmpne	r2,r2,zero
 d0420c0:	10000a1e 	bne	r2,zero,d0420ec <ip_raw_alloc+0xb4>
      {
         p->nb_prot += IPHSIZ;
 d0420c4:	e0bffc17 	ldw	r2,-16(fp)
 d0420c8:	10800317 	ldw	r2,12(r2)
 d0420cc:	10c00504 	addi	r3,r2,20
 d0420d0:	e0bffc17 	ldw	r2,-16(fp)
 d0420d4:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 d0420d8:	e0bffc17 	ldw	r2,-16(fp)
 d0420dc:	10800417 	ldw	r2,16(r2)
 d0420e0:	10fffb04 	addi	r3,r2,-20
 d0420e4:	e0bffc17 	ldw	r2,-16(fp)
 d0420e8:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 d0420ec:	e0bffc17 	ldw	r2,-16(fp)
}
 d0420f0:	e037883a 	mov	sp,fp
 d0420f4:	dfc00117 	ldw	ra,4(sp)
 d0420f8:	df000017 	ldw	fp,0(sp)
 d0420fc:	dec00204 	addi	sp,sp,8
 d042100:	f800283a 	ret

0d042104 <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 d042104:	defffd04 	addi	sp,sp,-12
 d042108:	dfc00215 	stw	ra,8(sp)
 d04210c:	df000115 	stw	fp,4(sp)
 d042110:	df000104 	addi	fp,sp,4
 d042114:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d042118:	01000084 	movi	r4,2
 d04211c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free(p);
 d042120:	e13fff17 	ldw	r4,-4(fp)
 d042124:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d042128:	01000084 	movi	r4,2
 d04212c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
}
 d042130:	e037883a 	mov	sp,fp
 d042134:	dfc00117 	ldw	ra,4(sp)
 d042138:	df000017 	ldw	fp,0(sp)
 d04213c:	dec00204 	addi	sp,sp,8
 d042140:	f800283a 	ret

0d042144 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 d042144:	defffd04 	addi	sp,sp,-12
 d042148:	df000215 	stw	fp,8(sp)
 d04214c:	df000204 	addi	fp,sp,8
 d042150:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 d042154:	00834174 	movhi	r2,3333
 d042158:	108a5a04 	addi	r2,r2,10600
 d04215c:	10c00017 	ldw	r3,0(r2)
 d042160:	00834174 	movhi	r2,3333
 d042164:	108aa204 	addi	r2,r2,10888
 d042168:	10800017 	ldw	r2,0(r2)
 d04216c:	1885c83a 	sub	r2,r3,r2
 d042170:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 d042174:	e0bfff17 	ldw	r2,-4(fp)
 d042178:	1004c03a 	cmpne	r2,r2,zero
 d04217c:	1000031e 	bne	r2,zero,d04218c <ip_raw_maxalloc+0x48>
      len -= IPHSIZ;
 d042180:	e0bffe17 	ldw	r2,-8(fp)
 d042184:	10bffb04 	addi	r2,r2,-20
 d042188:	e0bffe15 	stw	r2,-8(fp)
   return len;
 d04218c:	e0bffe17 	ldw	r2,-8(fp)
}
 d042190:	e037883a 	mov	sp,fp
 d042194:	df000017 	ldw	fp,0(sp)
 d042198:	dec00104 	addi	sp,sp,4
 d04219c:	f800283a 	ret

0d0421a0 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 d0421a0:	defff804 	addi	sp,sp,-32
 d0421a4:	df000715 	stw	fp,28(sp)
 d0421a8:	df000704 	addi	fp,sp,28
 d0421ac:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 d0421b0:	e03ffc45 	stb	zero,-15(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 d0421b4:	e03ffd15 	stw	zero,-12(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d0421b8:	00834174 	movhi	r2,3333
 d0421bc:	108ae704 	addi	r2,r2,11164
 d0421c0:	10800017 	ldw	r2,0(r2)
 d0421c4:	e0bffe15 	stw	r2,-8(fp)
 d0421c8:	00003e06 	br	d0422c4 <rt_lookup+0x124>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 d0421cc:	e0bffe17 	ldw	r2,-8(fp)
 d0421d0:	10800617 	ldw	r2,24(r2)
 d0421d4:	1005003a 	cmpeq	r2,r2,zero
 d0421d8:	1000371e 	bne	r2,zero,d0422b8 <rt_lookup+0x118>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 d0421dc:	e0bffe17 	ldw	r2,-8(fp)
 d0421e0:	10800a17 	ldw	r2,40(r2)
 d0421e4:	e0bffb15 	stw	r2,-20(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 d0421e8:	e0bffe17 	ldw	r2,-8(fp)
 d0421ec:	10c00017 	ldw	r3,0(r2)
 d0421f0:	e0bffb17 	ldw	r2,-20(fp)
 d0421f4:	1888703a 	and	r4,r3,r2
 d0421f8:	e0ffff17 	ldw	r3,-4(fp)
 d0421fc:	e0bffb17 	ldw	r2,-20(fp)
 d042200:	1884703a 	and	r2,r3,r2
 d042204:	20802c1e 	bne	r4,r2,d0422b8 <rt_lookup+0x118>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 d042208:	e03ffc05 	stb	zero,-16(fp)
 d04220c:	00a00034 	movhi	r2,32768
 d042210:	e0bffa15 	stw	r2,-24(fp)
 d042214:	00001b06 	br	d042284 <rt_lookup+0xe4>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 d042218:	e0bffb17 	ldw	r2,-20(fp)
 d04221c:	1004d63a 	srli	r2,r2,24
 d042220:	10c03fcc 	andi	r3,r2,255
 d042224:	e0bffb17 	ldw	r2,-20(fp)
 d042228:	1004d23a 	srli	r2,r2,8
 d04222c:	10bfc00c 	andi	r2,r2,65280
 d042230:	1886b03a 	or	r3,r3,r2
 d042234:	e0bffb17 	ldw	r2,-20(fp)
 d042238:	10bfc00c 	andi	r2,r2,65280
 d04223c:	1004923a 	slli	r2,r2,8
 d042240:	1886b03a 	or	r3,r3,r2
 d042244:	e0bffb17 	ldw	r2,-20(fp)
 d042248:	10803fcc 	andi	r2,r2,255
 d04224c:	1004963a 	slli	r2,r2,24
 d042250:	1886b03a 	or	r3,r3,r2
 d042254:	e0bffa17 	ldw	r2,-24(fp)
 d042258:	1884703a 	and	r2,r3,r2
 d04225c:	e0bff915 	stw	r2,-28(fp)
            if (extracted_bit) ++curr_bits_matched;
 d042260:	e0bff917 	ldw	r2,-28(fp)
 d042264:	1005003a 	cmpeq	r2,r2,zero
 d042268:	1000031e 	bne	r2,zero,d042278 <rt_lookup+0xd8>
 d04226c:	e0bffc03 	ldbu	r2,-16(fp)
 d042270:	10800044 	addi	r2,r2,1
 d042274:	e0bffc05 	stb	r2,-16(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 d042278:	e0bffa17 	ldw	r2,-24(fp)
 d04227c:	1004d07a 	srli	r2,r2,1
 d042280:	e0bffa15 	stw	r2,-24(fp)
 d042284:	e0bffa17 	ldw	r2,-24(fp)
 d042288:	1004c03a 	cmpne	r2,r2,zero
 d04228c:	103fe21e 	bne	r2,zero,d042218 <rt_lookup+0x78>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 d042290:	e0fffc03 	ldbu	r3,-16(fp)
 d042294:	e0bffc43 	ldbu	r2,-15(fp)
 d042298:	10c0072e 	bgeu	r2,r3,d0422b8 <rt_lookup+0x118>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 d04229c:	e0bffc03 	ldbu	r2,-16(fp)
 d0422a0:	e0bffc45 	stb	r2,-15(fp)
            netmatch = rtp;
 d0422a4:	e0bffe17 	ldw	r2,-8(fp)
 d0422a8:	e0bffd15 	stw	r2,-12(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 d0422ac:	e0bffc43 	ldbu	r2,-15(fp)
 d0422b0:	10800820 	cmpeqi	r2,r2,32
 d0422b4:	10000e1e 	bne	r2,zero,d0422f0 <rt_lookup+0x150>
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d0422b8:	e0bffe17 	ldw	r2,-8(fp)
 d0422bc:	10800f04 	addi	r2,r2,60
 d0422c0:	e0bffe15 	stw	r2,-8(fp)
 d0422c4:	00834174 	movhi	r2,3333
 d0422c8:	108a7204 	addi	r2,r2,10696
 d0422cc:	10800017 	ldw	r2,0(r2)
 d0422d0:	10800f24 	muli	r2,r2,60
 d0422d4:	1007883a 	mov	r3,r2
 d0422d8:	00834174 	movhi	r2,3333
 d0422dc:	108ae704 	addi	r2,r2,11164
 d0422e0:	10800017 	ldw	r2,0(r2)
 d0422e4:	1887883a 	add	r3,r3,r2
 d0422e8:	e0bffe17 	ldw	r2,-8(fp)
 d0422ec:	10ffb736 	bltu	r2,r3,d0421cc <rt_lookup+0x2c>
               break;
         }
      }
   }

   if (netmatch)
 d0422f0:	e0bffd17 	ldw	r2,-12(fp)
 d0422f4:	1005003a 	cmpeq	r2,r2,zero
 d0422f8:	1000051e 	bne	r2,zero,d042310 <rt_lookup+0x170>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 d0422fc:	00834174 	movhi	r2,3333
 d042300:	108ac904 	addi	r2,r2,11044
 d042304:	10c00017 	ldw	r3,0(r2)
 d042308:	e0bffd17 	ldw	r2,-12(fp)
 d04230c:	10c00915 	stw	r3,36(r2)

   return netmatch;
 d042310:	e0bffd17 	ldw	r2,-12(fp)
}
 d042314:	e037883a 	mov	sp,fp
 d042318:	df000017 	ldw	fp,0(sp)
 d04231c:	dec00104 	addi	sp,sp,4
 d042320:	f800283a 	ret

0d042324 <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 d042324:	defff604 	addi	sp,sp,-40
 d042328:	dfc00915 	stw	ra,36(sp)
 d04232c:	df000815 	stw	fp,32(sp)
 d042330:	df000804 	addi	fp,sp,32
 d042334:	e13ffb15 	stw	r4,-20(fp)
 d042338:	e17ffc15 	stw	r5,-16(fp)
 d04233c:	e1bffd15 	stw	r6,-12(fp)
 d042340:	e1fffe15 	stw	r7,-8(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 d042344:	e03ff915 	stw	zero,-28(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 d042348:	e13ffe17 	ldw	r4,-8(fp)
 d04234c:	d03c76c0 	call	d03c76c <if_getbynum>
 d042350:	e0bff815 	stw	r2,-32(fp)
   if(!ifp)
 d042354:	e0bff817 	ldw	r2,-32(fp)
 d042358:	1004c03a 	cmpne	r2,r2,zero
 d04235c:	1000021e 	bne	r2,zero,d042368 <add_route+0x44>
      return NULL;
 d042360:	e03fff15 	stw	zero,-4(fp)
 d042364:	0000f306 	br	d042734 <add_route+0x410>

   if (rt_mib == NULL)
 d042368:	00834174 	movhi	r2,3333
 d04236c:	108ae704 	addi	r2,r2,11164
 d042370:	10800017 	ldw	r2,0(r2)
 d042374:	1004c03a 	cmpne	r2,r2,zero
 d042378:	1000021e 	bne	r2,zero,d042384 <add_route+0x60>
      return NULL;
 d04237c:	e03fff15 	stw	zero,-4(fp)
 d042380:	0000ec06 	br	d042734 <add_route+0x410>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 d042384:	e0bffb17 	ldw	r2,-20(fp)
 d042388:	1005003a 	cmpeq	r2,r2,zero
 d04238c:	1000031e 	bne	r2,zero,d04239c <add_route+0x78>
 d042390:	e0bffc17 	ldw	r2,-16(fp)
 d042394:	1004c03a 	cmpne	r2,r2,zero
 d042398:	1000241e 	bne	r2,zero,d04242c <add_route+0x108>
   {
      dtrap();    /* bad configuration? */
 d04239c:	d0293e80 	call	d0293e8 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 d0423a0:	e0bffb17 	ldw	r2,-20(fp)
 d0423a4:	1004d63a 	srli	r2,r2,24
 d0423a8:	10c03fcc 	andi	r3,r2,255
 d0423ac:	e0bffb17 	ldw	r2,-20(fp)
 d0423b0:	1004d23a 	srli	r2,r2,8
 d0423b4:	10bfc00c 	andi	r2,r2,65280
 d0423b8:	1886b03a 	or	r3,r3,r2
 d0423bc:	e0bffb17 	ldw	r2,-20(fp)
 d0423c0:	10bfc00c 	andi	r2,r2,65280
 d0423c4:	1004923a 	slli	r2,r2,8
 d0423c8:	1886b03a 	or	r3,r3,r2
 d0423cc:	e0bffb17 	ldw	r2,-20(fp)
 d0423d0:	10803fcc 	andi	r2,r2,255
 d0423d4:	1004963a 	slli	r2,r2,24
 d0423d8:	188ab03a 	or	r5,r3,r2
 d0423dc:	e0bffc17 	ldw	r2,-16(fp)
 d0423e0:	1004d63a 	srli	r2,r2,24
 d0423e4:	10c03fcc 	andi	r3,r2,255
 d0423e8:	e0bffc17 	ldw	r2,-16(fp)
 d0423ec:	1004d23a 	srli	r2,r2,8
 d0423f0:	10bfc00c 	andi	r2,r2,65280
 d0423f4:	1886b03a 	or	r3,r3,r2
 d0423f8:	e0bffc17 	ldw	r2,-16(fp)
 d0423fc:	10bfc00c 	andi	r2,r2,65280
 d042400:	1004923a 	slli	r2,r2,8
 d042404:	1886b03a 	or	r3,r3,r2
 d042408:	e0bffc17 	ldw	r2,-16(fp)
 d04240c:	10803fcc 	andi	r2,r2,255
 d042410:	1004963a 	slli	r2,r2,24
 d042414:	188cb03a 	or	r6,r3,r2
 d042418:	01034174 	movhi	r4,3333
 d04241c:	213ff804 	addi	r4,r4,-32
 d042420:	d0029980 	call	d002998 <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 d042424:	e03fff15 	stw	zero,-4(fp)
 d042428:	0000c206 	br	d042734 <add_route+0x410>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d04242c:	00834174 	movhi	r2,3333
 d042430:	108ae704 	addi	r2,r2,11164
 d042434:	10800017 	ldw	r2,0(r2)
 d042438:	e0bffa15 	stw	r2,-24(fp)
 d04243c:	00006f06 	br	d0425fc <add_route+0x2d8>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 d042440:	e0bffa17 	ldw	r2,-24(fp)
 d042444:	10c00017 	ldw	r3,0(r2)
 d042448:	e0bffb17 	ldw	r2,-20(fp)
 d04244c:	1880181e 	bne	r3,r2,d0424b0 <add_route+0x18c>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 d042450:	e0fffa17 	ldw	r3,-24(fp)
 d042454:	e0bffd17 	ldw	r2,-12(fp)
 d042458:	18800615 	stw	r2,24(r3)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 d04245c:	00834174 	movhi	r2,3333
 d042460:	108ac904 	addi	r2,r2,11044
 d042464:	10c00017 	ldw	r3,0(r2)
 d042468:	e0bffa17 	ldw	r2,-24(fp)
 d04246c:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 d042470:	e0bffe17 	ldw	r2,-8(fp)
 d042474:	10c00044 	addi	r3,r2,1
 d042478:	e0bffa17 	ldw	r2,-24(fp)
 d04247c:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 d042480:	e0fffa17 	ldw	r3,-24(fp)
 d042484:	e0800217 	ldw	r2,8(fp)
 d042488:	18800815 	stw	r2,32(r3)
         rtp->ipRouteMask = mask;
 d04248c:	e0fffa17 	ldw	r3,-24(fp)
 d042490:	e0bffc17 	ldw	r2,-16(fp)
 d042494:	18800a15 	stw	r2,40(r3)
         rtp->ifp = ifp;
 d042498:	e0fffa17 	ldw	r3,-24(fp)
 d04249c:	e0bff817 	ldw	r2,-32(fp)
 d0424a0:	18800e15 	stw	r2,56(r3)
         return(rtp);   /* just update and exit */
 d0424a4:	e0bffa17 	ldw	r2,-24(fp)
 d0424a8:	e0bfff15 	stw	r2,-4(fp)
 d0424ac:	0000a106 	br	d042734 <add_route+0x410>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 d0424b0:	e0bff917 	ldw	r2,-28(fp)
 d0424b4:	1005003a 	cmpeq	r2,r2,zero
 d0424b8:	1000041e 	bne	r2,zero,d0424cc <add_route+0x1a8>
 d0424bc:	e0bff917 	ldw	r2,-28(fp)
 d0424c0:	10800817 	ldw	r2,32(r2)
 d0424c4:	1005003a 	cmpeq	r2,r2,zero
 d0424c8:	1000491e 	bne	r2,zero,d0425f0 <add_route+0x2cc>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 d0424cc:	e0bffa17 	ldw	r2,-24(fp)
 d0424d0:	10800617 	ldw	r2,24(r2)
 d0424d4:	1004c03a 	cmpne	r2,r2,zero
 d0424d8:	1000051e 	bne	r2,zero,d0424f0 <add_route+0x1cc>
         {
            newrt = rtp;   /* record empty route for use */
 d0424dc:	e0bffa17 	ldw	r2,-24(fp)
 d0424e0:	e0bff915 	stw	r2,-28(fp)
            newrt->ipRouteProto = 0;
 d0424e4:	e0bff917 	ldw	r2,-28(fp)
 d0424e8:	10000815 	stw	zero,32(r2)
            continue;
 d0424ec:	00004006 	br	d0425f0 <add_route+0x2cc>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 d0424f0:	e0c00217 	ldw	r3,8(fp)
 d0424f4:	00834174 	movhi	r2,3333
 d0424f8:	1089c304 	addi	r2,r2,9996
 d0424fc:	10c5883a 	add	r2,r2,r3
 d042500:	11000003 	ldbu	r4,0(r2)
 d042504:	e0bffa17 	ldw	r2,-24(fp)
 d042508:	10c00817 	ldw	r3,32(r2)
 d04250c:	00834174 	movhi	r2,3333
 d042510:	1089c304 	addi	r2,r2,9996
 d042514:	10c5883a 	add	r2,r2,r3
 d042518:	10800003 	ldbu	r2,0(r2)
 d04251c:	20c03fcc 	andi	r3,r4,255
 d042520:	10803fcc 	andi	r2,r2,255
 d042524:	18803236 	bltu	r3,r2,d0425f0 <add_route+0x2cc>
         {
            if (!newrt)
 d042528:	e0bff917 	ldw	r2,-28(fp)
 d04252c:	1004c03a 	cmpne	r2,r2,zero
 d042530:	1000031e 	bne	r2,zero,d042540 <add_route+0x21c>
            {
               newrt = rtp;
 d042534:	e0bffa17 	ldw	r2,-24(fp)
 d042538:	e0bff915 	stw	r2,-28(fp)
               continue;
 d04253c:	00002c06 	br	d0425f0 <add_route+0x2cc>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 d042540:	e0bffa17 	ldw	r2,-24(fp)
 d042544:	10c00817 	ldw	r3,32(r2)
 d042548:	00834174 	movhi	r2,3333
 d04254c:	1089c304 	addi	r2,r2,9996
 d042550:	10c5883a 	add	r2,r2,r3
 d042554:	11000003 	ldbu	r4,0(r2)
 d042558:	e0bff917 	ldw	r2,-28(fp)
 d04255c:	10c00817 	ldw	r3,32(r2)
 d042560:	00834174 	movhi	r2,3333
 d042564:	1089c304 	addi	r2,r2,9996
 d042568:	10c5883a 	add	r2,r2,r3
 d04256c:	10800003 	ldbu	r2,0(r2)
 d042570:	20c03fcc 	andi	r3,r4,255
 d042574:	10803fcc 	andi	r2,r2,255
 d042578:	1880032e 	bgeu	r3,r2,d042588 <add_route+0x264>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 d04257c:	e0bffa17 	ldw	r2,-24(fp)
 d042580:	e0bff915 	stw	r2,-28(fp)
 d042584:	00001a06 	br	d0425f0 <add_route+0x2cc>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 d042588:	e0bffa17 	ldw	r2,-24(fp)
 d04258c:	10c00817 	ldw	r3,32(r2)
 d042590:	00834174 	movhi	r2,3333
 d042594:	1089c304 	addi	r2,r2,9996
 d042598:	10c5883a 	add	r2,r2,r3
 d04259c:	11000003 	ldbu	r4,0(r2)
 d0425a0:	e0bff917 	ldw	r2,-28(fp)
 d0425a4:	10c00817 	ldw	r3,32(r2)
 d0425a8:	00834174 	movhi	r2,3333
 d0425ac:	1089c304 	addi	r2,r2,9996
 d0425b0:	10c5883a 	add	r2,r2,r3
 d0425b4:	10800003 	ldbu	r2,0(r2)
 d0425b8:	20c03fcc 	andi	r3,r4,255
 d0425bc:	10803fcc 	andi	r2,r2,255
 d0425c0:	18800b1e 	bne	r3,r2,d0425f0 <add_route+0x2cc>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 d0425c4:	e0bffa17 	ldw	r2,-24(fp)
 d0425c8:	11000917 	ldw	r4,36(r2)
 d0425cc:	e0bff917 	ldw	r2,-28(fp)
 d0425d0:	11400917 	ldw	r5,36(r2)
 d0425d4:	d021f040 	call	d021f04 <c_older>
 d0425d8:	1007883a 	mov	r3,r2
 d0425dc:	e0bffa17 	ldw	r2,-24(fp)
 d0425e0:	10800917 	ldw	r2,36(r2)
 d0425e4:	1880021e 	bne	r3,r2,d0425f0 <add_route+0x2cc>
                  newrt = rtp;   /* got an older one */
 d0425e8:	e0bffa17 	ldw	r2,-24(fp)
 d0425ec:	e0bff915 	stw	r2,-28(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d0425f0:	e0bffa17 	ldw	r2,-24(fp)
 d0425f4:	10800f04 	addi	r2,r2,60
 d0425f8:	e0bffa15 	stw	r2,-24(fp)
 d0425fc:	00834174 	movhi	r2,3333
 d042600:	108a7204 	addi	r2,r2,10696
 d042604:	10800017 	ldw	r2,0(r2)
 d042608:	10800f24 	muli	r2,r2,60
 d04260c:	1007883a 	mov	r3,r2
 d042610:	00834174 	movhi	r2,3333
 d042614:	108ae704 	addi	r2,r2,11164
 d042618:	10800017 	ldw	r2,0(r2)
 d04261c:	1887883a 	add	r3,r3,r2
 d042620:	e0bffa17 	ldw	r2,-24(fp)
 d042624:	10ff8636 	bltu	r2,r3,d042440 <add_route+0x11c>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 d042628:	e0bff917 	ldw	r2,-28(fp)
 d04262c:	1005003a 	cmpeq	r2,r2,zero
 d042630:	10002a1e 	bne	r2,zero,d0426dc <add_route+0x3b8>
      rtp = newrt;   /* create new entry in lowest priority slot */
 d042634:	e0bff917 	ldw	r2,-28(fp)
 d042638:	e0bffa15 	stw	r2,-24(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 d04263c:	e0fffa17 	ldw	r3,-24(fp)
 d042640:	e0bff817 	ldw	r2,-32(fp)
 d042644:	18800e15 	stw	r2,56(r3)
   rtp->ipRouteDest = dest;
 d042648:	e0fffa17 	ldw	r3,-24(fp)
 d04264c:	e0bffb17 	ldw	r2,-20(fp)
 d042650:	18800015 	stw	r2,0(r3)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 d042654:	e13ff817 	ldw	r4,-32(fp)
 d042658:	d0225980 	call	d022598 <if_netnumber>
 d04265c:	10c00044 	addi	r3,r2,1
 d042660:	e0bffa17 	ldw	r2,-24(fp)
 d042664:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 d042668:	008341b4 	movhi	r2,3334
 d04266c:	10b4eb04 	addi	r2,r2,-11348
 d042670:	10800117 	ldw	r2,4(r2)
 d042674:	1007883a 	mov	r3,r2
 d042678:	e0bffa17 	ldw	r2,-24(fp)
 d04267c:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 d042680:	e0fffa17 	ldw	r3,-24(fp)
 d042684:	00bfffc4 	movi	r2,-1
 d042688:	18800315 	stw	r2,12(r3)
   rtp->ipRouteMetric3 = -1;
 d04268c:	e0fffa17 	ldw	r3,-24(fp)
 d042690:	00bfffc4 	movi	r2,-1
 d042694:	18800415 	stw	r2,16(r3)
   rtp->ipRouteMetric4 = -1;
 d042698:	e0fffa17 	ldw	r3,-24(fp)
 d04269c:	00bfffc4 	movi	r2,-1
 d0426a0:	18800515 	stw	r2,20(r3)
   rtp->ipRouteNextHop = nexthop;
 d0426a4:	e0fffa17 	ldw	r3,-24(fp)
 d0426a8:	e0bffd17 	ldw	r2,-12(fp)
 d0426ac:	18800615 	stw	r2,24(r3)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 d0426b0:	e0fffa17 	ldw	r3,-24(fp)
 d0426b4:	e0800217 	ldw	r2,8(fp)
 d0426b8:	18800815 	stw	r2,32(r3)

   if ((dest & mask) == (nexthop & mask))
 d0426bc:	e0fffb17 	ldw	r3,-20(fp)
 d0426c0:	e0bffc17 	ldw	r2,-16(fp)
 d0426c4:	1888703a 	and	r4,r3,r2
 d0426c8:	e0fffd17 	ldw	r3,-12(fp)
 d0426cc:	e0bffc17 	ldw	r2,-16(fp)
 d0426d0:	1884703a 	and	r2,r3,r2
 d0426d4:	20800326 	beq	r4,r2,d0426e4 <add_route+0x3c0>
 d0426d8:	00000606 	br	d0426f4 <add_route+0x3d0>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 d0426dc:	e03fff15 	stw	zero,-4(fp)
 d0426e0:	00001406 	br	d042734 <add_route+0x410>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 d0426e4:	e0fffa17 	ldw	r3,-24(fp)
 d0426e8:	008000c4 	movi	r2,3
 d0426ec:	18800715 	stw	r2,28(r3)
 d0426f0:	00000306 	br	d042700 <add_route+0x3dc>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 d0426f4:	e0fffa17 	ldw	r3,-24(fp)
 d0426f8:	00800104 	movi	r2,4
 d0426fc:	18800715 	stw	r2,28(r3)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 d042700:	00834174 	movhi	r2,3333
 d042704:	108ac904 	addi	r2,r2,11044
 d042708:	10c00017 	ldw	r3,0(r2)
 d04270c:	e0bffa17 	ldw	r2,-24(fp)
 d042710:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 d042714:	e0fffa17 	ldw	r3,-24(fp)
 d042718:	e0bffc17 	ldw	r2,-16(fp)
 d04271c:	18800a15 	stw	r2,40(r3)
   rtp->ipRouteMetric5 = -1;
 d042720:	e0fffa17 	ldw	r3,-24(fp)
 d042724:	00bfffc4 	movi	r2,-1
 d042728:	18800b15 	stw	r2,44(r3)
   return(rtp);
 d04272c:	e0bffa17 	ldw	r2,-24(fp)
 d042730:	e0bfff15 	stw	r2,-4(fp)
 d042734:	e0bfff17 	ldw	r2,-4(fp)
}
 d042738:	e037883a 	mov	sp,fp
 d04273c:	dfc00117 	ldw	ra,4(sp)
 d042740:	df000017 	ldw	fp,0(sp)
 d042744:	dec00204 	addi	sp,sp,8
 d042748:	f800283a 	ret

0d04274c <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 d04274c:	defff704 	addi	sp,sp,-36
 d042750:	dfc00815 	stw	ra,32(sp)
 d042754:	df000715 	stw	fp,28(sp)
 d042758:	df000704 	addi	fp,sp,28
 d04275c:	e13ffc15 	stw	r4,-16(fp)
 d042760:	e17ffd15 	stw	r5,-12(fp)
 d042764:	e1bffe15 	stw	r6,-8(fp)
   RTMIB rtp;
   int   retval   =  0;
 d042768:	e03ffa15 	stw	zero,-24(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 d04276c:	e0bffe17 	ldw	r2,-8(fp)
 d042770:	10bfffd8 	cmpnei	r2,r2,-1
 d042774:	1000021e 	bne	r2,zero,d042780 <del_route+0x34>
      ifp = NULL;    /* wildcard */
 d042778:	e03ff915 	stw	zero,-28(fp)
 d04277c:	00000306 	br	d04278c <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 d042780:	e13ffe17 	ldw	r4,-8(fp)
 d042784:	d03c76c0 	call	d03c76c <if_getbynum>
 d042788:	e0bff915 	stw	r2,-28(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 d04278c:	00834174 	movhi	r2,3333
 d042790:	108ae704 	addi	r2,r2,11164
 d042794:	10800017 	ldw	r2,0(r2)
 d042798:	1004c03a 	cmpne	r2,r2,zero
 d04279c:	1000021e 	bne	r2,zero,d0427a8 <del_route+0x5c>
      return 0;
 d0427a0:	e03fff15 	stw	zero,-4(fp)
 d0427a4:	00003406 	br	d042878 <del_route+0x12c>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d0427a8:	00834174 	movhi	r2,3333
 d0427ac:	108ae704 	addi	r2,r2,11164
 d0427b0:	10800017 	ldw	r2,0(r2)
 d0427b4:	e0bffb15 	stw	r2,-20(fp)
 d0427b8:	00002206 	br	d042844 <del_route+0xf8>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 d0427bc:	e0bffb17 	ldw	r2,-20(fp)
 d0427c0:	10800617 	ldw	r2,24(r2)
 d0427c4:	1005003a 	cmpeq	r2,r2,zero
 d0427c8:	10001b1e 	bne	r2,zero,d042838 <del_route+0xec>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 d0427cc:	e0bff917 	ldw	r2,-28(fp)
 d0427d0:	1005003a 	cmpeq	r2,r2,zero
 d0427d4:	1000041e 	bne	r2,zero,d0427e8 <del_route+0x9c>
 d0427d8:	e0bffb17 	ldw	r2,-20(fp)
 d0427dc:	10c00e17 	ldw	r3,56(r2)
 d0427e0:	e0bff917 	ldw	r2,-28(fp)
 d0427e4:	1880141e 	bne	r3,r2,d042838 <del_route+0xec>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 d0427e8:	e0bffb17 	ldw	r2,-20(fp)
 d0427ec:	10c00017 	ldw	r3,0(r2)
 d0427f0:	e0bffd17 	ldw	r2,-12(fp)
 d0427f4:	1888703a 	and	r4,r3,r2
 d0427f8:	e0fffc17 	ldw	r3,-16(fp)
 d0427fc:	e0bffd17 	ldw	r2,-12(fp)
 d042800:	1884703a 	and	r2,r3,r2
 d042804:	2080081e 	bne	r4,r2,d042828 <del_route+0xdc>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 d042808:	e0bffb17 	ldw	r2,-20(fp)
 d04280c:	1009883a 	mov	r4,r2
 d042810:	01800f04 	movi	r6,60
 d042814:	000b883a 	mov	r5,zero
 d042818:	d0028800 	call	d002880 <memset>
         retval++;
 d04281c:	e0bffa17 	ldw	r2,-24(fp)
 d042820:	10800044 	addi	r2,r2,1
 d042824:	e0bffa15 	stw	r2,-24(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 d042828:	d0e0d017 	ldw	r3,-31936(gp)
 d04282c:	e0bffb17 	ldw	r2,-20(fp)
 d042830:	1880011e 	bne	r3,r2,d042838 <del_route+0xec>
         cachedRoute = NULL;
 d042834:	d020d015 	stw	zero,-31936(gp)
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 d042838:	e0bffb17 	ldw	r2,-20(fp)
 d04283c:	10800f04 	addi	r2,r2,60
 d042840:	e0bffb15 	stw	r2,-20(fp)
 d042844:	00834174 	movhi	r2,3333
 d042848:	108a7204 	addi	r2,r2,10696
 d04284c:	10800017 	ldw	r2,0(r2)
 d042850:	10800f24 	muli	r2,r2,60
 d042854:	1007883a 	mov	r3,r2
 d042858:	00834174 	movhi	r2,3333
 d04285c:	108ae704 	addi	r2,r2,11164
 d042860:	10800017 	ldw	r2,0(r2)
 d042864:	1887883a 	add	r3,r3,r2
 d042868:	e0bffb17 	ldw	r2,-20(fp)
 d04286c:	10ffd336 	bltu	r2,r3,d0427bc <del_route+0x70>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 d042870:	e0bffa17 	ldw	r2,-24(fp)
 d042874:	e0bfff15 	stw	r2,-4(fp)
 d042878:	e0bfff17 	ldw	r2,-4(fp)
}
 d04287c:	e037883a 	mov	sp,fp
 d042880:	dfc00117 	ldw	ra,4(sp)
 d042884:	df000017 	ldw	fp,0(sp)
 d042888:	dec00204 	addi	sp,sp,8
 d04288c:	f800283a 	ret

0d042890 <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 d042890:	deffec04 	addi	sp,sp,-80
 d042894:	dfc01315 	stw	ra,76(sp)
 d042898:	df001215 	stw	fp,72(sp)
 d04289c:	df001204 	addi	fp,sp,72
 d0428a0:	e13ffe15 	stw	r4,-8(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 d0428a4:	e0bffe17 	ldw	r2,-8(fp)
 d0428a8:	10800317 	ldw	r2,12(r2)
 d0428ac:	e0bffa15 	stw	r2,-24(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 d0428b0:	e0bffa17 	ldw	r2,-24(fp)
 d0428b4:	10800003 	ldbu	r2,0(r2)
 d0428b8:	10803fcc 	andi	r2,r2,255
 d0428bc:	108003cc 	andi	r2,r2,15
 d0428c0:	1085883a 	add	r2,r2,r2
 d0428c4:	1085883a 	add	r2,r2,r2
 d0428c8:	1007883a 	mov	r3,r2
 d0428cc:	e0bffa17 	ldw	r2,-24(fp)
 d0428d0:	1885883a 	add	r2,r3,r2
 d0428d4:	e0bff915 	stw	r2,-28(fp)
   plen = htons(pup->ud_len);
 d0428d8:	e0bff917 	ldw	r2,-28(fp)
 d0428dc:	1080010b 	ldhu	r2,4(r2)
 d0428e0:	10bfffcc 	andi	r2,r2,65535
 d0428e4:	1004d23a 	srli	r2,r2,8
 d0428e8:	10bfffcc 	andi	r2,r2,65535
 d0428ec:	10c03fcc 	andi	r3,r2,255
 d0428f0:	e0bff917 	ldw	r2,-28(fp)
 d0428f4:	1080010b 	ldhu	r2,4(r2)
 d0428f8:	10bfffcc 	andi	r2,r2,65535
 d0428fc:	1004923a 	slli	r2,r2,8
 d042900:	10bfc00c 	andi	r2,r2,65280
 d042904:	1884b03a 	or	r2,r3,r2
 d042908:	e0bff615 	stw	r2,-40(fp)

   if (plen > p->nb_plen)
 d04290c:	e0bffe17 	ldw	r2,-8(fp)
 d042910:	10c00417 	ldw	r3,16(r2)
 d042914:	e0bff617 	ldw	r2,-40(fp)
 d042918:	18802a2e 	bgeu	r3,r2,d0429c4 <udpdemux+0x134>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d04291c:	00834174 	movhi	r2,3333
 d042920:	108aa404 	addi	r2,r2,10896
 d042924:	10800017 	ldw	r2,0(r2)
 d042928:	1081000c 	andi	r2,r2,1024
 d04292c:	1005003a 	cmpeq	r2,r2,zero
 d042930:	1000181e 	bne	r2,zero,d042994 <udpdemux+0x104>
 d042934:	00834174 	movhi	r2,3333
 d042938:	108aa404 	addi	r2,r2,10896
 d04293c:	10800017 	ldw	r2,0(r2)
 d042940:	1080400c 	andi	r2,r2,256
 d042944:	1005003a 	cmpeq	r2,r2,zero
 d042948:	1000121e 	bne	r2,zero,d042994 <udpdemux+0x104>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 d04294c:	e0bffe17 	ldw	r2,-8(fp)
 d042950:	11400417 	ldw	r5,16(r2)
 d042954:	e0bff917 	ldw	r2,-28(fp)
 d042958:	1080010b 	ldhu	r2,4(r2)
 d04295c:	10bfffcc 	andi	r2,r2,65535
 d042960:	1004d23a 	srli	r2,r2,8
 d042964:	10bfffcc 	andi	r2,r2,65535
 d042968:	10c03fcc 	andi	r3,r2,255
 d04296c:	e0bff917 	ldw	r2,-28(fp)
 d042970:	1080010b 	ldhu	r2,4(r2)
 d042974:	10bfffcc 	andi	r2,r2,65535
 d042978:	1004923a 	slli	r2,r2,8
 d04297c:	10bfc00c 	andi	r2,r2,65280
 d042980:	1884b03a 	or	r2,r3,r2
 d042984:	11800204 	addi	r6,r2,8
 d042988:	01034174 	movhi	r4,3333
 d04298c:	21000604 	addi	r4,r4,24
 d042990:	d0029980 	call	d002998 <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 d042994:	008341b4 	movhi	r2,3334
 d042998:	10b50504 	addi	r2,r2,-11244
 d04299c:	10800217 	ldw	r2,8(r2)
 d0429a0:	10c00044 	addi	r3,r2,1
 d0429a4:	008341b4 	movhi	r2,3334
 d0429a8:	10b50504 	addi	r2,r2,-11244
 d0429ac:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 d0429b0:	e13ffe17 	ldw	r4,-8(fp)
 d0429b4:	d04368c0 	call	d04368c <udp_free>
      return ENP_BAD_HEADER;
 d0429b8:	00bff804 	movi	r2,-32
 d0429bc:	e0bfff15 	stw	r2,-4(fp)
 d0429c0:	0001c306 	br	d0430d0 <udpdemux+0x840>
   }

   osum = pup->ud_cksum;
 d0429c4:	e0bff917 	ldw	r2,-28(fp)
 d0429c8:	1080018b 	ldhu	r2,6(r2)
 d0429cc:	e0bff78d 	sth	r2,-34(fp)
   /* did other guy use checksumming? */
   if (osum)
 d0429d0:	e0bff78b 	ldhu	r2,-34(fp)
 d0429d4:	1005003a 	cmpeq	r2,r2,zero
 d0429d8:	1000631e 	bne	r2,zero,d042b68 <udpdemux+0x2d8>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 d0429dc:	e0bff617 	ldw	r2,-40(fp)
 d0429e0:	1080004c 	andi	r2,r2,1
 d0429e4:	10803fcc 	andi	r2,r2,255
 d0429e8:	1005003a 	cmpeq	r2,r2,zero
 d0429ec:	1000041e 	bne	r2,zero,d042a00 <udpdemux+0x170>
 d0429f0:	e0bff917 	ldw	r2,-28(fp)
 d0429f4:	e0fff617 	ldw	r3,-40(fp)
 d0429f8:	10c5883a 	add	r2,r2,r3
 d0429fc:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 d042a00:	e0bffe17 	ldw	r2,-8(fp)
 d042a04:	10800717 	ldw	r2,28(r2)
 d042a08:	e0bffb15 	stw	r2,-20(fp)
      php.ph_dest = pip->ip_dest;
 d042a0c:	e0bffa17 	ldw	r2,-24(fp)
 d042a10:	10800417 	ldw	r2,16(r2)
 d042a14:	e0bffc15 	stw	r2,-16(fp)
      php.ph_zero = 0;
 d042a18:	e03ffd05 	stb	zero,-12(fp)
      php.ph_prot = UDP_PROT;
 d042a1c:	00800444 	movi	r2,17
 d042a20:	e0bffd45 	stb	r2,-11(fp)
      php.ph_len  = pup->ud_len;
 d042a24:	e0bff917 	ldw	r2,-28(fp)
 d042a28:	1080010b 	ldhu	r2,4(r2)
 d042a2c:	e0bffd8d 	sth	r2,-10(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 d042a30:	e13ffb04 	addi	r4,fp,-20
 d042a34:	01400184 	movi	r5,6
 d042a38:	d0242340 	call	d024234 <cksum>
 d042a3c:	1007883a 	mov	r3,r2
 d042a40:	e0bff917 	ldw	r2,-28(fp)
 d042a44:	10c0018d 	sth	r3,6(r2)
      xsum = ~cksum(pup, (plen+1)>>1);
 d042a48:	e0bff617 	ldw	r2,-40(fp)
 d042a4c:	10800044 	addi	r2,r2,1
 d042a50:	100ad07a 	srli	r5,r2,1
 d042a54:	e13ff917 	ldw	r4,-28(fp)
 d042a58:	d0242340 	call	d024234 <cksum>
 d042a5c:	0084303a 	nor	r2,zero,r2
 d042a60:	e0bff70d 	sth	r2,-36(fp)
      if (!xsum)
 d042a64:	e0bff70b 	ldhu	r2,-36(fp)
 d042a68:	1004c03a 	cmpne	r2,r2,zero
 d042a6c:	1000021e 	bne	r2,zero,d042a78 <udpdemux+0x1e8>
         xsum = 0xffff;
 d042a70:	00bfffc4 	movi	r2,-1
 d042a74:	e0bff70d 	sth	r2,-36(fp)
      pup->ud_cksum = osum;
 d042a78:	e0fff917 	ldw	r3,-28(fp)
 d042a7c:	e0bff78b 	ldhu	r2,-34(fp)
 d042a80:	1880018d 	sth	r2,6(r3)
      if (xsum != osum)
 d042a84:	e0fff70b 	ldhu	r3,-36(fp)
 d042a88:	e0bff78b 	ldhu	r2,-34(fp)
 d042a8c:	18803626 	beq	r3,r2,d042b68 <udpdemux+0x2d8>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d042a90:	00834174 	movhi	r2,3333
 d042a94:	108aa404 	addi	r2,r2,10896
 d042a98:	10800017 	ldw	r2,0(r2)
 d042a9c:	1081000c 	andi	r2,r2,1024
 d042aa0:	1005003a 	cmpeq	r2,r2,zero
 d042aa4:	1000241e 	bne	r2,zero,d042b38 <udpdemux+0x2a8>
 d042aa8:	00834174 	movhi	r2,3333
 d042aac:	108aa404 	addi	r2,r2,10896
 d042ab0:	10800017 	ldw	r2,0(r2)
 d042ab4:	1080400c 	andi	r2,r2,256
 d042ab8:	1005003a 	cmpeq	r2,r2,zero
 d042abc:	10001e1e 	bne	r2,zero,d042b38 <udpdemux+0x2a8>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 d042ac0:	e17ff78b 	ldhu	r5,-34(fp)
 d042ac4:	e1bff70b 	ldhu	r6,-36(fp)
 d042ac8:	e0bffe17 	ldw	r2,-8(fp)
 d042acc:	10800717 	ldw	r2,28(r2)
 d042ad0:	11c03fcc 	andi	r7,r2,255
 d042ad4:	e0bffe17 	ldw	r2,-8(fp)
 d042ad8:	10800717 	ldw	r2,28(r2)
 d042adc:	1004d23a 	srli	r2,r2,8
 d042ae0:	11003fcc 	andi	r4,r2,255
 d042ae4:	e0bffe17 	ldw	r2,-8(fp)
 d042ae8:	10800717 	ldw	r2,28(r2)
 d042aec:	1004d43a 	srli	r2,r2,16
 d042af0:	10c03fcc 	andi	r3,r2,255
 d042af4:	e0bffe17 	ldw	r2,-8(fp)
 d042af8:	10800717 	ldw	r2,28(r2)
 d042afc:	1004d63a 	srli	r2,r2,24
 d042b00:	d9000015 	stw	r4,0(sp)
 d042b04:	d8c00115 	stw	r3,4(sp)
 d042b08:	d8800215 	stw	r2,8(sp)
 d042b0c:	01034174 	movhi	r4,3333
 d042b10:	21001004 	addi	r4,r4,64
 d042b14:	d0029980 	call	d002998 <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 d042b18:	00834174 	movhi	r2,3333
 d042b1c:	108aa404 	addi	r2,r2,10896
 d042b20:	10800017 	ldw	r2,0(r2)
 d042b24:	1080008c 	andi	r2,r2,2
 d042b28:	1005003a 	cmpeq	r2,r2,zero
 d042b2c:	1000021e 	bne	r2,zero,d042b38 <udpdemux+0x2a8>
               ip_dump(p);
 d042b30:	e13ffe17 	ldw	r4,-8(fp)
 d042b34:	d03e6540 	call	d03e654 <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 d042b38:	008341b4 	movhi	r2,3334
 d042b3c:	10b50504 	addi	r2,r2,-11244
 d042b40:	10800217 	ldw	r2,8(r2)
 d042b44:	10c00044 	addi	r3,r2,1
 d042b48:	008341b4 	movhi	r2,3334
 d042b4c:	10b50504 	addi	r2,r2,-11244
 d042b50:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 d042b54:	e13ffe17 	ldw	r4,-8(fp)
 d042b58:	d04368c0 	call	d04368c <udp_free>
         return ENP_BAD_HEADER;
 d042b5c:	00bff804 	movi	r2,-32
 d042b60:	e0bfff15 	stw	r2,-4(fp)
 d042b64:	00015a06 	br	d0430d0 <udpdemux+0x840>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 d042b68:	e13ff917 	ldw	r4,-28(fp)
 d042b6c:	d0433a00 	call	d0433a0 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 d042b70:	e0bffa17 	ldw	r2,-24(fp)
 d042b74:	10800003 	ldbu	r2,0(r2)
 d042b78:	10803fcc 	andi	r2,r2,255
 d042b7c:	108003cc 	andi	r2,r2,15
 d042b80:	1085883a 	add	r2,r2,r2
 d042b84:	1085883a 	add	r2,r2,r2
 d042b88:	10800204 	addi	r2,r2,8
 d042b8c:	e0bff515 	stw	r2,-44(fp)
   p->nb_plen -= e;
 d042b90:	e0bffe17 	ldw	r2,-8(fp)
 d042b94:	10c00417 	ldw	r3,16(r2)
 d042b98:	e0bff517 	ldw	r2,-44(fp)
 d042b9c:	1887c83a 	sub	r3,r3,r2
 d042ba0:	e0bffe17 	ldw	r2,-8(fp)
 d042ba4:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 d042ba8:	e0bffe17 	ldw	r2,-8(fp)
 d042bac:	10c00317 	ldw	r3,12(r2)
 d042bb0:	e0bff517 	ldw	r2,-44(fp)
 d042bb4:	1887883a 	add	r3,r3,r2
 d042bb8:	e0bffe17 	ldw	r2,-8(fp)
 d042bbc:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d042bc0:	00834174 	movhi	r2,3333
 d042bc4:	108aa404 	addi	r2,r2,10896
 d042bc8:	10800017 	ldw	r2,0(r2)
 d042bcc:	1081000c 	andi	r2,r2,1024
 d042bd0:	1005003a 	cmpeq	r2,r2,zero
 d042bd4:	1000221e 	bne	r2,zero,d042c60 <udpdemux+0x3d0>
 d042bd8:	00834174 	movhi	r2,3333
 d042bdc:	108aa404 	addi	r2,r2,10896
 d042be0:	10800017 	ldw	r2,0(r2)
 d042be4:	1080400c 	andi	r2,r2,256
 d042be8:	1005003a 	cmpeq	r2,r2,zero
 d042bec:	10001c1e 	bne	r2,zero,d042c60 <udpdemux+0x3d0>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 d042bf0:	e0bffe17 	ldw	r2,-8(fp)
 d042bf4:	10800717 	ldw	r2,28(r2)
 d042bf8:	11803fcc 	andi	r6,r2,255
 d042bfc:	e0bffe17 	ldw	r2,-8(fp)
 d042c00:	10800717 	ldw	r2,28(r2)
 d042c04:	1004d23a 	srli	r2,r2,8
 d042c08:	11c03fcc 	andi	r7,r2,255
 d042c0c:	e0bffe17 	ldw	r2,-8(fp)
 d042c10:	10800717 	ldw	r2,28(r2)
 d042c14:	1004d43a 	srli	r2,r2,16
 d042c18:	10c03fcc 	andi	r3,r2,255
 d042c1c:	e0bffe17 	ldw	r2,-8(fp)
 d042c20:	10800717 	ldw	r2,28(r2)
 d042c24:	1008d63a 	srli	r4,r2,24
 d042c28:	e0bff917 	ldw	r2,-28(fp)
 d042c2c:	1080000b 	ldhu	r2,0(r2)
 d042c30:	117fffcc 	andi	r5,r2,65535
 d042c34:	e0bff917 	ldw	r2,-28(fp)
 d042c38:	1080008b 	ldhu	r2,2(r2)
 d042c3c:	10bfffcc 	andi	r2,r2,65535
 d042c40:	d8c00015 	stw	r3,0(sp)
 d042c44:	d9000115 	stw	r4,4(sp)
 d042c48:	d9400215 	stw	r5,8(sp)
 d042c4c:	d8800315 	stw	r2,12(sp)
 d042c50:	01034174 	movhi	r4,3333
 d042c54:	21001e04 	addi	r4,r4,120
 d042c58:	e17ff617 	ldw	r5,-40(fp)
 d042c5c:	d0029980 	call	d002998 <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 d042c60:	00834174 	movhi	r2,3333
 d042c64:	108abd04 	addi	r2,r2,10996
 d042c68:	10800017 	ldw	r2,0(r2)
 d042c6c:	e0bff815 	stw	r2,-32(fp)
 d042c70:	0000b106 	br	d042f38 <udpdemux+0x6a8>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 d042c74:	e0bff817 	ldw	r2,-32(fp)
 d042c78:	1080018b 	ldhu	r2,6(r2)
 d042c7c:	10bfffcc 	andi	r2,r2,65535
 d042c80:	1005003a 	cmpeq	r2,r2,zero
 d042c84:	1000071e 	bne	r2,zero,d042ca4 <udpdemux+0x414>
 d042c88:	e0bff817 	ldw	r2,-32(fp)
 d042c8c:	10c0018b 	ldhu	r3,6(r2)
 d042c90:	e0bff917 	ldw	r2,-28(fp)
 d042c94:	1080008b 	ldhu	r2,2(r2)
 d042c98:	18ffffcc 	andi	r3,r3,65535
 d042c9c:	10bfffcc 	andi	r2,r2,65535
 d042ca0:	1880a21e 	bne	r3,r2,d042f2c <udpdemux+0x69c>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 d042ca4:	e0bff817 	ldw	r2,-32(fp)
 d042ca8:	1080020b 	ldhu	r2,8(r2)
 d042cac:	10bfffcc 	andi	r2,r2,65535
 d042cb0:	1005003a 	cmpeq	r2,r2,zero
 d042cb4:	1000071e 	bne	r2,zero,d042cd4 <udpdemux+0x444>
 d042cb8:	e0bff817 	ldw	r2,-32(fp)
 d042cbc:	10c0020b 	ldhu	r3,8(r2)
 d042cc0:	e0bff917 	ldw	r2,-28(fp)
 d042cc4:	1080000b 	ldhu	r2,0(r2)
 d042cc8:	18ffffcc 	andi	r3,r3,65535
 d042ccc:	10bfffcc 	andi	r2,r2,65535
 d042cd0:	1880961e 	bne	r3,r2,d042f2c <udpdemux+0x69c>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 d042cd4:	e0bff817 	ldw	r2,-32(fp)
 d042cd8:	10800417 	ldw	r2,16(r2)
 d042cdc:	1005003a 	cmpeq	r2,r2,zero
 d042ce0:	1000051e 	bne	r2,zero,d042cf8 <udpdemux+0x468>
 d042ce4:	e0bff817 	ldw	r2,-32(fp)
 d042ce8:	10c00417 	ldw	r3,16(r2)
 d042cec:	e0bffe17 	ldw	r2,-8(fp)
 d042cf0:	10800717 	ldw	r2,28(r2)
 d042cf4:	18808d1e 	bne	r3,r2,d042f2c <udpdemux+0x69c>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 d042cf8:	e0bffa17 	ldw	r2,-24(fp)
 d042cfc:	10800417 	ldw	r2,16(r2)
 d042d00:	1004d63a 	srli	r2,r2,24
 d042d04:	10c03fcc 	andi	r3,r2,255
 d042d08:	e0bffa17 	ldw	r2,-24(fp)
 d042d0c:	10800417 	ldw	r2,16(r2)
 d042d10:	1004d23a 	srli	r2,r2,8
 d042d14:	10bfc00c 	andi	r2,r2,65280
 d042d18:	1886b03a 	or	r3,r3,r2
 d042d1c:	e0bffa17 	ldw	r2,-24(fp)
 d042d20:	10800417 	ldw	r2,16(r2)
 d042d24:	10bfc00c 	andi	r2,r2,65280
 d042d28:	1004923a 	slli	r2,r2,8
 d042d2c:	1886b03a 	or	r3,r3,r2
 d042d30:	e0bffa17 	ldw	r2,-24(fp)
 d042d34:	10800417 	ldw	r2,16(r2)
 d042d38:	10803fcc 	andi	r2,r2,255
 d042d3c:	1004963a 	slli	r2,r2,24
 d042d40:	1884b03a 	or	r2,r3,r2
 d042d44:	10fc002c 	andhi	r3,r2,61440
 d042d48:	00b80034 	movhi	r2,57344
 d042d4c:	1880301e 	bne	r3,r2,d042e10 <udpdemux+0x580>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 d042d50:	e0bff817 	ldw	r2,-32(fp)
 d042d54:	10800617 	ldw	r2,24(r2)
 d042d58:	e0bff415 	stw	r2,-48(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 d042d5c:	e0bff817 	ldw	r2,-32(fp)
 d042d60:	10c00517 	ldw	r3,20(r2)
 d042d64:	008340f4 	movhi	r2,3331
 d042d68:	109ecb04 	addi	r2,r2,31532
 d042d6c:	1880281e 	bne	r3,r2,d042e10 <udpdemux+0x580>
 d042d70:	e0bff417 	ldw	r2,-48(fp)
 d042d74:	10800317 	ldw	r2,12(r2)
 d042d78:	1005003a 	cmpeq	r2,r2,zero
 d042d7c:	1000241e 	bne	r2,zero,d042e10 <udpdemux+0x580>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 d042d80:	e0bff417 	ldw	r2,-48(fp)
 d042d84:	10800317 	ldw	r2,12(r2)
 d042d88:	e0bff215 	stw	r2,-56(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 d042d8c:	e03ff30d 	sth	zero,-52(fp)
 d042d90:	00001906 	br	d042df8 <udpdemux+0x568>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 d042d94:	e0bff30b 	ldhu	r2,-52(fp)
 d042d98:	e0fff217 	ldw	r3,-56(fp)
 d042d9c:	1085883a 	add	r2,r2,r2
 d042da0:	1085883a 	add	r2,r2,r2
 d042da4:	10c5883a 	add	r2,r2,r3
 d042da8:	10800204 	addi	r2,r2,8
 d042dac:	10800017 	ldw	r2,0(r2)
 d042db0:	10c00117 	ldw	r3,4(r2)
 d042db4:	e0bffe17 	ldw	r2,-8(fp)
 d042db8:	10800617 	ldw	r2,24(r2)
 d042dbc:	18800b1e 	bne	r3,r2,d042dec <udpdemux+0x55c>
 d042dc0:	e0bff30b 	ldhu	r2,-52(fp)
 d042dc4:	e0fff217 	ldw	r3,-56(fp)
 d042dc8:	1085883a 	add	r2,r2,r2
 d042dcc:	1085883a 	add	r2,r2,r2
 d042dd0:	10c5883a 	add	r2,r2,r3
 d042dd4:	10800204 	addi	r2,r2,8
 d042dd8:	10800017 	ldw	r2,0(r2)
 d042ddc:	10c00017 	ldw	r3,0(r2)
 d042de0:	e0bffa17 	ldw	r2,-24(fp)
 d042de4:	10800417 	ldw	r2,16(r2)
 d042de8:	18800926 	beq	r3,r2,d042e10 <udpdemux+0x580>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 d042dec:	e0bff30b 	ldhu	r2,-52(fp)
 d042df0:	10800044 	addi	r2,r2,1
 d042df4:	e0bff30d 	sth	r2,-52(fp)
 d042df8:	e0bff217 	ldw	r2,-56(fp)
 d042dfc:	1080018b 	ldhu	r2,6(r2)
 d042e00:	10ffffcc 	andi	r3,r2,65535
 d042e04:	e0bff30b 	ldhu	r2,-52(fp)
 d042e08:	10ffe236 	bltu	r2,r3,d042d94 <udpdemux+0x504>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 d042e0c:	00004706 	br	d042f2c <udpdemux+0x69c>
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 d042e10:	e0bffa17 	ldw	r2,-24(fp)
 d042e14:	10800417 	ldw	r2,16(r2)
 d042e18:	1004d63a 	srli	r2,r2,24
 d042e1c:	10c03fcc 	andi	r3,r2,255
 d042e20:	e0bffa17 	ldw	r2,-24(fp)
 d042e24:	10800417 	ldw	r2,16(r2)
 d042e28:	1004d23a 	srli	r2,r2,8
 d042e2c:	10bfc00c 	andi	r2,r2,65280
 d042e30:	1886b03a 	or	r3,r3,r2
 d042e34:	e0bffa17 	ldw	r2,-24(fp)
 d042e38:	10800417 	ldw	r2,16(r2)
 d042e3c:	10bfc00c 	andi	r2,r2,65280
 d042e40:	1004923a 	slli	r2,r2,8
 d042e44:	1886b03a 	or	r3,r3,r2
 d042e48:	e0bffa17 	ldw	r2,-24(fp)
 d042e4c:	10800417 	ldw	r2,16(r2)
 d042e50:	10803fcc 	andi	r2,r2,255
 d042e54:	1004963a 	slli	r2,r2,24
 d042e58:	1884b03a 	or	r2,r3,r2
 d042e5c:	10fc002c 	andhi	r3,r2,61440
 d042e60:	00b80034 	movhi	r2,57344
 d042e64:	18800926 	beq	r3,r2,d042e8c <udpdemux+0x5fc>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 d042e68:	e0bff817 	ldw	r2,-32(fp)
 d042e6c:	10800317 	ldw	r2,12(r2)
 d042e70:	1005003a 	cmpeq	r2,r2,zero
 d042e74:	1000051e 	bne	r2,zero,d042e8c <udpdemux+0x5fc>
 d042e78:	e0bff817 	ldw	r2,-32(fp)
 d042e7c:	10c00317 	ldw	r3,12(r2)
 d042e80:	e0bffa17 	ldw	r2,-24(fp)
 d042e84:	10800417 	ldw	r2,16(r2)
 d042e88:	1880281e 	bne	r3,r2,d042f2c <udpdemux+0x69c>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 d042e8c:	008341b4 	movhi	r2,3334
 d042e90:	10b50504 	addi	r2,r2,-11244
 d042e94:	10800017 	ldw	r2,0(r2)
 d042e98:	10c00044 	addi	r3,r2,1
 d042e9c:	008341b4 	movhi	r2,3334
 d042ea0:	10b50504 	addi	r2,r2,-11244
 d042ea4:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 d042ea8:	e0bff817 	ldw	r2,-32(fp)
 d042eac:	10800517 	ldw	r2,20(r2)
 d042eb0:	1005003a 	cmpeq	r2,r2,zero
 d042eb4:	10000c1e 	bne	r2,zero,d042ee8 <udpdemux+0x658>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 d042eb8:	0009883a 	mov	r4,zero
 d042ebc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 d042ec0:	e0bff817 	ldw	r2,-32(fp)
 d042ec4:	10c00517 	ldw	r3,20(r2)
 d042ec8:	e0bff817 	ldw	r2,-32(fp)
 d042ecc:	11400617 	ldw	r5,24(r2)
 d042ed0:	e13ffe17 	ldw	r4,-8(fp)
 d042ed4:	183ee83a 	callr	r3
 d042ed8:	e0bff515 	stw	r2,-44(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 d042edc:	0009883a 	mov	r4,zero
 d042ee0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
 d042ee4:	00000206 	br	d042ef0 <udpdemux+0x660>
      }
      else
         e = ENP_LOGIC;
 d042ee8:	00bffd44 	movi	r2,-11
 d042eec:	e0bff515 	stw	r2,-44(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 d042ef0:	e0bff517 	ldw	r2,-44(fp)
 d042ef4:	1005003a 	cmpeq	r2,r2,zero
 d042ef8:	1000091e 	bne	r2,zero,d042f20 <udpdemux+0x690>
      {
         udp_mib.udpInErrors++;
 d042efc:	008341b4 	movhi	r2,3334
 d042f00:	10b50504 	addi	r2,r2,-11244
 d042f04:	10800217 	ldw	r2,8(r2)
 d042f08:	10c00044 	addi	r3,r2,1
 d042f0c:	008341b4 	movhi	r2,3334
 d042f10:	10b50504 	addi	r2,r2,-11244
 d042f14:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 d042f18:	e13ffe17 	ldw	r4,-8(fp)
 d042f1c:	d04368c0 	call	d04368c <udp_free>
      }

      return(e);
 d042f20:	e0bff517 	ldw	r2,-44(fp)
 d042f24:	e0bfff15 	stw	r2,-4(fp)
 d042f28:	00006906 	br	d0430d0 <udpdemux+0x840>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 d042f2c:	e0bff817 	ldw	r2,-32(fp)
 d042f30:	10800017 	ldw	r2,0(r2)
 d042f34:	e0bff815 	stw	r2,-32(fp)
 d042f38:	e0bff817 	ldw	r2,-32(fp)
 d042f3c:	1004c03a 	cmpne	r2,r2,zero
 d042f40:	103f4c1e 	bne	r2,zero,d042c74 <udpdemux+0x3e4>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 d042f44:	e0bffa17 	ldw	r2,-24(fp)
 d042f48:	10800417 	ldw	r2,16(r2)
 d042f4c:	10bfffe0 	cmpeqi	r2,r2,-1
 d042f50:	1000121e 	bne	r2,zero,d042f9c <udpdemux+0x70c>
 d042f54:	e0bffa17 	ldw	r2,-24(fp)
 d042f58:	10c00417 	ldw	r3,16(r2)
 d042f5c:	e0bffe17 	ldw	r2,-8(fp)
 d042f60:	10800617 	ldw	r2,24(r2)
 d042f64:	10800e17 	ldw	r2,56(r2)
 d042f68:	18800c26 	beq	r3,r2,d042f9c <udpdemux+0x70c>
 d042f6c:	e0bffa17 	ldw	r2,-24(fp)
 d042f70:	10c00417 	ldw	r3,16(r2)
 d042f74:	e0bffe17 	ldw	r2,-8(fp)
 d042f78:	10800617 	ldw	r2,24(r2)
 d042f7c:	10800f17 	ldw	r2,60(r2)
 d042f80:	18800626 	beq	r3,r2,d042f9c <udpdemux+0x70c>
 d042f84:	e0bffa17 	ldw	r2,-24(fp)
 d042f88:	10c00417 	ldw	r3,16(r2)
 d042f8c:	e0bffe17 	ldw	r2,-8(fp)
 d042f90:	10800617 	ldw	r2,24(r2)
 d042f94:	10801017 	ldw	r2,64(r2)
 d042f98:	18801b1e 	bne	r3,r2,d043008 <udpdemux+0x778>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d042f9c:	00834174 	movhi	r2,3333
 d042fa0:	108aa404 	addi	r2,r2,10896
 d042fa4:	10800017 	ldw	r2,0(r2)
 d042fa8:	1081000c 	andi	r2,r2,1024
 d042fac:	1005003a 	cmpeq	r2,r2,zero
 d042fb0:	1000091e 	bne	r2,zero,d042fd8 <udpdemux+0x748>
 d042fb4:	00834174 	movhi	r2,3333
 d042fb8:	108aa404 	addi	r2,r2,10896
 d042fbc:	10800017 	ldw	r2,0(r2)
 d042fc0:	1080400c 	andi	r2,r2,256
 d042fc4:	1005003a 	cmpeq	r2,r2,zero
 d042fc8:	1000031e 	bne	r2,zero,d042fd8 <udpdemux+0x748>
         dprintf("UDP: ignoring ip broadcast\n");
 d042fcc:	01034174 	movhi	r4,3333
 d042fd0:	21002804 	addi	r4,r4,160
 d042fd4:	d002cc00 	call	d002cc0 <puts>
#endif
      udp_mib.udpInErrors++;
 d042fd8:	008341b4 	movhi	r2,3334
 d042fdc:	10b50504 	addi	r2,r2,-11244
 d042fe0:	10800217 	ldw	r2,8(r2)
 d042fe4:	10c00044 	addi	r3,r2,1
 d042fe8:	008341b4 	movhi	r2,3334
 d042fec:	10b50504 	addi	r2,r2,-11244
 d042ff0:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 d042ff4:	e13ffe17 	ldw	r4,-8(fp)
 d042ff8:	d04368c0 	call	d04368c <udp_free>
      return ENP_NOT_MINE;
 d042ffc:	00800084 	movi	r2,2
 d043000:	e0bfff15 	stw	r2,-4(fp)
 d043004:	00003206 	br	d0430d0 <udpdemux+0x840>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 d043008:	00834174 	movhi	r2,3333
 d04300c:	108aa404 	addi	r2,r2,10896
 d043010:	10800017 	ldw	r2,0(r2)
 d043014:	1081000c 	andi	r2,r2,1024
 d043018:	1005003a 	cmpeq	r2,r2,zero
 d04301c:	1000141e 	bne	r2,zero,d043070 <udpdemux+0x7e0>
 d043020:	00834174 	movhi	r2,3333
 d043024:	108aa404 	addi	r2,r2,10896
 d043028:	10800017 	ldw	r2,0(r2)
 d04302c:	1080400c 	andi	r2,r2,256
 d043030:	1005003a 	cmpeq	r2,r2,zero
 d043034:	10000e1e 	bne	r2,zero,d043070 <udpdemux+0x7e0>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 d043038:	e0bff917 	ldw	r2,-28(fp)
 d04303c:	1080008b 	ldhu	r2,2(r2)
 d043040:	117fffcc 	andi	r5,r2,65535
 d043044:	01034174 	movhi	r4,3333
 d043048:	21002f04 	addi	r4,r4,188
 d04304c:	d0029980 	call	d002998 <printf>
      if (NDEBUG & DUMP) 
 d043050:	00834174 	movhi	r2,3333
 d043054:	108aa404 	addi	r2,r2,10896
 d043058:	10800017 	ldw	r2,0(r2)
 d04305c:	1080008c 	andi	r2,r2,2
 d043060:	1005003a 	cmpeq	r2,r2,zero
 d043064:	1000021e 	bne	r2,zero,d043070 <udpdemux+0x7e0>
         ip_dump(p);
 d043068:	e13ffe17 	ldw	r4,-8(fp)
 d04306c:	d03e6540 	call	d03e654 <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 d043070:	e13ff917 	ldw	r4,-28(fp)
 d043074:	d0433a00 	call	d0433a0 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 d043078:	e0bffe17 	ldw	r2,-8(fp)
 d04307c:	11000717 	ldw	r4,28(r2)
 d043080:	e0bffe17 	ldw	r2,-8(fp)
 d043084:	10800617 	ldw	r2,24(r2)
 d043088:	11400a17 	ldw	r5,40(r2)
 d04308c:	e0bffe17 	ldw	r2,-8(fp)
 d043090:	10800617 	ldw	r2,24(r2)
 d043094:	d8800015 	stw	r2,0(sp)
 d043098:	e1bffa17 	ldw	r6,-24(fp)
 d04309c:	01c000c4 	movi	r7,3
 d0430a0:	d0497540 	call	d049754 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 d0430a4:	008341b4 	movhi	r2,3334
 d0430a8:	10b50504 	addi	r2,r2,-11244
 d0430ac:	10800117 	ldw	r2,4(r2)
 d0430b0:	10c00044 	addi	r3,r2,1
 d0430b4:	008341b4 	movhi	r2,3334
 d0430b8:	10b50504 	addi	r2,r2,-11244
 d0430bc:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 d0430c0:	e13ffe17 	ldw	r4,-8(fp)
 d0430c4:	d04368c0 	call	d04368c <udp_free>
   return ENP_NOT_MINE;
 d0430c8:	00800084 	movi	r2,2
 d0430cc:	e0bfff15 	stw	r2,-4(fp)
 d0430d0:	e0bfff17 	ldw	r2,-4(fp)
}
 d0430d4:	e037883a 	mov	sp,fp
 d0430d8:	dfc00117 	ldw	ra,4(sp)
 d0430dc:	df000017 	ldw	fp,0(sp)
 d0430e0:	dec00204 	addi	sp,sp,8
 d0430e4:	f800283a 	ret

0d0430e8 <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 d0430e8:	deffee04 	addi	sp,sp,-72
 d0430ec:	dfc01115 	stw	ra,68(sp)
 d0430f0:	df001015 	stw	fp,64(sp)
 d0430f4:	df001004 	addi	fp,sp,64
 d0430f8:	e1bffe15 	stw	r6,-8(fp)
 d0430fc:	e13ffc0d 	sth	r4,-16(fp)
 d043100:	e17ffd0d 	sth	r5,-12(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 d043104:	00834174 	movhi	r2,3333
 d043108:	108aa404 	addi	r2,r2,10896
 d04310c:	10800017 	ldw	r2,0(r2)
 d043110:	1080410c 	andi	r2,r2,260
 d043114:	1005003a 	cmpeq	r2,r2,zero
 d043118:	10001c1e 	bne	r2,zero,d04318c <udp_send+0xa4>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 d04311c:	e0bffe17 	ldw	r2,-8(fp)
 d043120:	11800417 	ldw	r6,16(r2)
 d043124:	e1fffd0b 	ldhu	r7,-12(fp)
 d043128:	e0bffe17 	ldw	r2,-8(fp)
 d04312c:	10800717 	ldw	r2,28(r2)
 d043130:	12003fcc 	andi	r8,r2,255
 d043134:	e0bffe17 	ldw	r2,-8(fp)
 d043138:	10800717 	ldw	r2,28(r2)
 d04313c:	1004d23a 	srli	r2,r2,8
 d043140:	11003fcc 	andi	r4,r2,255
 d043144:	e0bffe17 	ldw	r2,-8(fp)
 d043148:	10800717 	ldw	r2,28(r2)
 d04314c:	1004d43a 	srli	r2,r2,16
 d043150:	11403fcc 	andi	r5,r2,255
 d043154:	e0bffe17 	ldw	r2,-8(fp)
 d043158:	10800717 	ldw	r2,28(r2)
 d04315c:	1004d63a 	srli	r2,r2,24
 d043160:	e0fffc0b 	ldhu	r3,-16(fp)
 d043164:	d9000015 	stw	r4,0(sp)
 d043168:	d9400115 	stw	r5,4(sp)
 d04316c:	d8800215 	stw	r2,8(sp)
 d043170:	d8c00315 	stw	r3,12(sp)
 d043174:	01034174 	movhi	r4,3333
 d043178:	21003604 	addi	r4,r4,216
 d04317c:	300b883a 	mov	r5,r6
 d043180:	380d883a 	mov	r6,r7
 d043184:	400f883a 	mov	r7,r8
 d043188:	d0029980 	call	d002998 <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 d04318c:	0009883a 	mov	r4,zero
 d043190:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 d043194:	e0bffe17 	ldw	r2,-8(fp)
 d043198:	10800317 	ldw	r2,12(r2)
 d04319c:	10fffe04 	addi	r3,r2,-8
 d0431a0:	e0bffe17 	ldw	r2,-8(fp)
 d0431a4:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 d0431a8:	e0bffe17 	ldw	r2,-8(fp)
 d0431ac:	10800317 	ldw	r2,12(r2)
 d0431b0:	e0bff815 	stw	r2,-32(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 d0431b4:	e0bffe17 	ldw	r2,-8(fp)
 d0431b8:	10800417 	ldw	r2,16(r2)
 d0431bc:	10800204 	addi	r2,r2,8
 d0431c0:	e0bff615 	stw	r2,-40(fp)
   p->nb_plen = udplen;
 d0431c4:	e0fff617 	ldw	r3,-40(fp)
 d0431c8:	e0bffe17 	ldw	r2,-8(fp)
 d0431cc:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 d0431d0:	e0bff617 	ldw	r2,-40(fp)
 d0431d4:	1080004c 	andi	r2,r2,1
 d0431d8:	10803fcc 	andi	r2,r2,255
 d0431dc:	1005003a 	cmpeq	r2,r2,zero
 d0431e0:	1000041e 	bne	r2,zero,d0431f4 <udp_send+0x10c>
 d0431e4:	e0fff817 	ldw	r3,-32(fp)
 d0431e8:	e0bff617 	ldw	r2,-40(fp)
 d0431ec:	1885883a 	add	r2,r3,r2
 d0431f0:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 d0431f4:	e0bff617 	ldw	r2,-40(fp)
 d0431f8:	1007883a 	mov	r3,r2
 d0431fc:	e0bff817 	ldw	r2,-32(fp)
 d043200:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 d043204:	e0fff817 	ldw	r3,-32(fp)
 d043208:	e0bffd0b 	ldhu	r2,-12(fp)
 d04320c:	1880000d 	sth	r2,0(r3)
   pup->ud_dstp = fport;
 d043210:	e0fff817 	ldw	r3,-32(fp)
 d043214:	e0bffc0b 	ldhu	r2,-16(fp)
 d043218:	1880008d 	sth	r2,2(r3)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 d04321c:	e13ff817 	ldw	r4,-32(fp)
 d043220:	d0433a00 	call	d0433a0 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 d043224:	e0bffe17 	ldw	r2,-8(fp)
 d043228:	10800717 	ldw	r2,28(r2)
 d04322c:	10bfffd8 	cmpnei	r2,r2,-1
 d043230:	1000111e 	bne	r2,zero,d043278 <udp_send+0x190>
   {
      if (!p->net)
 d043234:	e0bffe17 	ldw	r2,-8(fp)
 d043238:	10800617 	ldw	r2,24(r2)
 d04323c:	1004c03a 	cmpne	r2,r2,zero
 d043240:	1000081e 	bne	r2,zero,d043264 <udp_send+0x17c>
      {
         dtrap();    /* programmer forgot to select iface */
 d043244:	d0293e80 	call	d0293e8 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 d043248:	e13ffe17 	ldw	r4,-8(fp)
 d04324c:	d04368c0 	call	d04368c <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 d043250:	0009883a 	mov	r4,zero
 d043254:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 d043258:	00bff784 	movi	r2,-34
 d04325c:	e0bfff15 	stw	r2,-4(fp)
 d043260:	00004906 	br	d043388 <udp_send+0x2a0>
      }
      src_ip = p->net->n_ipaddr;
 d043264:	e0bffe17 	ldw	r2,-8(fp)
 d043268:	10800617 	ldw	r2,24(r2)
 d04326c:	10800a17 	ldw	r2,40(r2)
 d043270:	e0bff415 	stw	r2,-48(fp)
 d043274:	00000406 	br	d043288 <udp_send+0x1a0>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 d043278:	e0bffe17 	ldw	r2,-8(fp)
 d04327c:	11000717 	ldw	r4,28(r2)
 d043280:	d03e5a80 	call	d03e5a8 <ip_mymach>
 d043284:	e0bff415 	stw	r2,-48(fp)
   php.ph_src = src_ip;
 d043288:	e0bff417 	ldw	r2,-48(fp)
 d04328c:	e0bff915 	stw	r2,-28(fp)
   php.ph_dest = p->fhost;
 d043290:	e0bffe17 	ldw	r2,-8(fp)
 d043294:	10800717 	ldw	r2,28(r2)
 d043298:	e0bffa15 	stw	r2,-24(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 d04329c:	e03ffb05 	stb	zero,-20(fp)
   php.ph_prot = UDP_PROT;
 d0432a0:	00800444 	movi	r2,17
 d0432a4:	e0bffb45 	stb	r2,-19(fp)
   php.ph_len = pup->ud_len;
 d0432a8:	e0bff817 	ldw	r2,-32(fp)
 d0432ac:	1080010b 	ldhu	r2,4(r2)
 d0432b0:	e0bffb8d 	sth	r2,-18(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 d0432b4:	e13ff904 	addi	r4,fp,-28
 d0432b8:	01400184 	movi	r5,6
 d0432bc:	d0242340 	call	d024234 <cksum>
 d0432c0:	1007883a 	mov	r3,r2
 d0432c4:	e0bff817 	ldw	r2,-32(fp)
 d0432c8:	10c0018d 	sth	r3,6(r2)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 d0432cc:	e0bff617 	ldw	r2,-40(fp)
 d0432d0:	10800044 	addi	r2,r2,1
 d0432d4:	1005d07a 	srai	r2,r2,1
 d0432d8:	100b883a 	mov	r5,r2
 d0432dc:	e13ff817 	ldw	r4,-32(fp)
 d0432e0:	d0242340 	call	d024234 <cksum>
 d0432e4:	0084303a 	nor	r2,zero,r2
 d0432e8:	1007883a 	mov	r3,r2
 d0432ec:	e0bff817 	ldw	r2,-32(fp)
 d0432f0:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 d0432f4:	e0bff817 	ldw	r2,-32(fp)
 d0432f8:	1080018b 	ldhu	r2,6(r2)
 d0432fc:	10bfffcc 	andi	r2,r2,65535
 d043300:	1004c03a 	cmpne	r2,r2,zero
 d043304:	1000031e 	bne	r2,zero,d043314 <udp_send+0x22c>
      pup->ud_cksum = 0xffff;
 d043308:	e0fff817 	ldw	r3,-32(fp)
 d04330c:	00bfffc4 	movi	r2,-1
 d043310:	1880018d 	sth	r2,6(r3)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 d043314:	e0bffe17 	ldw	r2,-8(fp)
 d043318:	10800317 	ldw	r2,12(r2)
 d04331c:	10bffb04 	addi	r2,r2,-20
 d043320:	e0bff715 	stw	r2,-36(fp)
   pip->ip_src = src_ip;
 d043324:	e0fff717 	ldw	r3,-36(fp)
 d043328:	e0bff417 	ldw	r2,-48(fp)
 d04332c:	18800315 	stw	r2,12(r3)
   pip->ip_dest = p->fhost;
 d043330:	e0bffe17 	ldw	r2,-8(fp)
 d043334:	10c00717 	ldw	r3,28(r2)
 d043338:	e0bff717 	ldw	r2,-36(fp)
 d04333c:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 d043340:	008341b4 	movhi	r2,3334
 d043344:	10b50504 	addi	r2,r2,-11244
 d043348:	10800317 	ldw	r2,12(r2)
 d04334c:	10c00044 	addi	r3,r2,1
 d043350:	008341b4 	movhi	r2,3334
 d043354:	10b50504 	addi	r2,r2,-11244
 d043358:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 d04335c:	e0fff617 	ldw	r3,-40(fp)
 d043360:	e0bffe17 	ldw	r2,-8(fp)
 d043364:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 d043368:	01000444 	movi	r4,17
 d04336c:	e17ffe17 	ldw	r5,-8(fp)
 d043370:	d03d4240 	call	d03d424 <ip_write>
 d043374:	e0bff515 	stw	r2,-44(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 d043378:	0009883a 	mov	r4,zero
 d04337c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   return e;
 d043380:	e0bff517 	ldw	r2,-44(fp)
 d043384:	e0bfff15 	stw	r2,-4(fp)
 d043388:	e0bfff17 	ldw	r2,-4(fp)
}
 d04338c:	e037883a 	mov	sp,fp
 d043390:	dfc00117 	ldw	ra,4(sp)
 d043394:	df000017 	ldw	fp,0(sp)
 d043398:	dec00204 	addi	sp,sp,8
 d04339c:	f800283a 	ret

0d0433a0 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 d0433a0:	defffe04 	addi	sp,sp,-8
 d0433a4:	df000115 	stw	fp,4(sp)
 d0433a8:	df000104 	addi	fp,sp,4
 d0433ac:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 d0433b0:	e0bfff17 	ldw	r2,-4(fp)
 d0433b4:	1080000b 	ldhu	r2,0(r2)
 d0433b8:	10bfffcc 	andi	r2,r2,65535
 d0433bc:	1004d23a 	srli	r2,r2,8
 d0433c0:	10803fcc 	andi	r2,r2,255
 d0433c4:	1009883a 	mov	r4,r2
 d0433c8:	e0bfff17 	ldw	r2,-4(fp)
 d0433cc:	1080000b 	ldhu	r2,0(r2)
 d0433d0:	10bfffcc 	andi	r2,r2,65535
 d0433d4:	1004923a 	slli	r2,r2,8
 d0433d8:	1007883a 	mov	r3,r2
 d0433dc:	00bfc004 	movi	r2,-256
 d0433e0:	1884703a 	and	r2,r3,r2
 d0433e4:	2084b03a 	or	r2,r4,r2
 d0433e8:	1007883a 	mov	r3,r2
 d0433ec:	e0bfff17 	ldw	r2,-4(fp)
 d0433f0:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 d0433f4:	e0bfff17 	ldw	r2,-4(fp)
 d0433f8:	1080008b 	ldhu	r2,2(r2)
 d0433fc:	10bfffcc 	andi	r2,r2,65535
 d043400:	1004d23a 	srli	r2,r2,8
 d043404:	10803fcc 	andi	r2,r2,255
 d043408:	1009883a 	mov	r4,r2
 d04340c:	e0bfff17 	ldw	r2,-4(fp)
 d043410:	1080008b 	ldhu	r2,2(r2)
 d043414:	10bfffcc 	andi	r2,r2,65535
 d043418:	1004923a 	slli	r2,r2,8
 d04341c:	1007883a 	mov	r3,r2
 d043420:	00bfc004 	movi	r2,-256
 d043424:	1884703a 	and	r2,r3,r2
 d043428:	2084b03a 	or	r2,r4,r2
 d04342c:	1007883a 	mov	r3,r2
 d043430:	e0bfff17 	ldw	r2,-4(fp)
 d043434:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 d043438:	e0bfff17 	ldw	r2,-4(fp)
 d04343c:	1080010b 	ldhu	r2,4(r2)
 d043440:	10bfffcc 	andi	r2,r2,65535
 d043444:	1004d23a 	srli	r2,r2,8
 d043448:	10803fcc 	andi	r2,r2,255
 d04344c:	1009883a 	mov	r4,r2
 d043450:	e0bfff17 	ldw	r2,-4(fp)
 d043454:	1080010b 	ldhu	r2,4(r2)
 d043458:	10bfffcc 	andi	r2,r2,65535
 d04345c:	1004923a 	slli	r2,r2,8
 d043460:	1007883a 	mov	r3,r2
 d043464:	00bfc004 	movi	r2,-256
 d043468:	1884703a 	and	r2,r3,r2
 d04346c:	2084b03a 	or	r2,r4,r2
 d043470:	1007883a 	mov	r3,r2
 d043474:	e0bfff17 	ldw	r2,-4(fp)
 d043478:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 d04347c:	e0bfff17 	ldw	r2,-4(fp)
 d043480:	1080018b 	ldhu	r2,6(r2)
 d043484:	10bfffcc 	andi	r2,r2,65535
 d043488:	1004d23a 	srli	r2,r2,8
 d04348c:	10803fcc 	andi	r2,r2,255
 d043490:	1009883a 	mov	r4,r2
 d043494:	e0bfff17 	ldw	r2,-4(fp)
 d043498:	1080018b 	ldhu	r2,6(r2)
 d04349c:	10bfffcc 	andi	r2,r2,65535
 d0434a0:	1004923a 	slli	r2,r2,8
 d0434a4:	1007883a 	mov	r3,r2
 d0434a8:	00bfc004 	movi	r2,-256
 d0434ac:	1884703a 	and	r2,r3,r2
 d0434b0:	2084b03a 	or	r2,r4,r2
 d0434b4:	1007883a 	mov	r3,r2
 d0434b8:	e0bfff17 	ldw	r2,-4(fp)
 d0434bc:	10c0018d 	sth	r3,6(r2)
}
 d0434c0:	e037883a 	mov	sp,fp
 d0434c4:	df000017 	ldw	fp,0(sp)
 d0434c8:	dec00104 	addi	sp,sp,4
 d0434cc:	f800283a 	ret

0d0434d0 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 d0434d0:	defffe04 	addi	sp,sp,-8
 d0434d4:	df000115 	stw	fp,4(sp)
 d0434d8:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 d0434dc:	d0a0d10b 	ldhu	r2,-31932(gp)
 d0434e0:	10bfffcc 	andi	r2,r2,65535
 d0434e4:	10812c28 	cmpgeui	r2,r2,1200
 d0434e8:	10000c1e 	bne	r2,zero,d04351c <udp_socket+0x4c>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 d0434ec:	00834174 	movhi	r2,3333
 d0434f0:	108ac904 	addi	r2,r2,11044
 d0434f4:	10800017 	ldw	r2,0(r2)
 d0434f8:	109fffcc 	andi	r2,r2,32767
 d0434fc:	d0a0d10d 	sth	r2,-31932(gp)
      if (usocket < MINSOCKET)
 d043500:	d0a0d10b 	ldhu	r2,-31932(gp)
 d043504:	10bfffcc 	andi	r2,r2,65535
 d043508:	10812c28 	cmpgeui	r2,r2,1200
 d04350c:	1000031e 	bne	r2,zero,d04351c <udp_socket+0x4c>
         usocket += MINSOCKET;
 d043510:	d0a0d10b 	ldhu	r2,-31932(gp)
 d043514:	10812c04 	addi	r2,r2,1200
 d043518:	d0a0d10d 	sth	r2,-31932(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d04351c:	00834174 	movhi	r2,3333
 d043520:	108abd04 	addi	r2,r2,10996
 d043524:	10800017 	ldw	r2,0(r2)
 d043528:	e0bfff15 	stw	r2,-4(fp)
 d04352c:	00001006 	br	d043570 <udp_socket+0xa0>
   {
      if (tmp->u_lport == usocket)
 d043530:	e0bfff17 	ldw	r2,-4(fp)
 d043534:	1080018b 	ldhu	r2,6(r2)
 d043538:	d0e0d10b 	ldhu	r3,-31932(gp)
 d04353c:	113fffcc 	andi	r4,r2,65535
 d043540:	18bfffcc 	andi	r2,r3,65535
 d043544:	2080071e 	bne	r4,r2,d043564 <udp_socket+0x94>
      {
         usocket++;     /* bump socket number */
 d043548:	d0a0d10b 	ldhu	r2,-31932(gp)
 d04354c:	10800044 	addi	r2,r2,1
 d043550:	d0a0d10d 	sth	r2,-31932(gp)
         tmp = firstudp;   /* restart scan */
 d043554:	00834174 	movhi	r2,3333
 d043558:	108abd04 	addi	r2,r2,10996
 d04355c:	10800017 	ldw	r2,0(r2)
 d043560:	e0bfff15 	stw	r2,-4(fp)
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 d043564:	e0bfff17 	ldw	r2,-4(fp)
 d043568:	10800017 	ldw	r2,0(r2)
 d04356c:	e0bfff15 	stw	r2,-4(fp)
 d043570:	e0bfff17 	ldw	r2,-4(fp)
 d043574:	1004c03a 	cmpne	r2,r2,zero
 d043578:	103fed1e 	bne	r2,zero,d043530 <udp_socket+0x60>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 d04357c:	d0a0d10b 	ldhu	r2,-31932(gp)
 d043580:	10ffffcc 	andi	r3,r2,65535
 d043584:	10800044 	addi	r2,r2,1
 d043588:	d0a0d10d 	sth	r2,-31932(gp)
 d04358c:	1805883a 	mov	r2,r3
}
 d043590:	e037883a 	mov	sp,fp
 d043594:	df000017 	ldw	fp,0(sp)
 d043598:	dec00104 	addi	sp,sp,4
 d04359c:	f800283a 	ret

0d0435a0 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 d0435a0:	defffa04 	addi	sp,sp,-24
 d0435a4:	dfc00515 	stw	ra,20(sp)
 d0435a8:	df000415 	stw	fp,16(sp)
 d0435ac:	df000404 	addi	fp,sp,16
 d0435b0:	e13ffe15 	stw	r4,-8(fp)
 d0435b4:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 d0435b8:	e0bffe17 	ldw	r2,-8(fp)
 d0435bc:	10800244 	addi	r2,r2,9
 d0435c0:	1007883a 	mov	r3,r2
 d0435c4:	00bfff84 	movi	r2,-2
 d0435c8:	1884703a 	and	r2,r3,r2
 d0435cc:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d0435d0:	01000084 	movi	r4,2
 d0435d4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 d0435d8:	e0fffd17 	ldw	r3,-12(fp)
 d0435dc:	e0bfff17 	ldw	r2,-4(fp)
 d0435e0:	1885883a 	add	r2,r3,r2
 d0435e4:	10800904 	addi	r2,r2,36
 d0435e8:	1009883a 	mov	r4,r2
 d0435ec:	d0287a40 	call	d0287a4 <pk_alloc>
 d0435f0:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0435f4:	01000084 	movi	r4,2
 d0435f8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 d0435fc:	e0bffc17 	ldw	r2,-16(fp)
 d043600:	1005003a 	cmpeq	r2,r2,zero
 d043604:	1000101e 	bne	r2,zero,d043648 <udp_alloc+0xa8>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 d043608:	e0bfff17 	ldw	r2,-4(fp)
 d04360c:	1005d0ba 	srai	r2,r2,2
 d043610:	10800704 	addi	r2,r2,28
 d043614:	e0bffd15 	stw	r2,-12(fp)
      p->nb_prot += len;
 d043618:	e0bffc17 	ldw	r2,-16(fp)
 d04361c:	10c00317 	ldw	r3,12(r2)
 d043620:	e0bffd17 	ldw	r2,-12(fp)
 d043624:	1887883a 	add	r3,r3,r2
 d043628:	e0bffc17 	ldw	r2,-16(fp)
 d04362c:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 d043630:	e0bffc17 	ldw	r2,-16(fp)
 d043634:	10c00417 	ldw	r3,16(r2)
 d043638:	e0bffd17 	ldw	r2,-12(fp)
 d04363c:	1887c83a 	sub	r3,r3,r2
 d043640:	e0bffc17 	ldw	r2,-16(fp)
 d043644:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 d043648:	e0bffc17 	ldw	r2,-16(fp)
}
 d04364c:	e037883a 	mov	sp,fp
 d043650:	dfc00117 	ldw	ra,4(sp)
 d043654:	df000017 	ldw	fp,0(sp)
 d043658:	dec00204 	addi	sp,sp,8
 d04365c:	f800283a 	ret

0d043660 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 d043660:	deffff04 	addi	sp,sp,-4
 d043664:	df000015 	stw	fp,0(sp)
 d043668:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 d04366c:	00834174 	movhi	r2,3333
 d043670:	108a5a04 	addi	r2,r2,10600
 d043674:	10800017 	ldw	r2,0(r2)
 d043678:	10bff704 	addi	r2,r2,-36
#endif
}
 d04367c:	e037883a 	mov	sp,fp
 d043680:	df000017 	ldw	fp,0(sp)
 d043684:	dec00104 	addi	sp,sp,4
 d043688:	f800283a 	ret

0d04368c <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 d04368c:	defffd04 	addi	sp,sp,-12
 d043690:	dfc00215 	stw	ra,8(sp)
 d043694:	df000115 	stw	fp,4(sp)
 d043698:	df000104 	addi	fp,sp,4
 d04369c:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d0436a0:	01000084 	movi	r4,2
 d0436a4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free(p);
 d0436a8:	e13fff17 	ldw	r4,-4(fp)
 d0436ac:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0436b0:	01000084 	movi	r4,2
 d0436b4:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
}
 d0436b8:	e037883a 	mov	sp,fp
 d0436bc:	dfc00117 	ldw	ra,4(sp)
 d0436c0:	df000017 	ldw	fp,0(sp)
 d0436c4:	dec00204 	addi	sp,sp,8
 d0436c8:	f800283a 	ret

0d0436cc <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 d0436cc:	defff704 	addi	sp,sp,-36
 d0436d0:	dfc00815 	stw	ra,32(sp)
 d0436d4:	df000715 	stw	fp,28(sp)
 d0436d8:	df000704 	addi	fp,sp,28
 d0436dc:	e13ffe15 	stw	r4,-8(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 d0436e0:	e0bffe17 	ldw	r2,-8(fp)
 d0436e4:	10800617 	ldw	r2,24(r2)
 d0436e8:	e0bffa15 	stw	r2,-24(fp)
   int rc;
         
   pip = ip_head (p);
 d0436ec:	e0bffe17 	ldw	r2,-8(fp)
 d0436f0:	10800317 	ldw	r2,12(r2)
 d0436f4:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));
 d0436f8:	e0bffc17 	ldw	r2,-16(fp)
 d0436fc:	10800003 	ldbu	r2,0(r2)
 d043700:	10803fcc 	andi	r2,r2,255
 d043704:	108003cc 	andi	r2,r2,15
 d043708:	1085883a 	add	r2,r2,r2
 d04370c:	1085883a 	add	r2,r2,r2
 d043710:	1007883a 	mov	r3,r2
 d043714:	e0bffc17 	ldw	r2,-16(fp)
 d043718:	1885883a 	add	r2,r3,r2
 d04371c:	e0bffd15 	stw	r2,-12(fp)

   switch (igmp->igmp_type) 
 d043720:	e0bffd17 	ldw	r2,-12(fp)
 d043724:	10800003 	ldbu	r2,0(r2)
 d043728:	10803fcc 	andi	r2,r2,255
 d04372c:	e0bfff15 	stw	r2,-4(fp)
 d043730:	e0ffff17 	ldw	r3,-4(fp)
 d043734:	18800460 	cmpeqi	r2,r3,17
 d043738:	1000041e 	bne	r2,zero,d04374c <igmpv1_input+0x80>
 d04373c:	e0ffff17 	ldw	r3,-4(fp)
 d043740:	188004a0 	cmpeqi	r2,r3,18
 d043744:	1000631e 	bne	r2,zero,d0438d4 <igmpv1_input+0x208>
 d043748:	00008706 	br	d043968 <igmpv1_input+0x29c>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 d04374c:	008341b4 	movhi	r2,3334
 d043750:	10b2a904 	addi	r2,r2,-13660
 d043754:	10800117 	ldw	r2,4(r2)
 d043758:	10c00044 	addi	r3,r2,1
 d04375c:	008341b4 	movhi	r2,3334
 d043760:	10b2a904 	addi	r2,r2,-13660
 d043764:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 d043768:	e0bffa17 	ldw	r2,-24(fp)
 d04376c:	10802c17 	ldw	r2,176(r2)
 d043770:	e0bffb15 	stw	r2,-20(fp)
 d043774:	00005206 	br	d0438c0 <igmpv1_input+0x1f4>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 d043778:	e0bffb17 	ldw	r2,-20(fp)
 d04377c:	10800017 	ldw	r2,0(r2)
 d043780:	1005003a 	cmpeq	r2,r2,zero
 d043784:	10004b1e 	bne	r2,zero,d0438b4 <igmpv1_input+0x1e8>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 d043788:	e0bffb17 	ldw	r2,-20(fp)
 d04378c:	10c00017 	ldw	r3,0(r2)
 d043790:	00834174 	movhi	r2,3333
 d043794:	108aa904 	addi	r2,r2,10916
 d043798:	10800017 	ldw	r2,0(r2)
 d04379c:	18804526 	beq	r3,r2,d0438b4 <igmpv1_input+0x1e8>
         {
            if (inm->inm_timer == 0)
 d0437a0:	e0bffb17 	ldw	r2,-20(fp)
 d0437a4:	10800317 	ldw	r2,12(r2)
 d0437a8:	1004c03a 	cmpne	r2,r2,zero
 d0437ac:	1000411e 	bne	r2,zero,d0438b4 <igmpv1_input+0x1e8>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 d0437b0:	008341b4 	movhi	r2,3334
 d0437b4:	10b4eb04 	addi	r2,r2,-11348
 d0437b8:	11000217 	ldw	r4,8(r2)
 d0437bc:	008341b4 	movhi	r2,3334
 d0437c0:	10b2a504 	addi	r2,r2,-13676
 d0437c4:	10800017 	ldw	r2,0(r2)
 d0437c8:	10800a17 	ldw	r2,40(r2)
 d0437cc:	1004d63a 	srli	r2,r2,24
 d0437d0:	10c03fcc 	andi	r3,r2,255
 d0437d4:	008341b4 	movhi	r2,3334
 d0437d8:	10b2a504 	addi	r2,r2,-13676
 d0437dc:	10800017 	ldw	r2,0(r2)
 d0437e0:	10800a17 	ldw	r2,40(r2)
 d0437e4:	1004d23a 	srli	r2,r2,8
 d0437e8:	10bfc00c 	andi	r2,r2,65280
 d0437ec:	1886b03a 	or	r3,r3,r2
 d0437f0:	008341b4 	movhi	r2,3334
 d0437f4:	10b2a504 	addi	r2,r2,-13676
 d0437f8:	10800017 	ldw	r2,0(r2)
 d0437fc:	10800a17 	ldw	r2,40(r2)
 d043800:	10bfc00c 	andi	r2,r2,65280
 d043804:	1004923a 	slli	r2,r2,8
 d043808:	1886b03a 	or	r3,r3,r2
 d04380c:	008341b4 	movhi	r2,3334
 d043810:	10b2a504 	addi	r2,r2,-13676
 d043814:	10800017 	ldw	r2,0(r2)
 d043818:	10800a17 	ldw	r2,40(r2)
 d04381c:	10803fcc 	andi	r2,r2,255
 d043820:	1004963a 	slli	r2,r2,24
 d043824:	1884b03a 	or	r2,r3,r2
 d043828:	2089883a 	add	r4,r4,r2
 d04382c:	e0bffb17 	ldw	r2,-20(fp)
 d043830:	10800017 	ldw	r2,0(r2)
 d043834:	1004d63a 	srli	r2,r2,24
 d043838:	10c03fcc 	andi	r3,r2,255
 d04383c:	e0bffb17 	ldw	r2,-20(fp)
 d043840:	10800017 	ldw	r2,0(r2)
 d043844:	1004d23a 	srli	r2,r2,8
 d043848:	10bfc00c 	andi	r2,r2,65280
 d04384c:	1886b03a 	or	r3,r3,r2
 d043850:	e0bffb17 	ldw	r2,-20(fp)
 d043854:	10800017 	ldw	r2,0(r2)
 d043858:	10bfc00c 	andi	r2,r2,65280
 d04385c:	1004923a 	slli	r2,r2,8
 d043860:	1886b03a 	or	r3,r3,r2
 d043864:	e0bffb17 	ldw	r2,-20(fp)
 d043868:	10800017 	ldw	r2,0(r2)
 d04386c:	10803fcc 	andi	r2,r2,255
 d043870:	1004963a 	slli	r2,r2,24
 d043874:	1884b03a 	or	r2,r3,r2
 d043878:	2087883a 	add	r3,r4,r2
 d04387c:	00800c84 	movi	r2,50
 d043880:	1885203a 	divu	r2,r3,r2
 d043884:	10800ca4 	muli	r2,r2,50
 d043888:	1885c83a 	sub	r2,r3,r2
 d04388c:	10c00044 	addi	r3,r2,1
 d043890:	e0bffb17 	ldw	r2,-20(fp)
 d043894:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 d043898:	00834174 	movhi	r2,3333
 d04389c:	108aa704 	addi	r2,r2,10908
 d0438a0:	10800017 	ldw	r2,0(r2)
 d0438a4:	10c00044 	addi	r3,r2,1
 d0438a8:	00834174 	movhi	r2,3333
 d0438ac:	108aa704 	addi	r2,r2,10908
 d0438b0:	10c00015 	stw	r3,0(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 d0438b4:	e0bffb17 	ldw	r2,-20(fp)
 d0438b8:	10800517 	ldw	r2,20(r2)
 d0438bc:	e0bffb15 	stw	r2,-20(fp)
 d0438c0:	e0bffb17 	ldw	r2,-20(fp)
 d0438c4:	1004c03a 	cmpne	r2,r2,zero
 d0438c8:	103fab1e 	bne	r2,zero,d043778 <igmpv1_input+0xac>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 d0438cc:	e03ff915 	stw	zero,-28(fp)
      break;
 d0438d0:	00002e06 	br	d04398c <igmpv1_input+0x2c0>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 d0438d4:	008341b4 	movhi	r2,3334
 d0438d8:	10b2a904 	addi	r2,r2,-13660
 d0438dc:	10800217 	ldw	r2,8(r2)
 d0438e0:	10c00044 	addi	r3,r2,1
 d0438e4:	008341b4 	movhi	r2,3334
 d0438e8:	10b2a904 	addi	r2,r2,-13660
 d0438ec:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 d0438f0:	e0bffd17 	ldw	r2,-12(fp)
 d0438f4:	11000117 	ldw	r4,4(r2)
 d0438f8:	e17ffa17 	ldw	r5,-24(fp)
 d0438fc:	d041afc0 	call	d041afc <lookup_mcast>
 d043900:	e0bffb15 	stw	r2,-20(fp)
      if (inm != NULL) 
 d043904:	e0bffb17 	ldw	r2,-20(fp)
 d043908:	1005003a 	cmpeq	r2,r2,zero
 d04390c:	1000141e 	bne	r2,zero,d043960 <igmpv1_input+0x294>
      {
         if (inm->inm_timer > 0)
 d043910:	e0bffb17 	ldw	r2,-20(fp)
 d043914:	10800317 	ldw	r2,12(r2)
 d043918:	1005003a 	cmpeq	r2,r2,zero
 d04391c:	1000101e 	bne	r2,zero,d043960 <igmpv1_input+0x294>
         {
            inm->inm_timer = 0;
 d043920:	e0bffb17 	ldw	r2,-20(fp)
 d043924:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 d043928:	00834174 	movhi	r2,3333
 d04392c:	108aa704 	addi	r2,r2,10908
 d043930:	10800017 	ldw	r2,0(r2)
 d043934:	10ffffc4 	addi	r3,r2,-1
 d043938:	00834174 	movhi	r2,3333
 d04393c:	108aa704 	addi	r2,r2,10908
 d043940:	10c00015 	stw	r3,0(r2)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 d043944:	008341b4 	movhi	r2,3334
 d043948:	10b2a904 	addi	r2,r2,-13660
 d04394c:	10800317 	ldw	r2,12(r2)
 d043950:	10c00044 	addi	r3,r2,1
 d043954:	008341b4 	movhi	r2,3334
 d043958:	10b2a904 	addi	r2,r2,-13660
 d04395c:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 d043960:	e03ff915 	stw	zero,-28(fp)
      break;
 d043964:	00000906 	br	d04398c <igmpv1_input+0x2c0>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 d043968:	008341b4 	movhi	r2,3334
 d04396c:	10b2a904 	addi	r2,r2,-13660
 d043970:	10801017 	ldw	r2,64(r2)
 d043974:	10c00044 	addi	r3,r2,1
 d043978:	008341b4 	movhi	r2,3334
 d04397c:	10b2a904 	addi	r2,r2,-13660
 d043980:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 d043984:	00bfffc4 	movi	r2,-1
 d043988:	e0bff915 	stw	r2,-28(fp)
      break;   
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d04398c:	01000084 	movi	r4,2
 d043990:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free(p);
 d043994:	e13ffe17 	ldw	r4,-8(fp)
 d043998:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d04399c:	01000084 	movi	r4,2
 d0439a0:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      
   return rc;
 d0439a4:	e0bff917 	ldw	r2,-28(fp)
}
 d0439a8:	e037883a 	mov	sp,fp
 d0439ac:	dfc00117 	ldw	ra,4(sp)
 d0439b0:	df000017 	ldw	fp,0(sp)
 d0439b4:	dec00204 	addi	sp,sp,8
 d0439b8:	f800283a 	ret

0d0439bc <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 d0439bc:	defff704 	addi	sp,sp,-36
 d0439c0:	dfc00815 	stw	ra,32(sp)
 d0439c4:	df000715 	stw	fp,28(sp)
 d0439c8:	df000704 	addi	fp,sp,28
 d0439cc:	e13ffe15 	stw	r4,-8(fp)
   struct ip * pip;
   int igmplen;
   u_char type;
   int rc;

   pip = ip_head (p);    
 d0439d0:	e0bffe17 	ldw	r2,-8(fp)
 d0439d4:	10800317 	ldw	r2,12(r2)
 d0439d8:	e0bffc15 	stw	r2,-16(fp)
   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */   
   igmplen = p->nb_plen - ip_hlen (pip);
 d0439dc:	e0bffe17 	ldw	r2,-8(fp)
 d0439e0:	10c00417 	ldw	r3,16(r2)
 d0439e4:	e0bffc17 	ldw	r2,-16(fp)
 d0439e8:	10800003 	ldbu	r2,0(r2)
 d0439ec:	10803fcc 	andi	r2,r2,255
 d0439f0:	108003cc 	andi	r2,r2,15
 d0439f4:	1085883a 	add	r2,r2,r2
 d0439f8:	1085883a 	add	r2,r2,r2
 d0439fc:	1885c83a 	sub	r2,r3,r2
 d043a00:	e0bffb15 	stw	r2,-20(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 d043a04:	e0bffc17 	ldw	r2,-16(fp)
 d043a08:	10800003 	ldbu	r2,0(r2)
 d043a0c:	10803fcc 	andi	r2,r2,255
 d043a10:	108003cc 	andi	r2,r2,15
 d043a14:	1085883a 	add	r2,r2,r2
 d043a18:	1085883a 	add	r2,r2,r2
 d043a1c:	1007883a 	mov	r3,r2
 d043a20:	e0bffc17 	ldw	r2,-16(fp)
 d043a24:	1885883a 	add	r2,r3,r2
 d043a28:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 d043a2c:	e0bffd17 	ldw	r2,-12(fp)
 d043a30:	10800003 	ldbu	r2,0(r2)
 d043a34:	e0bffa05 	stb	r2,-24(fp)

   switch (type) 
 d043a38:	e0bffa03 	ldbu	r2,-24(fp)
 d043a3c:	e0bfff15 	stw	r2,-4(fp)
 d043a40:	e0ffff17 	ldw	r3,-4(fp)
 d043a44:	188004a0 	cmpeqi	r2,r3,18
 d043a48:	1000121e 	bne	r2,zero,d043a94 <igmpv2_input+0xd8>
 d043a4c:	e0ffff17 	ldw	r3,-4(fp)
 d043a50:	188004c8 	cmpgei	r2,r3,19
 d043a54:	1000041e 	bne	r2,zero,d043a68 <igmpv2_input+0xac>
 d043a58:	e0ffff17 	ldw	r3,-4(fp)
 d043a5c:	18800460 	cmpeqi	r2,r3,17
 d043a60:	1000081e 	bne	r2,zero,d043a84 <igmpv2_input+0xc8>
 d043a64:	00001806 	br	d043ac8 <igmpv2_input+0x10c>
 d043a68:	e0ffff17 	ldw	r3,-4(fp)
 d043a6c:	188005a0 	cmpeqi	r2,r3,22
 d043a70:	1000081e 	bne	r2,zero,d043a94 <igmpv2_input+0xd8>
 d043a74:	e0ffff17 	ldw	r3,-4(fp)
 d043a78:	188005e0 	cmpeqi	r2,r3,23
 d043a7c:	1000091e 	bne	r2,zero,d043aa4 <igmpv2_input+0xe8>
 d043a80:	00001106 	br	d043ac8 <igmpv2_input+0x10c>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 d043a84:	e13ffe17 	ldw	r4,-8(fp)
 d043a88:	d043c680 	call	d043c68 <igmpv2_process_query>
 d043a8c:	e0bff915 	stw	r2,-28(fp)
         break;
 d043a90:	00001606 	br	d043aec <igmpv2_input+0x130>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 d043a94:	e13ffe17 	ldw	r4,-8(fp)
 d043a98:	d043b1c0 	call	d043b1c <igmpv2_process_report>
 d043a9c:	e0bff915 	stw	r2,-28(fp)
         break;
 d043aa0:	00001206 	br	d043aec <igmpv2_input+0x130>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 d043aa4:	008341b4 	movhi	r2,3334
 d043aa8:	10b2a904 	addi	r2,r2,-13660
 d043aac:	10800917 	ldw	r2,36(r2)
 d043ab0:	10c00044 	addi	r3,r2,1
 d043ab4:	008341b4 	movhi	r2,3334
 d043ab8:	10b2a904 	addi	r2,r2,-13660
 d043abc:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 d043ac0:	e03ff915 	stw	zero,-28(fp)
         break;               
 d043ac4:	00000906 	br	d043aec <igmpv2_input+0x130>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 d043ac8:	008341b4 	movhi	r2,3334
 d043acc:	10b2a904 	addi	r2,r2,-13660
 d043ad0:	10801517 	ldw	r2,84(r2)
 d043ad4:	10c00044 	addi	r3,r2,1
 d043ad8:	008341b4 	movhi	r2,3334
 d043adc:	10b2a904 	addi	r2,r2,-13660
 d043ae0:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 d043ae4:	00bfffc4 	movi	r2,-1
 d043ae8:	e0bff915 	stw	r2,-28(fp)
         break;
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d043aec:	01000084 	movi	r4,2
 d043af0:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   pk_free(p);
 d043af4:	e13ffe17 	ldw	r4,-8(fp)
 d043af8:	d028b380 	call	d028b38 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d043afc:	01000084 	movi	r4,2
 d043b00:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
   
   return rc;
 d043b04:	e0bff917 	ldw	r2,-28(fp)
}
 d043b08:	e037883a 	mov	sp,fp
 d043b0c:	dfc00117 	ldw	ra,4(sp)
 d043b10:	df000017 	ldw	fp,0(sp)
 d043b14:	dec00204 	addi	sp,sp,8
 d043b18:	f800283a 	ret

0d043b1c <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 d043b1c:	defff904 	addi	sp,sp,-28
 d043b20:	dfc00615 	stw	ra,24(sp)
 d043b24:	df000515 	stw	fp,20(sp)
 d043b28:	df000504 	addi	fp,sp,20
 d043b2c:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 d043b30:	e0bfff17 	ldw	r2,-4(fp)
 d043b34:	10800617 	ldw	r2,24(r2)
 d043b38:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 d043b3c:	e0bfff17 	ldw	r2,-4(fp)
 d043b40:	10800317 	ldw	r2,12(r2)
 d043b44:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 d043b48:	e0bffd17 	ldw	r2,-12(fp)
 d043b4c:	10800003 	ldbu	r2,0(r2)
 d043b50:	10803fcc 	andi	r2,r2,255
 d043b54:	108003cc 	andi	r2,r2,15
 d043b58:	1085883a 	add	r2,r2,r2
 d043b5c:	1085883a 	add	r2,r2,r2
 d043b60:	1007883a 	mov	r3,r2
 d043b64:	e0bffd17 	ldw	r2,-12(fp)
 d043b68:	1885883a 	add	r2,r3,r2
 d043b6c:	e0bffe15 	stw	r2,-8(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 d043b70:	e0bffe17 	ldw	r2,-8(fp)
 d043b74:	11000117 	ldw	r4,4(r2)
 d043b78:	e17ffc17 	ldw	r5,-16(fp)
 d043b7c:	d041afc0 	call	d041afc <lookup_mcast>
 d043b80:	e0bffb15 	stw	r2,-20(fp)
   if (inm != NULL) 
 d043b84:	e0bffb17 	ldw	r2,-20(fp)
 d043b88:	1005003a 	cmpeq	r2,r2,zero
 d043b8c:	1000291e 	bne	r2,zero,d043c34 <igmpv2_process_report+0x118>
   {
      if (inm->inm_timer != 0)
 d043b90:	e0bffb17 	ldw	r2,-20(fp)
 d043b94:	10800317 	ldw	r2,12(r2)
 d043b98:	1005003a 	cmpeq	r2,r2,zero
 d043b9c:	10001d1e 	bne	r2,zero,d043c14 <igmpv2_process_report+0xf8>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 d043ba0:	e0bffc17 	ldw	r2,-16(fp)
 d043ba4:	10802d03 	ldbu	r2,180(r2)
 d043ba8:	10803fcc 	andi	r2,r2,255
 d043bac:	1005003a 	cmpeq	r2,r2,zero
 d043bb0:	1000051e 	bne	r2,zero,d043bc8 <igmpv2_process_report+0xac>
 d043bb4:	e0bffe17 	ldw	r2,-8(fp)
 d043bb8:	10800003 	ldbu	r2,0(r2)
 d043bbc:	10803fcc 	andi	r2,r2,255
 d043bc0:	108005a0 	cmpeqi	r2,r2,22
 d043bc4:	1000221e 	bne	r2,zero,d043c50 <igmpv2_process_report+0x134>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 d043bc8:	e0bffb17 	ldw	r2,-20(fp)
 d043bcc:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 d043bd0:	00834174 	movhi	r2,3333
 d043bd4:	108aa704 	addi	r2,r2,10908
 d043bd8:	10800017 	ldw	r2,0(r2)
 d043bdc:	10ffffc4 	addi	r3,r2,-1
 d043be0:	00834174 	movhi	r2,3333
 d043be4:	108aa704 	addi	r2,r2,10908
 d043be8:	10c00015 	stw	r3,0(r2)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 d043bec:	e0bffb17 	ldw	r2,-20(fp)
 d043bf0:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 d043bf4:	008341b4 	movhi	r2,3334
 d043bf8:	10b2a904 	addi	r2,r2,-13660
 d043bfc:	10800717 	ldw	r2,28(r2)
 d043c00:	10c00044 	addi	r3,r2,1
 d043c04:	008341b4 	movhi	r2,3334
 d043c08:	10b2a904 	addi	r2,r2,-13660
 d043c0c:	10c00715 	stw	r3,28(r2)
 d043c10:	00000f06 	br	d043c50 <igmpv2_process_report+0x134>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 d043c14:	008341b4 	movhi	r2,3334
 d043c18:	10b2a904 	addi	r2,r2,-13660
 d043c1c:	10800817 	ldw	r2,32(r2)
 d043c20:	10c00044 	addi	r3,r2,1
 d043c24:	008341b4 	movhi	r2,3334
 d043c28:	10b2a904 	addi	r2,r2,-13660
 d043c2c:	10c00815 	stw	r3,32(r2)
 d043c30:	00000706 	br	d043c50 <igmpv2_process_report+0x134>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 d043c34:	008341b4 	movhi	r2,3334
 d043c38:	10b2a904 	addi	r2,r2,-13660
 d043c3c:	10801317 	ldw	r2,76(r2)
 d043c40:	10c00044 	addi	r3,r2,1
 d043c44:	008341b4 	movhi	r2,3334
 d043c48:	10b2a904 	addi	r2,r2,-13660
 d043c4c:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 d043c50:	0005883a 	mov	r2,zero
}
 d043c54:	e037883a 	mov	sp,fp
 d043c58:	dfc00117 	ldw	ra,4(sp)
 d043c5c:	df000017 	ldw	fp,0(sp)
 d043c60:	dec00204 	addi	sp,sp,8
 d043c64:	f800283a 	ret

0d043c68 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 d043c68:	defff704 	addi	sp,sp,-36
 d043c6c:	dfc00815 	stw	ra,32(sp)
 d043c70:	df000715 	stw	fp,28(sp)
 d043c74:	df000704 	addi	fp,sp,28
 d043c78:	e13fff15 	stw	r4,-4(fp)
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;
   ip_addr mcgrp_addr;

   netp = p->net;
 d043c7c:	e0bfff17 	ldw	r2,-4(fp)
 d043c80:	10800617 	ldw	r2,24(r2)
 d043c84:	e0bffc15 	stw	r2,-16(fp)
   pip = ip_head (p);
 d043c88:	e0bfff17 	ldw	r2,-4(fp)
 d043c8c:	10800317 	ldw	r2,12(r2)
 d043c90:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 d043c94:	e0bffd17 	ldw	r2,-12(fp)
 d043c98:	10800003 	ldbu	r2,0(r2)
 d043c9c:	10803fcc 	andi	r2,r2,255
 d043ca0:	108003cc 	andi	r2,r2,15
 d043ca4:	1085883a 	add	r2,r2,r2
 d043ca8:	1085883a 	add	r2,r2,r2
 d043cac:	1007883a 	mov	r3,r2
 d043cb0:	e0bffd17 	ldw	r2,-12(fp)
 d043cb4:	1885883a 	add	r2,r3,r2
 d043cb8:	e0bffe15 	stw	r2,-8(fp)
   mcgrp_addr = ntohl(igmp->igmp_group);
 d043cbc:	e0bffe17 	ldw	r2,-8(fp)
 d043cc0:	10800117 	ldw	r2,4(r2)
 d043cc4:	1004d63a 	srli	r2,r2,24
 d043cc8:	10c03fcc 	andi	r3,r2,255
 d043ccc:	e0bffe17 	ldw	r2,-8(fp)
 d043cd0:	10800117 	ldw	r2,4(r2)
 d043cd4:	1004d23a 	srli	r2,r2,8
 d043cd8:	10bfc00c 	andi	r2,r2,65280
 d043cdc:	1886b03a 	or	r3,r3,r2
 d043ce0:	e0bffe17 	ldw	r2,-8(fp)
 d043ce4:	10800117 	ldw	r2,4(r2)
 d043ce8:	10bfc00c 	andi	r2,r2,65280
 d043cec:	1004923a 	slli	r2,r2,8
 d043cf0:	1886b03a 	or	r3,r3,r2
 d043cf4:	e0bffe17 	ldw	r2,-8(fp)
 d043cf8:	10800117 	ldw	r2,4(r2)
 d043cfc:	10803fcc 	andi	r2,r2,255
 d043d00:	1004963a 	slli	r2,r2,24
 d043d04:	1884b03a 	or	r2,r3,r2
 d043d08:	e0bff915 	stw	r2,-28(fp)

   if (igmp->igmp_code == 0)
 d043d0c:	e0bffe17 	ldw	r2,-8(fp)
 d043d10:	10800043 	ldbu	r2,1(r2)
 d043d14:	10803fcc 	andi	r2,r2,255
 d043d18:	1004c03a 	cmpne	r2,r2,zero
 d043d1c:	1000141e 	bne	r2,zero,d043d70 <igmpv2_process_query+0x108>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 d043d20:	e0fffc17 	ldw	r3,-16(fp)
 d043d24:	00800044 	movi	r2,1
 d043d28:	18802d05 	stb	r2,180(r3)
      netp->igmpv1_query_rcvd_time = cticks;      
 d043d2c:	00834174 	movhi	r2,3333
 d043d30:	108ac904 	addi	r2,r2,11044
 d043d34:	10c00017 	ldw	r3,0(r2)
 d043d38:	e0bffc17 	ldw	r2,-16(fp)
 d043d3c:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 d043d40:	008341b4 	movhi	r2,3334
 d043d44:	10b2a904 	addi	r2,r2,-13660
 d043d48:	10800417 	ldw	r2,16(r2)
 d043d4c:	10c00044 	addi	r3,r2,1
 d043d50:	008341b4 	movhi	r2,3334
 d043d54:	10b2a904 	addi	r2,r2,-13660
 d043d58:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 d043d5c:	00800c84 	movi	r2,50
 d043d60:	e0bffb8d 	sth	r2,-18(fp)
      process_all = IGMP_TRUE;
 d043d64:	00800044 	movi	r2,1
 d043d68:	e0bffb05 	stb	r2,-20(fp)
 d043d6c:	00001d06 	br	d043de4 <igmpv2_process_query+0x17c>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 d043d70:	e0bffe17 	ldw	r2,-8(fp)
 d043d74:	10800117 	ldw	r2,4(r2)
 d043d78:	1004c03a 	cmpne	r2,r2,zero
 d043d7c:	10000a1e 	bne	r2,zero,d043da8 <igmpv2_process_query+0x140>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 d043d80:	008341b4 	movhi	r2,3334
 d043d84:	10b2a904 	addi	r2,r2,-13660
 d043d88:	10800517 	ldw	r2,20(r2)
 d043d8c:	10c00044 	addi	r3,r2,1
 d043d90:	008341b4 	movhi	r2,3334
 d043d94:	10b2a904 	addi	r2,r2,-13660
 d043d98:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 d043d9c:	00800044 	movi	r2,1
 d043da0:	e0bffb05 	stb	r2,-20(fp)
 d043da4:	00000806 	br	d043dc8 <igmpv2_process_query+0x160>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 d043da8:	008341b4 	movhi	r2,3334
 d043dac:	10b2a904 	addi	r2,r2,-13660
 d043db0:	10800617 	ldw	r2,24(r2)
 d043db4:	10c00044 	addi	r3,r2,1
 d043db8:	008341b4 	movhi	r2,3334
 d043dbc:	10b2a904 	addi	r2,r2,-13660
 d043dc0:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 d043dc4:	e03ffb05 	stb	zero,-20(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 d043dc8:	e0bffe17 	ldw	r2,-8(fp)
 d043dcc:	10800043 	ldbu	r2,1(r2)
 d043dd0:	10c03fcc 	andi	r3,r2,255
 d043dd4:	1804d7fa 	srli	r2,r3,31
 d043dd8:	10c5883a 	add	r2,r2,r3
 d043ddc:	1005d07a 	srai	r2,r2,1
 d043de0:	e0bffb8d 	sth	r2,-18(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 d043de4:	e0bffb03 	ldbu	r2,-20(fp)
 d043de8:	1005003a 	cmpeq	r2,r2,zero
 d043dec:	1000181e 	bne	r2,zero,d043e50 <igmpv2_process_query+0x1e8>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 d043df0:	e0bffc17 	ldw	r2,-16(fp)
 d043df4:	10802c17 	ldw	r2,176(r2)
 d043df8:	e0bffa15 	stw	r2,-24(fp)
 d043dfc:	00001006 	br	d043e40 <igmpv2_process_query+0x1d8>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 d043e00:	e0bffa17 	ldw	r2,-24(fp)
 d043e04:	10800017 	ldw	r2,0(r2)
 d043e08:	1005003a 	cmpeq	r2,r2,zero
 d043e0c:	1000091e 	bne	r2,zero,d043e34 <igmpv2_process_query+0x1cc>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 d043e10:	e0bffa17 	ldw	r2,-24(fp)
 d043e14:	10c00017 	ldw	r3,0(r2)
 d043e18:	00834174 	movhi	r2,3333
 d043e1c:	108aa904 	addi	r2,r2,10916
 d043e20:	10800017 	ldw	r2,0(r2)
 d043e24:	18800326 	beq	r3,r2,d043e34 <igmpv2_process_query+0x1cc>
            igmpv2_chk_set_timer (inm, max_resp_time);
 d043e28:	e17ffb8b 	ldhu	r5,-18(fp)
 d043e2c:	e13ffa17 	ldw	r4,-24(fp)
 d043e30:	d043eb40 	call	d043eb4 <igmpv2_chk_set_timer>
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 d043e34:	e0bffa17 	ldw	r2,-24(fp)
 d043e38:	10800517 	ldw	r2,20(r2)
 d043e3c:	e0bffa15 	stw	r2,-24(fp)
 d043e40:	e0bffa17 	ldw	r2,-24(fp)
 d043e44:	1004c03a 	cmpne	r2,r2,zero
 d043e48:	103fed1e 	bne	r2,zero,d043e00 <igmpv2_process_query+0x198>
 d043e4c:	00001306 	br	d043e9c <igmpv2_process_query+0x234>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 d043e50:	e0bffe17 	ldw	r2,-8(fp)
 d043e54:	11000117 	ldw	r4,4(r2)
 d043e58:	e17ffc17 	ldw	r5,-16(fp)
 d043e5c:	d041afc0 	call	d041afc <lookup_mcast>
 d043e60:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL)
 d043e64:	e0bffa17 	ldw	r2,-24(fp)
 d043e68:	1005003a 	cmpeq	r2,r2,zero
 d043e6c:	1000041e 	bne	r2,zero,d043e80 <igmpv2_process_query+0x218>
         igmpv2_chk_set_timer (inm, max_resp_time);
 d043e70:	e17ffb8b 	ldhu	r5,-18(fp)
 d043e74:	e13ffa17 	ldw	r4,-24(fp)
 d043e78:	d043eb40 	call	d043eb4 <igmpv2_chk_set_timer>
 d043e7c:	00000706 	br	d043e9c <igmpv2_process_query+0x234>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 d043e80:	008341b4 	movhi	r2,3334
 d043e84:	10b2a904 	addi	r2,r2,-13660
 d043e88:	10801217 	ldw	r2,72(r2)
 d043e8c:	10c00044 	addi	r3,r2,1
 d043e90:	008341b4 	movhi	r2,3334
 d043e94:	10b2a904 	addi	r2,r2,-13660
 d043e98:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 d043e9c:	0005883a 	mov	r2,zero
}
 d043ea0:	e037883a 	mov	sp,fp
 d043ea4:	dfc00117 	ldw	ra,4(sp)
 d043ea8:	df000017 	ldw	fp,0(sp)
 d043eac:	dec00204 	addi	sp,sp,8
 d043eb0:	f800283a 	ret

0d043eb4 <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 d043eb4:	defffd04 	addi	sp,sp,-12
 d043eb8:	df000215 	stw	fp,8(sp)
 d043ebc:	df000204 	addi	fp,sp,8
 d043ec0:	e13ffe15 	stw	r4,-8(fp)
 d043ec4:	e17fff0d 	sth	r5,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 d043ec8:	e0bffe17 	ldw	r2,-8(fp)
 d043ecc:	10c00317 	ldw	r3,12(r2)
 d043ed0:	e0bfff0b 	ldhu	r2,-4(fp)
 d043ed4:	10c00436 	bltu	r2,r3,d043ee8 <igmpv2_chk_set_timer+0x34>
 d043ed8:	e0bffe17 	ldw	r2,-8(fp)
 d043edc:	10800317 	ldw	r2,12(r2)
 d043ee0:	1004c03a 	cmpne	r2,r2,zero
 d043ee4:	1000451e 	bne	r2,zero,d043ffc <igmpv2_chk_set_timer+0x148>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 d043ee8:	e0bffe17 	ldw	r2,-8(fp)
 d043eec:	10800317 	ldw	r2,12(r2)
 d043ef0:	1004c03a 	cmpne	r2,r2,zero
 d043ef4:	1000071e 	bne	r2,zero,d043f14 <igmpv2_chk_set_timer+0x60>
 d043ef8:	00834174 	movhi	r2,3333
 d043efc:	108aa704 	addi	r2,r2,10908
 d043f00:	10800017 	ldw	r2,0(r2)
 d043f04:	10c00044 	addi	r3,r2,1
 d043f08:	00834174 	movhi	r2,3333
 d043f0c:	108aa704 	addi	r2,r2,10908
 d043f10:	10c00015 	stw	r3,0(r2)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 d043f14:	008341b4 	movhi	r2,3334
 d043f18:	10b4eb04 	addi	r2,r2,-11348
 d043f1c:	11000217 	ldw	r4,8(r2)
 d043f20:	008341b4 	movhi	r2,3334
 d043f24:	10b2a504 	addi	r2,r2,-13676
 d043f28:	10800017 	ldw	r2,0(r2)
 d043f2c:	10800a17 	ldw	r2,40(r2)
 d043f30:	1004d63a 	srli	r2,r2,24
 d043f34:	10c03fcc 	andi	r3,r2,255
 d043f38:	008341b4 	movhi	r2,3334
 d043f3c:	10b2a504 	addi	r2,r2,-13676
 d043f40:	10800017 	ldw	r2,0(r2)
 d043f44:	10800a17 	ldw	r2,40(r2)
 d043f48:	1004d23a 	srli	r2,r2,8
 d043f4c:	10bfc00c 	andi	r2,r2,65280
 d043f50:	1886b03a 	or	r3,r3,r2
 d043f54:	008341b4 	movhi	r2,3334
 d043f58:	10b2a504 	addi	r2,r2,-13676
 d043f5c:	10800017 	ldw	r2,0(r2)
 d043f60:	10800a17 	ldw	r2,40(r2)
 d043f64:	10bfc00c 	andi	r2,r2,65280
 d043f68:	1004923a 	slli	r2,r2,8
 d043f6c:	1886b03a 	or	r3,r3,r2
 d043f70:	008341b4 	movhi	r2,3334
 d043f74:	10b2a504 	addi	r2,r2,-13676
 d043f78:	10800017 	ldw	r2,0(r2)
 d043f7c:	10800a17 	ldw	r2,40(r2)
 d043f80:	10803fcc 	andi	r2,r2,255
 d043f84:	1004963a 	slli	r2,r2,24
 d043f88:	1884b03a 	or	r2,r3,r2
 d043f8c:	2089883a 	add	r4,r4,r2
 d043f90:	e0bffe17 	ldw	r2,-8(fp)
 d043f94:	10800017 	ldw	r2,0(r2)
 d043f98:	1004d63a 	srli	r2,r2,24
 d043f9c:	10c03fcc 	andi	r3,r2,255
 d043fa0:	e0bffe17 	ldw	r2,-8(fp)
 d043fa4:	10800017 	ldw	r2,0(r2)
 d043fa8:	1004d23a 	srli	r2,r2,8
 d043fac:	10bfc00c 	andi	r2,r2,65280
 d043fb0:	1886b03a 	or	r3,r3,r2
 d043fb4:	e0bffe17 	ldw	r2,-8(fp)
 d043fb8:	10800017 	ldw	r2,0(r2)
 d043fbc:	10bfc00c 	andi	r2,r2,65280
 d043fc0:	1004923a 	slli	r2,r2,8
 d043fc4:	1886b03a 	or	r3,r3,r2
 d043fc8:	e0bffe17 	ldw	r2,-8(fp)
 d043fcc:	10800017 	ldw	r2,0(r2)
 d043fd0:	10803fcc 	andi	r2,r2,255
 d043fd4:	1004963a 	slli	r2,r2,24
 d043fd8:	1884b03a 	or	r2,r3,r2
 d043fdc:	2089883a 	add	r4,r4,r2
 d043fe0:	e0ffff0b 	ldhu	r3,-4(fp)
 d043fe4:	20c5203a 	divu	r2,r4,r3
 d043fe8:	10c5383a 	mul	r2,r2,r3
 d043fec:	2085c83a 	sub	r2,r4,r2
 d043ff0:	10c00044 	addi	r3,r2,1
 d043ff4:	e0bffe17 	ldw	r2,-8(fp)
 d043ff8:	10c00315 	stw	r3,12(r2)
   }

   return;
}
 d043ffc:	e037883a 	mov	sp,fp
 d044000:	df000017 	ldw	fp,0(sp)
 d044004:	dec00104 	addi	sp,sp,4
 d044008:	f800283a 	ret

0d04400c <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 d04400c:	defff904 	addi	sp,sp,-28
 d044010:	df000615 	stw	fp,24(sp)
 d044014:	df000604 	addi	fp,sp,24
 d044018:	e13ffd15 	stw	r4,-12(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 d04401c:	e0bffd17 	ldw	r2,-12(fp)
 d044020:	10800003 	ldbu	r2,0(r2)
 d044024:	108003cc 	andi	r2,r2,15
 d044028:	1085883a 	add	r2,r2,r2
 d04402c:	1085883a 	add	r2,r2,r2
 d044030:	10bffb04 	addi	r2,r2,-20
 d044034:	e0bffa85 	stb	r2,-22(fp)

   if (total_optlen > 0)
 d044038:	e0bffa83 	ldbu	r2,-22(fp)
 d04403c:	1005003a 	cmpeq	r2,r2,zero
 d044040:	1000481e 	bne	r2,zero,d044164 <igmpv2_chk4_rtr_alert_opt+0x158>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 d044044:	e0bffd17 	ldw	r2,-12(fp)
 d044048:	10800504 	addi	r2,r2,20
 d04404c:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 d044050:	00004106 	br	d044158 <igmpv2_chk4_rtr_alert_opt+0x14c>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 d044054:	e0bffc17 	ldw	r2,-16(fp)
 d044058:	10800003 	ldbu	r2,0(r2)
 d04405c:	108007cc 	andi	r2,r2,31
 d044060:	e0bffa05 	stb	r2,-24(fp)
         switch (optval)
 d044064:	e0bffa03 	ldbu	r2,-24(fp)
 d044068:	e0bfff15 	stw	r2,-4(fp)
 d04406c:	e0ffff17 	ldw	r3,-4(fp)
 d044070:	18800060 	cmpeqi	r2,r3,1
 d044074:	10000b1e 	bne	r2,zero,d0440a4 <igmpv2_chk4_rtr_alert_opt+0x98>
 d044078:	e0ffff17 	ldw	r3,-4(fp)
 d04407c:	18800520 	cmpeqi	r2,r3,20
 d044080:	10000b1e 	bne	r2,zero,d0440b0 <igmpv2_chk4_rtr_alert_opt+0xa4>
 d044084:	e0ffff17 	ldw	r3,-4(fp)
 d044088:	1805003a 	cmpeq	r2,r3,zero
 d04408c:	1000011e 	bne	r2,zero,d044094 <igmpv2_chk4_rtr_alert_opt+0x88>
 d044090:	00002306 	br	d044120 <igmpv2_chk4_rtr_alert_opt+0x114>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 d044094:	00800044 	movi	r2,1
 d044098:	e0bffa45 	stb	r2,-23(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 d04409c:	e03ffe15 	stw	zero,-8(fp)
 d0440a0:	00003106 	br	d044168 <igmpv2_chk4_rtr_alert_opt+0x15c>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 d0440a4:	00800044 	movi	r2,1
 d0440a8:	e0bffa45 	stb	r2,-23(fp)
               break;
 d0440ac:	00002106 	br	d044134 <igmpv2_chk4_rtr_alert_opt+0x128>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 d0440b0:	e0bffc17 	ldw	r2,-16(fp)
 d0440b4:	e0bffb15 	stw	r2,-20(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 d0440b8:	e0bffb17 	ldw	r2,-20(fp)
 d0440bc:	10800017 	ldw	r2,0(r2)
 d0440c0:	1004d63a 	srli	r2,r2,24
 d0440c4:	10c03fcc 	andi	r3,r2,255
 d0440c8:	e0bffb17 	ldw	r2,-20(fp)
 d0440cc:	10800017 	ldw	r2,0(r2)
 d0440d0:	1004d23a 	srli	r2,r2,8
 d0440d4:	10bfc00c 	andi	r2,r2,65280
 d0440d8:	1886b03a 	or	r3,r3,r2
 d0440dc:	e0bffb17 	ldw	r2,-20(fp)
 d0440e0:	10800017 	ldw	r2,0(r2)
 d0440e4:	10bfc00c 	andi	r2,r2,65280
 d0440e8:	1004923a 	slli	r2,r2,8
 d0440ec:	1886b03a 	or	r3,r3,r2
 d0440f0:	e0bffb17 	ldw	r2,-20(fp)
 d0440f4:	10800017 	ldw	r2,0(r2)
 d0440f8:	10803fcc 	andi	r2,r2,255
 d0440fc:	1004963a 	slli	r2,r2,24
 d044100:	1886b03a 	or	r3,r3,r2
 d044104:	00a50134 	movhi	r2,37892
 d044108:	1880031e 	bne	r3,r2,d044118 <igmpv2_chk4_rtr_alert_opt+0x10c>
                  /* found the option, return success */
                  return IGMP_TRUE;
 d04410c:	00800044 	movi	r2,1
 d044110:	e0bffe15 	stw	r2,-8(fp)
 d044114:	00001406 	br	d044168 <igmpv2_chk4_rtr_alert_opt+0x15c>
               else return IGMP_FALSE;
 d044118:	e03ffe15 	stw	zero,-8(fp)
 d04411c:	00001206 	br	d044168 <igmpv2_chk4_rtr_alert_opt+0x15c>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 d044120:	e0bffc17 	ldw	r2,-16(fp)
 d044124:	10800044 	addi	r2,r2,1
 d044128:	10800003 	ldbu	r2,0(r2)
 d04412c:	10800084 	addi	r2,r2,2
 d044130:	e0bffa45 	stb	r2,-23(fp)
               break;
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 d044134:	e0bffa43 	ldbu	r2,-23(fp)
 d044138:	1007883a 	mov	r3,r2
 d04413c:	e0bffc17 	ldw	r2,-16(fp)
 d044140:	10c5883a 	add	r2,r2,r3
 d044144:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 d044148:	e0fffa83 	ldbu	r3,-22(fp)
 d04414c:	e0bffa43 	ldbu	r2,-23(fp)
 d044150:	1885c83a 	sub	r2,r3,r2
 d044154:	e0bffa85 	stb	r2,-22(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 d044158:	e0bffa83 	ldbu	r2,-22(fp)
 d04415c:	1004c03a 	cmpne	r2,r2,zero
 d044160:	103fbc1e 	bne	r2,zero,d044054 <igmpv2_chk4_rtr_alert_opt+0x48>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 d044164:	e03ffe15 	stw	zero,-8(fp)
 d044168:	e0bffe17 	ldw	r2,-8(fp)
}
 d04416c:	e037883a 	mov	sp,fp
 d044170:	df000017 	ldw	fp,0(sp)
 d044174:	dec00104 	addi	sp,sp,4
 d044178:	f800283a 	ret

0d04417c <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 d04417c:	defffc04 	addi	sp,sp,-16
 d044180:	df000315 	stw	fp,12(sp)
 d044184:	df000304 	addi	fp,sp,12
 d044188:	e13ffe15 	stw	r4,-8(fp)
 d04418c:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 d044190:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 d044194:	e0bffd0b 	ldhu	r2,-12(fp)
 d044198:	00c341b4 	movhi	r3,3334
 d04419c:	18f2a504 	addi	r3,r3,-13676
 d0441a0:	1085883a 	add	r2,r2,r2
 d0441a4:	1085883a 	add	r2,r2,r2
 d0441a8:	10c5883a 	add	r2,r2,r3
 d0441ac:	10c00017 	ldw	r3,0(r2)
 d0441b0:	e0bfff17 	ldw	r2,-4(fp)
 d0441b4:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 d0441b8:	e0bffe17 	ldw	r2,-8(fp)
 d0441bc:	1004c03a 	cmpne	r2,r2,zero
 d0441c0:	1000331e 	bne	r2,zero,d044290 <IPADDR_TO_NETP+0x114>
   {
      for (idx = 0; idx < ifNumber; idx++)
 d0441c4:	e03ffd0d 	sth	zero,-12(fp)
 d0441c8:	00001706 	br	d044228 <IPADDR_TO_NETP+0xac>
      {
         if (nets[idx]->n_mcastlist)
 d0441cc:	e0bffd0b 	ldhu	r2,-12(fp)
 d0441d0:	00c341b4 	movhi	r3,3334
 d0441d4:	18f2a504 	addi	r3,r3,-13676
 d0441d8:	1085883a 	add	r2,r2,r2
 d0441dc:	1085883a 	add	r2,r2,r2
 d0441e0:	10c5883a 	add	r2,r2,r3
 d0441e4:	10800017 	ldw	r2,0(r2)
 d0441e8:	10802b17 	ldw	r2,172(r2)
 d0441ec:	1005003a 	cmpeq	r2,r2,zero
 d0441f0:	10000a1e 	bne	r2,zero,d04421c <IPADDR_TO_NETP+0xa0>
         {
            *netp = nets[idx];
 d0441f4:	e0bffd0b 	ldhu	r2,-12(fp)
 d0441f8:	00c341b4 	movhi	r3,3334
 d0441fc:	18f2a504 	addi	r3,r3,-13676
 d044200:	1085883a 	add	r2,r2,r2
 d044204:	1085883a 	add	r2,r2,r2
 d044208:	10c5883a 	add	r2,r2,r3
 d04420c:	10c00017 	ldw	r3,0(r2)
 d044210:	e0bfff17 	ldw	r2,-4(fp)
 d044214:	10c00015 	stw	r3,0(r2)
            break;
 d044218:	00002606 	br	d0442b4 <IPADDR_TO_NETP+0x138>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 d04421c:	e0bffd0b 	ldhu	r2,-12(fp)
 d044220:	10800044 	addi	r2,r2,1
 d044224:	e0bffd0d 	sth	r2,-12(fp)
 d044228:	e0bffd0b 	ldhu	r2,-12(fp)
 d04422c:	00c34174 	movhi	r3,3333
 d044230:	18caa504 	addi	r3,r3,10900
 d044234:	18c00017 	ldw	r3,0(r3)
 d044238:	10ffe436 	bltu	r2,r3,d0441cc <IPADDR_TO_NETP+0x50>
 d04423c:	00001d06 	br	d0442b4 <IPADDR_TO_NETP+0x138>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 d044240:	e0bffd0b 	ldhu	r2,-12(fp)
 d044244:	10800044 	addi	r2,r2,1
 d044248:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 d04424c:	e0fffd0b 	ldhu	r3,-12(fp)
 d044250:	00834174 	movhi	r2,3333
 d044254:	108aa504 	addi	r2,r2,10900
 d044258:	10800017 	ldw	r2,0(r2)
 d04425c:	18800336 	bltu	r3,r2,d04426c <IPADDR_TO_NETP+0xf0>
         {
            *netp = NULL;
 d044260:	e0bfff17 	ldw	r2,-4(fp)
 d044264:	10000015 	stw	zero,0(r2)
            break;
 d044268:	00001206 	br	d0442b4 <IPADDR_TO_NETP+0x138>
         }
         else
            *netp = nets[idx];
 d04426c:	e0bffd0b 	ldhu	r2,-12(fp)
 d044270:	00c341b4 	movhi	r3,3334
 d044274:	18f2a504 	addi	r3,r3,-13676
 d044278:	1085883a 	add	r2,r2,r2
 d04427c:	1085883a 	add	r2,r2,r2
 d044280:	10c5883a 	add	r2,r2,r3
 d044284:	10c00017 	ldw	r3,0(r2)
 d044288:	e0bfff17 	ldw	r2,-4(fp)
 d04428c:	10c00015 	stw	r3,0(r2)
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 d044290:	e0bfff17 	ldw	r2,-4(fp)
 d044294:	10800017 	ldw	r2,0(r2)
 d044298:	1005003a 	cmpeq	r2,r2,zero
 d04429c:	1000051e 	bne	r2,zero,d0442b4 <IPADDR_TO_NETP+0x138>
 d0442a0:	e0bfff17 	ldw	r2,-4(fp)
 d0442a4:	10800017 	ldw	r2,0(r2)
 d0442a8:	10c00a17 	ldw	r3,40(r2)
 d0442ac:	e0bffe17 	ldw	r2,-8(fp)
 d0442b0:	18bfe31e 	bne	r3,r2,d044240 <IPADDR_TO_NETP+0xc4>
         }
         else
            *netp = nets[idx];
      }
   }
}
 d0442b4:	e037883a 	mov	sp,fp
 d0442b8:	df000017 	ldw	fp,0(sp)
 d0442bc:	dec00104 	addi	sp,sp,4
 d0442c0:	f800283a 	ret

0d0442c4 <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 d0442c4:	defff104 	addi	sp,sp,-60
 d0442c8:	dfc00e15 	stw	ra,56(sp)
 d0442cc:	df000d15 	stw	fp,52(sp)
 d0442d0:	dc000c15 	stw	r16,48(sp)
 d0442d4:	df000c04 	addi	fp,sp,48
 d0442d8:	e13ffb15 	stw	r4,-20(fp)
 d0442dc:	e17ffc15 	stw	r5,-16(fp)
 d0442e0:	e1bffd15 	stw	r6,-12(fp)
   int   error =  0;
 d0442e4:	e03ff915 	stw	zero,-28(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 d0442e8:	e03ffa15 	stw	zero,-24(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 d0442ec:	e0bffc17 	ldw	r2,-16(fp)
 d0442f0:	10800317 	ldw	r2,12(r2)
 d0442f4:	e0bff615 	stw	r2,-40(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 d0442f8:	e0bffc17 	ldw	r2,-16(fp)
 d0442fc:	10800304 	addi	r2,r2,12
 d044300:	e0bff515 	stw	r2,-44(fp)
   ip_addr addr;


   if (imo == NULL) 
 d044304:	e0bff617 	ldw	r2,-40(fp)
 d044308:	1004c03a 	cmpne	r2,r2,zero
 d04430c:	1000161e 	bne	r2,zero,d044368 <ip_setmoptions+0xa4>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 d044310:	01001604 	movi	r4,88
 d044314:	d029e2c0 	call	d029e2c <npalloc>
 d044318:	e0bff615 	stw	r2,-40(fp)

      if (imo == NULL)
 d04431c:	e0bff617 	ldw	r2,-40(fp)
 d044320:	1004c03a 	cmpne	r2,r2,zero
 d044324:	1000031e 	bne	r2,zero,d044334 <ip_setmoptions+0x70>
         return (ENOBUFS);
 d044328:	00801a44 	movi	r2,105
 d04432c:	e0bffe15 	stw	r2,-8(fp)
 d044330:	00015906 	br	d044898 <ip_setmoptions+0x5d4>
      *imop = imo;
 d044334:	e0fff517 	ldw	r3,-44(fp)
 d044338:	e0bff617 	ldw	r2,-40(fp)
 d04433c:	18800015 	stw	r2,0(r3)
      imo->imo_multicast_netp = NULL;
 d044340:	e0bff617 	ldw	r2,-40(fp)
 d044344:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 d044348:	e0fff617 	ldw	r3,-40(fp)
 d04434c:	00800044 	movi	r2,1
 d044350:	18800105 	stb	r2,4(r3)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 d044354:	e0fff617 	ldw	r3,-40(fp)
 d044358:	00800044 	movi	r2,1
 d04435c:	18800145 	stb	r2,5(r3)
      imo->imo_num_memberships = 0;
 d044360:	e0bff617 	ldw	r2,-40(fp)
 d044364:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 d044368:	e0bffb17 	ldw	r2,-20(fp)
 d04436c:	10bffdc4 	addi	r2,r2,-9
 d044370:	e0bfff15 	stw	r2,-4(fp)
 d044374:	e0ffff17 	ldw	r3,-4(fp)
 d044378:	18800168 	cmpgeui	r2,r3,5
 d04437c:	10012a1e 	bne	r2,zero,d044828 <ip_setmoptions+0x564>
 d044380:	e13fff17 	ldw	r4,-4(fp)
 d044384:	e13fff17 	ldw	r4,-4(fp)
 d044388:	2105883a 	add	r2,r4,r4
 d04438c:	1087883a 	add	r3,r2,r2
 d044390:	00834134 	movhi	r2,3332
 d044394:	1090e904 	addi	r2,r2,17316
 d044398:	1885883a 	add	r2,r3,r2
 d04439c:	10800017 	ldw	r2,0(r2)
 d0443a0:	1000683a 	jmp	r2
 d0443a4:	0d0443b8 	rdprs	r20,at,4366
 d0443a8:	0d04442c 	andhi	r20,at,4368
 d0443ac:	0d044440 	call	d04444 <OSCtxSw_SWITCH_PC+0xd04404>
 d0443b0:	0d044474 	orhi	r20,at,4369
 d0443b4:	0d044644 	addi	r20,at,4377

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 d0443b8:	e0bffd17 	ldw	r2,-12(fp)
 d0443bc:	10800017 	ldw	r2,0(r2)
 d0443c0:	e0bff415 	stw	r2,-48(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 d0443c4:	e0bff417 	ldw	r2,-48(fp)
 d0443c8:	1004c03a 	cmpne	r2,r2,zero
 d0443cc:	1000031e 	bne	r2,zero,d0443dc <ip_setmoptions+0x118>
      {
         imo->imo_multicast_netp = NULL;
 d0443d0:	e0bff617 	ldw	r2,-40(fp)
 d0443d4:	10000015 	stw	zero,0(r2)
         break;
 d0443d8:	00011506 	br	d044830 <ip_setmoptions+0x56c>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 d0443dc:	e17ffa04 	addi	r5,fp,-24
 d0443e0:	e13ff417 	ldw	r4,-48(fp)
 d0443e4:	d04417c0 	call	d04417c <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 d0443e8:	e0bffa17 	ldw	r2,-24(fp)
 d0443ec:	1005003a 	cmpeq	r2,r2,zero
 d0443f0:	1000041e 	bne	r2,zero,d044404 <ip_setmoptions+0x140>
 d0443f4:	e0bffa17 	ldw	r2,-24(fp)
 d0443f8:	10802b17 	ldw	r2,172(r2)
 d0443fc:	1004c03a 	cmpne	r2,r2,zero
 d044400:	1000031e 	bne	r2,zero,d044410 <ip_setmoptions+0x14c>
      {
         error = EADDRNOTAVAIL;
 d044404:	00801f44 	movi	r2,125
 d044408:	e0bff915 	stw	r2,-28(fp)
         break;
 d04440c:	00010806 	br	d044830 <ip_setmoptions+0x56c>
      }
      if (addr != AADDR) 
 d044410:	e0bff417 	ldw	r2,-48(fp)
 d044414:	1005003a 	cmpeq	r2,r2,zero
 d044418:	1001051e 	bne	r2,zero,d044830 <ip_setmoptions+0x56c>
         imo->imo_multicast_netp = netp;
 d04441c:	e0fffa17 	ldw	r3,-24(fp)
 d044420:	e0bff617 	ldw	r2,-40(fp)
 d044424:	10c00015 	stw	r3,0(r2)
      break;
 d044428:	00010106 	br	d044830 <ip_setmoptions+0x56c>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 d04442c:	e0bffd17 	ldw	r2,-12(fp)
 d044430:	10c00003 	ldbu	r3,0(r2)
 d044434:	e0bff617 	ldw	r2,-40(fp)
 d044438:	10c00105 	stb	r3,4(r2)
      break;
 d04443c:	0000fc06 	br	d044830 <ip_setmoptions+0x56c>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 d044440:	e0bffd17 	ldw	r2,-12(fp)
 d044444:	10800003 	ldbu	r2,0(r2)
 d044448:	10803fcc 	andi	r2,r2,255
 d04444c:	108000b0 	cmpltui	r2,r2,2
 d044450:	1000031e 	bne	r2,zero,d044460 <ip_setmoptions+0x19c>
      {
         error = EINVAL;
 d044454:	00800584 	movi	r2,22
 d044458:	e0bff915 	stw	r2,-28(fp)
         break;
 d04445c:	0000f406 	br	d044830 <ip_setmoptions+0x56c>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 d044460:	e0bffd17 	ldw	r2,-12(fp)
 d044464:	10c00003 	ldbu	r3,0(r2)
 d044468:	e0bff617 	ldw	r2,-40(fp)
 d04446c:	10c00145 	stb	r3,5(r2)
      break;
 d044470:	0000ef06 	br	d044830 <ip_setmoptions+0x56c>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 d044474:	e0bffd17 	ldw	r2,-12(fp)
 d044478:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 d04447c:	e0bff717 	ldw	r2,-36(fp)
 d044480:	10800017 	ldw	r2,0(r2)
 d044484:	1004d63a 	srli	r2,r2,24
 d044488:	10c03fcc 	andi	r3,r2,255
 d04448c:	e0bff717 	ldw	r2,-36(fp)
 d044490:	10800017 	ldw	r2,0(r2)
 d044494:	1004d23a 	srli	r2,r2,8
 d044498:	10bfc00c 	andi	r2,r2,65280
 d04449c:	1886b03a 	or	r3,r3,r2
 d0444a0:	e0bff717 	ldw	r2,-36(fp)
 d0444a4:	10800017 	ldw	r2,0(r2)
 d0444a8:	10bfc00c 	andi	r2,r2,65280
 d0444ac:	1004923a 	slli	r2,r2,8
 d0444b0:	1886b03a 	or	r3,r3,r2
 d0444b4:	e0bff717 	ldw	r2,-36(fp)
 d0444b8:	10800017 	ldw	r2,0(r2)
 d0444bc:	10803fcc 	andi	r2,r2,255
 d0444c0:	1004963a 	slli	r2,r2,24
 d0444c4:	1884b03a 	or	r2,r3,r2
 d0444c8:	10fc002c 	andhi	r3,r2,61440
 d0444cc:	00b80034 	movhi	r2,57344
 d0444d0:	18800326 	beq	r3,r2,d0444e0 <ip_setmoptions+0x21c>
      {
         error = EINVAL;
 d0444d4:	00800584 	movi	r2,22
 d0444d8:	e0bff915 	stw	r2,-28(fp)
         break;
 d0444dc:	0000d406 	br	d044830 <ip_setmoptions+0x56c>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 d0444e0:	e0bff717 	ldw	r2,-36(fp)
 d0444e4:	11000117 	ldw	r4,4(r2)
 d0444e8:	e17ffa04 	addi	r5,fp,-24
 d0444ec:	d04417c0 	call	d04417c <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 d0444f0:	e0bffa17 	ldw	r2,-24(fp)
 d0444f4:	1005003a 	cmpeq	r2,r2,zero
 d0444f8:	1000041e 	bne	r2,zero,d04450c <ip_setmoptions+0x248>
 d0444fc:	e0bffa17 	ldw	r2,-24(fp)
 d044500:	10802b17 	ldw	r2,172(r2)
 d044504:	1004c03a 	cmpne	r2,r2,zero
 d044508:	1000031e 	bne	r2,zero,d044518 <ip_setmoptions+0x254>
      {
         error = EADDRNOTAVAIL;
 d04450c:	00801f44 	movi	r2,125
 d044510:	e0bff915 	stw	r2,-28(fp)
         break;
 d044514:	0000c606 	br	d044830 <ip_setmoptions+0x56c>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 d044518:	e03ff80d 	sth	zero,-32(fp)
 d04451c:	00001806 	br	d044580 <ip_setmoptions+0x2bc>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 d044520:	e0bff80b 	ldhu	r2,-32(fp)
 d044524:	e0fff617 	ldw	r3,-40(fp)
 d044528:	1085883a 	add	r2,r2,r2
 d04452c:	1085883a 	add	r2,r2,r2
 d044530:	10c5883a 	add	r2,r2,r3
 d044534:	10800204 	addi	r2,r2,8
 d044538:	10800017 	ldw	r2,0(r2)
 d04453c:	10c00117 	ldw	r3,4(r2)
 d044540:	e0bffa17 	ldw	r2,-24(fp)
 d044544:	18800b1e 	bne	r3,r2,d044574 <ip_setmoptions+0x2b0>
 d044548:	e0bff80b 	ldhu	r2,-32(fp)
 d04454c:	e0fff617 	ldw	r3,-40(fp)
 d044550:	1085883a 	add	r2,r2,r2
 d044554:	1085883a 	add	r2,r2,r2
 d044558:	10c5883a 	add	r2,r2,r3
 d04455c:	10800204 	addi	r2,r2,8
 d044560:	10800017 	ldw	r2,0(r2)
 d044564:	10c00017 	ldw	r3,0(r2)
 d044568:	e0bff717 	ldw	r2,-36(fp)
 d04456c:	10800017 	ldw	r2,0(r2)
 d044570:	18800826 	beq	r3,r2,d044594 <ip_setmoptions+0x2d0>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 d044574:	e0bff80b 	ldhu	r2,-32(fp)
 d044578:	10800044 	addi	r2,r2,1
 d04457c:	e0bff80d 	sth	r2,-32(fp)
 d044580:	e0bff617 	ldw	r2,-40(fp)
 d044584:	1080018b 	ldhu	r2,6(r2)
 d044588:	10ffffcc 	andi	r3,r2,65535
 d04458c:	e0bff80b 	ldhu	r2,-32(fp)
 d044590:	10ffe336 	bltu	r2,r3,d044520 <ip_setmoptions+0x25c>
             == mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i < imo->imo_num_memberships) 
 d044594:	e0bff617 	ldw	r2,-40(fp)
 d044598:	1080018b 	ldhu	r2,6(r2)
 d04459c:	10ffffcc 	andi	r3,r2,65535
 d0445a0:	e0bff80b 	ldhu	r2,-32(fp)
 d0445a4:	10c0032e 	bgeu	r2,r3,d0445b4 <ip_setmoptions+0x2f0>
      {
         error = EADDRINUSE;
 d0445a8:	00801c04 	movi	r2,112
 d0445ac:	e0bff915 	stw	r2,-28(fp)
         break;
 d0445b0:	00009f06 	br	d044830 <ip_setmoptions+0x56c>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 d0445b4:	e0bff80b 	ldhu	r2,-32(fp)
 d0445b8:	10800518 	cmpnei	r2,r2,20
 d0445bc:	1000031e 	bne	r2,zero,d0445cc <ip_setmoptions+0x308>
      {
         error = ETOOMANYREFS;
 d0445c0:	00802044 	movi	r2,129
 d0445c4:	e0bff915 	stw	r2,-28(fp)
         break;
 d0445c8:	00009906 	br	d044830 <ip_setmoptions+0x56c>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 d0445cc:	e43ff80b 	ldhu	r16,-32(fp)
 d0445d0:	e13ff717 	ldw	r4,-36(fp)
 d0445d4:	e17ffa17 	ldw	r5,-24(fp)
 d0445d8:	01800104 	movi	r6,4
 d0445dc:	d04187c0 	call	d04187c <in_addmulti>
 d0445e0:	1009883a 	mov	r4,r2
 d0445e4:	e0fff617 	ldw	r3,-40(fp)
 d0445e8:	8405883a 	add	r2,r16,r16
 d0445ec:	1085883a 	add	r2,r2,r2
 d0445f0:	10c5883a 	add	r2,r2,r3
 d0445f4:	10800204 	addi	r2,r2,8
 d0445f8:	11000015 	stw	r4,0(r2)
 d0445fc:	e0fff617 	ldw	r3,-40(fp)
 d044600:	8405883a 	add	r2,r16,r16
 d044604:	1085883a 	add	r2,r2,r2
 d044608:	10c5883a 	add	r2,r2,r3
 d04460c:	10800204 	addi	r2,r2,8
 d044610:	10800017 	ldw	r2,0(r2)
 d044614:	1004c03a 	cmpne	r2,r2,zero
 d044618:	1000031e 	bne	r2,zero,d044628 <ip_setmoptions+0x364>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 d04461c:	00801a44 	movi	r2,105
 d044620:	e0bff915 	stw	r2,-28(fp)
         break;
 d044624:	00008206 	br	d044830 <ip_setmoptions+0x56c>
      }
      ++imo->imo_num_memberships;
 d044628:	e0bff617 	ldw	r2,-40(fp)
 d04462c:	1080018b 	ldhu	r2,6(r2)
 d044630:	10800044 	addi	r2,r2,1
 d044634:	1007883a 	mov	r3,r2
 d044638:	e0bff617 	ldw	r2,-40(fp)
 d04463c:	10c0018d 	sth	r3,6(r2)
      break;
 d044640:	00007b06 	br	d044830 <ip_setmoptions+0x56c>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 d044644:	e0bffd17 	ldw	r2,-12(fp)
 d044648:	e0bff715 	stw	r2,-36(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 d04464c:	e0bff717 	ldw	r2,-36(fp)
 d044650:	10800017 	ldw	r2,0(r2)
 d044654:	1004d63a 	srli	r2,r2,24
 d044658:	10c03fcc 	andi	r3,r2,255
 d04465c:	e0bff717 	ldw	r2,-36(fp)
 d044660:	10800017 	ldw	r2,0(r2)
 d044664:	1004d23a 	srli	r2,r2,8
 d044668:	10bfc00c 	andi	r2,r2,65280
 d04466c:	1886b03a 	or	r3,r3,r2
 d044670:	e0bff717 	ldw	r2,-36(fp)
 d044674:	10800017 	ldw	r2,0(r2)
 d044678:	10bfc00c 	andi	r2,r2,65280
 d04467c:	1004923a 	slli	r2,r2,8
 d044680:	1886b03a 	or	r3,r3,r2
 d044684:	e0bff717 	ldw	r2,-36(fp)
 d044688:	10800017 	ldw	r2,0(r2)
 d04468c:	10803fcc 	andi	r2,r2,255
 d044690:	1004963a 	slli	r2,r2,24
 d044694:	1884b03a 	or	r2,r3,r2
 d044698:	10fc002c 	andhi	r3,r2,61440
 d04469c:	00b80034 	movhi	r2,57344
 d0446a0:	18800326 	beq	r3,r2,d0446b0 <ip_setmoptions+0x3ec>
      {
         error = EINVAL;
 d0446a4:	00800584 	movi	r2,22
 d0446a8:	e0bff915 	stw	r2,-28(fp)
         break;
 d0446ac:	00006006 	br	d044830 <ip_setmoptions+0x56c>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 d0446b0:	e0bff717 	ldw	r2,-36(fp)
 d0446b4:	11000117 	ldw	r4,4(r2)
 d0446b8:	e17ffa04 	addi	r5,fp,-24
 d0446bc:	d04417c0 	call	d04417c <IPADDR_TO_NETP>
      if (netp == NULL) 
 d0446c0:	e0bffa17 	ldw	r2,-24(fp)
 d0446c4:	1004c03a 	cmpne	r2,r2,zero
 d0446c8:	1000031e 	bne	r2,zero,d0446d8 <ip_setmoptions+0x414>
      {
         error = EADDRNOTAVAIL;
 d0446cc:	00801f44 	movi	r2,125
 d0446d0:	e0bff915 	stw	r2,-28(fp)
         break;
 d0446d4:	00005606 	br	d044830 <ip_setmoptions+0x56c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 d0446d8:	e03ff80d 	sth	zero,-32(fp)
 d0446dc:	00001b06 	br	d04474c <ip_setmoptions+0x488>
      {
         if ((netp == NULL ||
 d0446e0:	e0bffa17 	ldw	r2,-24(fp)
 d0446e4:	1005003a 	cmpeq	r2,r2,zero
 d0446e8:	10000a1e 	bne	r2,zero,d044714 <ip_setmoptions+0x450>
 d0446ec:	e0bff80b 	ldhu	r2,-32(fp)
 d0446f0:	e0fff617 	ldw	r3,-40(fp)
 d0446f4:	1085883a 	add	r2,r2,r2
 d0446f8:	1085883a 	add	r2,r2,r2
 d0446fc:	10c5883a 	add	r2,r2,r3
 d044700:	10800204 	addi	r2,r2,8
 d044704:	10800017 	ldw	r2,0(r2)
 d044708:	10c00117 	ldw	r3,4(r2)
 d04470c:	e0bffa17 	ldw	r2,-24(fp)
 d044710:	18800b1e 	bne	r3,r2,d044740 <ip_setmoptions+0x47c>
 d044714:	e0bff80b 	ldhu	r2,-32(fp)
 d044718:	e0fff617 	ldw	r3,-40(fp)
 d04471c:	1085883a 	add	r2,r2,r2
 d044720:	1085883a 	add	r2,r2,r2
 d044724:	10c5883a 	add	r2,r2,r3
 d044728:	10800204 	addi	r2,r2,8
 d04472c:	10800017 	ldw	r2,0(r2)
 d044730:	10c00017 	ldw	r3,0(r2)
 d044734:	e0bff717 	ldw	r2,-36(fp)
 d044738:	10800017 	ldw	r2,0(r2)
 d04473c:	18800826 	beq	r3,r2,d044760 <ip_setmoptions+0x49c>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 d044740:	e0bff80b 	ldhu	r2,-32(fp)
 d044744:	10800044 	addi	r2,r2,1
 d044748:	e0bff80d 	sth	r2,-32(fp)
 d04474c:	e0bff617 	ldw	r2,-40(fp)
 d044750:	1080018b 	ldhu	r2,6(r2)
 d044754:	10ffffcc 	andi	r3,r2,65535
 d044758:	e0bff80b 	ldhu	r2,-32(fp)
 d04475c:	10ffe036 	bltu	r2,r3,d0446e0 <ip_setmoptions+0x41c>
             mreq->imr_multiaddr)
         {
            break;
         }
      }
      if (i == imo->imo_num_memberships) 
 d044760:	e0bff617 	ldw	r2,-40(fp)
 d044764:	1080018b 	ldhu	r2,6(r2)
 d044768:	10ffffcc 	andi	r3,r2,65535
 d04476c:	e0bff80b 	ldhu	r2,-32(fp)
 d044770:	1880031e 	bne	r3,r2,d044780 <ip_setmoptions+0x4bc>
      {
         error = EADDRNOTAVAIL;
 d044774:	00801f44 	movi	r2,125
 d044778:	e0bff915 	stw	r2,-28(fp)
         break;
 d04477c:	00002c06 	br	d044830 <ip_setmoptions+0x56c>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 d044780:	e0bff80b 	ldhu	r2,-32(fp)
 d044784:	e0fff617 	ldw	r3,-40(fp)
 d044788:	1085883a 	add	r2,r2,r2
 d04478c:	1085883a 	add	r2,r2,r2
 d044790:	10c5883a 	add	r2,r2,r3
 d044794:	10800204 	addi	r2,r2,8
 d044798:	11000017 	ldw	r4,0(r2)
 d04479c:	d0419e40 	call	d0419e4 <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 d0447a0:	e0bff80b 	ldhu	r2,-32(fp)
 d0447a4:	10800044 	addi	r2,r2,1
 d0447a8:	e0bff80d 	sth	r2,-32(fp)
 d0447ac:	00001206 	br	d0447f8 <ip_setmoptions+0x534>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 d0447b0:	e0bff80b 	ldhu	r2,-32(fp)
 d0447b4:	113fffc4 	addi	r4,r2,-1
 d0447b8:	e0bff80b 	ldhu	r2,-32(fp)
 d0447bc:	e0fff617 	ldw	r3,-40(fp)
 d0447c0:	1085883a 	add	r2,r2,r2
 d0447c4:	1085883a 	add	r2,r2,r2
 d0447c8:	10c5883a 	add	r2,r2,r3
 d0447cc:	10800204 	addi	r2,r2,8
 d0447d0:	11400017 	ldw	r5,0(r2)
 d0447d4:	e0fff617 	ldw	r3,-40(fp)
 d0447d8:	2105883a 	add	r2,r4,r4
 d0447dc:	1085883a 	add	r2,r2,r2
 d0447e0:	10c5883a 	add	r2,r2,r3
 d0447e4:	10800204 	addi	r2,r2,8
 d0447e8:	11400015 	stw	r5,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 d0447ec:	e0bff80b 	ldhu	r2,-32(fp)
 d0447f0:	10800044 	addi	r2,r2,1
 d0447f4:	e0bff80d 	sth	r2,-32(fp)
 d0447f8:	e0bff617 	ldw	r2,-40(fp)
 d0447fc:	1080018b 	ldhu	r2,6(r2)
 d044800:	10ffffcc 	andi	r3,r2,65535
 d044804:	e0bff80b 	ldhu	r2,-32(fp)
 d044808:	10ffe936 	bltu	r2,r3,d0447b0 <ip_setmoptions+0x4ec>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 d04480c:	e0bff617 	ldw	r2,-40(fp)
 d044810:	1080018b 	ldhu	r2,6(r2)
 d044814:	10bfffc4 	addi	r2,r2,-1
 d044818:	1007883a 	mov	r3,r2
 d04481c:	e0bff617 	ldw	r2,-40(fp)
 d044820:	10c0018d 	sth	r3,6(r2)
      break;
 d044824:	00000206 	br	d044830 <ip_setmoptions+0x56c>

      default:
      error = EOPNOTSUPP;
 d044828:	008017c4 	movi	r2,95
 d04482c:	e0bff915 	stw	r2,-28(fp)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 d044830:	e0bff617 	ldw	r2,-40(fp)
 d044834:	10800017 	ldw	r2,0(r2)
 d044838:	1004c03a 	cmpne	r2,r2,zero
 d04483c:	1000141e 	bne	r2,zero,d044890 <ip_setmoptions+0x5cc>
 d044840:	e0bff617 	ldw	r2,-40(fp)
 d044844:	10800103 	ldbu	r2,4(r2)
 d044848:	10803fcc 	andi	r2,r2,255
 d04484c:	10800058 	cmpnei	r2,r2,1
 d044850:	10000f1e 	bne	r2,zero,d044890 <ip_setmoptions+0x5cc>
 d044854:	e0bff617 	ldw	r2,-40(fp)
 d044858:	10800143 	ldbu	r2,5(r2)
 d04485c:	10803fcc 	andi	r2,r2,255
 d044860:	10800058 	cmpnei	r2,r2,1
 d044864:	10000a1e 	bne	r2,zero,d044890 <ip_setmoptions+0x5cc>
 d044868:	e0bff617 	ldw	r2,-40(fp)
 d04486c:	1080018b 	ldhu	r2,6(r2)
 d044870:	10bfffcc 	andi	r2,r2,65535
 d044874:	1004c03a 	cmpne	r2,r2,zero
 d044878:	1000051e 	bne	r2,zero,d044890 <ip_setmoptions+0x5cc>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 d04487c:	e0bff517 	ldw	r2,-44(fp)
 d044880:	11000017 	ldw	r4,0(r2)
 d044884:	d029f200 	call	d029f20 <npfree>
      *imop = NULL;
 d044888:	e0bff517 	ldw	r2,-44(fp)
 d04488c:	10000015 	stw	zero,0(r2)
   }
   return (error);
 d044890:	e0bff917 	ldw	r2,-28(fp)
 d044894:	e0bffe15 	stw	r2,-8(fp)
 d044898:	e0bffe17 	ldw	r2,-8(fp)
}
 d04489c:	e037883a 	mov	sp,fp
 d0448a0:	dfc00217 	ldw	ra,8(sp)
 d0448a4:	df000117 	ldw	fp,4(sp)
 d0448a8:	dc000017 	ldw	r16,0(sp)
 d0448ac:	dec00304 	addi	sp,sp,12
 d0448b0:	f800283a 	ret

0d0448b4 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 d0448b4:	defff604 	addi	sp,sp,-40
 d0448b8:	df000915 	stw	fp,36(sp)
 d0448bc:	df000904 	addi	fp,sp,36
 d0448c0:	e13ffb15 	stw	r4,-20(fp)
 d0448c4:	e17ffc15 	stw	r5,-16(fp)
 d0448c8:	e1bffd15 	stw	r6,-12(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 d0448cc:	e0bffc17 	ldw	r2,-16(fp)
 d0448d0:	10800317 	ldw	r2,12(r2)
 d0448d4:	e0bff715 	stw	r2,-36(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 d0448d8:	e0bffb17 	ldw	r2,-20(fp)
 d0448dc:	e0bfff15 	stw	r2,-4(fp)
 d0448e0:	e0ffff17 	ldw	r3,-4(fp)
 d0448e4:	18800260 	cmpeqi	r2,r3,9
 d0448e8:	10000a1e 	bne	r2,zero,d044914 <ip_getmoptions+0x60>
 d0448ec:	e0ffff17 	ldw	r3,-4(fp)
 d0448f0:	18800250 	cmplti	r2,r3,9
 d0448f4:	1000381e 	bne	r2,zero,d0449d8 <ip_getmoptions+0x124>
 d0448f8:	e0ffff17 	ldw	r3,-4(fp)
 d0448fc:	188002a0 	cmpeqi	r2,r3,10
 d044900:	1000171e 	bne	r2,zero,d044960 <ip_getmoptions+0xac>
 d044904:	e0ffff17 	ldw	r3,-4(fp)
 d044908:	188002e0 	cmpeqi	r2,r3,11
 d04490c:	1000231e 	bne	r2,zero,d04499c <ip_getmoptions+0xe8>
 d044910:	00003106 	br	d0449d8 <ip_getmoptions+0x124>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 d044914:	e0bffd17 	ldw	r2,-12(fp)
 d044918:	e0bff815 	stw	r2,-32(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 d04491c:	e0bff717 	ldw	r2,-36(fp)
 d044920:	1005003a 	cmpeq	r2,r2,zero
 d044924:	1000041e 	bne	r2,zero,d044938 <ip_getmoptions+0x84>
 d044928:	e0bff717 	ldw	r2,-36(fp)
 d04492c:	10800017 	ldw	r2,0(r2)
 d044930:	1004c03a 	cmpne	r2,r2,zero
 d044934:	1000031e 	bne	r2,zero,d044944 <ip_getmoptions+0x90>
         *addr = AADDR;
 d044938:	e0bff817 	ldw	r2,-32(fp)
 d04493c:	10000015 	stw	zero,0(r2)
   switch (optname) 
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 d044940:	00000506 	br	d044958 <ip_getmoptions+0xa4>
         *addr = AADDR;
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 d044944:	e0bff717 	ldw	r2,-36(fp)
 d044948:	10800017 	ldw	r2,0(r2)
 d04494c:	10c00a17 	ldw	r3,40(r2)
 d044950:	e0bff817 	ldw	r2,-32(fp)
 d044954:	10c00015 	stw	r3,0(r2)
      return (0);
 d044958:	e03ffe15 	stw	zero,-8(fp)
 d04495c:	00002006 	br	d0449e0 <ip_getmoptions+0x12c>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 d044960:	e0bffd17 	ldw	r2,-12(fp)
 d044964:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL)
 d044968:	e0bff717 	ldw	r2,-36(fp)
 d04496c:	1004c03a 	cmpne	r2,r2,zero
 d044970:	1000041e 	bne	r2,zero,d044984 <ip_getmoptions+0xd0>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 d044974:	e0fffa17 	ldw	r3,-24(fp)
 d044978:	00800044 	movi	r2,1
 d04497c:	18800005 	stb	r2,0(r3)
 d044980:	00000406 	br	d044994 <ip_getmoptions+0xe0>
      else
         *ttl = imo->imo_multicast_ttl;
 d044984:	e0bff717 	ldw	r2,-36(fp)
 d044988:	10c00103 	ldbu	r3,4(r2)
 d04498c:	e0bffa17 	ldw	r2,-24(fp)
 d044990:	10c00005 	stb	r3,0(r2)
      return (0);
 d044994:	e03ffe15 	stw	zero,-8(fp)
 d044998:	00001106 	br	d0449e0 <ip_getmoptions+0x12c>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 d04499c:	e0bffd17 	ldw	r2,-12(fp)
 d0449a0:	e0bff915 	stw	r2,-28(fp)
      if (imo == NULL)
 d0449a4:	e0bff717 	ldw	r2,-36(fp)
 d0449a8:	1004c03a 	cmpne	r2,r2,zero
 d0449ac:	1000041e 	bne	r2,zero,d0449c0 <ip_getmoptions+0x10c>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 d0449b0:	e0fff917 	ldw	r3,-28(fp)
 d0449b4:	00800044 	movi	r2,1
 d0449b8:	18800005 	stb	r2,0(r3)
 d0449bc:	00000406 	br	d0449d0 <ip_getmoptions+0x11c>
      else
         *loop = imo->imo_multicast_loop;
 d0449c0:	e0bff717 	ldw	r2,-36(fp)
 d0449c4:	10c00143 	ldbu	r3,5(r2)
 d0449c8:	e0bff917 	ldw	r2,-28(fp)
 d0449cc:	10c00005 	stb	r3,0(r2)
      return (0);
 d0449d0:	e03ffe15 	stw	zero,-8(fp)
 d0449d4:	00000206 	br	d0449e0 <ip_getmoptions+0x12c>

      default:
      return (EOPNOTSUPP);
 d0449d8:	008017c4 	movi	r2,95
 d0449dc:	e0bffe15 	stw	r2,-8(fp)
 d0449e0:	e0bffe17 	ldw	r2,-8(fp)
   }
}
 d0449e4:	e037883a 	mov	sp,fp
 d0449e8:	df000017 	ldw	fp,0(sp)
 d0449ec:	dec00104 	addi	sp,sp,4
 d0449f0:	f800283a 	ret

0d0449f4 <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 d0449f4:	defffc04 	addi	sp,sp,-16
 d0449f8:	dfc00315 	stw	ra,12(sp)
 d0449fc:	df000215 	stw	fp,8(sp)
 d044a00:	df000204 	addi	fp,sp,8
 d044a04:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 d044a08:	e0bfff17 	ldw	r2,-4(fp)
 d044a0c:	1005003a 	cmpeq	r2,r2,zero
 d044a10:	1000141e 	bne	r2,zero,d044a64 <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 d044a14:	e03ffe0d 	sth	zero,-8(fp)
 d044a18:	00000b06 	br	d044a48 <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 d044a1c:	e0bffe0b 	ldhu	r2,-8(fp)
 d044a20:	e0ffff17 	ldw	r3,-4(fp)
 d044a24:	1085883a 	add	r2,r2,r2
 d044a28:	1085883a 	add	r2,r2,r2
 d044a2c:	10c5883a 	add	r2,r2,r3
 d044a30:	10800204 	addi	r2,r2,8
 d044a34:	11000017 	ldw	r4,0(r2)
 d044a38:	d0419e40 	call	d0419e4 <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 d044a3c:	e0bffe0b 	ldhu	r2,-8(fp)
 d044a40:	10800044 	addi	r2,r2,1
 d044a44:	e0bffe0d 	sth	r2,-8(fp)
 d044a48:	e0bfff17 	ldw	r2,-4(fp)
 d044a4c:	1080018b 	ldhu	r2,6(r2)
 d044a50:	10ffffcc 	andi	r3,r2,65535
 d044a54:	e0bffe0b 	ldhu	r2,-8(fp)
 d044a58:	10fff036 	bltu	r2,r3,d044a1c <ip_freemoptions+0x28>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 d044a5c:	e13fff17 	ldw	r4,-4(fp)
 d044a60:	d029f200 	call	d029f20 <npfree>
   }
}
 d044a64:	e037883a 	mov	sp,fp
 d044a68:	dfc00117 	ldw	ra,4(sp)
 d044a6c:	df000017 	ldw	fp,0(sp)
 d044a70:	dec00204 	addi	sp,sp,8
 d044a74:	f800283a 	ret

0d044a78 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 d044a78:	defffe04 	addi	sp,sp,-8
 d044a7c:	dfc00115 	stw	ra,4(sp)
 d044a80:	df000015 	stw	fp,0(sp)
 d044a84:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 d044a88:	01034174 	movhi	r4,3333
 d044a8c:	21004004 	addi	r4,r4,256
 d044a90:	d002cc00 	call	d002cc0 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 d044a94:	e037883a 	mov	sp,fp
 d044a98:	dfc00117 	ldw	ra,4(sp)
 d044a9c:	df000017 	ldw	fp,0(sp)
 d044aa0:	dec00204 	addi	sp,sp,8
 d044aa4:	f800283a 	ret

0d044aa8 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 d044aa8:	defede04 	addi	sp,sp,-1160
 d044aac:	dfc12115 	stw	ra,1156(sp)
 d044ab0:	df012015 	stw	fp,1152(sp)
 d044ab4:	df012004 	addi	fp,sp,1152
 d044ab8:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 d044abc:	00c34174 	movhi	r3,3333
 d044ac0:	18c0ec04 	addi	r3,r3,944
 d044ac4:	18800017 	ldw	r2,0(r3)
 d044ac8:	e0bff215 	stw	r2,-56(fp)
 d044acc:	18800117 	ldw	r2,4(r3)
 d044ad0:	e0bff315 	stw	r2,-52(fp)
 d044ad4:	18800217 	ldw	r2,8(r3)
 d044ad8:	e0bff415 	stw	r2,-48(fp)
 d044adc:	18800317 	ldw	r2,12(r3)
 d044ae0:	e0bff515 	stw	r2,-44(fp)
 d044ae4:	18800417 	ldw	r2,16(r3)
 d044ae8:	e0bff615 	stw	r2,-40(fp)
 d044aec:	18800517 	ldw	r2,20(r3)
 d044af0:	e0bff715 	stw	r2,-36(fp)
 d044af4:	18800617 	ldw	r2,24(r3)
 d044af8:	e0bff815 	stw	r2,-32(fp)
 d044afc:	1880070b 	ldhu	r2,28(r3)
 d044b00:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 d044b04:	01000084 	movi	r4,2
 d044b08:	01400084 	movi	r5,2
 d044b0c:	000d883a 	mov	r6,zero
 d044b10:	d02c46c0 	call	d02c46c <t_socket>
 d044b14:	e0bee515 	stw	r2,-1132(fp)

   if (s == INVALID_SOCKET) 
 d044b18:	e0bee517 	ldw	r2,-1132(fp)
 d044b1c:	10bfffd8 	cmpnei	r2,r2,-1
 d044b20:	1000091e 	bne	r2,zero,d044b48 <u_mctest_run+0xa0>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 d044b24:	e13ee517 	ldw	r4,-1132(fp)
 d044b28:	d02db800 	call	d02db80 <t_errno>
 d044b2c:	100d883a 	mov	r6,r2
 d044b30:	e13fff17 	ldw	r4,-4(fp)
 d044b34:	01434174 	movhi	r5,3333
 d044b38:	29404504 	addi	r5,r5,276
 d044b3c:	d02486c0 	call	d02486c <ns_printf>
      exit(1);
 d044b40:	01000044 	movi	r4,1
 d044b44:	d049e740 	call	d049e74 <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 d044b48:	00800044 	movi	r2,1
 d044b4c:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 d044b50:	e1fffa04 	addi	r7,fp,-24
 d044b54:	00800104 	movi	r2,4
 d044b58:	d8800015 	stw	r2,0(sp)
 d044b5c:	e13ee517 	ldw	r4,-1132(fp)
 d044b60:	017fffc4 	movi	r5,-1
 d044b64:	01800104 	movi	r6,4
 d044b68:	d02cf200 	call	d02cf20 <t_setsockopt>
 d044b6c:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d044b70:	e0bee317 	ldw	r2,-1140(fp)
 d044b74:	10bfffd8 	cmpnei	r2,r2,-1
 d044b78:	1000071e 	bne	r2,zero,d044b98 <u_mctest_run+0xf0>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 d044b7c:	e13ee517 	ldw	r4,-1132(fp)
 d044b80:	d02db800 	call	d02db80 <t_errno>
 d044b84:	100d883a 	mov	r6,r2
 d044b88:	e13fff17 	ldw	r4,-4(fp)
 d044b8c:	01434174 	movhi	r5,3333
 d044b90:	29404c04 	addi	r5,r5,304
 d044b94:	d02486c0 	call	d02486c <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 d044b98:	00800084 	movi	r2,2
 d044b9c:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 d044ba0:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 d044ba4:	00a00344 	movi	r2,-32755
 d044ba8:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 d044bac:	e17ee604 	addi	r5,fp,-1128
 d044bb0:	e13ee517 	ldw	r4,-1132(fp)
 d044bb4:	01800404 	movi	r6,16
 d044bb8:	d02c4fc0 	call	d02c4fc <t_bind>
 d044bbc:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d044bc0:	e0bee317 	ldw	r2,-1140(fp)
 d044bc4:	10bfffd8 	cmpnei	r2,r2,-1
 d044bc8:	1000061e 	bne	r2,zero,d044be4 <u_mctest_run+0x13c>
   {
      printf ("t_bind() failed, Err: %d\n",
 d044bcc:	e13ee517 	ldw	r4,-1132(fp)
 d044bd0:	d02db800 	call	d02db80 <t_errno>
 d044bd4:	100b883a 	mov	r5,r2
 d044bd8:	01034174 	movhi	r4,3333
 d044bdc:	21005804 	addi	r4,r4,352
 d044be0:	d0029980 	call	d002998 <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 d044be4:	e13fff17 	ldw	r4,-4(fp)
 d044be8:	01434174 	movhi	r5,3333
 d044bec:	29405f04 	addi	r5,r5,380
 d044bf0:	01834174 	movhi	r6,3333
 d044bf4:	31806704 	addi	r6,r6,412
 d044bf8:	d02486c0 	call	d02486c <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 d044bfc:	01034174 	movhi	r4,3333
 d044c00:	21006704 	addi	r4,r4,412
 d044c04:	d045bd40 	call	d045bd4 <inet_addr>
 d044c08:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 d044c0c:	008341b4 	movhi	r2,3334
 d044c10:	10b1e504 	addi	r2,r2,-14444
 d044c14:	10800a17 	ldw	r2,40(r2)
 d044c18:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 d044c1c:	e1fffb04 	addi	r7,fp,-20
 d044c20:	00800204 	movi	r2,8
 d044c24:	d8800015 	stw	r2,0(sp)
 d044c28:	e13ee517 	ldw	r4,-1132(fp)
 d044c2c:	000b883a 	mov	r5,zero
 d044c30:	01800304 	movi	r6,12
 d044c34:	d02cf200 	call	d02cf20 <t_setsockopt>
 d044c38:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 d044c3c:	e0bee317 	ldw	r2,-1140(fp)
 d044c40:	10bfffd8 	cmpnei	r2,r2,-1
 d044c44:	1000071e 	bne	r2,zero,d044c64 <u_mctest_run+0x1bc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 d044c48:	e13ee517 	ldw	r4,-1132(fp)
 d044c4c:	d02db800 	call	d02db80 <t_errno>
 d044c50:	100d883a 	mov	r6,r2
 d044c54:	e13fff17 	ldw	r4,-4(fp)
 d044c58:	01434174 	movhi	r5,3333
 d044c5c:	29406a04 	addi	r5,r5,424
 d044c60:	d02486c0 	call	d02486c <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 d044c64:	d0252d40 	call	d0252d4 <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 d044c68:	e13fff17 	ldw	r4,-4(fp)
 d044c6c:	01434174 	movhi	r5,3333
 d044c70:	29405f04 	addi	r5,r5,380
 d044c74:	01834174 	movhi	r6,3333
 d044c78:	31807704 	addi	r6,r6,476
 d044c7c:	d02486c0 	call	d02486c <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 d044c80:	01034174 	movhi	r4,3333
 d044c84:	21007704 	addi	r4,r4,476
 d044c88:	d045bd40 	call	d045bd4 <inet_addr>
 d044c8c:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 d044c90:	008341b4 	movhi	r2,3334
 d044c94:	10b1e504 	addi	r2,r2,-14444
 d044c98:	10800a17 	ldw	r2,40(r2)
 d044c9c:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 d044ca0:	e1fffb04 	addi	r7,fp,-20
 d044ca4:	00800204 	movi	r2,8
 d044ca8:	d8800015 	stw	r2,0(sp)
 d044cac:	e13ee517 	ldw	r4,-1132(fp)
 d044cb0:	000b883a 	mov	r5,zero
 d044cb4:	01800304 	movi	r6,12
 d044cb8:	d02cf200 	call	d02cf20 <t_setsockopt>
 d044cbc:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 d044cc0:	e0bee317 	ldw	r2,-1140(fp)
 d044cc4:	10bfffd8 	cmpnei	r2,r2,-1
 d044cc8:	1000071e 	bne	r2,zero,d044ce8 <u_mctest_run+0x240>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 d044ccc:	e13ee517 	ldw	r4,-1132(fp)
 d044cd0:	d02db800 	call	d02db80 <t_errno>
 d044cd4:	100d883a 	mov	r6,r2
 d044cd8:	e13fff17 	ldw	r4,-4(fp)
 d044cdc:	01434174 	movhi	r5,3333
 d044ce0:	29406a04 	addi	r5,r5,424
 d044ce4:	d02486c0 	call	d02486c <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 d044ce8:	d0252d40 	call	d0252d4 <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 d044cec:	e13fff17 	ldw	r4,-4(fp)
 d044cf0:	01434174 	movhi	r5,3333
 d044cf4:	29405f04 	addi	r5,r5,380
 d044cf8:	01834174 	movhi	r6,3333
 d044cfc:	31807a04 	addi	r6,r6,488
 d044d00:	d02486c0 	call	d02486c <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 d044d04:	01034174 	movhi	r4,3333
 d044d08:	21007a04 	addi	r4,r4,488
 d044d0c:	d045bd40 	call	d045bd4 <inet_addr>
 d044d10:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 d044d14:	008341b4 	movhi	r2,3334
 d044d18:	10b1e504 	addi	r2,r2,-14444
 d044d1c:	10800a17 	ldw	r2,40(r2)
 d044d20:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 d044d24:	e1fffb04 	addi	r7,fp,-20
 d044d28:	00800204 	movi	r2,8
 d044d2c:	d8800015 	stw	r2,0(sp)
 d044d30:	e13ee517 	ldw	r4,-1132(fp)
 d044d34:	000b883a 	mov	r5,zero
 d044d38:	01800304 	movi	r6,12
 d044d3c:	d02cf200 	call	d02cf20 <t_setsockopt>
 d044d40:	e0bee315 	stw	r2,-1140(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 d044d44:	e0bee317 	ldw	r2,-1140(fp)
 d044d48:	10bfffd8 	cmpnei	r2,r2,-1
 d044d4c:	1000071e 	bne	r2,zero,d044d6c <u_mctest_run+0x2c4>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 d044d50:	e13ee517 	ldw	r4,-1132(fp)
 d044d54:	d02db800 	call	d02db80 <t_errno>
 d044d58:	100d883a 	mov	r6,r2
 d044d5c:	e13fff17 	ldw	r4,-4(fp)
 d044d60:	01434174 	movhi	r5,3333
 d044d64:	29406a04 	addi	r5,r5,424
 d044d68:	d02486c0 	call	d02486c <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 d044d6c:	d0252d40 	call	d0252d4 <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 d044d70:	00800084 	movi	r2,2
 d044d74:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 d044d78:	e1fffd04 	addi	r7,fp,-12
 d044d7c:	00800044 	movi	r2,1
 d044d80:	d8800015 	stw	r2,0(sp)
 d044d84:	e13ee517 	ldw	r4,-1132(fp)
 d044d88:	000b883a 	mov	r5,zero
 d044d8c:	01800284 	movi	r6,10
 d044d90:	d02cf200 	call	d02cf20 <t_setsockopt>
 d044d94:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d044d98:	e0bee317 	ldw	r2,-1140(fp)
 d044d9c:	10bfffd8 	cmpnei	r2,r2,-1
 d044da0:	1000071e 	bne	r2,zero,d044dc0 <u_mctest_run+0x318>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 d044da4:	e13ee517 	ldw	r4,-1132(fp)
 d044da8:	d02db800 	call	d02db80 <t_errno>
 d044dac:	100d883a 	mov	r6,r2
 d044db0:	e13fff17 	ldw	r4,-4(fp)
 d044db4:	01434174 	movhi	r5,3333
 d044db8:	29407d04 	addi	r5,r5,500
 d044dbc:	d02486c0 	call	d02486c <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 d044dc0:	00800044 	movi	r2,1
 d044dc4:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 d044dc8:	e1fffd04 	addi	r7,fp,-12
 d044dcc:	00800044 	movi	r2,1
 d044dd0:	d8800015 	stw	r2,0(sp)
 d044dd4:	e13ee517 	ldw	r4,-1132(fp)
 d044dd8:	000b883a 	mov	r5,zero
 d044ddc:	018002c4 	movi	r6,11
 d044de0:	d02cf200 	call	d02cf20 <t_setsockopt>
 d044de4:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d044de8:	e0bee317 	ldw	r2,-1140(fp)
 d044dec:	10bfffd8 	cmpnei	r2,r2,-1
 d044df0:	1000071e 	bne	r2,zero,d044e10 <u_mctest_run+0x368>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 d044df4:	e13ee517 	ldw	r4,-1132(fp)
 d044df8:	d02db800 	call	d02db80 <t_errno>
 d044dfc:	100d883a 	mov	r6,r2
 d044e00:	e13fff17 	ldw	r4,-4(fp)
 d044e04:	01434174 	movhi	r5,3333
 d044e08:	29408a04 	addi	r5,r5,552
 d044e0c:	d02486c0 	call	d02486c <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 d044e10:	00800084 	movi	r2,2
 d044e14:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 d044e18:	01034174 	movhi	r4,3333
 d044e1c:	21007704 	addi	r4,r4,476
 d044e20:	d045bd40 	call	d045bd4 <inet_addr>
 d044e24:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 d044e28:	00a00344 	movi	r2,-32755
 d044e2c:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 d044e30:	e13fff17 	ldw	r4,-4(fp)
 d044e34:	01434174 	movhi	r5,3333
 d044e38:	29409704 	addi	r5,r5,604
 d044e3c:	01834174 	movhi	r6,3333
 d044e40:	31807704 	addi	r6,r6,476
 d044e44:	d02486c0 	call	d02486c <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 d044e48:	e03ee415 	stw	zero,-1136(fp)
 d044e4c:	00008506 	br	d045064 <u_mctest_run+0x5bc>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 d044e50:	e0bff204 	addi	r2,fp,-56
 d044e54:	11000404 	addi	r4,r2,16
 d044e58:	d0a05217 	ldw	r2,-32440(gp)
 d044e5c:	100d883a 	mov	r6,r2
 d044e60:	10800044 	addi	r2,r2,1
 d044e64:	d0a05215 	stw	r2,-32440(gp)
 d044e68:	01434174 	movhi	r5,3333
 d044e6c:	2940a604 	addi	r5,r5,664
 d044e70:	d002d340 	call	d002d34 <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 d044e74:	e0beea04 	addi	r2,fp,-1112
 d044e78:	e17ff204 	addi	r5,fp,-56
 d044e7c:	d8800015 	stw	r2,0(sp)
 d044e80:	00800404 	movi	r2,16
 d044e84:	d8800115 	stw	r2,4(sp)
 d044e88:	e13ee517 	ldw	r4,-1132(fp)
 d044e8c:	01800784 	movi	r6,30
 d044e90:	000f883a 	mov	r7,zero
 d044e94:	d02d4e00 	call	d02d4e0 <t_sendto>
 d044e98:	e0bee315 	stw	r2,-1140(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 d044e9c:	e0bee317 	ldw	r2,-1140(fp)
 d044ea0:	1004403a 	cmpge	r2,r2,zero
 d044ea4:	1000081e 	bne	r2,zero,d044ec8 <u_mctest_run+0x420>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 d044ea8:	e13ee517 	ldw	r4,-1132(fp)
 d044eac:	d02db800 	call	d02db80 <t_errno>
 d044eb0:	100d883a 	mov	r6,r2
 d044eb4:	e13fff17 	ldw	r4,-4(fp)
 d044eb8:	01434174 	movhi	r5,3333
 d044ebc:	2940a704 	addi	r5,r5,668
 d044ec0:	d02486c0 	call	d02486c <ns_printf>
         /*     exit(1); */
         goto exitloop;
 d044ec4:	00006a06 	br	d045070 <u_mctest_run+0x5c8>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 d044ec8:	00800044 	movi	r2,1
 d044ecc:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 d044ed0:	e1fffa04 	addi	r7,fp,-24
 d044ed4:	00800104 	movi	r2,4
 d044ed8:	d8800015 	stw	r2,0(sp)
 d044edc:	e13ee517 	ldw	r4,-1132(fp)
 d044ee0:	017fffc4 	movi	r5,-1
 d044ee4:	01840584 	movi	r6,4118
 d044ee8:	d02cf200 	call	d02cf20 <t_setsockopt>
 d044eec:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 d044ef0:	e0bee317 	ldw	r2,-1140(fp)
 d044ef4:	10bfffd8 	cmpnei	r2,r2,-1
 d044ef8:	1000071e 	bne	r2,zero,d044f18 <u_mctest_run+0x470>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 d044efc:	e13ee517 	ldw	r4,-1132(fp)
 d044f00:	d02db800 	call	d02db80 <t_errno>
 d044f04:	100d883a 	mov	r6,r2
 d044f08:	e13fff17 	ldw	r4,-4(fp)
 d044f0c:	01434174 	movhi	r5,3333
 d044f10:	2940af04 	addi	r5,r5,700
 d044f14:	d02486c0 	call	d02486c <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 d044f18:	00834174 	movhi	r2,3333
 d044f1c:	108ac904 	addi	r2,r2,11044
 d044f20:	10800017 	ldw	r2,0(r2)
 d044f24:	10807d04 	addi	r2,r2,500
 d044f28:	e0bee215 	stw	r2,-1144(fp)

      while (cticks < endtime)
 d044f2c:	00003206 	br	d044ff8 <u_mctest_run+0x550>
      {
         int sa_size = sizeof(struct sockaddr_in);
 d044f30:	00800404 	movi	r2,16
 d044f34:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 d044f38:	d0252d40 	call	d0252d4 <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 d044f3c:	e0beee04 	addi	r2,fp,-1096
 d044f40:	e17ef204 	addi	r5,fp,-1080
 d044f44:	d8800015 	stw	r2,0(sp)
 d044f48:	e0bffe04 	addi	r2,fp,-8
 d044f4c:	d8800115 	stw	r2,4(sp)
 d044f50:	e13ee517 	ldw	r4,-1132(fp)
 d044f54:	01810004 	movi	r6,1024
 d044f58:	000f883a 	mov	r7,zero
 d044f5c:	d02d3900 	call	d02d390 <t_recvfrom>
 d044f60:	e0bee315 	stw	r2,-1140(fp)
         if (iRet < 0) 
 d044f64:	e0bee317 	ldw	r2,-1140(fp)
 d044f68:	1004403a 	cmpge	r2,r2,zero
 d044f6c:	10000c1e 	bne	r2,zero,d044fa0 <u_mctest_run+0x4f8>
         {
            if (t_errno(s) != EWOULDBLOCK)
 d044f70:	e13ee517 	ldw	r4,-1132(fp)
 d044f74:	d02db800 	call	d02db80 <t_errno>
 d044f78:	108002e0 	cmpeqi	r2,r2,11
 d044f7c:	1000081e 	bne	r2,zero,d044fa0 <u_mctest_run+0x4f8>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 d044f80:	e13ee517 	ldw	r4,-1132(fp)
 d044f84:	d02db800 	call	d02db80 <t_errno>
 d044f88:	100d883a 	mov	r6,r2
 d044f8c:	e13fff17 	ldw	r4,-4(fp)
 d044f90:	01434174 	movhi	r5,3333
 d044f94:	2940bb04 	addi	r5,r5,748
 d044f98:	d02486c0 	call	d02486c <ns_printf>
               /*     exit(1); */
               goto exitloop;
 d044f9c:	00003406 	br	d045070 <u_mctest_run+0x5c8>
            }
         }
         if (iRet > 0)
 d044fa0:	e0bee317 	ldw	r2,-1140(fp)
 d044fa4:	10800050 	cmplti	r2,r2,1
 d044fa8:	1000131e 	bne	r2,zero,d044ff8 <u_mctest_run+0x550>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 d044fac:	e13eef17 	ldw	r4,-1092(fp)
 d044fb0:	d02448c0 	call	d02448c <print_ipad>
 d044fb4:	100d883a 	mov	r6,r2
 d044fb8:	e0beee8b 	ldhu	r2,-1094(fp)
 d044fbc:	10bfffcc 	andi	r2,r2,65535
 d044fc0:	1004d23a 	srli	r2,r2,8
 d044fc4:	10bfffcc 	andi	r2,r2,65535
 d044fc8:	10c03fcc 	andi	r3,r2,255
 d044fcc:	e0beee8b 	ldhu	r2,-1094(fp)
 d044fd0:	10bfffcc 	andi	r2,r2,65535
 d044fd4:	1004923a 	slli	r2,r2,8
 d044fd8:	10bfc00c 	andi	r2,r2,65280
 d044fdc:	188eb03a 	or	r7,r3,r2
 d044fe0:	e0bef204 	addi	r2,fp,-1080
 d044fe4:	d8800015 	stw	r2,0(sp)
 d044fe8:	e13fff17 	ldw	r4,-4(fp)
 d044fec:	01434174 	movhi	r5,3333
 d044ff0:	2940c304 	addi	r5,r5,780
 d044ff4:	d02486c0 	call	d02486c <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 d044ff8:	00834174 	movhi	r2,3333
 d044ffc:	108ac904 	addi	r2,r2,11044
 d045000:	10c00017 	ldw	r3,0(r2)
 d045004:	e0bee217 	ldw	r2,-1144(fp)
 d045008:	18bfc936 	bltu	r3,r2,d044f30 <u_mctest_run+0x488>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 d04500c:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 d045010:	e1fffd04 	addi	r7,fp,-12
 d045014:	00800044 	movi	r2,1
 d045018:	d8800015 	stw	r2,0(sp)
 d04501c:	e13ee517 	ldw	r4,-1132(fp)
 d045020:	017fffc4 	movi	r5,-1
 d045024:	01840584 	movi	r6,4118
 d045028:	d02cf200 	call	d02cf20 <t_setsockopt>
 d04502c:	e0bee315 	stw	r2,-1140(fp)
      if (iRet == SOCKET_ERROR) 
 d045030:	e0bee317 	ldw	r2,-1140(fp)
 d045034:	10bfffd8 	cmpnei	r2,r2,-1
 d045038:	1000071e 	bne	r2,zero,d045058 <u_mctest_run+0x5b0>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 d04503c:	e13ee517 	ldw	r4,-1132(fp)
 d045040:	d02db800 	call	d02db80 <t_errno>
 d045044:	100d883a 	mov	r6,r2
 d045048:	e13fff17 	ldw	r4,-4(fp)
 d04504c:	01434174 	movhi	r5,3333
 d045050:	2940ca04 	addi	r5,r5,808
 d045054:	d02486c0 	call	d02486c <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 d045058:	e0bee417 	ldw	r2,-1136(fp)
 d04505c:	10800044 	addi	r2,r2,1
 d045060:	e0bee415 	stw	r2,-1136(fp)
 d045064:	e0bee417 	ldw	r2,-1136(fp)
 d045068:	108000d0 	cmplti	r2,r2,3
 d04506c:	103f781e 	bne	r2,zero,d044e50 <u_mctest_run+0x3a8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 d045070:	01034174 	movhi	r4,3333
 d045074:	21006704 	addi	r4,r4,412
 d045078:	d045bd40 	call	d045bd4 <inet_addr>
 d04507c:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 d045080:	008341b4 	movhi	r2,3334
 d045084:	10b1e504 	addi	r2,r2,-14444
 d045088:	10800a17 	ldw	r2,40(r2)
 d04508c:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 d045090:	e1fffb04 	addi	r7,fp,-20
 d045094:	00800204 	movi	r2,8
 d045098:	d8800015 	stw	r2,0(sp)
 d04509c:	e13ee517 	ldw	r4,-1132(fp)
 d0450a0:	000b883a 	mov	r5,zero
 d0450a4:	01800344 	movi	r6,13
 d0450a8:	d02cf200 	call	d02cf20 <t_setsockopt>
 d0450ac:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d0450b0:	e0bee317 	ldw	r2,-1140(fp)
 d0450b4:	10bfffd8 	cmpnei	r2,r2,-1
 d0450b8:	1000071e 	bne	r2,zero,d0450d8 <u_mctest_run+0x630>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 d0450bc:	e13ee517 	ldw	r4,-1132(fp)
 d0450c0:	d02db800 	call	d02db80 <t_errno>
 d0450c4:	100d883a 	mov	r6,r2
 d0450c8:	e13fff17 	ldw	r4,-4(fp)
 d0450cc:	01434174 	movhi	r5,3333
 d0450d0:	2940d604 	addi	r5,r5,856
 d0450d4:	d02486c0 	call	d02486c <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 d0450d8:	e13ee517 	ldw	r4,-1132(fp)
 d0450dc:	d02da180 	call	d02da18 <t_socketclose>
 d0450e0:	e0bee315 	stw	r2,-1140(fp)
   if (iRet == SOCKET_ERROR) 
 d0450e4:	e0bee317 	ldw	r2,-1140(fp)
 d0450e8:	10bfffd8 	cmpnei	r2,r2,-1
 d0450ec:	1000071e 	bne	r2,zero,d04510c <u_mctest_run+0x664>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 d0450f0:	e13ee517 	ldw	r4,-1132(fp)
 d0450f4:	d02db800 	call	d02db80 <t_errno>
 d0450f8:	100d883a 	mov	r6,r2
 d0450fc:	e13fff17 	ldw	r4,-4(fp)
 d045100:	01434174 	movhi	r5,3333
 d045104:	2940e304 	addi	r5,r5,908
 d045108:	d02486c0 	call	d02486c <ns_printf>
   }

   return(0);
 d04510c:	0005883a 	mov	r2,zero
}  /* end main() */  
 d045110:	e037883a 	mov	sp,fp
 d045114:	dfc00117 	ldw	ra,4(sp)
 d045118:	df000017 	ldw	fp,0(sp)
 d04511c:	dec00204 	addi	sp,sp,8
 d045120:	f800283a 	ret

0d045124 <dhc_setup>:
 * RETURNS: void
 */

void
dhc_setup(void)
{  
 d045124:	defff604 	addi	sp,sp,-40
 d045128:	dfc00915 	stw	ra,36(sp)
 d04512c:	df000815 	stw	fp,32(sp)
 d045130:	df000804 	addi	fp,sp,32
   int      iface;
   ulong    dhcp_started;
   ip_addr  dhcp_saveaddr[STATIC_NETS];
   int      e;
   int      dhcnets = 0;   /* number of nets doing DHCP */
 d045134:	e03ff815 	stw	zero,-32(fp)

   e = dhc_init();
 d045138:	d0255980 	call	d025598 <dhc_init>
 d04513c:	e0bff915 	stw	r2,-28(fp)

   if (e)
 d045140:	e0bff917 	ldw	r2,-28(fp)
 d045144:	1005003a 	cmpeq	r2,r2,zero
 d045148:	1000051e 	bne	r2,zero,d045160 <dhc_setup+0x3c>
   {
      printf("Error starting DHCP client code.\n");
 d04514c:	01034174 	movhi	r4,3333
 d045150:	2100f404 	addi	r4,r4,976
 d045154:	d002cc00 	call	d002cc0 <puts>
      netexit(1);
 d045158:	01000044 	movi	r4,1
 d04515c:	d041c000 	call	d041c00 <netexit>
   }

   dhcp_started = cticks;  /* init timeout */
 d045160:	00834174 	movhi	r2,3333
 d045164:	108ac904 	addi	r2,r2,11044
 d045168:	10800017 	ldw	r2,0(r2)
 d04516c:	e0bffa15 	stw	r2,-24(fp)

   for (iface = 0; iface < STATIC_NETS; iface++)
 d045170:	e03ffb15 	stw	zero,-20(fp)
 d045174:	00005106 	br	d0452bc <dhc_setup+0x198>
   {
      if (!nets[iface])
 d045178:	e0bffb17 	ldw	r2,-20(fp)
 d04517c:	00c341b4 	movhi	r3,3334
 d045180:	18f2a504 	addi	r3,r3,-13676
 d045184:	1085883a 	add	r2,r2,r2
 d045188:	1085883a 	add	r2,r2,r2
 d04518c:	10c5883a 	add	r2,r2,r3
 d045190:	10800017 	ldw	r2,0(r2)
 d045194:	1005003a 	cmpeq	r2,r2,zero
 d045198:	1000451e 	bne	r2,zero,d0452b0 <dhc_setup+0x18c>
#ifdef INCLUDE_NVPARMS
      if (inet_nvparms.ifs[iface].client_dhcp)
         nets[iface]->n_flags |= NF_DHCPC ; /* use DHCP Client on this iface */
#endif   /* INCLUDE_NVPARMS */

      if (!(nets[iface]->n_flags & NF_DHCPC))
 d04519c:	e0bffb17 	ldw	r2,-20(fp)
 d0451a0:	00c341b4 	movhi	r3,3334
 d0451a4:	18f2a504 	addi	r3,r3,-13676
 d0451a8:	1085883a 	add	r2,r2,r2
 d0451ac:	1085883a 	add	r2,r2,r2
 d0451b0:	10c5883a 	add	r2,r2,r3
 d0451b4:	10800017 	ldw	r2,0(r2)
 d0451b8:	10802a17 	ldw	r2,168(r2)
 d0451bc:	1080400c 	andi	r2,r2,256
 d0451c0:	1005003a 	cmpeq	r2,r2,zero
 d0451c4:	10003a1e 	bne	r2,zero,d0452b0 <dhc_setup+0x18c>
         continue;

      /* If callback is not already in use (by AutoIP) grab it for
       * our printf routine.
       */
      if(dhc_states[iface].callback == NULL)
 d0451c8:	e0bffb17 	ldw	r2,-20(fp)
 d0451cc:	00c341b4 	movhi	r3,3334
 d0451d0:	18f2cb04 	addi	r3,r3,-13524
 d0451d4:	10800f24 	muli	r2,r2,60
 d0451d8:	10c5883a 	add	r2,r2,r3
 d0451dc:	10800e04 	addi	r2,r2,56
 d0451e0:	10800017 	ldw	r2,0(r2)
 d0451e4:	1004c03a 	cmpne	r2,r2,zero
 d0451e8:	1000041e 	bne	r2,zero,d0451fc <dhc_setup+0xd8>
      {
         dhc_set_callback(iface, dhc_main_ipset);
 d0451ec:	e13ffb17 	ldw	r4,-20(fp)
 d0451f0:	01434134 	movhi	r5,3332
 d0451f4:	2954ea04 	addi	r5,r5,21416
 d0451f8:	d0256540 	call	d025654 <dhc_set_callback>
      }

      /* start DHCP on the iface - first save the default address */
      dhcp_saveaddr[iface] = nets[iface]->n_ipaddr;
 d0451fc:	e13ffb17 	ldw	r4,-20(fp)
 d045200:	e0bffb17 	ldw	r2,-20(fp)
 d045204:	00c341b4 	movhi	r3,3334
 d045208:	18f2a504 	addi	r3,r3,-13676
 d04520c:	1085883a 	add	r2,r2,r2
 d045210:	1085883a 	add	r2,r2,r2
 d045214:	10c5883a 	add	r2,r2,r3
 d045218:	10800017 	ldw	r2,0(r2)
 d04521c:	10c00a17 	ldw	r3,40(r2)
 d045220:	2105883a 	add	r2,r4,r4
 d045224:	1085883a 	add	r2,r2,r2
 d045228:	e13ff804 	addi	r4,fp,-32
 d04522c:	1105883a 	add	r2,r2,r4
 d045230:	10800404 	addi	r2,r2,16
 d045234:	10c00015 	stw	r3,0(r2)

      if (dhcp_saveaddr[iface] == 0L)  /* see if there is a default */
 d045238:	e0bffb17 	ldw	r2,-20(fp)
 d04523c:	1085883a 	add	r2,r2,r2
 d045240:	1085883a 	add	r2,r2,r2
 d045244:	e0fff804 	addi	r3,fp,-32
 d045248:	10c5883a 	add	r2,r2,r3
 d04524c:	10800404 	addi	r2,r2,16
 d045250:	10800017 	ldw	r2,0(r2)
 d045254:	1004c03a 	cmpne	r2,r2,zero
 d045258:	1000041e 	bne	r2,zero,d04526c <dhc_setup+0x148>
         dhc_state_init(iface, TRUE);  /* Put DHCPClient in INIT state */
 d04525c:	e13ffb17 	ldw	r4,-20(fp)
 d045260:	01400044 	movi	r5,1
 d045264:	d0282340 	call	d028234 <dhc_state_init>
 d045268:	00000306 	br	d045278 <dhc_setup+0x154>
      else
         dhc_state_init(iface, FALSE); /* Put DHCPClient in INIT-REBOOT state */
 d04526c:	e13ffb17 	ldw	r4,-20(fp)
 d045270:	000b883a 	mov	r5,zero
 d045274:	d0282340 	call	d028234 <dhc_state_init>

      e=dhc_second();                  /* To send the DISCOVER/REQUEST pkt */
 d045278:	d027a400 	call	d027a40 <dhc_second>
 d04527c:	e0bff915 	stw	r2,-28(fp)
      if (e)
 d045280:	e0bff917 	ldw	r2,-28(fp)
 d045284:	1005003a 	cmpeq	r2,r2,zero
 d045288:	1000061e 	bne	r2,zero,d0452a4 <dhc_setup+0x180>
      {
         printf("Error sending DHCP packet on iface %d.\n", iface);
 d04528c:	01034174 	movhi	r4,3333
 d045290:	2100fd04 	addi	r4,r4,1012
 d045294:	e17ffb17 	ldw	r5,-20(fp)
 d045298:	d0029980 	call	d002998 <printf>
         netexit(1);
 d04529c:	01000044 	movi	r4,1
 d0452a0:	d041c000 	call	d041c00 <netexit>
      /* If we are not using Auto IP then we want to block below waiting
       * for DHCP completion. If we are using Auto IP then we want to
       * return and let the Auto IP code handle the DHCP completion.
       * "dhcnets" is a flag which allows this.
       */
      dhcnets++;
 d0452a4:	e0bff817 	ldw	r2,-32(fp)
 d0452a8:	10800044 	addi	r2,r2,1
 d0452ac:	e0bff815 	stw	r2,-32(fp)
      netexit(1);
   }

   dhcp_started = cticks;  /* init timeout */

   for (iface = 0; iface < STATIC_NETS; iface++)
 d0452b0:	e0bffb17 	ldw	r2,-20(fp)
 d0452b4:	10800044 	addi	r2,r2,1
 d0452b8:	e0bffb15 	stw	r2,-20(fp)
 d0452bc:	e0bffb17 	ldw	r2,-20(fp)
 d0452c0:	10800110 	cmplti	r2,r2,4
 d0452c4:	103fac1e 	bne	r2,zero,d045178 <dhc_setup+0x54>
       */
      dhcnets++;
#endif
   }

   if(dhcnets == 0)  /* no nets doing DHCP? */
 d0452c8:	e0bff817 	ldw	r2,-32(fp)
 d0452cc:	1005003a 	cmpeq	r2,r2,zero
 d0452d0:	1000301e 	bne	r2,zero,d045394 <dhc_setup+0x270>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 d0452d4:	00000206 	br	d0452e0 <dhc_setup+0x1bc>
   {
      /* let other tasks spin. This is required, since some systems
       * increment cticks in tasks, or use a polling task to receive
       * packets. Without this activity this loop will never exit.
       */
      tk_yield();
 d0452d8:	d0252d40 	call	d0252d4 <tk_yield>
      pktdemux();
 d0452dc:	d021b300 	call	d021b30 <pktdemux>
   /* wait for DHCP activity to conclude */
   /* 
    * Altera Niche Stack Nios port modification:
    * Increase DHCP timeout to > 2 minutes 
    */
   while (((cticks - dhcp_started) < (130*TPS)) &&
 d0452e0:	00834174 	movhi	r2,3333
 d0452e4:	108ac904 	addi	r2,r2,11044
 d0452e8:	10c00017 	ldw	r3,0(r2)
 d0452ec:	e0bffa17 	ldw	r2,-24(fp)
 d0452f0:	1885c83a 	sub	r2,r3,r2
 d0452f4:	108cb228 	cmpgeui	r2,r2,13000
 d0452f8:	1000031e 	bne	r2,zero,d045308 <dhc_setup+0x1e4>
 d0452fc:	d0282940 	call	d028294 <dhc_alldone>
 d045300:	1005003a 	cmpeq	r2,r2,zero
 d045304:	103ff41e 	bne	r2,zero,d0452d8 <dhc_setup+0x1b4>
#ifdef SUPERLOOP
      dhc_second ();
#endif
   }

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
 d045308:	d0282940 	call	d028294 <dhc_alldone>
 d04530c:	1004c03a 	cmpne	r2,r2,zero
 d045310:	1000201e 	bne	r2,zero,d045394 <dhc_setup+0x270>
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
 d045314:	01034174 	movhi	r4,3333
 d045318:	21010704 	addi	r4,r4,1052
 d04531c:	d002cc00 	call	d002cc0 <puts>
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 d045320:	e03ffb15 	stw	zero,-20(fp)
 d045324:	00001806 	br	d045388 <dhc_setup+0x264>
      {
         if (dhc_ifacedone(iface) == FALSE)
 d045328:	e13ffb17 	ldw	r4,-20(fp)
 d04532c:	d0283240 	call	d028324 <dhc_ifacedone>
 d045330:	1004c03a 	cmpne	r2,r2,zero
 d045334:	1000111e 	bne	r2,zero,d04537c <dhc_setup+0x258>
         {
            dhc_halt(iface);
 d045338:	e13ffb17 	ldw	r4,-20(fp)
 d04533c:	d027fdc0 	call	d027fdc <dhc_halt>
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
 d045340:	e0bffb17 	ldw	r2,-20(fp)
 d045344:	00c341b4 	movhi	r3,3334
 d045348:	18f2a504 	addi	r3,r3,-13676
 d04534c:	1085883a 	add	r2,r2,r2
 d045350:	1085883a 	add	r2,r2,r2
 d045354:	10c5883a 	add	r2,r2,r3
 d045358:	10c00017 	ldw	r3,0(r2)
 d04535c:	e0bffb17 	ldw	r2,-20(fp)
 d045360:	1085883a 	add	r2,r2,r2
 d045364:	1085883a 	add	r2,r2,r2
 d045368:	e13ff804 	addi	r4,fp,-32
 d04536c:	1105883a 	add	r2,r2,r4
 d045370:	10800404 	addi	r2,r2,16
 d045374:	10800017 	ldw	r2,0(r2)
 d045378:	18800a15 	stw	r2,40(r3)

   if (dhc_alldone() == FALSE)   /* dhcp timed out? */
   {
      dprintf("DHCP timed out, going back to default IP address(es)\n");
      /* go back to defaults */
      for (iface = 0; iface < STATIC_NETS; iface++)
 d04537c:	e0bffb17 	ldw	r2,-20(fp)
 d045380:	10800044 	addi	r2,r2,1
 d045384:	e0bffb15 	stw	r2,-20(fp)
 d045388:	e0bffb17 	ldw	r2,-20(fp)
 d04538c:	10800110 	cmplti	r2,r2,4
 d045390:	103fe51e 	bne	r2,zero,d045328 <dhc_setup+0x204>
            dhc_halt(iface);
            nets[iface]->n_ipaddr = dhcp_saveaddr[iface];
         }
      }
   }
}
 d045394:	e037883a 	mov	sp,fp
 d045398:	dfc00117 	ldw	ra,4(sp)
 d04539c:	df000017 	ldw	fp,0(sp)
 d0453a0:	dec00204 	addi	sp,sp,8
 d0453a4:	f800283a 	ret

0d0453a8 <dhc_main_ipset>:
 * RETURNS: 
 */

int
dhc_main_ipset(int iface, int state)
{
 d0453a8:	defffc04 	addi	sp,sp,-16
 d0453ac:	dfc00315 	stw	ra,12(sp)
 d0453b0:	df000215 	stw	fp,8(sp)
 d0453b4:	df000204 	addi	fp,sp,8
 d0453b8:	e13ffe15 	stw	r4,-8(fp)
 d0453bc:	e17fff15 	stw	r5,-4(fp)
   if ( state == DHCS_BOUND )
 d0453c0:	e0bfff17 	ldw	r2,-4(fp)
 d0453c4:	10800198 	cmpnei	r2,r2,6
 d0453c8:	1000321e 	bne	r2,zero,d045494 <dhc_main_ipset+0xec>
   {
      /* print IP address acquired through DHCP Client - for user's benefit */
      printf("Acquired IP address via DHCP client for interface: %s\n",
 d0453cc:	e0bffe17 	ldw	r2,-8(fp)
 d0453d0:	00c341b4 	movhi	r3,3334
 d0453d4:	18f2a504 	addi	r3,r3,-13676
 d0453d8:	1085883a 	add	r2,r2,r2
 d0453dc:	1085883a 	add	r2,r2,r2
 d0453e0:	10c5883a 	add	r2,r2,r3
 d0453e4:	10800017 	ldw	r2,0(r2)
 d0453e8:	11400104 	addi	r5,r2,4
 d0453ec:	01034174 	movhi	r4,3333
 d0453f0:	21011504 	addi	r4,r4,1108
 d0453f4:	d0029980 	call	d002998 <printf>
              nets[iface]->name);

      printf("IP address : %s\n", print_ipad(nets[iface]->n_ipaddr));
 d0453f8:	e0bffe17 	ldw	r2,-8(fp)
 d0453fc:	00c341b4 	movhi	r3,3334
 d045400:	18f2a504 	addi	r3,r3,-13676
 d045404:	1085883a 	add	r2,r2,r2
 d045408:	1085883a 	add	r2,r2,r2
 d04540c:	10c5883a 	add	r2,r2,r3
 d045410:	10800017 	ldw	r2,0(r2)
 d045414:	11000a17 	ldw	r4,40(r2)
 d045418:	d02448c0 	call	d02448c <print_ipad>
 d04541c:	100b883a 	mov	r5,r2
 d045420:	01034174 	movhi	r4,3333
 d045424:	21012304 	addi	r4,r4,1164
 d045428:	d0029980 	call	d002998 <printf>
      printf("Subnet Mask: %s\n", print_ipad(nets[iface]->snmask));
 d04542c:	e0bffe17 	ldw	r2,-8(fp)
 d045430:	00c341b4 	movhi	r3,3334
 d045434:	18f2a504 	addi	r3,r3,-13676
 d045438:	1085883a 	add	r2,r2,r2
 d04543c:	1085883a 	add	r2,r2,r2
 d045440:	10c5883a 	add	r2,r2,r3
 d045444:	10800017 	ldw	r2,0(r2)
 d045448:	11000c17 	ldw	r4,48(r2)
 d04544c:	d02448c0 	call	d02448c <print_ipad>
 d045450:	100b883a 	mov	r5,r2
 d045454:	01034174 	movhi	r4,3333
 d045458:	21012804 	addi	r4,r4,1184
 d04545c:	d0029980 	call	d002998 <printf>
      printf("Gateway    : %s\n", print_ipad(nets[iface]->n_defgw));
 d045460:	e0bffe17 	ldw	r2,-8(fp)
 d045464:	00c341b4 	movhi	r3,3334
 d045468:	18f2a504 	addi	r3,r3,-13676
 d04546c:	1085883a 	add	r2,r2,r2
 d045470:	1085883a 	add	r2,r2,r2
 d045474:	10c5883a 	add	r2,r2,r3
 d045478:	10800017 	ldw	r2,0(r2)
 d04547c:	11000d17 	ldw	r4,52(r2)
 d045480:	d02448c0 	call	d02448c <print_ipad>
 d045484:	100b883a 	mov	r5,r2
 d045488:	01034174 	movhi	r4,3333
 d04548c:	21012d04 	addi	r4,r4,1204
 d045490:	d0029980 	call	d002998 <printf>
   }
   return 0;
 d045494:	0005883a 	mov	r2,zero
}
 d045498:	e037883a 	mov	sp,fp
 d04549c:	dfc00117 	ldw	ra,4(sp)
 d0454a0:	df000017 	ldw	fp,0(sp)
 d0454a4:	dec00204 	addi	sp,sp,8
 d0454a8:	f800283a 	ret

0d0454ac <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 d0454ac:	deffff04 	addi	sp,sp,-4
 d0454b0:	df000015 	stw	fp,0(sp)
 d0454b4:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 d0454b8:	00834174 	movhi	r2,3333
 d0454bc:	108af504 	addi	r2,r2,11220
 d0454c0:	10c00017 	ldw	r3,0(r2)
 d0454c4:	00834174 	movhi	r2,3333
 d0454c8:	1089c604 	addi	r2,r2,10008
 d0454cc:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 d0454d0:	00c34174 	movhi	r3,3333
 d0454d4:	18caf504 	addi	r3,r3,11220
 d0454d8:	00834174 	movhi	r2,3333
 d0454dc:	1089c604 	addi	r2,r2,10008
 d0454e0:	18800015 	stw	r2,0(r3)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 d0454e4:	00834174 	movhi	r2,3333
 d0454e8:	108af704 	addi	r2,r2,11228
 d0454ec:	10c00017 	ldw	r3,0(r2)
 d0454f0:	00834174 	movhi	r2,3333
 d0454f4:	1089cf04 	addi	r2,r2,10044
 d0454f8:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 d0454fc:	00c34174 	movhi	r3,3333
 d045500:	18c9f004 	addi	r3,r3,10176
 d045504:	00834174 	movhi	r2,3333
 d045508:	108af704 	addi	r2,r2,11228
 d04550c:	10c00015 	stw	r3,0(r2)

   return 0;
 d045510:	0005883a 	mov	r2,zero
}
 d045514:	e037883a 	mov	sp,fp
 d045518:	df000017 	ldw	fp,0(sp)
 d04551c:	dec00104 	addi	sp,sp,4
 d045520:	f800283a 	ret

0d045524 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 d045524:	defffd04 	addi	sp,sp,-12
 d045528:	df000215 	stw	fp,8(sp)
 d04552c:	df000204 	addi	fp,sp,8
 d045530:	e13ffe15 	stw	r4,-8(fp)
 d045534:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 d045538:	0005883a 	mov	r2,zero
}
 d04553c:	e037883a 	mov	sp,fp
 d045540:	df000017 	ldw	fp,0(sp)
 d045544:	dec00104 	addi	sp,sp,4
 d045548:	f800283a 	ret

0d04554c <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 d04554c:	defffe04 	addi	sp,sp,-8
 d045550:	df000115 	stw	fp,4(sp)
 d045554:	df000104 	addi	fp,sp,4
 d045558:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 d04555c:	e037883a 	mov	sp,fp
 d045560:	df000017 	ldw	fp,0(sp)
 d045564:	dec00104 	addi	sp,sp,4
 d045568:	f800283a 	ret

0d04556c <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d04556c:	defff604 	addi	sp,sp,-40
 d045570:	dfc00915 	stw	ra,36(sp)
 d045574:	df000815 	stw	fp,32(sp)
 d045578:	df000804 	addi	fp,sp,32
 d04557c:	e13ffb15 	stw	r4,-20(fp)
 d045580:	e17ffc15 	stw	r5,-16(fp)
 d045584:	e1bffd15 	stw	r6,-12(fp)
 d045588:	e1fffe15 	stw	r7,-8(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 d04558c:	00800834 	movhi	r2,32
 d045590:	e0bff815 	stw	r2,-32(fp)
   if(vfd && vfd->file)
 d045594:	e0bffe17 	ldw	r2,-8(fp)
 d045598:	1005003a 	cmpeq	r2,r2,zero
 d04559c:	1000081e 	bne	r2,zero,d0455c0 <md_fread+0x54>
 d0455a0:	e0bffe17 	ldw	r2,-8(fp)
 d0455a4:	10800117 	ldw	r2,4(r2)
 d0455a8:	1005003a 	cmpeq	r2,r2,zero
 d0455ac:	1000041e 	bne	r2,zero,d0455c0 <md_fread+0x54>
   {
      file_size = vfd->file->real_size; 
 d0455b0:	e0bffe17 	ldw	r2,-8(fp)
 d0455b4:	10800117 	ldw	r2,4(r2)
 d0455b8:	10800717 	ldw	r2,28(r2)
 d0455bc:	e0bff815 	stw	r2,-32(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 d0455c0:	e0bffe17 	ldw	r2,-8(fp)
 d0455c4:	10800217 	ldw	r2,8(r2)
 d0455c8:	1007883a 	mov	r3,r2
 d0455cc:	e0bffe17 	ldw	r2,-8(fp)
 d0455d0:	10800117 	ldw	r2,4(r2)
 d0455d4:	10800617 	ldw	r2,24(r2)
 d0455d8:	1885c83a 	sub	r2,r3,r2
 d0455dc:	e0bff915 	stw	r2,-28(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 d0455e0:	e0fffd17 	ldw	r3,-12(fp)
 d0455e4:	e0bffc17 	ldw	r2,-16(fp)
 d0455e8:	1885383a 	mul	r2,r3,r2
 d0455ec:	e0bffa15 	stw	r2,-24(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 d0455f0:	e0fff917 	ldw	r3,-28(fp)
 d0455f4:	e0bffa17 	ldw	r2,-24(fp)
 d0455f8:	1887883a 	add	r3,r3,r2
 d0455fc:	e0bff817 	ldw	r2,-32(fp)
 d045600:	10c0042e 	bgeu	r2,r3,d045614 <md_fread+0xa8>
      bcount = ((u_long)file_size - location);
 d045604:	e0bff817 	ldw	r2,-32(fp)
 d045608:	e0fff917 	ldw	r3,-28(fp)
 d04560c:	10c5c83a 	sub	r2,r2,r3
 d045610:	e0bffa15 	stw	r2,-24(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 d045614:	e0fff917 	ldw	r3,-28(fp)
 d045618:	e0bff817 	ldw	r2,-32(fp)
 d04561c:	1880072e 	bgeu	r3,r2,d04563c <md_fread+0xd0>
 d045620:	e0bffa17 	ldw	r2,-24(fp)
 d045624:	10bfffec 	andhi	r2,r2,65535
 d045628:	1004c03a 	cmpne	r2,r2,zero
 d04562c:	1000031e 	bne	r2,zero,d04563c <md_fread+0xd0>
 d045630:	e0bffa17 	ldw	r2,-24(fp)
 d045634:	1004c03a 	cmpne	r2,r2,zero
 d045638:	1000021e 	bne	r2,zero,d045644 <md_fread+0xd8>
      (bcount  & 0xFFFF0000) ||
      (bcount == 0))
   {
      return 0;
 d04563c:	e03fff15 	stw	zero,-4(fp)
 d045640:	00002406 	br	d0456d4 <md_fread+0x168>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 d045644:	e0bffe17 	ldw	r2,-8(fp)
 d045648:	10800117 	ldw	r2,4(r2)
 d04564c:	1080058b 	ldhu	r2,22(r2)
 d045650:	10bfffcc 	andi	r2,r2,65535
 d045654:	10a0001c 	xori	r2,r2,32768
 d045658:	10a00004 	addi	r2,r2,-32768
 d04565c:	1004803a 	cmplt	r2,r2,zero
 d045660:	1000111e 	bne	r2,zero,d0456a8 <md_fread+0x13c>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 d045664:	e0bffe17 	ldw	r2,-8(fp)
 d045668:	10800117 	ldw	r2,4(r2)
 d04566c:	10800103 	ldbu	r2,4(r2)
 d045670:	10803fcc 	andi	r2,r2,255
 d045674:	1080201c 	xori	r2,r2,128
 d045678:	10bfe004 	addi	r2,r2,-128
 d04567c:	10801b58 	cmpnei	r2,r2,109
 d045680:	1000091e 	bne	r2,zero,d0456a8 <md_fread+0x13c>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 d045684:	e0bffe17 	ldw	r2,-8(fp)
 d045688:	10c00217 	ldw	r3,8(r2)
 d04568c:	00800834 	movhi	r2,32
 d045690:	1887883a 	add	r3,r3,r2
 d045694:	e0bffb17 	ldw	r2,-20(fp)
 d045698:	1009883a 	mov	r4,r2
 d04569c:	180b883a 	mov	r5,r3
 d0456a0:	e1bffa17 	ldw	r6,-24(fp)
 d0456a4:	d0027000 	call	d002700 <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 d0456a8:	e0bffe17 	ldw	r2,-8(fp)
 d0456ac:	10c00217 	ldw	r3,8(r2)
 d0456b0:	e0bffa17 	ldw	r2,-24(fp)
 d0456b4:	1887883a 	add	r3,r3,r2
 d0456b8:	e0bffe17 	ldw	r2,-8(fp)
 d0456bc:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 d0456c0:	e0bffa17 	ldw	r2,-24(fp)
 d0456c4:	1007883a 	mov	r3,r2
 d0456c8:	e0bffc17 	ldw	r2,-16(fp)
 d0456cc:	1885203a 	divu	r2,r3,r2
 d0456d0:	e0bfff15 	stw	r2,-4(fp)
 d0456d4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0456d8:	e037883a 	mov	sp,fp
 d0456dc:	dfc00117 	ldw	ra,4(sp)
 d0456e0:	df000017 	ldw	fp,0(sp)
 d0456e4:	dec00204 	addi	sp,sp,8
 d0456e8:	f800283a 	ret

0d0456ec <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d0456ec:	defffa04 	addi	sp,sp,-24
 d0456f0:	df000515 	stw	fp,20(sp)
 d0456f4:	df000504 	addi	fp,sp,20
 d0456f8:	e13ffb15 	stw	r4,-20(fp)
 d0456fc:	e17ffc15 	stw	r5,-16(fp)
 d045700:	e1bffd15 	stw	r6,-12(fp)
 d045704:	e1fffe15 	stw	r7,-8(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 d045708:	e0bffe17 	ldw	r2,-8(fp)
 d04570c:	10800117 	ldw	r2,4(r2)
 d045710:	10800103 	ldbu	r2,4(r2)
 d045714:	10803fcc 	andi	r2,r2,255
 d045718:	1080201c 	xori	r2,r2,128
 d04571c:	10bfe004 	addi	r2,r2,-128
 d045720:	10801b58 	cmpnei	r2,r2,109
 d045724:	1000021e 	bne	r2,zero,d045730 <md_fwrite+0x44>
      return 0;   /* not writable device */
 d045728:	e03fff15 	stw	zero,-4(fp)
 d04572c:	00000a06 	br	d045758 <md_fwrite+0x6c>

   vfd->cmploc += (items * size);   /* adjust location */
 d045730:	e0bffe17 	ldw	r2,-8(fp)
 d045734:	11000217 	ldw	r4,8(r2)
 d045738:	e0fffd17 	ldw	r3,-12(fp)
 d04573c:	e0bffc17 	ldw	r2,-16(fp)
 d045740:	1885383a 	mul	r2,r3,r2
 d045744:	2087883a 	add	r3,r4,r2
 d045748:	e0bffe17 	ldw	r2,-8(fp)
 d04574c:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 d045750:	e0bffd17 	ldw	r2,-12(fp)
 d045754:	e0bfff15 	stw	r2,-4(fp)
 d045758:	e0bfff17 	ldw	r2,-4(fp)
}
 d04575c:	e037883a 	mov	sp,fp
 d045760:	df000017 	ldw	fp,0(sp)
 d045764:	dec00104 	addi	sp,sp,4
 d045768:	f800283a 	ret

0d04576c <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 d04576c:	defffc04 	addi	sp,sp,-16
 d045770:	df000315 	stw	fp,12(sp)
 d045774:	df000304 	addi	fp,sp,12
 d045778:	e13ffd15 	stw	r4,-12(fp)
 d04577c:	e17ffe15 	stw	r5,-8(fp)
 d045780:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 d045784:	0005883a 	mov	r2,zero
}
 d045788:	e037883a 	mov	sp,fp
 d04578c:	df000017 	ldw	fp,0(sp)
 d045790:	dec00104 	addi	sp,sp,4
 d045794:	f800283a 	ret

0d045798 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 d045798:	defffe04 	addi	sp,sp,-8
 d04579c:	df000115 	stw	fp,4(sp)
 d0457a0:	df000104 	addi	fp,sp,4
 d0457a4:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 d0457a8:	00800834 	movhi	r2,32
}
 d0457ac:	e037883a 	mov	sp,fp
 d0457b0:	df000017 	ldw	fp,0(sp)
 d0457b4:	dec00104 	addi	sp,sp,4
 d0457b8:	f800283a 	ret

0d0457bc <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 d0457bc:	defffb04 	addi	sp,sp,-20
 d0457c0:	df000415 	stw	fp,16(sp)
 d0457c4:	df000404 	addi	fp,sp,16
 d0457c8:	e13ffe15 	stw	r4,-8(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 d0457cc:	e03ffc15 	stw	zero,-16(fp)

   location = vfd->cmploc - vfd->file->data;
 d0457d0:	e0bffe17 	ldw	r2,-8(fp)
 d0457d4:	10800217 	ldw	r2,8(r2)
 d0457d8:	1007883a 	mov	r3,r2
 d0457dc:	e0bffe17 	ldw	r2,-8(fp)
 d0457e0:	10800117 	ldw	r2,4(r2)
 d0457e4:	10800617 	ldw	r2,24(r2)
 d0457e8:	1885c83a 	sub	r2,r3,r2
 d0457ec:	e0bffd15 	stw	r2,-12(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 d0457f0:	e0bffe17 	ldw	r2,-8(fp)
 d0457f4:	10800117 	ldw	r2,4(r2)
 d0457f8:	10c00717 	ldw	r3,28(r2)
 d0457fc:	e0bffd17 	ldw	r2,-12(fp)
 d045800:	10c00336 	bltu	r2,r3,d045810 <md_fgetc+0x54>
      return EOF;
 d045804:	00bfffc4 	movi	r2,-1
 d045808:	e0bfff15 	stw	r2,-4(fp)
 d04580c:	00001c06 	br	d045880 <md_fgetc+0xc4>

   if (!(vfd->file->flags & VF_NODATA))
 d045810:	e0bffe17 	ldw	r2,-8(fp)
 d045814:	10800117 	ldw	r2,4(r2)
 d045818:	1080058b 	ldhu	r2,22(r2)
 d04581c:	10bfffcc 	andi	r2,r2,65535
 d045820:	10a0001c 	xori	r2,r2,32768
 d045824:	10a00004 	addi	r2,r2,-32768
 d045828:	1004803a 	cmplt	r2,r2,zero
 d04582c:	10000d1e 	bne	r2,zero,d045864 <md_fgetc+0xa8>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 d045830:	e0bffe17 	ldw	r2,-8(fp)
 d045834:	10800117 	ldw	r2,4(r2)
 d045838:	10800103 	ldbu	r2,4(r2)
 d04583c:	10803fcc 	andi	r2,r2,255
 d045840:	1080201c 	xori	r2,r2,128
 d045844:	10bfe004 	addi	r2,r2,-128
 d045848:	10801b58 	cmpnei	r2,r2,109
 d04584c:	1000051e 	bne	r2,zero,d045864 <md_fgetc+0xa8>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 d045850:	e0bffe17 	ldw	r2,-8(fp)
 d045854:	10800217 	ldw	r2,8(r2)
 d045858:	10800003 	ldbu	r2,0(r2)
 d04585c:	10803fcc 	andi	r2,r2,255
 d045860:	e0bffc15 	stw	r2,-16(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 d045864:	e0bffe17 	ldw	r2,-8(fp)
 d045868:	10800217 	ldw	r2,8(r2)
 d04586c:	10c00044 	addi	r3,r2,1
 d045870:	e0bffe17 	ldw	r2,-8(fp)
 d045874:	10c00215 	stw	r3,8(r2)
   return retval;
 d045878:	e0bffc17 	ldw	r2,-16(fp)
 d04587c:	e0bfff15 	stw	r2,-4(fp)
 d045880:	e0bfff17 	ldw	r2,-4(fp)
}
 d045884:	e037883a 	mov	sp,fp
 d045888:	df000017 	ldw	fp,0(sp)
 d04588c:	dec00104 	addi	sp,sp,4
 d045890:	f800283a 	ret

0d045894 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 d045894:	defffe04 	addi	sp,sp,-8
 d045898:	df000115 	stw	fp,4(sp)
 d04589c:	df000104 	addi	fp,sp,4
 d0458a0:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 d0458a4:	0005883a 	mov	r2,zero
}
 d0458a8:	e037883a 	mov	sp,fp
 d0458ac:	df000017 	ldw	fp,0(sp)
 d0458b0:	dec00104 	addi	sp,sp,4
 d0458b4:	f800283a 	ret

0d0458b8 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 d0458b8:	defff504 	addi	sp,sp,-44
 d0458bc:	dfc00a15 	stw	ra,40(sp)
 d0458c0:	df000915 	stw	fp,36(sp)
 d0458c4:	df000904 	addi	fp,sp,36
 d0458c8:	e13ffc15 	stw	r4,-16(fp)
 d0458cc:	e17ffd15 	stw	r5,-12(fp)
 d0458d0:	e1bffe15 	stw	r6,-8(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 d0458d4:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 d0458d8:	00834174 	movhi	r2,3333
 d0458dc:	10813204 	addi	r2,r2,1224
 d0458e0:	e0bff715 	stw	r2,-36(fp)

   cp = stringin;
 d0458e4:	e0bffe17 	ldw	r2,-8(fp)
 d0458e8:	e0bffa15 	stw	r2,-24(fp)
   while (*cp)
 d0458ec:	00002606 	br	d045988 <parse_ipad+0xd0>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 d0458f0:	e0bffa17 	ldw	r2,-24(fp)
 d0458f4:	10800003 	ldbu	r2,0(r2)
 d0458f8:	10803fcc 	andi	r2,r2,255
 d0458fc:	1080201c 	xori	r2,r2,128
 d045900:	10bfe004 	addi	r2,r2,-128
 d045904:	10800e88 	cmpgei	r2,r2,58
 d045908:	10000e1e 	bne	r2,zero,d045944 <parse_ipad+0x8c>
 d04590c:	e0bffa17 	ldw	r2,-24(fp)
 d045910:	10800003 	ldbu	r2,0(r2)
 d045914:	10803fcc 	andi	r2,r2,255
 d045918:	1080201c 	xori	r2,r2,128
 d04591c:	10bfe004 	addi	r2,r2,-128
 d045920:	10800b90 	cmplti	r2,r2,46
 d045924:	1000071e 	bne	r2,zero,d045944 <parse_ipad+0x8c>
 d045928:	e0bffa17 	ldw	r2,-24(fp)
 d04592c:	10800003 	ldbu	r2,0(r2)
 d045930:	10803fcc 	andi	r2,r2,255
 d045934:	1080201c 	xori	r2,r2,128
 d045938:	10bfe004 	addi	r2,r2,-128
 d04593c:	10800bd8 	cmpnei	r2,r2,47
 d045940:	1000041e 	bne	r2,zero,d045954 <parse_ipad+0x9c>
         return("all chars must be digits (0-9) or dots (.)");
 d045944:	00834174 	movhi	r2,3333
 d045948:	10813b04 	addi	r2,r2,1260
 d04594c:	e0bfff15 	stw	r2,-4(fp)
 d045950:	00009a06 	br	d045bbc <parse_ipad+0x304>
      if (*cp == '.')dots++;
 d045954:	e0bffa17 	ldw	r2,-24(fp)
 d045958:	10800003 	ldbu	r2,0(r2)
 d04595c:	10803fcc 	andi	r2,r2,255
 d045960:	1080201c 	xori	r2,r2,128
 d045964:	10bfe004 	addi	r2,r2,-128
 d045968:	10800b98 	cmpnei	r2,r2,46
 d04596c:	1000031e 	bne	r2,zero,d04597c <parse_ipad+0xc4>
 d045970:	e0bff917 	ldw	r2,-28(fp)
 d045974:	10800044 	addi	r2,r2,1
 d045978:	e0bff915 	stw	r2,-28(fp)
         cp++;
 d04597c:	e0bffa17 	ldw	r2,-24(fp)
 d045980:	10800044 	addi	r2,r2,1
 d045984:	e0bffa15 	stw	r2,-24(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 d045988:	e0bffa17 	ldw	r2,-24(fp)
 d04598c:	10800003 	ldbu	r2,0(r2)
 d045990:	10803fcc 	andi	r2,r2,255
 d045994:	1080201c 	xori	r2,r2,128
 d045998:	10bfe004 	addi	r2,r2,-128
 d04599c:	1004c03a 	cmpne	r2,r2,zero
 d0459a0:	103fd31e 	bne	r2,zero,d0458f0 <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 d0459a4:	e0bff917 	ldw	r2,-28(fp)
 d0459a8:	10800050 	cmplti	r2,r2,1
 d0459ac:	1000031e 	bne	r2,zero,d0459bc <parse_ipad+0x104>
 d0459b0:	e0bff917 	ldw	r2,-28(fp)
 d0459b4:	10800110 	cmplti	r2,r2,4
 d0459b8:	1000041e 	bne	r2,zero,d0459cc <parse_ipad+0x114>
      return("string must contain 1 - 3 dots (.)");
 d0459bc:	00834174 	movhi	r2,3333
 d0459c0:	10814604 	addi	r2,r2,1304
 d0459c4:	e0bfff15 	stw	r2,-4(fp)
 d0459c8:	00007c06 	br	d045bbc <parse_ipad+0x304>

   cp = stringin;
 d0459cc:	e0bffe17 	ldw	r2,-8(fp)
 d0459d0:	e0bffa15 	stw	r2,-24(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 d0459d4:	e13ffa17 	ldw	r4,-24(fp)
 d0459d8:	d049e4c0 	call	d049e4c <atoi>
 d0459dc:	e0bff815 	stw	r2,-32(fp)
 d0459e0:	e0bff817 	ldw	r2,-32(fp)
 d0459e4:	10804010 	cmplti	r2,r2,256
 d0459e8:	1000031e 	bne	r2,zero,d0459f8 <parse_ipad+0x140>
      return(toobig);
 d0459ec:	e0bff717 	ldw	r2,-36(fp)
 d0459f0:	e0bfff15 	stw	r2,-4(fp)
 d0459f4:	00007106 	br	d045bbc <parse_ipad+0x304>

   retval.c[0] = (u_char)number;
 d0459f8:	e0bff817 	ldw	r2,-32(fp)
 d0459fc:	e0bffb05 	stb	r2,-20(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 d045a00:	00000306 	br	d045a10 <parse_ipad+0x158>
 d045a04:	e0bffa17 	ldw	r2,-24(fp)
 d045a08:	10800044 	addi	r2,r2,1
 d045a0c:	e0bffa15 	stw	r2,-24(fp)
 d045a10:	e0bffa17 	ldw	r2,-24(fp)
 d045a14:	10800003 	ldbu	r2,0(r2)
 d045a18:	10803fcc 	andi	r2,r2,255
 d045a1c:	1080201c 	xori	r2,r2,128
 d045a20:	10bfe004 	addi	r2,r2,-128
 d045a24:	10800b98 	cmpnei	r2,r2,46
 d045a28:	103ff61e 	bne	r2,zero,d045a04 <parse_ipad+0x14c>
      cp++;             /* point past dot */
 d045a2c:	e0bffa17 	ldw	r2,-24(fp)
 d045a30:	10800044 	addi	r2,r2,1
 d045a34:	e0bffa15 	stw	r2,-24(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 d045a38:	e0bff917 	ldw	r2,-28(fp)
 d045a3c:	10800060 	cmpeqi	r2,r2,1
 d045a40:	1000031e 	bne	r2,zero,d045a50 <parse_ipad+0x198>
 d045a44:	e0bff917 	ldw	r2,-28(fp)
 d045a48:	10800098 	cmpnei	r2,r2,2
 d045a4c:	1000021e 	bne	r2,zero,d045a58 <parse_ipad+0x1a0>
 d045a50:	e03ffb45 	stb	zero,-19(fp)
 d045a54:	00001906 	br	d045abc <parse_ipad+0x204>
      else
   {
      number = atoi(cp);
 d045a58:	e13ffa17 	ldw	r4,-24(fp)
 d045a5c:	d049e4c0 	call	d049e4c <atoi>
 d045a60:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 d045a64:	00000306 	br	d045a74 <parse_ipad+0x1bc>
 d045a68:	e0bffa17 	ldw	r2,-24(fp)
 d045a6c:	10800044 	addi	r2,r2,1
 d045a70:	e0bffa15 	stw	r2,-24(fp)
 d045a74:	e0bffa17 	ldw	r2,-24(fp)
 d045a78:	10800003 	ldbu	r2,0(r2)
 d045a7c:	10803fcc 	andi	r2,r2,255
 d045a80:	1080201c 	xori	r2,r2,128
 d045a84:	10bfe004 	addi	r2,r2,-128
 d045a88:	10800b98 	cmpnei	r2,r2,46
 d045a8c:	103ff61e 	bne	r2,zero,d045a68 <parse_ipad+0x1b0>
         cp++;             /* point past dot */
 d045a90:	e0bffa17 	ldw	r2,-24(fp)
 d045a94:	10800044 	addi	r2,r2,1
 d045a98:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 d045a9c:	e0bff817 	ldw	r2,-32(fp)
 d045aa0:	10804010 	cmplti	r2,r2,256
 d045aa4:	1000031e 	bne	r2,zero,d045ab4 <parse_ipad+0x1fc>
 d045aa8:	e0bff717 	ldw	r2,-36(fp)
 d045aac:	e0bfff15 	stw	r2,-4(fp)
 d045ab0:	00004206 	br	d045bbc <parse_ipad+0x304>
         retval.c[1] = (u_char)number;
 d045ab4:	e0bff817 	ldw	r2,-32(fp)
 d045ab8:	e0bffb45 	stb	r2,-19(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 d045abc:	e0bff917 	ldw	r2,-28(fp)
 d045ac0:	10800058 	cmpnei	r2,r2,1
 d045ac4:	1000021e 	bne	r2,zero,d045ad0 <parse_ipad+0x218>
 d045ac8:	e03ffb85 	stb	zero,-18(fp)
 d045acc:	00001906 	br	d045b34 <parse_ipad+0x27c>
      else
   {
      number = atoi(cp);
 d045ad0:	e13ffa17 	ldw	r4,-24(fp)
 d045ad4:	d049e4c0 	call	d049e4c <atoi>
 d045ad8:	e0bff815 	stw	r2,-32(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 d045adc:	00000306 	br	d045aec <parse_ipad+0x234>
 d045ae0:	e0bffa17 	ldw	r2,-24(fp)
 d045ae4:	10800044 	addi	r2,r2,1
 d045ae8:	e0bffa15 	stw	r2,-24(fp)
 d045aec:	e0bffa17 	ldw	r2,-24(fp)
 d045af0:	10800003 	ldbu	r2,0(r2)
 d045af4:	10803fcc 	andi	r2,r2,255
 d045af8:	1080201c 	xori	r2,r2,128
 d045afc:	10bfe004 	addi	r2,r2,-128
 d045b00:	10800b98 	cmpnei	r2,r2,46
 d045b04:	103ff61e 	bne	r2,zero,d045ae0 <parse_ipad+0x228>
         cp++;             /* point past dot */
 d045b08:	e0bffa17 	ldw	r2,-24(fp)
 d045b0c:	10800044 	addi	r2,r2,1
 d045b10:	e0bffa15 	stw	r2,-24(fp)
      if (number > 255) return(toobig);
 d045b14:	e0bff817 	ldw	r2,-32(fp)
 d045b18:	10804010 	cmplti	r2,r2,256
 d045b1c:	1000031e 	bne	r2,zero,d045b2c <parse_ipad+0x274>
 d045b20:	e0bff717 	ldw	r2,-36(fp)
 d045b24:	e0bfff15 	stw	r2,-4(fp)
 d045b28:	00002406 	br	d045bbc <parse_ipad+0x304>
         retval.c[2] = (u_char)number;
 d045b2c:	e0bff817 	ldw	r2,-32(fp)
 d045b30:	e0bffb85 	stb	r2,-18(fp)
   }

   if ((number = atoi(cp)) > 255)
 d045b34:	e13ffa17 	ldw	r4,-24(fp)
 d045b38:	d049e4c0 	call	d049e4c <atoi>
 d045b3c:	e0bff815 	stw	r2,-32(fp)
 d045b40:	e0bff817 	ldw	r2,-32(fp)
 d045b44:	10804010 	cmplti	r2,r2,256
 d045b48:	1000031e 	bne	r2,zero,d045b58 <parse_ipad+0x2a0>
      return(toobig);
 d045b4c:	e0bff717 	ldw	r2,-36(fp)
 d045b50:	e0bfff15 	stw	r2,-4(fp)
 d045b54:	00001906 	br	d045bbc <parse_ipad+0x304>
   retval.c[3] = (u_char)number;
 d045b58:	e0bff817 	ldw	r2,-32(fp)
 d045b5c:	e0bffbc5 	stb	r2,-17(fp)

   if (retval.c[0] < 128) *sbits = 8;
 d045b60:	e0bffb03 	ldbu	r2,-20(fp)
 d045b64:	10803fcc 	andi	r2,r2,255
 d045b68:	10802028 	cmpgeui	r2,r2,128
 d045b6c:	1000041e 	bne	r2,zero,d045b80 <parse_ipad+0x2c8>
 d045b70:	e0fffd17 	ldw	r3,-12(fp)
 d045b74:	00800204 	movi	r2,8
 d045b78:	18800015 	stw	r2,0(r3)
 d045b7c:	00000b06 	br	d045bac <parse_ipad+0x2f4>
      else if(retval.c[0] < 192) *sbits = 16;
 d045b80:	e0bffb03 	ldbu	r2,-20(fp)
 d045b84:	10803fcc 	andi	r2,r2,255
 d045b88:	10803028 	cmpgeui	r2,r2,192
 d045b8c:	1000041e 	bne	r2,zero,d045ba0 <parse_ipad+0x2e8>
 d045b90:	e0fffd17 	ldw	r3,-12(fp)
 d045b94:	00800404 	movi	r2,16
 d045b98:	18800015 	stw	r2,0(r3)
 d045b9c:	00000306 	br	d045bac <parse_ipad+0x2f4>
      else *sbits = 24;
 d045ba0:	e0fffd17 	ldw	r3,-12(fp)
 d045ba4:	00800604 	movi	r2,24
 d045ba8:	18800015 	stw	r2,0(r3)

      *ipout = retval.l;      /* everything went OK, return number */
 d045bac:	e0fffb17 	ldw	r3,-20(fp)
 d045bb0:	e0bffc17 	ldw	r2,-16(fp)
 d045bb4:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 d045bb8:	e03fff15 	stw	zero,-4(fp)
 d045bbc:	e0bfff17 	ldw	r2,-4(fp)
}
 d045bc0:	e037883a 	mov	sp,fp
 d045bc4:	dfc00117 	ldw	ra,4(sp)
 d045bc8:	df000017 	ldw	fp,0(sp)
 d045bcc:	dec00204 	addi	sp,sp,8
 d045bd0:	f800283a 	ret

0d045bd4 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 d045bd4:	defffa04 	addi	sp,sp,-24
 d045bd8:	dfc00515 	stw	ra,20(sp)
 d045bdc:	df000415 	stw	fp,16(sp)
 d045be0:	df000404 	addi	fp,sp,16
 d045be4:	e13ffe15 	stw	r4,-8(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 d045be8:	01034174 	movhi	r4,3333
 d045bec:	210c9904 	addi	r4,r4,12900
 d045bf0:	e17ffe17 	ldw	r5,-8(fp)
 d045bf4:	d049f480 	call	d049f48 <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 d045bf8:	e17ffd04 	addi	r5,fp,-12
 d045bfc:	e13ffc04 	addi	r4,fp,-16
 d045c00:	01834174 	movhi	r6,3333
 d045c04:	318c9904 	addi	r6,r6,12900
 d045c08:	d0458b80 	call	d0458b8 <parse_ipad>
 d045c0c:	1004c03a 	cmpne	r2,r2,zero
 d045c10:	1000031e 	bne	r2,zero,d045c20 <inet_addr+0x4c>
   {
      return ipaddr ;
 d045c14:	e0bffc17 	ldw	r2,-16(fp)
 d045c18:	e0bfff15 	stw	r2,-4(fp)
 d045c1c:	00000106 	br	d045c24 <inet_addr+0x50>
   }
   else
   {
      return (u_long)NULL ;
 d045c20:	e03fff15 	stw	zero,-4(fp)
 d045c24:	e0bfff17 	ldw	r2,-4(fp)
   }
}
 d045c28:	e037883a 	mov	sp,fp
 d045c2c:	dfc00117 	ldw	ra,4(sp)
 d045c30:	df000017 	ldw	fp,0(sp)
 d045c34:	dec00204 	addi	sp,sp,8
 d045c38:	f800283a 	ret

0d045c3c <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 d045c3c:	defffd04 	addi	sp,sp,-12
 d045c40:	df000215 	stw	fp,8(sp)
 d045c44:	df000204 	addi	fp,sp,8
 d045c48:	e13ffe15 	stw	r4,-8(fp)
   val &= 0x0f;
 d045c4c:	e0bffe17 	ldw	r2,-8(fp)
 d045c50:	108003cc 	andi	r2,r2,15
 d045c54:	e0bffe15 	stw	r2,-8(fp)
   if(val < 10)
 d045c58:	e0bffe17 	ldw	r2,-8(fp)
 d045c5c:	10800288 	cmpgei	r2,r2,10
 d045c60:	1000071e 	bne	r2,zero,d045c80 <hextoa+0x44>
      return (char)(val + '0');
 d045c64:	e0bffe17 	ldw	r2,-8(fp)
 d045c68:	10800c04 	addi	r2,r2,48
 d045c6c:	10803fcc 	andi	r2,r2,255
 d045c70:	1080201c 	xori	r2,r2,128
 d045c74:	10bfe004 	addi	r2,r2,-128
 d045c78:	e0bfff15 	stw	r2,-4(fp)
 d045c7c:	00000606 	br	d045c98 <hextoa+0x5c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 d045c80:	e0bffe17 	ldw	r2,-8(fp)
 d045c84:	10800dc4 	addi	r2,r2,55
 d045c88:	10803fcc 	andi	r2,r2,255
 d045c8c:	1080201c 	xori	r2,r2,128
 d045c90:	10bfe004 	addi	r2,r2,-128
 d045c94:	e0bfff15 	stw	r2,-4(fp)
 d045c98:	e0bfff17 	ldw	r2,-4(fp)
}
 d045c9c:	e037883a 	mov	sp,fp
 d045ca0:	df000017 	ldw	fp,0(sp)
 d045ca4:	dec00104 	addi	sp,sp,4
 d045ca8:	f800283a 	ret

0d045cac <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 d045cac:	defff704 	addi	sp,sp,-36
 d045cb0:	dfc00815 	stw	ra,32(sp)
 d045cb4:	df000715 	stw	fp,28(sp)
 d045cb8:	df000704 	addi	fp,sp,28
 d045cbc:	e13ffc15 	stw	r4,-16(fp)
 d045cc0:	e17ffd15 	stw	r5,-12(fp)
 d045cc4:	e1bffe15 	stw	r6,-8(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 d045cc8:	e0bffc17 	ldw	r2,-16(fp)
 d045ccc:	10800098 	cmpnei	r2,r2,2
 d045cd0:	10001a1e 	bne	r2,zero,d045d3c <inet_pton+0x90>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 d045cd4:	e13ffa04 	addi	r4,fp,-24
 d045cd8:	e17ffb04 	addi	r5,fp,-20
 d045cdc:	e1bffd17 	ldw	r6,-12(fp)
 d045ce0:	d0458b80 	call	d0458b8 <parse_ipad>
 d045ce4:	e0bff915 	stw	r2,-28(fp)
      if(err == NULL)
 d045ce8:	e0bff917 	ldw	r2,-28(fp)
 d045cec:	1004c03a 	cmpne	r2,r2,zero
 d045cf0:	10000c1e 	bne	r2,zero,d045d24 <inet_pton+0x78>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 d045cf4:	e13ffe17 	ldw	r4,-8(fp)
 d045cf8:	e0fffa04 	addi	r3,fp,-24
 d045cfc:	18800003 	ldbu	r2,0(r3)
 d045d00:	20800005 	stb	r2,0(r4)
 d045d04:	18800043 	ldbu	r2,1(r3)
 d045d08:	20800045 	stb	r2,1(r4)
 d045d0c:	18800083 	ldbu	r2,2(r3)
 d045d10:	20800085 	stb	r2,2(r4)
 d045d14:	188000c3 	ldbu	r2,3(r3)
 d045d18:	208000c5 	stb	r2,3(r4)
         return 0;
 d045d1c:	e03fff15 	stw	zero,-4(fp)
 d045d20:	00000706 	br	d045d40 <inet_pton+0x94>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 d045d24:	00834174 	movhi	r2,3333
 d045d28:	10815004 	addi	r2,r2,1344
 d045d2c:	d0a05415 	stw	r2,-32432(gp)
         return 1;
 d045d30:	00800044 	movi	r2,1
 d045d34:	e0bfff15 	stw	r2,-4(fp)
 d045d38:	00000106 	br	d045d40 <inet_pton+0x94>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 d045d3c:	e03fff15 	stw	zero,-4(fp)
 d045d40:	e0bfff17 	ldw	r2,-4(fp)
}
 d045d44:	e037883a 	mov	sp,fp
 d045d48:	dfc00117 	ldw	ra,4(sp)
 d045d4c:	df000017 	ldw	fp,0(sp)
 d045d50:	dec00204 	addi	sp,sp,8
 d045d54:	f800283a 	ret

0d045d58 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 d045d58:	defff704 	addi	sp,sp,-36
 d045d5c:	dfc00815 	stw	ra,32(sp)
 d045d60:	df000715 	stw	fp,28(sp)
 d045d64:	df000704 	addi	fp,sp,28
 d045d68:	e13ffb15 	stw	r4,-20(fp)
 d045d6c:	e17ffc15 	stw	r5,-16(fp)
 d045d70:	e1bffd15 	stw	r6,-12(fp)
 d045d74:	e1fffe15 	stw	r7,-8(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 d045d78:	e0bffb17 	ldw	r2,-20(fp)
 d045d7c:	10800098 	cmpnei	r2,r2,2
 d045d80:	1000111e 	bne	r2,zero,d045dc8 <inet_ntop+0x70>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 d045d84:	e0bffc17 	ldw	r2,-16(fp)
 d045d88:	10800017 	ldw	r2,0(r2)
 d045d8c:	e0bff915 	stw	r2,-28(fp)
      cp = print_ipad(ip4addr);
 d045d90:	e13ff917 	ldw	r4,-28(fp)
 d045d94:	d02448c0 	call	d02448c <print_ipad>
 d045d98:	e0bffa15 	stw	r2,-24(fp)
      if (strlen(cp) < size)
 d045d9c:	e13ffa17 	ldw	r4,-24(fp)
 d045da0:	d00355c0 	call	d00355c <strlen>
 d045da4:	1007883a 	mov	r3,r2
 d045da8:	e0bffe17 	ldw	r2,-8(fp)
 d045dac:	1880062e 	bgeu	r3,r2,d045dc8 <inet_ntop+0x70>
      {
         strcpy(str, cp);
 d045db0:	e13ffd17 	ldw	r4,-12(fp)
 d045db4:	e17ffa17 	ldw	r5,-24(fp)
 d045db8:	d049f480 	call	d049f48 <strcpy>
         return (str);
 d045dbc:	e0bffd17 	ldw	r2,-12(fp)
 d045dc0:	e0bfff15 	stw	r2,-4(fp)
 d045dc4:	00000106 	br	d045dcc <inet_ntop+0x74>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 d045dc8:	e03fff15 	stw	zero,-4(fp)
 d045dcc:	e0bfff17 	ldw	r2,-4(fp)
}
 d045dd0:	e037883a 	mov	sp,fp
 d045dd4:	dfc00117 	ldw	ra,4(sp)
 d045dd8:	df000017 	ldw	fp,0(sp)
 d045ddc:	dec00204 	addi	sp,sp,8
 d045de0:	f800283a 	ret

0d045de4 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 d045de4:	defffb04 	addi	sp,sp,-20
 d045de8:	dfc00415 	stw	ra,16(sp)
 d045dec:	df000315 	stw	fp,12(sp)
 d045df0:	df000304 	addi	fp,sp,12
 d045df4:	e13ffe15 	stw	r4,-8(fp)
   if (ipaddr->sa_family == AF_INET)
 d045df8:	e0bffe17 	ldw	r2,-8(fp)
 d045dfc:	1080000b 	ldhu	r2,0(r2)
 d045e00:	10bfffcc 	andi	r2,r2,65535
 d045e04:	10800098 	cmpnei	r2,r2,2
 d045e08:	1000071e 	bne	r2,zero,d045e28 <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 d045e0c:	e0bffe17 	ldw	r2,-8(fp)
 d045e10:	e0bffd15 	stw	r2,-12(fp)
      return print_ipad(addr->sin_addr.s_addr);
 d045e14:	e0bffd17 	ldw	r2,-12(fp)
 d045e18:	11000117 	ldw	r4,4(r2)
 d045e1c:	d02448c0 	call	d02448c <print_ipad>
 d045e20:	e0bfff15 	stw	r2,-4(fp)
 d045e24:	00000106 	br	d045e2c <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 d045e28:	e03fff15 	stw	zero,-4(fp)
 d045e2c:	e0bfff17 	ldw	r2,-4(fp)
}
 d045e30:	e037883a 	mov	sp,fp
 d045e34:	dfc00117 	ldw	ra,4(sp)
 d045e38:	df000017 	ldw	fp,0(sp)
 d045e3c:	dec00204 	addi	sp,sp,8
 d045e40:	f800283a 	ret

0d045e44 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 d045e44:	defffb04 	addi	sp,sp,-20
 d045e48:	dfc00415 	stw	ra,16(sp)
 d045e4c:	df000315 	stw	fp,12(sp)
 d045e50:	df000304 	addi	fp,sp,12
 d045e54:	e13ffe15 	stw	r4,-8(fp)
 d045e58:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 d045e5c:	e0ffff17 	ldw	r3,-4(fp)
 d045e60:	00800084 	movi	r2,2
 d045e64:	1880000d 	sth	r2,0(r3)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 d045e68:	e0bffe17 	ldw	r2,-8(fp)
 d045e6c:	10800044 	addi	r2,r2,1
 d045e70:	10800003 	ldbu	r2,0(r2)
 d045e74:	10803fcc 	andi	r2,r2,255
 d045e78:	1080201c 	xori	r2,r2,128
 d045e7c:	10bfe004 	addi	r2,r2,-128
 d045e80:	10800ba0 	cmpeqi	r2,r2,46
 d045e84:	1000101e 	bne	r2,zero,d045ec8 <inet46_addr+0x84>
 d045e88:	e0bffe17 	ldw	r2,-8(fp)
 d045e8c:	10800084 	addi	r2,r2,2
 d045e90:	10800003 	ldbu	r2,0(r2)
 d045e94:	10803fcc 	andi	r2,r2,255
 d045e98:	1080201c 	xori	r2,r2,128
 d045e9c:	10bfe004 	addi	r2,r2,-128
 d045ea0:	10800ba0 	cmpeqi	r2,r2,46
 d045ea4:	1000081e 	bne	r2,zero,d045ec8 <inet46_addr+0x84>
 d045ea8:	e0bffe17 	ldw	r2,-8(fp)
 d045eac:	108000c4 	addi	r2,r2,3
 d045eb0:	10800003 	ldbu	r2,0(r2)
 d045eb4:	10803fcc 	andi	r2,r2,255
 d045eb8:	1080201c 	xori	r2,r2,128
 d045ebc:	10bfe004 	addi	r2,r2,-128
 d045ec0:	10800b98 	cmpnei	r2,r2,46
 d045ec4:	10000a1e 	bne	r2,zero,d045ef0 <inet46_addr+0xac>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 d045ec8:	e0bfff17 	ldw	r2,-4(fp)
 d045ecc:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 d045ed0:	e13ffe17 	ldw	r4,-8(fp)
 d045ed4:	d045bd40 	call	d045bd4 <inet_addr>
 d045ed8:	1007883a 	mov	r3,r2
 d045edc:	e0bffd17 	ldw	r2,-12(fp)
 d045ee0:	10c00115 	stw	r3,4(r2)
      addr->sin_family = AF_INET;
 d045ee4:	e0fffd17 	ldw	r3,-12(fp)
 d045ee8:	00800084 	movi	r2,2
 d045eec:	1880000d 	sth	r2,0(r3)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 d045ef0:	0005883a 	mov	r2,zero
}
 d045ef4:	e037883a 	mov	sp,fp
 d045ef8:	dfc00117 	ldw	ra,4(sp)
 d045efc:	df000017 	ldw	fp,0(sp)
 d045f00:	dec00204 	addi	sp,sp,8
 d045f04:	f800283a 	ret

0d045f08 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 d045f08:	defffc04 	addi	sp,sp,-16
 d045f0c:	df000315 	stw	fp,12(sp)
 d045f10:	df000304 	addi	fp,sp,12
 d045f14:	e13ffe15 	stw	r4,-8(fp)
 d045f18:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 d045f1c:	e0bffe17 	ldw	r2,-8(fp)
 d045f20:	1080000b 	ldhu	r2,0(r2)
 d045f24:	10bfffcc 	andi	r2,r2,65535
 d045f28:	10800098 	cmpnei	r2,r2,2
 d045f2c:	10000f1e 	bne	r2,zero,d045f6c <inet_setport+0x64>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 d045f30:	e0bffe17 	ldw	r2,-8(fp)
 d045f34:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 d045f38:	e0bfff17 	ldw	r2,-4(fp)
 d045f3c:	1005d23a 	srai	r2,r2,8
 d045f40:	10803fcc 	andi	r2,r2,255
 d045f44:	1009883a 	mov	r4,r2
 d045f48:	e0bfff17 	ldw	r2,-4(fp)
 d045f4c:	1004923a 	slli	r2,r2,8
 d045f50:	1007883a 	mov	r3,r2
 d045f54:	00bfc004 	movi	r2,-256
 d045f58:	1884703a 	and	r2,r3,r2
 d045f5c:	2084b03a 	or	r2,r4,r2
 d045f60:	1007883a 	mov	r3,r2
 d045f64:	e0bffd17 	ldw	r2,-12(fp)
 d045f68:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 d045f6c:	e037883a 	mov	sp,fp
 d045f70:	df000017 	ldw	fp,0(sp)
 d045f74:	dec00104 	addi	sp,sp,4
 d045f78:	f800283a 	ret

0d045f7c <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 d045f7c:	defff804 	addi	sp,sp,-32
 d045f80:	df000715 	stw	fp,28(sp)
 d045f84:	df000704 	addi	fp,sp,28
 d045f88:	e13ffe15 	stw	r4,-8(fp)
   const char *cp = p;
 d045f8c:	e0bffe17 	ldw	r2,-8(fp)
 d045f90:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 d045f94:	e0bffd04 	addi	r2,fp,-12
 d045f98:	e0bffb15 	stw	r2,-20(fp)
   int n = 0;
 d045f9c:	e03ffa15 	stw	zero,-24(fp)
   unsigned short v = 0;
 d045fa0:	e03ff90d 	sth	zero,-28(fp)
   dw = 0;
 d045fa4:	e03ffd15 	stw	zero,-12(fp)
   while(*cp)
 d045fa8:	00003306 	br	d046078 <convert_ip+0xfc>
   {
      if( *cp == '.')
 d045fac:	e0bffc17 	ldw	r2,-16(fp)
 d045fb0:	10800003 	ldbu	r2,0(r2)
 d045fb4:	10803fcc 	andi	r2,r2,255
 d045fb8:	1080201c 	xori	r2,r2,128
 d045fbc:	10bfe004 	addi	r2,r2,-128
 d045fc0:	10800b98 	cmpnei	r2,r2,46
 d045fc4:	1000101e 	bne	r2,zero,d046008 <convert_ip+0x8c>
      {
         lpb[n] = (unsigned char) v;
 d045fc8:	e0bffa17 	ldw	r2,-24(fp)
 d045fcc:	1007883a 	mov	r3,r2
 d045fd0:	e0bffb17 	ldw	r2,-20(fp)
 d045fd4:	1887883a 	add	r3,r3,r2
 d045fd8:	e0bff90b 	ldhu	r2,-28(fp)
 d045fdc:	18800005 	stb	r2,0(r3)
         v = 0;
 d045fe0:	e03ff90d 	sth	zero,-28(fp)
         n++;
 d045fe4:	e0bffa17 	ldw	r2,-24(fp)
 d045fe8:	10800044 	addi	r2,r2,1
 d045fec:	e0bffa15 	stw	r2,-24(fp)
         if(n > 3)
 d045ff0:	e0bffa17 	ldw	r2,-24(fp)
 d045ff4:	10800110 	cmplti	r2,r2,4
 d045ff8:	10001c1e 	bne	r2,zero,d04606c <convert_ip+0xf0>
         {
            return dw;
 d045ffc:	e0bffd17 	ldw	r2,-12(fp)
 d046000:	e0bfff15 	stw	r2,-4(fp)
 d046004:	00002b06 	br	d0460b4 <convert_ip+0x138>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 d046008:	e0bffc17 	ldw	r2,-16(fp)
 d04600c:	10800003 	ldbu	r2,0(r2)
 d046010:	10803fcc 	andi	r2,r2,255
 d046014:	1080201c 	xori	r2,r2,128
 d046018:	10bfe004 	addi	r2,r2,-128
 d04601c:	10800c10 	cmplti	r2,r2,48
 d046020:	1000121e 	bne	r2,zero,d04606c <convert_ip+0xf0>
 d046024:	e0bffc17 	ldw	r2,-16(fp)
 d046028:	10800003 	ldbu	r2,0(r2)
 d04602c:	10803fcc 	andi	r2,r2,255
 d046030:	1080201c 	xori	r2,r2,128
 d046034:	10bfe004 	addi	r2,r2,-128
 d046038:	10800e88 	cmpgei	r2,r2,58
 d04603c:	10000b1e 	bne	r2,zero,d04606c <convert_ip+0xf0>
      {
         v = (v * 10) + (*cp - '0');
 d046040:	e0bff90b 	ldhu	r2,-28(fp)
 d046044:	108002a4 	muli	r2,r2,10
 d046048:	1007883a 	mov	r3,r2
 d04604c:	e0bffc17 	ldw	r2,-16(fp)
 d046050:	10800003 	ldbu	r2,0(r2)
 d046054:	10803fcc 	andi	r2,r2,255
 d046058:	1080201c 	xori	r2,r2,128
 d04605c:	10bfe004 	addi	r2,r2,-128
 d046060:	1885883a 	add	r2,r3,r2
 d046064:	10bff404 	addi	r2,r2,-48
 d046068:	e0bff90d 	sth	r2,-28(fp)
      }
      cp++;
 d04606c:	e0bffc17 	ldw	r2,-16(fp)
 d046070:	10800044 	addi	r2,r2,1
 d046074:	e0bffc15 	stw	r2,-16(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 d046078:	e0bffc17 	ldw	r2,-16(fp)
 d04607c:	10800003 	ldbu	r2,0(r2)
 d046080:	10803fcc 	andi	r2,r2,255
 d046084:	1080201c 	xori	r2,r2,128
 d046088:	10bfe004 	addi	r2,r2,-128
 d04608c:	1004c03a 	cmpne	r2,r2,zero
 d046090:	103fc61e 	bne	r2,zero,d045fac <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 d046094:	e0bffa17 	ldw	r2,-24(fp)
 d046098:	1007883a 	mov	r3,r2
 d04609c:	e0bffb17 	ldw	r2,-20(fp)
 d0460a0:	1887883a 	add	r3,r3,r2
 d0460a4:	e0bff90b 	ldhu	r2,-28(fp)
 d0460a8:	18800005 	stb	r2,0(r3)
   return dw;
 d0460ac:	e0bffd17 	ldw	r2,-12(fp)
 d0460b0:	e0bfff15 	stw	r2,-4(fp)
 d0460b4:	e0bfff17 	ldw	r2,-4(fp)
}  /* convert_ip() */
 d0460b8:	e037883a 	mov	sp,fp
 d0460bc:	df000017 	ldw	fp,0(sp)
 d0460c0:	dec00104 	addi	sp,sp,4
 d0460c4:	f800283a 	ret

0d0460c8 <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 d0460c8:	defff804 	addi	sp,sp,-32
 d0460cc:	dfc00715 	stw	ra,28(sp)
 d0460d0:	df000615 	stw	fp,24(sp)
 d0460d4:	df000604 	addi	fp,sp,24
 d0460d8:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 d0460dc:	e03ffd15 	stw	zero,-12(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 d0460e0:	e03ffc05 	stb	zero,-16(fp)

   iphlen = (unshort)ip_hlen(pip);
 d0460e4:	e0bfff17 	ldw	r2,-4(fp)
 d0460e8:	10800003 	ldbu	r2,0(r2)
 d0460ec:	10803fcc 	andi	r2,r2,255
 d0460f0:	108003cc 	andi	r2,r2,15
 d0460f4:	1085883a 	add	r2,r2,r2
 d0460f8:	1085883a 	add	r2,r2,r2
 d0460fc:	e0bffe8d 	sth	r2,-6(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 d046100:	e0bfff17 	ldw	r2,-4(fp)
 d046104:	1080008b 	ldhu	r2,2(r2)
 d046108:	10bfffcc 	andi	r2,r2,65535
 d04610c:	1004d23a 	srli	r2,r2,8
 d046110:	10803fcc 	andi	r2,r2,255
 d046114:	1009883a 	mov	r4,r2
 d046118:	e0bfff17 	ldw	r2,-4(fp)
 d04611c:	1080008b 	ldhu	r2,2(r2)
 d046120:	10bfffcc 	andi	r2,r2,65535
 d046124:	1004923a 	slli	r2,r2,8
 d046128:	1007883a 	mov	r3,r2
 d04612c:	00bfc004 	movi	r2,-256
 d046130:	1884703a 	and	r2,r3,r2
 d046134:	2084b03a 	or	r2,r4,r2
 d046138:	1007883a 	mov	r3,r2
 d04613c:	e0bffe8b 	ldhu	r2,-6(fp)
 d046140:	1885c83a 	sub	r2,r3,r2
 d046144:	e0bffe0d 	sth	r2,-8(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 d046148:	e0bfff17 	ldw	r2,-4(fp)
 d04614c:	10800003 	ldbu	r2,0(r2)
 d046150:	10803fcc 	andi	r2,r2,255
 d046154:	108003cc 	andi	r2,r2,15
 d046158:	1085883a 	add	r2,r2,r2
 d04615c:	1085883a 	add	r2,r2,r2
 d046160:	1007883a 	mov	r3,r2
 d046164:	e0bfff17 	ldw	r2,-4(fp)
 d046168:	1885883a 	add	r2,r3,r2
 d04616c:	e0bffa15 	stw	r2,-24(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 d046170:	e0bffa17 	ldw	r2,-24(fp)
 d046174:	1080040b 	ldhu	r2,16(r2)
 d046178:	e0bffb8d 	sth	r2,-18(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 d04617c:	e0bffe0b 	ldhu	r2,-8(fp)
 d046180:	10800184 	addi	r2,r2,6
 d046184:	1005d23a 	srai	r2,r2,8
 d046188:	10803fcc 	andi	r2,r2,255
 d04618c:	1009883a 	mov	r4,r2
 d046190:	e0bffe0b 	ldhu	r2,-8(fp)
 d046194:	10800184 	addi	r2,r2,6
 d046198:	1004923a 	slli	r2,r2,8
 d04619c:	1007883a 	mov	r3,r2
 d0461a0:	00bfc004 	movi	r2,-256
 d0461a4:	1884703a 	and	r2,r3,r2
 d0461a8:	2084b03a 	or	r2,r4,r2
 d0461ac:	1007883a 	mov	r3,r2
 d0461b0:	e0bffa17 	ldw	r2,-24(fp)
 d0461b4:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 d0461b8:	e0bffe0b 	ldhu	r2,-8(fp)
 d0461bc:	1080004c 	andi	r2,r2,1
 d0461c0:	10803fcc 	andi	r2,r2,255
 d0461c4:	1005003a 	cmpeq	r2,r2,zero
 d0461c8:	10000f1e 	bne	r2,zero,d046208 <tcp_cksum+0x140>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 d0461cc:	e0bffe8b 	ldhu	r2,-6(fp)
 d0461d0:	1007883a 	mov	r3,r2
 d0461d4:	e0bfff17 	ldw	r2,-4(fp)
 d0461d8:	1887883a 	add	r3,r3,r2
 d0461dc:	e0bffe0b 	ldhu	r2,-8(fp)
 d0461e0:	1885883a 	add	r2,r3,r2
 d0461e4:	e0bffd15 	stw	r2,-12(fp)
      oddchar = *tcpdata;
 d0461e8:	e0bffd17 	ldw	r2,-12(fp)
 d0461ec:	10800003 	ldbu	r2,0(r2)
 d0461f0:	e0bffc05 	stb	r2,-16(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 d0461f4:	e0bffd17 	ldw	r2,-12(fp)
 d0461f8:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 d0461fc:	e0bffe0b 	ldhu	r2,-8(fp)
 d046200:	10800044 	addi	r2,r2,1
 d046204:	e0bffe0d 	sth	r2,-8(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 d046208:	e0bffa17 	ldw	r2,-24(fp)
 d04620c:	113ffe04 	addi	r4,r2,-8
 d046210:	e0bffe0b 	ldhu	r2,-8(fp)
 d046214:	10800204 	addi	r2,r2,8
 d046218:	1005d07a 	srai	r2,r2,1
 d04621c:	100b883a 	mov	r5,r2
 d046220:	d0242340 	call	d024234 <cksum>
 d046224:	0084303a 	nor	r2,zero,r2
 d046228:	e0bffb0d 	sth	r2,-20(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 d04622c:	e0fffb0b 	ldhu	r3,-20(fp)
 d046230:	e0bffb8b 	ldhu	r2,-18(fp)
 d046234:	18800826 	beq	r3,r2,d046258 <tcp_cksum+0x190>
 d046238:	e0fffb8b 	ldhu	r3,-18(fp)
 d04623c:	00bfffd4 	movui	r2,65535
 d046240:	1880051e 	bne	r3,r2,d046258 <tcp_cksum+0x190>
 d046244:	e0bffb0b 	ldhu	r2,-20(fp)
 d046248:	1004c03a 	cmpne	r2,r2,zero
 d04624c:	1000021e 	bne	r2,zero,d046258 <tcp_cksum+0x190>
      newsum = 0xffff;
 d046250:	00bfffc4 	movi	r2,-1
 d046254:	e0bffb0d 	sth	r2,-20(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 d046258:	e0fffa17 	ldw	r3,-24(fp)
 d04625c:	e0bffb8b 	ldhu	r2,-18(fp)
 d046260:	1880040d 	sth	r2,16(r3)
   if (oddchar)
 d046264:	e0bffc07 	ldb	r2,-16(fp)
 d046268:	1005003a 	cmpeq	r2,r2,zero
 d04626c:	1000031e 	bne	r2,zero,d04627c <tcp_cksum+0x1b4>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 d046270:	e0fffd17 	ldw	r3,-12(fp)
 d046274:	e0bffc03 	ldbu	r2,-16(fp)
 d046278:	18800005 	stb	r2,0(r3)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 d04627c:	e0bffb0b 	ldhu	r2,-20(fp)
}
 d046280:	e037883a 	mov	sp,fp
 d046284:	dfc00117 	ldw	ra,4(sp)
 d046288:	df000017 	ldw	fp,0(sp)
 d04628c:	dec00204 	addi	sp,sp,8
 d046290:	f800283a 	ret

0d046294 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 d046294:	defffa04 	addi	sp,sp,-24
 d046298:	dfc00515 	stw	ra,20(sp)
 d04629c:	df000415 	stw	fp,16(sp)
 d0462a0:	df000404 	addi	fp,sp,16
 d0462a4:	e13ffd15 	stw	r4,-12(fp)
 d0462a8:	e17ffe15 	stw	r5,-8(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 d0462ac:	01000b04 	movi	r4,44
 d0462b0:	d029e2c0 	call	d029e2c <npalloc>
 d0462b4:	e0bffc15 	stw	r2,-16(fp)
   if (inp == 0)
 d0462b8:	e0bffc17 	ldw	r2,-16(fp)
 d0462bc:	1004c03a 	cmpne	r2,r2,zero
 d0462c0:	1000031e 	bne	r2,zero,d0462d0 <in_pcballoc+0x3c>
      return ENOMEM;
 d0462c4:	00800304 	movi	r2,12
 d0462c8:	e0bfff15 	stw	r2,-4(fp)
 d0462cc:	00001006 	br	d046310 <in_pcballoc+0x7c>
   inp->inp_head = head;
 d0462d0:	e0fffc17 	ldw	r3,-16(fp)
 d0462d4:	e0bffe17 	ldw	r2,-8(fp)
 d0462d8:	18800215 	stw	r2,8(r3)
   inp->inp_socket = so;
 d0462dc:	e0fffc17 	ldw	r3,-16(fp)
 d0462e0:	e0bffd17 	ldw	r2,-12(fp)
 d0462e4:	18800815 	stw	r2,32(r3)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 d0462e8:	e0fffc17 	ldw	r3,-16(fp)
 d0462ec:	00808004 	movi	r2,512
 d0462f0:	18800615 	stw	r2,24(r3)
   insque(inp, head);
 d0462f4:	e13ffc17 	ldw	r4,-16(fp)
 d0462f8:	e17ffe17 	ldw	r5,-8(fp)
 d0462fc:	d02ab6c0 	call	d02ab6c <insque>
   so->so_pcb = inp;
 d046300:	e0fffd17 	ldw	r3,-12(fp)
 d046304:	e0bffc17 	ldw	r2,-16(fp)
 d046308:	18800115 	stw	r2,4(r3)
   return 0;
 d04630c:	e03fff15 	stw	zero,-4(fp)
 d046310:	e0bfff17 	ldw	r2,-4(fp)
}
 d046314:	e037883a 	mov	sp,fp
 d046318:	dfc00117 	ldw	ra,4(sp)
 d04631c:	df000017 	ldw	fp,0(sp)
 d046320:	dec00204 	addi	sp,sp,8
 d046324:	f800283a 	ret

0d046328 <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 d046328:	defffc04 	addi	sp,sp,-16
 d04632c:	dfc00315 	stw	ra,12(sp)
 d046330:	df000215 	stw	fp,8(sp)
 d046334:	df000204 	addi	fp,sp,8
 d046338:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 d04633c:	e0bfff17 	ldw	r2,-4(fp)
 d046340:	10800817 	ldw	r2,32(r2)
 d046344:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 d046348:	e0bffe17 	ldw	r2,-8(fp)
 d04634c:	10000115 	stw	zero,4(r2)
   sofree(so);
 d046350:	e13ffe17 	ldw	r4,-8(fp)
 d046354:	d02df340 	call	d02df34 <sofree>
   remque(inp);
 d046358:	e13fff17 	ldw	r4,-4(fp)
 d04635c:	d02aafc0 	call	d02aafc <remque>
   INP_FREE (inp);
 d046360:	e13fff17 	ldw	r4,-4(fp)
 d046364:	d029f200 	call	d029f20 <npfree>
}
 d046368:	e037883a 	mov	sp,fp
 d04636c:	dfc00117 	ldw	ra,4(sp)
 d046370:	df000017 	ldw	fp,0(sp)
 d046374:	dec00204 	addi	sp,sp,8
 d046378:	f800283a 	ret

0d04637c <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 d04637c:	defff404 	addi	sp,sp,-48
 d046380:	dfc00b15 	stw	ra,44(sp)
 d046384:	df000a15 	stw	fp,40(sp)
 d046388:	df000a04 	addi	fp,sp,40
 d04638c:	e13ffd15 	stw	r4,-12(fp)
 d046390:	e17ffe15 	stw	r5,-8(fp)
   struct socket *   so =  inp->inp_socket;
 d046394:	e0bffd17 	ldw	r2,-12(fp)
 d046398:	10800817 	ldw	r2,32(r2)
 d04639c:	e0bffc15 	stw	r2,-16(fp)
   struct inpcb * head  =  inp->inp_head;
 d0463a0:	e0bffd17 	ldw	r2,-12(fp)
 d0463a4:	10800217 	ldw	r2,8(r2)
 d0463a8:	e0bffb15 	stw	r2,-20(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 d0463ac:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 d0463b0:	e0bffd17 	ldw	r2,-12(fp)
 d0463b4:	1080078b 	ldhu	r2,30(r2)
 d0463b8:	10bfffcc 	andi	r2,r2,65535
 d0463bc:	1004c03a 	cmpne	r2,r2,zero
 d0463c0:	1000041e 	bne	r2,zero,d0463d4 <in_pcbbind+0x58>
 d0463c4:	e0bffd17 	ldw	r2,-12(fp)
 d0463c8:	10800417 	ldw	r2,16(r2)
 d0463cc:	1005003a 	cmpeq	r2,r2,zero
 d0463d0:	1000031e 	bne	r2,zero,d0463e0 <in_pcbbind+0x64>
      return (EINVAL);
 d0463d4:	00800584 	movi	r2,22
 d0463d8:	e0bfff15 	stw	r2,-4(fp)
 d0463dc:	00007606 	br	d0465b8 <in_pcbbind+0x23c>
   if (nam == 0)
 d0463e0:	e0bffe17 	ldw	r2,-8(fp)
 d0463e4:	1005003a 	cmpeq	r2,r2,zero
 d0463e8:	10003e1e 	bne	r2,zero,d0464e4 <in_pcbbind+0x168>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 d0463ec:	e0bffe17 	ldw	r2,-8(fp)
 d0463f0:	10800317 	ldw	r2,12(r2)
 d0463f4:	e0bffa15 	stw	r2,-24(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 d0463f8:	e0bffa17 	ldw	r2,-24(fp)
 d0463fc:	10800117 	ldw	r2,4(r2)
 d046400:	1005003a 	cmpeq	r2,r2,zero
 d046404:	10000a1e 	bne	r2,zero,d046430 <in_pcbbind+0xb4>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 d046408:	e0bffa17 	ldw	r2,-24(fp)
 d04640c:	11000117 	ldw	r4,4(r2)
 d046410:	d03e5a80 	call	d03e5a8 <ip_mymach>
 d046414:	1007883a 	mov	r3,r2
 d046418:	e0bffa17 	ldw	r2,-24(fp)
 d04641c:	10800117 	ldw	r2,4(r2)
 d046420:	18800326 	beq	r3,r2,d046430 <in_pcbbind+0xb4>
      return (EADDRNOTAVAIL);
 d046424:	00801f44 	movi	r2,125
 d046428:	e0bfff15 	stw	r2,-4(fp)
 d04642c:	00006206 	br	d0465b8 <in_pcbbind+0x23c>
   }
   lport = sin->sin_port;
 d046430:	e0bffa17 	ldw	r2,-24(fp)
 d046434:	1080008b 	ldhu	r2,2(r2)
 d046438:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 d04643c:	e0bff90b 	ldhu	r2,-28(fp)
 d046440:	1005003a 	cmpeq	r2,r2,zero
 d046444:	1000231e 	bne	r2,zero,d0464d4 <in_pcbbind+0x158>
   {
      int   wild  =  0;
 d046448:	e03ff815 	stw	zero,-32(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 d04644c:	e0bffc17 	ldw	r2,-16(fp)
 d046450:	10800417 	ldw	r2,16(r2)
 d046454:	1080010c 	andi	r2,r2,4
 d046458:	1004c03a 	cmpne	r2,r2,zero
 d04645c:	10000e1e 	bne	r2,zero,d046498 <in_pcbbind+0x11c>
 d046460:	e0bffc17 	ldw	r2,-16(fp)
 d046464:	10800217 	ldw	r2,8(r2)
 d046468:	1080010b 	ldhu	r2,4(r2)
 d04646c:	10bfffcc 	andi	r2,r2,65535
 d046470:	1080010c 	andi	r2,r2,4
 d046474:	1005003a 	cmpeq	r2,r2,zero
 d046478:	1000051e 	bne	r2,zero,d046490 <in_pcbbind+0x114>
 d04647c:	e0bffc17 	ldw	r2,-16(fp)
 d046480:	10800417 	ldw	r2,16(r2)
 d046484:	1080008c 	andi	r2,r2,2
 d046488:	1004c03a 	cmpne	r2,r2,zero
 d04648c:	1000021e 	bne	r2,zero,d046498 <in_pcbbind+0x11c>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 d046490:	00800044 	movi	r2,1
 d046494:	e0bff815 	stw	r2,-32(fp)
      }
      if (in_pcblookup(head,
 d046498:	e0bffa17 	ldw	r2,-24(fp)
 d04649c:	11c00117 	ldw	r7,4(r2)
 d0464a0:	e0bff90b 	ldhu	r2,-28(fp)
 d0464a4:	d8800015 	stw	r2,0(sp)
 d0464a8:	e0bff817 	ldw	r2,-32(fp)
 d0464ac:	d8800115 	stw	r2,4(sp)
 d0464b0:	e13ffb17 	ldw	r4,-20(fp)
 d0464b4:	000b883a 	mov	r5,zero
 d0464b8:	000d883a 	mov	r6,zero
 d0464bc:	d0469380 	call	d046938 <in_pcblookup>
 d0464c0:	1005003a 	cmpeq	r2,r2,zero
 d0464c4:	1000031e 	bne	r2,zero,d0464d4 <in_pcbbind+0x158>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 d0464c8:	00801c04 	movi	r2,112
 d0464cc:	e0bfff15 	stw	r2,-4(fp)
 d0464d0:	00003906 	br	d0465b8 <in_pcbbind+0x23c>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 d0464d4:	e0bffa17 	ldw	r2,-24(fp)
 d0464d8:	10c00117 	ldw	r3,4(r2)
 d0464dc:	e0bffd17 	ldw	r2,-12(fp)
 d0464e0:	10c00415 	stw	r3,16(r2)
noname:
   if (lport == 0)
 d0464e4:	e0bff90b 	ldhu	r2,-28(fp)
 d0464e8:	1004c03a 	cmpne	r2,r2,zero
 d0464ec:	10002e1e 	bne	r2,zero,d0465a8 <in_pcbbind+0x22c>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 d0464f0:	e0bffb17 	ldw	r2,-20(fp)
 d0464f4:	10c0078b 	ldhu	r3,30(r2)
 d0464f8:	18bfffcc 	andi	r2,r3,65535
 d0464fc:	10810030 	cmpltui	r2,r2,1024
 d046500:	1009883a 	mov	r4,r2
 d046504:	18800044 	addi	r2,r3,1
 d046508:	1007883a 	mov	r3,r2
 d04650c:	e0bffb17 	ldw	r2,-20(fp)
 d046510:	10c0078d 	sth	r3,30(r2)
 d046514:	20803fcc 	andi	r2,r4,255
 d046518:	1004c03a 	cmpne	r2,r2,zero
 d04651c:	1000051e 	bne	r2,zero,d046534 <in_pcbbind+0x1b8>
 d046520:	e0bffb17 	ldw	r2,-20(fp)
 d046524:	1080078b 	ldhu	r2,30(r2)
 d046528:	10bfffcc 	andi	r2,r2,65535
 d04652c:	1084e270 	cmpltui	r2,r2,5001
 d046530:	1000031e 	bne	r2,zero,d046540 <in_pcbbind+0x1c4>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 d046534:	e0fffb17 	ldw	r3,-20(fp)
 d046538:	00810004 	movi	r2,1024
 d04653c:	1880078d 	sth	r2,30(r3)
         }
         lport = htons(head->inp_lport);
 d046540:	e0bffb17 	ldw	r2,-20(fp)
 d046544:	1080078b 	ldhu	r2,30(r2)
 d046548:	10bfffcc 	andi	r2,r2,65535
 d04654c:	1004d23a 	srli	r2,r2,8
 d046550:	10803fcc 	andi	r2,r2,255
 d046554:	1009883a 	mov	r4,r2
 d046558:	e0bffb17 	ldw	r2,-20(fp)
 d04655c:	1080078b 	ldhu	r2,30(r2)
 d046560:	10bfffcc 	andi	r2,r2,65535
 d046564:	1004923a 	slli	r2,r2,8
 d046568:	1007883a 	mov	r3,r2
 d04656c:	00bfc004 	movi	r2,-256
 d046570:	1884703a 	and	r2,r3,r2
 d046574:	2084b03a 	or	r2,r4,r2
 d046578:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 d04657c:	e0bffd17 	ldw	r2,-12(fp)
 d046580:	11c00417 	ldw	r7,16(r2)
 d046584:	e0bff90b 	ldhu	r2,-28(fp)
 d046588:	d8800015 	stw	r2,0(sp)
 d04658c:	d8000115 	stw	zero,4(sp)
 d046590:	e13ffb17 	ldw	r4,-20(fp)
 d046594:	000b883a 	mov	r5,zero
 d046598:	000d883a 	mov	r6,zero
 d04659c:	d0469380 	call	d046938 <in_pcblookup>
 d0465a0:	1004c03a 	cmpne	r2,r2,zero
 d0465a4:	103fd21e 	bne	r2,zero,d0464f0 <in_pcbbind+0x174>
   }
   inp->inp_lport = lport;
 d0465a8:	e0fffd17 	ldw	r3,-12(fp)
 d0465ac:	e0bff90b 	ldhu	r2,-28(fp)
 d0465b0:	1880078d 	sth	r2,30(r3)
   return (0);
 d0465b4:	e03fff15 	stw	zero,-4(fp)
 d0465b8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0465bc:	e037883a 	mov	sp,fp
 d0465c0:	dfc00117 	ldw	ra,4(sp)
 d0465c4:	df000017 	ldw	fp,0(sp)
 d0465c8:	dec00204 	addi	sp,sp,8
 d0465cc:	f800283a 	ret

0d0465d0 <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 d0465d0:	defff504 	addi	sp,sp,-44
 d0465d4:	dfc00a15 	stw	ra,40(sp)
 d0465d8:	df000915 	stw	fp,36(sp)
 d0465dc:	df000904 	addi	fp,sp,36
 d0465e0:	e13ffd15 	stw	r4,-12(fp)
 d0465e4:	e17ffe15 	stw	r5,-8(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 d0465e8:	e0bffe17 	ldw	r2,-8(fp)
 d0465ec:	10800317 	ldw	r2,12(r2)
 d0465f0:	e0bffa15 	stw	r2,-24(fp)

   if (nam->m_len < sizeof (*sin))
 d0465f4:	e0bffe17 	ldw	r2,-8(fp)
 d0465f8:	10800217 	ldw	r2,8(r2)
 d0465fc:	10800428 	cmpgeui	r2,r2,16
 d046600:	1000031e 	bne	r2,zero,d046610 <in_pcbconnect+0x40>
      return (EINVAL);
 d046604:	00800584 	movi	r2,22
 d046608:	e0bfff15 	stw	r2,-4(fp)
 d04660c:	00006e06 	br	d0467c8 <in_pcbconnect+0x1f8>
   if (sin->sin_family != AF_INET)
 d046610:	e0bffa17 	ldw	r2,-24(fp)
 d046614:	1080000b 	ldhu	r2,0(r2)
 d046618:	10bfffcc 	andi	r2,r2,65535
 d04661c:	10a0001c 	xori	r2,r2,32768
 d046620:	10a00004 	addi	r2,r2,-32768
 d046624:	108000a0 	cmpeqi	r2,r2,2
 d046628:	1000031e 	bne	r2,zero,d046638 <in_pcbconnect+0x68>
      return (EAFNOSUPPORT);
 d04662c:	00801a84 	movi	r2,106
 d046630:	e0bfff15 	stw	r2,-4(fp)
 d046634:	00006406 	br	d0467c8 <in_pcbconnect+0x1f8>
   if (sin->sin_port == 0)
 d046638:	e0bffa17 	ldw	r2,-24(fp)
 d04663c:	1080008b 	ldhu	r2,2(r2)
 d046640:	10bfffcc 	andi	r2,r2,65535
 d046644:	1004c03a 	cmpne	r2,r2,zero
 d046648:	1000031e 	bne	r2,zero,d046658 <in_pcbconnect+0x88>
      return (EADDRNOTAVAIL);
 d04664c:	00801f44 	movi	r2,125
 d046650:	e0bfff15 	stw	r2,-4(fp)
 d046654:	00005c06 	br	d0467c8 <in_pcbconnect+0x1f8>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 d046658:	e0bffa17 	ldw	r2,-24(fp)
 d04665c:	10800117 	ldw	r2,4(r2)
 d046660:	1004c03a 	cmpne	r2,r2,zero
 d046664:	1000101e 	bne	r2,zero,d0466a8 <in_pcbconnect+0xd8>
   {
      if (inp && inp->ifp)
 d046668:	e0bffd17 	ldw	r2,-12(fp)
 d04666c:	1005003a 	cmpeq	r2,r2,zero
 d046670:	10000a1e 	bne	r2,zero,d04669c <in_pcbconnect+0xcc>
 d046674:	e0bffd17 	ldw	r2,-12(fp)
 d046678:	10800a17 	ldw	r2,40(r2)
 d04667c:	1005003a 	cmpeq	r2,r2,zero
 d046680:	1000061e 	bne	r2,zero,d04669c <in_pcbconnect+0xcc>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 d046684:	e0bffd17 	ldw	r2,-12(fp)
 d046688:	10800a17 	ldw	r2,40(r2)
 d04668c:	10c00a17 	ldw	r3,40(r2)
 d046690:	e0bffa17 	ldw	r2,-24(fp)
 d046694:	10c00115 	stw	r3,4(r2)
 d046698:	00000a06 	br	d0466c4 <in_pcbconnect+0xf4>
      else
         return (EADDRNOTAVAIL);
 d04669c:	00801f44 	movi	r2,125
 d0466a0:	e0bfff15 	stw	r2,-4(fp)
 d0466a4:	00004806 	br	d0467c8 <in_pcbconnect+0x1f8>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 d0466a8:	e0bffa17 	ldw	r2,-24(fp)
 d0466ac:	10800117 	ldw	r2,4(r2)
 d0466b0:	10bfffd8 	cmpnei	r2,r2,-1
 d0466b4:	1000031e 	bne	r2,zero,d0466c4 <in_pcbconnect+0xf4>
      return (EADDRNOTAVAIL);
 d0466b8:	00801f44 	movi	r2,125
 d0466bc:	e0bfff15 	stw	r2,-4(fp)
 d0466c0:	00004106 	br	d0467c8 <in_pcbconnect+0x1f8>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 d0466c4:	e0bffd17 	ldw	r2,-12(fp)
 d0466c8:	10800417 	ldw	r2,16(r2)
 d0466cc:	1004c03a 	cmpne	r2,r2,zero
 d0466d0:	10000f1e 	bne	r2,zero,d046710 <in_pcbconnect+0x140>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 d0466d4:	e0bffa17 	ldw	r2,-24(fp)
 d0466d8:	11000117 	ldw	r4,4(r2)
 d0466dc:	e17ffc04 	addi	r5,fp,-16
 d0466e0:	d03e90c0 	call	d03e90c <iproute>
 d0466e4:	e0bff915 	stw	r2,-28(fp)
      if (!npnet)
 d0466e8:	e0bff917 	ldw	r2,-28(fp)
 d0466ec:	1004c03a 	cmpne	r2,r2,zero
 d0466f0:	1000031e 	bne	r2,zero,d046700 <in_pcbconnect+0x130>
         return EADDRNOTAVAIL;
 d0466f4:	00801f44 	movi	r2,125
 d0466f8:	e0bfff15 	stw	r2,-4(fp)
 d0466fc:	00003206 	br	d0467c8 <in_pcbconnect+0x1f8>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 d046700:	e0bff917 	ldw	r2,-28(fp)
 d046704:	10800a17 	ldw	r2,40(r2)
 d046708:	e0bffb15 	stw	r2,-20(fp)
 d04670c:	00000306 	br	d04671c <in_pcbconnect+0x14c>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 d046710:	e0bffd17 	ldw	r2,-12(fp)
 d046714:	10800417 	ldw	r2,16(r2)
 d046718:	e0bffb15 	stw	r2,-20(fp)

   if (in_pcblookup(inp->inp_head,
 d04671c:	e0bffd17 	ldw	r2,-12(fp)
 d046720:	11000217 	ldw	r4,8(r2)
 d046724:	e0bffa17 	ldw	r2,-24(fp)
 d046728:	11400117 	ldw	r5,4(r2)
 d04672c:	e0bffa17 	ldw	r2,-24(fp)
 d046730:	1080008b 	ldhu	r2,2(r2)
 d046734:	11bfffcc 	andi	r6,r2,65535
 d046738:	e0bffd17 	ldw	r2,-12(fp)
 d04673c:	1080078b 	ldhu	r2,30(r2)
 d046740:	10bfffcc 	andi	r2,r2,65535
 d046744:	d8800015 	stw	r2,0(sp)
 d046748:	d8000115 	stw	zero,4(sp)
 d04674c:	e1fffb17 	ldw	r7,-20(fp)
 d046750:	d0469380 	call	d046938 <in_pcblookup>
 d046754:	1005003a 	cmpeq	r2,r2,zero
 d046758:	1000031e 	bne	r2,zero,d046768 <in_pcbconnect+0x198>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 d04675c:	00801c04 	movi	r2,112
 d046760:	e0bfff15 	stw	r2,-4(fp)
 d046764:	00001806 	br	d0467c8 <in_pcbconnect+0x1f8>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 d046768:	e0bffd17 	ldw	r2,-12(fp)
 d04676c:	10800417 	ldw	r2,16(r2)
 d046770:	1004c03a 	cmpne	r2,r2,zero
 d046774:	10000b1e 	bne	r2,zero,d0467a4 <in_pcbconnect+0x1d4>
   {
      if (inp->inp_lport == 0)
 d046778:	e0bffd17 	ldw	r2,-12(fp)
 d04677c:	1080078b 	ldhu	r2,30(r2)
 d046780:	10bfffcc 	andi	r2,r2,65535
 d046784:	1004c03a 	cmpne	r2,r2,zero
 d046788:	1000031e 	bne	r2,zero,d046798 <in_pcbconnect+0x1c8>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 d04678c:	e13ffd17 	ldw	r4,-12(fp)
 d046790:	000b883a 	mov	r5,zero
 d046794:	d04637c0 	call	d04637c <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 d046798:	e0fffd17 	ldw	r3,-12(fp)
 d04679c:	e0bffb17 	ldw	r2,-20(fp)
 d0467a0:	18800415 	stw	r2,16(r3)
   }
   inp->inp_faddr = sin->sin_addr;
 d0467a4:	e0bffa17 	ldw	r2,-24(fp)
 d0467a8:	10c00117 	ldw	r3,4(r2)
 d0467ac:	e0bffd17 	ldw	r2,-12(fp)
 d0467b0:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 d0467b4:	e0bffa17 	ldw	r2,-24(fp)
 d0467b8:	10c0008b 	ldhu	r3,2(r2)
 d0467bc:	e0bffd17 	ldw	r2,-12(fp)
 d0467c0:	10c0070d 	sth	r3,28(r2)
   return 0;
 d0467c4:	e03fff15 	stw	zero,-4(fp)
 d0467c8:	e0bfff17 	ldw	r2,-4(fp)
}
 d0467cc:	e037883a 	mov	sp,fp
 d0467d0:	dfc00117 	ldw	ra,4(sp)
 d0467d4:	df000017 	ldw	fp,0(sp)
 d0467d8:	dec00204 	addi	sp,sp,8
 d0467dc:	f800283a 	ret

0d0467e0 <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 d0467e0:	defffd04 	addi	sp,sp,-12
 d0467e4:	dfc00215 	stw	ra,8(sp)
 d0467e8:	df000115 	stw	fp,4(sp)
 d0467ec:	df000104 	addi	fp,sp,4
 d0467f0:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 d0467f4:	e0bfff17 	ldw	r2,-4(fp)
 d0467f8:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 d0467fc:	e0bfff17 	ldw	r2,-4(fp)
 d046800:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 d046804:	e0bfff17 	ldw	r2,-4(fp)
 d046808:	10800817 	ldw	r2,32(r2)
 d04680c:	1080088b 	ldhu	r2,34(r2)
 d046810:	10bfffcc 	andi	r2,r2,65535
 d046814:	1080004c 	andi	r2,r2,1
 d046818:	10803fcc 	andi	r2,r2,255
 d04681c:	1005003a 	cmpeq	r2,r2,zero
 d046820:	1000021e 	bne	r2,zero,d04682c <in_pcbdisconnect+0x4c>
      in_pcbdetach (inp);
 d046824:	e13fff17 	ldw	r4,-4(fp)
 d046828:	d0463280 	call	d046328 <in_pcbdetach>
}
 d04682c:	e037883a 	mov	sp,fp
 d046830:	dfc00117 	ldw	ra,4(sp)
 d046834:	df000017 	ldw	fp,0(sp)
 d046838:	dec00204 	addi	sp,sp,8
 d04683c:	f800283a 	ret

0d046840 <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 d046840:	defffc04 	addi	sp,sp,-16
 d046844:	df000315 	stw	fp,12(sp)
 d046848:	df000304 	addi	fp,sp,12
 d04684c:	e13ffe15 	stw	r4,-8(fp)
 d046850:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 d046854:	e0ffff17 	ldw	r3,-4(fp)
 d046858:	00800404 	movi	r2,16
 d04685c:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 d046860:	e0bfff17 	ldw	r2,-4(fp)
 d046864:	10800317 	ldw	r2,12(r2)
 d046868:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 d04686c:	e0bffd17 	ldw	r2,-12(fp)
 d046870:	10000015 	stw	zero,0(r2)
 d046874:	10000115 	stw	zero,4(r2)
 d046878:	10000215 	stw	zero,8(r2)
 d04687c:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 d046880:	e0fffd17 	ldw	r3,-12(fp)
 d046884:	00800084 	movi	r2,2
 d046888:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_lport;
 d04688c:	e0bffe17 	ldw	r2,-8(fp)
 d046890:	10c0078b 	ldhu	r3,30(r2)
 d046894:	e0bffd17 	ldw	r2,-12(fp)
 d046898:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 d04689c:	e0bffe17 	ldw	r2,-8(fp)
 d0468a0:	10c00417 	ldw	r3,16(r2)
 d0468a4:	e0bffd17 	ldw	r2,-12(fp)
 d0468a8:	10c00115 	stw	r3,4(r2)
}
 d0468ac:	e037883a 	mov	sp,fp
 d0468b0:	df000017 	ldw	fp,0(sp)
 d0468b4:	dec00104 	addi	sp,sp,4
 d0468b8:	f800283a 	ret

0d0468bc <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 d0468bc:	defffc04 	addi	sp,sp,-16
 d0468c0:	df000315 	stw	fp,12(sp)
 d0468c4:	df000304 	addi	fp,sp,12
 d0468c8:	e13ffe15 	stw	r4,-8(fp)
 d0468cc:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 d0468d0:	e0ffff17 	ldw	r3,-4(fp)
 d0468d4:	00800404 	movi	r2,16
 d0468d8:	18800215 	stw	r2,8(r3)
   sin = mtod(nam, struct sockaddr_in *);
 d0468dc:	e0bfff17 	ldw	r2,-4(fp)
 d0468e0:	10800317 	ldw	r2,12(r2)
 d0468e4:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 d0468e8:	e0bffd17 	ldw	r2,-12(fp)
 d0468ec:	10000015 	stw	zero,0(r2)
 d0468f0:	10000115 	stw	zero,4(r2)
 d0468f4:	10000215 	stw	zero,8(r2)
 d0468f8:	10000315 	stw	zero,12(r2)
   sin->sin_family = AF_INET;
 d0468fc:	e0fffd17 	ldw	r3,-12(fp)
 d046900:	00800084 	movi	r2,2
 d046904:	1880000d 	sth	r2,0(r3)
   sin->sin_port = inp->inp_fport;
 d046908:	e0bffe17 	ldw	r2,-8(fp)
 d04690c:	10c0070b 	ldhu	r3,28(r2)
 d046910:	e0bffd17 	ldw	r2,-12(fp)
 d046914:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 d046918:	e0bffe17 	ldw	r2,-8(fp)
 d04691c:	10c00317 	ldw	r3,12(r2)
 d046920:	e0bffd17 	ldw	r2,-12(fp)
 d046924:	10c00115 	stw	r3,4(r2)
}
 d046928:	e037883a 	mov	sp,fp
 d04692c:	df000017 	ldw	fp,0(sp)
 d046930:	dec00104 	addi	sp,sp,4
 d046934:	f800283a 	ret

0d046938 <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 d046938:	defff404 	addi	sp,sp,-48
 d04693c:	df000b15 	stw	fp,44(sp)
 d046940:	df000b04 	addi	fp,sp,44
 d046944:	e13ffa15 	stw	r4,-24(fp)
 d046948:	e17ffb15 	stw	r5,-20(fp)
 d04694c:	e1fffd15 	stw	r7,-12(fp)
 d046950:	e0800117 	ldw	r2,4(fp)
 d046954:	e1bffc0d 	sth	r6,-16(fp)
 d046958:	e0bffe0d 	sth	r2,-8(fp)
   struct inpcb * inp, *   match =  0;
 d04695c:	e03ff815 	stw	zero,-32(fp)
   unshort  fport =  xfport; 
 d046960:	e0bffc0b 	ldhu	r2,-16(fp)
 d046964:	e0bff78d 	sth	r2,-34(fp)
   unshort  lport =  xlport;
 d046968:	e0bffe0b 	ldhu	r2,-8(fp)
 d04696c:	e0bff70d 	sth	r2,-36(fp)
   int   matchwild   =  3;
 d046970:	008000c4 	movi	r2,3
 d046974:	e0bff615 	stw	r2,-40(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 d046978:	e0bffa17 	ldw	r2,-24(fp)
 d04697c:	10800017 	ldw	r2,0(r2)
 d046980:	e0bff915 	stw	r2,-28(fp)
 d046984:	00005006 	br	d046ac8 <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 d046988:	e0bff917 	ldw	r2,-28(fp)
 d04698c:	1080078b 	ldhu	r2,30(r2)
 d046990:	10ffffcc 	andi	r3,r2,65535
 d046994:	e0bff70b 	ldhu	r2,-36(fp)
 d046998:	1880481e 	bne	r3,r2,d046abc <in_pcblookup+0x184>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 d04699c:	e0bff917 	ldw	r2,-28(fp)
 d0469a0:	10800817 	ldw	r2,32(r2)
 d0469a4:	10800517 	ldw	r2,20(r2)
 d0469a8:	10800098 	cmpnei	r2,r2,2
 d0469ac:	1000431e 	bne	r2,zero,d046abc <in_pcblookup+0x184>
         continue;

      wildcard = 0;
 d0469b0:	e03ff515 	stw	zero,-44(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 d0469b4:	e0bff917 	ldw	r2,-28(fp)
 d0469b8:	10800417 	ldw	r2,16(r2)
 d0469bc:	1005003a 	cmpeq	r2,r2,zero
 d0469c0:	10000c1e 	bne	r2,zero,d0469f4 <in_pcblookup+0xbc>
      {
         if (laddr == INADDR_ANY)
 d0469c4:	e0bffd17 	ldw	r2,-12(fp)
 d0469c8:	1004c03a 	cmpne	r2,r2,zero
 d0469cc:	1000041e 	bne	r2,zero,d0469e0 <in_pcblookup+0xa8>
            wildcard++;
 d0469d0:	e0bff517 	ldw	r2,-44(fp)
 d0469d4:	10800044 	addi	r2,r2,1
 d0469d8:	e0bff515 	stw	r2,-44(fp)
 d0469dc:	00000b06 	br	d046a0c <in_pcblookup+0xd4>
         else if (inp->inp_laddr.s_addr != laddr)
 d0469e0:	e0bff917 	ldw	r2,-28(fp)
 d0469e4:	10c00417 	ldw	r3,16(r2)
 d0469e8:	e0bffd17 	ldw	r2,-12(fp)
 d0469ec:	1880331e 	bne	r3,r2,d046abc <in_pcblookup+0x184>
            continue;
 d0469f0:	00000606 	br	d046a0c <in_pcblookup+0xd4>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 d0469f4:	e0bffd17 	ldw	r2,-12(fp)
 d0469f8:	1005003a 	cmpeq	r2,r2,zero
 d0469fc:	1000031e 	bne	r2,zero,d046a0c <in_pcblookup+0xd4>
            wildcard++;
 d046a00:	e0bff517 	ldw	r2,-44(fp)
 d046a04:	10800044 	addi	r2,r2,1
 d046a08:	e0bff515 	stw	r2,-44(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 d046a0c:	e0bff917 	ldw	r2,-28(fp)
 d046a10:	10800317 	ldw	r2,12(r2)
 d046a14:	1005003a 	cmpeq	r2,r2,zero
 d046a18:	1000111e 	bne	r2,zero,d046a60 <in_pcblookup+0x128>
      {
         if (faddr == INADDR_ANY)
 d046a1c:	e0bffb17 	ldw	r2,-20(fp)
 d046a20:	1004c03a 	cmpne	r2,r2,zero
 d046a24:	1000041e 	bne	r2,zero,d046a38 <in_pcblookup+0x100>
            wildcard++;
 d046a28:	e0bff517 	ldw	r2,-44(fp)
 d046a2c:	10800044 	addi	r2,r2,1
 d046a30:	e0bff515 	stw	r2,-44(fp)
 d046a34:	00001006 	br	d046a78 <in_pcblookup+0x140>
         else if (inp->inp_faddr.s_addr != faddr ||
 d046a38:	e0bff917 	ldw	r2,-28(fp)
 d046a3c:	10c00317 	ldw	r3,12(r2)
 d046a40:	e0bffb17 	ldw	r2,-20(fp)
 d046a44:	18801d1e 	bne	r3,r2,d046abc <in_pcblookup+0x184>
 d046a48:	e0bff917 	ldw	r2,-28(fp)
 d046a4c:	1080070b 	ldhu	r2,28(r2)
 d046a50:	10ffffcc 	andi	r3,r2,65535
 d046a54:	e0bff78b 	ldhu	r2,-34(fp)
 d046a58:	1880181e 	bne	r3,r2,d046abc <in_pcblookup+0x184>
 d046a5c:	00000606 	br	d046a78 <in_pcblookup+0x140>
         {
            continue;
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 d046a60:	e0bffb17 	ldw	r2,-20(fp)
 d046a64:	1005003a 	cmpeq	r2,r2,zero
 d046a68:	1000031e 	bne	r2,zero,d046a78 <in_pcblookup+0x140>
            wildcard++;
 d046a6c:	e0bff517 	ldw	r2,-44(fp)
 d046a70:	10800044 	addi	r2,r2,1
 d046a74:	e0bff515 	stw	r2,-44(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 d046a78:	e0bff517 	ldw	r2,-44(fp)
 d046a7c:	1005003a 	cmpeq	r2,r2,zero
 d046a80:	1000041e 	bne	r2,zero,d046a94 <in_pcblookup+0x15c>
 d046a84:	e0800217 	ldw	r2,8(fp)
 d046a88:	1080004c 	andi	r2,r2,1
 d046a8c:	1005003a 	cmpeq	r2,r2,zero
 d046a90:	10000a1e 	bne	r2,zero,d046abc <in_pcblookup+0x184>
         continue;
      if (wildcard < matchwild) 
 d046a94:	e0fff517 	ldw	r3,-44(fp)
 d046a98:	e0bff617 	ldw	r2,-40(fp)
 d046a9c:	1880070e 	bge	r3,r2,d046abc <in_pcblookup+0x184>
      {
         match = inp;
 d046aa0:	e0bff917 	ldw	r2,-28(fp)
 d046aa4:	e0bff815 	stw	r2,-32(fp)
         matchwild = wildcard;
 d046aa8:	e0bff517 	ldw	r2,-44(fp)
 d046aac:	e0bff615 	stw	r2,-40(fp)
         if (matchwild == 0)
 d046ab0:	e0bff617 	ldw	r2,-40(fp)
 d046ab4:	1005003a 	cmpeq	r2,r2,zero
 d046ab8:	1000061e 	bne	r2,zero,d046ad4 <in_pcblookup+0x19c>
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 d046abc:	e0bff917 	ldw	r2,-28(fp)
 d046ac0:	10800017 	ldw	r2,0(r2)
 d046ac4:	e0bff915 	stw	r2,-28(fp)
 d046ac8:	e0fff917 	ldw	r3,-28(fp)
 d046acc:	e0bffa17 	ldw	r2,-24(fp)
 d046ad0:	18bfad1e 	bne	r3,r2,d046988 <in_pcblookup+0x50>
         matchwild = wildcard;
         if (matchwild == 0)
            break;
      }
   }
   if (match == NULL)
 d046ad4:	e0bff817 	ldw	r2,-32(fp)
 d046ad8:	1004c03a 	cmpne	r2,r2,zero
 d046adc:	1000031e 	bne	r2,zero,d046aec <in_pcblookup+0x1b4>
      return match;
 d046ae0:	e0bff817 	ldw	r2,-32(fp)
 d046ae4:	e0bfff15 	stw	r2,-4(fp)
 d046ae8:	00002506 	br	d046b80 <in_pcblookup+0x248>

   if (head->inp_next == match)  /* got cache hit? */
 d046aec:	e0bffa17 	ldw	r2,-24(fp)
 d046af0:	10c00017 	ldw	r3,0(r2)
 d046af4:	e0bff817 	ldw	r2,-32(fp)
 d046af8:	1880041e 	bne	r3,r2,d046b0c <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 d046afc:	d0a0d217 	ldw	r2,-31928(gp)
 d046b00:	10800044 	addi	r2,r2,1
 d046b04:	d0a0d215 	stw	r2,-31928(gp)
 d046b08:	00001b06 	br	d046b78 <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 d046b0c:	d0a0d317 	ldw	r2,-31924(gp)
 d046b10:	10800044 	addi	r2,r2,1
 d046b14:	d0a0d315 	stw	r2,-31924(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 d046b18:	e0bff817 	ldw	r2,-32(fp)
 d046b1c:	10c00017 	ldw	r3,0(r2)
 d046b20:	e0bff817 	ldw	r2,-32(fp)
 d046b24:	10800117 	ldw	r2,4(r2)
 d046b28:	18800115 	stw	r2,4(r3)
      match->inp_prev->inp_next = match->inp_next;
 d046b2c:	e0bff817 	ldw	r2,-32(fp)
 d046b30:	10c00117 	ldw	r3,4(r2)
 d046b34:	e0bff817 	ldw	r2,-32(fp)
 d046b38:	10800017 	ldw	r2,0(r2)
 d046b3c:	18800015 	stw	r2,0(r3)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 d046b40:	e0bffa17 	ldw	r2,-24(fp)
 d046b44:	10c00017 	ldw	r3,0(r2)
 d046b48:	e0bff817 	ldw	r2,-32(fp)
 d046b4c:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 d046b50:	e0fffa17 	ldw	r3,-24(fp)
 d046b54:	e0bff817 	ldw	r2,-32(fp)
 d046b58:	18800015 	stw	r2,0(r3)
      match->inp_prev = head;
 d046b5c:	e0fff817 	ldw	r3,-32(fp)
 d046b60:	e0bffa17 	ldw	r2,-24(fp)
 d046b64:	18800115 	stw	r2,4(r3)
      match->inp_next->inp_prev = match;
 d046b68:	e0bff817 	ldw	r2,-32(fp)
 d046b6c:	10c00017 	ldw	r3,0(r2)
 d046b70:	e0bff817 	ldw	r2,-32(fp)
 d046b74:	18800115 	stw	r2,4(r3)
   }
   return (match);
 d046b78:	e0bff817 	ldw	r2,-32(fp)
 d046b7c:	e0bfff15 	stw	r2,-4(fp)
 d046b80:	e0bfff17 	ldw	r2,-4(fp)
}
 d046b84:	e037883a 	mov	sp,fp
 d046b88:	df000017 	ldw	fp,0(sp)
 d046b8c:	dec00104 	addi	sp,sp,4
 d046b90:	f800283a 	ret

0d046b94 <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 d046b94:	defffe04 	addi	sp,sp,-8
 d046b98:	df000115 	stw	fp,4(sp)
 d046b9c:	df000104 	addi	fp,sp,4
 d046ba0:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 d046ba4:	e0bfff17 	ldw	r2,-4(fp)
 d046ba8:	d0a0d715 	stw	r2,-31908(gp)
}
 d046bac:	e037883a 	mov	sp,fp
 d046bb0:	df000017 	ldw	fp,0(sp)
 d046bb4:	dec00104 	addi	sp,sp,4
 d046bb8:	f800283a 	ret

0d046bbc <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 d046bbc:	deffff04 	addi	sp,sp,-4
 d046bc0:	df000015 	stw	fp,0(sp)
 d046bc4:	d839883a 	mov	fp,sp
   return vfopen_error;
 d046bc8:	d0a0d717 	ldw	r2,-31908(gp)
}
 d046bcc:	e037883a 	mov	sp,fp
 d046bd0:	df000017 	ldw	fp,0(sp)
 d046bd4:	dec00104 	addi	sp,sp,4
 d046bd8:	f800283a 	ret

0d046bdc <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 d046bdc:	defffc04 	addi	sp,sp,-16
 d046be0:	dfc00315 	stw	ra,12(sp)
 d046be4:	df000215 	stw	fp,8(sp)
 d046be8:	df000204 	addi	fp,sp,8
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 d046bec:	d0a0d917 	ldw	r2,-31900(gp)
 d046bf0:	10803ff0 	cmpltui	r2,r2,255
 d046bf4:	1000021e 	bne	r2,zero,d046c00 <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 d046bf8:	e03fff15 	stw	zero,-4(fp)
 d046bfc:	00001006 	br	d046c40 <vf_alloc_and_link_vop+0x64>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 d046c00:	01000504 	movi	r4,20
 d046c04:	d029e2c0 	call	d029e2c <npalloc>
 d046c08:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (vop)
 d046c0c:	e0bffe17 	ldw	r2,-8(fp)
 d046c10:	1005003a 	cmpeq	r2,r2,zero
 d046c14:	1000081e 	bne	r2,zero,d046c38 <vf_alloc_and_link_vop+0x5c>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 d046c18:	d0e0d517 	ldw	r3,-31916(gp)
 d046c1c:	e0bffe17 	ldw	r2,-8(fp)
 d046c20:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 d046c24:	e0bffe17 	ldw	r2,-8(fp)
 d046c28:	d0a0d515 	stw	r2,-31916(gp)
      /* increment the count of open files */
      vfs_open_files++;
 d046c2c:	d0a0d917 	ldw	r2,-31900(gp)
 d046c30:	10800044 	addi	r2,r2,1
 d046c34:	d0a0d915 	stw	r2,-31900(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 d046c38:	e0bffe17 	ldw	r2,-8(fp)
 d046c3c:	e0bfff15 	stw	r2,-4(fp)
 d046c40:	e0bfff17 	ldw	r2,-4(fp)
}
 d046c44:	e037883a 	mov	sp,fp
 d046c48:	dfc00117 	ldw	ra,4(sp)
 d046c4c:	df000017 	ldw	fp,0(sp)
 d046c50:	dec00204 	addi	sp,sp,8
 d046c54:	f800283a 	ret

0d046c58 <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 d046c58:	defff804 	addi	sp,sp,-32
 d046c5c:	dfc00715 	stw	ra,28(sp)
 d046c60:	df000615 	stw	fp,24(sp)
 d046c64:	df000604 	addi	fp,sp,24
 d046c68:	e13ffe15 	stw	r4,-8(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 d046c6c:	d0e0da17 	ldw	r3,-31896(gp)
 d046c70:	e0bffe17 	ldw	r2,-8(fp)
 d046c74:	1887883a 	add	r3,r3,r2
 d046c78:	00bfffd4 	movui	r2,65535
 d046c7c:	10c0022e 	bgeu	r2,r3,d046c88 <vf_alloc_buffer+0x30>
      return NULL;
 d046c80:	e03fff15 	stw	zero,-4(fp)
 d046c84:	00002406 	br	d046d18 <vf_alloc_buffer+0xc0>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 d046c88:	00800104 	movi	r2,4
 d046c8c:	e0bffc15 	stw	r2,-16(fp)
   int_size = sizeof(unsigned int);
 d046c90:	00800104 	movi	r2,4
 d046c94:	e0bffb15 	stw	r2,-20(fp)
   if (long_size > int_size)
 d046c98:	e0fffc17 	ldw	r3,-16(fp)
 d046c9c:	e0bffb17 	ldw	r2,-20(fp)
 d046ca0:	10c0112e 	bgeu	r2,r3,d046ce8 <vf_alloc_buffer+0x90>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 d046ca4:	e0bffb17 	ldw	r2,-20(fp)
 d046ca8:	108000a0 	cmpeqi	r2,r2,2
 d046cac:	1000011e 	bne	r2,zero,d046cb4 <vf_alloc_buffer+0x5c>
 d046cb0:	00000806 	br	d046cd4 <vf_alloc_buffer+0x7c>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 d046cb4:	00bffff4 	movhi	r2,65535
 d046cb8:	e0bffa15 	stw	r2,-24(fp)
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 d046cbc:	e0fffe17 	ldw	r3,-8(fp)
 d046cc0:	e0bffa17 	ldw	r2,-24(fp)
 d046cc4:	1884703a 	and	r2,r3,r2
 d046cc8:	1004c03a 	cmpne	r2,r2,zero
 d046ccc:	1000041e 	bne	r2,zero,d046ce0 <vf_alloc_buffer+0x88>
 d046cd0:	00000506 	br	d046ce8 <vf_alloc_buffer+0x90>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 d046cd4:	d0293e80 	call	d0293e8 <dtrap>
         return NULL;
 d046cd8:	e03fff15 	stw	zero,-4(fp)
 d046cdc:	00000e06 	br	d046d18 <vf_alloc_buffer+0xc0>
      }

      if (size & mem_mask)
         return NULL;
 d046ce0:	e03fff15 	stw	zero,-4(fp)
 d046ce4:	00000c06 	br	d046d18 <vf_alloc_buffer+0xc0>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 d046ce8:	e13ffe17 	ldw	r4,-8(fp)
 d046cec:	d029e2c0 	call	d029e2c <npalloc>
 d046cf0:	e0bffd15 	stw	r2,-12(fp)

   /* if the allocation succeeded */
   if (buffer)
 d046cf4:	e0bffd17 	ldw	r2,-12(fp)
 d046cf8:	1005003a 	cmpeq	r2,r2,zero
 d046cfc:	1000041e 	bne	r2,zero,d046d10 <vf_alloc_buffer+0xb8>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 d046d00:	d0a0da17 	ldw	r2,-31896(gp)
 d046d04:	e0fffe17 	ldw	r3,-8(fp)
 d046d08:	10c5883a 	add	r2,r2,r3
 d046d0c:	d0a0da15 	stw	r2,-31896(gp)
   }

   return buffer;
 d046d10:	e0bffd17 	ldw	r2,-12(fp)
 d046d14:	e0bfff15 	stw	r2,-4(fp)
 d046d18:	e0bfff17 	ldw	r2,-4(fp)
}
 d046d1c:	e037883a 	mov	sp,fp
 d046d20:	dfc00117 	ldw	ra,4(sp)
 d046d24:	df000017 	ldw	fp,0(sp)
 d046d28:	dec00204 	addi	sp,sp,8
 d046d2c:	f800283a 	ret

0d046d30 <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 d046d30:	defffc04 	addi	sp,sp,-16
 d046d34:	dfc00315 	stw	ra,12(sp)
 d046d38:	df000215 	stw	fp,8(sp)
 d046d3c:	df000204 	addi	fp,sp,8
 d046d40:	e13ffe15 	stw	r4,-8(fp)
 d046d44:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 d046d48:	e0bffe17 	ldw	r2,-8(fp)
 d046d4c:	1005003a 	cmpeq	r2,r2,zero
 d046d50:	1000021e 	bne	r2,zero,d046d5c <vf_free_buffer+0x2c>
      npfree(buffer);
 d046d54:	e13ffe17 	ldw	r4,-8(fp)
 d046d58:	d029f200 	call	d029f20 <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 d046d5c:	d0a0da17 	ldw	r2,-31896(gp)
 d046d60:	e0ffff17 	ldw	r3,-4(fp)
 d046d64:	10c5c83a 	sub	r2,r2,r3
 d046d68:	d0a0da15 	stw	r2,-31896(gp)
}
 d046d6c:	e037883a 	mov	sp,fp
 d046d70:	dfc00117 	ldw	ra,4(sp)
 d046d74:	df000017 	ldw	fp,0(sp)
 d046d78:	dec00204 	addi	sp,sp,8
 d046d7c:	f800283a 	ret

0d046d80 <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 d046d80:	defff804 	addi	sp,sp,-32
 d046d84:	dfc00715 	stw	ra,28(sp)
 d046d88:	df000615 	stw	fp,24(sp)
 d046d8c:	df000604 	addi	fp,sp,24
 d046d90:	e13ffd15 	stw	r4,-12(fp)
 d046d94:	e17ffe15 	stw	r5,-8(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 d046d98:	0009883a 	mov	r4,zero
 d046d9c:	d046b940 	call	d046b94 <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 d046da0:	e13ffd17 	ldw	r4,-12(fp)
 d046da4:	01400fc4 	movi	r5,63
 d046da8:	d002e080 	call	d002e08 <strchr>
 d046dac:	1005003a 	cmpeq	r2,r2,zero
 d046db0:	1000031e 	bne	r2,zero,d046dc0 <vfopen_locked+0x40>
   {
      dtrap();
 d046db4:	d0293e80 	call	d0293e8 <dtrap>
      return NULL;
 d046db8:	e03fff15 	stw	zero,-4(fp)
 d046dbc:	0000c406 	br	d0470d0 <vfopen_locked+0x350>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 d046dc0:	e13ffd17 	ldw	r4,-12(fp)
 d046dc4:	d04812c0 	call	d04812c <vfslookup_locked>
 d046dc8:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 d046dcc:	e0bffc17 	ldw	r2,-16(fp)
 d046dd0:	1005003a 	cmpeq	r2,r2,zero
 d046dd4:	10004e1e 	bne	r2,zero,d046f10 <vfopen_locked+0x190>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 d046dd8:	e0bffe17 	ldw	r2,-8(fp)
 d046ddc:	10800003 	ldbu	r2,0(r2)
 d046de0:	10803fcc 	andi	r2,r2,255
 d046de4:	1080201c 	xori	r2,r2,128
 d046de8:	10bfe004 	addi	r2,r2,-128
 d046dec:	10801dd8 	cmpnei	r2,r2,119
 d046df0:	10000a1e 	bne	r2,zero,d046e1c <vfopen_locked+0x9c>
 d046df4:	e0bffc17 	ldw	r2,-16(fp)
 d046df8:	1080058b 	ldhu	r2,22(r2)
 d046dfc:	10bfffcc 	andi	r2,r2,65535
 d046e00:	1080080c 	andi	r2,r2,32
 d046e04:	1004c03a 	cmpne	r2,r2,zero
 d046e08:	1000041e 	bne	r2,zero,d046e1c <vfopen_locked+0x9c>
      {
         set_vfopen_error(ENP_FILEIO);
 d046e0c:	013ff984 	movi	r4,-26
 d046e10:	d046b940 	call	d046b94 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d046e14:	e03fff15 	stw	zero,-4(fp)
 d046e18:	0000ad06 	br	d0470d0 <vfopen_locked+0x350>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 d046e1c:	d046bdc0 	call	d046bdc <vf_alloc_and_link_vop>
 d046e20:	e0bffb15 	stw	r2,-20(fp)

      /* check for failure */
      if (!vop)
 d046e24:	e0bffb17 	ldw	r2,-20(fp)
 d046e28:	1004c03a 	cmpne	r2,r2,zero
 d046e2c:	1000041e 	bne	r2,zero,d046e40 <vfopen_locked+0xc0>
      {
         set_vfopen_error(ENP_NOMEM);
 d046e30:	013ffb04 	movi	r4,-20
 d046e34:	d046b940 	call	d046b94 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d046e38:	e03fff15 	stw	zero,-4(fp)
 d046e3c:	0000a406 	br	d0470d0 <vfopen_locked+0x350>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 d046e40:	e0fffb17 	ldw	r3,-20(fp)
 d046e44:	e0bffc17 	ldw	r2,-16(fp)
 d046e48:	18800115 	stw	r2,4(r3)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 d046e4c:	e0bffc17 	ldw	r2,-16(fp)
 d046e50:	10c00617 	ldw	r3,24(r2)
 d046e54:	e0bffb17 	ldw	r2,-20(fp)
 d046e58:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 d046e5c:	e0bffe17 	ldw	r2,-8(fp)
 d046e60:	10800003 	ldbu	r2,0(r2)
 d046e64:	10803fcc 	andi	r2,r2,255
 d046e68:	1080201c 	xori	r2,r2,128
 d046e6c:	10bfe004 	addi	r2,r2,-128
 d046e70:	10801858 	cmpnei	r2,r2,97
 d046e74:	10000b1e 	bne	r2,zero,d046ea4 <vfopen_locked+0x124>
      {
         if (vfp->data)
 d046e78:	e0bffc17 	ldw	r2,-16(fp)
 d046e7c:	10800617 	ldw	r2,24(r2)
 d046e80:	1005003a 	cmpeq	r2,r2,zero
 d046e84:	1000071e 	bne	r2,zero,d046ea4 <vfopen_locked+0x124>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 d046e88:	e0bffc17 	ldw	r2,-16(fp)
 d046e8c:	10c00617 	ldw	r3,24(r2)
 d046e90:	e0bffc17 	ldw	r2,-16(fp)
 d046e94:	10800817 	ldw	r2,32(r2)
 d046e98:	1887883a 	add	r3,r3,r2
 d046e9c:	e0bffb17 	ldw	r2,-20(fp)
 d046ea0:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 d046ea4:	e0bffe17 	ldw	r2,-8(fp)
 d046ea8:	10800003 	ldbu	r2,0(r2)
 d046eac:	10803fcc 	andi	r2,r2,255
 d046eb0:	1080201c 	xori	r2,r2,128
 d046eb4:	10bfe004 	addi	r2,r2,-128
 d046eb8:	10801dd8 	cmpnei	r2,r2,119
 d046ebc:	1000111e 	bne	r2,zero,d046f04 <vfopen_locked+0x184>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 d046ec0:	e0bffc17 	ldw	r2,-16(fp)
 d046ec4:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 d046ec8:	e0bffc17 	ldw	r2,-16(fp)
 d046ecc:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 d046ed0:	e0bffc17 	ldw	r2,-16(fp)
 d046ed4:	1080058b 	ldhu	r2,22(r2)
 d046ed8:	10808014 	ori	r2,r2,512
 d046edc:	1007883a 	mov	r3,r2
 d046ee0:	e0bffc17 	ldw	r2,-16(fp)
 d046ee4:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 d046ee8:	e0bffc17 	ldw	r2,-16(fp)
 d046eec:	10c0058b 	ldhu	r3,22(r2)
 d046ef0:	00bfff84 	movi	r2,-2
 d046ef4:	1884703a 	and	r2,r3,r2
 d046ef8:	1007883a 	mov	r3,r2
 d046efc:	e0bffc17 	ldw	r2,-16(fp)
 d046f00:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 d046f04:	e0bffb17 	ldw	r2,-20(fp)
 d046f08:	e0bfff15 	stw	r2,-4(fp)
 d046f0c:	00007006 	br	d0470d0 <vfopen_locked+0x350>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 d046f10:	e0bffe17 	ldw	r2,-8(fp)
 d046f14:	10800003 	ldbu	r2,0(r2)
 d046f18:	10803fcc 	andi	r2,r2,255
 d046f1c:	1080201c 	xori	r2,r2,128
 d046f20:	10bfe004 	addi	r2,r2,-128
 d046f24:	10801ca0 	cmpeqi	r2,r2,114
 d046f28:	1000151e 	bne	r2,zero,d046f80 <vfopen_locked+0x200>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 d046f2c:	d0a0d417 	ldw	r2,-31920(gp)
 d046f30:	e0bffa15 	stw	r2,-24(fp)
 d046f34:	00000f06 	br	d046f74 <vfopen_locked+0x1f4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 d046f38:	e0bffa17 	ldw	r2,-24(fp)
 d046f3c:	10800117 	ldw	r2,4(r2)
 d046f40:	e13ffd17 	ldw	r4,-12(fp)
 d046f44:	e17ffe17 	ldw	r5,-8(fp)
 d046f48:	103ee83a 	callr	r2
 d046f4c:	e0bffb15 	stw	r2,-20(fp)
 d046f50:	e0bffb17 	ldw	r2,-20(fp)
 d046f54:	1005003a 	cmpeq	r2,r2,zero
 d046f58:	1000031e 	bne	r2,zero,d046f68 <vfopen_locked+0x1e8>
         {
            return vop;
 d046f5c:	e0bffb17 	ldw	r2,-20(fp)
 d046f60:	e0bfff15 	stw	r2,-4(fp)
 d046f64:	00005a06 	br	d0470d0 <vfopen_locked+0x350>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 d046f68:	e0bffa17 	ldw	r2,-24(fp)
 d046f6c:	10800017 	ldw	r2,0(r2)
 d046f70:	e0bffa15 	stw	r2,-24(fp)
 d046f74:	e0bffa17 	ldw	r2,-24(fp)
 d046f78:	1004c03a 	cmpne	r2,r2,zero
 d046f7c:	103fee1e 	bne	r2,zero,d046f38 <vfopen_locked+0x1b8>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 d046f80:	e0bffe17 	ldw	r2,-8(fp)
 d046f84:	10800003 	ldbu	r2,0(r2)
 d046f88:	10803fcc 	andi	r2,r2,255
 d046f8c:	1080201c 	xori	r2,r2,128
 d046f90:	10bfe004 	addi	r2,r2,-128
 d046f94:	10801ca0 	cmpeqi	r2,r2,114
 d046f98:	10004a1e 	bne	r2,zero,d0470c4 <vfopen_locked+0x344>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 d046f9c:	d0a0db17 	ldw	r2,-31892(gp)
 d046fa0:	10803ff0 	cmpltui	r2,r2,255
 d046fa4:	1000041e 	bne	r2,zero,d046fb8 <vfopen_locked+0x238>
      {
         set_vfopen_error(ENP_NOMEM);
 d046fa8:	013ffb04 	movi	r4,-20
 d046fac:	d046b940 	call	d046b94 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d046fb0:	e03fff15 	stw	zero,-4(fp)
 d046fb4:	00004606 	br	d0470d0 <vfopen_locked+0x350>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 d046fb8:	e13ffd17 	ldw	r4,-12(fp)
 d046fbc:	d00355c0 	call	d00355c <strlen>
 d046fc0:	10800470 	cmpltui	r2,r2,17
 d046fc4:	1000041e 	bne	r2,zero,d046fd8 <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_PARAM);
 d046fc8:	013ffd84 	movi	r4,-10
 d046fcc:	d046b940 	call	d046b94 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d046fd0:	e03fff15 	stw	zero,-4(fp)
 d046fd4:	00003e06 	br	d0470d0 <vfopen_locked+0x350>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 d046fd8:	01000b04 	movi	r4,44
 d046fdc:	d029e2c0 	call	d029e2c <npalloc>
 d046fe0:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 d046fe4:	e0bffc17 	ldw	r2,-16(fp)
 d046fe8:	1004c03a 	cmpne	r2,r2,zero
 d046fec:	1000041e 	bne	r2,zero,d047000 <vfopen_locked+0x280>
      {
         set_vfopen_error(ENP_NOMEM);
 d046ff0:	013ffb04 	movi	r4,-20
 d046ff4:	d046b940 	call	d046b94 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d046ff8:	e03fff15 	stw	zero,-4(fp)
 d046ffc:	00003406 	br	d0470d0 <vfopen_locked+0x350>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 d047000:	d046bdc0 	call	d046bdc <vf_alloc_and_link_vop>
 d047004:	e0bffb15 	stw	r2,-20(fp)

      /* check for memory allocation failure */
      if (!vop)
 d047008:	e0bffb17 	ldw	r2,-20(fp)
 d04700c:	1004c03a 	cmpne	r2,r2,zero
 d047010:	1000061e 	bne	r2,zero,d04702c <vfopen_locked+0x2ac>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 d047014:	e13ffc17 	ldw	r4,-16(fp)
 d047018:	d029f200 	call	d029f20 <npfree>
         set_vfopen_error(ENP_NOMEM);
 d04701c:	013ffb04 	movi	r4,-20
 d047020:	d046b940 	call	d046b94 <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 d047024:	e03fff15 	stw	zero,-4(fp)
 d047028:	00002906 	br	d0470d0 <vfopen_locked+0x350>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 d04702c:	d0e0d617 	ldw	r3,-31912(gp)
 d047030:	e0bffc17 	ldw	r2,-16(fp)
 d047034:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 d047038:	e0bffc17 	ldw	r2,-16(fp)
 d04703c:	d0a0d615 	stw	r2,-31912(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 d047040:	d0a0db17 	ldw	r2,-31892(gp)
 d047044:	10800044 	addi	r2,r2,1
 d047048:	d0a0db15 	stw	r2,-31892(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 d04704c:	e0bffd17 	ldw	r2,-12(fp)
 d047050:	10800003 	ldbu	r2,0(r2)
 d047054:	10803fcc 	andi	r2,r2,255
 d047058:	1080201c 	xori	r2,r2,128
 d04705c:	10bfe004 	addi	r2,r2,-128
 d047060:	10800be0 	cmpeqi	r2,r2,47
 d047064:	1000071e 	bne	r2,zero,d047084 <vfopen_locked+0x304>
 d047068:	e0bffd17 	ldw	r2,-12(fp)
 d04706c:	10800003 	ldbu	r2,0(r2)
 d047070:	10803fcc 	andi	r2,r2,255
 d047074:	1080201c 	xori	r2,r2,128
 d047078:	10bfe004 	addi	r2,r2,-128
 d04707c:	10801718 	cmpnei	r2,r2,92
 d047080:	1000031e 	bne	r2,zero,d047090 <vfopen_locked+0x310>
         name++;
 d047084:	e0bffd17 	ldw	r2,-12(fp)
 d047088:	10800044 	addi	r2,r2,1
 d04708c:	e0bffd15 	stw	r2,-12(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 d047090:	e0bffc17 	ldw	r2,-16(fp)
 d047094:	11000104 	addi	r4,r2,4
 d047098:	e17ffd17 	ldw	r5,-12(fp)
 d04709c:	d049f480 	call	d049f48 <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 d0470a0:	e0fffc17 	ldw	r3,-16(fp)
 d0470a4:	0080d804 	movi	r2,864
 d0470a8:	1880058d 	sth	r2,22(r3)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 d0470ac:	e0fffb17 	ldw	r3,-20(fp)
 d0470b0:	e0bffc17 	ldw	r2,-16(fp)
 d0470b4:	18800115 	stw	r2,4(r3)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 d0470b8:	e0bffb17 	ldw	r2,-20(fp)
 d0470bc:	e0bfff15 	stw	r2,-4(fp)
 d0470c0:	00000306 	br	d0470d0 <vfopen_locked+0x350>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 d0470c4:	013ff9c4 	movi	r4,-25
 d0470c8:	d046b940 	call	d046b94 <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 d0470cc:	e03fff15 	stw	zero,-4(fp)
 d0470d0:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_LOCALFS */
}
 d0470d4:	e037883a 	mov	sp,fp
 d0470d8:	dfc00117 	ldw	ra,4(sp)
 d0470dc:	df000017 	ldw	fp,0(sp)
 d0470e0:	dec00204 	addi	sp,sp,8
 d0470e4:	f800283a 	ret

0d0470e8 <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 d0470e8:	defffb04 	addi	sp,sp,-20
 d0470ec:	dfc00415 	stw	ra,16(sp)
 d0470f0:	df000315 	stw	fp,12(sp)
 d0470f4:	df000304 	addi	fp,sp,12
 d0470f8:	e13ffe15 	stw	r4,-8(fp)
 d0470fc:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 d047100:	01000144 	movi	r4,5
 d047104:	d0299e40 	call	d0299e4 <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 d047108:	e13ffe17 	ldw	r4,-8(fp)
 d04710c:	e17fff17 	ldw	r5,-4(fp)
 d047110:	d046d800 	call	d046d80 <vfopen_locked>
 d047114:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 d047118:	01000144 	movi	r4,5
 d04711c:	d029a980 	call	d029a98 <post_app_sem>

   return vfd;
 d047120:	e0bffd17 	ldw	r2,-12(fp)
}
 d047124:	e037883a 	mov	sp,fp
 d047128:	dfc00117 	ldw	ra,4(sp)
 d04712c:	df000017 	ldw	fp,0(sp)
 d047130:	dec00204 	addi	sp,sp,8
 d047134:	f800283a 	ret

0d047138 <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 d047138:	defff804 	addi	sp,sp,-32
 d04713c:	dfc00715 	stw	ra,28(sp)
 d047140:	df000615 	stw	fp,24(sp)
 d047144:	df000604 	addi	fp,sp,24
 d047148:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 d04714c:	e03ffd15 	stw	zero,-12(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 d047150:	d0a0d517 	ldw	r2,-31916(gp)
 d047154:	e0bffe15 	stw	r2,-8(fp)
   while (vtmp)
 d047158:	00000806 	br	d04717c <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 d04715c:	e0ffff17 	ldw	r3,-4(fp)
 d047160:	e0bffe17 	ldw	r2,-8(fp)
 d047164:	18800826 	beq	r3,r2,d047188 <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 d047168:	e0bffe17 	ldw	r2,-8(fp)
 d04716c:	e0bffd15 	stw	r2,-12(fp)
      vtmp = vtmp->next;
 d047170:	e0bffe17 	ldw	r2,-8(fp)
 d047174:	10800017 	ldw	r2,0(r2)
 d047178:	e0bffe15 	stw	r2,-8(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 d04717c:	e0bffe17 	ldw	r2,-8(fp)
 d047180:	1004c03a 	cmpne	r2,r2,zero
 d047184:	103ff51e 	bne	r2,zero,d04715c <vfclose_locked+0x24>
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 d047188:	e0ffff17 	ldw	r3,-4(fp)
 d04718c:	e0bffe17 	ldw	r2,-8(fp)
 d047190:	18804e1e 	bne	r3,r2,d0472cc <vfclose_locked+0x194>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 d047194:	e0bfff17 	ldw	r2,-4(fp)
 d047198:	10800117 	ldw	r2,4(r2)
 d04719c:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 d0471a0:	e0bffc17 	ldw	r2,-16(fp)
 d0471a4:	1005003a 	cmpeq	r2,r2,zero
 d0471a8:	1000381e 	bne	r2,zero,d04728c <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 d0471ac:	e0bffc17 	ldw	r2,-16(fp)
 d0471b0:	10800a17 	ldw	r2,40(r2)
 d0471b4:	1005003a 	cmpeq	r2,r2,zero
 d0471b8:	1000081e 	bne	r2,zero,d0471dc <vfclose_locked+0xa4>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 d0471bc:	e0bffc17 	ldw	r2,-16(fp)
 d0471c0:	10800a17 	ldw	r2,40(r2)
 d0471c4:	e0bffa15 	stw	r2,-24(fp)

         vfs->r_fclose(vfd);
 d0471c8:	e0bffa17 	ldw	r2,-24(fp)
 d0471cc:	10800217 	ldw	r2,8(r2)
 d0471d0:	e13fff17 	ldw	r4,-4(fp)
 d0471d4:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 d0471d8:	00002c06 	br	d04728c <vfclose_locked+0x154>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 d0471dc:	e0bffc17 	ldw	r2,-16(fp)
 d0471e0:	1080058b 	ldhu	r2,22(r2)
 d0471e4:	10bfffcc 	andi	r2,r2,65535
 d0471e8:	1080200c 	andi	r2,r2,128
 d0471ec:	1005003a 	cmpeq	r2,r2,zero
 d0471f0:	1000261e 	bne	r2,zero,d04728c <vfclose_locked+0x154>
 d0471f4:	e0bffc17 	ldw	r2,-16(fp)
 d0471f8:	10c00917 	ldw	r3,36(r2)
 d0471fc:	e0bffc17 	ldw	r2,-16(fp)
 d047200:	10800817 	ldw	r2,32(r2)
 d047204:	1885c83a 	sub	r2,r3,r2
 d047208:	10804030 	cmpltui	r2,r2,256
 d04720c:	10001f1e 	bne	r2,zero,d04728c <vfclose_locked+0x154>
 d047210:	e0bffc17 	ldw	r2,-16(fp)
 d047214:	10800617 	ldw	r2,24(r2)
 d047218:	1005003a 	cmpeq	r2,r2,zero
 d04721c:	10001b1e 	bne	r2,zero,d04728c <vfclose_locked+0x154>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 d047220:	e0bffc17 	ldw	r2,-16(fp)
 d047224:	11000817 	ldw	r4,32(r2)
 d047228:	d046c580 	call	d046c58 <vf_alloc_buffer>
 d04722c:	e0bffb15 	stw	r2,-20(fp)

         /* if the allocation worked */
         if (new_buffer)
 d047230:	e0bffb17 	ldw	r2,-20(fp)
 d047234:	1005003a 	cmpeq	r2,r2,zero
 d047238:	1000141e 	bne	r2,zero,d04728c <vfclose_locked+0x154>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 d04723c:	e0bffc17 	ldw	r2,-16(fp)
 d047240:	10c00617 	ldw	r3,24(r2)
 d047244:	e0bffc17 	ldw	r2,-16(fp)
 d047248:	11800817 	ldw	r6,32(r2)
 d04724c:	e0bffb17 	ldw	r2,-20(fp)
 d047250:	1009883a 	mov	r4,r2
 d047254:	180b883a 	mov	r5,r3
 d047258:	d0027000 	call	d002700 <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 d04725c:	e0bffc17 	ldw	r2,-16(fp)
 d047260:	11000617 	ldw	r4,24(r2)
 d047264:	e0bffc17 	ldw	r2,-16(fp)
 d047268:	11400917 	ldw	r5,36(r2)
 d04726c:	d046d300 	call	d046d30 <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 d047270:	e0fffc17 	ldw	r3,-16(fp)
 d047274:	e0bffb17 	ldw	r2,-20(fp)
 d047278:	18800615 	stw	r2,24(r3)
            vfp->buf_size = vfp->comp_size;
 d04727c:	e0bffc17 	ldw	r2,-16(fp)
 d047280:	10c00817 	ldw	r3,32(r2)
 d047284:	e0bffc17 	ldw	r2,-16(fp)
 d047288:	10c00915 	stw	r3,36(r2)
      /* break to list deletion code below */
      break;

   }

   if (vlast)  /* unlink from list of open files */
 d04728c:	e0bffd17 	ldw	r2,-12(fp)
 d047290:	1005003a 	cmpeq	r2,r2,zero
 d047294:	1000051e 	bne	r2,zero,d0472ac <vfclose_locked+0x174>
      vlast->next = vtmp->next;
 d047298:	e0bffe17 	ldw	r2,-8(fp)
 d04729c:	10c00017 	ldw	r3,0(r2)
 d0472a0:	e0bffd17 	ldw	r2,-12(fp)
 d0472a4:	10c00015 	stw	r3,0(r2)
 d0472a8:	00000306 	br	d0472b8 <vfclose_locked+0x180>
   else
      vfiles = vtmp->next;
 d0472ac:	e0bffe17 	ldw	r2,-8(fp)
 d0472b0:	10800017 	ldw	r2,0(r2)
 d0472b4:	d0a0d515 	stw	r2,-31916(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 d0472b8:	e13ffe17 	ldw	r4,-8(fp)
 d0472bc:	d029f200 	call	d029f20 <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 d0472c0:	d0a0d917 	ldw	r2,-31900(gp)
 d0472c4:	10bfffc4 	addi	r2,r2,-1
 d0472c8:	d0a0d915 	stw	r2,-31900(gp)
   return;
}
 d0472cc:	e037883a 	mov	sp,fp
 d0472d0:	dfc00117 	ldw	ra,4(sp)
 d0472d4:	df000017 	ldw	fp,0(sp)
 d0472d8:	dec00204 	addi	sp,sp,8
 d0472dc:	f800283a 	ret

0d0472e0 <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 d0472e0:	defffd04 	addi	sp,sp,-12
 d0472e4:	dfc00215 	stw	ra,8(sp)
 d0472e8:	df000115 	stw	fp,4(sp)
 d0472ec:	df000104 	addi	fp,sp,4
 d0472f0:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 d0472f4:	01000144 	movi	r4,5
 d0472f8:	d0299e40 	call	d0299e4 <wait_app_sem>

   vfclose_locked(vfd);
 d0472fc:	e13fff17 	ldw	r4,-4(fp)
 d047300:	d0471380 	call	d047138 <vfclose_locked>

   vfs_unlock();
 d047304:	01000144 	movi	r4,5
 d047308:	d029a980 	call	d029a98 <post_app_sem>
}
 d04730c:	e037883a 	mov	sp,fp
 d047310:	dfc00117 	ldw	ra,4(sp)
 d047314:	df000017 	ldw	fp,0(sp)
 d047318:	dec00204 	addi	sp,sp,8
 d04731c:	f800283a 	ret

0d047320 <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 d047320:	defffd04 	addi	sp,sp,-12
 d047324:	dfc00215 	stw	ra,8(sp)
 d047328:	df000115 	stw	fp,4(sp)
 d04732c:	df000104 	addi	fp,sp,4
 d047330:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 d047334:	01000144 	movi	r4,5
 d047338:	d0299e40 	call	d0299e4 <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 d04733c:	01034174 	movhi	r4,3333
 d047340:	21015704 	addi	r4,r4,1372
 d047344:	d002cc00 	call	d002cc0 <puts>

   vfs_unlock();
 d047348:	01000144 	movi	r4,5
 d04734c:	d029a980 	call	d029a98 <post_app_sem>
   return(0);
 d047350:	0005883a 	mov	r2,zero
}
 d047354:	e037883a 	mov	sp,fp
 d047358:	dfc00117 	ldw	ra,4(sp)
 d04735c:	df000017 	ldw	fp,0(sp)
 d047360:	dec00204 	addi	sp,sp,8
 d047364:	f800283a 	ret

0d047368 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 d047368:	defff804 	addi	sp,sp,-32
 d04736c:	dfc00715 	stw	ra,28(sp)
 d047370:	df000615 	stw	fp,24(sp)
 d047374:	df000604 	addi	fp,sp,24
 d047378:	e13ffc15 	stw	r4,-16(fp)
 d04737c:	e17ffd15 	stw	r5,-12(fp)
 d047380:	e1bffe15 	stw	r6,-8(fp)
   int c;
   char * ret;

   ret = s;
 d047384:	e0bffc17 	ldw	r2,-16(fp)
 d047388:	e0bffa15 	stw	r2,-24(fp)
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 d04738c:	00001106 	br	d0473d4 <vfgets+0x6c>
      if (( *ret ++ = c) == '\n')
 d047390:	e0bffb17 	ldw	r2,-20(fp)
 d047394:	1007883a 	mov	r3,r2
 d047398:	e0bffa17 	ldw	r2,-24(fp)
 d04739c:	10c00005 	stb	r3,0(r2)
 d0473a0:	e0bffa17 	ldw	r2,-24(fp)
 d0473a4:	10800003 	ldbu	r2,0(r2)
 d0473a8:	10803fcc 	andi	r2,r2,255
 d0473ac:	1080201c 	xori	r2,r2,128
 d0473b0:	10bfe004 	addi	r2,r2,-128
 d0473b4:	108002a0 	cmpeqi	r2,r2,10
 d0473b8:	1007883a 	mov	r3,r2
 d0473bc:	e0bffa17 	ldw	r2,-24(fp)
 d0473c0:	10800044 	addi	r2,r2,1
 d0473c4:	e0bffa15 	stw	r2,-24(fp)
 d0473c8:	18803fcc 	andi	r2,r3,255
 d0473cc:	1004c03a 	cmpne	r2,r2,zero
 d0473d0:	10000c1e 	bne	r2,zero,d047404 <vfgets+0x9c>
{
   int c;
   char * ret;

   ret = s;
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 d0473d4:	e0bffd17 	ldw	r2,-12(fp)
 d0473d8:	10bfffc4 	addi	r2,r2,-1
 d0473dc:	e0bffd15 	stw	r2,-12(fp)
 d0473e0:	e0bffd17 	ldw	r2,-12(fp)
 d0473e4:	10800050 	cmplti	r2,r2,1
 d0473e8:	1000061e 	bne	r2,zero,d047404 <vfgets+0x9c>
 d0473ec:	e13ffe17 	ldw	r4,-8(fp)
 d0473f0:	d0480e40 	call	d0480e4 <vgetc>
 d0473f4:	e0bffb15 	stw	r2,-20(fp)
 d0473f8:	e0bffb17 	ldw	r2,-20(fp)
 d0473fc:	10bfffd8 	cmpnei	r2,r2,-1
 d047400:	103fe31e 	bne	r2,zero,d047390 <vfgets+0x28>
      if (( *ret ++ = c) == '\n')
         break;
   *ret = '\0';
 d047404:	e0bffa17 	ldw	r2,-24(fp)
 d047408:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 d04740c:	e0bffb17 	ldw	r2,-20(fp)
 d047410:	10bfffd8 	cmpnei	r2,r2,-1
 d047414:	1000031e 	bne	r2,zero,d047424 <vfgets+0xbc>
 d047418:	e0fffa17 	ldw	r3,-24(fp)
 d04741c:	e0bffc17 	ldw	r2,-16(fp)
 d047420:	18800326 	beq	r3,r2,d047430 <vfgets+0xc8>
 d047424:	e0bffc17 	ldw	r2,-16(fp)
 d047428:	e0bfff15 	stw	r2,-4(fp)
 d04742c:	00000106 	br	d047434 <vfgets+0xcc>
 d047430:	e03fff15 	stw	zero,-4(fp)
 d047434:	e0bfff17 	ldw	r2,-4(fp)
}
 d047438:	e037883a 	mov	sp,fp
 d04743c:	dfc00117 	ldw	ra,4(sp)
 d047440:	df000017 	ldw	fp,0(sp)
 d047444:	dec00204 	addi	sp,sp,8
 d047448:	f800283a 	ret

0d04744c <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 d04744c:	defffb04 	addi	sp,sp,-20
 d047450:	dfc00415 	stw	ra,16(sp)
 d047454:	df000315 	stw	fp,12(sp)
 d047458:	df000304 	addi	fp,sp,12
 d04745c:	e13ffe15 	stw	r4,-8(fp)
   int c = 0;
 d047460:	e03ffd15 	stw	zero,-12(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 d047464:	e13ffe17 	ldw	r4,-8(fp)
 d047468:	d0480e40 	call	d0480e4 <vgetc>
 d04746c:	e0bffd15 	stw	r2,-12(fp)
 d047470:	e0bffd17 	ldw	r2,-12(fp)
 d047474:	10bfffd8 	cmpnei	r2,r2,-1
 d047478:	1000031e 	bne	r2,zero,d047488 <vfeof+0x3c>
   {
      return 1;
 d04747c:	00800044 	movi	r2,1
 d047480:	e0bfff15 	stw	r2,-4(fp)
 d047484:	00000106 	br	d04748c <vfeof+0x40>
   }   
   return 0;
 d047488:	e03fff15 	stw	zero,-4(fp)
 d04748c:	e0bfff17 	ldw	r2,-4(fp)
}
 d047490:	e037883a 	mov	sp,fp
 d047494:	dfc00117 	ldw	ra,4(sp)
 d047498:	df000017 	ldw	fp,0(sp)
 d04749c:	dec00204 	addi	sp,sp,8
 d0474a0:	f800283a 	ret

0d0474a4 <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 d0474a4:	defffd04 	addi	sp,sp,-12
 d0474a8:	df000215 	stw	fp,8(sp)
 d0474ac:	df000204 	addi	fp,sp,8
 d0474b0:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 d0474b4:	d0a0d517 	ldw	r2,-31916(gp)
 d0474b8:	e0bffe15 	stw	r2,-8(fp)
 d0474bc:	00000906 	br	d0474e4 <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 d0474c0:	e0bffe17 	ldw	r2,-8(fp)
 d0474c4:	10c00117 	ldw	r3,4(r2)
 d0474c8:	e0bfff17 	ldw	r2,-4(fp)
 d0474cc:	1880021e 	bne	r3,r2,d0474d8 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 d0474d0:	e0bffe17 	ldw	r2,-8(fp)
 d0474d4:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 d0474d8:	e0bffe17 	ldw	r2,-8(fp)
 d0474dc:	10800017 	ldw	r2,0(r2)
 d0474e0:	e0bffe15 	stw	r2,-8(fp)
 d0474e4:	e0bffe17 	ldw	r2,-8(fp)
 d0474e8:	1004c03a 	cmpne	r2,r2,zero
 d0474ec:	103ff41e 	bne	r2,zero,d0474c0 <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 d0474f0:	e037883a 	mov	sp,fp
 d0474f4:	df000017 	ldw	fp,0(sp)
 d0474f8:	dec00104 	addi	sp,sp,4
 d0474fc:	f800283a 	ret

0d047500 <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 d047500:	defff504 	addi	sp,sp,-44
 d047504:	dfc00a15 	stw	ra,40(sp)
 d047508:	df000915 	stw	fp,36(sp)
 d04750c:	df000904 	addi	fp,sp,36
 d047510:	e13ffe15 	stw	r4,-8(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 d047514:	e03ffc15 	stw	zero,-16(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name));
 d047518:	e13ffe17 	ldw	r4,-8(fp)
 d04751c:	d00355c0 	call	d00355c <strlen>
 d047520:	1009883a 	mov	r4,r2
 d047524:	d049ec00 	call	d049ec0 <malloc>
 d047528:	e0bff815 	stw	r2,-32(fp)
   strcpy(name, const_name);
 d04752c:	e13ff817 	ldw	r4,-32(fp)
 d047530:	e17ffe17 	ldw	r5,-8(fp)
 d047534:	d049f480 	call	d049f48 <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 d047538:	01000144 	movi	r4,5
 d04753c:	d0299e40 	call	d0299e4 <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 d047540:	e13ff817 	ldw	r4,-32(fp)
 d047544:	d04812c0 	call	d04812c <vfslookup_locked>
 d047548:	e0bffd15 	stw	r2,-12(fp)
 d04754c:	e0bffd17 	ldw	r2,-12(fp)
 d047550:	1004c03a 	cmpne	r2,r2,zero
 d047554:	1000071e 	bne	r2,zero,d047574 <vunlink+0x74>
   {
      vfs_unlock();
 d047558:	01000144 	movi	r4,5
 d04755c:	d029a980 	call	d029a98 <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 d047560:	e13ff817 	ldw	r4,-32(fp)
 d047564:	d049eac0 	call	d049eac <free>
      return -1;
 d047568:	00bfffc4 	movi	r2,-1
 d04756c:	e0bfff15 	stw	r2,-4(fp)
 d047570:	00006506 	br	d047708 <vunlink+0x208>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 d047574:	e0bffd17 	ldw	r2,-12(fp)
 d047578:	10800017 	ldw	r2,0(r2)
 d04757c:	e0bff915 	stw	r2,-28(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 d047580:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 d047584:	d0a0d617 	ldw	r2,-31912(gp)
 d047588:	e0bffb15 	stw	r2,-20(fp)
 d04758c:	00000806 	br	d0475b0 <vunlink+0xb0>
   {
      if (vtmp == vfp)
 d047590:	e0fffb17 	ldw	r3,-20(fp)
 d047594:	e0bffd17 	ldw	r2,-12(fp)
 d047598:	18800826 	beq	r3,r2,d0475bc <vunlink+0xbc>
         break;
      vflast = vtmp;
 d04759c:	e0bffb17 	ldw	r2,-20(fp)
 d0475a0:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 d0475a4:	e0bffb17 	ldw	r2,-20(fp)
 d0475a8:	10800017 	ldw	r2,0(r2)
 d0475ac:	e0bffb15 	stw	r2,-20(fp)
 d0475b0:	e0bffb17 	ldw	r2,-20(fp)
 d0475b4:	1004c03a 	cmpne	r2,r2,zero
 d0475b8:	103ff51e 	bne	r2,zero,d047590 <vunlink+0x90>
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 d0475bc:	e0bffb17 	ldw	r2,-20(fp)
 d0475c0:	1004c03a 	cmpne	r2,r2,zero
 d0475c4:	1000081e 	bne	r2,zero,d0475e8 <vunlink+0xe8>
   {
      dtrap();
 d0475c8:	d0293e80 	call	d0293e8 <dtrap>
      vfs_unlock();
 d0475cc:	01000144 	movi	r4,5
 d0475d0:	d029a980 	call	d029a98 <post_app_sem>
      free(name);
 d0475d4:	e13ff817 	ldw	r4,-32(fp)
 d0475d8:	d049eac0 	call	d049eac <free>
      return -1;
 d0475dc:	00bfffc4 	movi	r2,-1
 d0475e0:	e0bfff15 	stw	r2,-4(fp)
 d0475e4:	00004806 	br	d047708 <vunlink+0x208>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 d0475e8:	e0bffd17 	ldw	r2,-12(fp)
 d0475ec:	10800a17 	ldw	r2,40(r2)
 d0475f0:	1005003a 	cmpeq	r2,r2,zero
 d0475f4:	1000091e 	bne	r2,zero,d04761c <vunlink+0x11c>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 d0475f8:	e0bffd17 	ldw	r2,-12(fp)
 d0475fc:	10800a17 	ldw	r2,40(r2)
 d047600:	e0bff715 	stw	r2,-36(fp)

         rc = vfs->r_unlink(name);
 d047604:	e0bff717 	ldw	r2,-36(fp)
 d047608:	10800817 	ldw	r2,32(r2)
 d04760c:	e13ff817 	ldw	r4,-32(fp)
 d047610:	103ee83a 	callr	r2
 d047614:	e0bffc15 	stw	r2,-16(fp)
         break;   /* break to list deletion code after end of phoney loop */
 d047618:	00002806 	br	d0476bc <vunlink+0x1bc>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 d04761c:	e0bffd17 	ldw	r2,-12(fp)
 d047620:	1080058b 	ldhu	r2,22(r2)
 d047624:	10bfffcc 	andi	r2,r2,65535
 d047628:	1080080c 	andi	r2,r2,32
 d04762c:	1004c03a 	cmpne	r2,r2,zero
 d047630:	1000071e 	bne	r2,zero,d047650 <vunlink+0x150>
      {
         vfs_unlock();
 d047634:	01000144 	movi	r4,5
 d047638:	d029a980 	call	d029a98 <post_app_sem>
         free(name);
 d04763c:	e13ff817 	ldw	r4,-32(fp)
 d047640:	d049eac0 	call	d049eac <free>
         return -1;
 d047644:	00bfffc4 	movi	r2,-1
 d047648:	e0bfff15 	stw	r2,-4(fp)
 d04764c:	00002e06 	br	d047708 <vunlink+0x208>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 d047650:	e0bffd17 	ldw	r2,-12(fp)
 d047654:	1080058b 	ldhu	r2,22(r2)
 d047658:	10bfffcc 	andi	r2,r2,65535
 d04765c:	1080200c 	andi	r2,r2,128
 d047660:	1005003a 	cmpeq	r2,r2,zero
 d047664:	1000091e 	bne	r2,zero,d04768c <vunlink+0x18c>
 d047668:	e0bffd17 	ldw	r2,-12(fp)
 d04766c:	10800617 	ldw	r2,24(r2)
 d047670:	1005003a 	cmpeq	r2,r2,zero
 d047674:	1000051e 	bne	r2,zero,d04768c <vunlink+0x18c>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 d047678:	e0bffd17 	ldw	r2,-12(fp)
 d04767c:	11000617 	ldw	r4,24(r2)
 d047680:	e0bffd17 	ldw	r2,-12(fp)
 d047684:	11400917 	ldw	r5,36(r2)
 d047688:	d046d300 	call	d046d30 <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 d04768c:	e0bffd17 	ldw	r2,-12(fp)
 d047690:	1080058b 	ldhu	r2,22(r2)
 d047694:	10bfffcc 	andi	r2,r2,65535
 d047698:	1080100c 	andi	r2,r2,64
 d04769c:	1005003a 	cmpeq	r2,r2,zero
 d0476a0:	1000051e 	bne	r2,zero,d0476b8 <vunlink+0x1b8>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 d0476a4:	d0a0db17 	ldw	r2,-31892(gp)
 d0476a8:	10bfffc4 	addi	r2,r2,-1
 d0476ac:	d0a0db15 	stw	r2,-31892(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 d0476b0:	e13ffd17 	ldw	r4,-12(fp)
 d0476b4:	d029f200 	call	d029f20 <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 d0476b8:	e03ffc15 	stw	zero,-16(fp)

      break;
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 d0476bc:	e0bffa17 	ldw	r2,-24(fp)
 d0476c0:	1005003a 	cmpeq	r2,r2,zero
 d0476c4:	1000041e 	bne	r2,zero,d0476d8 <vunlink+0x1d8>
      vflast->next = vfnext;
 d0476c8:	e0fffa17 	ldw	r3,-24(fp)
 d0476cc:	e0bff917 	ldw	r2,-28(fp)
 d0476d0:	18800015 	stw	r2,0(r3)
 d0476d4:	00000206 	br	d0476e0 <vunlink+0x1e0>
   else
      vfsfiles = vfnext;
 d0476d8:	e0bff917 	ldw	r2,-28(fp)
 d0476dc:	d0a0d615 	stw	r2,-31912(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 d0476e0:	e13ffd17 	ldw	r4,-12(fp)
 d0476e4:	d0474a40 	call	d0474a4 <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 d0476e8:	00800044 	movi	r2,1
 d0476ec:	d0a0d815 	stw	r2,-31904(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 d0476f0:	01000144 	movi	r4,5
 d0476f4:	d029a980 	call	d029a98 <post_app_sem>
   free(name);
 d0476f8:	e13ff817 	ldw	r4,-32(fp)
 d0476fc:	d049eac0 	call	d049eac <free>
   return rc;
 d047700:	e0bffc17 	ldw	r2,-16(fp)
 d047704:	e0bfff15 	stw	r2,-4(fp)
 d047708:	e0bfff17 	ldw	r2,-4(fp)
}
 d04770c:	e037883a 	mov	sp,fp
 d047710:	dfc00117 	ldw	ra,4(sp)
 d047714:	df000017 	ldw	fp,0(sp)
 d047718:	dec00204 	addi	sp,sp,8
 d04771c:	f800283a 	ret

0d047720 <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d047720:	defff504 	addi	sp,sp,-44
 d047724:	dfc00a15 	stw	ra,40(sp)
 d047728:	df000915 	stw	fp,36(sp)
 d04772c:	df000904 	addi	fp,sp,36
 d047730:	e13ffb15 	stw	r4,-20(fp)
 d047734:	e17ffc15 	stw	r5,-16(fp)
 d047738:	e1bffd15 	stw	r6,-12(fp)
 d04773c:	e1fffe15 	stw	r7,-8(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 d047740:	01000144 	movi	r4,5
 d047744:	d0299e40 	call	d0299e4 <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 d047748:	e13ffe17 	ldw	r4,-8(fp)
 d04774c:	d0484940 	call	d048494 <isvfile_locked>
 d047750:	1005003a 	cmpeq	r2,r2,zero
 d047754:	1000541e 	bne	r2,zero,d0478a8 <vfread+0x188>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 d047758:	e0bffe17 	ldw	r2,-8(fp)
 d04775c:	10800117 	ldw	r2,4(r2)
 d047760:	1004c03a 	cmpne	r2,r2,zero
 d047764:	1000041e 	bne	r2,zero,d047778 <vfread+0x58>
      {
         vfs_unlock();
 d047768:	01000144 	movi	r4,5
 d04776c:	d029a980 	call	d029a98 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 d047770:	e03fff15 	stw	zero,-4(fp)
 d047774:	00004f06 	br	d0478b4 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 d047778:	e0bffe17 	ldw	r2,-8(fp)
 d04777c:	10800117 	ldw	r2,4(r2)
 d047780:	10800a17 	ldw	r2,40(r2)
 d047784:	1005003a 	cmpeq	r2,r2,zero
 d047788:	1000111e 	bne	r2,zero,d0477d0 <vfread+0xb0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 d04778c:	e0bffe17 	ldw	r2,-8(fp)
 d047790:	10800117 	ldw	r2,4(r2)
 d047794:	10800a17 	ldw	r2,40(r2)
 d047798:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 d04779c:	e0bff917 	ldw	r2,-28(fp)
 d0477a0:	10800317 	ldw	r2,12(r2)
 d0477a4:	e13ffb17 	ldw	r4,-20(fp)
 d0477a8:	e17ffc17 	ldw	r5,-16(fp)
 d0477ac:	e1bffd17 	ldw	r6,-12(fp)
 d0477b0:	e1fffe17 	ldw	r7,-8(fp)
 d0477b4:	103ee83a 	callr	r2
 d0477b8:	e0bff815 	stw	r2,-32(fp)
         vfs_unlock();
 d0477bc:	01000144 	movi	r4,5
 d0477c0:	d029a980 	call	d029a98 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 d0477c4:	e0bff817 	ldw	r2,-32(fp)
 d0477c8:	e0bfff15 	stw	r2,-4(fp)
 d0477cc:	00003906 	br	d0478b4 <vfread+0x194>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 d0477d0:	e0bffe17 	ldw	r2,-8(fp)
 d0477d4:	10800117 	ldw	r2,4(r2)
 d0477d8:	10800617 	ldw	r2,24(r2)
 d0477dc:	1004c03a 	cmpne	r2,r2,zero
 d0477e0:	1000041e 	bne	r2,zero,d0477f4 <vfread+0xd4>
      {
         vfs_unlock();
 d0477e4:	01000144 	movi	r4,5
 d0477e8:	d029a980 	call	d029a98 <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 d0477ec:	e03fff15 	stw	zero,-4(fp)
 d0477f0:	00003006 	br	d0478b4 <vfread+0x194>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 d0477f4:	e0fffd17 	ldw	r3,-12(fp)
 d0477f8:	e0bffc17 	ldw	r2,-16(fp)
 d0477fc:	1885383a 	mul	r2,r3,r2
 d047800:	e0bffa15 	stw	r2,-24(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 d047804:	e0bffe17 	ldw	r2,-8(fp)
 d047808:	10800217 	ldw	r2,8(r2)
 d04780c:	1007883a 	mov	r3,r2
 d047810:	e0bffe17 	ldw	r2,-8(fp)
 d047814:	10800117 	ldw	r2,4(r2)
 d047818:	10800617 	ldw	r2,24(r2)
 d04781c:	1885c83a 	sub	r2,r3,r2
 d047820:	e0bff715 	stw	r2,-36(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 d047824:	e0fff717 	ldw	r3,-36(fp)
 d047828:	e0bffa17 	ldw	r2,-24(fp)
 d04782c:	1887883a 	add	r3,r3,r2
 d047830:	e0bffe17 	ldw	r2,-8(fp)
 d047834:	10800117 	ldw	r2,4(r2)
 d047838:	10800817 	ldw	r2,32(r2)
 d04783c:	10c0062e 	bgeu	r2,r3,d047858 <vfread+0x138>
            bcount = (unsigned)(vfd->file->comp_size - location);
 d047840:	e0bffe17 	ldw	r2,-8(fp)
 d047844:	10800117 	ldw	r2,4(r2)
 d047848:	10c00817 	ldw	r3,32(r2)
 d04784c:	e0bff717 	ldw	r2,-36(fp)
 d047850:	1885c83a 	sub	r2,r3,r2
 d047854:	e0bffa15 	stw	r2,-24(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 d047858:	e0bffe17 	ldw	r2,-8(fp)
 d04785c:	10c00217 	ldw	r3,8(r2)
 d047860:	e0bffb17 	ldw	r2,-20(fp)
 d047864:	1009883a 	mov	r4,r2
 d047868:	180b883a 	mov	r5,r3
 d04786c:	e1bffa17 	ldw	r6,-24(fp)
 d047870:	d0027000 	call	d002700 <memcpy>
         vfd->cmploc += bcount;
 d047874:	e0bffe17 	ldw	r2,-8(fp)
 d047878:	10c00217 	ldw	r3,8(r2)
 d04787c:	e0bffa17 	ldw	r2,-24(fp)
 d047880:	1887883a 	add	r3,r3,r2
 d047884:	e0bffe17 	ldw	r2,-8(fp)
 d047888:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 d04788c:	01000144 	movi	r4,5
 d047890:	d029a980 	call	d029a98 <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 d047894:	e0fffa17 	ldw	r3,-24(fp)
 d047898:	e0bffc17 	ldw	r2,-16(fp)
 d04789c:	1885203a 	divu	r2,r3,r2
 d0478a0:	e0bfff15 	stw	r2,-4(fp)
 d0478a4:	00000306 	br	d0478b4 <vfread+0x194>
   }

   vfs_unlock();
 d0478a8:	01000144 	movi	r4,5
 d0478ac:	d029a980 	call	d029a98 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 d0478b0:	e03fff15 	stw	zero,-4(fp)
 d0478b4:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 d0478b8:	e037883a 	mov	sp,fp
 d0478bc:	dfc00117 	ldw	ra,4(sp)
 d0478c0:	df000017 	ldw	fp,0(sp)
 d0478c4:	dec00204 	addi	sp,sp,8
 d0478c8:	f800283a 	ret

0d0478cc <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d0478cc:	defff104 	addi	sp,sp,-60
 d0478d0:	dfc00e15 	stw	ra,56(sp)
 d0478d4:	df000d15 	stw	fp,52(sp)
 d0478d8:	df000d04 	addi	fp,sp,52
 d0478dc:	e13ffb15 	stw	r4,-20(fp)
 d0478e0:	e17ffc15 	stw	r5,-16(fp)
 d0478e4:	e1bffd15 	stw	r6,-12(fp)
 d0478e8:	e1fffe15 	stw	r7,-8(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 d0478ec:	e13ffe17 	ldw	r4,-8(fp)
 d0478f0:	d0484940 	call	d048494 <isvfile_locked>
 d0478f4:	1004c03a 	cmpne	r2,r2,zero
 d0478f8:	1000031e 	bne	r2,zero,d047908 <vfwrite_locked+0x3c>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 d0478fc:	00800244 	movi	r2,9
 d047900:	e0bfff15 	stw	r2,-4(fp)
 d047904:	0000e506 	br	d047c9c <vfwrite_locked+0x3d0>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 d047908:	e0bffe17 	ldw	r2,-8(fp)
 d04790c:	10800117 	ldw	r2,4(r2)
 d047910:	10800a17 	ldw	r2,40(r2)
 d047914:	1005003a 	cmpeq	r2,r2,zero
 d047918:	10000f1e 	bne	r2,zero,d047958 <vfwrite_locked+0x8c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 d04791c:	e0bffe17 	ldw	r2,-8(fp)
 d047920:	10800117 	ldw	r2,4(r2)
 d047924:	10800a17 	ldw	r2,40(r2)
 d047928:	e0bff715 	stw	r2,-36(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 d04792c:	e0bff717 	ldw	r2,-36(fp)
 d047930:	10800417 	ldw	r2,16(r2)
 d047934:	e13ffb17 	ldw	r4,-20(fp)
 d047938:	e17ffc17 	ldw	r5,-16(fp)
 d04793c:	e1bffd17 	ldw	r6,-12(fp)
 d047940:	e1fffe17 	ldw	r7,-8(fp)
 d047944:	103ee83a 	callr	r2
 d047948:	e0bff615 	stw	r2,-40(fp)
      return rc;
 d04794c:	e0bff617 	ldw	r2,-40(fp)
 d047950:	e0bfff15 	stw	r2,-4(fp)
 d047954:	0000d106 	br	d047c9c <vfwrite_locked+0x3d0>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 d047958:	e0bffe17 	ldw	r2,-8(fp)
 d04795c:	10800117 	ldw	r2,4(r2)
 d047960:	1004c03a 	cmpne	r2,r2,zero
 d047964:	1000021e 	bne	r2,zero,d047970 <vfwrite_locked+0xa4>
   {
      return 0;
 d047968:	e03fff15 	stw	zero,-4(fp)
 d04796c:	0000cb06 	br	d047c9c <vfwrite_locked+0x3d0>
   }

   vfp = vfd->file;
 d047970:	e0bffe17 	ldw	r2,-8(fp)
 d047974:	10800117 	ldw	r2,4(r2)
 d047978:	e0bff815 	stw	r2,-32(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 d04797c:	e0bff817 	ldw	r2,-32(fp)
 d047980:	1080058b 	ldhu	r2,22(r2)
 d047984:	10bfffcc 	andi	r2,r2,65535
 d047988:	1080080c 	andi	r2,r2,32
 d04798c:	1004c03a 	cmpne	r2,r2,zero
 d047990:	1000051e 	bne	r2,zero,d0479a8 <vfwrite_locked+0xdc>
   {
      vfd->error = ENP_FILEIO;
 d047994:	e0fffe17 	ldw	r3,-8(fp)
 d047998:	00bff984 	movi	r2,-26
 d04799c:	18800415 	stw	r2,16(r3)
      return 0;
 d0479a0:	e03fff15 	stw	zero,-4(fp)
 d0479a4:	0000bd06 	br	d047c9c <vfwrite_locked+0x3d0>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 d0479a8:	e0fffc17 	ldw	r3,-16(fp)
 d0479ac:	e0bffd17 	ldw	r2,-12(fp)
 d0479b0:	1885383a 	mul	r2,r3,r2
 d0479b4:	e0bffa15 	stw	r2,-24(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 d0479b8:	e0bffa17 	ldw	r2,-24(fp)
 d0479bc:	1004c03a 	cmpne	r2,r2,zero
 d0479c0:	1000021e 	bne	r2,zero,d0479cc <vfwrite_locked+0x100>
   {
      return 0;
 d0479c4:	e03fff15 	stw	zero,-4(fp)
 d0479c8:	0000b406 	br	d047c9c <vfwrite_locked+0x3d0>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 d0479cc:	e0bff817 	ldw	r2,-32(fp)
 d0479d0:	10800617 	ldw	r2,24(r2)
 d0479d4:	1004c03a 	cmpne	r2,r2,zero
 d0479d8:	1000401e 	bne	r2,zero,d047adc <vfwrite_locked+0x210>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 d0479dc:	e0bffa17 	ldw	r2,-24(fp)
 d0479e0:	10bfffc4 	addi	r2,r2,-1
 d0479e4:	1004d37a 	srli	r2,r2,13
 d0479e8:	1004937a 	slli	r2,r2,13
 d0479ec:	10880004 	addi	r2,r2,8192
 d0479f0:	e0bff515 	stw	r2,-44(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 d0479f4:	e13ff517 	ldw	r4,-44(fp)
 d0479f8:	d046c580 	call	d046c58 <vf_alloc_buffer>
 d0479fc:	1007883a 	mov	r3,r2
 d047a00:	e0bff817 	ldw	r2,-32(fp)
 d047a04:	10c00615 	stw	r3,24(r2)

      /* if the allocation failed */
      if (!(vfp->data))
 d047a08:	e0bff817 	ldw	r2,-32(fp)
 d047a0c:	10800617 	ldw	r2,24(r2)
 d047a10:	1004c03a 	cmpne	r2,r2,zero
 d047a14:	1000051e 	bne	r2,zero,d047a2c <vfwrite_locked+0x160>
      {
         vfd->error = ENP_NOMEM;
 d047a18:	e0fffe17 	ldw	r3,-8(fp)
 d047a1c:	00bffb04 	movi	r2,-20
 d047a20:	18800415 	stw	r2,16(r3)
         return 0;
 d047a24:	e03fff15 	stw	zero,-4(fp)
 d047a28:	00009c06 	br	d047c9c <vfwrite_locked+0x3d0>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 d047a2c:	e0fff817 	ldw	r3,-32(fp)
 d047a30:	e0bff517 	ldw	r2,-44(fp)
 d047a34:	18800915 	stw	r2,36(r3)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 d047a38:	e0fff817 	ldw	r3,-32(fp)
 d047a3c:	e0bffa17 	ldw	r2,-24(fp)
 d047a40:	18800715 	stw	r2,28(r3)
      vfp->comp_size = bcount;
 d047a44:	e0fff817 	ldw	r3,-32(fp)
 d047a48:	e0bffa17 	ldw	r2,-24(fp)
 d047a4c:	18800815 	stw	r2,32(r3)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 d047a50:	e0bff817 	ldw	r2,-32(fp)
 d047a54:	10c00617 	ldw	r3,24(r2)
 d047a58:	e0bffa17 	ldw	r2,-24(fp)
 d047a5c:	1887883a 	add	r3,r3,r2
 d047a60:	e0bffe17 	ldw	r2,-8(fp)
 d047a64:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 d047a68:	e0bff817 	ldw	r2,-32(fp)
 d047a6c:	10c0058b 	ldhu	r3,22(r2)
 d047a70:	00bfff84 	movi	r2,-2
 d047a74:	1884703a 	and	r2,r3,r2
 d047a78:	1007883a 	mov	r3,r2
 d047a7c:	e0bff817 	ldw	r2,-32(fp)
 d047a80:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 d047a84:	e0bff817 	ldw	r2,-32(fp)
 d047a88:	1080058b 	ldhu	r2,22(r2)
 d047a8c:	10808014 	ori	r2,r2,512
 d047a90:	1007883a 	mov	r3,r2
 d047a94:	e0bff817 	ldw	r2,-32(fp)
 d047a98:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 d047a9c:	e0bff817 	ldw	r2,-32(fp)
 d047aa0:	1080058b 	ldhu	r2,22(r2)
 d047aa4:	10802014 	ori	r2,r2,128
 d047aa8:	1007883a 	mov	r3,r2
 d047aac:	e0bff817 	ldw	r2,-32(fp)
 d047ab0:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 d047ab4:	e0bff817 	ldw	r2,-32(fp)
 d047ab8:	10800617 	ldw	r2,24(r2)
 d047abc:	e0fffb17 	ldw	r3,-20(fp)
 d047ac0:	1009883a 	mov	r4,r2
 d047ac4:	180b883a 	mov	r5,r3
 d047ac8:	e1bffa17 	ldw	r6,-24(fp)
 d047acc:	d0027000 	call	d002700 <memcpy>

      /* return the number of "items" written */
      return items;
 d047ad0:	e0bffd17 	ldw	r2,-12(fp)
 d047ad4:	e0bfff15 	stw	r2,-4(fp)
 d047ad8:	00007006 	br	d047c9c <vfwrite_locked+0x3d0>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 d047adc:	e0bffe17 	ldw	r2,-8(fp)
 d047ae0:	10800217 	ldw	r2,8(r2)
 d047ae4:	1007883a 	mov	r3,r2
 d047ae8:	e0bff817 	ldw	r2,-32(fp)
 d047aec:	10800617 	ldw	r2,24(r2)
 d047af0:	1885c83a 	sub	r2,r3,r2
 d047af4:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 d047af8:	e0fff917 	ldw	r3,-28(fp)
 d047afc:	e0bffa17 	ldw	r2,-24(fp)
 d047b00:	1887883a 	add	r3,r3,r2
 d047b04:	e0bff817 	ldw	r2,-32(fp)
 d047b08:	10800917 	ldw	r2,36(r2)
 d047b0c:	10c0382e 	bgeu	r2,r3,d047bf0 <vfwrite_locked+0x324>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 d047b10:	e0fff917 	ldw	r3,-28(fp)
 d047b14:	e0bffa17 	ldw	r2,-24(fp)
 d047b18:	1885883a 	add	r2,r3,r2
 d047b1c:	10bfffc4 	addi	r2,r2,-1
 d047b20:	1004d37a 	srli	r2,r2,13
 d047b24:	1004937a 	slli	r2,r2,13
 d047b28:	10880004 	addi	r2,r2,8192
 d047b2c:	e0bff415 	stw	r2,-48(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 d047b30:	e13ff417 	ldw	r4,-48(fp)
 d047b34:	d046c580 	call	d046c58 <vf_alloc_buffer>
 d047b38:	e0bff315 	stw	r2,-52(fp)

      /* check for allocation failure */
      if (!new_buffer)
 d047b3c:	e0bff317 	ldw	r2,-52(fp)
 d047b40:	1004c03a 	cmpne	r2,r2,zero
 d047b44:	1000051e 	bne	r2,zero,d047b5c <vfwrite_locked+0x290>
      {
         vfd->error = ENP_NOMEM;
 d047b48:	e0fffe17 	ldw	r3,-8(fp)
 d047b4c:	00bffb04 	movi	r2,-20
 d047b50:	18800415 	stw	r2,16(r3)
         return 0;
 d047b54:	e03fff15 	stw	zero,-4(fp)
 d047b58:	00005006 	br	d047c9c <vfwrite_locked+0x3d0>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 d047b5c:	e0bff817 	ldw	r2,-32(fp)
 d047b60:	10c00617 	ldw	r3,24(r2)
 d047b64:	e0bff817 	ldw	r2,-32(fp)
 d047b68:	11800817 	ldw	r6,32(r2)
 d047b6c:	e0bff317 	ldw	r2,-52(fp)
 d047b70:	1009883a 	mov	r4,r2
 d047b74:	180b883a 	mov	r5,r3
 d047b78:	d0027000 	call	d002700 <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 d047b7c:	e0bff817 	ldw	r2,-32(fp)
 d047b80:	1080058b 	ldhu	r2,22(r2)
 d047b84:	10bfffcc 	andi	r2,r2,65535
 d047b88:	1080200c 	andi	r2,r2,128
 d047b8c:	1005003a 	cmpeq	r2,r2,zero
 d047b90:	1000051e 	bne	r2,zero,d047ba8 <vfwrite_locked+0x2dc>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 d047b94:	e0bff817 	ldw	r2,-32(fp)
 d047b98:	11000617 	ldw	r4,24(r2)
 d047b9c:	e0bff817 	ldw	r2,-32(fp)
 d047ba0:	11400917 	ldw	r5,36(r2)
 d047ba4:	d046d300 	call	d046d30 <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 d047ba8:	e0fff817 	ldw	r3,-32(fp)
 d047bac:	e0bff317 	ldw	r2,-52(fp)
 d047bb0:	18800615 	stw	r2,24(r3)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 d047bb4:	e0fff817 	ldw	r3,-32(fp)
 d047bb8:	e0bff417 	ldw	r2,-48(fp)
 d047bbc:	18800915 	stw	r2,36(r3)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 d047bc0:	e0bff817 	ldw	r2,-32(fp)
 d047bc4:	1080058b 	ldhu	r2,22(r2)
 d047bc8:	10802014 	ori	r2,r2,128
 d047bcc:	1007883a 	mov	r3,r2
 d047bd0:	e0bff817 	ldw	r2,-32(fp)
 d047bd4:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 d047bd8:	e0bff817 	ldw	r2,-32(fp)
 d047bdc:	10c00617 	ldw	r3,24(r2)
 d047be0:	e0bff917 	ldw	r2,-28(fp)
 d047be4:	1887883a 	add	r3,r3,r2
 d047be8:	e0bffe17 	ldw	r2,-8(fp)
 d047bec:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 d047bf0:	e0bffe17 	ldw	r2,-8(fp)
 d047bf4:	10800217 	ldw	r2,8(r2)
 d047bf8:	e0fffb17 	ldw	r3,-20(fp)
 d047bfc:	1009883a 	mov	r4,r2
 d047c00:	180b883a 	mov	r5,r3
 d047c04:	e1bffa17 	ldw	r6,-24(fp)
 d047c08:	d0027000 	call	d002700 <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 d047c0c:	e0bffe17 	ldw	r2,-8(fp)
 d047c10:	10c00217 	ldw	r3,8(r2)
 d047c14:	e0bffa17 	ldw	r2,-24(fp)
 d047c18:	1887883a 	add	r3,r3,r2
 d047c1c:	e0bffe17 	ldw	r2,-8(fp)
 d047c20:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 d047c24:	e0fff917 	ldw	r3,-28(fp)
 d047c28:	e0bffa17 	ldw	r2,-24(fp)
 d047c2c:	1887883a 	add	r3,r3,r2
 d047c30:	e0bff817 	ldw	r2,-32(fp)
 d047c34:	10800817 	ldw	r2,32(r2)
 d047c38:	10c0052e 	bgeu	r2,r3,d047c50 <vfwrite_locked+0x384>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 d047c3c:	e0fff917 	ldw	r3,-28(fp)
 d047c40:	e0bffa17 	ldw	r2,-24(fp)
 d047c44:	1887883a 	add	r3,r3,r2
 d047c48:	e0bff817 	ldw	r2,-32(fp)
 d047c4c:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 d047c50:	e0bff817 	ldw	r2,-32(fp)
 d047c54:	10c00817 	ldw	r3,32(r2)
 d047c58:	e0bff817 	ldw	r2,-32(fp)
 d047c5c:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 d047c60:	e0bff817 	ldw	r2,-32(fp)
 d047c64:	10c0058b 	ldhu	r3,22(r2)
 d047c68:	00bfff84 	movi	r2,-2
 d047c6c:	1884703a 	and	r2,r3,r2
 d047c70:	1007883a 	mov	r3,r2
 d047c74:	e0bff817 	ldw	r2,-32(fp)
 d047c78:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 d047c7c:	e0bff817 	ldw	r2,-32(fp)
 d047c80:	1080058b 	ldhu	r2,22(r2)
 d047c84:	10808014 	ori	r2,r2,512
 d047c88:	1007883a 	mov	r3,r2
 d047c8c:	e0bff817 	ldw	r2,-32(fp)
 d047c90:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 d047c94:	e0bffd17 	ldw	r2,-12(fp)
 d047c98:	e0bfff15 	stw	r2,-4(fp)
 d047c9c:	e0bfff17 	ldw	r2,-4(fp)

#endif   /* HT_RWVFS */
}
 d047ca0:	e037883a 	mov	sp,fp
 d047ca4:	dfc00117 	ldw	ra,4(sp)
 d047ca8:	df000017 	ldw	fp,0(sp)
 d047cac:	dec00204 	addi	sp,sp,8
 d047cb0:	f800283a 	ret

0d047cb4 <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 d047cb4:	defff904 	addi	sp,sp,-28
 d047cb8:	dfc00615 	stw	ra,24(sp)
 d047cbc:	df000515 	stw	fp,20(sp)
 d047cc0:	df000504 	addi	fp,sp,20
 d047cc4:	e13ffc15 	stw	r4,-16(fp)
 d047cc8:	e17ffd15 	stw	r5,-12(fp)
 d047ccc:	e1bffe15 	stw	r6,-8(fp)
 d047cd0:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 d047cd4:	01000144 	movi	r4,5
 d047cd8:	d0299e40 	call	d0299e4 <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 d047cdc:	e13ffc17 	ldw	r4,-16(fp)
 d047ce0:	e17ffd17 	ldw	r5,-12(fp)
 d047ce4:	e1bffe17 	ldw	r6,-8(fp)
 d047ce8:	e1ffff17 	ldw	r7,-4(fp)
 d047cec:	d0478cc0 	call	d0478cc <vfwrite_locked>
 d047cf0:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 d047cf4:	01000144 	movi	r4,5
 d047cf8:	d029a980 	call	d029a98 <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 d047cfc:	e0bffb17 	ldw	r2,-20(fp)
}
 d047d00:	e037883a 	mov	sp,fp
 d047d04:	dfc00117 	ldw	ra,4(sp)
 d047d08:	df000017 	ldw	fp,0(sp)
 d047d0c:	dec00204 	addi	sp,sp,8
 d047d10:	f800283a 	ret

0d047d14 <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 d047d14:	defff704 	addi	sp,sp,-36
 d047d18:	dfc00815 	stw	ra,32(sp)
 d047d1c:	df000715 	stw	fp,28(sp)
 d047d20:	df000704 	addi	fp,sp,28
 d047d24:	e13ffb15 	stw	r4,-20(fp)
 d047d28:	e17ffc15 	stw	r5,-16(fp)
 d047d2c:	e1bffd15 	stw	r6,-12(fp)
   /* lock the VFS */
   vfs_lock();
 d047d30:	01000144 	movi	r4,5
 d047d34:	d0299e40 	call	d0299e4 <wait_app_sem>

   if (isvfile_locked(vfd))
 d047d38:	e13ffb17 	ldw	r4,-20(fp)
 d047d3c:	d0484940 	call	d048494 <isvfile_locked>
 d047d40:	1005003a 	cmpeq	r2,r2,zero
 d047d44:	1000481e 	bne	r2,zero,d047e68 <vfseek+0x154>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 d047d48:	e0bffb17 	ldw	r2,-20(fp)
 d047d4c:	10800117 	ldw	r2,4(r2)
 d047d50:	1004c03a 	cmpne	r2,r2,zero
 d047d54:	1000051e 	bne	r2,zero,d047d6c <vfseek+0x58>
      {
         vfs_unlock();
 d047d58:	01000144 	movi	r4,5
 d047d5c:	d029a980 	call	d029a98 <post_app_sem>
         return -1;
 d047d60:	00bfffc4 	movi	r2,-1
 d047d64:	e0bffe15 	stw	r2,-8(fp)
 d047d68:	00004306 	br	d047e78 <vfseek+0x164>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 d047d6c:	e0bffb17 	ldw	r2,-20(fp)
 d047d70:	10800117 	ldw	r2,4(r2)
 d047d74:	10800a17 	ldw	r2,40(r2)
 d047d78:	1005003a 	cmpeq	r2,r2,zero
 d047d7c:	1000101e 	bne	r2,zero,d047dc0 <vfseek+0xac>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 d047d80:	e0bffb17 	ldw	r2,-20(fp)
 d047d84:	10800117 	ldw	r2,4(r2)
 d047d88:	10800a17 	ldw	r2,40(r2)
 d047d8c:	e0bffa15 	stw	r2,-24(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 d047d90:	e0bffa17 	ldw	r2,-24(fp)
 d047d94:	10800517 	ldw	r2,20(r2)
 d047d98:	e13ffb17 	ldw	r4,-20(fp)
 d047d9c:	e17ffc17 	ldw	r5,-16(fp)
 d047da0:	e1bffd17 	ldw	r6,-12(fp)
 d047da4:	103ee83a 	callr	r2
 d047da8:	e0bff915 	stw	r2,-28(fp)
         vfs_unlock();
 d047dac:	01000144 	movi	r4,5
 d047db0:	d029a980 	call	d029a98 <post_app_sem>
         return rc;
 d047db4:	e0fff917 	ldw	r3,-28(fp)
 d047db8:	e0fffe15 	stw	r3,-8(fp)
 d047dbc:	00002e06 	br	d047e78 <vfseek+0x164>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 d047dc0:	e0bffd17 	ldw	r2,-12(fp)
 d047dc4:	e0bfff15 	stw	r2,-4(fp)
 d047dc8:	e0ffff17 	ldw	r3,-4(fp)
 d047dcc:	18800060 	cmpeqi	r2,r3,1
 d047dd0:	10000f1e 	bne	r2,zero,d047e10 <vfseek+0xfc>
 d047dd4:	e0ffff17 	ldw	r3,-4(fp)
 d047dd8:	188000a0 	cmpeqi	r2,r3,2
 d047ddc:	1000131e 	bne	r2,zero,d047e2c <vfseek+0x118>
 d047de0:	e0ffff17 	ldw	r3,-4(fp)
 d047de4:	1805003a 	cmpeq	r2,r3,zero
 d047de8:	1000011e 	bne	r2,zero,d047df0 <vfseek+0xdc>
 d047dec:	00001a06 	br	d047e58 <vfseek+0x144>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 d047df0:	e0bffb17 	ldw	r2,-20(fp)
 d047df4:	10800117 	ldw	r2,4(r2)
 d047df8:	10c00617 	ldw	r3,24(r2)
 d047dfc:	e0bffc17 	ldw	r2,-16(fp)
 d047e00:	1887883a 	add	r3,r3,r2
 d047e04:	e0bffb17 	ldw	r2,-20(fp)
 d047e08:	10c00215 	stw	r3,8(r2)
         break;
 d047e0c:	00001206 	br	d047e58 <vfseek+0x144>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 d047e10:	e0bffb17 	ldw	r2,-20(fp)
 d047e14:	10c00217 	ldw	r3,8(r2)
 d047e18:	e0bffc17 	ldw	r2,-16(fp)
 d047e1c:	1887883a 	add	r3,r3,r2
 d047e20:	e0bffb17 	ldw	r2,-20(fp)
 d047e24:	10c00215 	stw	r3,8(r2)
         break;
 d047e28:	00000b06 	br	d047e58 <vfseek+0x144>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 d047e2c:	e0bffb17 	ldw	r2,-20(fp)
 d047e30:	10800117 	ldw	r2,4(r2)
 d047e34:	10c00617 	ldw	r3,24(r2)
 d047e38:	e0bffb17 	ldw	r2,-20(fp)
 d047e3c:	10800117 	ldw	r2,4(r2)
 d047e40:	10800817 	ldw	r2,32(r2)
 d047e44:	1887883a 	add	r3,r3,r2
 d047e48:	e0bffc17 	ldw	r2,-16(fp)
 d047e4c:	1887883a 	add	r3,r3,r2
 d047e50:	e0bffb17 	ldw	r2,-20(fp)
 d047e54:	10c00215 	stw	r3,8(r2)
         break;
      }
      vfs_unlock();
 d047e58:	01000144 	movi	r4,5
 d047e5c:	d029a980 	call	d029a98 <post_app_sem>
      return(0);
 d047e60:	e03ffe15 	stw	zero,-8(fp)
 d047e64:	00000406 	br	d047e78 <vfseek+0x164>
   }

   vfs_unlock();
 d047e68:	01000144 	movi	r4,5
 d047e6c:	d029a980 	call	d029a98 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 d047e70:	00bfffc4 	movi	r2,-1
 d047e74:	e0bffe15 	stw	r2,-8(fp)
 d047e78:	e0bffe17 	ldw	r2,-8(fp)
#endif   /* HT_LOCALFS */
}
 d047e7c:	e037883a 	mov	sp,fp
 d047e80:	dfc00117 	ldw	ra,4(sp)
 d047e84:	df000017 	ldw	fp,0(sp)
 d047e88:	dec00204 	addi	sp,sp,8
 d047e8c:	f800283a 	ret

0d047e90 <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 d047e90:	defffa04 	addi	sp,sp,-24
 d047e94:	dfc00515 	stw	ra,20(sp)
 d047e98:	df000415 	stw	fp,16(sp)
 d047e9c:	df000404 	addi	fp,sp,16
 d047ea0:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 d047ea4:	01000144 	movi	r4,5
 d047ea8:	d0299e40 	call	d0299e4 <wait_app_sem>

   if (isvfile_locked(vfd))
 d047eac:	e13ffe17 	ldw	r4,-8(fp)
 d047eb0:	d0484940 	call	d048494 <isvfile_locked>
 d047eb4:	1005003a 	cmpeq	r2,r2,zero
 d047eb8:	1000381e 	bne	r2,zero,d047f9c <vftell+0x10c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 d047ebc:	e0bffe17 	ldw	r2,-8(fp)
 d047ec0:	10800117 	ldw	r2,4(r2)
 d047ec4:	1004c03a 	cmpne	r2,r2,zero
 d047ec8:	1000051e 	bne	r2,zero,d047ee0 <vftell+0x50>
      {
         vfs_unlock();
 d047ecc:	01000144 	movi	r4,5
 d047ed0:	d029a980 	call	d029a98 <post_app_sem>
         return -1;
 d047ed4:	00bfffc4 	movi	r2,-1
 d047ed8:	e0bfff15 	stw	r2,-4(fp)
 d047edc:	00003306 	br	d047fac <vftell+0x11c>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 d047ee0:	e0bffe17 	ldw	r2,-8(fp)
 d047ee4:	10800117 	ldw	r2,4(r2)
 d047ee8:	10800a17 	ldw	r2,40(r2)
 d047eec:	1005003a 	cmpeq	r2,r2,zero
 d047ef0:	10000e1e 	bne	r2,zero,d047f2c <vftell+0x9c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 d047ef4:	e0bffe17 	ldw	r2,-8(fp)
 d047ef8:	10800117 	ldw	r2,4(r2)
 d047efc:	10800a17 	ldw	r2,40(r2)
 d047f00:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 d047f04:	e0bffd17 	ldw	r2,-12(fp)
 d047f08:	10800617 	ldw	r2,24(r2)
 d047f0c:	e13ffe17 	ldw	r4,-8(fp)
 d047f10:	103ee83a 	callr	r2
 d047f14:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 d047f18:	01000144 	movi	r4,5
 d047f1c:	d029a980 	call	d029a98 <post_app_sem>
         return rc;
 d047f20:	e0bffc17 	ldw	r2,-16(fp)
 d047f24:	e0bfff15 	stw	r2,-4(fp)
 d047f28:	00002006 	br	d047fac <vftell+0x11c>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 d047f2c:	e0bffe17 	ldw	r2,-8(fp)
 d047f30:	11000217 	ldw	r4,8(r2)
 d047f34:	e0bffe17 	ldw	r2,-8(fp)
 d047f38:	10800117 	ldw	r2,4(r2)
 d047f3c:	10c00617 	ldw	r3,24(r2)
 d047f40:	e0bffe17 	ldw	r2,-8(fp)
 d047f44:	10800117 	ldw	r2,4(r2)
 d047f48:	10800817 	ldw	r2,32(r2)
 d047f4c:	1885883a 	add	r2,r3,r2
 d047f50:	2080071e 	bne	r4,r2,d047f70 <vftell+0xe0>
      {
         vfs_unlock();
 d047f54:	01000144 	movi	r4,5
 d047f58:	d029a980 	call	d029a98 <post_app_sem>

         return vfd->file->comp_size;
 d047f5c:	e0bffe17 	ldw	r2,-8(fp)
 d047f60:	10800117 	ldw	r2,4(r2)
 d047f64:	10800817 	ldw	r2,32(r2)
 d047f68:	e0bfff15 	stw	r2,-4(fp)
 d047f6c:	00000f06 	br	d047fac <vftell+0x11c>
      }
      else
      {
         vfs_unlock();
 d047f70:	01000144 	movi	r4,5
 d047f74:	d029a980 	call	d029a98 <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 d047f78:	e0bffe17 	ldw	r2,-8(fp)
 d047f7c:	10800217 	ldw	r2,8(r2)
 d047f80:	1007883a 	mov	r3,r2
 d047f84:	e0bffe17 	ldw	r2,-8(fp)
 d047f88:	10800117 	ldw	r2,4(r2)
 d047f8c:	10800617 	ldw	r2,24(r2)
 d047f90:	1887c83a 	sub	r3,r3,r2
 d047f94:	e0ffff15 	stw	r3,-4(fp)
 d047f98:	00000406 	br	d047fac <vftell+0x11c>
      }
   }

   vfs_unlock();
 d047f9c:	01000144 	movi	r4,5
 d047fa0:	d029a980 	call	d029a98 <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 d047fa4:	00800244 	movi	r2,9
 d047fa8:	e0bfff15 	stw	r2,-4(fp)
 d047fac:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 d047fb0:	e037883a 	mov	sp,fp
 d047fb4:	dfc00117 	ldw	ra,4(sp)
 d047fb8:	df000017 	ldw	fp,0(sp)
 d047fbc:	dec00204 	addi	sp,sp,8
 d047fc0:	f800283a 	ret

0d047fc4 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 d047fc4:	defffa04 	addi	sp,sp,-24
 d047fc8:	dfc00515 	stw	ra,20(sp)
 d047fcc:	df000415 	stw	fp,16(sp)
 d047fd0:	df000404 	addi	fp,sp,16
 d047fd4:	e13ffe15 	stw	r4,-8(fp)
   int   chr;

   if (isvfile_locked(vfd))
 d047fd8:	e13ffe17 	ldw	r4,-8(fp)
 d047fdc:	d0484940 	call	d048494 <isvfile_locked>
 d047fe0:	1005003a 	cmpeq	r2,r2,zero
 d047fe4:	1000361e 	bne	r2,zero,d0480c0 <vgetc_locked+0xfc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 d047fe8:	e0bffe17 	ldw	r2,-8(fp)
 d047fec:	10800117 	ldw	r2,4(r2)
 d047ff0:	1004c03a 	cmpne	r2,r2,zero
 d047ff4:	1000031e 	bne	r2,zero,d048004 <vgetc_locked+0x40>
      {
         return EOF;
 d047ff8:	00bfffc4 	movi	r2,-1
 d047ffc:	e0bfff15 	stw	r2,-4(fp)
 d048000:	00003206 	br	d0480cc <vgetc_locked+0x108>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 d048004:	e0bffe17 	ldw	r2,-8(fp)
 d048008:	10800117 	ldw	r2,4(r2)
 d04800c:	10800a17 	ldw	r2,40(r2)
 d048010:	1005003a 	cmpeq	r2,r2,zero
 d048014:	10000a1e 	bne	r2,zero,d048040 <vgetc_locked+0x7c>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 d048018:	e0bffe17 	ldw	r2,-8(fp)
 d04801c:	10800117 	ldw	r2,4(r2)
 d048020:	10800a17 	ldw	r2,40(r2)
 d048024:	e0bffc15 	stw	r2,-16(fp)
         return (vfp->r_fgetc(vfd));
 d048028:	e0bffc17 	ldw	r2,-16(fp)
 d04802c:	10800717 	ldw	r2,28(r2)
 d048030:	e13ffe17 	ldw	r4,-8(fp)
 d048034:	103ee83a 	callr	r2
 d048038:	e0bfff15 	stw	r2,-4(fp)
 d04803c:	00002306 	br	d0480cc <vgetc_locked+0x108>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 d048040:	e0bffe17 	ldw	r2,-8(fp)
 d048044:	10800117 	ldw	r2,4(r2)
 d048048:	10800617 	ldw	r2,24(r2)
 d04804c:	1004c03a 	cmpne	r2,r2,zero
 d048050:	1000031e 	bne	r2,zero,d048060 <vgetc_locked+0x9c>
         return EOF;
 d048054:	00bfffc4 	movi	r2,-1
 d048058:	e0bfff15 	stw	r2,-4(fp)
 d04805c:	00001b06 	br	d0480cc <vgetc_locked+0x108>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 d048060:	e0bffe17 	ldw	r2,-8(fp)
 d048064:	11000217 	ldw	r4,8(r2)
 d048068:	e0bffe17 	ldw	r2,-8(fp)
 d04806c:	10800117 	ldw	r2,4(r2)
 d048070:	10c00617 	ldw	r3,24(r2)
 d048074:	e0bffe17 	ldw	r2,-8(fp)
 d048078:	10800117 	ldw	r2,4(r2)
 d04807c:	10800817 	ldw	r2,32(r2)
 d048080:	1885883a 	add	r2,r3,r2
 d048084:	20800336 	bltu	r4,r2,d048094 <vgetc_locked+0xd0>
            chr = EOF;
 d048088:	00bfffc4 	movi	r2,-1
 d04808c:	e0bffd15 	stw	r2,-12(fp)
 d048090:	00000806 	br	d0480b4 <vgetc_locked+0xf0>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 d048094:	e0bffe17 	ldw	r2,-8(fp)
 d048098:	10c00217 	ldw	r3,8(r2)
 d04809c:	18800003 	ldbu	r2,0(r3)
 d0480a0:	10803fcc 	andi	r2,r2,255
 d0480a4:	e0bffd15 	stw	r2,-12(fp)
 d0480a8:	18c00044 	addi	r3,r3,1
 d0480ac:	e0bffe17 	ldw	r2,-8(fp)
 d0480b0:	10c00215 	stw	r3,8(r2)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 d0480b4:	e0bffd17 	ldw	r2,-12(fp)
 d0480b8:	e0bfff15 	stw	r2,-4(fp)
 d0480bc:	00000306 	br	d0480cc <vgetc_locked+0x108>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 d0480c0:	d0293e80 	call	d0293e8 <dtrap>
   return EOF;
 d0480c4:	00bfffc4 	movi	r2,-1
 d0480c8:	e0bfff15 	stw	r2,-4(fp)
 d0480cc:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 d0480d0:	e037883a 	mov	sp,fp
 d0480d4:	dfc00117 	ldw	ra,4(sp)
 d0480d8:	df000017 	ldw	fp,0(sp)
 d0480dc:	dec00204 	addi	sp,sp,8
 d0480e0:	f800283a 	ret

0d0480e4 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 d0480e4:	defffc04 	addi	sp,sp,-16
 d0480e8:	dfc00315 	stw	ra,12(sp)
 d0480ec:	df000215 	stw	fp,8(sp)
 d0480f0:	df000204 	addi	fp,sp,8
 d0480f4:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 d0480f8:	01000144 	movi	r4,5
 d0480fc:	d0299e40 	call	d0299e4 <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 d048100:	e13fff17 	ldw	r4,-4(fp)
 d048104:	d047fc40 	call	d047fc4 <vgetc_locked>
 d048108:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 d04810c:	01000144 	movi	r4,5
 d048110:	d029a980 	call	d029a98 <post_app_sem>
   return rc;
 d048114:	e0bffe17 	ldw	r2,-8(fp)
}
 d048118:	e037883a 	mov	sp,fp
 d04811c:	dfc00117 	ldw	ra,4(sp)
 d048120:	df000017 	ldw	fp,0(sp)
 d048124:	dec00204 	addi	sp,sp,8
 d048128:	f800283a 	ret

0d04812c <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 d04812c:	defffa04 	addi	sp,sp,-24
 d048130:	dfc00515 	stw	ra,20(sp)
 d048134:	df000415 	stw	fp,16(sp)
 d048138:	df000404 	addi	fp,sp,16
 d04813c:	e13ffe15 	stw	r4,-8(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 d048140:	e0bffe17 	ldw	r2,-8(fp)
 d048144:	10800003 	ldbu	r2,0(r2)
 d048148:	10803fcc 	andi	r2,r2,255
 d04814c:	1080201c 	xori	r2,r2,128
 d048150:	10bfe004 	addi	r2,r2,-128
 d048154:	10800be0 	cmpeqi	r2,r2,47
 d048158:	1000071e 	bne	r2,zero,d048178 <vfslookup_locked+0x4c>
 d04815c:	e0bffe17 	ldw	r2,-8(fp)
 d048160:	10800003 	ldbu	r2,0(r2)
 d048164:	10803fcc 	andi	r2,r2,255
 d048168:	1080201c 	xori	r2,r2,128
 d04816c:	10bfe004 	addi	r2,r2,-128
 d048170:	10801718 	cmpnei	r2,r2,92
 d048174:	10001a1e 	bne	r2,zero,d0481e0 <vfslookup_locked+0xb4>
   {
      cp = strippath(name);
 d048178:	e13ffe17 	ldw	r4,-8(fp)
 d04817c:	d0482ac0 	call	d0482ac <strippath>
 d048180:	e0bffc15 	stw	r2,-16(fp)

      if (!cp) /* strippath coundn't match our path */
 d048184:	e0bffc17 	ldw	r2,-16(fp)
 d048188:	1004c03a 	cmpne	r2,r2,zero
 d04818c:	1000121e 	bne	r2,zero,d0481d8 <vfslookup_locked+0xac>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 d048190:	e0bffe17 	ldw	r2,-8(fp)
 d048194:	10800003 	ldbu	r2,0(r2)
 d048198:	10803fcc 	andi	r2,r2,255
 d04819c:	1080201c 	xori	r2,r2,128
 d0481a0:	10bfe004 	addi	r2,r2,-128
 d0481a4:	10800be0 	cmpeqi	r2,r2,47
 d0481a8:	1000071e 	bne	r2,zero,d0481c8 <vfslookup_locked+0x9c>
 d0481ac:	e0bffe17 	ldw	r2,-8(fp)
 d0481b0:	10800003 	ldbu	r2,0(r2)
 d0481b4:	10803fcc 	andi	r2,r2,255
 d0481b8:	1080201c 	xori	r2,r2,128
 d0481bc:	10bfe004 	addi	r2,r2,-128
 d0481c0:	10801718 	cmpnei	r2,r2,92
 d0481c4:	1000061e 	bne	r2,zero,d0481e0 <vfslookup_locked+0xb4>
            name++;
 d0481c8:	e0bffe17 	ldw	r2,-8(fp)
 d0481cc:	10800044 	addi	r2,r2,1
 d0481d0:	e0bffe15 	stw	r2,-8(fp)
 d0481d4:	00000206 	br	d0481e0 <vfslookup_locked+0xb4>
      }
      else
         name = cp ;
 d0481d8:	e0bffc17 	ldw	r2,-16(fp)
 d0481dc:	e0bffe15 	stw	r2,-8(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 d0481e0:	e13ffe17 	ldw	r4,-8(fp)
 d0481e4:	01400fc4 	movi	r5,63
 d0481e8:	d002e080 	call	d002e08 <strchr>
 d0481ec:	1005003a 	cmpeq	r2,r2,zero
 d0481f0:	1000031e 	bne	r2,zero,d048200 <vfslookup_locked+0xd4>
   {
      dtrap(); /* is this still allowed? */
 d0481f4:	d0293e80 	call	d0293e8 <dtrap>
      return NULL;
 d0481f8:	e03fff15 	stw	zero,-4(fp)
 d0481fc:	00001306 	br	d04824c <vfslookup_locked+0x120>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 d048200:	d0a0d617 	ldw	r2,-31912(gp)
 d048204:	e0bffd15 	stw	r2,-12(fp)
 d048208:	00000c06 	br	d04823c <vfslookup_locked+0x110>
   {
      if (strcmp(name, vp->name) == 0)
 d04820c:	e0bffd17 	ldw	r2,-12(fp)
 d048210:	11400104 	addi	r5,r2,4
 d048214:	e13ffe17 	ldw	r4,-8(fp)
 d048218:	d00a45c0 	call	d00a45c <strcmp>
 d04821c:	1004c03a 	cmpne	r2,r2,zero
 d048220:	1000031e 	bne	r2,zero,d048230 <vfslookup_locked+0x104>
         return vp;
 d048224:	e0bffd17 	ldw	r2,-12(fp)
 d048228:	e0bfff15 	stw	r2,-4(fp)
 d04822c:	00000706 	br	d04824c <vfslookup_locked+0x120>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 d048230:	e0bffd17 	ldw	r2,-12(fp)
 d048234:	10800017 	ldw	r2,0(r2)
 d048238:	e0bffd15 	stw	r2,-12(fp)
 d04823c:	e0bffd17 	ldw	r2,-12(fp)
 d048240:	1004c03a 	cmpne	r2,r2,zero
 d048244:	103ff11e 	bne	r2,zero,d04820c <vfslookup_locked+0xe0>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 d048248:	e03fff15 	stw	zero,-4(fp)
 d04824c:	e0bfff17 	ldw	r2,-4(fp)
}
 d048250:	e037883a 	mov	sp,fp
 d048254:	dfc00117 	ldw	ra,4(sp)
 d048258:	df000017 	ldw	fp,0(sp)
 d04825c:	dec00204 	addi	sp,sp,8
 d048260:	f800283a 	ret

0d048264 <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 d048264:	defffc04 	addi	sp,sp,-16
 d048268:	dfc00315 	stw	ra,12(sp)
 d04826c:	df000215 	stw	fp,8(sp)
 d048270:	df000204 	addi	fp,sp,8
 d048274:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 d048278:	01000144 	movi	r4,5
 d04827c:	d0299e40 	call	d0299e4 <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 d048280:	e13fff17 	ldw	r4,-4(fp)
 d048284:	d04812c0 	call	d04812c <vfslookup_locked>
 d048288:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 d04828c:	01000144 	movi	r4,5
 d048290:	d029a980 	call	d029a98 <post_app_sem>
   return vp;
 d048294:	e0bffe17 	ldw	r2,-8(fp)
}
 d048298:	e037883a 	mov	sp,fp
 d04829c:	dfc00117 	ldw	ra,4(sp)
 d0482a0:	df000017 	ldw	fp,0(sp)
 d0482a4:	dec00204 	addi	sp,sp,8
 d0482a8:	f800283a 	ret

0d0482ac <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 d0482ac:	defff804 	addi	sp,sp,-32
 d0482b0:	dfc00715 	stw	ra,28(sp)
 d0482b4:	df000615 	stw	fp,24(sp)
 d0482b8:	df000604 	addi	fp,sp,24
 d0482bc:	e13ffe15 	stw	r4,-8(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 d0482c0:	e13ffe17 	ldw	r4,-8(fp)
 d0482c4:	d0247ec0 	call	d0247ec <uslash>
 d0482c8:	e0bffb15 	stw	r2,-20(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 d0482cc:	d0a05517 	ldw	r2,-32428(gp)
 d0482d0:	e0bffd15 	stw	r2,-12(fp)
   while (*path && *ntmp)
 d0482d4:	00003e06 	br	d0483d0 <strippath+0x124>
   {
      while (*path == '/') path++;   /* strip leading slash */
 d0482d8:	e0bffd17 	ldw	r2,-12(fp)
 d0482dc:	10800044 	addi	r2,r2,1
 d0482e0:	e0bffd15 	stw	r2,-12(fp)
 d0482e4:	e0bffd17 	ldw	r2,-12(fp)
 d0482e8:	10800003 	ldbu	r2,0(r2)
 d0482ec:	10803fcc 	andi	r2,r2,255
 d0482f0:	1080201c 	xori	r2,r2,128
 d0482f4:	10bfe004 	addi	r2,r2,-128
 d0482f8:	10800be0 	cmpeqi	r2,r2,47
 d0482fc:	103ff61e 	bne	r2,zero,d0482d8 <strippath+0x2c>
         if (*path == 0)
 d048300:	e0bffd17 	ldw	r2,-12(fp)
 d048304:	10800003 	ldbu	r2,0(r2)
 d048308:	10803fcc 	andi	r2,r2,255
 d04830c:	1080201c 	xori	r2,r2,128
 d048310:	10bfe004 	addi	r2,r2,-128
 d048314:	1005003a 	cmpeq	r2,r2,zero
 d048318:	10003b1e 	bne	r2,zero,d048408 <strippath+0x15c>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 d04831c:	e13ffd17 	ldw	r4,-12(fp)
 d048320:	01400bc4 	movi	r5,47
 d048324:	d002e080 	call	d002e08 <strchr>
 d048328:	e0bffc15 	stw	r2,-16(fp)
      if (ptmp)
 d04832c:	e0bffc17 	ldw	r2,-16(fp)
 d048330:	1005003a 	cmpeq	r2,r2,zero
 d048334:	1000051e 	bne	r2,zero,d04834c <strippath+0xa0>
         dirlen = ptmp - path;
 d048338:	e0bffc17 	ldw	r2,-16(fp)
 d04833c:	e0fffd17 	ldw	r3,-12(fp)
 d048340:	10c5c83a 	sub	r2,r2,r3
 d048344:	e0bffa15 	stw	r2,-24(fp)
 d048348:	00000706 	br	d048368 <strippath+0xbc>
      else
         dirlen = strlen(path);
 d04834c:	e13ffd17 	ldw	r4,-12(fp)
 d048350:	d00355c0 	call	d00355c <strlen>
 d048354:	e0bffa15 	stw	r2,-24(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 d048358:	00000306 	br	d048368 <strippath+0xbc>
 d04835c:	e0bffb17 	ldw	r2,-20(fp)
 d048360:	10800044 	addi	r2,r2,1
 d048364:	e0bffb15 	stw	r2,-20(fp)
 d048368:	e0bffb17 	ldw	r2,-20(fp)
 d04836c:	10800003 	ldbu	r2,0(r2)
 d048370:	10803fcc 	andi	r2,r2,255
 d048374:	1080201c 	xori	r2,r2,128
 d048378:	10bfe004 	addi	r2,r2,-128
 d04837c:	10800be0 	cmpeqi	r2,r2,47
 d048380:	103ff61e 	bne	r2,zero,d04835c <strippath+0xb0>
         if (strncmp(ntmp, path, dirlen) == 0)
 d048384:	e1bffa17 	ldw	r6,-24(fp)
 d048388:	e13ffb17 	ldw	r4,-20(fp)
 d04838c:	e17ffd17 	ldw	r5,-12(fp)
 d048390:	d049fd40 	call	d049fd4 <strncmp>
 d048394:	1004c03a 	cmpne	r2,r2,zero
 d048398:	10000b1e 	bne	r2,zero,d0483c8 <strippath+0x11c>
      {
         path += dirlen;
 d04839c:	e0bffa17 	ldw	r2,-24(fp)
 d0483a0:	1007883a 	mov	r3,r2
 d0483a4:	e0bffd17 	ldw	r2,-12(fp)
 d0483a8:	10c5883a 	add	r2,r2,r3
 d0483ac:	e0bffd15 	stw	r2,-12(fp)
         ntmp += dirlen;
 d0483b0:	e0bffa17 	ldw	r2,-24(fp)
 d0483b4:	1007883a 	mov	r3,r2
 d0483b8:	e0bffb17 	ldw	r2,-20(fp)
 d0483bc:	10c5883a 	add	r2,r2,r3
 d0483c0:	e0bffb15 	stw	r2,-20(fp)
 d0483c4:	00000206 	br	d0483d0 <strippath+0x124>
      }
      else
         return NULL;   /* didn't match */
 d0483c8:	e03fff15 	stw	zero,-4(fp)
 d0483cc:	00002b06 	br	d04847c <strippath+0x1d0>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 d0483d0:	e0bffd17 	ldw	r2,-12(fp)
 d0483d4:	10800003 	ldbu	r2,0(r2)
 d0483d8:	10803fcc 	andi	r2,r2,255
 d0483dc:	1080201c 	xori	r2,r2,128
 d0483e0:	10bfe004 	addi	r2,r2,-128
 d0483e4:	1005003a 	cmpeq	r2,r2,zero
 d0483e8:	1000071e 	bne	r2,zero,d048408 <strippath+0x15c>
 d0483ec:	e0bffb17 	ldw	r2,-20(fp)
 d0483f0:	10800003 	ldbu	r2,0(r2)
 d0483f4:	10803fcc 	andi	r2,r2,255
 d0483f8:	1080201c 	xori	r2,r2,128
 d0483fc:	10bfe004 	addi	r2,r2,-128
 d048400:	1004c03a 	cmpne	r2,r2,zero
 d048404:	103fb71e 	bne	r2,zero,d0482e4 <strippath+0x38>
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 d048408:	e0bffd17 	ldw	r2,-12(fp)
 d04840c:	10800003 	ldbu	r2,0(r2)
 d048410:	10803fcc 	andi	r2,r2,255
 d048414:	1080201c 	xori	r2,r2,128
 d048418:	10bfe004 	addi	r2,r2,-128
 d04841c:	1004c03a 	cmpne	r2,r2,zero
 d048420:	1000151e 	bne	r2,zero,d048478 <strippath+0x1cc>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 d048424:	00000306 	br	d048434 <strippath+0x188>
         ntmp++;
 d048428:	e0bffb17 	ldw	r2,-20(fp)
 d04842c:	10800044 	addi	r2,r2,1
 d048430:	e0bffb15 	stw	r2,-20(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 d048434:	e0bffb17 	ldw	r2,-20(fp)
 d048438:	10800003 	ldbu	r2,0(r2)
 d04843c:	10803fcc 	andi	r2,r2,255
 d048440:	1080201c 	xori	r2,r2,128
 d048444:	10bfe004 	addi	r2,r2,-128
 d048448:	10801720 	cmpeqi	r2,r2,92
 d04844c:	103ff61e 	bne	r2,zero,d048428 <strippath+0x17c>
 d048450:	e0bffb17 	ldw	r2,-20(fp)
 d048454:	10800003 	ldbu	r2,0(r2)
 d048458:	10803fcc 	andi	r2,r2,255
 d04845c:	1080201c 	xori	r2,r2,128
 d048460:	10bfe004 	addi	r2,r2,-128
 d048464:	10800be0 	cmpeqi	r2,r2,47
 d048468:	103fef1e 	bne	r2,zero,d048428 <strippath+0x17c>
         ntmp++;
      return ntmp;
 d04846c:	e0bffb17 	ldw	r2,-20(fp)
 d048470:	e0bfff15 	stw	r2,-4(fp)
 d048474:	00000106 	br	d04847c <strippath+0x1d0>
   }
   else
      return NULL;
 d048478:	e03fff15 	stw	zero,-4(fp)
 d04847c:	e0bfff17 	ldw	r2,-4(fp)
}
 d048480:	e037883a 	mov	sp,fp
 d048484:	dfc00117 	ldw	ra,4(sp)
 d048488:	df000017 	ldw	fp,0(sp)
 d04848c:	dec00204 	addi	sp,sp,8
 d048490:	f800283a 	ret

0d048494 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 d048494:	defffc04 	addi	sp,sp,-16
 d048498:	df000315 	stw	fp,12(sp)
 d04849c:	df000304 	addi	fp,sp,12
 d0484a0:	e13ffe15 	stw	r4,-8(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 d0484a4:	d0a0d517 	ldw	r2,-31916(gp)
 d0484a8:	e0bffd15 	stw	r2,-12(fp)
 d0484ac:	00000906 	br	d0484d4 <isvfile_locked+0x40>
      if (vtmp == vfp)
 d0484b0:	e0fffd17 	ldw	r3,-12(fp)
 d0484b4:	e0bffe17 	ldw	r2,-8(fp)
 d0484b8:	1880031e 	bne	r3,r2,d0484c8 <isvfile_locked+0x34>
      return TRUE;
 d0484bc:	00800044 	movi	r2,1
 d0484c0:	e0bfff15 	stw	r2,-4(fp)
 d0484c4:	00000706 	br	d0484e4 <isvfile_locked+0x50>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 d0484c8:	e0bffd17 	ldw	r2,-12(fp)
 d0484cc:	10800017 	ldw	r2,0(r2)
 d0484d0:	e0bffd15 	stw	r2,-12(fp)
 d0484d4:	e0bffd17 	ldw	r2,-12(fp)
 d0484d8:	1004c03a 	cmpne	r2,r2,zero
 d0484dc:	103ff41e 	bne	r2,zero,d0484b0 <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 d0484e0:	e03fff15 	stw	zero,-4(fp)
 d0484e4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0484e8:	e037883a 	mov	sp,fp
 d0484ec:	df000017 	ldw	fp,0(sp)
 d0484f0:	dec00104 	addi	sp,sp,4
 d0484f4:	f800283a 	ret

0d0484f8 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 d0484f8:	defffc04 	addi	sp,sp,-16
 d0484fc:	dfc00315 	stw	ra,12(sp)
 d048500:	df000215 	stw	fp,8(sp)
 d048504:	df000204 	addi	fp,sp,8
 d048508:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 d04850c:	01000144 	movi	r4,5
 d048510:	d0299e40 	call	d0299e4 <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 d048514:	e13fff17 	ldw	r4,-4(fp)
 d048518:	d0484940 	call	d048494 <isvfile_locked>
 d04851c:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 d048520:	01000144 	movi	r4,5
 d048524:	d029a980 	call	d029a98 <post_app_sem>
   return rc;
 d048528:	e0bffe17 	ldw	r2,-8(fp)
}
 d04852c:	e037883a 	mov	sp,fp
 d048530:	dfc00117 	ldw	ra,4(sp)
 d048534:	df000017 	ldw	fp,0(sp)
 d048538:	dec00204 	addi	sp,sp,8
 d04853c:	f800283a 	ret

0d048540 <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 d048540:	defffc04 	addi	sp,sp,-16
 d048544:	dfc00315 	stw	ra,12(sp)
 d048548:	df000215 	stw	fp,8(sp)
 d04854c:	df000204 	addi	fp,sp,8
 d048550:	e13ffe15 	stw	r4,-8(fp)
   /* lock the VFS */
   vfs_lock();
 d048554:	01000144 	movi	r4,5
 d048558:	d0299e40 	call	d0299e4 <wait_app_sem>

   if (isvfile_locked(vfd))
 d04855c:	e13ffe17 	ldw	r4,-8(fp)
 d048560:	d0484940 	call	d048494 <isvfile_locked>
 d048564:	1005003a 	cmpeq	r2,r2,zero
 d048568:	1000061e 	bne	r2,zero,d048584 <vferror+0x44>
   {
      vfs_unlock();
 d04856c:	01000144 	movi	r4,5
 d048570:	d029a980 	call	d029a98 <post_app_sem>

      return vfd->error;
 d048574:	e0bffe17 	ldw	r2,-8(fp)
 d048578:	10800417 	ldw	r2,16(r2)
 d04857c:	e0bfff15 	stw	r2,-4(fp)
 d048580:	00000406 	br	d048594 <vferror+0x54>
   }

   vfs_unlock();
 d048584:	01000144 	movi	r4,5
 d048588:	d029a980 	call	d029a98 <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 d04858c:	00bfffc4 	movi	r2,-1
 d048590:	e0bfff15 	stw	r2,-4(fp)
 d048594:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* HT_LOCALFS */
}
 d048598:	e037883a 	mov	sp,fp
 d04859c:	dfc00117 	ldw	ra,4(sp)
 d0485a0:	df000017 	ldw	fp,0(sp)
 d0485a4:	dec00204 	addi	sp,sp,8
 d0485a8:	f800283a 	ret

0d0485ac <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 d0485ac:	defffd04 	addi	sp,sp,-12
 d0485b0:	dfc00215 	stw	ra,8(sp)
 d0485b4:	df000115 	stw	fp,4(sp)
 d0485b8:	df000104 	addi	fp,sp,4
 d0485bc:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 d0485c0:	01000144 	movi	r4,5
 d0485c4:	d0299e40 	call	d0299e4 <wait_app_sem>

   if (isvfile_locked(vfd))
 d0485c8:	e13fff17 	ldw	r4,-4(fp)
 d0485cc:	d0484940 	call	d048494 <isvfile_locked>
 d0485d0:	1005003a 	cmpeq	r2,r2,zero
 d0485d4:	1000051e 	bne	r2,zero,d0485ec <vclearerr+0x40>
   {
      vfs_unlock();
 d0485d8:	01000144 	movi	r4,5
 d0485dc:	d029a980 	call	d029a98 <post_app_sem>

      vfd->error = 0;
 d0485e0:	e0bfff17 	ldw	r2,-4(fp)
 d0485e4:	10000415 	stw	zero,16(r2)
      return;
 d0485e8:	00000206 	br	d0485f4 <vclearerr+0x48>
   }

   vfs_unlock();
 d0485ec:	01000144 	movi	r4,5
 d0485f0:	d029a980 	call	d029a98 <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 d0485f4:	e037883a 	mov	sp,fp
 d0485f8:	dfc00117 	ldw	ra,4(sp)
 d0485fc:	df000017 	ldw	fp,0(sp)
 d048600:	dec00204 	addi	sp,sp,8
 d048604:	f800283a 	ret

0d048608 <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 d048608:	defffe04 	addi	sp,sp,-8
 d04860c:	df000115 	stw	fp,4(sp)
 d048610:	df000104 	addi	fp,sp,4
int e = 0;
 d048614:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 d048618:	e0bfff17 	ldw	r2,-4(fp)
}
 d04861c:	e037883a 	mov	sp,fp
 d048620:	df000017 	ldw	fp,0(sp)
 d048624:	dec00104 	addi	sp,sp,4
 d048628:	f800283a 	ret

0d04862c <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 d04862c:	defffb04 	addi	sp,sp,-20
 d048630:	df000415 	stw	fp,16(sp)
 d048634:	df000404 	addi	fp,sp,16
 d048638:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 d04863c:	008000c4 	movi	r2,3
 d048640:	e0bffc15 	stw	r2,-16(fp)
  }
  

  big_loops = us / (INT_MAX/
 d048644:	e0fffc17 	ldw	r3,-16(fp)
 d048648:	008003f4 	movhi	r2,15
 d04864c:	10909004 	addi	r2,r2,16960
 d048650:	1887383a 	mul	r3,r3,r2
 d048654:	0081dcf4 	movhi	r2,1907
 d048658:	10965004 	addi	r2,r2,22848
 d04865c:	10c7203a 	divu	r3,r2,r3
 d048660:	00a00034 	movhi	r2,32768
 d048664:	10bfffc4 	addi	r2,r2,-1
 d048668:	10c7203a 	divu	r3,r2,r3
 d04866c:	e0bfff17 	ldw	r2,-4(fp)
 d048670:	10c5203a 	divu	r2,r2,r3
 d048674:	e0bffd15 	stw	r2,-12(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 d048678:	e0bffd17 	ldw	r2,-12(fp)
 d04867c:	1005003a 	cmpeq	r2,r2,zero
 d048680:	1000251e 	bne	r2,zero,d048718 <alt_busy_sleep+0xec>
  {
    for(i=0;i<big_loops;i++)
 d048684:	e03ffe15 	stw	zero,-8(fp)
 d048688:	00001406 	br	d0486dc <alt_busy_sleep+0xb0>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 d04868c:	00a00034 	movhi	r2,32768
 d048690:	10bfffc4 	addi	r2,r2,-1
 d048694:	10bfffc4 	addi	r2,r2,-1
 d048698:	103ffe1e 	bne	r2,zero,d048694 <alt_busy_sleep+0x68>
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 d04869c:	e0fffc17 	ldw	r3,-16(fp)
 d0486a0:	008003f4 	movhi	r2,15
 d0486a4:	10909004 	addi	r2,r2,16960
 d0486a8:	1887383a 	mul	r3,r3,r2
 d0486ac:	0081dcf4 	movhi	r2,1907
 d0486b0:	10965004 	addi	r2,r2,22848
 d0486b4:	10c7203a 	divu	r3,r2,r3
 d0486b8:	00a00034 	movhi	r2,32768
 d0486bc:	10bfffc4 	addi	r2,r2,-1
 d0486c0:	10c7203a 	divu	r3,r2,r3
 d0486c4:	e0bfff17 	ldw	r2,-4(fp)
 d0486c8:	10c5c83a 	sub	r2,r2,r3
 d0486cc:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 d0486d0:	e0bffe17 	ldw	r2,-8(fp)
 d0486d4:	10800044 	addi	r2,r2,1
 d0486d8:	e0bffe15 	stw	r2,-8(fp)
 d0486dc:	e0fffe17 	ldw	r3,-8(fp)
 d0486e0:	e0bffd17 	ldw	r2,-12(fp)
 d0486e4:	18bfe916 	blt	r3,r2,d04868c <alt_busy_sleep+0x60>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 d0486e8:	e0fffc17 	ldw	r3,-16(fp)
 d0486ec:	008003f4 	movhi	r2,15
 d0486f0:	10909004 	addi	r2,r2,16960
 d0486f4:	1887383a 	mul	r3,r3,r2
 d0486f8:	0081dcf4 	movhi	r2,1907
 d0486fc:	10965004 	addi	r2,r2,22848
 d048700:	10c7203a 	divu	r3,r2,r3
 d048704:	e0bfff17 	ldw	r2,-4(fp)
 d048708:	1885383a 	mul	r2,r3,r2
 d04870c:	10bfffc4 	addi	r2,r2,-1
 d048710:	103ffe1e 	bne	r2,zero,d04870c <alt_busy_sleep+0xe0>
 d048714:	00000b06 	br	d048744 <alt_busy_sleep+0x118>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 d048718:	e0fffc17 	ldw	r3,-16(fp)
 d04871c:	008003f4 	movhi	r2,15
 d048720:	10909004 	addi	r2,r2,16960
 d048724:	1887383a 	mul	r3,r3,r2
 d048728:	0081dcf4 	movhi	r2,1907
 d04872c:	10965004 	addi	r2,r2,22848
 d048730:	10c7203a 	divu	r3,r2,r3
 d048734:	e0bfff17 	ldw	r2,-4(fp)
 d048738:	1885383a 	mul	r2,r3,r2
 d04873c:	10bfffc4 	addi	r2,r2,-1
 d048740:	00bffe16 	blt	zero,r2,d04873c <alt_busy_sleep+0x110>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 d048744:	0005883a 	mov	r2,zero
}
 d048748:	e037883a 	mov	sp,fp
 d04874c:	df000017 	ldw	fp,0(sp)
 d048750:	dec00104 	addi	sp,sp,4
 d048754:	f800283a 	ret

0d048758 <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 d048758:	defff404 	addi	sp,sp,-48
 d04875c:	dfc00915 	stw	ra,36(sp)
 d048760:	df000815 	stw	fp,32(sp)
 d048764:	df000804 	addi	fp,sp,32
 d048768:	e13ffb15 	stw	r4,-20(fp)
 d04876c:	e1800215 	stw	r6,8(fp)
 d048770:	e1c00315 	stw	r7,12(fp)
 d048774:	e17ffc15 	stw	r5,-16(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 d048778:	e0bffb17 	ldw	r2,-20(fp)
 d04877c:	1004803a 	cmplt	r2,r2,zero
 d048780:	1000081e 	bne	r2,zero,d0487a4 <alt_fcntl+0x4c>
 d048784:	e0bffb17 	ldw	r2,-20(fp)
 d048788:	10800324 	muli	r2,r2,12
 d04878c:	1007883a 	mov	r3,r2
 d048790:	00834174 	movhi	r2,3333
 d048794:	10895d04 	addi	r2,r2,9588
 d048798:	1887883a 	add	r3,r3,r2
 d04879c:	e0fffe15 	stw	r3,-8(fp)
 d0487a0:	00000106 	br	d0487a8 <alt_fcntl+0x50>
 d0487a4:	e03ffe15 	stw	zero,-8(fp)
 d0487a8:	e0bffe17 	ldw	r2,-8(fp)
 d0487ac:	e0bff915 	stw	r2,-28(fp)
  
  if (fd)
 d0487b0:	e0bff917 	ldw	r2,-28(fp)
 d0487b4:	1005003a 	cmpeq	r2,r2,zero
 d0487b8:	1000301e 	bne	r2,zero,d04887c <alt_fcntl+0x124>
  {
    switch (cmd)
 d0487bc:	e0fffc17 	ldw	r3,-16(fp)
 d0487c0:	e0ffff15 	stw	r3,-4(fp)
 d0487c4:	e0ffff17 	ldw	r3,-4(fp)
 d0487c8:	188000e0 	cmpeqi	r2,r3,3
 d0487cc:	1000041e 	bne	r2,zero,d0487e0 <alt_fcntl+0x88>
 d0487d0:	e0ffff17 	ldw	r3,-4(fp)
 d0487d4:	18800120 	cmpeqi	r2,r3,4
 d0487d8:	1000081e 	bne	r2,zero,d0487fc <alt_fcntl+0xa4>
 d0487dc:	00002006 	br	d048860 <alt_fcntl+0x108>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 d0487e0:	e0bff917 	ldw	r2,-28(fp)
 d0487e4:	10c00217 	ldw	r3,8(r2)
 d0487e8:	00900034 	movhi	r2,16384
 d0487ec:	10bfffc4 	addi	r2,r2,-1
 d0487f0:	1886703a 	and	r3,r3,r2
 d0487f4:	e0fffd15 	stw	r3,-12(fp)
 d0487f8:	00002606 	br	d048894 <alt_fcntl+0x13c>
    case F_SETFL:
      va_start(argp, cmd);
 d0487fc:	e0800204 	addi	r2,fp,8
 d048800:	e0bffa15 	stw	r2,-24(fp)
      flags = va_arg(argp, long);
 d048804:	e0fffa17 	ldw	r3,-24(fp)
 d048808:	18800104 	addi	r2,r3,4
 d04880c:	e0bffa15 	stw	r2,-24(fp)
 d048810:	1805883a 	mov	r2,r3
 d048814:	10800017 	ldw	r2,0(r2)
 d048818:	e0bff815 	stw	r2,-32(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 d04881c:	e0bff917 	ldw	r2,-28(fp)
 d048820:	10c00217 	ldw	r3,8(r2)
 d048824:	00affdc4 	movi	r2,-16393
 d048828:	1886703a 	and	r3,r3,r2
 d04882c:	e0bff917 	ldw	r2,-28(fp)
 d048830:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 d048834:	e0bff917 	ldw	r2,-28(fp)
 d048838:	10800217 	ldw	r2,8(r2)
 d04883c:	1007883a 	mov	r3,r2
 d048840:	e0bff817 	ldw	r2,-32(fp)
 d048844:	1090020c 	andi	r2,r2,16392
 d048848:	1884b03a 	or	r2,r3,r2
 d04884c:	1007883a 	mov	r3,r2
 d048850:	e0bff917 	ldw	r2,-28(fp)
 d048854:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 d048858:	e03ffd15 	stw	zero,-12(fp)
 d04885c:	00000d06 	br	d048894 <alt_fcntl+0x13c>
    default:
      ALT_ERRNO = EINVAL;
 d048860:	d0488ac0 	call	d0488ac <alt_get_errno>
 d048864:	1007883a 	mov	r3,r2
 d048868:	00800584 	movi	r2,22
 d04886c:	18800015 	stw	r2,0(r3)
      return -1;
 d048870:	00bfffc4 	movi	r2,-1
 d048874:	e0bffd15 	stw	r2,-12(fp)
 d048878:	00000606 	br	d048894 <alt_fcntl+0x13c>
    }
  }

  ALT_ERRNO = EBADFD;
 d04887c:	d0488ac0 	call	d0488ac <alt_get_errno>
 d048880:	1007883a 	mov	r3,r2
 d048884:	00801444 	movi	r2,81
 d048888:	18800015 	stw	r2,0(r3)
  return -1;
 d04888c:	00ffffc4 	movi	r3,-1
 d048890:	e0fffd15 	stw	r3,-12(fp)
 d048894:	e0bffd17 	ldw	r2,-12(fp)
}
 d048898:	e037883a 	mov	sp,fp
 d04889c:	dfc00117 	ldw	ra,4(sp)
 d0488a0:	df000017 	ldw	fp,0(sp)
 d0488a4:	dec00404 	addi	sp,sp,16
 d0488a8:	f800283a 	ret

0d0488ac <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 d0488ac:	defffd04 	addi	sp,sp,-12
 d0488b0:	dfc00215 	stw	ra,8(sp)
 d0488b4:	df000115 	stw	fp,4(sp)
 d0488b8:	df000104 	addi	fp,sp,4
  return ((alt_errno) ? alt_errno() : &errno);
 d0488bc:	00834174 	movhi	r2,3333
 d0488c0:	108a6804 	addi	r2,r2,10656
 d0488c4:	10800017 	ldw	r2,0(r2)
 d0488c8:	1005003a 	cmpeq	r2,r2,zero
 d0488cc:	1000061e 	bne	r2,zero,d0488e8 <alt_get_errno+0x3c>
 d0488d0:	00834174 	movhi	r2,3333
 d0488d4:	108a6804 	addi	r2,r2,10656
 d0488d8:	10800017 	ldw	r2,0(r2)
 d0488dc:	103ee83a 	callr	r2
 d0488e0:	e0bfff15 	stw	r2,-4(fp)
 d0488e4:	00000306 	br	d0488f4 <alt_get_errno+0x48>
 d0488e8:	00834174 	movhi	r2,3333
 d0488ec:	108a8404 	addi	r2,r2,10768
 d0488f0:	e0bfff15 	stw	r2,-4(fp)
 d0488f4:	e0bfff17 	ldw	r2,-4(fp)
}
 d0488f8:	e037883a 	mov	sp,fp
 d0488fc:	dfc00117 	ldw	ra,4(sp)
 d048900:	df000017 	ldw	fp,0(sp)
 d048904:	dec00204 	addi	sp,sp,8
 d048908:	f800283a 	ret

0d04890c <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 d04890c:	defffa04 	addi	sp,sp,-24
 d048910:	dfc00515 	stw	ra,20(sp)
 d048914:	df000415 	stw	fp,16(sp)
 d048918:	df000404 	addi	fp,sp,16
 d04891c:	e13ffe15 	stw	r4,-8(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 d048920:	00834174 	movhi	r2,3333
 d048924:	108a6304 	addi	r2,r2,10636
 d048928:	10800017 	ldw	r2,0(r2)
 d04892c:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 d048930:	00003306 	br	d048a00 <alt_find_file+0xf4>
  {
    len = strlen(next->name);
 d048934:	e0bffd17 	ldw	r2,-12(fp)
 d048938:	11000217 	ldw	r4,8(r2)
 d04893c:	d00355c0 	call	d00355c <strlen>
 d048940:	e0bffc15 	stw	r2,-16(fp)
    
    if (next->name[len-1] == '/')
 d048944:	e0bffd17 	ldw	r2,-12(fp)
 d048948:	10c00217 	ldw	r3,8(r2)
 d04894c:	e0bffc17 	ldw	r2,-16(fp)
 d048950:	1885883a 	add	r2,r3,r2
 d048954:	10bfffc4 	addi	r2,r2,-1
 d048958:	10800003 	ldbu	r2,0(r2)
 d04895c:	10803fcc 	andi	r2,r2,255
 d048960:	1080201c 	xori	r2,r2,128
 d048964:	10bfe004 	addi	r2,r2,-128
 d048968:	10800bd8 	cmpnei	r2,r2,47
 d04896c:	1000031e 	bne	r2,zero,d04897c <alt_find_file+0x70>
    {
      len -= 1;
 d048970:	e0bffc17 	ldw	r2,-16(fp)
 d048974:	10bfffc4 	addi	r2,r2,-1
 d048978:	e0bffc15 	stw	r2,-16(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 d04897c:	e0bffc17 	ldw	r2,-16(fp)
 d048980:	1007883a 	mov	r3,r2
 d048984:	e0bffe17 	ldw	r2,-8(fp)
 d048988:	1885883a 	add	r2,r3,r2
 d04898c:	10800003 	ldbu	r2,0(r2)
 d048990:	10803fcc 	andi	r2,r2,255
 d048994:	1080201c 	xori	r2,r2,128
 d048998:	10bfe004 	addi	r2,r2,-128
 d04899c:	10800be0 	cmpeqi	r2,r2,47
 d0489a0:	10000a1e 	bne	r2,zero,d0489cc <alt_find_file+0xc0>
 d0489a4:	e0bffc17 	ldw	r2,-16(fp)
 d0489a8:	1007883a 	mov	r3,r2
 d0489ac:	e0bffe17 	ldw	r2,-8(fp)
 d0489b0:	1885883a 	add	r2,r3,r2
 d0489b4:	10800003 	ldbu	r2,0(r2)
 d0489b8:	10803fcc 	andi	r2,r2,255
 d0489bc:	1080201c 	xori	r2,r2,128
 d0489c0:	10bfe004 	addi	r2,r2,-128
 d0489c4:	1004c03a 	cmpne	r2,r2,zero
 d0489c8:	10000a1e 	bne	r2,zero,d0489f4 <alt_find_file+0xe8>
 d0489cc:	e0bffd17 	ldw	r2,-12(fp)
 d0489d0:	11000217 	ldw	r4,8(r2)
 d0489d4:	e1bffc17 	ldw	r6,-16(fp)
 d0489d8:	e17ffe17 	ldw	r5,-8(fp)
 d0489dc:	d049ed40 	call	d049ed4 <memcmp>
 d0489e0:	1004c03a 	cmpne	r2,r2,zero
 d0489e4:	1000031e 	bne	r2,zero,d0489f4 <alt_find_file+0xe8>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 d0489e8:	e0bffd17 	ldw	r2,-12(fp)
 d0489ec:	e0bfff15 	stw	r2,-4(fp)
 d0489f0:	00000806 	br	d048a14 <alt_find_file+0x108>
    }
    next = (alt_dev*) next->llist.next;
 d0489f4:	e0bffd17 	ldw	r2,-12(fp)
 d0489f8:	10800017 	ldw	r2,0(r2)
 d0489fc:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 d048a00:	00c34174 	movhi	r3,3333
 d048a04:	18ca6304 	addi	r3,r3,10636
 d048a08:	e0bffd17 	ldw	r2,-12(fp)
 d048a0c:	10ffc91e 	bne	r2,r3,d048934 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 d048a10:	e03fff15 	stw	zero,-4(fp)
 d048a14:	e0bfff17 	ldw	r2,-4(fp)
}
 d048a18:	e037883a 	mov	sp,fp
 d048a1c:	dfc00117 	ldw	ra,4(sp)
 d048a20:	df000017 	ldw	fp,0(sp)
 d048a24:	dec00204 	addi	sp,sp,8
 d048a28:	f800283a 	ret

0d048a2c <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 d048a2c:	defff804 	addi	sp,sp,-32
 d048a30:	dfc00715 	stw	ra,28(sp)
 d048a34:	df000615 	stw	fp,24(sp)
 d048a38:	df000604 	addi	fp,sp,24
 d048a3c:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 d048a40:	00bffa04 	movi	r2,-24
 d048a44:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 d048a48:	00834174 	movhi	r2,3333
 d048a4c:	108ad704 	addi	r2,r2,11100
 d048a50:	10800017 	ldw	r2,0(r2)
 d048a54:	e0bffa15 	stw	r2,-24(fp)
 d048a58:	e03ffb0d 	sth	zero,-20(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 d048a5c:	e17ffb0b 	ldhu	r5,-20(fp)
 d048a60:	e1bffe04 	addi	r6,fp,-8
 d048a64:	e13ffa17 	ldw	r4,-24(fp)
 d048a68:	d0132540 	call	d013254 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 d048a6c:	e03ffd15 	stw	zero,-12(fp)
 d048a70:	00001e06 	br	d048aec <alt_get_fd+0xc0>
  {
    if (!alt_fd_list[i].dev)
 d048a74:	e0bffd17 	ldw	r2,-12(fp)
 d048a78:	00c34174 	movhi	r3,3333
 d048a7c:	18c95d04 	addi	r3,r3,9588
 d048a80:	10800324 	muli	r2,r2,12
 d048a84:	10c5883a 	add	r2,r2,r3
 d048a88:	10800017 	ldw	r2,0(r2)
 d048a8c:	1004c03a 	cmpne	r2,r2,zero
 d048a90:	1000131e 	bne	r2,zero,d048ae0 <alt_get_fd+0xb4>
    {
      alt_fd_list[i].dev = dev;
 d048a94:	e0bffd17 	ldw	r2,-12(fp)
 d048a98:	00c34174 	movhi	r3,3333
 d048a9c:	18c95d04 	addi	r3,r3,9588
 d048aa0:	10800324 	muli	r2,r2,12
 d048aa4:	10c7883a 	add	r3,r2,r3
 d048aa8:	e0bfff17 	ldw	r2,-4(fp)
 d048aac:	18800015 	stw	r2,0(r3)
      if (i > alt_max_fd)
 d048ab0:	00834174 	movhi	r2,3333
 d048ab4:	108a6704 	addi	r2,r2,10652
 d048ab8:	10c00017 	ldw	r3,0(r2)
 d048abc:	e0bffd17 	ldw	r2,-12(fp)
 d048ac0:	1880040e 	bge	r3,r2,d048ad4 <alt_get_fd+0xa8>
      {
        alt_max_fd = i;
 d048ac4:	00c34174 	movhi	r3,3333
 d048ac8:	18ca6704 	addi	r3,r3,10652
 d048acc:	e0bffd17 	ldw	r2,-12(fp)
 d048ad0:	18800015 	stw	r2,0(r3)
      }
      rc = i;
 d048ad4:	e0bffd17 	ldw	r2,-12(fp)
 d048ad8:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 d048adc:	00000606 	br	d048af8 <alt_get_fd+0xcc>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 d048ae0:	e0bffd17 	ldw	r2,-12(fp)
 d048ae4:	10800044 	addi	r2,r2,1
 d048ae8:	e0bffd15 	stw	r2,-12(fp)
 d048aec:	e0bffd17 	ldw	r2,-12(fp)
 d048af0:	10800810 	cmplti	r2,r2,32
 d048af4:	103fdf1e 	bne	r2,zero,d048a74 <alt_get_fd+0x48>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 d048af8:	00834174 	movhi	r2,3333
 d048afc:	108ad704 	addi	r2,r2,11100
 d048b00:	11000017 	ldw	r4,0(r2)
 d048b04:	d01364c0 	call	d01364c <OSSemPost>

  return rc;
 d048b08:	e0bffc17 	ldw	r2,-16(fp)
}
 d048b0c:	e037883a 	mov	sp,fp
 d048b10:	dfc00117 	ldw	ra,4(sp)
 d048b14:	df000017 	ldw	fp,0(sp)
 d048b18:	dec00204 	addi	sp,sp,8
 d048b1c:	f800283a 	ret

0d048b20 <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 d048b20:	deffed04 	addi	sp,sp,-76
 d048b24:	dfc01215 	stw	ra,72(sp)
 d048b28:	df001115 	stw	fp,68(sp)
 d048b2c:	dc401015 	stw	r17,64(sp)
 d048b30:	dc000f15 	stw	r16,60(sp)
 d048b34:	df000f04 	addi	fp,sp,60
 d048b38:	e13ffd15 	stw	r4,-12(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 d048b3c:	e03ff505 	stb	zero,-44(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 d048b40:	008341b4 	movhi	r2,3334
 d048b44:	10b50904 	addi	r2,r2,-11228
 d048b48:	10800017 	ldw	r2,0(r2)
 d048b4c:	10c00044 	addi	r3,r2,1
 d048b50:	008341b4 	movhi	r2,3334
 d048b54:	10b50904 	addi	r2,r2,-11228
 d048b58:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 d048b5c:	e0bffd17 	ldw	r2,-12(fp)
 d048b60:	10800317 	ldw	r2,12(r2)
 d048b64:	e0bffa15 	stw	r2,-24(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 d048b68:	e0bffd17 	ldw	r2,-12(fp)
 d048b6c:	10c00417 	ldw	r3,16(r2)
 d048b70:	e0bffa17 	ldw	r2,-24(fp)
 d048b74:	10800003 	ldbu	r2,0(r2)
 d048b78:	10803fcc 	andi	r2,r2,255
 d048b7c:	108003cc 	andi	r2,r2,15
 d048b80:	1085883a 	add	r2,r2,r2
 d048b84:	1085883a 	add	r2,r2,r2
 d048b88:	1885c83a 	sub	r2,r3,r2
 d048b8c:	e0bffc15 	stw	r2,-16(fp)
   host = p->fhost;                       /* filled in by IP layer */
 d048b90:	e0bffd17 	ldw	r2,-12(fp)
 d048b94:	10800717 	ldw	r2,28(r2)
 d048b98:	e0bffb15 	stw	r2,-20(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d048b9c:	00834174 	movhi	r2,3333
 d048ba0:	108aa404 	addi	r2,r2,10896
 d048ba4:	10800017 	ldw	r2,0(r2)
 d048ba8:	1081000c 	andi	r2,r2,1024
 d048bac:	1005003a 	cmpeq	r2,r2,zero
 d048bb0:	1000161e 	bne	r2,zero,d048c0c <icmprcv+0xec>
 d048bb4:	00834174 	movhi	r2,3333
 d048bb8:	108aa404 	addi	r2,r2,10896
 d048bbc:	10800017 	ldw	r2,0(r2)
 d048bc0:	1080800c 	andi	r2,r2,512
 d048bc4:	1005003a 	cmpeq	r2,r2,zero
 d048bc8:	1000101e 	bne	r2,zero,d048c0c <icmprcv+0xec>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 d048bcc:	e0bffb17 	ldw	r2,-20(fp)
 d048bd0:	11803fcc 	andi	r6,r2,255
 d048bd4:	e0bffb17 	ldw	r2,-20(fp)
 d048bd8:	1004d23a 	srli	r2,r2,8
 d048bdc:	11c03fcc 	andi	r7,r2,255
 d048be0:	e0bffb17 	ldw	r2,-20(fp)
 d048be4:	1004d43a 	srli	r2,r2,16
 d048be8:	10c03fcc 	andi	r3,r2,255
 d048bec:	e0bffb17 	ldw	r2,-20(fp)
 d048bf0:	1004d63a 	srli	r2,r2,24
 d048bf4:	d8c00015 	stw	r3,0(sp)
 d048bf8:	d8800115 	stw	r2,4(sp)
 d048bfc:	01034174 	movhi	r4,3333
 d048c00:	21016404 	addi	r4,r4,1424
 d048c04:	e17ffc17 	ldw	r5,-16(fp)
 d048c08:	d0029980 	call	d002998 <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 d048c0c:	e0bffa17 	ldw	r2,-24(fp)
 d048c10:	10800003 	ldbu	r2,0(r2)
 d048c14:	10803fcc 	andi	r2,r2,255
 d048c18:	108003cc 	andi	r2,r2,15
 d048c1c:	1085883a 	add	r2,r2,r2
 d048c20:	1085883a 	add	r2,r2,r2
 d048c24:	1007883a 	mov	r3,r2
 d048c28:	e0bffa17 	ldw	r2,-24(fp)
 d048c2c:	1885883a 	add	r2,r3,r2
 d048c30:	e0bff915 	stw	r2,-28(fp)

   osum = e->pchksum;
 d048c34:	e0bff917 	ldw	r2,-28(fp)
 d048c38:	1080008b 	ldhu	r2,2(r2)
 d048c3c:	e0bff88d 	sth	r2,-30(fp)
   e->pchksum = 0;
 d048c40:	e0bff917 	ldw	r2,-28(fp)
 d048c44:	1000008d 	sth	zero,2(r2)

   if (len&1)
 d048c48:	e0bffc17 	ldw	r2,-16(fp)
 d048c4c:	1080004c 	andi	r2,r2,1
 d048c50:	10803fcc 	andi	r2,r2,255
 d048c54:	1005003a 	cmpeq	r2,r2,zero
 d048c58:	1000091e 	bne	r2,zero,d048c80 <icmprcv+0x160>
   {
      sav_ch = *(((char *) e) + len);
 d048c5c:	e0fff917 	ldw	r3,-28(fp)
 d048c60:	e0bffc17 	ldw	r2,-16(fp)
 d048c64:	1885883a 	add	r2,r3,r2
 d048c68:	10800003 	ldbu	r2,0(r2)
 d048c6c:	e0bff505 	stb	r2,-44(fp)
      ((char *)e)[len] = 0;
 d048c70:	e0fff917 	ldw	r3,-28(fp)
 d048c74:	e0bffc17 	ldw	r2,-16(fp)
 d048c78:	1885883a 	add	r2,r3,r2
 d048c7c:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 d048c80:	e0bffc17 	ldw	r2,-16(fp)
 d048c84:	10800044 	addi	r2,r2,1
 d048c88:	100ad07a 	srli	r5,r2,1
 d048c8c:	e13ff917 	ldw	r4,-28(fp)
 d048c90:	d0242340 	call	d024234 <cksum>
 d048c94:	0084303a 	nor	r2,zero,r2
 d048c98:	e0bff80d 	sth	r2,-32(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 d048c9c:	e0bffc17 	ldw	r2,-16(fp)
 d048ca0:	1080004c 	andi	r2,r2,1
 d048ca4:	10803fcc 	andi	r2,r2,255
 d048ca8:	1005003a 	cmpeq	r2,r2,zero
 d048cac:	1000051e 	bne	r2,zero,d048cc4 <icmprcv+0x1a4>
 d048cb0:	e0fff917 	ldw	r3,-28(fp)
 d048cb4:	e0bffc17 	ldw	r2,-16(fp)
 d048cb8:	1887883a 	add	r3,r3,r2
 d048cbc:	e0bff503 	ldbu	r2,-44(fp)
 d048cc0:	18800005 	stb	r2,0(r3)
   if (xsum != osum)
 d048cc4:	e0fff80b 	ldhu	r3,-32(fp)
 d048cc8:	e0bff88b 	ldhu	r2,-30(fp)
 d048ccc:	18802c26 	beq	r3,r2,d048d80 <icmprcv+0x260>
   {
      e->pchksum = osum;
 d048cd0:	e0fff917 	ldw	r3,-28(fp)
 d048cd4:	e0bff88b 	ldhu	r2,-30(fp)
 d048cd8:	1880008d 	sth	r2,2(r3)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d048cdc:	00834174 	movhi	r2,3333
 d048ce0:	108aa404 	addi	r2,r2,10896
 d048ce4:	10800017 	ldw	r2,0(r2)
 d048ce8:	1081000c 	andi	r2,r2,1024
 d048cec:	1005003a 	cmpeq	r2,r2,zero
 d048cf0:	1000131e 	bne	r2,zero,d048d40 <icmprcv+0x220>
 d048cf4:	00834174 	movhi	r2,3333
 d048cf8:	108aa404 	addi	r2,r2,10896
 d048cfc:	10800017 	ldw	r2,0(r2)
 d048d00:	1080800c 	andi	r2,r2,512
 d048d04:	1005003a 	cmpeq	r2,r2,zero
 d048d08:	10000d1e 	bne	r2,zero,d048d40 <icmprcv+0x220>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 d048d0c:	e17ff88b 	ldhu	r5,-30(fp)
 d048d10:	e1bff80b 	ldhu	r6,-32(fp)
 d048d14:	01034174 	movhi	r4,3333
 d048d18:	21016c04 	addi	r4,r4,1456
 d048d1c:	d0029980 	call	d002998 <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 d048d20:	00834174 	movhi	r2,3333
 d048d24:	108aa404 	addi	r2,r2,10896
 d048d28:	10800017 	ldw	r2,0(r2)
 d048d2c:	1080008c 	andi	r2,r2,2
 d048d30:	1005003a 	cmpeq	r2,r2,zero
 d048d34:	1000021e 	bne	r2,zero,d048d40 <icmprcv+0x220>
 d048d38:	e13ffd17 	ldw	r4,-12(fp)
 d048d3c:	d03e6540 	call	d03e654 <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 d048d40:	008341b4 	movhi	r2,3334
 d048d44:	10b50904 	addi	r2,r2,-11228
 d048d48:	10800117 	ldw	r2,4(r2)
 d048d4c:	10c00044 	addi	r3,r2,1
 d048d50:	008341b4 	movhi	r2,3334
 d048d54:	10b50904 	addi	r2,r2,-11228
 d048d58:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d048d5c:	01000084 	movi	r4,2
 d048d60:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d048d64:	e13ffd17 	ldw	r4,-12(fp)
 d048d68:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d048d6c:	01000084 	movi	r4,2
 d048d70:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 d048d74:	00bff804 	movi	r2,-32
 d048d78:	e0bfff15 	stw	r2,-4(fp)
 d048d7c:	00026d06 	br	d049734 <icmprcv+0xc14>
   }

   e->pchksum = osum;
 d048d80:	e0fff917 	ldw	r3,-28(fp)
 d048d84:	e0bff88b 	ldhu	r2,-30(fp)
 d048d88:	1880008d 	sth	r2,2(r3)

   switch (e->ptype) 
 d048d8c:	e0bff917 	ldw	r2,-28(fp)
 d048d90:	10800003 	ldbu	r2,0(r2)
 d048d94:	10803fcc 	andi	r2,r2,255
 d048d98:	1080201c 	xori	r2,r2,128
 d048d9c:	10bfe004 	addi	r2,r2,-128
 d048da0:	e0bffe15 	stw	r2,-8(fp)
 d048da4:	e0fffe17 	ldw	r3,-8(fp)
 d048da8:	18800428 	cmpgeui	r2,r3,16
 d048dac:	1002401e 	bne	r2,zero,d0496b0 <icmprcv+0xb90>
 d048db0:	e13ffe17 	ldw	r4,-8(fp)
 d048db4:	e13ffe17 	ldw	r4,-8(fp)
 d048db8:	2105883a 	add	r2,r4,r4
 d048dbc:	1087883a 	add	r3,r2,r2
 d048dc0:	00834174 	movhi	r2,3333
 d048dc4:	10a37504 	addi	r2,r2,-29228
 d048dc8:	1885883a 	add	r2,r3,r2
 d048dcc:	10800017 	ldw	r2,0(r2)
 d048dd0:	1000683a 	jmp	r2
 d048dd4:	0d0490b8 	rdprs	r20,at,4674
 d048dd8:	0d0496b0 	cmpltui	r20,at,4698
 d048ddc:	0d0496b0 	cmpltui	r20,at,4698
 d048de0:	0d0490e4 	muli	r20,at,4675
 d048de4:	0d0491d4 	ori	r20,at,4679
 d048de8:	0d04927c 	xorhi	r20,at,4681
 d048dec:	0d0496b0 	cmpltui	r20,at,4698
 d048df0:	0d0496b0 	cmpltui	r20,at,4698
 d048df4:	0d048e14 	ori	r20,at,4664
 d048df8:	0d0496b0 	cmpltui	r20,at,4698
 d048dfc:	0d0496b0 	cmpltui	r20,at,4698
 d048e00:	0d04939c 	xori	r20,at,4686
 d048e04:	0d0494a4 	muli	r20,at,4690
 d048e08:	0d049520 	cmpeqi	r20,at,4692
 d048e0c:	0d0496b0 	cmpltui	r20,at,4698
 d048e10:	0d049670 	cmpltui	r20,at,4697
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 d048e14:	008341b4 	movhi	r2,3334
 d048e18:	10b50904 	addi	r2,r2,-11228
 d048e1c:	10800717 	ldw	r2,28(r2)
 d048e20:	10c00044 	addi	r3,r2,1
 d048e24:	008341b4 	movhi	r2,3334
 d048e28:	10b50904 	addi	r2,r2,-11228
 d048e2c:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 d048e30:	00834174 	movhi	r2,3333
 d048e34:	108aa404 	addi	r2,r2,10896
 d048e38:	10800017 	ldw	r2,0(r2)
 d048e3c:	1081000c 	andi	r2,r2,1024
 d048e40:	1005003a 	cmpeq	r2,r2,zero
 d048e44:	1000141e 	bne	r2,zero,d048e98 <icmprcv+0x378>
 d048e48:	00834174 	movhi	r2,3333
 d048e4c:	108aa404 	addi	r2,r2,10896
 d048e50:	10800017 	ldw	r2,0(r2)
 d048e54:	1080800c 	andi	r2,r2,512
 d048e58:	1005003a 	cmpeq	r2,r2,zero
 d048e5c:	10000e1e 	bne	r2,zero,d048e98 <icmprcv+0x378>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 d048e60:	e0bffb17 	ldw	r2,-20(fp)
 d048e64:	11403fcc 	andi	r5,r2,255
 d048e68:	e0bffb17 	ldw	r2,-20(fp)
 d048e6c:	1004d23a 	srli	r2,r2,8
 d048e70:	11803fcc 	andi	r6,r2,255
 d048e74:	e0bffb17 	ldw	r2,-20(fp)
 d048e78:	1004d43a 	srli	r2,r2,16
 d048e7c:	11c03fcc 	andi	r7,r2,255
 d048e80:	e0bffb17 	ldw	r2,-20(fp)
 d048e84:	1004d63a 	srli	r2,r2,24
 d048e88:	d8800015 	stw	r2,0(sp)
 d048e8c:	01034174 	movhi	r4,3333
 d048e90:	21017704 	addi	r4,r4,1500
 d048e94:	d0029980 	call	d002998 <printf>
#endif
      e->ptype = ECHOREP;
 d048e98:	e0bff917 	ldw	r2,-28(fp)
 d048e9c:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 d048ea0:	e0bff917 	ldw	r2,-28(fp)
 d048ea4:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 d048ea8:	e0bffc17 	ldw	r2,-16(fp)
 d048eac:	1080004c 	andi	r2,r2,1
 d048eb0:	10803fcc 	andi	r2,r2,255
 d048eb4:	1005003a 	cmpeq	r2,r2,zero
 d048eb8:	1000091e 	bne	r2,zero,d048ee0 <icmprcv+0x3c0>
      {
         sav_ch = *(((char *) e) + len);
 d048ebc:	e0fff917 	ldw	r3,-28(fp)
 d048ec0:	e0bffc17 	ldw	r2,-16(fp)
 d048ec4:	1885883a 	add	r2,r3,r2
 d048ec8:	10800003 	ldbu	r2,0(r2)
 d048ecc:	e0bff505 	stb	r2,-44(fp)
         ((char *)e)[len] = 0;
 d048ed0:	e0fff917 	ldw	r3,-28(fp)
 d048ed4:	e0bffc17 	ldw	r2,-16(fp)
 d048ed8:	1885883a 	add	r2,r3,r2
 d048edc:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 d048ee0:	e0bffc17 	ldw	r2,-16(fp)
 d048ee4:	10800044 	addi	r2,r2,1
 d048ee8:	100ad07a 	srli	r5,r2,1
 d048eec:	e13ff917 	ldw	r4,-28(fp)
 d048ef0:	d0242340 	call	d024234 <cksum>
 d048ef4:	0084303a 	nor	r2,zero,r2
 d048ef8:	1007883a 	mov	r3,r2
 d048efc:	e0bff917 	ldw	r2,-28(fp)
 d048f00:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 d048f04:	e0bffc17 	ldw	r2,-16(fp)
 d048f08:	1080004c 	andi	r2,r2,1
 d048f0c:	10803fcc 	andi	r2,r2,255
 d048f10:	1005003a 	cmpeq	r2,r2,zero
 d048f14:	1000051e 	bne	r2,zero,d048f2c <icmprcv+0x40c>
 d048f18:	e0fff917 	ldw	r3,-28(fp)
 d048f1c:	e0bffc17 	ldw	r2,-16(fp)
 d048f20:	1887883a 	add	r3,r3,r2
 d048f24:	e0bff503 	ldbu	r2,-44(fp)
 d048f28:	18800005 	stb	r2,0(r3)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 d048f2c:	e0bffa17 	ldw	r2,-24(fp)
 d048f30:	10800417 	ldw	r2,16(r2)
 d048f34:	10bfffe0 	cmpeqi	r2,r2,-1
 d048f38:	1000211e 	bne	r2,zero,d048fc0 <icmprcv+0x4a0>
 d048f3c:	e0bffa17 	ldw	r2,-24(fp)
 d048f40:	10800417 	ldw	r2,16(r2)
 d048f44:	1004d63a 	srli	r2,r2,24
 d048f48:	10c03fcc 	andi	r3,r2,255
 d048f4c:	e0bffa17 	ldw	r2,-24(fp)
 d048f50:	10800417 	ldw	r2,16(r2)
 d048f54:	1004d23a 	srli	r2,r2,8
 d048f58:	10bfc00c 	andi	r2,r2,65280
 d048f5c:	1886b03a 	or	r3,r3,r2
 d048f60:	e0bffa17 	ldw	r2,-24(fp)
 d048f64:	10800417 	ldw	r2,16(r2)
 d048f68:	10bfc00c 	andi	r2,r2,65280
 d048f6c:	1004923a 	slli	r2,r2,8
 d048f70:	1886b03a 	or	r3,r3,r2
 d048f74:	e0bffa17 	ldw	r2,-24(fp)
 d048f78:	10800417 	ldw	r2,16(r2)
 d048f7c:	10803fcc 	andi	r2,r2,255
 d048f80:	1004963a 	slli	r2,r2,24
 d048f84:	1884b03a 	or	r2,r3,r2
 d048f88:	10fc002c 	andhi	r3,r2,61440
 d048f8c:	00b80034 	movhi	r2,57344
 d048f90:	18800b26 	beq	r3,r2,d048fc0 <icmprcv+0x4a0>
 d048f94:	e0bffa17 	ldw	r2,-24(fp)
 d048f98:	11000417 	ldw	r4,16(r2)
 d048f9c:	e0bffd17 	ldw	r2,-12(fp)
 d048fa0:	10800617 	ldw	r2,24(r2)
 d048fa4:	10c00a17 	ldw	r3,40(r2)
 d048fa8:	e0bffd17 	ldw	r2,-12(fp)
 d048fac:	10800617 	ldw	r2,24(r2)
 d048fb0:	10800c17 	ldw	r2,48(r2)
 d048fb4:	0084303a 	nor	r2,zero,r2
 d048fb8:	1884b03a 	or	r2,r3,r2
 d048fbc:	2080061e 	bne	r4,r2,d048fd8 <icmprcv+0x4b8>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 d048fc0:	e0bffd17 	ldw	r2,-12(fp)
 d048fc4:	10800617 	ldw	r2,24(r2)
 d048fc8:	10c00a17 	ldw	r3,40(r2)
 d048fcc:	e0bffa17 	ldw	r2,-24(fp)
 d048fd0:	10c00315 	stw	r3,12(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 d048fd4:	00000406 	br	d048fe8 <icmprcv+0x4c8>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
      }
      else pip->ip_src = pip->ip_dest;
 d048fd8:	e0bffa17 	ldw	r2,-24(fp)
 d048fdc:	10c00417 	ldw	r3,16(r2)
 d048fe0:	e0bffa17 	ldw	r2,-24(fp)
 d048fe4:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 d048fe8:	e0fffa17 	ldw	r3,-24(fp)
 d048fec:	e0bffb17 	ldw	r2,-20(fp)
 d048ff0:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutEchoReps++;
 d048ff4:	008341b4 	movhi	r2,3334
 d048ff8:	10b50904 	addi	r2,r2,-11228
 d048ffc:	10801517 	ldw	r2,84(r2)
 d049000:	10c00044 	addi	r3,r2,1
 d049004:	008341b4 	movhi	r2,3334
 d049008:	10b50904 	addi	r2,r2,-11228
 d04900c:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 d049010:	008341b4 	movhi	r2,3334
 d049014:	10b50904 	addi	r2,r2,-11228
 d049018:	10800d17 	ldw	r2,52(r2)
 d04901c:	10c00044 	addi	r3,r2,1
 d049020:	008341b4 	movhi	r2,3334
 d049024:	10b50904 	addi	r2,r2,-11228
 d049028:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 d04902c:	e0fffd17 	ldw	r3,-12(fp)
 d049030:	e0bffb17 	ldw	r2,-20(fp)
 d049034:	18800715 	stw	r2,28(r3)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 d049038:	e0bffd17 	ldw	r2,-12(fp)
 d04903c:	10c00317 	ldw	r3,12(r2)
 d049040:	e0bffa17 	ldw	r2,-24(fp)
 d049044:	10800003 	ldbu	r2,0(r2)
 d049048:	10803fcc 	andi	r2,r2,255
 d04904c:	108003cc 	andi	r2,r2,15
 d049050:	1085883a 	add	r2,r2,r2
 d049054:	1085883a 	add	r2,r2,r2
 d049058:	1887883a 	add	r3,r3,r2
 d04905c:	e0bffd17 	ldw	r2,-12(fp)
 d049060:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 d049064:	e0fffd17 	ldw	r3,-12(fp)
 d049068:	e0bffc17 	ldw	r2,-16(fp)
 d04906c:	18800415 	stw	r2,16(r3)

      i = ip_write(ICMP_PROT, p);
 d049070:	01000044 	movi	r4,1
 d049074:	e17ffd17 	ldw	r5,-12(fp)
 d049078:	d03d4240 	call	d03d424 <ip_write>
 d04907c:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 d049080:	e0bff417 	ldw	r2,-48(fp)
 d049084:	1004403a 	cmpge	r2,r2,zero
 d049088:	1000091e 	bne	r2,zero,d0490b0 <icmprcv+0x590>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 d04908c:	00834174 	movhi	r2,3333
 d049090:	108aa404 	addi	r2,r2,10896
 d049094:	10800017 	ldw	r2,0(r2)
 d049098:	1081000c 	andi	r2,r2,1024
 d04909c:	1005003a 	cmpeq	r2,r2,zero
 d0490a0:	1000031e 	bne	r2,zero,d0490b0 <icmprcv+0x590>
            dprintf("icmp: reply failed\n");
 d0490a4:	01034174 	movhi	r4,3333
 d0490a8:	21018004 	addi	r4,r4,1536
 d0490ac:	d002cc00 	call	d002cc0 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 d0490b0:	e03fff15 	stw	zero,-4(fp)
 d0490b4:	00019f06 	br	d049734 <icmprcv+0xc14>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 d0490b8:	008341b4 	movhi	r2,3334
 d0490bc:	10b50904 	addi	r2,r2,-11228
 d0490c0:	10800817 	ldw	r2,32(r2)
 d0490c4:	10c00044 	addi	r3,r2,1
 d0490c8:	008341b4 	movhi	r2,3334
 d0490cc:	10b50904 	addi	r2,r2,-11228
 d0490d0:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 d0490d4:	e13ffd17 	ldw	r4,-12(fp)
 d0490d8:	d041e000 	call	d041e00 <ip_raw_input>
 d0490dc:	e0bfff15 	stw	r2,-4(fp)
 d0490e0:	00019406 	br	d049734 <icmprcv+0xc14>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 d0490e4:	008341b4 	movhi	r2,3334
 d0490e8:	10b50904 	addi	r2,r2,-11228
 d0490ec:	10800217 	ldw	r2,8(r2)
 d0490f0:	10c00044 	addi	r3,r2,1
 d0490f4:	008341b4 	movhi	r2,3334
 d0490f8:	10b50904 	addi	r2,r2,-11228
 d0490fc:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 d049100:	e0bff917 	ldw	r2,-28(fp)
 d049104:	e0bff615 	stw	r2,-40(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d049108:	00834174 	movhi	r2,3333
 d04910c:	108aa404 	addi	r2,r2,10896
 d049110:	10800017 	ldw	r2,0(r2)
 d049114:	1081000c 	andi	r2,r2,1024
 d049118:	1005003a 	cmpeq	r2,r2,zero
 d04911c:	1000291e 	bne	r2,zero,d0491c4 <icmprcv+0x6a4>
      {
         dprintf("ICMP: got dest unreachable type ");
 d049120:	01034174 	movhi	r4,3333
 d049124:	21018504 	addi	r4,r4,1556
 d049128:	d0029980 	call	d002998 <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 d04912c:	e0bff617 	ldw	r2,-40(fp)
 d049130:	10800043 	ldbu	r2,1(r2)
 d049134:	11403fcc 	andi	r5,r2,255
 d049138:	2940201c 	xori	r5,r5,128
 d04913c:	297fe004 	addi	r5,r5,-128
 d049140:	e0bff617 	ldw	r2,-40(fp)
 d049144:	10800617 	ldw	r2,24(r2)
 d049148:	11803fcc 	andi	r6,r2,255
 d04914c:	e0bff617 	ldw	r2,-40(fp)
 d049150:	10800617 	ldw	r2,24(r2)
 d049154:	1004d23a 	srli	r2,r2,8
 d049158:	11c03fcc 	andi	r7,r2,255
 d04915c:	e0bff617 	ldw	r2,-40(fp)
 d049160:	10800617 	ldw	r2,24(r2)
 d049164:	1004d43a 	srli	r2,r2,16
 d049168:	10c03fcc 	andi	r3,r2,255
 d04916c:	e0bff617 	ldw	r2,-40(fp)
 d049170:	10800617 	ldw	r2,24(r2)
 d049174:	1004d63a 	srli	r2,r2,24
 d049178:	d8c00015 	stw	r3,0(sp)
 d04917c:	d8800115 	stw	r2,4(sp)
 d049180:	01034174 	movhi	r4,3333
 d049184:	21018e04 	addi	r4,r4,1592
 d049188:	d0029980 	call	d002998 <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 d04918c:	e0bffb17 	ldw	r2,-20(fp)
 d049190:	11403fcc 	andi	r5,r2,255
 d049194:	e0bffb17 	ldw	r2,-20(fp)
 d049198:	1004d23a 	srli	r2,r2,8
 d04919c:	11803fcc 	andi	r6,r2,255
 d0491a0:	e0bffb17 	ldw	r2,-20(fp)
 d0491a4:	1004d43a 	srli	r2,r2,16
 d0491a8:	11c03fcc 	andi	r7,r2,255
 d0491ac:	e0bffb17 	ldw	r2,-20(fp)
 d0491b0:	1004d63a 	srli	r2,r2,24
 d0491b4:	d8800015 	stw	r2,0(sp)
 d0491b8:	01034174 	movhi	r4,3333
 d0491bc:	21019304 	addi	r4,r4,1612
 d0491c0:	d0029980 	call	d002998 <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 d0491c4:	e13ffd17 	ldw	r4,-12(fp)
 d0491c8:	e17ff617 	ldw	r5,-40(fp)
 d0491cc:	d049dd80 	call	d049dd8 <icmp_du>
      break;
 d0491d0:	00015606 	br	d04972c <icmprcv+0xc0c>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 d0491d4:	008341b4 	movhi	r2,3334
 d0491d8:	10b50904 	addi	r2,r2,-11228
 d0491dc:	10800517 	ldw	r2,20(r2)
 d0491e0:	10c00044 	addi	r3,r2,1
 d0491e4:	008341b4 	movhi	r2,3334
 d0491e8:	10b50904 	addi	r2,r2,-11228
 d0491ec:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d0491f0:	00834174 	movhi	r2,3333
 d0491f4:	108aa404 	addi	r2,r2,10896
 d0491f8:	10800017 	ldw	r2,0(r2)
 d0491fc:	1081000c 	andi	r2,r2,1024
 d049200:	1005003a 	cmpeq	r2,r2,zero
 d049204:	1000161e 	bne	r2,zero,d049260 <icmprcv+0x740>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 d049208:	e0bffb17 	ldw	r2,-20(fp)
 d04920c:	11403fcc 	andi	r5,r2,255
 d049210:	e0bffb17 	ldw	r2,-20(fp)
 d049214:	1004d23a 	srli	r2,r2,8
 d049218:	11803fcc 	andi	r6,r2,255
 d04921c:	e0bffb17 	ldw	r2,-20(fp)
 d049220:	1004d43a 	srli	r2,r2,16
 d049224:	11c03fcc 	andi	r7,r2,255
 d049228:	e0bffb17 	ldw	r2,-20(fp)
 d04922c:	1004d63a 	srli	r2,r2,24
 d049230:	d8800015 	stw	r2,0(sp)
 d049234:	01034174 	movhi	r4,3333
 d049238:	21019804 	addi	r4,r4,1632
 d04923c:	d0029980 	call	d002998 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 d049240:	00834174 	movhi	r2,3333
 d049244:	108aa404 	addi	r2,r2,10896
 d049248:	10800017 	ldw	r2,0(r2)
 d04924c:	1080008c 	andi	r2,r2,2
 d049250:	1005003a 	cmpeq	r2,r2,zero
 d049254:	1000021e 	bne	r2,zero,d049260 <icmprcv+0x740>
 d049258:	e13ffd17 	ldw	r4,-12(fp)
 d04925c:	d03e6540 	call	d03e654 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d049260:	01000084 	movi	r4,2
 d049264:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d049268:	e13ffd17 	ldw	r4,-12(fp)
 d04926c:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d049270:	01000084 	movi	r4,2
 d049274:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      break;
 d049278:	00012c06 	br	d04972c <icmprcv+0xc0c>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 d04927c:	008341b4 	movhi	r2,3334
 d049280:	10b50904 	addi	r2,r2,-11228
 d049284:	10800617 	ldw	r2,24(r2)
 d049288:	10c00044 	addi	r3,r2,1
 d04928c:	008341b4 	movhi	r2,3334
 d049290:	10b50904 	addi	r2,r2,-11228
 d049294:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 d049298:	e0bff917 	ldw	r2,-28(fp)
 d04929c:	e0bff715 	stw	r2,-36(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d0492a0:	00834174 	movhi	r2,3333
 d0492a4:	108aa404 	addi	r2,r2,10896
 d0492a8:	10800017 	ldw	r2,0(r2)
 d0492ac:	1081000c 	andi	r2,r2,1024
 d0492b0:	1005003a 	cmpeq	r2,r2,zero
 d0492b4:	1000241e 	bne	r2,zero,d049348 <icmprcv+0x828>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 d0492b8:	e0bff717 	ldw	r2,-36(fp)
 d0492bc:	10800617 	ldw	r2,24(r2)
 d0492c0:	11403fcc 	andi	r5,r2,255
 d0492c4:	e0bff717 	ldw	r2,-36(fp)
 d0492c8:	10800617 	ldw	r2,24(r2)
 d0492cc:	1004d23a 	srli	r2,r2,8
 d0492d0:	11803fcc 	andi	r6,r2,255
 d0492d4:	e0bff717 	ldw	r2,-36(fp)
 d0492d8:	10800617 	ldw	r2,24(r2)
 d0492dc:	1004d43a 	srli	r2,r2,16
 d0492e0:	11c03fcc 	andi	r7,r2,255
 d0492e4:	e0bff717 	ldw	r2,-36(fp)
 d0492e8:	10800617 	ldw	r2,24(r2)
 d0492ec:	1004d63a 	srli	r2,r2,24
 d0492f0:	d8800015 	stw	r2,0(sp)
 d0492f4:	01034174 	movhi	r4,3333
 d0492f8:	2101a204 	addi	r4,r4,1672
 d0492fc:	d0029980 	call	d002998 <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 d049300:	e0bff717 	ldw	r2,-36(fp)
 d049304:	10800117 	ldw	r2,4(r2)
 d049308:	11403fcc 	andi	r5,r2,255
 d04930c:	e0bff717 	ldw	r2,-36(fp)
 d049310:	10800117 	ldw	r2,4(r2)
 d049314:	1004d23a 	srli	r2,r2,8
 d049318:	11803fcc 	andi	r6,r2,255
 d04931c:	e0bff717 	ldw	r2,-36(fp)
 d049320:	10800117 	ldw	r2,4(r2)
 d049324:	1004d43a 	srli	r2,r2,16
 d049328:	11c03fcc 	andi	r7,r2,255
 d04932c:	e0bff717 	ldw	r2,-36(fp)
 d049330:	10800117 	ldw	r2,4(r2)
 d049334:	1004d63a 	srli	r2,r2,24
 d049338:	d8800015 	stw	r2,0(sp)
 d04933c:	01034174 	movhi	r4,3333
 d049340:	2101ac04 	addi	r4,r4,1712
 d049344:	d0029980 	call	d002998 <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 d049348:	e0bff717 	ldw	r2,-36(fp)
 d04934c:	14000617 	ldw	r16,24(r2)
 d049350:	e0bff717 	ldw	r2,-36(fp)
 d049354:	14400117 	ldw	r17,4(r2)
 d049358:	e0bffd17 	ldw	r2,-12(fp)
 d04935c:	11000617 	ldw	r4,24(r2)
 d049360:	d0225980 	call	d022598 <if_netnumber>
 d049364:	100f883a 	mov	r7,r2
 d049368:	00800104 	movi	r2,4
 d04936c:	d8800015 	stw	r2,0(sp)
 d049370:	8009883a 	mov	r4,r16
 d049374:	017fffc4 	movi	r5,-1
 d049378:	880d883a 	mov	r6,r17
 d04937c:	d0423240 	call	d042324 <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d049380:	01000084 	movi	r4,2
 d049384:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d049388:	e13ffd17 	ldw	r4,-12(fp)
 d04938c:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d049390:	01000084 	movi	r4,2
 d049394:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      break;
 d049398:	0000e406 	br	d04972c <icmprcv+0xc0c>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 d04939c:	008341b4 	movhi	r2,3334
 d0493a0:	10b50904 	addi	r2,r2,-11228
 d0493a4:	10800317 	ldw	r2,12(r2)
 d0493a8:	10c00044 	addi	r3,r2,1
 d0493ac:	008341b4 	movhi	r2,3334
 d0493b0:	10b50904 	addi	r2,r2,-11228
 d0493b4:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d0493b8:	00834174 	movhi	r2,3333
 d0493bc:	108aa404 	addi	r2,r2,10896
 d0493c0:	10800017 	ldw	r2,0(r2)
 d0493c4:	1081000c 	andi	r2,r2,1024
 d0493c8:	1005003a 	cmpeq	r2,r2,zero
 d0493cc:	10002e1e 	bne	r2,zero,d049488 <icmprcv+0x968>
      {
         struct timex * pt =  (struct  timex *)e;
 d0493d0:	e0bff917 	ldw	r2,-28(fp)
 d0493d4:	e0bff315 	stw	r2,-52(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 d0493d8:	e0bffd17 	ldw	r2,-12(fp)
 d0493dc:	10800717 	ldw	r2,28(r2)
 d0493e0:	11403fcc 	andi	r5,r2,255
 d0493e4:	e0bffd17 	ldw	r2,-12(fp)
 d0493e8:	10800717 	ldw	r2,28(r2)
 d0493ec:	1004d23a 	srli	r2,r2,8
 d0493f0:	11803fcc 	andi	r6,r2,255
 d0493f4:	e0bffd17 	ldw	r2,-12(fp)
 d0493f8:	10800717 	ldw	r2,28(r2)
 d0493fc:	1004d43a 	srli	r2,r2,16
 d049400:	11c03fcc 	andi	r7,r2,255
 d049404:	e0bffd17 	ldw	r2,-12(fp)
 d049408:	10800717 	ldw	r2,28(r2)
 d04940c:	1004d63a 	srli	r2,r2,24
 d049410:	d8800015 	stw	r2,0(sp)
 d049414:	01034174 	movhi	r4,3333
 d049418:	2101b004 	addi	r4,r4,1728
 d04941c:	d0029980 	call	d002998 <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 d049420:	e0bff317 	ldw	r2,-52(fp)
 d049424:	10800617 	ldw	r2,24(r2)
 d049428:	11403fcc 	andi	r5,r2,255
 d04942c:	e0bff317 	ldw	r2,-52(fp)
 d049430:	10800617 	ldw	r2,24(r2)
 d049434:	1004d23a 	srli	r2,r2,8
 d049438:	11803fcc 	andi	r6,r2,255
 d04943c:	e0bff317 	ldw	r2,-52(fp)
 d049440:	10800617 	ldw	r2,24(r2)
 d049444:	1004d43a 	srli	r2,r2,16
 d049448:	11c03fcc 	andi	r7,r2,255
 d04944c:	e0bff317 	ldw	r2,-52(fp)
 d049450:	10800617 	ldw	r2,24(r2)
 d049454:	1004d63a 	srli	r2,r2,24
 d049458:	d8800015 	stw	r2,0(sp)
 d04945c:	01034174 	movhi	r4,3333
 d049460:	2101b904 	addi	r4,r4,1764
 d049464:	d0029980 	call	d002998 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 d049468:	00834174 	movhi	r2,3333
 d04946c:	108aa404 	addi	r2,r2,10896
 d049470:	10800017 	ldw	r2,0(r2)
 d049474:	1080008c 	andi	r2,r2,2
 d049478:	1005003a 	cmpeq	r2,r2,zero
 d04947c:	1000021e 	bne	r2,zero,d049488 <icmprcv+0x968>
 d049480:	e13ffd17 	ldw	r4,-12(fp)
 d049484:	d03e6540 	call	d03e654 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d049488:	01000084 	movi	r4,2
 d04948c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d049490:	e13ffd17 	ldw	r4,-12(fp)
 d049494:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d049498:	01000084 	movi	r4,2
 d04949c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      break;
 d0494a0:	0000a206 	br	d04972c <icmprcv+0xc0c>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 d0494a4:	008341b4 	movhi	r2,3334
 d0494a8:	10b50904 	addi	r2,r2,-11228
 d0494ac:	10800417 	ldw	r2,16(r2)
 d0494b0:	10c00044 	addi	r3,r2,1
 d0494b4:	008341b4 	movhi	r2,3334
 d0494b8:	10b50904 	addi	r2,r2,-11228
 d0494bc:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d0494c0:	00834174 	movhi	r2,3333
 d0494c4:	108aa404 	addi	r2,r2,10896
 d0494c8:	10800017 	ldw	r2,0(r2)
 d0494cc:	1081000c 	andi	r2,r2,1024
 d0494d0:	1005003a 	cmpeq	r2,r2,zero
 d0494d4:	1000031e 	bne	r2,zero,d0494e4 <icmprcv+0x9c4>
         dprintf("ICMP: got param problem message\n");
 d0494d8:	01034174 	movhi	r4,3333
 d0494dc:	2101be04 	addi	r4,r4,1784
 d0494e0:	d002cc00 	call	d002cc0 <puts>
      if (NDEBUG & DUMP)
 d0494e4:	00834174 	movhi	r2,3333
 d0494e8:	108aa404 	addi	r2,r2,10896
 d0494ec:	10800017 	ldw	r2,0(r2)
 d0494f0:	1080008c 	andi	r2,r2,2
 d0494f4:	1005003a 	cmpeq	r2,r2,zero
 d0494f8:	1000021e 	bne	r2,zero,d049504 <icmprcv+0x9e4>
      {
         ip_dump(p);
 d0494fc:	e13ffd17 	ldw	r4,-12(fp)
 d049500:	d03e6540 	call	d03e654 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d049504:	01000084 	movi	r4,2
 d049508:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d04950c:	e13ffd17 	ldw	r4,-12(fp)
 d049510:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d049514:	01000084 	movi	r4,2
 d049518:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      break;
 d04951c:	00008306 	br	d04972c <icmprcv+0xc0c>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 d049520:	008341b4 	movhi	r2,3334
 d049524:	10b50904 	addi	r2,r2,-11228
 d049528:	10800917 	ldw	r2,36(r2)
 d04952c:	10c00044 	addi	r3,r2,1
 d049530:	008341b4 	movhi	r2,3334
 d049534:	10b50904 	addi	r2,r2,-11228
 d049538:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d04953c:	00834174 	movhi	r2,3333
 d049540:	108aa404 	addi	r2,r2,10896
 d049544:	10800017 	ldw	r2,0(r2)
 d049548:	1081000c 	andi	r2,r2,1024
 d04954c:	1005003a 	cmpeq	r2,r2,zero
 d049550:	1000031e 	bne	r2,zero,d049560 <icmprcv+0xa40>
         dprintf("ICMP: got timestamp request\n");
 d049554:	01034174 	movhi	r4,3333
 d049558:	2101c604 	addi	r4,r4,1816
 d04955c:	d002cc00 	call	d002cc0 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 d049560:	e0fff917 	ldw	r3,-28(fp)
 d049564:	00800384 	movi	r2,14
 d049568:	18800005 	stb	r2,0(r3)
      e->pchksum = 0;
 d04956c:	e0bff917 	ldw	r2,-28(fp)
 d049570:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 d049574:	e13ff917 	ldw	r4,-28(fp)
 d049578:	01400284 	movi	r5,10
 d04957c:	d0242340 	call	d024234 <cksum>
 d049580:	0084303a 	nor	r2,zero,r2
 d049584:	1007883a 	mov	r3,r2
 d049588:	e0bff917 	ldw	r2,-28(fp)
 d04958c:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 d049590:	e0bffa17 	ldw	r2,-24(fp)
 d049594:	10c00417 	ldw	r3,16(r2)
 d049598:	e0bffa17 	ldw	r2,-24(fp)
 d04959c:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 d0495a0:	e0fffa17 	ldw	r3,-24(fp)
 d0495a4:	e0bffb17 	ldw	r2,-20(fp)
 d0495a8:	18800415 	stw	r2,16(r3)
      icmp_mib.icmpOutMsgs++;
 d0495ac:	008341b4 	movhi	r2,3334
 d0495b0:	10b50904 	addi	r2,r2,-11228
 d0495b4:	10800d17 	ldw	r2,52(r2)
 d0495b8:	10c00044 	addi	r3,r2,1
 d0495bc:	008341b4 	movhi	r2,3334
 d0495c0:	10b50904 	addi	r2,r2,-11228
 d0495c4:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 d0495c8:	008341b4 	movhi	r2,3334
 d0495cc:	10b50904 	addi	r2,r2,-11228
 d0495d0:	10801717 	ldw	r2,92(r2)
 d0495d4:	10c00044 	addi	r3,r2,1
 d0495d8:	008341b4 	movhi	r2,3334
 d0495dc:	10b50904 	addi	r2,r2,-11228
 d0495e0:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 d0495e4:	e0bffd17 	ldw	r2,-12(fp)
 d0495e8:	10c00317 	ldw	r3,12(r2)
 d0495ec:	e0bffa17 	ldw	r2,-24(fp)
 d0495f0:	10800003 	ldbu	r2,0(r2)
 d0495f4:	10803fcc 	andi	r2,r2,255
 d0495f8:	108003cc 	andi	r2,r2,15
 d0495fc:	1085883a 	add	r2,r2,r2
 d049600:	1085883a 	add	r2,r2,r2
 d049604:	1887883a 	add	r3,r3,r2
 d049608:	e0bffd17 	ldw	r2,-12(fp)
 d04960c:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 d049610:	e0fffd17 	ldw	r3,-12(fp)
 d049614:	00800504 	movi	r2,20
 d049618:	18800415 	stw	r2,16(r3)
      p->fhost = host;
 d04961c:	e0fffd17 	ldw	r3,-12(fp)
 d049620:	e0bffb17 	ldw	r2,-20(fp)
 d049624:	18800715 	stw	r2,28(r3)
      i = ip_write(ICMP_PROT, p);
 d049628:	01000044 	movi	r4,1
 d04962c:	e17ffd17 	ldw	r5,-12(fp)
 d049630:	d03d4240 	call	d03d424 <ip_write>
 d049634:	e0bff415 	stw	r2,-48(fp)
      if (i < 0)
 d049638:	e0bff417 	ldw	r2,-48(fp)
 d04963c:	1004403a 	cmpge	r2,r2,zero
 d049640:	1000091e 	bne	r2,zero,d049668 <icmprcv+0xb48>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 d049644:	00834174 	movhi	r2,3333
 d049648:	108aa404 	addi	r2,r2,10896
 d04964c:	10800017 	ldw	r2,0(r2)
 d049650:	1081000c 	andi	r2,r2,1024
 d049654:	1005003a 	cmpeq	r2,r2,zero
 d049658:	1000031e 	bne	r2,zero,d049668 <icmprcv+0xb48>
            dprintf("icmp: can't send timestamp reply\n");
 d04965c:	01034174 	movhi	r4,3333
 d049660:	2101cd04 	addi	r4,r4,1844
 d049664:	d002cc00 	call	d002cc0 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 d049668:	e03fff15 	stw	zero,-4(fp)
 d04966c:	00003106 	br	d049734 <icmprcv+0xc14>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d049670:	00834174 	movhi	r2,3333
 d049674:	108aa404 	addi	r2,r2,10896
 d049678:	10800017 	ldw	r2,0(r2)
 d04967c:	1081000c 	andi	r2,r2,1024
 d049680:	1005003a 	cmpeq	r2,r2,zero
 d049684:	1000031e 	bne	r2,zero,d049694 <icmprcv+0xb74>
         dprintf("icmp: got info request\n");
 d049688:	01034174 	movhi	r4,3333
 d04968c:	2101d604 	addi	r4,r4,1880
 d049690:	d002cc00 	call	d002cc0 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d049694:	01000084 	movi	r4,2
 d049698:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d04969c:	e13ffd17 	ldw	r4,-12(fp)
 d0496a0:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0496a4:	01000084 	movi	r4,2
 d0496a8:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      break;
 d0496ac:	00001f06 	br	d04972c <icmprcv+0xc0c>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 d0496b0:	00834174 	movhi	r2,3333
 d0496b4:	108aa404 	addi	r2,r2,10896
 d0496b8:	10800017 	ldw	r2,0(r2)
 d0496bc:	1081000c 	andi	r2,r2,1024
 d0496c0:	1005003a 	cmpeq	r2,r2,zero
 d0496c4:	1000101e 	bne	r2,zero,d049708 <icmprcv+0xbe8>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 d0496c8:	e0bff917 	ldw	r2,-28(fp)
 d0496cc:	10800003 	ldbu	r2,0(r2)
 d0496d0:	11403fcc 	andi	r5,r2,255
 d0496d4:	2940201c 	xori	r5,r5,128
 d0496d8:	297fe004 	addi	r5,r5,-128
 d0496dc:	01034174 	movhi	r4,3333
 d0496e0:	2101dc04 	addi	r4,r4,1904
 d0496e4:	d0029980 	call	d002998 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 d0496e8:	00834174 	movhi	r2,3333
 d0496ec:	108aa404 	addi	r2,r2,10896
 d0496f0:	10800017 	ldw	r2,0(r2)
 d0496f4:	1080008c 	andi	r2,r2,2
 d0496f8:	1005003a 	cmpeq	r2,r2,zero
 d0496fc:	1000021e 	bne	r2,zero,d049708 <icmprcv+0xbe8>
 d049700:	e13ffd17 	ldw	r4,-12(fp)
 d049704:	d03e6540 	call	d03e654 <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 d049708:	01000084 	movi	r4,2
 d04970c:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
      pk_free(p);
 d049710:	e13ffd17 	ldw	r4,-12(fp)
 d049714:	d028b380 	call	d028b38 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d049718:	01000084 	movi	r4,2
 d04971c:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 d049720:	00800084 	movi	r2,2
 d049724:	e0bfff15 	stw	r2,-4(fp)
 d049728:	00000206 	br	d049734 <icmprcv+0xc14>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 d04972c:	00c00084 	movi	r3,2
 d049730:	e0ffff15 	stw	r3,-4(fp)
 d049734:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* FULL_ICMP */
}
 d049738:	e037883a 	mov	sp,fp
 d04973c:	dfc00317 	ldw	ra,12(sp)
 d049740:	df000217 	ldw	fp,8(sp)
 d049744:	dc400117 	ldw	r17,4(sp)
 d049748:	dc000017 	ldw	r16,0(sp)
 d04974c:	dec00404 	addi	sp,sp,16
 d049750:	f800283a 	ret

0d049754 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 d049754:	defff404 	addi	sp,sp,-48
 d049758:	dfc00b15 	stw	ra,44(sp)
 d04975c:	df000a15 	stw	fp,40(sp)
 d049760:	df000a04 	addi	fp,sp,40
 d049764:	e13ffc15 	stw	r4,-16(fp)
 d049768:	e17ffd15 	stw	r5,-12(fp)
 d04976c:	e1bffe15 	stw	r6,-8(fp)
 d049770:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 d049774:	00834174 	movhi	r2,3333
 d049778:	108aa404 	addi	r2,r2,10896
 d04977c:	10800017 	ldw	r2,0(r2)
 d049780:	1080040c 	andi	r2,r2,16
 d049784:	1005003a 	cmpeq	r2,r2,zero
 d049788:	1000171e 	bne	r2,zero,d0497e8 <icmp_destun+0x94>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 d04978c:	e0bfff17 	ldw	r2,-4(fp)
 d049790:	10803fcc 	andi	r2,r2,255
 d049794:	00c34174 	movhi	r3,3333
 d049798:	18ca1b04 	addi	r3,r3,10348
 d04979c:	1085883a 	add	r2,r2,r2
 d0497a0:	1085883a 	add	r2,r2,r2
 d0497a4:	10c5883a 	add	r2,r2,r3
 d0497a8:	11400017 	ldw	r5,0(r2)
 d0497ac:	e0bffc17 	ldw	r2,-16(fp)
 d0497b0:	11803fcc 	andi	r6,r2,255
 d0497b4:	e0bffc17 	ldw	r2,-16(fp)
 d0497b8:	1004d23a 	srli	r2,r2,8
 d0497bc:	11c03fcc 	andi	r7,r2,255
 d0497c0:	e0bffc17 	ldw	r2,-16(fp)
 d0497c4:	1004d43a 	srli	r2,r2,16
 d0497c8:	10c03fcc 	andi	r3,r2,255
 d0497cc:	e0bffc17 	ldw	r2,-16(fp)
 d0497d0:	1004d63a 	srli	r2,r2,24
 d0497d4:	d8c00015 	stw	r3,0(sp)
 d0497d8:	d8800115 	stw	r2,4(sp)
 d0497dc:	01034174 	movhi	r4,3333
 d0497e0:	2101f604 	addi	r4,r4,2008
 d0497e4:	d0029980 	call	d002998 <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 d0497e8:	01000084 	movi	r4,2
 d0497ec:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 d0497f0:	01008504 	movi	r4,532
 d0497f4:	d0287a40 	call	d0287a4 <pk_alloc>
 d0497f8:	e0bffb15 	stw	r2,-20(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d0497fc:	01000084 	movi	r4,2
 d049800:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 d049804:	e0bffb17 	ldw	r2,-20(fp)
 d049808:	1004c03a 	cmpne	r2,r2,zero
 d04980c:	1000111e 	bne	r2,zero,d049854 <icmp_destun+0x100>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 d049810:	00834174 	movhi	r2,3333
 d049814:	108aa404 	addi	r2,r2,10896
 d049818:	10800017 	ldw	r2,0(r2)
 d04981c:	1080800c 	andi	r2,r2,512
 d049820:	1005003a 	cmpeq	r2,r2,zero
 d049824:	1000031e 	bne	r2,zero,d049834 <icmp_destun+0xe0>
         dprintf("icmp: can't alloc pkt\n");
 d049828:	01034174 	movhi	r4,3333
 d04982c:	21020304 	addi	r4,r4,2060
 d049830:	d002cc00 	call	d002cc0 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 d049834:	008341b4 	movhi	r2,3334
 d049838:	10b50904 	addi	r2,r2,-11228
 d04983c:	10800e17 	ldw	r2,56(r2)
 d049840:	10c00044 	addi	r3,r2,1
 d049844:	008341b4 	movhi	r2,3334
 d049848:	10b50904 	addi	r2,r2,-11228
 d04984c:	10c00e15 	stw	r3,56(r2)
      return;
 d049850:	00008f06 	br	d049a90 <icmp_destun+0x33c>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 d049854:	e0bffb17 	ldw	r2,-20(fp)
 d049858:	10800317 	ldw	r2,12(r2)
 d04985c:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 d049860:	e0fff917 	ldw	r3,-28(fp)
 d049864:	e0bffd17 	ldw	r2,-12(fp)
 d049868:	18800315 	stw	r2,12(r3)
   pip->ip_dest = host;
 d04986c:	e0fff917 	ldw	r3,-28(fp)
 d049870:	e0bffc17 	ldw	r2,-16(fp)
 d049874:	18800415 	stw	r2,16(r3)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 d049878:	e0bffb17 	ldw	r2,-20(fp)
 d04987c:	10800317 	ldw	r2,12(r2)
 d049880:	10c00504 	addi	r3,r2,20
 d049884:	e0bffb17 	ldw	r2,-20(fp)
 d049888:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 d04988c:	e0bffb17 	ldw	r2,-20(fp)
 d049890:	10800417 	ldw	r2,16(r2)
 d049894:	10fffb04 	addi	r3,r2,-20
 d049898:	e0bffb17 	ldw	r2,-20(fp)
 d04989c:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 d0498a0:	e0fffb17 	ldw	r3,-20(fp)
 d0498a4:	e0800217 	ldw	r2,8(fp)
 d0498a8:	18800615 	stw	r2,24(r3)

   d = (struct destun *)p->nb_prot;
 d0498ac:	e0bffb17 	ldw	r2,-20(fp)
 d0498b0:	10800317 	ldw	r2,12(r2)
 d0498b4:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 d0498b8:	e0bfff17 	ldw	r2,-4(fp)
 d0498bc:	10bfc00c 	andi	r2,r2,65280
 d0498c0:	1005003a 	cmpeq	r2,r2,zero
 d0498c4:	1000061e 	bne	r2,zero,d0498e0 <icmp_destun+0x18c>
      d->dtype = (char)(typecode >>8);  /* then use it */
 d0498c8:	e0bfff17 	ldw	r2,-4(fp)
 d0498cc:	1004d23a 	srli	r2,r2,8
 d0498d0:	1007883a 	mov	r3,r2
 d0498d4:	e0bffa17 	ldw	r2,-24(fp)
 d0498d8:	10c00005 	stb	r3,0(r2)
 d0498dc:	00000306 	br	d0498ec <icmp_destun+0x198>
   else                                 /* else use default */
      d->dtype = DESTIN;
 d0498e0:	e0fffa17 	ldw	r3,-24(fp)
 d0498e4:	008000c4 	movi	r2,3
 d0498e8:	18800005 	stb	r2,0(r3)
   d->dcode = (char)(typecode & 0xFF);
 d0498ec:	e0bfff17 	ldw	r2,-4(fp)
 d0498f0:	1007883a 	mov	r3,r2
 d0498f4:	e0bffa17 	ldw	r2,-24(fp)
 d0498f8:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 d0498fc:	e0bffa17 	ldw	r2,-24(fp)
 d049900:	1000018d 	sth	zero,6(r2)
 d049904:	e0bffa17 	ldw	r2,-24(fp)
 d049908:	10c0018b 	ldhu	r3,6(r2)
 d04990c:	e0bffa17 	ldw	r2,-24(fp)
 d049910:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 d049914:	e0bfff17 	ldw	r2,-4(fp)
 d049918:	10803fcc 	andi	r2,r2,255
 d04991c:	10800118 	cmpnei	r2,r2,4
 d049920:	1000151e 	bne	r2,zero,d049978 <icmp_destun+0x224>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 d049924:	e0800217 	ldw	r2,8(fp)
 d049928:	10c00917 	ldw	r3,36(r2)
 d04992c:	e0800217 	ldw	r2,8(fp)
 d049930:	10800817 	ldw	r2,32(r2)
 d049934:	1885c83a 	sub	r2,r3,r2
 d049938:	1005d23a 	srai	r2,r2,8
 d04993c:	10803fcc 	andi	r2,r2,255
 d049940:	1009883a 	mov	r4,r2
 d049944:	e0800217 	ldw	r2,8(fp)
 d049948:	10c00917 	ldw	r3,36(r2)
 d04994c:	e0800217 	ldw	r2,8(fp)
 d049950:	10800817 	ldw	r2,32(r2)
 d049954:	1885c83a 	sub	r2,r3,r2
 d049958:	1004923a 	slli	r2,r2,8
 d04995c:	1007883a 	mov	r3,r2
 d049960:	00bfc004 	movi	r2,-256
 d049964:	1884703a 	and	r2,r3,r2
 d049968:	2084b03a 	or	r2,r4,r2
 d04996c:	1007883a 	mov	r3,r2
 d049970:	e0bffa17 	ldw	r2,-24(fp)
 d049974:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 d049978:	e0bffa17 	ldw	r2,-24(fp)
 d04997c:	11000204 	addi	r4,r2,8
 d049980:	e0fffe17 	ldw	r3,-8(fp)
 d049984:	18800017 	ldw	r2,0(r3)
 d049988:	20800015 	stw	r2,0(r4)
 d04998c:	18800117 	ldw	r2,4(r3)
 d049990:	20800115 	stw	r2,4(r4)
 d049994:	18800217 	ldw	r2,8(r3)
 d049998:	20800215 	stw	r2,8(r4)
 d04999c:	18800317 	ldw	r2,12(r3)
 d0499a0:	20800315 	stw	r2,12(r4)
 d0499a4:	18800417 	ldw	r2,16(r3)
 d0499a8:	20800415 	stw	r2,16(r4)
 d0499ac:	18800517 	ldw	r2,20(r3)
 d0499b0:	20800515 	stw	r2,20(r4)
 d0499b4:	18800617 	ldw	r2,24(r3)
 d0499b8:	20800615 	stw	r2,24(r4)

   d->dchksum = 0;
 d0499bc:	e0bffa17 	ldw	r2,-24(fp)
 d0499c0:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 d0499c4:	e13ffa17 	ldw	r4,-24(fp)
 d0499c8:	01400484 	movi	r5,18
 d0499cc:	d0242340 	call	d024234 <cksum>
 d0499d0:	0084303a 	nor	r2,zero,r2
 d0499d4:	1007883a 	mov	r3,r2
 d0499d8:	e0bffa17 	ldw	r2,-24(fp)
 d0499dc:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 d0499e0:	e0fffb17 	ldw	r3,-20(fp)
 d0499e4:	00800904 	movi	r2,36
 d0499e8:	18800415 	stw	r2,16(r3)
   p->fhost = host;
 d0499ec:	e0fffb17 	ldw	r3,-20(fp)
 d0499f0:	e0bffc17 	ldw	r2,-16(fp)
 d0499f4:	18800715 	stw	r2,28(r3)
   i = ip_write(ICMP_PROT, p);
 d0499f8:	01000044 	movi	r4,1
 d0499fc:	e17ffb17 	ldw	r5,-20(fp)
 d049a00:	d03d4240 	call	d03d424 <ip_write>
 d049a04:	e0bff815 	stw	r2,-32(fp)
   if (i < 0)
 d049a08:	e0bff817 	ldw	r2,-32(fp)
 d049a0c:	1004403a 	cmpge	r2,r2,zero
 d049a10:	1000111e 	bne	r2,zero,d049a58 <icmp_destun+0x304>
   {
      icmp_mib.icmpOutErrors++;
 d049a14:	008341b4 	movhi	r2,3334
 d049a18:	10b50904 	addi	r2,r2,-11228
 d049a1c:	10800e17 	ldw	r2,56(r2)
 d049a20:	10c00044 	addi	r3,r2,1
 d049a24:	008341b4 	movhi	r2,3334
 d049a28:	10b50904 	addi	r2,r2,-11228
 d049a2c:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 d049a30:	00834174 	movhi	r2,3333
 d049a34:	108aa404 	addi	r2,r2,10896
 d049a38:	10800017 	ldw	r2,0(r2)
 d049a3c:	1080860c 	andi	r2,r2,536
 d049a40:	1005003a 	cmpeq	r2,r2,zero
 d049a44:	1000121e 	bne	r2,zero,d049a90 <icmp_destun+0x33c>
         dprintf("ICMP: Can't send dest unreachable\n");
 d049a48:	01034174 	movhi	r4,3333
 d049a4c:	21020904 	addi	r4,r4,2084
 d049a50:	d002cc00 	call	d002cc0 <puts>
#endif   /* NPDEBUG  */
      return;
 d049a54:	00000e06 	br	d049a90 <icmp_destun+0x33c>
   }
   icmp_mib.icmpOutMsgs++;
 d049a58:	008341b4 	movhi	r2,3334
 d049a5c:	10b50904 	addi	r2,r2,-11228
 d049a60:	10800d17 	ldw	r2,52(r2)
 d049a64:	10c00044 	addi	r3,r2,1
 d049a68:	008341b4 	movhi	r2,3334
 d049a6c:	10b50904 	addi	r2,r2,-11228
 d049a70:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 d049a74:	008341b4 	movhi	r2,3334
 d049a78:	10b50904 	addi	r2,r2,-11228
 d049a7c:	10800f17 	ldw	r2,60(r2)
 d049a80:	10c00044 	addi	r3,r2,1
 d049a84:	008341b4 	movhi	r2,3334
 d049a88:	10b50904 	addi	r2,r2,-11228
 d049a8c:	10c00f15 	stw	r3,60(r2)
   return;
}
 d049a90:	e037883a 	mov	sp,fp
 d049a94:	dfc00117 	ldw	ra,4(sp)
 d049a98:	df000017 	ldw	fp,0(sp)
 d049a9c:	dec00204 	addi	sp,sp,8
 d049aa0:	f800283a 	ret

0d049aa4 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 d049aa4:	defff504 	addi	sp,sp,-44
 d049aa8:	dfc00a15 	stw	ra,40(sp)
 d049aac:	df000915 	stw	fp,36(sp)
 d049ab0:	df000904 	addi	fp,sp,36
 d049ab4:	e13ffe15 	stw	r4,-8(fp)
 d049ab8:	e17fff05 	stb	r5,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 d049abc:	00834174 	movhi	r2,3333
 d049ac0:	108aa404 	addi	r2,r2,10896
 d049ac4:	10800017 	ldw	r2,0(r2)
 d049ac8:	1080040c 	andi	r2,r2,16
 d049acc:	1005003a 	cmpeq	r2,r2,zero
 d049ad0:	1000301e 	bne	r2,zero,d049b94 <icmp_timex+0xf0>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 d049ad4:	e17fff07 	ldb	r5,-4(fp)
 d049ad8:	e0bffe17 	ldw	r2,-8(fp)
 d049adc:	10800317 	ldw	r2,12(r2)
 d049ae0:	1004d23a 	srli	r2,r2,8
 d049ae4:	10c03fcc 	andi	r3,r2,255
 d049ae8:	e0bffe17 	ldw	r2,-8(fp)
 d049aec:	10800317 	ldw	r2,12(r2)
 d049af0:	1004923a 	slli	r2,r2,8
 d049af4:	10bfc00c 	andi	r2,r2,65280
 d049af8:	1884b03a 	or	r2,r3,r2
 d049afc:	11803fcc 	andi	r6,r2,255
 d049b00:	e0bffe17 	ldw	r2,-8(fp)
 d049b04:	10800317 	ldw	r2,12(r2)
 d049b08:	1004d23a 	srli	r2,r2,8
 d049b0c:	10c03fcc 	andi	r3,r2,255
 d049b10:	e0bffe17 	ldw	r2,-8(fp)
 d049b14:	10800317 	ldw	r2,12(r2)
 d049b18:	1004923a 	slli	r2,r2,8
 d049b1c:	10bfc00c 	andi	r2,r2,65280
 d049b20:	1884b03a 	or	r2,r3,r2
 d049b24:	1004d23a 	srli	r2,r2,8
 d049b28:	11c03fcc 	andi	r7,r2,255
 d049b2c:	e0bffe17 	ldw	r2,-8(fp)
 d049b30:	10800317 	ldw	r2,12(r2)
 d049b34:	1004d23a 	srli	r2,r2,8
 d049b38:	10c03fcc 	andi	r3,r2,255
 d049b3c:	e0bffe17 	ldw	r2,-8(fp)
 d049b40:	10800317 	ldw	r2,12(r2)
 d049b44:	1004923a 	slli	r2,r2,8
 d049b48:	10bfc00c 	andi	r2,r2,65280
 d049b4c:	1884b03a 	or	r2,r3,r2
 d049b50:	1004d43a 	srli	r2,r2,16
 d049b54:	11003fcc 	andi	r4,r2,255
 d049b58:	e0bffe17 	ldw	r2,-8(fp)
 d049b5c:	10800317 	ldw	r2,12(r2)
 d049b60:	1004d23a 	srli	r2,r2,8
 d049b64:	10c03fcc 	andi	r3,r2,255
 d049b68:	e0bffe17 	ldw	r2,-8(fp)
 d049b6c:	10800317 	ldw	r2,12(r2)
 d049b70:	1004923a 	slli	r2,r2,8
 d049b74:	10bfc00c 	andi	r2,r2,65280
 d049b78:	1884b03a 	or	r2,r3,r2
 d049b7c:	1004d63a 	srli	r2,r2,24
 d049b80:	d9000015 	stw	r4,0(sp)
 d049b84:	d8800115 	stw	r2,4(sp)
 d049b88:	01034174 	movhi	r4,3333
 d049b8c:	21021204 	addi	r4,r4,2120
 d049b90:	d0029980 	call	d002998 <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 d049b94:	e0bffe17 	ldw	r2,-8(fp)
 d049b98:	10800003 	ldbu	r2,0(r2)
 d049b9c:	108003cc 	andi	r2,r2,15
 d049ba0:	1085883a 	add	r2,r2,r2
 d049ba4:	1085883a 	add	r2,r2,r2
 d049ba8:	10800404 	addi	r2,r2,16
 d049bac:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 d049bb0:	01000084 	movi	r4,2
 d049bb4:	d0296880 	call	d029688 <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 d049bb8:	e0fff903 	ldbu	r3,-28(fp)
 d049bbc:	00834174 	movhi	r2,3333
 d049bc0:	108aa204 	addi	r2,r2,10888
 d049bc4:	10800017 	ldw	r2,0(r2)
 d049bc8:	1885883a 	add	r2,r3,r2
 d049bcc:	11000504 	addi	r4,r2,20
 d049bd0:	d0287a40 	call	d0287a4 <pk_alloc>
 d049bd4:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 d049bd8:	01000084 	movi	r4,2
 d049bdc:	d0297480 	call	d029748 <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 d049be0:	e0bffd17 	ldw	r2,-12(fp)
 d049be4:	1004c03a 	cmpne	r2,r2,zero
 d049be8:	1000111e 	bne	r2,zero,d049c30 <icmp_timex+0x18c>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 d049bec:	00834174 	movhi	r2,3333
 d049bf0:	108aa404 	addi	r2,r2,10896
 d049bf4:	10800017 	ldw	r2,0(r2)
 d049bf8:	1080800c 	andi	r2,r2,512
 d049bfc:	1005003a 	cmpeq	r2,r2,zero
 d049c00:	1000031e 	bne	r2,zero,d049c10 <icmp_timex+0x16c>
         dprintf("icmp: can't alloc pkt\n");
 d049c04:	01034174 	movhi	r4,3333
 d049c08:	21020304 	addi	r4,r4,2060
 d049c0c:	d002cc00 	call	d002cc0 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 d049c10:	008341b4 	movhi	r2,3334
 d049c14:	10b50904 	addi	r2,r2,-11228
 d049c18:	10800e17 	ldw	r2,56(r2)
 d049c1c:	10c00044 	addi	r3,r2,1
 d049c20:	008341b4 	movhi	r2,3334
 d049c24:	10b50904 	addi	r2,r2,-11228
 d049c28:	10c00e15 	stw	r3,56(r2)
      return;
 d049c2c:	00006506 	br	d049dc4 <icmp_timex+0x320>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 d049c30:	e0bffd17 	ldw	r2,-12(fp)
 d049c34:	10800317 	ldw	r2,12(r2)
 d049c38:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 d049c3c:	e0bffe17 	ldw	r2,-8(fp)
 d049c40:	10c00417 	ldw	r3,16(r2)
 d049c44:	e0bffb17 	ldw	r2,-20(fp)
 d049c48:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 d049c4c:	e0bffe17 	ldw	r2,-8(fp)
 d049c50:	10c00317 	ldw	r3,12(r2)
 d049c54:	e0bffb17 	ldw	r2,-20(fp)
 d049c58:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 d049c5c:	e0bffd17 	ldw	r2,-12(fp)
 d049c60:	10800317 	ldw	r2,12(r2)
 d049c64:	10c00504 	addi	r3,r2,20
 d049c68:	e0bffd17 	ldw	r2,-12(fp)
 d049c6c:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 d049c70:	e0bffd17 	ldw	r2,-12(fp)
 d049c74:	10800317 	ldw	r2,12(r2)
 d049c78:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 d049c7c:	e0fffc17 	ldw	r3,-16(fp)
 d049c80:	008002c4 	movi	r2,11
 d049c84:	18800005 	stb	r2,0(r3)
   tx->tcode = code;
 d049c88:	e0fffc17 	ldw	r3,-16(fp)
 d049c8c:	e0bfff03 	ldbu	r2,-4(fp)
 d049c90:	18800045 	stb	r2,1(r3)
   tx->tno1 = tx->tno2 = 0;
 d049c94:	e0bffc17 	ldw	r2,-16(fp)
 d049c98:	1000018d 	sth	zero,6(r2)
 d049c9c:	e0bffc17 	ldw	r2,-16(fp)
 d049ca0:	10c0018b 	ldhu	r3,6(r2)
 d049ca4:	e0bffc17 	ldw	r2,-16(fp)
 d049ca8:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 d049cac:	e0bffc17 	ldw	r2,-16(fp)
 d049cb0:	11000204 	addi	r4,r2,8
 d049cb4:	e0bffe17 	ldw	r2,-8(fp)
 d049cb8:	10800003 	ldbu	r2,0(r2)
 d049cbc:	10803fcc 	andi	r2,r2,255
 d049cc0:	108003cc 	andi	r2,r2,15
 d049cc4:	1085883a 	add	r2,r2,r2
 d049cc8:	1085883a 	add	r2,r2,r2
 d049ccc:	10800204 	addi	r2,r2,8
 d049cd0:	1007883a 	mov	r3,r2
 d049cd4:	e0bffe17 	ldw	r2,-8(fp)
 d049cd8:	100b883a 	mov	r5,r2
 d049cdc:	180d883a 	mov	r6,r3
 d049ce0:	d0027000 	call	d002700 <memcpy>

   tx->tchksum = 0;
 d049ce4:	e0bffc17 	ldw	r2,-16(fp)
 d049ce8:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 d049cec:	e0bff903 	ldbu	r2,-28(fp)
 d049cf0:	1004d07a 	srli	r2,r2,1
 d049cf4:	11403fcc 	andi	r5,r2,255
 d049cf8:	e13ffc17 	ldw	r4,-16(fp)
 d049cfc:	d0242340 	call	d024234 <cksum>
 d049d00:	0084303a 	nor	r2,zero,r2
 d049d04:	1007883a 	mov	r3,r2
 d049d08:	e0bffc17 	ldw	r2,-16(fp)
 d049d0c:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 d049d10:	e0fff903 	ldbu	r3,-28(fp)
 d049d14:	e0bffd17 	ldw	r2,-12(fp)
 d049d18:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 d049d1c:	e0bffb17 	ldw	r2,-20(fp)
 d049d20:	10c00417 	ldw	r3,16(r2)
 d049d24:	e0bffd17 	ldw	r2,-12(fp)
 d049d28:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 d049d2c:	01000044 	movi	r4,1
 d049d30:	e17ffd17 	ldw	r5,-12(fp)
 d049d34:	d03d4240 	call	d03d424 <ip_write>
 d049d38:	e0bffa15 	stw	r2,-24(fp)
   if (i < 0)
 d049d3c:	e0bffa17 	ldw	r2,-24(fp)
 d049d40:	1004403a 	cmpge	r2,r2,zero
 d049d44:	1000111e 	bne	r2,zero,d049d8c <icmp_timex+0x2e8>
   {
      icmp_mib.icmpOutErrors++;
 d049d48:	008341b4 	movhi	r2,3334
 d049d4c:	10b50904 	addi	r2,r2,-11228
 d049d50:	10800e17 	ldw	r2,56(r2)
 d049d54:	10c00044 	addi	r3,r2,1
 d049d58:	008341b4 	movhi	r2,3334
 d049d5c:	10b50904 	addi	r2,r2,-11228
 d049d60:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 d049d64:	00834174 	movhi	r2,3333
 d049d68:	108aa404 	addi	r2,r2,10896
 d049d6c:	10800017 	ldw	r2,0(r2)
 d049d70:	1080860c 	andi	r2,r2,536
 d049d74:	1005003a 	cmpeq	r2,r2,zero
 d049d78:	1000121e 	bne	r2,zero,d049dc4 <icmp_timex+0x320>
         dprintf("ICMP: Can't send Time Exceeded\n");
 d049d7c:	01034174 	movhi	r4,3333
 d049d80:	21022204 	addi	r4,r4,2184
 d049d84:	d002cc00 	call	d002cc0 <puts>
#endif   /* NPDEBUG  */
      return;
 d049d88:	00000e06 	br	d049dc4 <icmp_timex+0x320>
   }
   icmp_mib.icmpOutMsgs++;
 d049d8c:	008341b4 	movhi	r2,3334
 d049d90:	10b50904 	addi	r2,r2,-11228
 d049d94:	10800d17 	ldw	r2,52(r2)
 d049d98:	10c00044 	addi	r3,r2,1
 d049d9c:	008341b4 	movhi	r2,3334
 d049da0:	10b50904 	addi	r2,r2,-11228
 d049da4:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 d049da8:	008341b4 	movhi	r2,3334
 d049dac:	10b50904 	addi	r2,r2,-11228
 d049db0:	10801017 	ldw	r2,64(r2)
 d049db4:	10c00044 	addi	r3,r2,1
 d049db8:	008341b4 	movhi	r2,3334
 d049dbc:	10b50904 	addi	r2,r2,-11228
 d049dc0:	10c01015 	stw	r3,64(r2)
   return;
}
 d049dc4:	e037883a 	mov	sp,fp
 d049dc8:	dfc00117 	ldw	ra,4(sp)
 d049dcc:	df000017 	ldw	fp,0(sp)
 d049dd0:	dec00204 	addi	sp,sp,8
 d049dd4:	f800283a 	ret

0d049dd8 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 d049dd8:	defffc04 	addi	sp,sp,-16
 d049ddc:	dfc00315 	stw	ra,12(sp)
 d049de0:	df000215 	stw	fp,8(sp)
 d049de4:	df000204 	addi	fp,sp,8
 d049de8:	e13ffe15 	stw	r4,-8(fp)
 d049dec:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 d049df0:	d0a0dc17 	ldw	r2,-31888(gp)
 d049df4:	1005003a 	cmpeq	r2,r2,zero
 d049df8:	1000041e 	bne	r2,zero,d049e0c <icmp_du+0x34>
      icmpdu_hook(p, pdp);
 d049dfc:	d0a0dc17 	ldw	r2,-31888(gp)
 d049e00:	e13ffe17 	ldw	r4,-8(fp)
 d049e04:	e17fff17 	ldw	r5,-4(fp)
 d049e08:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 d049e0c:	e13ffe17 	ldw	r4,-8(fp)
 d049e10:	e17fff17 	ldw	r5,-4(fp)
 d049e14:	d02b6180 	call	d02b618 <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 d049e18:	e037883a 	mov	sp,fp
 d049e1c:	dfc00117 	ldw	ra,4(sp)
 d049e20:	df000017 	ldw	fp,0(sp)
 d049e24:	dec00204 	addi	sp,sp,8
 d049e28:	f800283a 	ret

0d049e2c <atexit>:
 d049e2c:	200b883a 	mov	r5,r4
 d049e30:	000d883a 	mov	r6,zero
 d049e34:	0009883a 	mov	r4,zero
 d049e38:	000f883a 	mov	r7,zero
 d049e3c:	d04a4901 	jmpi	d04a490 <__register_exitproc>

0d049e40 <_atoi_r>:
 d049e40:	000d883a 	mov	r6,zero
 d049e44:	01c00284 	movi	r7,10
 d049e48:	d04a1801 	jmpi	d04a180 <_strtol_r>

0d049e4c <atoi>:
 d049e4c:	000b883a 	mov	r5,zero
 d049e50:	01800284 	movi	r6,10
 d049e54:	d04a3c41 	jmpi	d04a3c4 <strtol>

0d049e58 <calloc>:
 d049e58:	01834174 	movhi	r6,3333
 d049e5c:	318a2204 	addi	r6,r6,10376
 d049e60:	2007883a 	mov	r3,r4
 d049e64:	31000017 	ldw	r4,0(r6)
 d049e68:	280d883a 	mov	r6,r5
 d049e6c:	180b883a 	mov	r5,r3
 d049e70:	d00a5901 	jmpi	d00a590 <_calloc_r>

0d049e74 <exit>:
 d049e74:	defffe04 	addi	sp,sp,-8
 d049e78:	000b883a 	mov	r5,zero
 d049e7c:	dc000015 	stw	r16,0(sp)
 d049e80:	dfc00115 	stw	ra,4(sp)
 d049e84:	2021883a 	mov	r16,r4
 d049e88:	d04a5c80 	call	d04a5c8 <__call_exitprocs>
 d049e8c:	00834174 	movhi	r2,3333
 d049e90:	108a2304 	addi	r2,r2,10380
 d049e94:	11000017 	ldw	r4,0(r2)
 d049e98:	20800f17 	ldw	r2,60(r4)
 d049e9c:	10000126 	beq	r2,zero,d049ea4 <exit+0x30>
 d049ea0:	103ee83a 	callr	r2
 d049ea4:	8009883a 	mov	r4,r16
 d049ea8:	d04a7b80 	call	d04a7b8 <_exit>

0d049eac <free>:
 d049eac:	00834174 	movhi	r2,3333
 d049eb0:	108a2204 	addi	r2,r2,10376
 d049eb4:	200b883a 	mov	r5,r4
 d049eb8:	11000017 	ldw	r4,0(r2)
 d049ebc:	d0076bc1 	jmpi	d0076bc <_free_r>

0d049ec0 <malloc>:
 d049ec0:	00834174 	movhi	r2,3333
 d049ec4:	108a2204 	addi	r2,r2,10376
 d049ec8:	200b883a 	mov	r5,r4
 d049ecc:	11000017 	ldw	r4,0(r2)
 d049ed0:	d0082441 	jmpi	d008244 <_malloc_r>

0d049ed4 <memcmp>:
 d049ed4:	00c000c4 	movi	r3,3
 d049ed8:	1980032e 	bgeu	r3,r6,d049ee8 <memcmp+0x14>
 d049edc:	2144b03a 	or	r2,r4,r5
 d049ee0:	10c4703a 	and	r2,r2,r3
 d049ee4:	10000f26 	beq	r2,zero,d049f24 <memcmp+0x50>
 d049ee8:	31ffffc4 	addi	r7,r6,-1
 d049eec:	3000061e 	bne	r6,zero,d049f08 <memcmp+0x34>
 d049ef0:	00000a06 	br	d049f1c <memcmp+0x48>
 d049ef4:	39ffffc4 	addi	r7,r7,-1
 d049ef8:	00bfffc4 	movi	r2,-1
 d049efc:	21000044 	addi	r4,r4,1
 d049f00:	29400044 	addi	r5,r5,1
 d049f04:	38800526 	beq	r7,r2,d049f1c <memcmp+0x48>
 d049f08:	20c00003 	ldbu	r3,0(r4)
 d049f0c:	28800003 	ldbu	r2,0(r5)
 d049f10:	18bff826 	beq	r3,r2,d049ef4 <memcmp+0x20>
 d049f14:	1885c83a 	sub	r2,r3,r2
 d049f18:	f800283a 	ret
 d049f1c:	0005883a 	mov	r2,zero
 d049f20:	f800283a 	ret
 d049f24:	180f883a 	mov	r7,r3
 d049f28:	20c00017 	ldw	r3,0(r4)
 d049f2c:	28800017 	ldw	r2,0(r5)
 d049f30:	18bfed1e 	bne	r3,r2,d049ee8 <memcmp+0x14>
 d049f34:	31bfff04 	addi	r6,r6,-4
 d049f38:	21000104 	addi	r4,r4,4
 d049f3c:	29400104 	addi	r5,r5,4
 d049f40:	39bff936 	bltu	r7,r6,d049f28 <memcmp+0x54>
 d049f44:	003fe806 	br	d049ee8 <memcmp+0x14>

0d049f48 <strcpy>:
 d049f48:	2904b03a 	or	r2,r5,r4
 d049f4c:	108000cc 	andi	r2,r2,3
 d049f50:	10000826 	beq	r2,zero,d049f74 <strcpy+0x2c>
 d049f54:	2007883a 	mov	r3,r4
 d049f58:	28800003 	ldbu	r2,0(r5)
 d049f5c:	29400044 	addi	r5,r5,1
 d049f60:	18800005 	stb	r2,0(r3)
 d049f64:	18c00044 	addi	r3,r3,1
 d049f68:	103ffb1e 	bne	r2,zero,d049f58 <strcpy+0x10>
 d049f6c:	2005883a 	mov	r2,r4
 d049f70:	f800283a 	ret
 d049f74:	29800017 	ldw	r6,0(r5)
 d049f78:	023fbff4 	movhi	r8,65279
 d049f7c:	423fbfc4 	addi	r8,r8,-257
 d049f80:	02a02074 	movhi	r10,32897
 d049f84:	52a02004 	addi	r10,r10,-32640
 d049f88:	3205883a 	add	r2,r6,r8
 d049f8c:	0186303a 	nor	r3,zero,r6
 d049f90:	10c4703a 	and	r2,r2,r3
 d049f94:	1284703a 	and	r2,r2,r10
 d049f98:	200f883a 	mov	r7,r4
 d049f9c:	10000b1e 	bne	r2,zero,d049fcc <strcpy+0x84>
 d049fa0:	4013883a 	mov	r9,r8
 d049fa4:	5011883a 	mov	r8,r10
 d049fa8:	39800015 	stw	r6,0(r7)
 d049fac:	29400104 	addi	r5,r5,4
 d049fb0:	29800017 	ldw	r6,0(r5)
 d049fb4:	39c00104 	addi	r7,r7,4
 d049fb8:	3245883a 	add	r2,r6,r9
 d049fbc:	0186303a 	nor	r3,zero,r6
 d049fc0:	10c4703a 	and	r2,r2,r3
 d049fc4:	1204703a 	and	r2,r2,r8
 d049fc8:	103ff726 	beq	r2,zero,d049fa8 <strcpy+0x60>
 d049fcc:	3807883a 	mov	r3,r7
 d049fd0:	003fe106 	br	d049f58 <strcpy+0x10>

0d049fd4 <strncmp>:
 d049fd4:	30003926 	beq	r6,zero,d04a0bc <strncmp+0xe8>
 d049fd8:	2144b03a 	or	r2,r4,r5
 d049fdc:	108000cc 	andi	r2,r2,3
 d049fe0:	028000c4 	movi	r10,3
 d049fe4:	1000241e 	bne	r2,zero,d04a078 <strncmp+0xa4>
 d049fe8:	2011883a 	mov	r8,r4
 d049fec:	280f883a 	mov	r7,r5
 d049ff0:	51801f2e 	bgeu	r10,r6,d04a070 <strncmp+0x9c>
 d049ff4:	21000017 	ldw	r4,0(r4)
 d049ff8:	28800017 	ldw	r2,0(r5)
 d049ffc:	20801c1e 	bne	r4,r2,d04a070 <strncmp+0x9c>
 d04a000:	31bfff04 	addi	r6,r6,-4
 d04a004:	30002d26 	beq	r6,zero,d04a0bc <strncmp+0xe8>
 d04a008:	027fbff4 	movhi	r9,65279
 d04a00c:	4a7fbfc4 	addi	r9,r9,-257
 d04a010:	2247883a 	add	r3,r4,r9
 d04a014:	01602074 	movhi	r5,32897
 d04a018:	29602004 	addi	r5,r5,-32640
 d04a01c:	1946703a 	and	r3,r3,r5
 d04a020:	0104303a 	nor	r2,zero,r4
 d04a024:	10c4703a 	and	r2,r2,r3
 d04a028:	1000241e 	bne	r2,zero,d04a0bc <strncmp+0xe8>
 d04a02c:	5017883a 	mov	r11,r10
 d04a030:	4815883a 	mov	r10,r9
 d04a034:	2813883a 	mov	r9,r5
 d04a038:	00000a06 	br	d04a064 <strncmp+0x90>
 d04a03c:	41000017 	ldw	r4,0(r8)
 d04a040:	39400017 	ldw	r5,0(r7)
 d04a044:	2285883a 	add	r2,r4,r10
 d04a048:	1244703a 	and	r2,r2,r9
 d04a04c:	0106303a 	nor	r3,zero,r4
 d04a050:	1886703a 	and	r3,r3,r2
 d04a054:	2140061e 	bne	r4,r5,d04a070 <strncmp+0x9c>
 d04a058:	31bfff04 	addi	r6,r6,-4
 d04a05c:	30001726 	beq	r6,zero,d04a0bc <strncmp+0xe8>
 d04a060:	1800161e 	bne	r3,zero,d04a0bc <strncmp+0xe8>
 d04a064:	42000104 	addi	r8,r8,4
 d04a068:	39c00104 	addi	r7,r7,4
 d04a06c:	59bff336 	bltu	r11,r6,d04a03c <strncmp+0x68>
 d04a070:	4009883a 	mov	r4,r8
 d04a074:	380b883a 	mov	r5,r7
 d04a078:	31bfffc4 	addi	r6,r6,-1
 d04a07c:	01ffffc4 	movi	r7,-1
 d04a080:	31c00a1e 	bne	r6,r7,d04a0ac <strncmp+0xd8>
 d04a084:	20c00003 	ldbu	r3,0(r4)
 d04a088:	28800003 	ldbu	r2,0(r5)
 d04a08c:	1885c83a 	sub	r2,r3,r2
 d04a090:	f800283a 	ret
 d04a094:	30000926 	beq	r6,zero,d04a0bc <strncmp+0xe8>
 d04a098:	18000826 	beq	r3,zero,d04a0bc <strncmp+0xe8>
 d04a09c:	31bfffc4 	addi	r6,r6,-1
 d04a0a0:	21000044 	addi	r4,r4,1
 d04a0a4:	29400044 	addi	r5,r5,1
 d04a0a8:	31fff626 	beq	r6,r7,d04a084 <strncmp+0xb0>
 d04a0ac:	20c00007 	ldb	r3,0(r4)
 d04a0b0:	28800007 	ldb	r2,0(r5)
 d04a0b4:	18bff726 	beq	r3,r2,d04a094 <strncmp+0xc0>
 d04a0b8:	003ff206 	br	d04a084 <strncmp+0xb0>
 d04a0bc:	0005883a 	mov	r2,zero
 d04a0c0:	f800283a 	ret

0d04a0c4 <strncpy>:
 d04a0c4:	2904b03a 	or	r2,r5,r4
 d04a0c8:	108000cc 	andi	r2,r2,3
 d04a0cc:	00c000c4 	movi	r3,3
 d04a0d0:	1000291e 	bne	r2,zero,d04a178 <strncpy+0xb4>
 d04a0d4:	1980282e 	bgeu	r3,r6,d04a178 <strncpy+0xb4>
 d04a0d8:	1817883a 	mov	r11,r3
 d04a0dc:	2011883a 	mov	r8,r4
 d04a0e0:	02bfbff4 	movhi	r10,65279
 d04a0e4:	52bfbfc4 	addi	r10,r10,-257
 d04a0e8:	02602074 	movhi	r9,32897
 d04a0ec:	4a602004 	addi	r9,r9,-32640
 d04a0f0:	29c00017 	ldw	r7,0(r5)
 d04a0f4:	3a85883a 	add	r2,r7,r10
 d04a0f8:	01c6303a 	nor	r3,zero,r7
 d04a0fc:	10c4703a 	and	r2,r2,r3
 d04a100:	1244703a 	and	r2,r2,r9
 d04a104:	1000051e 	bne	r2,zero,d04a11c <strncpy+0x58>
 d04a108:	31bfff04 	addi	r6,r6,-4
 d04a10c:	41c00015 	stw	r7,0(r8)
 d04a110:	29400104 	addi	r5,r5,4
 d04a114:	42000104 	addi	r8,r8,4
 d04a118:	59bff536 	bltu	r11,r6,d04a0f0 <strncpy+0x2c>
 d04a11c:	400f883a 	mov	r7,r8
 d04a120:	30001326 	beq	r6,zero,d04a170 <strncpy+0xac>
 d04a124:	28800003 	ldbu	r2,0(r5)
 d04a128:	31bfffc4 	addi	r6,r6,-1
 d04a12c:	38c00044 	addi	r3,r7,1
 d04a130:	38800005 	stb	r2,0(r7)
 d04a134:	10000826 	beq	r2,zero,d04a158 <strncpy+0x94>
 d04a138:	29400044 	addi	r5,r5,1
 d04a13c:	30000c26 	beq	r6,zero,d04a170 <strncpy+0xac>
 d04a140:	28800003 	ldbu	r2,0(r5)
 d04a144:	31bfffc4 	addi	r6,r6,-1
 d04a148:	29400044 	addi	r5,r5,1
 d04a14c:	18800005 	stb	r2,0(r3)
 d04a150:	18c00044 	addi	r3,r3,1
 d04a154:	103ff91e 	bne	r2,zero,d04a13c <strncpy+0x78>
 d04a158:	30000526 	beq	r6,zero,d04a170 <strncpy+0xac>
 d04a15c:	1805883a 	mov	r2,r3
 d04a160:	30cd883a 	add	r6,r6,r3
 d04a164:	10000005 	stb	zero,0(r2)
 d04a168:	10800044 	addi	r2,r2,1
 d04a16c:	30bffd1e 	bne	r6,r2,d04a164 <strncpy+0xa0>
 d04a170:	2005883a 	mov	r2,r4
 d04a174:	f800283a 	ret
 d04a178:	200f883a 	mov	r7,r4
 d04a17c:	003fe806 	br	d04a120 <strncpy+0x5c>

0d04a180 <_strtol_r>:
 d04a180:	defff304 	addi	sp,sp,-52
 d04a184:	00834174 	movhi	r2,3333
 d04a188:	108a2104 	addi	r2,r2,10372
 d04a18c:	dcc00615 	stw	r19,24(sp)
 d04a190:	14c00017 	ldw	r19,0(r2)
 d04a194:	ddc00a15 	stw	r23,40(sp)
 d04a198:	dc000315 	stw	r16,12(sp)
 d04a19c:	dfc00c15 	stw	ra,48(sp)
 d04a1a0:	df000b15 	stw	fp,44(sp)
 d04a1a4:	dd800915 	stw	r22,36(sp)
 d04a1a8:	dd400815 	stw	r21,32(sp)
 d04a1ac:	dd000715 	stw	r20,28(sp)
 d04a1b0:	dc800515 	stw	r18,20(sp)
 d04a1b4:	dc400415 	stw	r17,16(sp)
 d04a1b8:	282f883a 	mov	r23,r5
 d04a1bc:	d9000015 	stw	r4,0(sp)
 d04a1c0:	d9800115 	stw	r6,4(sp)
 d04a1c4:	2821883a 	mov	r16,r5
 d04a1c8:	84400007 	ldb	r17,0(r16)
 d04a1cc:	84000044 	addi	r16,r16,1
 d04a1d0:	9c47883a 	add	r3,r19,r17
 d04a1d4:	18800003 	ldbu	r2,0(r3)
 d04a1d8:	1080020c 	andi	r2,r2,8
 d04a1dc:	103ffa1e 	bne	r2,zero,d04a1c8 <_strtol_r+0x48>
 d04a1e0:	00800b44 	movi	r2,45
 d04a1e4:	88805c26 	beq	r17,r2,d04a358 <_strtol_r+0x1d8>
 d04a1e8:	00800ac4 	movi	r2,43
 d04a1ec:	88805726 	beq	r17,r2,d04a34c <_strtol_r+0x1cc>
 d04a1f0:	0039883a 	mov	fp,zero
 d04a1f4:	3807003a 	cmpeq	r3,r7,zero
 d04a1f8:	1800431e 	bne	r3,zero,d04a308 <_strtol_r+0x188>
 d04a1fc:	00800404 	movi	r2,16
 d04a200:	38804126 	beq	r7,r2,d04a308 <_strtol_r+0x188>
 d04a204:	3829883a 	mov	r20,r7
 d04a208:	e02cc03a 	cmpne	r22,fp,zero
 d04a20c:	b0004b1e 	bne	r22,zero,d04a33c <_strtol_r+0x1bc>
 d04a210:	04a00034 	movhi	r18,32768
 d04a214:	94bfffc4 	addi	r18,r18,-1
 d04a218:	9009883a 	mov	r4,r18
 d04a21c:	a00b883a 	mov	r5,r20
 d04a220:	d9c00215 	stw	r7,8(sp)
 d04a224:	d00c7a80 	call	d00c7a8 <__umodsi3>
 d04a228:	9009883a 	mov	r4,r18
 d04a22c:	a00b883a 	mov	r5,r20
 d04a230:	102b883a 	mov	r21,r2
 d04a234:	d00c7a00 	call	d00c7a0 <__udivsi3>
 d04a238:	1011883a 	mov	r8,r2
 d04a23c:	9c45883a 	add	r2,r19,r17
 d04a240:	11000003 	ldbu	r4,0(r2)
 d04a244:	000b883a 	mov	r5,zero
 d04a248:	000d883a 	mov	r6,zero
 d04a24c:	20c0010c 	andi	r3,r4,4
 d04a250:	d9c00217 	ldw	r7,8(sp)
 d04a254:	18000e26 	beq	r3,zero,d04a290 <_strtol_r+0x110>
 d04a258:	88fff404 	addi	r3,r17,-48
 d04a25c:	19c0140e 	bge	r3,r7,d04a2b0 <_strtol_r+0x130>
 d04a260:	30003116 	blt	r6,zero,d04a328 <_strtol_r+0x1a8>
 d04a264:	41403036 	bltu	r8,r5,d04a328 <_strtol_r+0x1a8>
 d04a268:	2a002e26 	beq	r5,r8,d04a324 <_strtol_r+0x1a4>
 d04a26c:	2d05383a 	mul	r2,r5,r20
 d04a270:	01800044 	movi	r6,1
 d04a274:	10cb883a 	add	r5,r2,r3
 d04a278:	84400007 	ldb	r17,0(r16)
 d04a27c:	84000044 	addi	r16,r16,1
 d04a280:	9c45883a 	add	r2,r19,r17
 d04a284:	11000003 	ldbu	r4,0(r2)
 d04a288:	20c0010c 	andi	r3,r4,4
 d04a28c:	183ff21e 	bne	r3,zero,d04a258 <_strtol_r+0xd8>
 d04a290:	208000cc 	andi	r2,r4,3
 d04a294:	10000626 	beq	r2,zero,d04a2b0 <_strtol_r+0x130>
 d04a298:	2080004c 	andi	r2,r4,1
 d04a29c:	1005003a 	cmpeq	r2,r2,zero
 d04a2a0:	1000231e 	bne	r2,zero,d04a330 <_strtol_r+0x1b0>
 d04a2a4:	00800dc4 	movi	r2,55
 d04a2a8:	8887c83a 	sub	r3,r17,r2
 d04a2ac:	19ffec16 	blt	r3,r7,d04a260 <_strtol_r+0xe0>
 d04a2b0:	30002d16 	blt	r6,zero,d04a368 <_strtol_r+0x1e8>
 d04a2b4:	b000231e 	bne	r22,zero,d04a344 <_strtol_r+0x1c4>
 d04a2b8:	2807883a 	mov	r3,r5
 d04a2bc:	d8800117 	ldw	r2,4(sp)
 d04a2c0:	10000426 	beq	r2,zero,d04a2d4 <_strtol_r+0x154>
 d04a2c4:	30000126 	beq	r6,zero,d04a2cc <_strtol_r+0x14c>
 d04a2c8:	85ffffc4 	addi	r23,r16,-1
 d04a2cc:	d9000117 	ldw	r4,4(sp)
 d04a2d0:	25c00015 	stw	r23,0(r4)
 d04a2d4:	1805883a 	mov	r2,r3
 d04a2d8:	dfc00c17 	ldw	ra,48(sp)
 d04a2dc:	df000b17 	ldw	fp,44(sp)
 d04a2e0:	ddc00a17 	ldw	r23,40(sp)
 d04a2e4:	dd800917 	ldw	r22,36(sp)
 d04a2e8:	dd400817 	ldw	r21,32(sp)
 d04a2ec:	dd000717 	ldw	r20,28(sp)
 d04a2f0:	dcc00617 	ldw	r19,24(sp)
 d04a2f4:	dc800517 	ldw	r18,20(sp)
 d04a2f8:	dc400417 	ldw	r17,16(sp)
 d04a2fc:	dc000317 	ldw	r16,12(sp)
 d04a300:	dec00d04 	addi	sp,sp,52
 d04a304:	f800283a 	ret
 d04a308:	00800c04 	movi	r2,48
 d04a30c:	88801d26 	beq	r17,r2,d04a384 <_strtol_r+0x204>
 d04a310:	183fbc26 	beq	r3,zero,d04a204 <_strtol_r+0x84>
 d04a314:	00800c04 	movi	r2,48
 d04a318:	88802726 	beq	r17,r2,d04a3b8 <_strtol_r+0x238>
 d04a31c:	01c00284 	movi	r7,10
 d04a320:	003fb806 	br	d04a204 <_strtol_r+0x84>
 d04a324:	a8ffd10e 	bge	r21,r3,d04a26c <_strtol_r+0xec>
 d04a328:	01bfffc4 	movi	r6,-1
 d04a32c:	003fd206 	br	d04a278 <_strtol_r+0xf8>
 d04a330:	008015c4 	movi	r2,87
 d04a334:	8887c83a 	sub	r3,r17,r2
 d04a338:	003fdc06 	br	d04a2ac <_strtol_r+0x12c>
 d04a33c:	04a00034 	movhi	r18,32768
 d04a340:	003fb506 	br	d04a218 <_strtol_r+0x98>
 d04a344:	0147c83a 	sub	r3,zero,r5
 d04a348:	003fdc06 	br	d04a2bc <_strtol_r+0x13c>
 d04a34c:	84400007 	ldb	r17,0(r16)
 d04a350:	84000044 	addi	r16,r16,1
 d04a354:	003fa606 	br	d04a1f0 <_strtol_r+0x70>
 d04a358:	84400007 	ldb	r17,0(r16)
 d04a35c:	07000044 	movi	fp,1
 d04a360:	84000044 	addi	r16,r16,1
 d04a364:	003fa306 	br	d04a1f4 <_strtol_r+0x74>
 d04a368:	e005003a 	cmpeq	r2,fp,zero
 d04a36c:	10000f1e 	bne	r2,zero,d04a3ac <_strtol_r+0x22c>
 d04a370:	00e00034 	movhi	r3,32768
 d04a374:	d9000017 	ldw	r4,0(sp)
 d04a378:	00800884 	movi	r2,34
 d04a37c:	20800015 	stw	r2,0(r4)
 d04a380:	003fce06 	br	d04a2bc <_strtol_r+0x13c>
 d04a384:	81000007 	ldb	r4,0(r16)
 d04a388:	00801e04 	movi	r2,120
 d04a38c:	20800226 	beq	r4,r2,d04a398 <_strtol_r+0x218>
 d04a390:	00801604 	movi	r2,88
 d04a394:	20bfde1e 	bne	r4,r2,d04a310 <_strtol_r+0x190>
 d04a398:	84400047 	ldb	r17,1(r16)
 d04a39c:	01c00404 	movi	r7,16
 d04a3a0:	84000084 	addi	r16,r16,2
 d04a3a4:	3829883a 	mov	r20,r7
 d04a3a8:	003f9706 	br	d04a208 <_strtol_r+0x88>
 d04a3ac:	00e00034 	movhi	r3,32768
 d04a3b0:	18ffffc4 	addi	r3,r3,-1
 d04a3b4:	003fef06 	br	d04a374 <_strtol_r+0x1f4>
 d04a3b8:	01c00204 	movi	r7,8
 d04a3bc:	3829883a 	mov	r20,r7
 d04a3c0:	003f9106 	br	d04a208 <_strtol_r+0x88>

0d04a3c4 <strtol>:
 d04a3c4:	00834174 	movhi	r2,3333
 d04a3c8:	108a2204 	addi	r2,r2,10376
 d04a3cc:	2013883a 	mov	r9,r4
 d04a3d0:	11000017 	ldw	r4,0(r2)
 d04a3d4:	2805883a 	mov	r2,r5
 d04a3d8:	300f883a 	mov	r7,r6
 d04a3dc:	480b883a 	mov	r5,r9
 d04a3e0:	100d883a 	mov	r6,r2
 d04a3e4:	d04a1801 	jmpi	d04a180 <_strtol_r>

0d04a3e8 <_vprintf_r>:
 d04a3e8:	2807883a 	mov	r3,r5
 d04a3ec:	21400217 	ldw	r5,8(r4)
 d04a3f0:	300f883a 	mov	r7,r6
 d04a3f4:	180d883a 	mov	r6,r3
 d04a3f8:	d0036301 	jmpi	d003630 <___vfprintf_internal_r>

0d04a3fc <vprintf>:
 d04a3fc:	00834174 	movhi	r2,3333
 d04a400:	108a2204 	addi	r2,r2,10376
 d04a404:	12000017 	ldw	r8,0(r2)
 d04a408:	280f883a 	mov	r7,r5
 d04a40c:	200d883a 	mov	r6,r4
 d04a410:	41400217 	ldw	r5,8(r8)
 d04a414:	4009883a 	mov	r4,r8
 d04a418:	d0036301 	jmpi	d003630 <___vfprintf_internal_r>

0d04a41c <_vsprintf_r>:
 d04a41c:	deffe804 	addi	sp,sp,-96
 d04a420:	00808204 	movi	r2,520
 d04a424:	2811883a 	mov	r8,r5
 d04a428:	02600034 	movhi	r9,32768
 d04a42c:	4a7fffc4 	addi	r9,r9,-1
 d04a430:	d880030d 	sth	r2,12(sp)
 d04a434:	d80b883a 	mov	r5,sp
 d04a438:	00bfffc4 	movi	r2,-1
 d04a43c:	dfc01715 	stw	ra,92(sp)
 d04a440:	da000415 	stw	r8,16(sp)
 d04a444:	da400515 	stw	r9,20(sp)
 d04a448:	d880038d 	sth	r2,14(sp)
 d04a44c:	da000015 	stw	r8,0(sp)
 d04a450:	da400215 	stw	r9,8(sp)
 d04a454:	d0036300 	call	d003630 <___vfprintf_internal_r>
 d04a458:	d8c00017 	ldw	r3,0(sp)
 d04a45c:	18000005 	stb	zero,0(r3)
 d04a460:	dfc01717 	ldw	ra,92(sp)
 d04a464:	dec01804 	addi	sp,sp,96
 d04a468:	f800283a 	ret

0d04a46c <vsprintf>:
 d04a46c:	00834174 	movhi	r2,3333
 d04a470:	108a2204 	addi	r2,r2,10376
 d04a474:	2013883a 	mov	r9,r4
 d04a478:	11000017 	ldw	r4,0(r2)
 d04a47c:	2805883a 	mov	r2,r5
 d04a480:	300f883a 	mov	r7,r6
 d04a484:	480b883a 	mov	r5,r9
 d04a488:	100d883a 	mov	r6,r2
 d04a48c:	d04a41c1 	jmpi	d04a41c <_vsprintf_r>

0d04a490 <__register_exitproc>:
 d04a490:	defffa04 	addi	sp,sp,-24
 d04a494:	00834174 	movhi	r2,3333
 d04a498:	108a2304 	addi	r2,r2,10380
 d04a49c:	dc000015 	stw	r16,0(sp)
 d04a4a0:	14000017 	ldw	r16,0(r2)
 d04a4a4:	dd000415 	stw	r20,16(sp)
 d04a4a8:	2829883a 	mov	r20,r5
 d04a4ac:	81405217 	ldw	r5,328(r16)
 d04a4b0:	dcc00315 	stw	r19,12(sp)
 d04a4b4:	dc800215 	stw	r18,8(sp)
 d04a4b8:	dc400115 	stw	r17,4(sp)
 d04a4bc:	dfc00515 	stw	ra,20(sp)
 d04a4c0:	2023883a 	mov	r17,r4
 d04a4c4:	3027883a 	mov	r19,r6
 d04a4c8:	3825883a 	mov	r18,r7
 d04a4cc:	28002526 	beq	r5,zero,d04a564 <__register_exitproc+0xd4>
 d04a4d0:	29000117 	ldw	r4,4(r5)
 d04a4d4:	008007c4 	movi	r2,31
 d04a4d8:	11002716 	blt	r2,r4,d04a578 <__register_exitproc+0xe8>
 d04a4dc:	8800101e 	bne	r17,zero,d04a520 <__register_exitproc+0x90>
 d04a4e0:	2105883a 	add	r2,r4,r4
 d04a4e4:	1085883a 	add	r2,r2,r2
 d04a4e8:	20c00044 	addi	r3,r4,1
 d04a4ec:	1145883a 	add	r2,r2,r5
 d04a4f0:	0009883a 	mov	r4,zero
 d04a4f4:	15000215 	stw	r20,8(r2)
 d04a4f8:	28c00115 	stw	r3,4(r5)
 d04a4fc:	2005883a 	mov	r2,r4
 d04a500:	dfc00517 	ldw	ra,20(sp)
 d04a504:	dd000417 	ldw	r20,16(sp)
 d04a508:	dcc00317 	ldw	r19,12(sp)
 d04a50c:	dc800217 	ldw	r18,8(sp)
 d04a510:	dc400117 	ldw	r17,4(sp)
 d04a514:	dc000017 	ldw	r16,0(sp)
 d04a518:	dec00604 	addi	sp,sp,24
 d04a51c:	f800283a 	ret
 d04a520:	29802204 	addi	r6,r5,136
 d04a524:	00800044 	movi	r2,1
 d04a528:	110e983a 	sll	r7,r2,r4
 d04a52c:	30c04017 	ldw	r3,256(r6)
 d04a530:	2105883a 	add	r2,r4,r4
 d04a534:	1085883a 	add	r2,r2,r2
 d04a538:	1185883a 	add	r2,r2,r6
 d04a53c:	19c6b03a 	or	r3,r3,r7
 d04a540:	14802015 	stw	r18,128(r2)
 d04a544:	14c00015 	stw	r19,0(r2)
 d04a548:	00800084 	movi	r2,2
 d04a54c:	30c04015 	stw	r3,256(r6)
 d04a550:	88bfe31e 	bne	r17,r2,d04a4e0 <__register_exitproc+0x50>
 d04a554:	30804117 	ldw	r2,260(r6)
 d04a558:	11c4b03a 	or	r2,r2,r7
 d04a55c:	30804115 	stw	r2,260(r6)
 d04a560:	003fdf06 	br	d04a4e0 <__register_exitproc+0x50>
 d04a564:	008341b4 	movhi	r2,3334
 d04a568:	10b52304 	addi	r2,r2,-11124
 d04a56c:	100b883a 	mov	r5,r2
 d04a570:	80805215 	stw	r2,328(r16)
 d04a574:	003fd606 	br	d04a4d0 <__register_exitproc+0x40>
 d04a578:	00834174 	movhi	r2,3333
 d04a57c:	10a7b004 	addi	r2,r2,-24896
 d04a580:	1000021e 	bne	r2,zero,d04a58c <__register_exitproc+0xfc>
 d04a584:	013fffc4 	movi	r4,-1
 d04a588:	003fdc06 	br	d04a4fc <__register_exitproc+0x6c>
 d04a58c:	01006404 	movi	r4,400
 d04a590:	103ee83a 	callr	r2
 d04a594:	1007883a 	mov	r3,r2
 d04a598:	103ffa26 	beq	r2,zero,d04a584 <__register_exitproc+0xf4>
 d04a59c:	80805217 	ldw	r2,328(r16)
 d04a5a0:	180b883a 	mov	r5,r3
 d04a5a4:	18000115 	stw	zero,4(r3)
 d04a5a8:	18800015 	stw	r2,0(r3)
 d04a5ac:	80c05215 	stw	r3,328(r16)
 d04a5b0:	18006215 	stw	zero,392(r3)
 d04a5b4:	18006315 	stw	zero,396(r3)
 d04a5b8:	0009883a 	mov	r4,zero
 d04a5bc:	883fc826 	beq	r17,zero,d04a4e0 <__register_exitproc+0x50>
 d04a5c0:	003fd706 	br	d04a520 <__register_exitproc+0x90>

0d04a5c4 <register_fini>:
 d04a5c4:	f800283a 	ret

0d04a5c8 <__call_exitprocs>:
 d04a5c8:	00834174 	movhi	r2,3333
 d04a5cc:	108a2304 	addi	r2,r2,10380
 d04a5d0:	10800017 	ldw	r2,0(r2)
 d04a5d4:	defff304 	addi	sp,sp,-52
 d04a5d8:	df000b15 	stw	fp,44(sp)
 d04a5dc:	d8800115 	stw	r2,4(sp)
 d04a5e0:	00834174 	movhi	r2,3333
 d04a5e4:	10a7ab04 	addi	r2,r2,-24916
 d04a5e8:	1005003a 	cmpeq	r2,r2,zero
 d04a5ec:	d8800215 	stw	r2,8(sp)
 d04a5f0:	d8800117 	ldw	r2,4(sp)
 d04a5f4:	dd400815 	stw	r21,32(sp)
 d04a5f8:	dd000715 	stw	r20,28(sp)
 d04a5fc:	10805204 	addi	r2,r2,328
 d04a600:	dfc00c15 	stw	ra,48(sp)
 d04a604:	ddc00a15 	stw	r23,40(sp)
 d04a608:	dd800915 	stw	r22,36(sp)
 d04a60c:	dcc00615 	stw	r19,24(sp)
 d04a610:	dc800515 	stw	r18,20(sp)
 d04a614:	dc400415 	stw	r17,16(sp)
 d04a618:	dc000315 	stw	r16,12(sp)
 d04a61c:	282b883a 	mov	r21,r5
 d04a620:	2039883a 	mov	fp,r4
 d04a624:	d8800015 	stw	r2,0(sp)
 d04a628:	2829003a 	cmpeq	r20,r5,zero
 d04a62c:	d8800117 	ldw	r2,4(sp)
 d04a630:	14405217 	ldw	r17,328(r2)
 d04a634:	88001026 	beq	r17,zero,d04a678 <__call_exitprocs+0xb0>
 d04a638:	ddc00017 	ldw	r23,0(sp)
 d04a63c:	88800117 	ldw	r2,4(r17)
 d04a640:	8c802204 	addi	r18,r17,136
 d04a644:	143fffc4 	addi	r16,r2,-1
 d04a648:	80000916 	blt	r16,zero,d04a670 <__call_exitprocs+0xa8>
 d04a64c:	05bfffc4 	movi	r22,-1
 d04a650:	a000151e 	bne	r20,zero,d04a6a8 <__call_exitprocs+0xe0>
 d04a654:	8409883a 	add	r4,r16,r16
 d04a658:	2105883a 	add	r2,r4,r4
 d04a65c:	1485883a 	add	r2,r2,r18
 d04a660:	10c02017 	ldw	r3,128(r2)
 d04a664:	a8c01126 	beq	r21,r3,d04a6ac <__call_exitprocs+0xe4>
 d04a668:	843fffc4 	addi	r16,r16,-1
 d04a66c:	85bff81e 	bne	r16,r22,d04a650 <__call_exitprocs+0x88>
 d04a670:	d8800217 	ldw	r2,8(sp)
 d04a674:	10003126 	beq	r2,zero,d04a73c <__call_exitprocs+0x174>
 d04a678:	dfc00c17 	ldw	ra,48(sp)
 d04a67c:	df000b17 	ldw	fp,44(sp)
 d04a680:	ddc00a17 	ldw	r23,40(sp)
 d04a684:	dd800917 	ldw	r22,36(sp)
 d04a688:	dd400817 	ldw	r21,32(sp)
 d04a68c:	dd000717 	ldw	r20,28(sp)
 d04a690:	dcc00617 	ldw	r19,24(sp)
 d04a694:	dc800517 	ldw	r18,20(sp)
 d04a698:	dc400417 	ldw	r17,16(sp)
 d04a69c:	dc000317 	ldw	r16,12(sp)
 d04a6a0:	dec00d04 	addi	sp,sp,52
 d04a6a4:	f800283a 	ret
 d04a6a8:	8409883a 	add	r4,r16,r16
 d04a6ac:	88c00117 	ldw	r3,4(r17)
 d04a6b0:	2105883a 	add	r2,r4,r4
 d04a6b4:	1445883a 	add	r2,r2,r17
 d04a6b8:	18ffffc4 	addi	r3,r3,-1
 d04a6bc:	11800217 	ldw	r6,8(r2)
 d04a6c0:	1c001526 	beq	r3,r16,d04a718 <__call_exitprocs+0x150>
 d04a6c4:	10000215 	stw	zero,8(r2)
 d04a6c8:	303fe726 	beq	r6,zero,d04a668 <__call_exitprocs+0xa0>
 d04a6cc:	00c00044 	movi	r3,1
 d04a6d0:	1c06983a 	sll	r3,r3,r16
 d04a6d4:	90804017 	ldw	r2,256(r18)
 d04a6d8:	8cc00117 	ldw	r19,4(r17)
 d04a6dc:	1884703a 	and	r2,r3,r2
 d04a6e0:	10001426 	beq	r2,zero,d04a734 <__call_exitprocs+0x16c>
 d04a6e4:	90804117 	ldw	r2,260(r18)
 d04a6e8:	1884703a 	and	r2,r3,r2
 d04a6ec:	10000c1e 	bne	r2,zero,d04a720 <__call_exitprocs+0x158>
 d04a6f0:	2105883a 	add	r2,r4,r4
 d04a6f4:	1485883a 	add	r2,r2,r18
 d04a6f8:	11400017 	ldw	r5,0(r2)
 d04a6fc:	e009883a 	mov	r4,fp
 d04a700:	303ee83a 	callr	r6
 d04a704:	88800117 	ldw	r2,4(r17)
 d04a708:	98bfc81e 	bne	r19,r2,d04a62c <__call_exitprocs+0x64>
 d04a70c:	b8800017 	ldw	r2,0(r23)
 d04a710:	147fd526 	beq	r2,r17,d04a668 <__call_exitprocs+0xa0>
 d04a714:	003fc506 	br	d04a62c <__call_exitprocs+0x64>
 d04a718:	8c000115 	stw	r16,4(r17)
 d04a71c:	003fea06 	br	d04a6c8 <__call_exitprocs+0x100>
 d04a720:	2105883a 	add	r2,r4,r4
 d04a724:	1485883a 	add	r2,r2,r18
 d04a728:	11000017 	ldw	r4,0(r2)
 d04a72c:	303ee83a 	callr	r6
 d04a730:	003ff406 	br	d04a704 <__call_exitprocs+0x13c>
 d04a734:	303ee83a 	callr	r6
 d04a738:	003ff206 	br	d04a704 <__call_exitprocs+0x13c>
 d04a73c:	88800117 	ldw	r2,4(r17)
 d04a740:	1000081e 	bne	r2,zero,d04a764 <__call_exitprocs+0x19c>
 d04a744:	89000017 	ldw	r4,0(r17)
 d04a748:	20000726 	beq	r4,zero,d04a768 <__call_exitprocs+0x1a0>
 d04a74c:	b9000015 	stw	r4,0(r23)
 d04a750:	8809883a 	mov	r4,r17
 d04a754:	d049eac0 	call	d049eac <free>
 d04a758:	bc400017 	ldw	r17,0(r23)
 d04a75c:	883fb71e 	bne	r17,zero,d04a63c <__call_exitprocs+0x74>
 d04a760:	003fc506 	br	d04a678 <__call_exitprocs+0xb0>
 d04a764:	89000017 	ldw	r4,0(r17)
 d04a768:	882f883a 	mov	r23,r17
 d04a76c:	2023883a 	mov	r17,r4
 d04a770:	883fb21e 	bne	r17,zero,d04a63c <__call_exitprocs+0x74>
 d04a774:	003fc006 	br	d04a678 <__call_exitprocs+0xb0>

0d04a778 <alt_sim_halt>:

/*
 * Routine called on exit.
 */
static ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
 d04a778:	defffd04 	addi	sp,sp,-12
 d04a77c:	df000215 	stw	fp,8(sp)
 d04a780:	df000204 	addi	fp,sp,8
 d04a784:	e13fff15 	stw	r4,-4(fp)
  int r2 = exit_code;
 d04a788:	e0bfff17 	ldw	r2,-4(fp)
 d04a78c:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 d04a790:	e0bffe17 	ldw	r2,-8(fp)
 d04a794:	1005003a 	cmpeq	r2,r2,zero
 d04a798:	1000021e 	bne	r2,zero,d04a7a4 <alt_sim_halt+0x2c>
    ALT_SIM_FAIL();
 d04a79c:	002af070 	cmpltui	zero,zero,43969
 d04a7a0:	00000106 	br	d04a7a8 <alt_sim_halt+0x30>
  } else {
    ALT_SIM_PASS();
 d04a7a4:	002af0b0 	cmpltui	zero,zero,43970
  }
#endif /* DEBUG_STUB */
}
 d04a7a8:	e037883a 	mov	sp,fp
 d04a7ac:	df000017 	ldw	fp,0(sp)
 d04a7b0:	dec00104 	addi	sp,sp,4
 d04a7b4:	f800283a 	ret

0d04a7b8 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 d04a7b8:	defffd04 	addi	sp,sp,-12
 d04a7bc:	dfc00215 	stw	ra,8(sp)
 d04a7c0:	df000115 	stw	fp,4(sp)
 d04a7c4:	df000104 	addi	fp,sp,4
 d04a7c8:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 d04a7cc:	00834174 	movhi	r2,3333
 d04a7d0:	108a8c44 	addi	r2,r2,10801
 d04a7d4:	10000005 	stb	zero,0(r2)

  /* Provide notification to the simulator that we've stopped */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_SIM_HALT().\r\n");
  ALT_SIM_HALT(exit_code);
 d04a7d8:	e13fff17 	ldw	r4,-4(fp)
 d04a7dc:	d04a7780 	call	d04a778 <alt_sim_halt>

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 d04a7e0:	003fff06 	br	d04a7e0 <_exit+0x28>
 d04a7e4:	00000010 	cmplti	zero,zero,0
 d04a7e8:	00000000 	call	0 <OSTCBStkPtr_OFFSET>
 d04a7ec:	00527a01 	jmpi	527a0 <OSCtxSw_SWITCH_PC+0x52760>
 d04a7f0:	011f7c01 	jmpi	11f7c0 <OSCtxSw_SWITCH_PC+0x11f780>
 d04a7f4:	001b0c0b 	ldhu	zero,27696(zero)
 d04a7f8:	00000028 	cmpgeui	zero,zero,0
 d04a7fc:	00000018 	cmpnei	zero,zero,0
 d04a800:	0d00a9ac 	andhi	r20,at,678
 d04a804:	000005dc 	xori	zero,zero,23
 d04a808:	400e4400 	call	400e440 <OSCtxSw_SWITCH_PC+0x400e400>
 d04a80c:	92099170 	cmpltui	r8,r18,9797
 d04a810:	95079308 	cmpgei	r20,r18,7756
 d04a814:	97049605 	stb	fp,4696(r18)
 d04a818:	90019f03 	ldbu	zero,1660(r18)
 d04a81c:	9c06940a 	0x9c06940a
 d04a820:	00000002 	0x2
 d04a824:	00000028 	cmpgeui	zero,zero,0
 d04a828:	00000044 	movi	zero,1
 d04a82c:	0d00af88 	cmpgei	r20,at,702
 d04a830:	000005b0 	cmpltui	zero,zero,22
 d04a834:	3c0e4400 	call	3c0e440 <OSCtxSw_SWITCH_PC+0x3c0e400>
 d04a838:	92099168 	cmpgeui	r8,r18,9797
 d04a83c:	95079308 	cmpgei	r20,r18,7756
 d04a840:	9c039705 	stb	r16,3676(r19)
 d04a844:	90019f02 	0x90019f02
 d04a848:	9606940a 	0x9606940a
 d04a84c:	00000004 	movi	zero,0
 d04a850:	0d04a5c4 	addi	r20,at,4759
